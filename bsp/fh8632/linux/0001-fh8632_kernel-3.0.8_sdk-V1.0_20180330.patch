diff -uraN linux-3.0.8/arch/arm/boot/compressed/misc.c linux-3.0.8-fh8632-V1.0_20180330/arch/arm/boot/compressed/misc.c
--- linux-3.0.8/arch/arm/boot/compressed/misc.c	2021-07-14 21:51:58.555121096 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/boot/compressed/misc.c	2021-07-13 23:40:30.606336525 +0300
@@ -169,6 +169,23 @@
 
 extern int do_decompress(u8 *input, int len, u8 *output, void (*error)(char *x));
 
+#ifdef CONFIG_TEST_BOOT_TIME
+#define SET_TIMING_GPIO(port, level)					\
+	do {								\
+		unsigned char *p_gpio = (unsigned char *) 0xf0300000;	\
+		int data = *(p_gpio + 0x0004);				\
+		data |= 1 << (port);					\
+		*(p_gpio + 0x0004) = data;				\
+		data = *(p_gpio);					\
+		if ((level) == 0)					\
+			data &= ~(1 << (port));				\
+		else							\
+			data |= 1 << (port);				\
+		*(p_gpio) = data;					\
+	} while (0)
+#else
+#define SET_TIMING_GPIO(port, level)
+#endif
 
 void
 decompress_kernel(unsigned long output_start, unsigned long free_mem_ptr_p,
@@ -182,6 +199,8 @@
 	free_mem_end_ptr	= free_mem_ptr_end_p;
 	__machine_arch_type	= arch_id;
 
+	SET_TIMING_GPIO(4, 1);
+
 	arch_decomp_setup();
 
 	putstr("Uncompressing Linux...");
diff -uraN linux-3.0.8/arch/arm/configs/fh8632_defconfig linux-3.0.8-fh8632-V1.0_20180330/arch/arm/configs/fh8632_defconfig
--- linux-3.0.8/arch/arm/configs/fh8632_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/configs/fh8632_defconfig	2021-07-13 23:40:30.422335300 +0300
@@ -0,0 +1,1841 @@
+#
+# Automatically generated make config: don't edit
+# Linux/arm 3.0.8 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_SCHED_CLOCK=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+CONFIG_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_SHOW=y
+# CONFIG_SPARSE_IRQ is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TINY_RCU=y
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_TREE_RCU_TRACE is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=16
+# CONFIG_CGROUPS is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="usr/rootfs.cpio.gz"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+CONFIG_INITRAMFS_COMPRESSION_NONE=y
+# CONFIG_INITRAMFS_COMPRESSION_GZIP is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_SLUB_DEBUG is not set
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+
+#
+# GCOV-based kernel profiling
+#
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+# CONFIG_LBDAF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+CONFIG_INLINE_SPIN_UNLOCK=y
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+CONFIG_INLINE_READ_UNLOCK=y
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+CONFIG_INLINE_WRITE_UNLOCK=y
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS4 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_TCC_926 is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+CONFIG_ARCH_FULLHAN=y
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+CONFIG_CPU_FH8833=y
+
+#
+# FullHan Implementations
+#
+
+#
+# FullHan Core Type
+#
+# CONFIG_ARCH_FH8810 is not set
+CONFIG_ARCH_FH8833=y
+# CONFIG_ARCH_FH8830 is not set
+# CONFIG_ARCH_WUDANG is not set
+
+#
+# FullHan Board Type
+#
+CONFIG_USE_PTS_AS_CLOCKSOURCE=y
+# CONFIG_FH_SIMPLE_TIMER is not set
+CONFIG_MACH_FH8833=y
+# CONFIG_MACH_FH_NAND is not set
+# CONFIG_JLINK_DEBUG is not set
+
+#
+# System MMU
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_V6=y
+CONFIG_CPU_32v6=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_PABRT_V6=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_USE_DOMAINS=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_CPU_HAS_PMU=y
+CONFIG_ARM_ERRATA_411920=y
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=100
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+# CONFIG_HIGHMEM is not set
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_COMPACTION is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_NEED_PER_CPU_KM=y
+# CONFIG_CLEANCACHE is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+
+#
+# Boot options
+#
+# CONFIG_USE_OF is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_PM_SLEEP=y
+# CONFIG_PM_RUNTIME is not set
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=m
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=m
+CONFIG_INET6_XFRM_MODE_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_BEET=m
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=m
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+# CONFIG_NF_CONNTRACK is not set
+# CONFIG_NETFILTER_XTABLES is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV4 is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# IPv6: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV6 is not set
+# CONFIG_IP6_NF_QUEUE is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+
+#
+# Classification
+#
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_EMATCH is not set
+# CONFIG_NET_CLS_ACT is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_PRIV=y
+CONFIG_CFG80211=y
+CONFIG_NL80211_TESTMODE=y
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_WEXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+CONFIG_LIB80211=y
+# CONFIG_LIB80211_DEBUG is not set
+CONFIG_MAC80211=y
+CONFIG_MAC80211_HAS_RC=y
+# CONFIG_MAC80211_RC_PID is not set
+CONFIG_MAC80211_RC_MINSTREL=y
+CONFIG_MAC80211_RC_MINSTREL_HT=y
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel_ht"
+# CONFIG_MAC80211_MESH is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+# CONFIG_RFKILL_INPUT is not set
+# CONFIG_RFKILL_GPIO is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/mdev"
+CONFIG_DEVTMPFS=y
+# CONFIG_DEVTMPFS_MOUNT is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+CONFIG_MTD_M25P80=y
+CONFIG_M25PXX_USE_FAST_READ=y
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_INTEL_MID_PTI is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_FH_I2S is not set
+# CONFIG_FH_DW_I2S is not set
+# CONFIG_FH_ACW is not set
+# CONFIG_FH_PWM is not set
+CONFIG_FH_PWM_NUM=8
+CONFIG_FH_PINCTRL=y
+CONFIG_FH_SADC=y
+CONFIG_FH_FIRMWARE_LOADER=m
+CONFIG_FH_EFUSE=y
+CONFIG_FH_CLK_MISC=y
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+# CONFIG_BMP085 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+CONFIG_EEPROM_AT24=m
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IWMC3200TOP is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+# CONFIG_BLK_DEV_SD is not set
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=m
+# CONFIG_VETH is not set
+CONFIG_MII=y
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+CONFIG_FH_GMAC=y
+CONFIG_FH_GMAC_DA=y
+# CONFIG_ENC28J60 is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851 is not set
+# CONFIG_KS8851_MLL is not set
+# CONFIG_FTMAC100 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+CONFIG_WLAN=y
+# CONFIG_LIBERTAS_THINFIRM is not set
+# CONFIG_AT76C50X_USB is not set
+# CONFIG_RTL8187 is not set
+CONFIG_BCMDHD=m
+CONFIG_BCMDHD_FW_PATH="/bcmdhd/fw_bcmdhd.bin"
+CONFIG_BCMDHD_NVRAM_PATH="/bcmdhd/nvram_ap6181.txt"
+CONFIG_BCMDHD_CONFIG_PATH="/bcmdhd/config.txt"
+CONFIG_BCMDHD_OOB=y
+# CONFIG_BCMDHD_SDIO_IRQ is not set
+# CONFIG_RTL8189FS_SD is not set
+# CONFIG_MRVL8801 is not set
+# CONFIG_MAC80211_HWSIM is not set
+# CONFIG_ATH_COMMON is not set
+# CONFIG_B43 is not set
+# CONFIG_B43LEGACY is not set
+# CONFIG_HOSTAP is not set
+# CONFIG_IWM is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_P54_COMMON is not set
+# CONFIG_RT2X00 is not set
+# CONFIG_RTL8192SE is not set
+# CONFIG_RTL8192CU is not set
+# CONFIG_WL1251 is not set
+# CONFIG_WL12XX_MENU is not set
+# CONFIG_ZD1211RW is not set
+# CONFIG_MWIFIEX is not set
+# CONFIG_RTL8189ES is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_WAN is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_PPP=m
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_PPP_DEFLATE=m
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPP_MPPE is not set
+# CONFIG_PPPOE is not set
+# CONFIG_SLIP is not set
+CONFIG_SLHC=m
+CONFIG_NETCONSOLE=y
+CONFIG_NETPOLL=y
+CONFIG_NETPOLL_TRAP=y
+CONFIG_NET_POLL_CONTROLLER=y
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+# CONFIG_VT_CONSOLE is not set
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+CONFIG_SERIAL_FH=y
+CONFIG_SERIAL_FH_CONSOLE=y
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_RAMOOPS is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
+# CONFIG_I2C_HELPER_AUTO is not set
+# CONFIG_I2C_SMBUS is not set
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+CONFIG_I2C_FH_INTERRUPT=y
+# CONFIG_I2C_DESIGNWARE is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+CONFIG_SPI_FH=y
+CONFIG_SPI_FH_SLAVE=y
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_SPIDEV=y
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_BASIC_MMIO is not set
+# CONFIG_GPIO_IT8761E is not set
+CONFIG_GPIO_FH=y
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_ADS7871 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_THERMAL is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+CONFIG_FH_WATCHDOG=y
+
+#
+# USB-based Watchdog Cards
+#
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+CONFIG_MFD_SUPPORT=y
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_SOUND is not set
+# CONFIG_HID_SUPPORT is not set
+
+#
+# Miscellaneous USB options
+#
+
+#
+# USB Host Controller Drivers
+#
+
+#
+# USB Device Class drivers
+#
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+
+#
+# USB Imaging devices
+#
+
+#
+# USB port drivers
+#
+
+#
+# USB Miscellaneous drivers
+#
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_USB_SUPPORT is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_CLKGATE is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MMC_DW is not set
+CONFIG_MMC_FH=y
+CONFIG_MMC_FH_IDMAC=y
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+# CONFIG_LEDS_CLASS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+# CONFIG_NFC_DEVICES is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_DRV_FH=y
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+# CONFIG_DW_DMAC is not set
+CONFIG_FH_DMAC=y
+CONFIG_FH_DMAC_MISC=y
+# CONFIG_TIMB_DMA is not set
+CONFIG_DMA_ENGINE=y
+
+#
+# DMA Clients
+#
+# CONFIG_NET_DMA is not set
+# CONFIG_ASYNC_TX_DMA is not set
+# CONFIG_DMATEST is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_PWM=y
+CONFIG_PWM_FULLHAN=y
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_YAFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_LOGFS is not set
+CONFIG_CRAMFS=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+CONFIG_NFS_V4=y
+# CONFIG_NFS_V4_1 is not set
+# CONFIG_ROOT_NFS is not set
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+# CONFIG_NFS_USE_NEW_IDMAPPER is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=m
+
+#
+# Kernel hacking
+#
+# CONFIG_TEST_BOOT_TIME is not set
+CONFIG_PRINTK_TIME=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_MEMORY_INIT is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+# CONFIG_FTRACE_SYSCALLS is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_ARM_UNWIND is not set
+# CONFIG_DEBUG_USER is not set
+# CONFIG_OC_ETM is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+CONFIG_CRYPTO_SEQIV=y
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_USER_API=y
+# CONFIG_CRYPTO_USER_API_HASH is not set
+CONFIG_CRYPTO_USER_API_SKCIPHER=y
+CONFIG_CRYPTO_HW=y
+CONFIG_FH_AES=y
+# CONFIG_FH_AES_SELF_TEST is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=m
+# CONFIG_CRC16 is not set
+CONFIG_CRC_T10DIF=m
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
+CONFIG_AVERAGE=y
diff -uraN linux-3.0.8/arch/arm/include/asm/setup.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/include/asm/setup.h
--- linux-3.0.8/arch/arm/include/asm/setup.h	2021-07-14 21:51:58.627121304 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/include/asm/setup.h	2021-07-13 23:40:31.010339215 +0300
@@ -143,6 +143,12 @@
 	__u32 fmemclk;
 };
 
+#define ATAG_PHYMODE 0x41000601
+
+struct tag_phymode {
+    u32 phymode;
+};
+
 struct tag {
 	struct tag_header hdr;
 	union {
@@ -165,6 +171,11 @@
 		 * DC21285 specific
 		 */
 		struct tag_memclk	memclk;
+
+		/*
+		 * Fullhan specific
+		 */
+		struct tag_phymode  phymode;
 	} u;
 };
 
diff -uraN linux-3.0.8/arch/arm/Kconfig linux-3.0.8-fh8632-V1.0_20180330/arch/arm/Kconfig
--- linux-3.0.8/arch/arm/Kconfig	2021-07-14 21:51:58.551121084 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/Kconfig	2021-07-13 23:40:30.762337564 +0300
@@ -858,6 +858,20 @@
 	help
 	  Support for TI's OMAP platform (OMAP1/2/3/4).
 
+config ARCH_FULLHAN
+	bool "FullHan"
+	select GENERIC_CLOCKEVENTS
+#	select GENERIC_TIME
+	select HAVE_SCHED_CLOCK
+	select ARCH_REQUIRE_GPIOLIB
+#	select ZONE_DMA
+	select CLKDEV_LOOKUP
+	select GENERIC_ALLOCATOR
+#	select GENERIC_IRQ_CHIP
+	select HAVE_SYSCALL_TRACEPOINTS
+	help
+	  Support for FullHan's FH platform.
+
 config PLAT_SPEAR
 	bool "ST SPEAr"
 	select ARM_AMBA
@@ -900,6 +914,8 @@
 
 source "arch/arm/mach-ep93xx/Kconfig"
 
+source "arch/arm/mach-fh/Kconfig"
+
 source "arch/arm/mach-footbridge/Kconfig"
 
 source "arch/arm/mach-gemini/Kconfig"
@@ -1577,7 +1593,8 @@
 		   ARCH_OMAP || ARCH_P720T || ARCH_PXA_IDP || \
 		   ARCH_SA1100 || ARCH_SHARK || ARCH_VERSATILE || \
 		   ARCH_AT91 || ARCH_DAVINCI || \
-		   ARCH_KS8695 || MACH_RD88F5182 || ARCH_REALVIEW
+		   ARCH_KS8695 || MACH_RD88F5182 || ARCH_REALVIEW || \
+		   ARCH_FULLHAN
 	help
 	  If you say Y here, the LEDs on your machine will be used
 	  to provide useful information about your current system status.
diff -uraN linux-3.0.8/arch/arm/kernel/head.S linux-3.0.8-fh8632-V1.0_20180330/arch/arm/kernel/head.S
--- linux-3.0.8/arch/arm/kernel/head.S	2021-07-14 21:51:58.639121338 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/kernel/head.S	2021-07-13 23:40:30.354334847 +0300
@@ -226,6 +226,7 @@
 	 * This allows debug messages to be output
 	 * via a serial console before paging_init.
 	 */
+#ifndef CONFIG_JLINK_DEBUG
 	addruart r7, r3
 
 	mov	r3, r3, lsr #20
@@ -243,6 +244,7 @@
 	add	r3, r3, #1 << 20
 	teq	r0, r6
 	bne	1b
+#endif
 
 #else /* CONFIG_DEBUG_ICEDCC */
 	/* we don't need any serial debugging mappings for ICEDCC */
@@ -362,6 +364,13 @@
 #ifdef CONFIG_CPU_ICACHE_DISABLE
 	bic	r0, r0, #CR_I
 #endif
+	/*
+	* add by fullhan
+	*/
+#ifdef CONFIG_JLINK_DEBUG
+	mov r4, #0x10000000
+#endif
+
 	mov	r5, #(domain_val(DOMAIN_USER, DOMAIN_MANAGER) | \
 		      domain_val(DOMAIN_KERNEL, DOMAIN_MANAGER) | \
 		      domain_val(DOMAIN_TABLE, DOMAIN_MANAGER) | \
diff -uraN linux-3.0.8/arch/arm/mach-fh/board-fh8833.c linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/board-fh8833.c
--- linux-3.0.8/arch/arm/mach-fh/board-fh8833.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/board-fh8833.c	2021-07-13 23:40:30.646336791 +0300
@@ -0,0 +1,1100 @@
+/*
+ * Fullhan FH8810 board support
+ *
+ * Copyright (C) 2014 Fullhan Microelectronics Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/mmc/dw_mmc.h>
+#include <linux/clk.h>
+#include <linux/i2c/at24.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/phy.h>
+#include <linux/dma-mapping.h>
+#include <linux/spi/eeprom.h>
+#include <linux/delay.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/pmu.h>
+
+#include <mach/system.h>
+#include <mach/chip.h>
+#include <mach/iomux.h>
+#include <mach/irqs.h>
+#include <mach/pmu.h>
+#include <mach/fh_dmac.h>
+#include <mach/fh_gmac.h>
+#include <mach/gpio.h>
+#include <mach/spi.h>
+#include <mach/clock.h>
+#include <mach/rtc.h>
+#include <mach/pinctrl.h>
+#include <mach/fh_wdt.h>
+#include <mach/fhmci.h>
+#include <mach/board_config.h>
+
+
+static struct map_desc fh8833_io_desc[] = {
+	{
+		.virtual	= VA_RAM_REG_BASE,
+		.pfn		= __phys_to_pfn(RAM_BASE),
+		.length		= SZ_16K,
+		.type		= MT_MEMORY,
+	},
+	{
+		.virtual	= VA_DDRC_REG_BASE,
+		.pfn		= __phys_to_pfn(DDRC_REG_BASE),
+		.length		= SZ_16K,
+		.type		= MT_DEVICE,
+	},
+	{
+		.virtual	= VA_INTC_REG_BASE,
+		.pfn		= __phys_to_pfn(INTC_REG_BASE),
+		.length		= SZ_16K,
+		.type		= MT_DEVICE,
+	},
+	{
+		.virtual	= VA_TIMER_REG_BASE,
+		.pfn		= __phys_to_pfn(TIMER_REG_BASE),
+		.length		= SZ_16K,
+		.type		= MT_DEVICE,
+	},
+	{
+		.virtual	= VA_PMU_REG_BASE,
+		.pfn		= __phys_to_pfn(PMU_REG_BASE),
+		.length		= SZ_16K,
+		.type		= MT_DEVICE,
+	},
+	{
+		.virtual	= VA_UART0_REG_BASE,
+		.pfn		= __phys_to_pfn(UART0_REG_BASE),
+		.length		= SZ_16K,
+		.type		= MT_DEVICE,
+	},
+	{
+		.virtual	= VA_UART1_REG_BASE,
+		.pfn		= __phys_to_pfn(UART1_REG_BASE),
+		.length		= SZ_16K,
+		.type		= MT_DEVICE,
+	},
+	{
+		.virtual	= VA_PAE_REG_BASE,
+		.pfn		= __phys_to_pfn(PAE_REG_BASE),
+		.length		= SZ_16K,
+		.type		= MT_DEVICE,
+	},
+};
+
+
+static struct resource fh_gpio0_resources[] = {
+	{
+		.start		= GPIO0_REG_BASE,
+		.end		= GPIO0_REG_BASE + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+
+	{
+		.start		= GPIO0_IRQ,
+		.end		= GPIO0_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource fh_gpio1_resources[] = {
+	{
+		.start		= GPIO1_REG_BASE,
+		.end		= GPIO1_REG_BASE + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+
+	{
+		.start		= GPIO1_IRQ,
+		.end		= GPIO1_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+
+static struct resource fh_uart0_resources[] = {
+	{
+		.start		= (UART0_REG_BASE),
+		.end		= (UART0_REG_BASE) + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+
+	{
+		.start		= UART0_IRQ,
+		.end		= UART0_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource fh_uart1_resources[] = {
+	{
+		.start		= (UART1_REG_BASE),
+		.end		= (UART1_REG_BASE) + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+
+	{
+		.start		= UART1_IRQ,
+		.end		= UART1_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource fh_dma_resources[] = {
+	{
+		.start		= (DMAC_REG_BASE),
+		.end		= (DMAC_REG_BASE) + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+
+	{
+		.start		= DMAC0_IRQ,
+		.end		= DMAC0_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+static struct resource fh_i2c_resources_0[] = {
+	{
+		.start		= I2C0_REG_BASE,
+		.end		= I2C0_REG_BASE + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+
+	{
+		.start		= I2C0_IRQ,
+		.end		= I2C0_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+static struct resource fh_i2c_resources_1[] = {
+	{
+		.start		= I2C1_REG_BASE,
+		.end		= I2C1_REG_BASE + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+
+	{
+		.start		= I2C1_IRQ,
+		.end		= I2C1_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource fh_sdc0_resources[] = {
+	{
+		.start		= SDC0_REG_BASE,
+		.end		= SDC0_REG_BASE + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	{
+		.start		= SDC0_IRQ,
+		.end		= SDC0_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+static struct resource fh_sdc1_resources[] = {
+	{
+		.start		= SDC1_REG_BASE,
+		.end		= SDC1_REG_BASE + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	{
+		.start		= SDC1_IRQ,
+		.end		= SDC1_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+static struct resource fh_wdt_resources[] = {
+	{
+		.start		= WDT_REG_BASE,
+		.end		= WDT_REG_BASE + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	{
+		.start		= WDT_IRQ,
+		.end		= WDT_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+static struct resource fh_i2s_resources[] = {
+	{
+		.start		= I2S_REG_BASE,
+		.end		= I2S_REG_BASE + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	{
+		.start		= I2S0_IRQ,
+		.end		= I2S0_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource fh_spi0_resources[] = {
+	{
+		.start		= SPI0_REG_BASE,
+		.end		= SPI0_REG_BASE + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+		.name = "fh spi0 mem",
+	},
+	{
+		.start		= SPI0_IRQ,
+		.end		= SPI0_IRQ,
+		.flags		= IORESOURCE_IRQ,
+		.name = "fh spi0 irq",
+	},
+};
+
+static struct resource fh_spi1_resources[] = {
+	{
+		.start		= SPI1_REG_BASE,
+		.end		= SPI1_REG_BASE + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+		.name = "fh spi1 mem",
+	},
+	{
+		.start		= SPI1_IRQ,
+		.end		= SPI1_IRQ,
+		.flags		= IORESOURCE_IRQ,
+		.name = "fh spi1 irq",
+	},
+};
+
+static struct resource fh_spi2_resources[] = {
+	{
+		.start		= SPI2_REG_BASE,
+		.end		= SPI2_REG_BASE + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+		.name = "fh spi2 mem",
+	},
+	{
+		.start		= SPI2_IRQ,
+		.end		= SPI2_IRQ,
+		.flags		= IORESOURCE_IRQ,
+		.name = "fh spi2 irq",
+	},
+};
+
+
+
+static struct resource fh_gmac_resources[] = {
+	{
+		.start		= GMAC_REG_BASE,
+		.end		= GMAC_REG_BASE + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+
+	{
+		.start		= GMAC_IRQ,
+		.end		= GMAC_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource fh_pwm_resources[] = {
+	{
+		.start		= PWM_REG_BASE,
+		.end		= PWM_REG_BASE + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	{
+		.start		= PWM_IRQ,
+		.end		= PWM_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource fh_sadc_resources[] = {
+	{
+		.start		= SADC_REG_BASE,
+		.end		= SADC_REG_BASE + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+		.name = "fh sadc mem",
+	},
+	{
+		.start		= SADC_IRQ,
+		.end		= SADC_IRQ,
+		.flags		= IORESOURCE_IRQ,
+		.name = "fh sadc irq",
+	},
+};
+
+static struct resource fh_aes_resources[] = {
+	{
+		.start		= AES_REG_BASE,
+		.end		= AES_REG_BASE + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+		.name = "fh aes mem",
+	},
+	{
+		.start		= AES_IRQ,
+		.end		= AES_IRQ,
+		.flags		= IORESOURCE_IRQ,
+		.name = "fh aes irq",
+	},
+};
+
+static struct resource fh_acw_resources[] = {
+	{
+		.start		= ACW_REG_BASE,
+		.end		= ACW_REG_BASE + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	{
+		.start		= ACW_IRQ,
+		.end		= ACW_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+
+static struct resource fh_rtc_resources[] = {
+	{
+		.start		= RTC_REG_BASE,
+		.end		= RTC_REG_BASE + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	{
+		.start		= RTC_IRQ,
+		.end		= RTC_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+
+static struct resource fh_efuse_resources[] = {
+	{
+		.start		= EFUSE_REG_BASE,
+		.end		= EFUSE_REG_BASE + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+
+};
+
+static void fh_gmac_early_init(struct fh_gmac_platform_data *plat_data)
+{
+	if (plat_data->interface == PHY_INTERFACE_MODE_RMII)
+		fh_pmu_set_reg(REG_PMU_PAD_MAC_REF_CLK_CFG, 0x10001000);
+	else if (plat_data->interface == PHY_INTERFACE_MODE_MII)
+		fh_pmu_set_reg(REG_PMU_PAD_MAC_REF_CLK_CFG, 0x1000);
+}
+
+static void fh_gmac_plat_init(struct fh_gmac_platform_data *plat_data)
+{
+	u32 reg;
+
+	if (plat_data->interface == PHY_INTERFACE_MODE_RMII) {
+		reg = fh_pmu_get_reg(REG_PMU_SYS_CTRL);
+		reg |= 0x7000000;
+		fh_pmu_set_reg(REG_PMU_SYS_CTRL, reg);
+
+		fh_pmu_set_reg(REG_PMU_SWRST_AHB_CTRL, 0xfffdffff);
+		while (fh_pmu_get_reg(REG_PMU_SWRST_AHB_CTRL) != 0xffffffff)
+			;
+
+	} else if (plat_data->interface == PHY_INTERFACE_MODE_MII) {
+		reg = fh_pmu_get_reg(REG_PMU_SYS_CTRL);
+		reg &= ~(0x7000000);
+		reg |= 0x1000000;
+		fh_pmu_set_reg(REG_PMU_SYS_CTRL, reg);
+
+		fh_pmu_set_reg(REG_PMU_SWRST_AHB_CTRL, 0xfffdffff);
+		while (fh_pmu_get_reg(REG_PMU_SWRST_AHB_CTRL) != 0xffffffff)
+			;
+	}
+}
+
+static void fh_set_rmii_speed(int speed)
+{
+	u32 reg;
+
+	if (speed == gmac_speed_10m) {
+		reg = fh_pmu_get_reg(REG_PMU_SYS_CTRL);
+		reg &= ~(0x1000000);
+		fh_pmu_set_reg(REG_PMU_SYS_CTRL, reg);
+	} else {
+		reg = fh_pmu_get_reg(REG_PMU_SYS_CTRL);
+		reg |= 0x1000000;
+		fh_pmu_set_reg(REG_PMU_SYS_CTRL, reg);
+	}
+}
+
+static void fh_phy_reset(void)
+{
+	/*
+	 * RXDV must be low during phy reset
+	 * also, use AC_MCLK as our RMII REF CLK
+	 * just for temp use
+	 */
+	fh_pmu_set_reg(0x16c, 0x3001000);
+	fh_pmu_set_reg(0x1c, 0x0);
+	fh_pmu_set_reg(0x3c, 0x0b77030b);
+	fh_pmu_set_reg(0xe8, 0x1101000);
+
+	gpio_request(CONFIG_GPIO_EMACPHY_RESET, "phy_reset");
+	gpio_request(CONFIG_GPIO_EMACPHY_RXDV, "phy_rxdv");
+
+	gpio_direction_output(CONFIG_GPIO_EMACPHY_RXDV, 0);
+	gpio_direction_output(CONFIG_GPIO_EMACPHY_RESET, 0);
+	mdelay(10);
+	gpio_direction_output(CONFIG_GPIO_EMACPHY_RESET, 1);
+	mdelay(10);
+	gpio_free(CONFIG_GPIO_EMACPHY_RESET);
+	gpio_free(CONFIG_GPIO_EMACPHY_RXDV);
+
+	fh_pmu_set_reg(0xe8, 0x101000);
+
+}
+
+static struct fh_gmac_platform_data fh_gmac_data = {
+	.early_init = fh_gmac_early_init,
+	.plat_init = fh_gmac_plat_init,
+	.set_rmii_speed = fh_set_rmii_speed,
+	.phy_reset = fh_phy_reset,
+	.phyid = -1,
+};
+
+static const char *const fh_gpio0_names[] = {
+	"GPIO0",    "GPIO1",    "GPIO2",    "GPIO3",
+	"GPIO4",    "GPIO5",    "GPIO6",    "GPIO7",
+	"GPIO8",    "GPIO9",    "GPIO10",   "GPIO11",
+	"GPIO12",   "GPIO13",   "GPIO14",   "GPIO15",
+	"GPIO16",   "GPIO17",   "GPIO18",   "GPIO19",
+	"GPIO20",   "GPIO21",   "GPIO22",   "GPIO23",
+	"GPIO24",   "GPIO25",   "GPIO26",   "GPIO27",
+	"GPIO28",   "GPIO29",   "GPIO30",   "GPIO31",
+};
+
+static const char *const fh_gpio1_names[] = {
+	"GPIO32",   "GPIO33",   "GPIO34",   "GPIO35",
+	"GPIO36",   "GPIO37",   "GPIO38",   "GPIO39",
+	"GPIO40",   "GPIO41",   "GPIO42",   "GPIO43",
+	"GPIO44",   "GPIO45",   "GPIO46",   "GPIO47",
+	"GPIO48",   "GPIO49",   "GPIO50",   "GPIO51",
+	"GPIO52",   "GPIO53",   "GPIO54",   "GPIO55",
+	"GPIO56",   "GPIO57",   "GPIO58",   "GPIO59",
+	"GPIO60",   "GPIO61",   "GPIO62",   "GPIO63",
+	"GPIO64",   "GPIO65",   "GPIO66",   "GPIO67",
+	"GPIO68",   "GPIO69",   "GPIO70",   "GPIO71",
+};
+
+static struct fh_gpio_chip fh_gpio0_chip = {
+	.chip = {
+		.owner = THIS_MODULE,
+		.label = "FH_GPIO0",
+		.base = 0,
+		.ngpio = 32,
+		.names = fh_gpio0_names,
+	},
+};
+
+static struct fh_gpio_chip fh_gpio1_chip = {
+	.chip = {
+		.owner = THIS_MODULE,
+		.label = "FH_GPIO1",
+		.base = 32,
+		.ngpio = 32,
+		.names = fh_gpio1_names,
+	},
+};
+
+
+static void fh_wdt_pause(void)
+{
+	unsigned int reg;
+
+	reg = fh_pmu_get_reg(REG_PMU_WDT_CTRL);
+	reg |= 0x100;
+	fh_pmu_set_reg(REG_PMU_WDT_CTRL, reg);
+
+	printk(KERN_INFO "wdt pause\n");
+}
+
+static void fh_wdt_resume(void)
+{
+	unsigned int reg;
+
+	reg = fh_pmu_get_reg(REG_PMU_WDT_CTRL);
+	reg &= ~(0x100);
+	fh_pmu_set_reg(REG_PMU_WDT_CTRL, reg);
+}
+
+static struct fh_wdt_platform_data fh_wdt_data = {
+	.pause = fh_wdt_pause,
+	.resume = fh_wdt_resume,
+};
+
+static int fh_buswd(u32 slot_id)
+{
+	return 4;
+}
+
+static int sd_init(unsigned int slot_id, void *data, void *v)
+{
+	u32 reg;
+
+	reg = slot_id ? 0xfffffffd : 0xfffffffb;
+	fh_pmu_set_reg(REG_PMU_SWRST_AHB_CTRL, reg);
+	while (fh_pmu_get_reg(REG_PMU_SWRST_AHB_CTRL) != 0xffffffff)
+		;
+	return 0;
+}
+
+static unsigned int __maybe_unused
+fh_mci_sys_card_detect_fixed(struct fhmci_host *host)
+{
+	return 0;
+}
+
+static unsigned int __maybe_unused
+fh_mci_sys_read_only_fixed(struct fhmci_host *host)
+{
+	return 0;
+}
+
+struct fh_mci_board fh_mci = {
+	.init = sd_init,
+#ifdef CONFIG_SD_CD_FIXED
+	.get_cd = fh_mci_sys_card_detect_fixed,
+#endif
+#ifdef CONFIG_SD_WP_FIXED
+	.get_ro = fh_mci_sys_read_only_fixed,
+#endif
+	.num_slots = 1,
+	.bus_hz = 50000000,
+	.detect_delay_ms = 200,
+	.get_bus_wd = fh_buswd,
+	.caps = MMC_CAP_4_BIT_DATA
+	| MMC_CAP_SD_HIGHSPEED
+	| MMC_CAP_MMC_HIGHSPEED
+	| MMC_CAP_NEEDS_POLL
+	/*  | MMC_CAP_SDIO_IRQ  */,
+};
+
+struct fh_mci_board fh_mci_sd = {
+#ifdef CONFIG_SD_WP_FIXED
+	.get_ro = fh_mci_sys_read_only_fixed,
+#endif
+	.init = sd_init,
+	.num_slots = 1,
+	.bus_hz = 50000000,
+	.detect_delay_ms = 200,
+	.get_bus_wd = fh_buswd,
+	.caps = MMC_CAP_SD_HIGHSPEED
+	| MMC_CAP_MMC_HIGHSPEED
+	| MMC_CAP_NEEDS_POLL
+	/*  | MMC_CAP_SDIO_IRQ  */,
+};
+
+static struct fh_dma_platform_data fh_dma_data = {
+	.chan_priority  = CHAN_PRIORITY_DESCENDING,
+	.nr_channels    = 8,
+};
+
+static struct at24_platform_data at24c02 = {
+	.byte_len   = SZ_2K / 8,
+	.page_size  = 8,
+	.flags      = AT24_FLAG_TAKE8ADDR,
+};
+
+static struct platform_device fh_gmac_device = {
+	.name			= "fh_gmac",
+	.id			= 0,
+	.num_resources		= ARRAY_SIZE(fh_gmac_resources),
+	.resource		= fh_gmac_resources,
+	.dev			= {
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		.platform_data = &fh_gmac_data,
+	},
+};
+
+static struct platform_device fh_i2s_misc_device = {
+	.name			= "fh_i2s",
+	.id			= 0,
+	.num_resources		= ARRAY_SIZE(fh_i2s_resources),
+	.resource		= fh_i2s_resources,
+};
+
+static struct platform_device fh_acw_misc_device = {
+	.name			= "fh_acw",
+	.id			= 0,
+	.num_resources		= ARRAY_SIZE(fh_acw_resources),
+	.resource		= fh_acw_resources,
+};
+
+static struct platform_device fh_gpio0_device = {
+	.name			= GPIO_NAME,
+	.id			= 0,
+	.num_resources		= ARRAY_SIZE(fh_gpio0_resources),
+	.resource		= fh_gpio0_resources,
+	.dev			= {
+		.platform_data = &fh_gpio0_chip,
+	},
+};
+
+static struct platform_device fh_gpio1_device = {
+	.name			= GPIO_NAME,
+	.id			= 1,
+	.num_resources		= ARRAY_SIZE(fh_gpio1_resources),
+	.resource		= fh_gpio1_resources,
+	.dev			= {
+		.platform_data = &fh_gpio1_chip,
+	},
+};
+
+struct platform_device fh_sd0_device = {
+	.name			= "fh_mci",
+	.id			= 0,
+	.num_resources		= ARRAY_SIZE(fh_sdc0_resources),
+	.resource		= fh_sdc0_resources,
+	.dev			= {
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+		.platform_data = &fh_mci_sd,
+	}
+};
+
+struct platform_device fh_sd1_device = {
+	.name			= "fh_mci",
+	.id			= 1,
+	.num_resources		= ARRAY_SIZE(fh_sdc1_resources),
+	.resource		= fh_sdc1_resources,
+	.dev			= {
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+		.platform_data = &fh_mci,
+	}
+};
+
+struct platform_device fh_wdt_device = {
+	.name			= "fh_wdt",
+	.id			= 0,
+	.num_resources		= ARRAY_SIZE(fh_wdt_resources),
+	.resource		= fh_wdt_resources,
+	.dev			= {
+		.platform_data = &fh_wdt_data,
+	}
+};
+
+static struct platform_device fh_uart0_device = {
+	.name			= "ttyS",
+	.id			= 0,
+	.num_resources		= ARRAY_SIZE(fh_uart0_resources),
+	.resource		= fh_uart0_resources,
+};
+
+static struct platform_device fh_uart1_device = {
+	.name			= "ttyS",
+	.id			= 1,
+	.num_resources		= ARRAY_SIZE(fh_uart1_resources),
+	.resource		= fh_uart1_resources,
+};
+
+static struct platform_device fh_dma_device = {
+	.name			= "fh_dmac",
+	.id			= 0,
+	.num_resources		= ARRAY_SIZE(fh_dma_resources),
+	.resource		= fh_dma_resources,
+	.dev.platform_data	= &fh_dma_data,
+};
+
+static struct platform_device fh_i2c0_device = {
+	.name			= "fh_i2c",
+	.id			= 0,
+	.num_resources		= ARRAY_SIZE(fh_i2c_resources_0),
+	.resource		= fh_i2c_resources_0,
+};
+
+static struct platform_device fh_i2c1_device = {
+	.name			= "fh_i2c",
+	.id			= 1,
+	.num_resources		= ARRAY_SIZE(fh_i2c_resources_1),
+	.resource		= fh_i2c_resources_1,
+};
+
+static struct i2c_board_info __initdata fh_i2c_devices[] = {
+	{
+		I2C_BOARD_INFO("24c02", 0x50),
+		.platform_data = &at24c02,
+	},
+	{
+		I2C_BOARD_INFO("pcf8563", 0x51)
+	}
+};
+
+#define FH_SPI0_CS0	(54)
+#define FH_SPI0_CS1	(55)
+
+#define FH_SPI1_CS0	(56)
+#define FH_SPI1_CS1	(57)
+
+#define FH_SPI3_CS0	(58)
+#define FH_SPI3_CS1	(59)
+
+#define SPI0_FIFO_DEPTH				(64)
+#define SPI0_CLK_IN				(100000000)
+#define SPI0_MAX_SLAVE_NO			(2)
+#define SPI0_DMA_RX_CHANNEL			(0)
+#define SPI0_DMA_TX_CHANNEL			(1)
+
+#define SPI1_FIFO_DEPTH				(32)
+#define SPI1_CLK_IN				(100000000)
+#define SPI1_MAX_SLAVE_NO			(2)
+#define SPI1_DMA_RX_CHANNEL			(2)
+#define SPI1_DMA_TX_CHANNEL			(3)
+
+#define SPI2_FIFO_DEPTH				(64)
+#define SPI2_CLK_IN				(100000000)
+
+#define SPI3_FIFO_DEPTH				(32)
+#define SPI3_CLK_IN				(100000000)
+#define SPI3_MAX_SLAVE_NO			(2)
+#define SPI3_DMA_RX_CHANNEL			(4)
+#define SPI3_DMA_TX_CHANNEL			(5)
+/* SPI_TRANSFER_USE_DMA */
+
+static struct fh_spi_platform_data fh_spi0_data = {
+	.apb_clock_in = SPI0_CLK_IN,
+	.fifo_len = SPI0_FIFO_DEPTH,
+	.slave_max_num = SPI0_MAX_SLAVE_NO,
+	.cs_data[0].GPIO_Pin = FH_SPI0_CS0,
+	.cs_data[0].name = "spi0_cs0",
+	.cs_data[1].GPIO_Pin = FH_SPI0_CS1,
+	.cs_data[1].name = "spi0_cs1",
+	.dma_transfer_enable = 0,
+	.rx_handshake_num = 2,
+	.tx_handshake_num = 3,
+	.rx_dma_channel = SPI0_DMA_RX_CHANNEL,
+	.tx_dma_channel = SPI0_DMA_TX_CHANNEL,
+	.clk_name = "spi0_clk",
+};
+
+static struct fh_spi_platform_data fh_spi1_data = {
+	.apb_clock_in = SPI1_CLK_IN,
+	.fifo_len = SPI1_FIFO_DEPTH,
+	.slave_max_num = SPI1_MAX_SLAVE_NO,
+	.cs_data[0].GPIO_Pin = FH_SPI1_CS0,
+	.cs_data[0].name = "spi1_cs0",
+	.cs_data[1].GPIO_Pin = FH_SPI1_CS1,
+	.cs_data[1].name = "spi1_cs1",
+	.dma_transfer_enable = 0,
+	.rx_handshake_num = 4,
+	.tx_handshake_num = 5,
+	.rx_dma_channel = SPI1_DMA_RX_CHANNEL,
+	.tx_dma_channel = SPI1_DMA_TX_CHANNEL,
+	.clk_name = "spi1_clk",
+};
+
+static struct fh_spi_platform_data fh_spi2_data = {
+	.apb_clock_in = SPI2_CLK_IN,
+	.fifo_len = SPI2_FIFO_DEPTH,
+	.dma_transfer_enable = 0,
+	.rx_handshake_num = 12,
+	.tx_handshake_num = 13,
+	.clk_name = "spi2_clk",
+};
+
+static struct fh_rtc_platform_data fh_rtc_data = {
+	.clock_in = 32768,
+	.dev_name = "rtc",
+	.clk_name = "rtc_clk",
+	.base_year = 2000,
+	.base_month = 1,
+	.base_day = 1,
+	.sadc_channel = -1,
+};
+
+
+
+static struct platform_device fh_spi0_device = {
+	.name			= "fh_spi",
+	.id			= 0,
+	.num_resources		= ARRAY_SIZE(fh_spi0_resources),
+	.resource		= fh_spi0_resources,
+	.dev			= {
+		.platform_data = &fh_spi0_data,
+	},
+};
+
+static struct platform_device fh_spi1_device = {
+	.name			= "fh_spi",
+	.id			= 1,
+	.num_resources		= ARRAY_SIZE(fh_spi1_resources),
+	.resource		= fh_spi1_resources,
+	.dev			= {
+		.platform_data = &fh_spi1_data,
+	},
+};
+
+
+static struct platform_device fh_spi2_device = {
+	.name			= "fh_spi_slave",
+	.id			= 0,
+	.num_resources		= ARRAY_SIZE(fh_spi2_resources),
+	.resource		= fh_spi2_resources,
+	.dev			= {
+		.platform_data = &fh_spi2_data,
+	},
+};
+
+static struct platform_device fh_pwm_device = {
+	.name			= "fh_pwm",
+	.id			= 0,
+	.num_resources		= ARRAY_SIZE(fh_pwm_resources),
+	.resource		= fh_pwm_resources,
+
+};
+
+static struct platform_device fh_pinctrl_device = {
+	.name			= "fh_pinctrl",
+	.id			= 0,
+};
+
+static struct platform_device fh_sadc_device = {
+	.name			= "fh_sadc",
+	.id			= 0,
+	.num_resources		= ARRAY_SIZE(fh_sadc_resources),
+	.resource		= fh_sadc_resources,
+	.dev			= {
+		.platform_data = NULL,
+	},
+};
+
+static struct platform_device fh_aes_device = {
+	.name			= "fh_aes",
+	.id			= 0,
+	.num_resources		= ARRAY_SIZE(fh_aes_resources),
+	.resource		= fh_aes_resources,
+	.dev			= {
+		.platform_data = NULL,
+	},
+};
+
+static struct platform_device fh_ac97_device = {
+	.name			= "fh-acodec",
+	.id			= -1,
+};
+
+static struct platform_device fh_pcm_device = {
+	.name			= "fh-pcm-audio",
+	.id			= -1,
+};
+
+static struct platform_device fh_rtc_device = {
+	.name			= "fh_rtc",
+	.id			= 0,
+	.num_resources		= ARRAY_SIZE(fh_rtc_resources),
+	.resource		= fh_rtc_resources,
+	.dev			= {
+		.platform_data = &fh_rtc_data,
+	},
+};
+
+static struct platform_device fh_efuse_device = {
+	.name			= "fh_efuse",
+	.id			= 0,
+	.num_resources		= ARRAY_SIZE(fh_efuse_resources),
+	.resource		= fh_efuse_resources,
+};
+
+/*
+ * fh8833 usb board config
+ * add 2016/12/20
+ *
+ */
+static struct platform_device *fh8833_devices[] __initdata = {
+	&fh_gmac_device,
+	&fh_uart0_device,
+	&fh_uart1_device,
+	&fh_dma_device,
+	&fh_i2c0_device,
+	&fh_i2c1_device,
+	&fh_sd0_device,
+#ifndef CONFIG_FH_GMAC
+	&fh_sd1_device,
+#endif
+	&fh_spi0_device,
+	&fh_spi1_device,
+	&fh_spi2_device,
+	&fh_gpio0_device,
+	&fh_gpio1_device,
+	&fh_wdt_device,
+	&fh_pwm_device,
+	&fh_pinctrl_device,
+	&fh_sadc_device,
+	&fh_aes_device,
+	&fh_pcm_device,
+	&fh_ac97_device,
+	&fh_acw_misc_device,
+	&fh_i2s_misc_device,
+	&fh_rtc_device,
+	&fh_efuse_device,
+
+};
+
+static struct mtd_partition fh_sf_parts[] = {
+	{
+		/* head & Ramboot */
+		.name		= "bootstrap",
+		.offset		= 0,
+		.size		= SZ_256K,
+		.mask_flags	= MTD_WRITEABLE, /* force read-only */
+	}, {
+		/* Ramboot & U-Boot environment */
+		.name		= "uboot-env",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= SZ_64K,
+		.mask_flags	= MTD_WRITEABLE, /* force read-only */
+	}, {
+		/* U-Boot */
+		.name		= "uboot",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 3 * SZ_64K,
+		.mask_flags	= MTD_WRITEABLE, /* force read-only */
+	}, {
+		.name		= "kernel",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= SZ_4M,
+		.mask_flags	= 0,
+	}, {
+		.name		= "rootfs",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= SZ_8M,
+		.mask_flags	= 0,
+	}, {
+		.name		= "app",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= MTDPART_SIZ_FULL,
+		.mask_flags	= 0,
+	}
+	/* mtdparts=
+	 * spi_flash:256k(bootstrap),
+	 * 64k(u-boot-env),
+	 * 192k(u-boot),4M(kernel),
+	 * 8M(rootfs),
+	 * -(app) */
+	/* two blocks with bad block table (and mirror) at the end */
+};
+#ifdef CONFIG_MACH_FH_NAND
+static struct mtd_partition fh_sf_nand_parts[] = {
+	{
+		/* head & Ramboot */
+		.name		= "bootstrap",
+		.offset		= 0,
+		.size		= SZ_256K,
+		.mask_flags	= MTD_WRITEABLE, /* force read-only */
+	}, {
+		.name		= "uboot-env",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= SZ_256K,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "uboot",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= SZ_256K,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= SZ_4M,
+		.mask_flags	= 0,
+	}, {
+		.name		= "rootfs",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= SZ_8M,
+		.mask_flags	= 0,
+	}, {
+		.name		= "app",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= MTDPART_SIZ_FULL,
+		.mask_flags	= 0,
+	}
+	/* mtdparts=
+	 * spi0.0:64k(bootstrap),
+	 * 64k(u-boot-env),
+	 * 192k(u-boot),
+	 * 4M(kernel),
+	 * 8M(rootfs),
+	 * -(app) */
+	/* two blocks with bad block table (and mirror) at the end */
+};
+static struct flash_platform_data fh_nandflash_platform_data  = {
+	.name		= "spi_nandflash",
+	.parts		= fh_sf_nand_parts,
+	.nr_parts	= ARRAY_SIZE(fh_sf_nand_parts),
+};
+#endif
+static struct flash_platform_data fh_flash_platform_data  = {
+	.name		= "spi_flash",
+	.parts		= fh_sf_parts,
+	.nr_parts	= ARRAY_SIZE(fh_sf_parts),
+};
+static struct spi_board_info fh_spi_devices[] = {
+#ifdef CONFIG_MACH_FH_NAND
+	{
+		.modalias       = "spi-nand",
+		.bus_num        = 0,
+		.chip_select    = 0,
+		.max_speed_hz   = 50000000,
+		.mode           = SPI_MODE_3,
+		.platform_data   = &fh_nandflash_platform_data,
+	},
+#endif
+	{
+		.modalias        = "m25p80",
+		.bus_num         = 0,
+		.chip_select     = 0,
+		.mode            = SPI_MODE_3,
+		.max_speed_hz    = 25000000,
+		.platform_data   = &fh_flash_platform_data,
+	},
+
+};
+static void __init fh8833_map_io(void)
+{
+	iotable_init(fh8833_io_desc, ARRAY_SIZE(fh8833_io_desc));
+}
+
+
+static __init void fh8833_board_init(void)
+{
+	printk(KERN_INFO "fh8833 board init\n");
+	platform_add_devices(fh8833_devices, ARRAY_SIZE(fh8833_devices));
+	i2c_register_board_info(1, fh_i2c_devices, ARRAY_SIZE(fh_i2c_devices));
+	spi_register_board_info(fh_spi_devices, ARRAY_SIZE(fh_spi_devices));
+	fh_clk_procfs_init();
+	fh_pmu_init();
+}
+
+static void __init fh8833_init_early(void)
+{
+	fh_clk_init();
+	fh_pinctrl_init(VA_PMU_REG_BASE + 0x80);
+}
+
+MACHINE_START(FH8833, "FH8833")
+	.boot_params	= DDR_BASE + 0x100,
+	.map_io		= fh8833_map_io,
+	.init_irq	= fh_intc_init,
+	.timer		= &fh_timer,
+	.init_machine	= fh8833_board_init,
+	.init_early	= fh8833_init_early,
+MACHINE_END
diff -uraN linux-3.0.8/arch/arm/mach-fh/clock.c linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/clock.c
--- linux-3.0.8/arch/arm/mach-fh/clock.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/clock.c	2021-07-13 23:40:30.646336791 +0300
@@ -0,0 +1,638 @@
+/*
+ * Clock and PLL control for FH devices
+ *
+ * Copyright (C) 2014 Fullhan Microelectronics Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/io.h>
+#include <asm/bitops.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <mach/hardware.h>
+#include <asm/uaccess.h>
+#include <linux/miscdevice.h>
+#include <mach/clock.h>
+#include <mach/clock.h>
+#include <linux/platform_device.h>
+#include <mach/pmu.h>
+
+#define PROC_FILE   "driver/clock"
+
+static LIST_HEAD(clocks);
+static DEFINE_MUTEX(clocks_mutex);
+static DEFINE_SPINLOCK(clocks_lock);
+
+struct proc_dir_entry *proc_file;
+
+
+//#define FH_CLK_DEBUG
+
+#if defined(FH_CLK_DEBUG)
+#define PRINT_CLK_DBG(fmt, args...)   \
+    do                                \
+    {                                 \
+        printk("FH_CLK_DEBUG: "); \
+        printk(fmt, ##args);      \
+    } while (0)
+#else
+#define PRINT_CLK_DBG(fmt, args...) \
+    do                              \
+    {                               \
+    } while (0)
+#endif
+
+
+void clk_set_clk_sel(unsigned int reg)
+{
+	fh_pmu_set_reg(REG_PMU_CLK_SEL, reg);
+}
+EXPORT_SYMBOL(clk_set_clk_sel);
+
+unsigned int clk_get_clk_sel(void)
+{
+	return fh_pmu_get_reg(REG_PMU_CLK_SEL);
+}
+EXPORT_SYMBOL(clk_get_clk_sel);
+
+#ifdef FH_CLOCK_DEBUG
+static void __clk_sel_ddr_clk(int source)
+{
+	unsigned int clk_sel;
+	int shift = 24;
+	clk_sel = clk_get_clk_sel();
+	clk_sel &= ~(0x1 << shift);
+	clk_sel |= (source & 0x1) << shift;
+	clk_set_clk_sel(clk_sel);
+}
+
+static void __clk_sel_pix_clk(int source)
+{
+	unsigned int clk_sel;
+	int shift = 4;
+	clk_sel = clk_get_clk_sel();
+	clk_sel &= ~(0x3 << shift);
+	clk_sel |= (source & 0x3) << shift;
+	clk_set_clk_sel(clk_sel);
+}
+
+static void __clk_sel_ac_clk(int source)
+{
+	unsigned int clk_sel;
+	int shift = 0;
+	clk_sel = clk_get_clk_sel();
+	clk_sel &= ~(0x1 << shift);
+	clk_sel |= (source & 0x1) << shift;
+	clk_set_clk_sel(clk_sel);
+}
+#endif
+
+
+static void fh_clk_enable(struct clk *clk)
+{
+	unsigned int reg;
+
+	if (clk->flag & CLOCK_NOGATE) {
+		PRINT_CLK_DBG("%s, %s has no gate register\n", __func__, clk->name);
+		return;
+	}
+
+	reg = fh_pmu_get_reg(clk->en_reg_offset);
+	PRINT_CLK_DBG("%s, clk: %s, reg: 0x%x\n", __func__, clk->name, reg);
+	reg &= ~(clk->en_reg_mask);
+	fh_pmu_set_reg(clk->en_reg_offset, reg);
+	PRINT_CLK_DBG("%s, clk: %s, after mask: 0x%x\n", __func__, clk->name, reg);
+}
+
+static void fh_clk_disable(struct clk *clk)
+{
+	unsigned int reg;
+
+	if (clk->flag & CLOCK_NOGATE) {
+		PRINT_CLK_DBG("%s, %s has no gate register\n", __func__, clk->name);
+		return;
+	}
+
+	reg = fh_pmu_get_reg(clk->en_reg_offset);
+	reg |= clk->en_reg_mask;
+	fh_pmu_set_reg(clk->en_reg_offset, reg);
+
+	PRINT_CLK_DBG("%s, clk: %s, reg: 0x%x\n", __func__, clk->name, reg);
+}
+
+static int fh_clk_get_sel(struct clk *clk)
+{
+	unsigned int reg, shift;
+	int ret;
+
+	if (!(clk->flag & CLOCK_MULTI_PARENT))
+		return 0;
+
+	shift = ffs(clk->sel_reg_mask) - 1;
+	reg = fh_pmu_get_reg(clk->sel_reg_offset);
+	reg &= clk->sel_reg_mask;
+	ret = reg >> shift;
+	PRINT_CLK_DBG("%s, clk: %s, sel: %d\n", __func__, clk->name, ret);
+
+	return ret;
+}
+
+static void fh_clk_set_sel(struct clk *clk, int sel)
+{
+	unsigned int reg, shift;
+
+	if (!(clk->flag & CLOCK_MULTI_PARENT)) {
+		PRINT_CLK_DBG("%s, clk: %s has only one parent\n", __func__, clk->name);
+		return;
+	}
+
+	clk->select = sel;
+	shift = ffs(clk->sel_reg_mask) - 1;
+	reg = fh_pmu_get_reg(clk->sel_reg_offset);
+	reg &= ~(clk->sel_reg_mask);
+	reg |= (sel << shift);
+	fh_pmu_set_reg(clk->rst_reg_offset, reg);
+	PRINT_CLK_DBG("%s, clk: %s, select: %d, reg: 0x%x\n", __func__, clk->name, sel,
+		      reg);
+}
+
+static unsigned long fh_clk_get_pll_rate(struct clk *clk)
+{
+	unsigned int reg, m, n, od, no = 1, i;
+
+	reg = fh_pmu_get_reg(clk->div_reg_offset);
+	m = reg & 0xff;
+	n = (reg >> 8) & 0xf;
+	od = (reg >> 16) & 0x3;
+
+	for(i=0; i<od; i++)
+		no *= 2;
+
+	clk->frequency = OSC_FREQUENCY * m / n / no;
+
+	return clk->frequency;
+}
+
+static int fh_clk_get_div(struct clk *clk)
+{
+	unsigned int reg, shift;
+	int ret;
+
+	if (clk->flag & (CLOCK_NODIV | CLOCK_FIXED))
+		return 0;
+
+	shift = ffs(clk->div_reg_mask) - 1;
+	reg = fh_pmu_get_reg(clk->div_reg_offset);
+	PRINT_CLK_DBG("%s, clk: %s, reg: 0x%x\n", __func__, clk->name, reg);
+	reg &= clk->div_reg_mask;
+	PRINT_CLK_DBG("%s, clk: %s, shift: %d, after mask: 0x%x\n", __func__, clk->name,
+		      shift, reg);
+	ret = reg >> shift;
+	PRINT_CLK_DBG("%s, clk: %s, div: %d\n", __func__, clk->name, ret);
+	PRINT_CLK_DBG("%s, clk: %s, div_mask: 0x%x, div_offset: 0x%x\n",
+		      __func__, clk->name, clk->div_reg_mask, clk->div_reg_offset);
+
+	return ret;
+}
+
+static void fh_clk_set_div(struct clk *clk, int div)
+{
+	unsigned int reg, shift;
+
+	if (clk->flag & CLOCK_NODIV) {
+		PRINT_CLK_DBG("%s, clk: %s has no divide\n", __func__, clk->name);
+		return;
+	}
+
+	shift = ffs(clk->div_reg_mask) - 1;
+
+	if(div > clk->div_reg_mask >> shift)
+	{
+		pr_err("%s, clk: %s, curr div %d is too big, max is %d\n",
+				__func__, clk->name, div, clk->div_reg_mask >> shift);
+		return;
+	}
+
+	clk->divide = div;
+
+	reg = fh_pmu_get_reg(clk->div_reg_offset);
+	PRINT_CLK_DBG("%s, clk: %s, reg: 0x%x\n", __func__, clk->name, reg);
+	reg &= ~(clk->div_reg_mask);
+	reg |= (div << shift);
+	PRINT_CLK_DBG("%s, clk: %s, shift: %d, after mask: 0x%x\n", __func__, clk->name,
+		      shift, reg);
+	fh_pmu_set_reg(clk->div_reg_offset, reg);
+	PRINT_CLK_DBG("%s, clk: %s, div: %d, reg: 0x%x\n", __func__, clk->name, div,
+		      reg);
+	PRINT_CLK_DBG("%s, clk: %s, div_mask: 0x%x, div_offset: 0x%x\n",
+		      __func__, clk->name, clk->div_reg_mask, clk->div_reg_offset);
+
+}
+
+unsigned long fh_clk_get_rate(struct clk *clk)
+{
+	if (clk->flag & CLOCK_FIXED) {
+		PRINT_CLK_DBG("%s, clk: %s is fixed clock, rate: %lu\n", __func__, clk->name,
+			      clk->frequency);
+		return clk->frequency;
+	}
+
+	if (clk->flag & CLOCK_PLL) {
+		PRINT_CLK_DBG("%s, clk: %s is a PLL clock\n", __func__, clk->name);
+		return fh_clk_get_pll_rate(clk);
+	}
+
+
+	clk->select = fh_clk_get_sel(clk);
+	clk->divide = fh_clk_get_div(clk) + 1;
+
+	if (clk->select > CLOCK_MAX_PARENT) {
+		pr_err("ERROR, %s, clk: %s, select is not correct, clk->select: %d\n", __func__,
+		       clk->name, clk->select);
+		return 0;
+	}
+
+	if (!clk->parent[clk->select]) {
+		pr_err("ERROR, %s, clk: %s has no parent and is not a fixed clock\n", __func__,
+		       clk->name);
+		return 0;
+	}
+
+	clk->frequency = clk->parent[clk->select]->frequency / clk->prediv;
+	clk->frequency /= clk->divide;
+
+	PRINT_CLK_DBG("%s, clk: %s, rate: %lu\n", __func__, clk->name, clk->frequency);
+
+	return clk->frequency;
+}
+
+void fh_clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	if (clk->flag & CLOCK_FIXED) {
+		pr_err("%s, clk: %s is fixed clock, rate: %lu\n", __func__, clk->name,
+		       clk->frequency);
+		return;
+	}
+
+	if (clk->flag & CLOCK_PLL) {
+		pr_err("%s, clk: %s is a PLL clock, changing frequency is not recommended\n",
+				__func__, clk->name);
+		return;
+	}
+
+	if (clk->select > CLOCK_MAX_PARENT) {
+		pr_err("ERROR, %s, clk: %s, select is not correct, clk->select: %d\n", __func__,
+		       clk->name, clk->select);
+		return;
+	}
+
+	if (!clk->parent[clk->select]) {
+		pr_err("ERROR, %s, clk: %s has no parent and is not a fixed clock\n", __func__,
+		       clk->name);
+		return;
+	}
+
+	clk->frequency = clk->parent[clk->select]->frequency / clk->prediv;
+	clk->divide = clk->frequency / rate;
+	PRINT_CLK_DBG("%s, clk: %s, set rate: %lu, divide: %d\n", __func__, clk->name,
+		      rate, clk->divide);
+	fh_clk_set_div(clk, clk->divide - 1);
+
+	clk->frequency = rate;
+
+	PRINT_CLK_DBG("%s, clk: %s, rate: %lu\n", __func__, clk->name, clk->frequency);
+}
+
+void fh_clk_reset(struct clk *clk)
+{
+	unsigned int reg;
+
+	if (clk->flag & CLOCK_NORESET) {
+		pr_err("%s, clk: %s has no reset\n", __func__, clk->name);
+		return;
+	}
+
+	reg = 0xffffffff & ~(clk->rst_reg_mask);
+
+	fh_pmu_set_reg(clk->rst_reg_offset, reg);
+	while (fh_pmu_get_reg(clk->rst_reg_offset) != 0xffffffff) {
+
+	}
+	PRINT_CLK_DBG("%s, clk: %s has been reset\n", __func__, clk->name);
+}
+
+int clk_enable(struct clk *clk)
+{
+	unsigned long flags;
+
+	if (clk == NULL || IS_ERR(clk))
+		return -EINVAL;
+
+	spin_lock_irqsave(&clocks_lock, flags);
+	fh_clk_enable(clk);
+	spin_unlock_irqrestore(&clocks_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(clk_enable);
+
+void clk_disable(struct clk *clk)
+{
+	unsigned long flags;
+
+	if (clk == NULL || IS_ERR(clk))
+		return;
+
+	spin_lock_irqsave(&clocks_lock, flags);
+	fh_clk_disable(clk);
+	spin_unlock_irqrestore(&clocks_lock, flags);
+}
+EXPORT_SYMBOL(clk_disable);
+
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+	unsigned long flags, rate;
+
+	if (clk == NULL || IS_ERR(clk))
+		return -EINVAL;
+
+	spin_lock_irqsave(&clocks_lock, flags);
+
+	rate = fh_clk_get_rate(clk);
+
+	spin_unlock_irqrestore(&clocks_lock, flags);
+
+	return rate;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long flags, real_rate;
+	int ret = -EINVAL;
+
+	if (clk == NULL || IS_ERR(clk))
+		return ret;
+
+	spin_lock_irqsave(&clocks_lock, flags);
+	fh_clk_set_rate(clk, rate);
+	real_rate = clk_get_rate(clk);
+	if(rate != real_rate)
+	{
+		printk("WARN: set clk %s to %ld, but get %ld\n", clk->name, rate, real_rate);
+	}
+	spin_unlock_irqrestore(&clocks_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(clk_set_rate);
+
+void clk_reset(struct clk *clk)
+{
+	unsigned long flags;
+
+	if (clk == NULL || IS_ERR(clk))
+		return;
+
+	spin_lock_irqsave(&clocks_lock, flags);
+	fh_clk_reset(clk);
+	spin_unlock_irqrestore(&clocks_lock, flags);
+}
+EXPORT_SYMBOL(clk_reset);
+
+void clk_change_parent(struct clk *clk, int select)
+{
+	unsigned long flags;
+
+	if (clk == NULL || IS_ERR(clk))
+		return;
+
+	spin_lock_irqsave(&clocks_lock, flags);
+	fh_clk_set_sel(clk, select);
+	spin_unlock_irqrestore(&clocks_lock, flags);
+}
+EXPORT_SYMBOL(clk_change_parent);
+
+int clk_register(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return -EINVAL;
+
+	if (WARN(clk->parent[clk->select] && !clk->parent[clk->select]->frequency,
+		 "CLK: %s parent %s has no rate!\n",
+		 clk->name, clk->parent[clk->select]->name))
+		return -EINVAL;
+
+	clk_get_rate(clk);
+
+	PRINT_CLK_DBG("clk: %s has been registered, div: %d, sel: %d\n",
+		      clk->name, clk->divide, clk->select);
+
+	mutex_lock(&clocks_mutex);
+	list_add_tail(&clk->list, &clocks);
+	mutex_unlock(&clocks_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL(clk_register);
+
+void clk_unregister(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return;
+
+	mutex_lock(&clocks_mutex);
+	list_del(&clk->list);
+	mutex_unlock(&clocks_mutex);
+}
+EXPORT_SYMBOL(clk_unregister);
+
+
+static void del_char(char* str,char ch)
+{
+	char *p = str;
+	char *q = str;
+	while(*q)
+	{
+		if (*q !=ch)
+		{
+			*p++ = *q;
+		}
+		q++;
+	}
+	*p='\0';
+}
+
+static ssize_t fh_clk_proc_write(struct file *filp, const char *buf, size_t len, loff_t *off)
+{
+	int i, ret;
+	char message[64] = {0};
+	char * const delim = ",";
+	char *cur = message;
+	char* param_str[4];
+	unsigned int param[4];
+	struct clk *clk;
+
+	len = (len > 64) ? 64 : len;
+
+	if (copy_from_user(message, buf, len))
+		return -EFAULT;
+
+	for(i=0; i<3; i++)
+	{
+		param_str[i] = strsep(&cur, delim);
+		if(!param_str[i])
+		{
+			pr_err("%s: ERROR: parameter[%d] is empty\n", __func__, i);
+			pr_err("[clk name], [enable/disable], [clk rate]\n");
+			return -EINVAL;
+		}
+		else
+		{
+			del_char(param_str[i], ' ');
+			del_char(param_str[i], '\n');
+		}
+	}
+
+	clk = clk_get(NULL, param_str[0]);
+	if(!clk)
+	{
+		pr_err("%s: ERROR: clk %s is not found\n", __func__, param_str[0]);
+		pr_err("[clk name], [enable/disable], [clk rate]\n");
+		return -EINVAL;
+	}
+
+	param[2] = (u32)simple_strtoul(param_str[2], NULL, 10);
+	if(param[2] < 0)
+	{
+		pr_err("ERROR: parameter[2] is incorrect\n");
+		return -EINVAL;
+	}
+
+	ret = clk_set_rate(clk, param[2]);
+	if(ret)
+	{
+		pr_err("set clk rate failed\n, ret=%d\n", ret);
+	}
+
+        if(!strcmp(param_str[1], "enable"))
+        {
+        	clk_enable(clk);
+        	printk("clk %s enabled\n", param_str[0]);
+        }
+        else if(!strcmp(param_str[1], "disable"))
+        {
+        	clk_disable(clk);
+        	printk("clk %s disabled\n", param_str[0]);
+        }
+        else
+        {
+		pr_err("%s: ERROR: parameter[1]:%s is incorrect\n", __func__, param_str[1]);
+		pr_err("[clk name], [enable/disable], [clk rate]\n");
+		return -EINVAL;
+        }
+
+	return len;
+}
+
+
+static void *v_seq_start(struct seq_file *s, loff_t *pos)
+{
+	static unsigned long counter = 0;
+	if (*pos == 0)
+		return &counter;
+	else {
+		*pos = 0;
+		return NULL;
+	}
+}
+
+static void *v_seq_next(struct seq_file *s, void *v, loff_t *pos)
+{
+	(*pos)++;
+	return NULL;
+}
+
+static void v_seq_stop(struct seq_file *s, void *v)
+{
+
+}
+
+static int v_seq_show(struct seq_file *sfile, void *v)
+{
+
+	struct clk_lookup *clock_lookup;
+	struct clk *clk;
+	unsigned long rate;
+
+	seq_printf(sfile, "\nPLL Information: \n");
+
+	for (clock_lookup = fh_clks; clock_lookup->clk; clock_lookup++) {
+		clk = clock_lookup->clk;
+		rate = clk_get_rate(clk);
+		seq_printf(sfile, "\t%-20s \t%9lu HZ\n", clk->name, rate);
+	}
+	return 0;
+}
+
+static const struct seq_operations fh_clk_seq_ops = {
+	.start = v_seq_start,
+	.next = v_seq_next,
+	.stop = v_seq_stop,
+	.show = v_seq_show
+};
+
+static int fh_clk_proc_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &fh_clk_seq_ops);
+}
+
+
+static struct file_operations fh_clk_proc_ops = {
+	.owner		= THIS_MODULE,
+	.open		= fh_clk_proc_open,
+	.read		= seq_read,
+	.write		= fh_clk_proc_write,
+	.release	= seq_release,
+};
+
+int __init fh_clk_procfs_init(void)
+{
+	proc_file = create_proc_entry(PROC_FILE, 0644, NULL);
+	if (proc_file)
+		proc_file->proc_fops = &fh_clk_proc_ops;
+	else
+		pr_err("clock, create proc fs failed\n");
+
+	return 0;
+}
+
+int __init fh_clk_init(void)
+{
+	struct clk_lookup *clock_lookup;
+	struct clk *clk;
+	size_t num_clocks = 0;
+
+	for (clock_lookup = fh_clks; clock_lookup->clk; clock_lookup++) {
+		clk = clock_lookup->clk;
+		num_clocks++;
+		clk_register(clk);
+		if (clk->def_rate)
+			clk_set_rate(clk, clk->def_rate);
+	}
+	clkdev_add_table(fh_clks, num_clocks);
+	return 0;
+}
diff -uraN linux-3.0.8/arch/arm/mach-fh/fh8833.c linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/fh8833.c
--- linux-3.0.8/arch/arm/mach-fh/fh8833.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/fh8833.c	2021-07-13 23:40:30.646336791 +0300
@@ -0,0 +1,466 @@
+/*
+ * Fullhan FH8833 board support
+ *
+ * Copyright (C) 2014 Fullhan Microelectronics Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/serial_8250.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/gpio.h>
+#include <linux/spi/spi.h>
+
+#include <asm/mach/map.h>
+
+#include <mach/chip.h>
+#include <mach/irqs.h>
+#include <mach/timex.h>
+#include <mach/pmu.h>
+#include <mach/clock.h>
+
+/*
+ * external oscillator
+ * fixed to 24M
+ */
+static struct clk osc_clk = {
+	.name               = "osc_clk",
+	.frequency          = OSC_FREQUENCY,
+	.flag               = CLOCK_FIXED,
+};
+
+/*
+ * phase-locked-loop device,
+ * generates a higher frequency clock
+ * from the external oscillator reference
+ */
+static struct clk pll0_clk = {
+	.name               = "pll0_clk",
+	.flag               = CLOCK_PLL,
+	.parent             = {&osc_clk},
+	.div_reg_offset     = REG_PMU_PLL0,
+};
+
+static struct clk pll1_clk = {
+	.name               = "pll1_clk",
+	.flag               = CLOCK_PLL,
+	.parent             = {&osc_clk},
+	.div_reg_offset     = REG_PMU_PLL1,
+};
+
+/*
+ * CPU
+ */
+static struct clk arm_clk = {
+	.name               = "arm_clk",
+	.flag               = CLOCK_NOGATE,
+	.parent             = {&pll0_clk},
+	.prediv             = 1,
+	.div_reg_offset     = REG_PMU_CLK_DIV0,
+	.div_reg_mask       = 0xf,
+	.rst_reg_offset     = REG_PMU_SWRST_MAIN_CTRL,
+	.rst_reg_mask       = 0x1,
+};
+
+static struct clk arc_clk = {
+	.name               = "arc_clk",
+	.flag               = CLOCK_NOGATE | CLOCK_NODIV,
+	.parent             = {&pll0_clk},
+	.prediv             = 1,
+	.rst_reg_offset     = REG_PMU_SWRST_MAIN_CTRL,
+	.rst_reg_mask       = 0x400000,
+};
+
+/*
+ * BUS
+ */
+static struct clk axi_clk = {
+	.name               = "axi_clk",
+	.flag               = CLOCK_NOGATE | CLOCK_NODIV | CLOCK_NORESET,
+	.parent             = {&arm_clk},
+	.prediv             = 2,
+};
+
+static struct clk ahb_clk = {
+	.name               = "ahb_clk",
+	.flag               = CLOCK_NOGATE | CLOCK_NORESET,
+	.parent             = {&pll0_clk},
+	.prediv             = 2,
+	.div_reg_offset     = REG_PMU_CLK_DIV0,
+	.div_reg_mask       = 0xf0000,
+};
+
+static struct clk apb_clk = {
+	.name               = "apb_clk",
+	.flag               = CLOCK_NOGATE | CLOCK_NORESET | CLOCK_NODIV,
+	.parent             = {&ahb_clk},
+	.prediv             = 1,
+};
+
+
+/*
+ * ip
+ */
+static struct clk ddr_clk = {
+	.name               = "ddr_clk",
+	.parent             = {&pll0_clk},
+	.prediv             = 1,
+	.div_reg_offset     = REG_PMU_CLK_DIV1,
+	.div_reg_mask       = 0xf,
+	.en_reg_offset      = REG_PMU_CLK_GATE,
+	.en_reg_mask        = 0x40,
+	.rst_reg_offset     = REG_PMU_SWRST_MAIN_CTRL,
+	.rst_reg_mask       = 0x8,
+};
+
+static struct clk isp_aclk = {
+	.name               = "isp_aclk",
+	.flag               = CLOCK_NORESET,
+	.parent             = {&pll0_clk},
+	.prediv             = 1,
+	.div_reg_offset     = REG_PMU_CLK_DIV0,
+	.div_reg_mask       = 0xf00,
+	.en_reg_offset      = REG_PMU_CLK_GATE,
+	.en_reg_mask        = 0x1,
+};
+
+static struct clk pae_clk = {
+	.name               = "pae_clk",
+	.flag               = CLOCK_NORESET,
+	.parent             = {&pll0_clk},
+	.prediv             = 1,
+	.div_reg_offset     = REG_PMU_CLK_DIV0,
+	.div_reg_mask       = 0x7000000,
+	.en_reg_offset      = REG_PMU_CLK_GATE,
+	.en_reg_mask        = 0x10,
+};
+
+static struct clk bgm_clk = {
+	.name               = "bgm_clk",
+	.flag               = CLOCK_NORESET,
+	.parent             = {&isp_aclk},
+	.prediv             = 1,
+	.en_reg_offset      = REG_PMU_CLK_GATE,
+	.en_reg_mask        = 0x40000,
+};
+
+static struct clk cis_clk_out = {
+	.name               = "cis_clk_out",
+	.flag               = CLOCK_NORESET,
+	.parent             = {&pll0_clk},
+	.prediv             = 1,
+	.div_reg_offset     = REG_PMU_CLK_DIV1,
+	.div_reg_mask       = 0xff0000,
+	.en_reg_offset      = REG_PMU_CLK_GATE,
+	.en_reg_mask        = 0x800000,
+};
+
+static struct clk cis_clk_out_revert = {
+	.name               = "cis_clk_out_revert",
+	.flag               = CLOCK_NOGATE | CLOCK_NORESET | CLOCK_NODIV,
+	.parent             = {&cis_clk_out},
+	.prediv             = 1,
+};
+
+static struct clk mipi_dphy_clk = {
+	.name               = "mipi_dphy_clk",
+	.flag               = CLOCK_NORESET,
+	.parent             = {&pll0_clk},
+	.prediv             = 1,
+	.div_reg_offset     = REG_PMU_CLK_DIV2,
+	.div_reg_mask       = 0x1f0000,
+	.en_reg_offset      = REG_PMU_CLK_GATE,
+	.en_reg_mask        = 0x100000,
+};
+
+static struct clk mipi_pix_clk = {
+	.name               = "mipi_pix_clk",
+	.flag               = CLOCK_NORESET | CLOCK_NOGATE,
+	.parent             = {&pll0_clk},
+	.prediv             = 1,
+	.div_reg_offset     = REG_PMU_CLK_DIV2,
+	.div_reg_mask       = 0xf000000,
+};
+
+static struct clk pix_clk = {
+	.name               = "pix_clk",
+	.flag               = CLOCK_NORESET | CLOCK_NODIV | CLOCK_MULTI_PARENT,
+	.parent             = {&cis_clk_out, &cis_clk_out_revert, &mipi_pix_clk},
+	.prediv             = 1,
+	.sel_reg_offset     = REG_PMU_CLK_SEL,
+	.sel_reg_mask       = 0x30,
+	.en_reg_offset      = REG_PMU_CLK_GATE,
+	.en_reg_mask        = 0x400000,
+};
+
+static struct clk pts_clk = {
+	.name               = "pts_clk",
+	.parent             = {&pll1_clk},
+	.prediv             = 10,
+	.div_reg_offset     = REG_PMU_CLK_DIV2,
+	.div_reg_mask       = 0x1ff,
+	.en_reg_offset      = REG_PMU_CLK_GATE,
+	.en_reg_mask        = 0x80000,
+	.rst_reg_offset     = REG_PMU_SWRST_MAIN_CTRL,
+	.rst_reg_mask       = 0x20000,
+};
+
+static struct clk spi0_clk = {
+	.name               = "spi0_clk",
+	.parent             = {&pll1_clk},
+	.prediv             = 1,
+	.div_reg_offset     = REG_PMU_CLK_DIV3,
+	.div_reg_mask       = 0xff,
+	.en_reg_offset      = REG_PMU_CLK_GATE,
+	.en_reg_mask        = 0x80,
+	.rst_reg_offset     = REG_PMU_SWRST_MAIN_CTRL,
+	.rst_reg_mask       = 0x100,
+};
+
+static struct clk spi1_clk = {
+	.name               = "spi1_clk",
+	.parent             = {&pll1_clk},
+	.prediv             = 1,
+	.div_reg_offset     = REG_PMU_CLK_DIV3,
+	.div_reg_mask       = 0xff0000,
+	.en_reg_offset      = REG_PMU_CLK_GATE,
+	.en_reg_mask        = 0x100,
+	.rst_reg_offset     = REG_PMU_SWRST_MAIN_CTRL,
+	.rst_reg_mask       = 0x200,
+};
+
+static struct clk spi2_clk = {
+	.name               = "spi2_clk",
+	.parent             = {&pll1_clk},
+	.prediv             = 1,
+	.div_reg_offset     = REG_PMU_CLK_DIV3,
+	.div_reg_mask       = 0xf000,
+	.en_reg_offset      = REG_PMU_CLK_GATE,
+	.en_reg_mask        = 0x2,
+	.rst_reg_offset     = REG_PMU_SWRST_MAIN_CTRL,
+	.rst_reg_mask       = 0x100000,
+};
+
+static struct clk sdc0_clk = {
+	.name               = "sdc0_clk",
+	.parent             = {&pll1_clk},
+	.prediv             = 2,
+	.div_reg_offset     = REG_PMU_CLK_DIV3,
+	.div_reg_mask       = 0xf00,
+	.en_reg_offset      = REG_PMU_CLK_GATE,
+	.en_reg_mask        = 0x200,
+	.rst_reg_offset     = REG_PMU_SWRST_AHB_CTRL,
+	.rst_reg_mask       = 0x4,
+};
+
+static struct clk sdc1_clk = {
+	.name               = "sdc1_clk",
+	.parent             = {&pll1_clk},
+	.prediv             = 2,
+	.div_reg_offset     = REG_PMU_CLK_DIV3,
+	.div_reg_mask       = 0xf000000,
+	.en_reg_offset      = REG_PMU_CLK_GATE,
+	.en_reg_mask        = 0x400,
+	.rst_reg_offset     = REG_PMU_SWRST_AHB_CTRL,
+	.rst_reg_mask       = 0x2,
+};
+
+static struct clk uart0_clk = {
+	.name               = "uart0_clk",
+	.parent             = {&pll1_clk},
+	.prediv             = 10,
+	.div_reg_offset     = REG_PMU_CLK_DIV4,
+	.div_reg_mask       = 0x1f,
+	.en_reg_offset      = REG_PMU_CLK_GATE,
+	.en_reg_mask        = 0x2000,
+	.rst_reg_offset     = REG_PMU_SWRST_MAIN_CTRL,
+	.rst_reg_mask       = 0x4000,
+};
+
+static struct clk uart1_clk = {
+	.name               = "uart1_clk",
+	.parent             = {&pll1_clk},
+	.prediv             = 10,
+	.div_reg_offset     = REG_PMU_CLK_DIV4,
+	.div_reg_mask       = 0x1f00,
+	.en_reg_offset      = REG_PMU_CLK_GATE,
+	.en_reg_mask        = 0x4000,
+	.rst_reg_offset     = REG_PMU_SWRST_MAIN_CTRL,
+	.rst_reg_mask       = 0x8000,
+};
+
+static struct clk i2c0_clk = {
+	.name               = "i2c0_clk",
+	.parent             = {&pll1_clk},
+	.prediv             = 20,
+	.div_reg_offset     = REG_PMU_CLK_DIV4,
+	.div_reg_mask       = 0x3f0000,
+	.en_reg_offset      = REG_PMU_CLK_GATE,
+	.en_reg_mask        = 0x1000,
+	.rst_reg_offset     = REG_PMU_SWRST_MAIN_CTRL,
+	.rst_reg_mask       = 0x400,
+};
+
+static struct clk i2c1_clk = {
+	.name               = "i2c1_clk",
+	.parent             = {&pll1_clk},
+	.prediv             = 20,
+	.div_reg_offset     = REG_PMU_CLK_DIV4,
+	.div_reg_mask       = 0x3f000000,
+	.en_reg_offset      = REG_PMU_CLK_GATE,
+	.en_reg_mask        = 0x8000000,
+	.rst_reg_offset     = REG_PMU_SWRST_MAIN_CTRL,
+	.rst_reg_mask       = 0x800,
+};
+
+static struct clk pwm_clk = {
+	.name               = "pwm_clk",
+	.parent             = {&pll1_clk},
+	.prediv             = 2,
+	.div_reg_offset     = REG_PMU_CLK_DIV5,
+	.div_reg_mask       = 0xff,
+	.en_reg_offset      = REG_PMU_CLK_GATE,
+	.en_reg_mask        = 0x10000,
+	.rst_reg_offset     = REG_PMU_SWRST_MAIN_CTRL,
+	.rst_reg_mask       = 0x80,
+	.def_rate	    = 25000000,
+};
+
+static struct clk wdt_clk = {
+	.name               = "wdt_clk",
+	.flag               = CLOCK_NOGATE,
+	.parent             = {&ahb_clk},
+	.prediv             = 1,
+	.div_reg_offset     = REG_PMU_CLK_DIV5,
+	.div_reg_mask       = 0xff00,
+	.rst_reg_offset     = REG_PMU_SWRST_APB_CTRL,
+	.rst_reg_mask       = 0x100000,
+};
+
+
+static struct clk tmr0_clk = {
+	.name               = "tmr0_clk",
+	.parent             = {&pll1_clk},
+	.prediv             = 10,
+	.div_reg_offset     = REG_PMU_CLK_DIV5,
+	.div_reg_mask       = 0xff0000,
+	.en_reg_offset      = REG_PMU_CLK_GATE,
+	.en_reg_mask        = 0x20000,
+	.rst_reg_offset     = REG_PMU_SWRST_MAIN_CTRL,
+	.rst_reg_mask       = 0x40000,
+};
+
+static struct clk ac_clk = {
+	.name               = "ac_clk",
+	.parent             = {&pll1_clk},
+	.prediv             = 1,
+	.div_reg_offset     = REG_PMU_CLK_DIV6,
+	.div_reg_mask       = 0x3f,
+	.en_reg_offset      = REG_PMU_CLK_GATE,
+	.en_reg_mask        = 0x800,
+	.rst_reg_offset     = REG_PMU_SWRST_MAIN_CTRL,
+	.rst_reg_mask       = 0x1000,
+};
+
+static struct clk i2s_clk = {
+	.name               = "i2s_clk",
+	.parent             = {&ac_clk},
+	.prediv             = 1,
+	.div_reg_offset     = REG_PMU_CLK_DIV6,
+	.div_reg_mask       = 0x3f00,
+	.en_reg_offset      = REG_PMU_CLK_GATE,
+	.en_reg_mask        = 0x1000000,
+	.rst_reg_offset     = REG_PMU_SWRST_MAIN_CTRL,
+	.rst_reg_mask       = 0x2000,
+};
+
+static struct clk sadc_clk = {
+	.name               = "sadc_clk",
+	.parent             = {&pll1_clk},
+	.prediv             = 1,
+	.div_reg_offset     = REG_PMU_CLK_DIV6,
+	.div_reg_mask       = 0x7f0000,
+	.en_reg_offset      = REG_PMU_CLK_GATE,
+	.en_reg_mask        = 0x4000000,
+	.rst_reg_offset     = REG_PMU_SWRST_MAIN_CTRL,
+	.rst_reg_mask       = 0x10000,
+};
+
+static struct clk eth_clk = {
+	.name               = "eth_clk",
+	.parent             = {&pll1_clk},
+	.prediv             = 2,
+	.div_reg_offset     = REG_PMU_CLK_DIV6,
+	.div_reg_mask       = 0xf000000,
+	.en_reg_offset      = REG_PMU_CLK_GATE,
+	.en_reg_mask        = 0x72000000,
+	.rst_reg_offset     = REG_PMU_SWRST_AHB_CTRL,
+	.rst_reg_mask       = 0x20000,
+};
+
+static struct clk efuse_clk = {
+	.name               = "efuse_clk",
+	.parent             = {&pll1_clk},
+	.prediv             = 1,
+	.div_reg_offset     = REG_PMU_CLK_DIV1,
+	.div_reg_mask       = 0x3f000000,
+	.en_reg_offset      = REG_PMU_CLK_GATE,
+	.en_reg_mask        = 0x200000,
+	.rst_reg_offset     = REG_PMU_SWRST_MAIN_CTRL,
+	.rst_reg_mask       = 0x800000,
+};
+
+struct clk_lookup fh_clks[] = {
+	CLK(NULL, "osc_clk", &osc_clk),
+	CLK(NULL, "pll0_clk", &pll0_clk),
+	CLK(NULL, "pll1_clk", &pll1_clk),
+
+	CLK(NULL, "arm_clk", &arm_clk),
+	CLK(NULL, "arc_clk", &arc_clk),
+	CLK(NULL, "axi_clk", &axi_clk),
+	CLK(NULL, "ahb_clk", &ahb_clk),
+	CLK(NULL, "apb_clk", &apb_clk),
+
+	CLK(NULL, "ddr_clk", &ddr_clk),
+	CLK(NULL, "isp_aclk", &isp_aclk),
+	CLK(NULL, "pae_clk", &pae_clk),
+	CLK(NULL, "bgm_clk", &bgm_clk),
+
+	CLK(NULL, "cis_clk_out", &cis_clk_out),
+	CLK(NULL, "cis_clk_out_revert", &cis_clk_out_revert),
+	CLK(NULL, "mipi_dphy_clk", &mipi_dphy_clk),
+	CLK(NULL, "mipi_pix_clk", &mipi_pix_clk),
+	CLK(NULL, "pix_clk", &pix_clk),
+	CLK(NULL, "pts_clk", &pts_clk),
+
+	CLK(NULL, "spi0_clk", &spi0_clk),
+	CLK(NULL, "spi1_clk", &spi1_clk),
+	CLK(NULL, "spi2_clk", &spi2_clk),
+	CLK(NULL, "sdc0_clk", &sdc0_clk),
+	CLK(NULL, "sdc1_clk", &sdc1_clk),
+	CLK(NULL, "uart0_clk", &uart0_clk),
+	CLK(NULL, "uart1_clk", &uart1_clk),
+	CLK(NULL, "i2c0_clk", &i2c0_clk),
+	CLK(NULL, "i2c1_clk", &i2c1_clk),
+	CLK(NULL, "pwm_clk", &pwm_clk),
+	CLK(NULL, "wdt_clk", &wdt_clk),
+	CLK(NULL, "tmr0_clk", &tmr0_clk),
+	CLK(NULL, "ac_clk", &ac_clk),
+	CLK(NULL, "i2s_clk", &i2s_clk),
+	CLK(NULL, "sadc_clk", &sadc_clk),
+	CLK(NULL, "eth_clk", &eth_clk),
+	CLK(NULL, "efuse_clk", &efuse_clk),
+
+	CLK(NULL, NULL, NULL),
+};
+
+EXPORT_SYMBOL(fh_clks);
diff -uraN linux-3.0.8/arch/arm/mach-fh/fh_simple_timer.c linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/fh_simple_timer.c
--- linux-3.0.8/arch/arm/mach-fh/fh_simple_timer.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/fh_simple_timer.c	2021-07-13 23:40:30.646336791 +0300
@@ -0,0 +1,165 @@
+#include <linux/module.h>
+#include <mach/fh_simple_timer.h>
+
+//#define  FH_TIMER_DEBUG
+#ifdef FH_TIMER_DEBUG
+#define PRINT_DBG(fmt,args...)  printk(fmt,##args)
+#else
+#define PRINT_DBG(fmt,args...)  do{} while(0)
+#endif
+
+struct simple_time_base
+{
+	struct timerqueue_head	simple_timer_queue;
+	int state;
+};
+
+struct simple_time_base base;
+
+static void fh_timer_enable(void)
+{
+	SET_REG(VTIMER(REG_TIMER_CTRL_REG(SIMPLE_TIMER_BASE)), 0x3);
+}
+
+static void fh_timer_disable(void)
+{
+	SET_REG(VTIMER(REG_TIMER_CTRL_REG(SIMPLE_TIMER_BASE)), 0x0);
+}
+
+static void fh_timer_clearirq(void)
+{
+	GET_REG(VTIMER(REG_TIMER_EOI_REG(SIMPLE_TIMER_BASE)));
+}
+
+void fh_simple_timer_set_next(long cycles)
+{
+	long curr_val;
+
+	PRINT_DBG("cycles: %lu\n", cycles);
+
+	if(cycles < 0)
+	{
+		pr_err("ERROR: cycles is invaild: %lu\n", cycles);
+		fh_timer_clearirq();
+		fh_timer_disable();
+		base.state = SIMPLE_TIMER_ERROR;
+		return;
+	}
+
+	SET_REG_M(VTIMER(REG_TIMER_CTRL_REG(SIMPLE_TIMER_BASE)), 0x00, 0x0);
+	SET_REG(VTIMER(REG_TIMER_LOADCNT(SIMPLE_TIMER_BASE)), cycles);
+	SET_REG_M(VTIMER(REG_TIMER_CTRL_REG(SIMPLE_TIMER_BASE)), 0x01, 0x1);
+#ifdef CONFIG_USE_PTS_AS_CLOCKSOURCE
+	curr_val = GET_REG(VTIMER(REG_TIMER_CUR_VAL(SIMPLE_TIMER_BASE))) ;
+	if (curr_val >  0x80000000) { ///0xffff0000)
+		panic("timer curr %lu, want cycles %lu\n", curr_val, cycles);
+
+		SET_REG_M(VTIMER(REG_TIMER_CTRL_REG(SIMPLE_TIMER_BASE)), 0x01, 0x1);
+		SET_REG(VTIMER(REG_TIMER_LOADCNT(SIMPLE_TIMER_BASE)), cycles);
+
+		//pmu reset
+		fh_pmu_set_reg(REG_PMU_SWRST_MAIN_CTRL, 0xfffbffff);
+		while (fh_pmu_get_reg(REG_PMU_SWRST_MAIN_CTRL) != 0xffffffff) {
+
+		}
+	}
+
+	fh_pmu_set_reg(REG_PMU_SWRST_MAIN_CTRL, 0xfffbffff);
+	while (fh_pmu_get_reg(REG_PMU_SWRST_MAIN_CTRL) != 0xffffffff) {
+
+	}
+#endif
+
+}
+
+int fh_simple_timer_create(struct fh_simple_timer* new)
+{
+	if(base.state == SIMPLE_TIMER_START)
+	{
+		pr_err("ERROR: simple timer is working\n");
+		return 0;
+	}
+	timerqueue_init(&new->node);
+	new->node.expires = new->it_value;
+	timerqueue_add(&base.simple_timer_queue, &new->node);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(fh_simple_timer_create);
+
+int fh_timer_start(void)
+{
+	struct fh_simple_timer *timer = NULL;
+	struct timerqueue_node *node;
+
+	node = timerqueue_getnext(&base.simple_timer_queue);
+
+	if(node == NULL)
+	{
+		pr_err("ERROR: timequeue is empty\n");
+		return -1;
+	}
+
+	timer = container_of(node, struct fh_simple_timer, node);
+
+	base.state = SIMPLE_TIMER_START;
+	fh_timer_enable();
+	fh_simple_timer_set_next(ktime_to_us(ktime_sub(timer->it_value, timer->it_delay)));
+	return 0;
+}
+EXPORT_SYMBOL_GPL(fh_timer_start);
+
+int fh_simple_timer_interrupt(void)
+{
+	ktime_t diff;
+	struct fh_simple_timer *curr = NULL, *next = NULL;
+	struct timerqueue_node *node;
+
+	node = timerqueue_getnext(&base.simple_timer_queue);
+
+	if(node == NULL)
+	{
+		pr_err("ERROR: timequeue is empty\n");
+		fh_timer_clearirq();
+		fh_timer_disable();
+		base.state = SIMPLE_TIMER_ERROR;
+		return -1;
+	}
+
+	curr = container_of(node, struct fh_simple_timer, node);
+
+	timerqueue_del(&base.simple_timer_queue, &curr->node);
+
+	curr->function(curr->param);
+
+	node = timerqueue_getnext(&base.simple_timer_queue);
+
+	if(node == NULL)
+	{
+		PRINT_DBG("finished all timers, close device\n");
+		fh_timer_clearirq();
+		fh_timer_disable();
+		base.state = SIMPLE_TIMER_STOP;
+		return 0;
+	}
+
+	next = container_of(node, struct fh_simple_timer, node);
+
+	PRINT_DBG("sec: %lu, nsec: %lu\n", ktime_to_timespec(next->it_value).tv_sec,
+			ktime_to_timespec(next->it_value).tv_nsec);
+
+	diff = ktime_sub(next->it_value, curr->it_value);
+
+	fh_simple_timer_set_next(ktime_to_us(ktime_sub(diff, next->it_delay)));
+	fh_timer_clearirq();
+	return 0;
+}
+
+
+int fh_simple_timer_init(void)
+{
+	base.state = SIMPLE_TIMER_STOP;
+	timerqueue_init_head(&base.simple_timer_queue);
+	fh_timer_disable();
+	return 0;
+}
+EXPORT_SYMBOL_GPL(fh_simple_timer_init);
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/board_config.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/board_config.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/board_config.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/board_config.h	2021-07-13 23:40:30.654336845 +0300
@@ -0,0 +1,40 @@
+/*
+ * board_config.h
+ *
+ *  Created on: Jan 9, 2017
+ *      Author: duobao
+ */
+
+#ifndef BOARD_CONFIG_H_
+#define BOARD_CONFIG_H_
+
+/*
+ * GPIO0  -> IRCUT_ON
+ * GPIO1  -> IRCUT_OFF
+ * GPIO2  -> PHY Reset
+ * GPIO3  -> IR
+ * GPIO13 -> Sensor Reset
+ * GPIO14 -> Sensor Power Down
+ * GPIO55 -> CSN1
+ */
+
+#define CONFIG_GPIO_EMACPHY_RESET	2
+#define CONFIG_GPIO_EMACPHY_RXDV	41
+#define CONFIG_SD_WP_FIXED
+
+#define CONFIG_PINCTRL_SELECT					\
+	"MIPI", "RMII", "UART0", "DWI2S",		\
+	"I2C0", "SSI0", "SD0_CARD_1BIT",			\
+	"GPIO0", "GPIO1", "GPIO2", "GPIO3",			\
+	"GPIO13",						\
+								\
+	"GPIO4", "GPIO11", "GPIO5", "GPIO6", "GPIO7",		\
+	"GPIO8", "GPIO9", "GPIO10", "GPIO14", "GPIO19",		\
+	"GPIO20", "GPIO21", "GPIO23", "GPIO28", "GPIO29",	\
+	"GPIO30", "GPIO31", "GPIO32", "GPIO33", "GPIO35",	\
+	"GPIO36", "GPIO37", "GPIO39", "GPIO40", "GPIO44",	\
+	"GPIO45", "GPIO47", "GPIO50", "GPIO51",	"GPIO55",	\
+	"GPIO61",						\
+    
+    
+#endif /* BOARD_CONFIG_H_ */
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/chip.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/chip.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/chip.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/chip.h	2021-07-13 23:40:30.654336845 +0300
@@ -0,0 +1,19 @@
+/*****************************************************************************
+*
+*                                  chip.h
+*
+*	Copyright (c) 2010 Shanghai Fullhan Microelectronics Co., Ltd.
+*						All Rights Reserved. Confidential.
+*
+*	File Description:
+*		Chip definition. Include the base address of each module, memory
+*		address, memory size
+*
+*	Modification History:
+*
+******************************************************************************/
+#ifndef _CHIP_H_
+#define _CHIP_H_
+
+#include <mach/fh8833.h>
+#endif
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/clkdev.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/clkdev.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/clkdev.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/clkdev.h	2021-07-13 23:40:30.650336818 +0300
@@ -0,0 +1,15 @@
+#ifndef __MACH_CLKDEV_H
+#define __MACH_CLKDEV_H
+
+struct clk;
+
+static inline int __clk_get(struct clk *clk)
+{
+	return 1;
+}
+
+static inline void __clk_put(struct clk *clk)
+{
+}
+
+#endif
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/clock.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/clock.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/clock.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/clock.h	2021-07-13 23:40:30.650336818 +0300
@@ -0,0 +1,89 @@
+/*
+ *	Copyright (c) 2010 Shanghai Fullhan Microelectronics Co., Ltd.
+ *				All Rights Reserved. Confidential.
+ *
+ *This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ASM_ARCH_FH_CLOCK_H
+#define __ASM_ARCH_FH_CLOCK_H
+
+#include <linux/list.h>
+#include <linux/clkdev.h>
+
+#define CLOCK_MAX_PARENT    4
+
+#define OSC_FREQUENCY		(24000000)
+
+#define CLOCK_FIXED         	(1<<0)
+#define CLOCK_NOGATE        	(1<<1)
+#define CLOCK_NODIV         	(1<<2)
+#define CLOCK_NORESET       	(1<<3)
+#define CLOCK_MULTI_PARENT  	(1<<4)
+#define CLOCK_PLL		(1<<5)
+
+
+#define CLK_IOCTL_MAGIC 		'c'
+#define ENABLE_CLK	 		_IOWR(CLK_IOCTL_MAGIC, 0, unsigned int)
+#define DISABLE_CLK		 	_IOWR(CLK_IOCTL_MAGIC, 1, unsigned int)
+#define SET_CLK_RATE			_IOWR(CLK_IOCTL_MAGIC, 2, unsigned int)
+#define GET_CLK_RATE			_IOWR(CLK_IOCTL_MAGIC, 3, unsigned int)
+#define SET_PMU				_IOWR(CLK_IOCTL_MAGIC, 4, unsigned int)
+#define GET_PMU				_IOWR(CLK_IOCTL_MAGIC, 5, unsigned int)
+
+#define CLK_IOCTL_MAXNR 		8
+
+
+#define CLK(dev, con, ck) 	\
+		{					\
+			.dev_id = dev,	\
+			.con_id = con,	\
+			.clk = ck,		\
+		}
+
+struct clk_usr {
+	char			*name;
+	unsigned long       	frequency;
+};
+
+
+struct clk {
+	struct list_head    list;
+	const char          *name;
+	unsigned long       frequency;
+	unsigned int        flag;
+	int                 select;
+	struct clk         *parent[CLOCK_MAX_PARENT];
+	int                 prediv;
+	int                 divide;
+	unsigned int        div_reg_offset;
+	unsigned int        div_reg_mask;
+	unsigned int        en_reg_offset;
+	unsigned int        en_reg_mask;
+	unsigned int        rst_reg_offset;
+	unsigned int        rst_reg_mask;
+	unsigned int        sel_reg_offset;
+	unsigned int        sel_reg_mask;
+	unsigned int        def_rate;
+};
+
+extern int clk_register(struct clk *clk);
+extern void clk_unregister(struct clk *clk);
+
+void clk_set_clk_sel(unsigned int reg);
+unsigned int clk_get_clk_sel(void);
+
+int fh_clk_init(void);
+int fh_clk_procfs_init(void);
+int fh_clk_misc_init(void);
+
+extern struct clk_lookup fh_clks[];
+
+#endif
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/ddrc.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/ddrc.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/ddrc.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/ddrc.h	2021-07-13 23:40:30.650336818 +0300
@@ -0,0 +1,30 @@
+/*
+ *	Copyright (c) 2010 Shanghai Fullhan Microelectronics Co., Ltd.
+ *				All Rights Reserved. Confidential.
+ *
+ *This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef DDRC_H_
+#define DDRC_H_
+
+#define OFFSET_DENAL_CTL_31         (0x007c)
+#define OFFSET_DENAL_CTL_57         (0x00e4)
+#define OFFSET_DENAL_CTL_97         (0x0184)
+
+#define DDRC_CONTROLLER_BUSY        (1 << 24)
+#define DDRC_CKE_STATUS             (1 << 8)
+
+#define DDRC_LP_CMD_SELFREFRESH     (10 << 8)
+#define DDRC_LP_CMD_EXITLOWPOWER    (1 << 8)
+
+#define DDRC_LPI_SR_WAKEUP_TIME     (3 << 24)
+#define DDRC_CKSRX_DELAY            (1 << 0)
+
+#endif /* DDRC_H_ */
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/debug-macro.S linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/debug-macro.S
--- linux-3.0.8/arch/arm/mach-fh/include/mach/debug-macro.S	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/debug-macro.S	2021-07-13 23:40:30.650336818 +0300
@@ -0,0 +1,50 @@
+/* linux/arch/arm/mach-fh/include/mach/debug-macro.S
+ *
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+/* pull in the relevant register and map files. */
+
+	/* note, for the boot process to work we have to keep the UART
+	 * virtual address aligned to an 1MiB boundary for the L1
+	 * mapping the head code makes. We keep the UART virtual address
+	 * aligned and add in the offset when we load the value here.
+	 */
+
+
+#include <linux/serial_reg.h>
+#include <mach/hardware.h>
+#include <asm/memory.h>
+#include <mach/chip.h>
+
+#include <mach/io.h>
+
+	.macro addruart, rp, rv
+		ldr	\rp, =CONSOLE_REG_BASE
+		ldr	\rv, =VA_CONSOLE_REG_BASE
+	.endm
+
+ 	.macro senduart,data,addr
+        	strb      \data, [\addr, #(0x00)]           @ Write to Transmitter Holding Register
+ 	.endm
+
+  	.macro waituart,data,addr
+1001:   	ldr \data, [\addr, #(0x14)]                 @ Read Status Register
+        	tst \data, #(0x40)                               @when TX FIFO Full, then wait
+		beq 1001b
+  	.endm
+
+ 	.macro busyuart,data,addr
+@		stmfd r13!, {r4}
+1002:
+		ldr	\data, [\addr, #(0x14)]
+		tst	\data, #(0x40)
+		beq	1002b
+	.endm
+
+
+
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/entry-macro.S linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/entry-macro.S
--- linux-3.0.8/arch/arm/mach-fh/include/mach/entry-macro.S	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/entry-macro.S	2021-07-13 23:40:30.654336845 +0300
@@ -0,0 +1,31 @@
+#include <mach/io.h>
+#include <mach/irqs.h>
+
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		ldr \base, =VA_INTC_REG_BASE
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		@ check low interrupts
+		ldr		\irqstat, [\base, #0x30]
+		mov		\irqnr, #31
+		ands	\irqstat, \irqstat, #0xffffffff
+
+		@ if no low interrupts set, check high interrupts
+		ldreq	\irqstat, [\base, #0x34]
+		moveq	\irqnr, #63
+		andeqs	\irqstat, \irqstat, #0xffffffff
+
+		@ find first active interrupt source
+		clzne	\irqstat, \irqstat
+		subne	\irqnr, \irqnr, \irqstat
+		.endm
+
+		.macro	irq_prio_table
+		.endm
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/fh8833.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/fh8833.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/fh8833.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/fh8833.h	2021-07-13 23:40:30.650336818 +0300
@@ -0,0 +1,249 @@
+/*
+ *
+ * Copyright (C) 2015 Fullhan.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ASM_ARCH_FH8833_H
+#define __ASM_ARCH_FH8833_H
+
+#include <linux/init.h>
+
+#define SRAM_GRANULARITY		32
+#define SRAM_SIZE			SZ_32K
+
+#define SIMPLE_TIMER_BASE		2
+
+#define RAM_BASE			(0x10000000)
+#define DDR_BASE			(0xA0000000)
+
+#define PMU_REG_BASE			(0xF0000000)
+#define TIMER_REG_BASE			(0xF0C00000)
+#define GPIO0_REG_BASE			(0xF0300000)
+#define GPIO1_REG_BASE			(0xF4000000)
+#define UART0_REG_BASE			(0xF0700000)
+#define UART1_REG_BASE			(0xF0800000)
+#define SPI0_REG_BASE			(0xF0500000)
+#define SPI1_REG_BASE			(0xF0600000)
+#define SPI2_REG_BASE			(0xF0640000)
+#define INTC_REG_BASE			(0xE0200000)
+#define GMAC_REG_BASE			(0xE0600000)
+#define DMAC_REG_BASE			(0xE0300000)
+#define I2C1_REG_BASE			(0xF0B00000)
+#define I2C0_REG_BASE			(0xF0200000)
+#define SDC0_REG_BASE			(0xE2000000)
+#define SDC1_REG_BASE			(0xE2200000)
+#define WDT_REG_BASE			(0xF0D00000)
+#define PWM_REG_BASE			(0xF0400000)
+#define PAE_REG_BASE			(0xE7000000)
+#define I2S_REG_BASE			(0xF0900000)
+#define ACW_REG_BASE			(0xF0A00000)
+#define SADC_REG_BASE			(0xF1200000)
+#define EFUSE_REG_BASE			(0xF1600000)
+#define AES_REG_BASE			(0xE8200000)
+#define RTC_REG_BASE			(0xF1500000)
+#define DDRC_REG_BASE			(0xED000000)
+#define CONSOLE_REG_BASE		UART0_REG_BASE
+#define FH_UART_NUMBER			2
+
+#define PMU_REG_SIZE                  0x2018
+#define PMU_DEBUG
+
+#define REG_PMU_CHIP_ID                  (0x0000)
+#define REG_PMU_IP_VER                   (0x0004)
+#define REG_PMU_FW_VER                   (0x0008)
+#define REG_PMU_SYS_CTRL                 (0x000c)
+#define REG_PMU_PLL0                     (0x0010)
+#define REG_PMU_PLL1                     (0x0014)
+#define REG_PMU_PLL2                     (0x0018)
+#define REG_PMU_CLK_GATE                 (0x001c)
+#define REG_PMU_CLK_SEL                  (0x0020)
+#define REG_PMU_CLK_DIV0                 (0x0024)
+#define REG_PMU_CLK_DIV1                 (0x0028)
+#define REG_PMU_CLK_DIV2                 (0x002c)
+#define REG_PMU_CLK_DIV3                 (0x0030)
+#define REG_PMU_CLK_DIV4                 (0x0034)
+#define REG_PMU_CLK_DIV5                 (0x0038)
+#define REG_PMU_CLK_DIV6                 (0x003c)
+#define REG_PMU_SWRST_MAIN_CTRL          (0x0040)
+#define REG_PMU_SWRST_AXI_CTRL           (0x0044)
+#define REG_PMU_SWRST_AHB_CTRL           (0x0048)
+#define REG_PMU_SWRST_APB_CTRL           (0x004c)
+#define REG_PMU_SPC_IO_STATUS            (0x0054)
+#define REG_PMU_SPC_FUN                  (0x0058)
+#define REG_PMU_DBG_SPOT0                (0x005c)
+#define REG_PMU_DBG_SPOT1                (0x0060)
+#define REG_PMU_DBG_SPOT2                (0x0064)
+#define REG_PMU_DBG_SPOT3                (0x0068)
+
+#define REG_PMU_PAD_CIS_HSYNC_CFG        (0x0080)
+#define REG_PMU_PAD_CIS_VSYNC_CFG        (0x0084)
+#define REG_PMU_PAD_CIS_PCLK_CFG         (0x0088)
+#define REG_PMU_PAD_CIS_D_0_CFG          (0x008c)
+#define REG_PMU_PAD_CIS_D_1_CFG          (0x0090)
+#define REG_PMU_PAD_CIS_D_2_CFG          (0x0094)
+#define REG_PMU_PAD_CIS_D_3_CFG          (0x0098)
+#define REG_PMU_PAD_CIS_D_4_CFG          (0x009c)
+#define REG_PMU_PAD_CIS_D_5_CFG          (0x00a0)
+#define REG_PMU_PAD_CIS_D_6_CFG          (0x00a4)
+#define REG_PMU_PAD_CIS_D_7_CFG          (0x00a8)
+#define REG_PMU_PAD_CIS_D_8_CFG          (0x00ac)
+#define REG_PMU_PAD_CIS_D_9_CFG          (0x00b0)
+#define REG_PMU_PAD_CIS_D_10_CFG         (0x00b4)
+#define REG_PMU_PAD_CIS_D_11_CFG         (0x00b8)
+#define REG_PMU_PAD_MAC_RMII_CLK_CFG     (0x00bc)
+#define REG_PMU_PAD_MAC_REF_CLK_CFG      (0x00c0)
+#define REG_PMU_PAD_MAC_MDC_CFG          (0x00c4)
+#define REG_PMU_PAD_MAC_MDIO_CFG         (0x00c8)
+#define REG_PMU_PAD_MAC_COL_MII_CFG      (0x00cc)
+#define REG_PMU_PAD_MAC_CRS_MII_CFG      (0x00d0)
+#define REG_PMU_PAD_MAC_RXCK_CFG         (0x00d4)
+#define REG_PMU_PAD_MAC_RXD0_CFG         (0x00d8)
+#define REG_PMU_PAD_MAC_RXD1_CFG         (0x00dc)
+#define REG_PMU_PAD_MAC_RXD2_MII_CFG     (0x00e0)
+#define REG_PMU_PAD_MAC_RXD3_MII_CFG     (0x00e4)
+#define REG_PMU_PAD_MAC_RXDV_CFG         (0x00e8)
+#define REG_PMU_PAD_MAC_TXCK_CFG         (0x00ec)
+#define REG_PMU_PAD_MAC_TXD0_CFG         (0x00f0)
+#define REG_PMU_PAD_MAC_TXD1_CFG         (0x00f4)
+#define REG_PMU_PAD_MAC_TXD2_MII_CFG     (0x00f8)
+#define REG_PMU_PAD_MAC_TXD3_MII_CFG     (0x00fc)
+#define REG_PMU_PAD_MAC_TXEN_CFG         (0x0100)
+#define REG_PMU_PAD_MAC_RXER_MII_CFG     (0x0104)
+#define REG_PMU_PAD_MAC_TXER_MII_CFG     (0x0108)
+#define REG_PMU_PAD_GPIO_0_CFG           (0x010c)
+#define REG_PMU_PAD_GPIO_1_CFG           (0x0110)
+#define REG_PMU_PAD_GPIO_2_CFG           (0x0114)
+#define REG_PMU_PAD_GPIO_3_CFG           (0x0118)
+#define REG_PMU_PAD_GPIO_4_CFG           (0x011c)
+#define REG_PMU_PAD_GPIO_5_CFG           (0x0120)
+#define REG_PMU_PAD_GPIO_6_CFG           (0x0124)
+#define REG_PMU_PAD_GPIO_7_CFG           (0x0128)
+#define REG_PMU_PAD_GPIO_8_CFG           (0x012c)
+#define REG_PMU_PAD_GPIO_9_CFG           (0x0130)
+#define REG_PMU_PAD_GPIO_10_CFG          (0x0134)
+#define REG_PMU_PAD_GPIO_11_CFG          (0x0138)
+#define REG_PMU_PAD_GPIO_12_CFG          (0x013c)
+#define REG_PMU_PAD_GPIO_13_CFG          (0x0140)
+#define REG_PMU_PAD_GPIO_14_CFG          (0x0144)
+#define REG_PMU_PAD_UART_RX_CFG          (0x0148)
+#define REG_PMU_PAD_UART_TX_CFG          (0x014c)
+#define REG_PMU_PAD_CIS_SCL_CFG          (0x0150)
+#define REG_PMU_PAD_CIS_SDA_CFG          (0x0154)
+#define REG_PMU_PAD_I2C_SCL_CFG          (0x0158)
+#define REG_PMU_PAD_I2C_SDA_CFG          (0x015c)
+#define REG_PMU_PAD_SSI0_CLK_CFG         (0x0160)
+#define REG_PMU_PAD_SSI0_TXD_CFG         (0x0164)
+#define REG_PMU_PAD_SSI0_CSN_0_CFG       (0x0168)
+#define REG_PMU_PAD_SSI0_CSN_1_CFG       (0x016c)
+#define REG_PMU_PAD_SSI0_RXD_CFG         (0x0170)
+#define REG_PMU_PAD_SD0_CD_CFG           (0x0174)
+#define REG_PMU_PAD_SD0_WP_CFG           (0x0178)
+#define REG_PMU_PAD_SD0_CLK_CFG          (0x017c)
+#define REG_PMU_PAD_SD0_CMD_RSP_CFG      (0x0180)
+#define REG_PMU_PAD_SD0_DATA_0_CFG       (0x0184)
+#define REG_PMU_PAD_SD0_DATA_1_CFG       (0x0188)
+#define REG_PMU_PAD_SD0_DATA_2_CFG       (0x018c)
+#define REG_PMU_PAD_SD0_DATA_3_CFG       (0x0190)
+#define REG_PMU_PAD_SD1_CD_CFG           (0x0194)
+#define REG_PMU_PAD_SD1_WP_CFG           (0x0198)
+#define REG_PMU_PAD_SD1_CLK_CFG          (0x019c)
+#define REG_PMU_PAD_SD1_CMD_RSP_CFG      (0x01a0)
+#define REG_PMU_PAD_SD1_DATA_0_CFG       (0x01a4)
+#define REG_PMU_PAD_SD1_DATA_1_CFG       (0x01a8)
+#define REG_PMU_PAD_SD1_DATA_2_CFG       (0x01ac)
+#define REG_PMU_PAD_SD1_DATA_3_CFG       (0x01b0)
+#define REG_PMU_AXI0_PRIO_CFG0           (0x01b4)
+#define REG_PMU_AXI0_PRIO_CFG1           (0x01b8)
+#define REG_PMU_AXI1_PRIO_CFG0           (0x01bc)
+#define REG_PMU_AXI1_PRIO_CFG1           (0x01c0)
+#define REG_PMU_SWRSTN_NSR               (0x01c4)
+#define REG_PMU_ARM_INT_0                (0x01e0)
+#define REG_PMU_ARM_INT_1                (0x01e4)
+#define REG_PMU_ARM_INT_2                (0x01e8)
+#define REG_PMU_A625_INT_0               (0x01ec)
+#define REG_PMU_A625_INT_1               (0x01f0)
+#define REG_PMU_A625_INT_2               (0x01f4)
+#define REG_PMU_DMA                      (0x01f8)
+#define REG_PMU_WDT_CTRL                 (0x01fc)
+#define REG_PMU_DBG_STAT0                (0x0200)
+#define REG_PMU_DBG_STAT1                (0x0204)
+#define REG_PMU_DBG_STAT2                (0x0208)
+#define REG_PMU_DBG_STAT3                (0x020c)
+#define REG_PMU_PAD_CIS_CLK_CFG          (0x021c)
+#define REG_PMU_PAEARCBOOT0              (0x1000)
+#define REG_PMU_PAEARCBOOT1              (0x1004)
+#define REG_PMU_PAEARCBOOT2              (0x1008)
+#define REG_PMU_PAEARCBOOT3              (0x100c)
+#define REG_PMU_PAE_ARC_START_CTRL       (0x1010)
+#define REG_PMU_A625BOOT0                (0x2000)
+#define REG_PMU_A625BOOT1                (0x2004)
+#define REG_PMU_A625BOOT2                (0x2008)
+#define REG_PMU_A625BOOT3                (0x200c)
+#define REG_PMU_A625_START_CTRL          (0x2010)
+#define REG_PMU_ARC_INTC_MASK            (0x2014)
+#define REG_PMU_PAE_ARC_INTC_MASK        (0x2018)
+
+/*ATTENTION: written by ARC */
+#define PMU_ARM_INT_MASK             (0x01e0)
+#define PMU_ARM_INT_RAWSTAT          (0x01e4)
+#define PMU_ARM_INT_STAT             (0x01e8)
+
+#define PMU_A625_INT_MASK             (0x01ec)
+#define PMU_A625_INT_RAWSTAT          (0x01f0)
+#define PMU_A625_INT_STAT             (0x01f4)
+
+#define ARM_PMU_IRQ		0
+#define DDRC_IRQ		1
+#define WDT_IRQ			2
+#define TMR0_IRQ		3
+#define PAE_ARC_IRQ0		4
+#define PAE_ARC_IRQ1		5
+#define PAE_ARC_IRQ2		6
+#define ISPP_IRQ		7
+#define ISPF_IRQ		8
+#define VPU_IRQ			9
+#define PAE_IRQ			10
+#define I2C0_IRQ		11
+#define I2C1_IRQ		12
+#define JPEG_IRQ		13
+#define BGM_IRQ			14
+#define GMAC_IRQ		15
+#define AES_IRQ			16
+#define SDC0_IRQ		17
+#define SDC1_IRQ		18
+#define ACW_IRQ			19
+#define SADC_IRQ		20
+#define SPI1_IRQ		21
+#define SPI2_IRQ		22
+#define DMAC0_IRQ		23
+#define DMAC1_IRQ		24
+#define I2S0_IRQ		25
+#define GPIO0_IRQ		26
+#define SPI0_IRQ		28
+#define ARC_SW_IRQ		29
+#define UART0_IRQ		30
+#define UART1_IRQ		31
+#define ARM_SW_IRQ		32
+#define RTC_IRQ			33
+#define AHBC0_IRQ		34
+#define AHBC1_IRQ		35
+#define PWM_IRQ			36
+#define MIPIC_IRQ		37
+#define MIPI_WRAP_IRQ		38
+
+#define GPIO1_IRQ		40
+
+#define NR_INTERNAL_IRQS	(64)
+#define NR_EXTERNAL_IRQS	(64)
+#define NR_IRQS			(NR_INTERNAL_IRQS + NR_EXTERNAL_IRQS)
+
+#endif /* __ASM_ARCH_FH8833_H */
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/fh8833_iopad_mipi.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/fh8833_iopad_mipi.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/fh8833_iopad_mipi.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/fh8833_iopad_mipi.h	2021-07-13 23:40:30.650336818 +0300
@@ -0,0 +1,639 @@
+
+#include "pinctrl.h"
+#include "pinctrl_osdep.h"
+#include "board_config.h"
+
+PINCTRL_FUNC(CIS_HSYNC, 0, FUNC0, PUPD_DOWN);
+PINCTRL_FUNC(GPIO20, 0, FUNC1, PUPD_DOWN);
+PINCTRL_FUNC(CIS_VSYNC, 1, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO21, 1, FUNC1, PUPD_UP);
+PINCTRL_FUNC(PWM0, 1, FUNC2, PUPD_UP);
+PINCTRL_FUNC(UART1_TX, 1, FUNC3, PUPD_UP);
+PINCTRL_FUNC(CIS_PCLK, 2, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO19, 2, FUNC1, PUPD_UP);
+PINCTRL_FUNC(PWM1, 2, FUNC2, PUPD_UP);
+PINCTRL_FUNC(UART1_RX, 2, FUNC3, PUPD_UP);
+PINCTRL_FUNC(CIS_D_0, 3, FUNC0, PUPD_DOWN);
+PINCTRL_FUNC(GPIO22, 3, FUNC1, PUPD_DOWN);
+PINCTRL_FUNC(PWM2, 3, FUNC2, PUPD_DOWN);
+PINCTRL_FUNC(AD_I2S_DI, 3, FUNC4, PUPD_DOWN);
+PINCTRL_FUNC(RTC_CLK, 3, FUNC5, PUPD_DOWN);
+PINCTRL_FUNC(CIS_D_1, 4, FUNC0, PUPD_DOWN);
+PINCTRL_FUNC(GPIO23, 4, FUNC1, PUPD_DOWN);
+PINCTRL_FUNC(PWM3, 4, FUNC2, PUPD_DOWN);
+PINCTRL_FUNC(AC_MCLK, 4, FUNC3, PUPD_DOWN);
+PINCTRL_FUNC(AD_I2S_CLK, 4, FUNC4, PUPD_DOWN);
+PINCTRL_FUNC(CIS_D_2, 5, FUNC0, PUPD_DOWN);
+PINCTRL_FUNC(GPIO24, 5, FUNC1, PUPD_DOWN);
+PINCTRL_FUNC(PWM4, 5, FUNC2, PUPD_DOWN);
+PINCTRL_FUNC(I2S_DI, 5, FUNC3, PUPD_DOWN);
+PINCTRL_FUNC(AD_I2S_WS, 5, FUNC4, PUPD_DOWN);
+PINCTRL_FUNC(CIS_D_3, 6, FUNC0, PUPD_DOWN);
+PINCTRL_FUNC(GPIO25, 6, FUNC1, PUPD_DOWN);
+PINCTRL_FUNC(PWM5, 6, FUNC2, PUPD_DOWN);
+PINCTRL_FUNC(I2S_CLK, 6, FUNC3, PUPD_DOWN);
+PINCTRL_FUNC(DA_I2S_DO, 6, FUNC4, PUPD_DOWN);
+PINCTRL_FUNC(CIS_D_4, 7, FUNC0, PUPD_DOWN);
+PINCTRL_FUNC(GPIO26, 7, FUNC1, PUPD_DOWN);
+PINCTRL_FUNC(PWM6, 7, FUNC2, PUPD_DOWN);
+PINCTRL_FUNC(I2S_WS, 7, FUNC3, PUPD_DOWN);
+PINCTRL_FUNC(DA_I2S_WS, 7, FUNC4, PUPD_DOWN);
+PINCTRL_FUNC(CIS_D_5, 8, FUNC0, PUPD_DOWN);
+PINCTRL_FUNC(GPIO27, 8, FUNC1, PUPD_DOWN);
+PINCTRL_FUNC(PWM7, 8, FUNC2, PUPD_DOWN);
+PINCTRL_FUNC(I2S_DO, 8, FUNC3, PUPD_DOWN);
+PINCTRL_FUNC(DA_I2S_CLK, 8, FUNC4, PUPD_DOWN);
+PINCTRL_FUNC(CIS_D_6, 9, FUNC0, PUPD_DOWN);
+PINCTRL_FUNC(GPIO28, 9, FUNC1, PUPD_DOWN);
+PINCTRL_FUNC(CIS_D_7, 10, FUNC0, PUPD_DOWN);
+PINCTRL_FUNC(GPIO29, 10, FUNC1, PUPD_DOWN);
+PINCTRL_FUNC(CIS_D_8, 11, FUNC0, PUPD_DOWN);
+PINCTRL_FUNC(GPIO30, 11, FUNC1, PUPD_DOWN);
+PINCTRL_FUNC(CIS_D_9, 12, FUNC0, PUPD_DOWN);
+PINCTRL_FUNC(GPIO31, 12, FUNC1, PUPD_DOWN);
+PINCTRL_FUNC(CIS_D_10, 13, FUNC0, PUPD_DOWN);
+PINCTRL_FUNC(GPIO32, 13, FUNC1, PUPD_DOWN);
+PINCTRL_FUNC(CIS_D_11, 14, FUNC0, PUPD_DOWN);
+PINCTRL_FUNC(GPIO33, 14, FUNC1, PUPD_DOWN);
+PINCTRL_FUNC(MAC_RMII_CLK, 15, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO15, 15, FUNC1, PUPD_UP);
+PINCTRL_FUNC(SD1_CLK, 15, FUNC2, PUPD_UP);
+PINCTRL_FUNC(PWM0, 15, FUNC3, PUPD_UP);
+PINCTRL_FUNC(I2S_DI, 15, FUNC5, PUPD_UP);
+PINCTRL_FUNC(MAC_REF_CLK, 16, FUNC0, PUPD_NONE);
+PINCTRL_FUNC(MAC_MDC, 17, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO34, 17, FUNC1, PUPD_UP);
+PINCTRL_FUNC(SD1_WP, 17, FUNC2, PUPD_UP);
+PINCTRL_FUNC(I2C1_SDA, 17, FUNC3, PUPD_UP);
+PINCTRL_FUNC(UART1_TX, 17, FUNC4, PUPD_UP);
+PINCTRL_FUNC(SSI1_CLK, 17, FUNC5, PUPD_UP);
+PINCTRL_FUNC(MAC_MDIO, 18, FUNC0, PUPD_NONE);
+PINCTRL_FUNC(GPIO17, 18, FUNC1, PUPD_NONE);
+PINCTRL_FUNC(ARM_JTAG_TDO, 18, FUNC2, PUPD_NONE);
+PINCTRL_FUNC(I2C1_SCL, 18, FUNC3, PUPD_NONE);
+PINCTRL_FUNC(UART1_RX, 18, FUNC4, PUPD_NONE);
+PINCTRL_FUNC(PWM7, 18, FUNC5, PUPD_NONE);
+PINCTRL_FUNC(PWM0, 19, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO35, 19, FUNC1, PUPD_UP);
+PINCTRL_FUNC(PWM1, 20, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO36, 20, FUNC1, PUPD_UP);
+PINCTRL_FUNC(MAC_RXCK, 21, FUNC0, PUPD_NONE);
+PINCTRL_FUNC(MAC_RXD_0, 22, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO16, 22, FUNC1, PUPD_UP);
+PINCTRL_FUNC(SD1_DATA_0, 22, FUNC2, PUPD_UP);
+PINCTRL_FUNC(PWM1, 22, FUNC3, PUPD_UP);
+PINCTRL_FUNC(AD_I2S_DI, 22, FUNC4, PUPD_UP);
+PINCTRL_FUNC(I2S_CLK, 22, FUNC5, PUPD_UP);
+PINCTRL_FUNC(MAC_RXD_1, 23, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO38, 23, FUNC1, PUPD_UP);
+PINCTRL_FUNC(SD1_DATA_1, 23, FUNC2, PUPD_UP);
+PINCTRL_FUNC(PWM2, 23, FUNC3, PUPD_UP);
+PINCTRL_FUNC(AD_I2S_CLK, 23, FUNC4, PUPD_UP);
+PINCTRL_FUNC(I2S_WS, 23, FUNC5, PUPD_UP);
+PINCTRL_FUNC(PWM2, 24, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO39, 24, FUNC1, PUPD_UP);
+PINCTRL_FUNC(PWM3, 25, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO40, 25, FUNC1, PUPD_UP);
+PINCTRL_FUNC(MAC_RXDV, 26, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO41, 26, FUNC1, PUPD_UP);
+PINCTRL_FUNC(SD1_CD, 26, FUNC2, PUPD_UP);
+PINCTRL_FUNC(PWM3, 26, FUNC3, PUPD_UP);
+PINCTRL_FUNC(AD_I2S_WS, 26, FUNC4, PUPD_UP);
+PINCTRL_FUNC(I2S_DO, 26, FUNC5, PUPD_UP);
+PINCTRL_FUNC(MAC_TXCK, 27, FUNC0, PUPD_NONE);
+PINCTRL_FUNC(MAC_TXD_0, 28, FUNC0, PUPD_NONE);
+PINCTRL_FUNC(GPIO42, 28, FUNC1, PUPD_NONE);
+PINCTRL_FUNC(SD1_DATA_2, 28, FUNC2, PUPD_NONE);
+PINCTRL_FUNC(PWM4, 28, FUNC3, PUPD_NONE);
+PINCTRL_FUNC(DA_I2S_DO, 28, FUNC4, PUPD_NONE);
+PINCTRL_FUNC(SSI1_TXD, 28, FUNC5, PUPD_NONE);
+PINCTRL_FUNC(MAC_TXD_1, 29, FUNC0, PUPD_NONE);
+PINCTRL_FUNC(GPIO43, 29, FUNC1, PUPD_NONE);
+PINCTRL_FUNC(SD1_DATA_3, 29, FUNC2, PUPD_NONE);
+PINCTRL_FUNC(PWM5, 29, FUNC3, PUPD_NONE);
+PINCTRL_FUNC(DA_I2S_WS, 29, FUNC4, PUPD_NONE);
+PINCTRL_FUNC(SSI1_RXD, 29, FUNC5, PUPD_NONE);
+PINCTRL_FUNC(PWM4, 30, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO44, 30, FUNC1, PUPD_UP);
+PINCTRL_FUNC(PWM5, 31, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO45, 31, FUNC1, PUPD_UP);
+PINCTRL_FUNC(MAC_TXEN, 32, FUNC0, PUPD_NONE);
+PINCTRL_FUNC(GPIO46, 32, FUNC1, PUPD_NONE);
+PINCTRL_FUNC(SD1_CMD_RSP, 32, FUNC2, PUPD_NONE);
+PINCTRL_FUNC(PWM6, 32, FUNC3, PUPD_NONE);
+PINCTRL_FUNC(DA_I2S_CLK, 32, FUNC4, PUPD_NONE);
+PINCTRL_FUNC(AC_MCLK, 32, FUNC5, PUPD_NONE);
+PINCTRL_FUNC(PWM6, 33, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO47, 33, FUNC1, PUPD_UP);
+PINCTRL_FUNC(PWM7, 34, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO37, 34, FUNC1, PUPD_UP);
+PINCTRL_FUNC(ARM_JTAG_TRSTN, 35, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO0, 35, FUNC1, PUPD_UP);
+PINCTRL_FUNC(SSI1_TXD, 35, FUNC2, PUPD_UP);
+PINCTRL_FUNC(SSI2_TXD, 35, FUNC3, PUPD_UP);
+PINCTRL_FUNC(PWM0, 35, FUNC4, PUPD_UP);
+PINCTRL_FUNC(I2S_DI, 35, FUNC5, PUPD_UP);
+PINCTRL_FUNC(ARM_JTAG_TMS, 36, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO1, 36, FUNC1, PUPD_UP);
+PINCTRL_FUNC(SSI1_RXD, 36, FUNC2, PUPD_UP);
+PINCTRL_FUNC(SSI2_RXD, 36, FUNC3, PUPD_UP);
+PINCTRL_FUNC(PWM1, 36, FUNC4, PUPD_UP);
+PINCTRL_FUNC(I2S_WS, 36, FUNC5, PUPD_UP);
+PINCTRL_FUNC(ARM_JTAG_TCK, 37, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO2, 37, FUNC1, PUPD_UP);
+PINCTRL_FUNC(SSI1_CLK, 37, FUNC2, PUPD_UP);
+PINCTRL_FUNC(SSI2_CLK, 37, FUNC3, PUPD_UP);
+PINCTRL_FUNC(PWM2, 37, FUNC4, PUPD_UP);
+PINCTRL_FUNC(I2S_DO, 37, FUNC5, PUPD_UP);
+PINCTRL_FUNC(ARM_JTAG_TDI, 38, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO3, 38, FUNC1, PUPD_UP);
+PINCTRL_FUNC(SSI1_CSN_0, 38, FUNC2, PUPD_UP);
+PINCTRL_FUNC(SSI2_CSN, 38, FUNC3, PUPD_UP);
+PINCTRL_FUNC(PWM3, 38, FUNC4, PUPD_UP);
+PINCTRL_FUNC(I2S_CLK, 38, FUNC5, PUPD_UP);
+PINCTRL_FUNC(GPIO4, 39, FUNC0, PUPD_UP);
+PINCTRL_FUNC(ARM_JTAG_TCK, 40, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO5, 40, FUNC1, PUPD_UP);
+PINCTRL_FUNC(ARM_JTAG_TRSTN, 41, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO6, 41, FUNC1, PUPD_UP);
+PINCTRL_FUNC(ARM_JTAG_TMS, 42, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO7, 42, FUNC1, PUPD_UP);
+PINCTRL_FUNC(ARM_JTAG_TDI, 43, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO8, 43, FUNC1, PUPD_UP);
+PINCTRL_FUNC(ARM_JTAG_TDO, 44, FUNC0, PUPD_NONE);
+PINCTRL_FUNC(GPIO9, 44, FUNC1, PUPD_NONE);
+PINCTRL_FUNC(UART1_TX, 45, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO10, 45, FUNC1, PUPD_UP);
+PINCTRL_FUNC(UART1_RX, 46, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO11, 46, FUNC1, PUPD_UP);
+PINCTRL_FUNC(PWM0, 47, FUNC0, PUPD_NONE);
+PINCTRL_FUNC(GPIO12, 47, FUNC1, PUPD_NONE);
+PINCTRL_FUNC(CIS_CLK, 47, FUNC2, PUPD_NONE);
+PINCTRL_FUNC(PWM1, 48, FUNC0, PUPD_NONE);
+PINCTRL_FUNC(GPIO13, 48, FUNC1, PUPD_NONE);
+PINCTRL_FUNC(PWM2, 49, FUNC0, PUPD_NONE);
+PINCTRL_FUNC(GPIO14, 49, FUNC1, PUPD_NONE);
+PINCTRL_FUNC(UART0_RX, 50, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO48, 50, FUNC1, PUPD_UP);
+PINCTRL_FUNC(I2S_WS, 50, FUNC2, PUPD_UP);
+PINCTRL_FUNC(UART0_TX, 51, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO49, 51, FUNC1, PUPD_UP);
+PINCTRL_FUNC(I2S_CLK, 51, FUNC2, PUPD_UP);
+PINCTRL_FUNC(I2C0_SCL, 52, FUNC0, PUPD_NONE);
+PINCTRL_FUNC(GPIO57, 52, FUNC1, PUPD_NONE);
+PINCTRL_FUNC(I2C0_SDA, 53, FUNC0, PUPD_NONE);
+PINCTRL_FUNC(GPIO56, 53, FUNC1, PUPD_NONE);
+PINCTRL_FUNC(I2C1_SCL, 54, FUNC0, PUPD_NONE);
+PINCTRL_FUNC(GPIO51, 54, FUNC1, PUPD_NONE);
+PINCTRL_FUNC(I2S_DI, 54, FUNC2, PUPD_NONE);
+PINCTRL_FUNC(I2C1_SDA, 55, FUNC0, PUPD_NONE);
+PINCTRL_FUNC(GPIO50, 55, FUNC1, PUPD_NONE);
+PINCTRL_FUNC(I2S_DO, 55, FUNC2, PUPD_NONE);
+PINCTRL_FUNC(SSI0_CLK, 56, FUNC0, PUPD_NONE);
+PINCTRL_FUNC(SSI0_TXD, 57, FUNC0, PUPD_NONE);
+PINCTRL_FUNC(SSI0_CSN_0, 58, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO54, 58, FUNC1, PUPD_UP);
+PINCTRL_FUNC(SSI0_CSN_1, 59, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO55, 59, FUNC1, PUPD_UP);
+PINCTRL_FUNC(AC_MCLK, 59, FUNC3, PUPD_UP);
+PINCTRL_FUNC(PWM3, 59, FUNC4, PUPD_UP);
+PINCTRL_FUNC(UART1_TX, 59, FUNC5, PUPD_UP);
+PINCTRL_FUNC(SSI0_RXD, 60, FUNC0, PUPD_UP);
+PINCTRL_FUNC(SD0_CD, 61, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO52, 61, FUNC1, PUPD_UP);
+PINCTRL_FUNC(ARC_JTAG_TRSTN, 61, FUNC2, PUPD_UP);
+PINCTRL_FUNC(PAE_JTAG_TRSTN, 61, FUNC3, PUPD_UP);
+PINCTRL_FUNC(PWM5, 61, FUNC4, PUPD_UP);
+PINCTRL_FUNC(SSI2_TXD, 61, FUNC5, PUPD_UP);
+PINCTRL_FUNC(SD0_WP, 62, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO53, 62, FUNC1, PUPD_UP);
+PINCTRL_FUNC(SD0_CLK, 63, FUNC0, PUPD_NONE);
+PINCTRL_FUNC(GPIO63, 63, FUNC1, PUPD_NONE);
+PINCTRL_FUNC(ARC_JTAG_TMS, 63, FUNC2, PUPD_NONE);
+PINCTRL_FUNC(PAE_JTAG_TMS, 63, FUNC3, PUPD_NONE);
+PINCTRL_FUNC(PWM6, 63, FUNC4, PUPD_NONE);
+PINCTRL_FUNC(SSI2_RXD, 63, FUNC5, PUPD_NONE);
+PINCTRL_FUNC(SD0_CMD_RSP, 64, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO11, 64, FUNC1, PUPD_UP);
+PINCTRL_FUNC(ARC_JTAG_TCK, 64, FUNC2, PUPD_UP);
+PINCTRL_FUNC(PAE_JTAG_TCK, 64, FUNC3, PUPD_UP);
+PINCTRL_FUNC(PWM7, 64, FUNC4, PUPD_UP);
+PINCTRL_FUNC(SSI2_CLK, 64, FUNC5, PUPD_UP);
+PINCTRL_FUNC(SD0_DATA_0, 65, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO62, 65, FUNC1, PUPD_UP);
+PINCTRL_FUNC(ARC_JTAG_TDI, 65, FUNC2, PUPD_UP);
+PINCTRL_FUNC(PAE_JTAG_TDI, 65, FUNC3, PUPD_UP);
+PINCTRL_FUNC(PWM4, 65, FUNC4, PUPD_UP);
+PINCTRL_FUNC(SSI2_CSN, 65, FUNC5, PUPD_UP);
+PINCTRL_FUNC(SD0_DATA_1, 66, FUNC0, PUPD_UP);
+PINCTRL_FUNC(GPIO61, 66, FUNC1, PUPD_UP);
+PINCTRL_FUNC(ARC_JTAG_TDO, 66, FUNC2, PUPD_UP);
+PINCTRL_FUNC(PAE_JTAG_TDO, 66, FUNC3, PUPD_UP);
+PINCTRL_FUNC(SD0_WP, 66, FUNC4, PUPD_UP);
+PINCTRL_FUNC(UART1_TX, 66, FUNC5, PUPD_UP);
+
+PINCTRL_MUX(AC_MCLK, 2, &PAD4_AC_MCLK, &PAD32_AC_MCLK, &PAD59_AC_MCLK);
+
+PINCTRL_MUX(ACI2S_AD_CLK, 1, &PAD4_AD_I2S_CLK, &PAD23_AD_I2S_CLK);
+PINCTRL_MUX(ACI2S_AD_DI, 1, &PAD3_AD_I2S_DI, &PAD22_AD_I2S_DI);
+PINCTRL_MUX(ACI2S_AD_WS, 0, &PAD5_AD_I2S_WS, &PAD26_AD_I2S_WS);
+PINCTRL_MUX(ACI2S_DA_CLK, 0, &PAD8_DA_I2S_CLK, &PAD32_DA_I2S_CLK);
+PINCTRL_MUX(ACI2S_DA_DO, 0, &PAD6_DA_I2S_DO, &PAD28_DA_I2S_DO);
+PINCTRL_MUX(ACI2S_DA_WS, 0, &PAD7_DA_I2S_WS, &PAD29_DA_I2S_WS);
+
+PINCTRL_MUX(DWI2S_CLK, 0, &PAD6_I2S_CLK, &PAD22_I2S_CLK,
+		&PAD38_I2S_CLK, &PAD51_I2S_CLK);
+PINCTRL_MUX(DWI2S_DI, 0, &PAD5_I2S_DI, &PAD15_I2S_DI,
+		&PAD35_I2S_DI, &PAD54_I2S_DI);
+PINCTRL_MUX(DWI2S_DO, 0, &PAD8_I2S_DO, &PAD26_I2S_DO,
+		&PAD37_I2S_DO, &PAD55_I2S_DO);
+PINCTRL_MUX(DWI2S_WS, 0, &PAD7_I2S_WS, &PAD23_I2S_WS,
+		&PAD36_I2S_WS, &PAD50_I2S_WS);
+
+PINCTRL_MUX(ARCJTAG_TCK, 0, &PAD64_ARC_JTAG_TCK);
+PINCTRL_MUX(ARCJTAG_TDI, 0, &PAD65_ARC_JTAG_TDI);
+PINCTRL_MUX(ARCJTAG_TDO, 0, &PAD66_ARC_JTAG_TDO);
+PINCTRL_MUX(ARCJTAG_TMS, 0, &PAD63_ARC_JTAG_TMS);
+PINCTRL_MUX(ARCJTAG_TRSTN, 0, &PAD61_ARC_JTAG_TRSTN);
+
+PINCTRL_MUX(ARMJTAG_TCK, 1, &PAD37_ARM_JTAG_TCK, &PAD40_ARM_JTAG_TCK);
+PINCTRL_MUX(ARMJTAG_TDI, 1, &PAD38_ARM_JTAG_TDI, &PAD43_ARM_JTAG_TDI);
+PINCTRL_MUX(ARMJTAG_TDO, 1, &PAD18_ARM_JTAG_TDO, &PAD44_ARM_JTAG_TDO);
+PINCTRL_MUX(ARMJTAG_TMS, 1, &PAD36_ARM_JTAG_TMS, &PAD42_ARM_JTAG_TMS);
+PINCTRL_MUX(ARMJTAG_TRSTN, 1, &PAD35_ARM_JTAG_TRSTN, &PAD41_ARM_JTAG_TRSTN);
+
+PINCTRL_MUX(PAEJTAG_TCK, 0, &PAD64_PAE_JTAG_TCK);
+PINCTRL_MUX(PAEJTAG_TDI, 0, &PAD65_PAE_JTAG_TDI);
+PINCTRL_MUX(PAEJTAG_TDO, 0, &PAD66_PAE_JTAG_TDO);
+PINCTRL_MUX(PAEJTAG_TMS, 0, &PAD63_PAE_JTAG_TMS);
+PINCTRL_MUX(PAEJTAG_TRSTN, 0, &PAD61_PAE_JTAG_TRSTN);
+
+PINCTRL_MUX(CIS_CLK, 0, &PAD47_CIS_CLK);
+PINCTRL_MUX(CIS_PCLK, 0, &PAD2_CIS_PCLK);
+PINCTRL_MUX(CIS_HSYNC, 0, &PAD0_CIS_HSYNC);
+PINCTRL_MUX(CIS_VSYNC, 0, &PAD1_CIS_VSYNC);
+PINCTRL_MUX(CIS_D_0, 0, &PAD3_CIS_D_0);
+PINCTRL_MUX(CIS_D_1, 0, &PAD4_CIS_D_1);
+PINCTRL_MUX(CIS_D_2, 0, &PAD5_CIS_D_2);
+PINCTRL_MUX(CIS_D_3, 0, &PAD6_CIS_D_3);
+PINCTRL_MUX(CIS_D_4, 0, &PAD7_CIS_D_4);
+PINCTRL_MUX(CIS_D_5, 0, &PAD8_CIS_D_5);
+PINCTRL_MUX(CIS_D_6, 0, &PAD9_CIS_D_6);
+PINCTRL_MUX(CIS_D_7, 0, &PAD10_CIS_D_7);
+PINCTRL_MUX(CIS_D_8, 0, &PAD11_CIS_D_8);
+PINCTRL_MUX(CIS_D_9, 0, &PAD12_CIS_D_9);
+PINCTRL_MUX(CIS_D_10, 0, &PAD13_CIS_D_10);
+PINCTRL_MUX(CIS_D_11, 0, &PAD14_CIS_D_11);
+
+PINCTRL_MUX(I2C0_SCL, 0, &PAD52_I2C0_SCL);
+PINCTRL_MUX(I2C0_SDA, 0, &PAD53_I2C0_SDA);
+
+PINCTRL_MUX(I2C1_SCL, 1, &PAD18_I2C1_SCL, &PAD54_I2C1_SCL);
+PINCTRL_MUX(I2C1_SDA, 1, &PAD17_I2C1_SDA, &PAD55_I2C1_SDA);
+
+PINCTRL_MUX(MAC_REF_CLK, 0, &PAD16_MAC_REF_CLK);
+PINCTRL_MUX(MAC_RMII_CLK, 0, &PAD15_MAC_RMII_CLK);
+PINCTRL_MUX(MAC_MDC, 0, &PAD17_MAC_MDC);
+PINCTRL_MUX(MAC_MDIO, 0, &PAD18_MAC_MDIO);
+PINCTRL_MUX(MAC_RXCK, 0, &PAD21_MAC_RXCK);
+PINCTRL_MUX(MAC_RXD_0, 0, &PAD22_MAC_RXD_0);
+PINCTRL_MUX(MAC_RXD_1, 0, &PAD23_MAC_RXD_1);
+PINCTRL_MUX(MAC_RXDV, 0, &PAD26_MAC_RXDV);
+PINCTRL_MUX(MAC_TXCK, 0, &PAD27_MAC_TXCK);
+PINCTRL_MUX(MAC_TXD_0, 0, &PAD28_MAC_TXD_0);
+PINCTRL_MUX(MAC_TXD_1, 0, &PAD29_MAC_TXD_1);
+PINCTRL_MUX(MAC_TXEN, 0, &PAD32_MAC_TXEN);
+
+PINCTRL_MUX(PWM0, 3, &PAD1_PWM0, &PAD15_PWM0,
+		&PAD19_PWM0, &PAD35_PWM0, &PAD47_PWM0);
+PINCTRL_MUX(PWM1, 3, &PAD2_PWM1, &PAD20_PWM1,
+		&PAD22_PWM1, &PAD36_PWM1, &PAD48_PWM1);
+PINCTRL_MUX(PWM2, 3, &PAD3_PWM2, &PAD23_PWM2,
+		&PAD24_PWM2, &PAD37_PWM2, &PAD49_PWM2);
+PINCTRL_MUX(PWM3, 3, &PAD4_PWM3, &PAD25_PWM3,
+		&PAD26_PWM3, &PAD38_PWM3, &PAD59_PWM3);
+PINCTRL_MUX(PWM4, 2, &PAD5_PWM4, &PAD28_PWM4, &PAD30_PWM4,
+		&PAD65_PWM4);
+PINCTRL_MUX(PWM5, 2, &PAD6_PWM5, &PAD29_PWM5, &PAD31_PWM5,
+		&PAD61_PWM5);
+PINCTRL_MUX(PWM6, 2, &PAD7_PWM6, &PAD32_PWM6, &PAD33_PWM6,
+		&PAD63_PWM6);
+PINCTRL_MUX(PWM7, 2, &PAD8_PWM7, &PAD18_PWM7, &PAD34_PWM7,
+		&PAD64_PWM7);
+
+PINCTRL_MUX(SD0_CLK, 0, &PAD63_SD0_CLK);
+PINCTRL_MUX(SD0_CD, 0, &PAD61_SD0_CD);
+PINCTRL_MUX(SD0_CMD_RSP, 0, &PAD64_SD0_CMD_RSP);
+PINCTRL_MUX(SD0_WP, 0, &PAD62_SD0_WP, &PAD66_SD0_WP);
+PINCTRL_MUX(SD0_DATA_0, 0, &PAD65_SD0_DATA_0);
+PINCTRL_MUX(SD0_DATA_1, 0, &PAD66_SD0_DATA_1);
+
+PINCTRL_MUX(SD1_CLK, 0, &PAD15_SD1_CLK);
+PINCTRL_MUX(SD1_CD, 0, &PAD26_SD1_CD);
+PINCTRL_MUX(SD1_CMD_RSP, 0, &PAD32_SD1_CMD_RSP);
+PINCTRL_MUX(SD1_WP, 0, &PAD17_SD1_WP);
+PINCTRL_MUX(SD1_DATA_0, 0, &PAD22_SD1_DATA_0);
+PINCTRL_MUX(SD1_DATA_1, 0, &PAD23_SD1_DATA_1);
+PINCTRL_MUX(SD1_DATA_2, 0, &PAD28_SD1_DATA_2);
+PINCTRL_MUX(SD1_DATA_3, 0, &PAD29_SD1_DATA_3);
+
+PINCTRL_MUX(SSI0_CLK, 0, &PAD56_SSI0_CLK);
+PINCTRL_MUX(SSI0_RXD, 0, &PAD60_SSI0_RXD);
+PINCTRL_MUX(SSI0_TXD, 0, &PAD57_SSI0_TXD);
+PINCTRL_MUX(SSI0_CSN_0, 0, &PAD58_SSI0_CSN_0);
+PINCTRL_MUX(SSI0_CSN_1, 0, &PAD59_SSI0_CSN_1);
+
+PINCTRL_MUX(SSI1_CLK, 0, &PAD37_SSI1_CLK);
+PINCTRL_MUX(SSI1_RXD, 1, &PAD29_SSI1_RXD, &PAD36_SSI1_RXD);
+PINCTRL_MUX(SSI1_TXD, 1, &PAD28_SSI1_TXD, &PAD35_SSI1_TXD);
+PINCTRL_MUX(SSI1_CSN_0, 0, &PAD38_SSI1_CSN_0);
+
+PINCTRL_MUX(SSI2_CLK, 0, &PAD37_SSI2_CLK, &PAD64_SSI2_CLK);
+PINCTRL_MUX(SSI2_RXD, 0, &PAD36_SSI2_RXD, &PAD63_SSI2_RXD);
+PINCTRL_MUX(SSI2_TXD, 0, &PAD35_SSI2_TXD, &PAD61_SSI2_TXD);
+PINCTRL_MUX(SSI2_CSN, 0, &PAD38_SSI2_CSN, &PAD65_SSI2_CSN);
+
+PINCTRL_MUX(UART0_RX, 0, &PAD50_UART0_RX);
+PINCTRL_MUX(UART0_TX, 0, &PAD51_UART0_TX);
+PINCTRL_MUX(UART1_RX, 0, &PAD2_UART1_RX, &PAD18_UART1_RX,
+		&PAD46_UART1_RX);
+PINCTRL_MUX(UART1_TX, 0, &PAD1_UART1_TX, &PAD17_UART1_TX,
+		&PAD45_UART1_TX, &PAD59_UART1_TX, &PAD66_UART1_TX);
+
+PINCTRL_MUX(GPIO0, 0, &PAD35_GPIO0);
+PINCTRL_MUX(GPIO1, 0, &PAD36_GPIO1);
+PINCTRL_MUX(GPIO2, 0, &PAD37_GPIO2);
+PINCTRL_MUX(GPIO3, 0, &PAD38_GPIO3);
+PINCTRL_MUX(GPIO4, 0, &PAD39_GPIO4);
+PINCTRL_MUX(GPIO5, 0, &PAD40_GPIO5);
+PINCTRL_MUX(GPIO6, 0, &PAD41_GPIO6);
+PINCTRL_MUX(GPIO7, 0, &PAD42_GPIO7);
+PINCTRL_MUX(GPIO8, 0, &PAD43_GPIO8);
+PINCTRL_MUX(GPIO9, 0, &PAD44_GPIO9);
+PINCTRL_MUX(GPIO10, 0, &PAD45_GPIO10);
+PINCTRL_MUX(GPIO11, 0, &PAD46_GPIO11, &PAD64_GPIO11);
+PINCTRL_MUX(GPIO12, 0, &PAD47_GPIO12);
+PINCTRL_MUX(GPIO13, 0, &PAD48_GPIO13);
+PINCTRL_MUX(GPIO14, 0, &PAD49_GPIO14);
+PINCTRL_MUX(GPIO15, 0, &PAD15_GPIO15);
+PINCTRL_MUX(GPIO16, 0, &PAD22_GPIO16);
+PINCTRL_MUX(GPIO17, 0, &PAD18_GPIO17);
+PINCTRL_MUX(GPIO19, 0, &PAD2_GPIO19);
+PINCTRL_MUX(GPIO20, 0, &PAD0_GPIO20);
+PINCTRL_MUX(GPIO21, 0, &PAD1_GPIO21);
+PINCTRL_MUX(GPIO22, 0, &PAD3_GPIO22);
+PINCTRL_MUX(GPIO23, 0, &PAD4_GPIO23);
+PINCTRL_MUX(GPIO24, 0, &PAD5_GPIO24);
+PINCTRL_MUX(GPIO25, 0, &PAD6_GPIO25);
+PINCTRL_MUX(GPIO26, 0, &PAD7_GPIO26);
+PINCTRL_MUX(GPIO27, 0, &PAD8_GPIO27);
+PINCTRL_MUX(GPIO28, 0, &PAD9_GPIO28);
+PINCTRL_MUX(GPIO29, 0, &PAD10_GPIO29);
+PINCTRL_MUX(GPIO30, 0, &PAD11_GPIO30);
+PINCTRL_MUX(GPIO31, 0, &PAD12_GPIO31);
+PINCTRL_MUX(GPIO32, 0, &PAD13_GPIO32);
+PINCTRL_MUX(GPIO33, 0, &PAD14_GPIO33);
+PINCTRL_MUX(GPIO34, 0, &PAD17_GPIO34);
+PINCTRL_MUX(GPIO35, 0, &PAD19_GPIO35);
+PINCTRL_MUX(GPIO36, 0, &PAD20_GPIO36);
+PINCTRL_MUX(GPIO37, 0, &PAD34_GPIO37);
+PINCTRL_MUX(GPIO38, 0, &PAD23_GPIO38);
+PINCTRL_MUX(GPIO39, 0, &PAD24_GPIO39);
+PINCTRL_MUX(GPIO40, 0, &PAD25_GPIO40);
+PINCTRL_MUX(GPIO41, 0, &PAD26_GPIO41);
+PINCTRL_MUX(GPIO42, 0, &PAD28_GPIO42);
+PINCTRL_MUX(GPIO43, 0, &PAD29_GPIO43);
+PINCTRL_MUX(GPIO44, 0, &PAD30_GPIO44);
+PINCTRL_MUX(GPIO45, 0, &PAD31_GPIO45);
+PINCTRL_MUX(GPIO46, 0, &PAD32_GPIO46);
+PINCTRL_MUX(GPIO47, 0, &PAD33_GPIO47);
+PINCTRL_MUX(GPIO48, 0, &PAD50_GPIO48);
+PINCTRL_MUX(GPIO49, 0, &PAD51_GPIO49);
+PINCTRL_MUX(GPIO50, 0, &PAD55_GPIO50);
+PINCTRL_MUX(GPIO51, 0, &PAD54_GPIO51);
+PINCTRL_MUX(GPIO52, 0, &PAD61_GPIO52);
+PINCTRL_MUX(GPIO53, 0, &PAD62_GPIO53);
+PINCTRL_MUX(GPIO54, 0, &PAD58_GPIO54);
+PINCTRL_MUX(GPIO55, 0, &PAD59_GPIO55);
+PINCTRL_MUX(GPIO56, 0, &PAD53_GPIO56);
+PINCTRL_MUX(GPIO57, 0, &PAD52_GPIO57);
+PINCTRL_MUX(GPIO61, 0, &PAD66_GPIO61);
+PINCTRL_MUX(GPIO62, 0, &PAD65_GPIO62);
+PINCTRL_MUX(GPIO63, 0, &PAD63_GPIO63);
+
+PINCTRL_DEVICE(AC, 1, &MUX_AC_MCLK);
+PINCTRL_DEVICE(ACI2S, 6, &MUX_ACI2S_AD_CLK, &MUX_ACI2S_AD_DI, &MUX_ACI2S_AD_WS,
+		&MUX_ACI2S_DA_CLK, &MUX_ACI2S_DA_DO, &MUX_ACI2S_DA_WS);
+PINCTRL_DEVICE(DWI2S, 4, &MUX_DWI2S_CLK, &MUX_DWI2S_DI,
+		&MUX_DWI2S_DO, &MUX_DWI2S_WS);
+PINCTRL_DEVICE(ARCJTAG, 5, &MUX_ARCJTAG_TCK, &MUX_ARCJTAG_TDI, &MUX_ARCJTAG_TDO,
+		&MUX_ARCJTAG_TMS, &MUX_ARCJTAG_TRSTN);
+PINCTRL_DEVICE(ARMJTAG, 5, &MUX_ARMJTAG_TCK, &MUX_ARMJTAG_TDI, &MUX_ARMJTAG_TDO,
+		&MUX_ARMJTAG_TMS, &MUX_ARMJTAG_TRSTN);
+PINCTRL_DEVICE(PAEJTAG, 5, &MUX_PAEJTAG_TCK, &MUX_PAEJTAG_TDI, &MUX_PAEJTAG_TDO,
+		&MUX_PAEJTAG_TMS, &MUX_PAEJTAG_TRSTN);
+PINCTRL_DEVICE(CIS, 16, &MUX_CIS_CLK, &MUX_CIS_PCLK, &MUX_CIS_HSYNC,
+		&MUX_CIS_VSYNC, &MUX_CIS_D_0, &MUX_CIS_D_1, &MUX_CIS_D_2,
+		&MUX_CIS_D_3, &MUX_CIS_D_4, &MUX_CIS_D_5, &MUX_CIS_D_6,
+		&MUX_CIS_D_7, &MUX_CIS_D_8, &MUX_CIS_D_9, &MUX_CIS_D_10,
+		&MUX_CIS_D_11);
+PINCTRL_DEVICE(CIS_10BIT, 14, &MUX_CIS_CLK, &MUX_CIS_PCLK, &MUX_CIS_HSYNC,
+		&MUX_CIS_VSYNC, &MUX_CIS_D_2, &MUX_CIS_D_3,
+		&MUX_CIS_D_4, &MUX_CIS_D_5, &MUX_CIS_D_6, &MUX_CIS_D_7,
+		&MUX_CIS_D_8, &MUX_CIS_D_9, &MUX_CIS_D_10, &MUX_CIS_D_11);
+PINCTRL_DEVICE(MIPI, 1, &MUX_CIS_CLK);
+PINCTRL_DEVICE(I2C0, 2, &MUX_I2C0_SCL, &MUX_I2C0_SDA);
+PINCTRL_DEVICE(I2C1, 2, &MUX_I2C1_SCL, &MUX_I2C1_SDA);
+PINCTRL_DEVICE(RMII, 12, &MUX_MAC_REF_CLK, &MUX_MAC_RMII_CLK,
+		&MUX_MAC_MDC, &MUX_MAC_MDIO, &MUX_MAC_RXD_0,
+		&MUX_MAC_RXD_1, &MUX_MAC_RXDV, &MUX_MAC_TXD_0,
+		&MUX_MAC_TXD_1, &MUX_MAC_TXEN, &MUX_MAC_TXCK, &MUX_MAC_RXCK);
+PINCTRL_DEVICE(PWM0, 1, &MUX_PWM0);
+PINCTRL_DEVICE(PWM1, 1, &MUX_PWM1);
+PINCTRL_DEVICE(PWM2, 1, &MUX_PWM2);
+PINCTRL_DEVICE(PWM3, 1, &MUX_PWM3);
+PINCTRL_DEVICE(PWM4, 1, &MUX_PWM4);
+PINCTRL_DEVICE(PWM5, 1, &MUX_PWM5);
+PINCTRL_DEVICE(PWM6, 1, &MUX_PWM6);
+PINCTRL_DEVICE(PWM7, 1, &MUX_PWM7);
+PINCTRL_DEVICE(SD0, 6, &MUX_SD0_CLK, &MUX_SD0_CD, &MUX_SD0_CMD_RSP,
+		&MUX_SD0_WP, &MUX_SD0_DATA_0, &MUX_SD0_DATA_1);
+PINCTRL_DEVICE(SD0_CARD_1BIT, 5, &MUX_SD0_CLK, &MUX_SD0_CD, &MUX_SD0_CMD_RSP,
+		&MUX_SD0_WP, &MUX_SD0_DATA_0);
+PINCTRL_DEVICE(SD0_WIFI_2BIT, 4, &MUX_SD0_CLK, &MUX_SD0_CMD_RSP,
+		&MUX_SD0_DATA_0, &MUX_SD0_DATA_1);
+PINCTRL_DEVICE(SD1, 8, &MUX_SD1_CLK, &MUX_SD1_CD, &MUX_SD1_CMD_RSP,
+		&MUX_SD1_WP, &MUX_SD1_DATA_0, &MUX_SD1_DATA_1, &MUX_SD1_DATA_2,
+		&MUX_SD1_DATA_3);
+PINCTRL_DEVICE(SSI0, 4, &MUX_SSI0_CLK, &MUX_SSI0_RXD, &MUX_SSI0_TXD,
+		&MUX_GPIO54);
+PINCTRL_DEVICE(SSI1, 4, &MUX_SSI1_CLK, &MUX_SSI1_RXD, &MUX_SSI1_TXD,
+		&MUX_SSI1_CSN_0);
+PINCTRL_DEVICE(SSI2, 4, &MUX_SSI2_CLK, &MUX_SSI2_RXD, &MUX_SSI2_TXD,
+		&MUX_SSI2_CSN);
+PINCTRL_DEVICE(UART0, 2, &MUX_UART0_RX, &MUX_UART0_TX);
+PINCTRL_DEVICE(UART1, 2, &MUX_UART1_RX, &MUX_UART1_TX);
+PINCTRL_DEVICE(GPIO0, 1, &MUX_GPIO0);
+PINCTRL_DEVICE(GPIO1, 1, &MUX_GPIO1);
+PINCTRL_DEVICE(GPIO2, 1, &MUX_GPIO2);
+PINCTRL_DEVICE(GPIO3, 1, &MUX_GPIO3);
+PINCTRL_DEVICE(GPIO4, 1, &MUX_GPIO4);
+PINCTRL_DEVICE(GPIO5, 1, &MUX_GPIO5);
+PINCTRL_DEVICE(GPIO6, 1, &MUX_GPIO6);
+PINCTRL_DEVICE(GPIO7, 1, &MUX_GPIO7);
+PINCTRL_DEVICE(GPIO8, 1, &MUX_GPIO8);
+PINCTRL_DEVICE(GPIO9, 1, &MUX_GPIO9);
+PINCTRL_DEVICE(GPIO10, 1, &MUX_GPIO10);
+PINCTRL_DEVICE(GPIO11, 1, &MUX_GPIO11);
+PINCTRL_DEVICE(GPIO12, 1, &MUX_GPIO12);
+PINCTRL_DEVICE(GPIO13, 1, &MUX_GPIO13);
+PINCTRL_DEVICE(GPIO14, 1, &MUX_GPIO14);
+PINCTRL_DEVICE(GPIO15, 1, &MUX_GPIO15);
+PINCTRL_DEVICE(GPIO16, 1, &MUX_GPIO16);
+PINCTRL_DEVICE(GPIO17, 1, &MUX_GPIO17);
+PINCTRL_DEVICE(GPIO19, 1, &MUX_GPIO19);
+PINCTRL_DEVICE(GPIO20, 1, &MUX_GPIO20);
+PINCTRL_DEVICE(GPIO21, 1, &MUX_GPIO21);
+PINCTRL_DEVICE(GPIO22, 1, &MUX_GPIO22);
+PINCTRL_DEVICE(GPIO23, 1, &MUX_GPIO23);
+PINCTRL_DEVICE(GPIO24, 1, &MUX_GPIO24);
+PINCTRL_DEVICE(GPIO25, 1, &MUX_GPIO25);
+PINCTRL_DEVICE(GPIO26, 1, &MUX_GPIO26);
+PINCTRL_DEVICE(GPIO27, 1, &MUX_GPIO27);
+PINCTRL_DEVICE(GPIO28, 1, &MUX_GPIO28);
+PINCTRL_DEVICE(GPIO29, 1, &MUX_GPIO29);
+PINCTRL_DEVICE(GPIO30, 1, &MUX_GPIO30);
+PINCTRL_DEVICE(GPIO31, 1, &MUX_GPIO31);
+PINCTRL_DEVICE(GPIO32, 1, &MUX_GPIO32);
+PINCTRL_DEVICE(GPIO33, 1, &MUX_GPIO33);
+PINCTRL_DEVICE(GPIO34, 1, &MUX_GPIO34);
+PINCTRL_DEVICE(GPIO35, 1, &MUX_GPIO35);
+PINCTRL_DEVICE(GPIO36, 1, &MUX_GPIO36);
+PINCTRL_DEVICE(GPIO37, 1, &MUX_GPIO37);
+PINCTRL_DEVICE(GPIO38, 1, &MUX_GPIO38);
+PINCTRL_DEVICE(GPIO39, 1, &MUX_GPIO39);
+PINCTRL_DEVICE(GPIO40, 1, &MUX_GPIO40);
+PINCTRL_DEVICE(GPIO41, 1, &MUX_GPIO41);
+PINCTRL_DEVICE(GPIO42, 1, &MUX_GPIO42);
+PINCTRL_DEVICE(GPIO43, 1, &MUX_GPIO43);
+PINCTRL_DEVICE(GPIO44, 1, &MUX_GPIO44);
+PINCTRL_DEVICE(GPIO45, 1, &MUX_GPIO45);
+PINCTRL_DEVICE(GPIO46, 1, &MUX_GPIO46);
+PINCTRL_DEVICE(GPIO47, 1, &MUX_GPIO47);
+PINCTRL_DEVICE(GPIO48, 1, &MUX_GPIO48);
+PINCTRL_DEVICE(GPIO49, 1, &MUX_GPIO49);
+PINCTRL_DEVICE(GPIO50, 1, &MUX_GPIO50);
+PINCTRL_DEVICE(GPIO51, 1, &MUX_GPIO51);
+PINCTRL_DEVICE(GPIO52, 1, &MUX_GPIO52);
+PINCTRL_DEVICE(GPIO53, 1, &MUX_GPIO53);
+PINCTRL_DEVICE(GPIO54, 1, &MUX_GPIO54);
+PINCTRL_DEVICE(GPIO55, 1, &MUX_GPIO55);
+PINCTRL_DEVICE(GPIO56, 1, &MUX_GPIO56);
+PINCTRL_DEVICE(GPIO57, 1, &MUX_GPIO57);
+PINCTRL_DEVICE(GPIO61, 1, &MUX_GPIO61);
+PINCTRL_DEVICE(GPIO62, 1, &MUX_GPIO62);
+PINCTRL_DEVICE(GPIO63, 1, &MUX_GPIO63);
+
+
+void fh_pinctrl_init_devicelist(OS_LIST *list)
+{
+    OS_LIST_EMPTY(list);
+
+    PINCTRL_ADD_DEVICE(AC);
+    PINCTRL_ADD_DEVICE(ACI2S);
+    PINCTRL_ADD_DEVICE(DWI2S);
+    PINCTRL_ADD_DEVICE(ARCJTAG);
+    PINCTRL_ADD_DEVICE(ARMJTAG);
+    PINCTRL_ADD_DEVICE(PAEJTAG);
+    PINCTRL_ADD_DEVICE(CIS);
+    PINCTRL_ADD_DEVICE(MIPI);
+    PINCTRL_ADD_DEVICE(CIS_10BIT);
+
+    PINCTRL_ADD_DEVICE(I2C0);
+    PINCTRL_ADD_DEVICE(I2C1);
+    PINCTRL_ADD_DEVICE(RMII);
+    PINCTRL_ADD_DEVICE(PWM0);
+    PINCTRL_ADD_DEVICE(PWM1);
+    PINCTRL_ADD_DEVICE(PWM2);
+    PINCTRL_ADD_DEVICE(PWM3);
+    PINCTRL_ADD_DEVICE(PWM4);
+    PINCTRL_ADD_DEVICE(PWM5);
+    PINCTRL_ADD_DEVICE(PWM6);
+    PINCTRL_ADD_DEVICE(PWM7);
+    PINCTRL_ADD_DEVICE(SD0);
+    PINCTRL_ADD_DEVICE(SD0_CARD_1BIT);
+    PINCTRL_ADD_DEVICE(SD0_WIFI_2BIT);
+    PINCTRL_ADD_DEVICE(SD1);
+    PINCTRL_ADD_DEVICE(SSI0);
+    PINCTRL_ADD_DEVICE(SSI1);
+    PINCTRL_ADD_DEVICE(SSI2);
+    PINCTRL_ADD_DEVICE(UART0);
+    PINCTRL_ADD_DEVICE(UART1);
+    PINCTRL_ADD_DEVICE(GPIO0);
+    PINCTRL_ADD_DEVICE(GPIO1);
+    PINCTRL_ADD_DEVICE(GPIO2);
+    PINCTRL_ADD_DEVICE(GPIO3);
+    PINCTRL_ADD_DEVICE(GPIO4);
+    PINCTRL_ADD_DEVICE(GPIO5);
+    PINCTRL_ADD_DEVICE(GPIO6);
+    PINCTRL_ADD_DEVICE(GPIO7);
+    PINCTRL_ADD_DEVICE(GPIO8);
+    PINCTRL_ADD_DEVICE(GPIO9);
+    PINCTRL_ADD_DEVICE(GPIO10);
+    PINCTRL_ADD_DEVICE(GPIO11);
+    PINCTRL_ADD_DEVICE(GPIO12);
+    PINCTRL_ADD_DEVICE(GPIO13);
+    PINCTRL_ADD_DEVICE(GPIO14);
+    PINCTRL_ADD_DEVICE(GPIO15);
+    PINCTRL_ADD_DEVICE(GPIO16);
+    PINCTRL_ADD_DEVICE(GPIO17);
+    PINCTRL_ADD_DEVICE(GPIO19);
+    PINCTRL_ADD_DEVICE(GPIO20);
+    PINCTRL_ADD_DEVICE(GPIO21);
+    PINCTRL_ADD_DEVICE(GPIO22);
+    PINCTRL_ADD_DEVICE(GPIO23);
+    PINCTRL_ADD_DEVICE(GPIO24);
+    PINCTRL_ADD_DEVICE(GPIO25);
+    PINCTRL_ADD_DEVICE(GPIO26);
+    PINCTRL_ADD_DEVICE(GPIO27);
+    PINCTRL_ADD_DEVICE(GPIO28);
+    PINCTRL_ADD_DEVICE(GPIO29);
+    PINCTRL_ADD_DEVICE(GPIO30);
+    PINCTRL_ADD_DEVICE(GPIO31);
+    PINCTRL_ADD_DEVICE(GPIO32);
+    PINCTRL_ADD_DEVICE(GPIO33);
+    PINCTRL_ADD_DEVICE(GPIO34);
+    PINCTRL_ADD_DEVICE(GPIO35);
+    PINCTRL_ADD_DEVICE(GPIO36);
+    PINCTRL_ADD_DEVICE(GPIO37);
+    PINCTRL_ADD_DEVICE(GPIO38);
+    PINCTRL_ADD_DEVICE(GPIO39);
+    PINCTRL_ADD_DEVICE(GPIO40);
+    PINCTRL_ADD_DEVICE(GPIO41);
+    PINCTRL_ADD_DEVICE(GPIO42);
+    PINCTRL_ADD_DEVICE(GPIO43);
+    PINCTRL_ADD_DEVICE(GPIO44);
+    PINCTRL_ADD_DEVICE(GPIO45);
+    PINCTRL_ADD_DEVICE(GPIO46);
+    PINCTRL_ADD_DEVICE(GPIO47);
+    PINCTRL_ADD_DEVICE(GPIO48);
+    PINCTRL_ADD_DEVICE(GPIO49);
+    PINCTRL_ADD_DEVICE(GPIO50);
+    PINCTRL_ADD_DEVICE(GPIO51);
+    PINCTRL_ADD_DEVICE(GPIO52);
+    PINCTRL_ADD_DEVICE(GPIO53);
+    PINCTRL_ADD_DEVICE(GPIO54);
+    PINCTRL_ADD_DEVICE(GPIO55);
+    PINCTRL_ADD_DEVICE(GPIO56);
+    PINCTRL_ADD_DEVICE(GPIO57);
+    PINCTRL_ADD_DEVICE(GPIO61);
+    PINCTRL_ADD_DEVICE(GPIO62);
+    PINCTRL_ADD_DEVICE(GPIO63);
+}
+
+
+
+char* fh_pinctrl_selected_devices[] =
+{
+	CONFIG_PINCTRL_SELECT
+};
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/fh_dmac.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/fh_dmac.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/fh_dmac.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/fh_dmac.h	2021-07-13 23:40:30.650336818 +0300
@@ -0,0 +1,151 @@
+/*
+ * Driver for the Synopsys DesignWare DMA Controller (aka DMACA on
+ * AVR32 systems.)
+ *
+ * Copyright (C) 2007 Atmel Corporation
+ * Copyright (C) 2010-2011 ST Microelectronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef FH_DMAC_H
+#define FH_DMAC_H
+
+#include <linux/dmaengine.h>
+
+/**
+ * enum fh_dma_slave_width - DMA slave register access width.
+ * @DMA_SLAVE_WIDTH_8BIT: Do 8-bit slave register accesses
+ * @DMA_SLAVE_WIDTH_16BIT: Do 16-bit slave register accesses
+ * @DMA_SLAVE_WIDTH_32BIT: Do 32-bit slave register accesses
+ */
+enum fh_dma_slave_width {
+	FH_DMA_SLAVE_WIDTH_8BIT,
+	FH_DMA_SLAVE_WIDTH_16BIT,
+	FH_DMA_SLAVE_WIDTH_32BIT,
+};
+
+/* bursts size */
+enum fh_dma_msize {
+	FH_DMA_MSIZE_1,
+	FH_DMA_MSIZE_4,
+	FH_DMA_MSIZE_8,
+	FH_DMA_MSIZE_16,
+	FH_DMA_MSIZE_32,
+	FH_DMA_MSIZE_64,
+	FH_DMA_MSIZE_128,
+	FH_DMA_MSIZE_256,
+};
+
+/* flow controller */
+enum fh_dma_fc {
+	FH_DMA_FC_D_M2M,
+	FH_DMA_FC_D_M2P,
+	FH_DMA_FC_D_P2M,
+	FH_DMA_FC_D_P2P,
+	FH_DMA_FC_P_P2M,
+	FH_DMA_FC_SP_P2P,
+	FH_DMA_FC_P_M2P,
+	FH_DMA_FC_DP_P2P,
+};
+
+/**
+ * struct fh_dma_slave - Controller-specific information about a slave
+ *
+ * @dma_dev: required DMA master device
+ * @tx_reg: physical address of data register used for
+ *	memory-to-peripheral transfers
+ * @rx_reg: physical address of data register used for
+ *	peripheral-to-memory transfers
+ * @reg_width: peripheral register width
+ * @cfg_hi: Platform-specific initializer for the CFG_HI register
+ * @cfg_lo: Platform-specific initializer for the CFG_LO register
+ * @src_master: src master for transfers on allocated channel.
+ * @dst_master: dest master for transfers on allocated channel.
+ * @src_msize: src burst size.
+ * @dst_msize: dest burst size.
+ * @fc: flow controller for DMA transfer
+ */
+struct fh_dma_slave {
+	struct device		*dma_dev;
+	dma_addr_t		tx_reg;
+	dma_addr_t		rx_reg;
+	enum fh_dma_slave_width	reg_width;
+	u32			cfg_hi;
+	u32			cfg_lo;
+	u8			src_master;
+	u8			dst_master;
+	u8			src_msize;
+	u8			dst_msize;
+	u8			fc;
+};
+
+
+/**
+ * struct fh_dma_platform_data - Controller configuration parameters
+ * @nr_channels: Number of channels supported by hardware (max 8)
+ * @is_private: The device channels should be marked as private and not for
+ *	by the general purpose DMA channel allocator.
+ * @chan_allocation_order: Allocate channels starting from 0 or 7
+ * @chan_priority: Set channel priority increasing from 0 to 7 or 7 to 0.
+ * @block_size: Maximum block size supported by the controller
+ * @nr_masters: Number of AHB masters supported by the controller
+ * @data_width: Maximum data width supported by hardware per AHB master
+ *		(0 - 8bits, 1 - 16bits, ..., 5 - 256bits)
+ * @sd: slave specific data. Used for configuring channels
+ * @sd_count: count of slave data structures passed.
+ */
+struct fh_dma_platform_data {
+	unsigned int	nr_channels;
+	bool		is_private;
+#define CHAN_ALLOCATION_ASCENDING	0	/* zero to seven */
+#define CHAN_ALLOCATION_DESCENDING	1	/* seven to zero */
+	unsigned char	chan_allocation_order;
+#define CHAN_PRIORITY_ASCENDING		0	/* chan0 highest */
+#define CHAN_PRIORITY_DESCENDING	1	/* chan7 highest */
+	unsigned char	chan_priority;
+	unsigned short	block_size;
+	unsigned char	nr_masters;
+	unsigned char	data_width[4];
+};
+
+/* Platform-configurable bits in CFG_HI */
+#define FHC_CFGH_FCMODE		(1 << 0)
+#define FHC_CFGH_FIFO_MODE	(1 << 1)
+#define FHC_CFGH_PROTCTL(x)	((x) << 2)
+#define FHC_CFGH_SRC_PER(x)	((x) << 7)
+#define FHC_CFGH_DST_PER(x)	((x) << 11)
+
+/* Platform-configurable bits in CFG_LO */
+#define FHC_CFGL_LOCK_CH_XFER	(0 << 12)	/* scope of LOCK_CH */
+#define FHC_CFGL_LOCK_CH_BLOCK	(1 << 12)
+#define FHC_CFGL_LOCK_CH_XACT	(2 << 12)
+#define FHC_CFGL_LOCK_BUS_XFER	(0 << 14)	/* scope of LOCK_BUS */
+#define FHC_CFGL_LOCK_BUS_BLOCK	(1 << 14)
+#define FHC_CFGL_LOCK_BUS_XACT	(2 << 14)
+#define FHC_CFGL_LOCK_CH	(1 << 15)	/* channel lockout */
+#define FHC_CFGL_LOCK_BUS	(1 << 16)	/* busmaster lockout */
+#define FHC_CFGL_HS_DST_POL	(1 << 18)	/* dst handshake active low */
+#define FHC_CFGL_HS_SRC_POL	(1 << 19)	/* src handshake active low */
+
+/* DMA API extensions */
+struct fh_cyclic_desc {
+	struct fh_desc	**desc;
+	unsigned long	periods;
+	void	(*period_callback)(void *param);
+	void		*period_callback_param;
+};
+
+struct fh_cyclic_desc *fh_dma_cyclic_prep(struct dma_chan *chan,
+		dma_addr_t buf_addr, size_t buf_len, size_t period_len,
+		enum dma_transfer_direction direction);
+void fh_dma_cyclic_free(struct dma_chan *chan);
+int fh_dma_cyclic_start(struct dma_chan *chan);
+void fh_dma_cyclic_stop(struct dma_chan *chan);
+
+dma_addr_t fh_dma_get_src_addr(struct dma_chan *chan);
+
+dma_addr_t fh_dma_get_dst_addr(struct dma_chan *chan);
+
+#endif /* FH_DMAC_H */
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/fh_dmac_regs.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/fh_dmac_regs.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/fh_dmac_regs.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/fh_dmac_regs.h	2021-07-13 23:40:30.650336818 +0300
@@ -0,0 +1,312 @@
+/*
+ * Driver for the Synopsys DesignWare AHB DMA Controller
+ *
+ * Copyright (C) 2005-2007 Atmel Corporation
+ * Copyright (C) 2010-2011 ST Microelectronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/dmaengine.h>
+#include <mach/fh_dmac.h>
+
+#define FH_DMA_MAX_NR_CHANNELS	8
+#define FH_DMA_MAX_NR_REQUESTS	16
+
+/*
+ * Redefine this macro to handle differences between 32- and 64-bit
+ * addressing, big vs. little endian, etc.
+ */
+#define FH_REG(name)		u32 name; u32 __pad_##name
+
+/* Hardware register definitions. */
+struct fh_dma_chan_regs {
+	FH_REG(SAR);		/* Source Address Register */
+	FH_REG(DAR);		/* Destination Address Register */
+	FH_REG(LLP);		/* Linked List Pointer */
+	u32	CTL_LO;		/* Control Register Low */
+	u32	CTL_HI;		/* Control Register High */
+	FH_REG(SSTAT);
+	FH_REG(DSTAT);
+	FH_REG(SSTATAR);
+	FH_REG(DSTATAR);
+	u32	CFG_LO;		/* Configuration Register Low */
+	u32	CFG_HI;		/* Configuration Register High */
+	FH_REG(SGR);
+	FH_REG(DSR);
+};
+
+struct fh_dma_irq_regs {
+	FH_REG(XFER);
+	FH_REG(BLOCK);
+	FH_REG(SRC_TRAN);
+	FH_REG(DST_TRAN);
+	FH_REG(ERROR);
+};
+
+struct fh_dma_regs {
+	/* per-channel registers */
+	struct fh_dma_chan_regs	CHAN[FH_DMA_MAX_NR_CHANNELS];
+
+	/* irq handling */
+	struct fh_dma_irq_regs	RAW;		/* r */
+	struct fh_dma_irq_regs	STATUS;		/* r (raw & mask) */
+	struct fh_dma_irq_regs	MASK;		/* rw (set = irq enabled) */
+	struct fh_dma_irq_regs	CLEAR;		/* w (ack, affects "raw") */
+
+	FH_REG(STATUS_INT);			/* r */
+
+	/* software handshaking */
+	FH_REG(REQ_SRC);
+	FH_REG(REQ_DST);
+	FH_REG(SGL_REQ_SRC);
+	FH_REG(SGL_REQ_DST);
+	FH_REG(LAST_SRC);
+	FH_REG(LAST_DST);
+
+	/* miscellaneous */
+	FH_REG(CFG);
+	FH_REG(CH_EN);
+	FH_REG(ID);
+	FH_REG(TEST);
+
+	/* reserved */
+	FH_REG(__reserved0);
+	FH_REG(__reserved1);
+
+	/* optional encoded params, 0x3c8..0x3f7 */
+	u32	__reserved;
+
+	/* per-channel configuration registers */
+	u32	FHC_PARAMS[FH_DMA_MAX_NR_CHANNELS];
+	u32	MULTI_BLK_TYPE;
+	u32	MAX_BLK_SIZE;
+
+	/* top-level parameters */
+	u32	FH_PARAMS;
+};
+
+#ifdef CONFIG_FH_DMAC_BIG_ENDIAN_IO
+#define dma_readl_native ioread32be
+#define dma_writel_native iowrite32be
+#else
+#define dma_readl_native readl
+#define dma_writel_native writel
+#endif
+
+/* To access the registers in early stage of probe */
+#define dma_read_byaddr(addr, name) \
+	dma_readl_native((addr) + offsetof(struct fh_dma_regs, name))
+
+/* Bitfields in FH_PARAMS */
+#define FH_PARAMS_NR_CHAN	8		/* number of channels */
+#define FH_PARAMS_NR_MASTER	11		/* number of AHB masters */
+#define FH_PARAMS_DATA_WIDTH(n)	(15 + 2 * (n))
+#define FH_PARAMS_DATA_WIDTH1	15		/* master 1 data width */
+#define FH_PARAMS_DATA_WIDTH2	17		/* master 2 data width */
+#define FH_PARAMS_DATA_WIDTH3	19		/* master 3 data width */
+#define FH_PARAMS_DATA_WIDTH4	21		/* master 4 data width */
+#define FH_PARAMS_EN		28		/* encoded parameters */
+
+/* Bitfields in FHC_PARAMS */
+#define FHC_PARAMS_MBLK_EN	11		/* multi block transfer */
+
+/* Bitfields in CTL_LO */
+#define FHC_CTLL_INT_EN		(1 << 0)	/* irqs enabled? */
+#define FHC_CTLL_DST_WIDTH(n)	((n)<<1)	/* bytes per element */
+#define FHC_CTLL_SRC_WIDTH(n)	((n)<<4)
+#define FHC_CTLL_DST_INC	(0<<7)		/* DAR update/not */
+#define FHC_CTLL_DST_DEC	(1<<7)
+#define FHC_CTLL_DST_FIX	(2<<7)
+#define FHC_CTLL_SRC_INC	(0<<9)		/* SAR update/not */
+#define FHC_CTLL_SRC_DEC	(1<<9)
+#define FHC_CTLL_SRC_FIX	(2<<9)
+#define FHC_CTLL_DST_MSIZE(n)	((n)<<11)	/* burst, #elements */
+#define FHC_CTLL_SRC_MSIZE(n)	((n)<<14)
+#define FHC_CTLL_S_GATH_EN	(1 << 17)	/* src gather, !FIX */
+#define FHC_CTLL_D_SCAT_EN	(1 << 18)	/* dst scatter, !FIX */
+#define FHC_CTLL_FC(n)		((n) << 20)
+#define FHC_CTLL_FC_M2M		(0 << 20)	/* mem-to-mem */
+#define FHC_CTLL_FC_M2P		(1 << 20)	/* mem-to-periph */
+#define FHC_CTLL_FC_P2M		(2 << 20)	/* periph-to-mem */
+#define FHC_CTLL_FC_P2P		(3 << 20)	/* periph-to-periph */
+/* plus 4 transfer types for peripheral-as-flow-controller */
+#define FHC_CTLL_DMS(n)		((n)<<23)	/* dst master select */
+#define FHC_CTLL_SMS(n)		((n)<<25)	/* src master select */
+#define FHC_CTLL_LLP_D_EN	(1 << 27)	/* dest block chain */
+#define FHC_CTLL_LLP_S_EN	(1 << 28)	/* src block chain */
+
+/* Bitfields in CTL_HI */
+#define FHC_CTLH_DONE		0x00001000
+#define FHC_CTLH_BLOCK_TS_MASK	0x00000fff
+
+/* Bitfields in CFG_LO. Platform-configurable bits are in <linux/fh_dmac.h> */
+#define FHC_CFGL_CH_PRIOR_MASK	(0x7 << 5)	/* priority mask */
+#define FHC_CFGL_CH_PRIOR(x)	((x) << 5)	/* priority */
+#define FHC_CFGL_CH_SUSP	(1 << 8)	/* pause xfer */
+#define FHC_CFGL_FIFO_EMPTY	(1 << 9)	/* pause xfer */
+#define FHC_CFGL_HS_DST		(1 << 10)	/* handshake w/dst */
+#define FHC_CFGL_HS_SRC		(1 << 11)	/* handshake w/src */
+#define FHC_CFGL_MAX_BURST(x)	((x) << 20)
+#define FHC_CFGL_RELOAD_SAR	(1 << 30)
+#define FHC_CFGL_RELOAD_DAR	(1 << 31)
+
+/* Bitfields in CFG_HI. Platform-configurable bits are in <linux/fh_dmac.h> */
+#define FHC_CFGH_DS_UPD_EN	(1 << 5)
+#define FHC_CFGH_SS_UPD_EN	(1 << 6)
+
+/* Bitfields in SGR */
+#define FHC_SGR_SGI(x)		((x) << 0)
+#define FHC_SGR_SGC(x)		((x) << 20)
+
+/* Bitfields in DSR */
+#define FHC_DSR_DSI(x)		((x) << 0)
+#define FHC_DSR_DSC(x)		((x) << 20)
+
+/* Bitfields in CFG */
+#define FH_CFG_DMA_EN		(1 << 0)
+
+#define FH_REGLEN       0x400
+
+enum fh_dmac_flags {
+	FH_DMA_IS_CYCLIC = 0,
+	FH_DMA_IS_SOFT_LLP = 1,
+};
+
+struct fh_dma_chan {
+	struct dma_chan			chan;
+	void __iomem			*ch_regs;
+	u8				mask;
+	u8				priority;
+	enum dma_transfer_direction	direction;
+	bool				paused;
+	bool				initialized;
+
+	/* software emulation of the LLP transfers */
+	struct list_head	*tx_node_active;
+
+	spinlock_t		lock;
+
+	/* these other elements are all protected by lock */
+	unsigned long		flags;
+	struct list_head	active_list;
+	struct list_head	queue;
+	struct list_head	free_list;
+	u32			residue;
+	struct fh_cyclic_desc	*cdesc;
+
+	unsigned int		descs_allocated;
+
+	/* hardware configuration */
+	unsigned int		block_size;
+	bool			nollp;
+
+	/* custom slave configuration */
+	unsigned int		request_line;
+	unsigned char		src_master;
+	unsigned char		dst_master;
+
+	/* configuration passed via DMA_SLAVE_CONFIG */
+	struct dma_slave_config dma_sconfig;
+};
+
+enum fh_dma_slave_increment {
+	FH_DMA_SLAVE_INC,
+	FH_DMA_SLAVE_DEC,
+	FH_DMA_SLAVE_FIX,
+};
+
+struct fh_dma_pri {
+	u32 sinc;
+	u32 dinc;
+};
+
+static inline struct fh_dma_chan_regs __iomem *
+__fhc_regs(struct fh_dma_chan *fhc)
+{
+	return fhc->ch_regs;
+}
+
+#define channel_readl(fhc, name) \
+	dma_readl_native(&(__fhc_regs(fhc)->name))
+#define channel_writel(fhc, name, val) \
+	dma_writel_native((val), &(__fhc_regs(fhc)->name))
+
+static inline struct fh_dma_chan *to_fh_dma_chan(struct dma_chan *chan)
+{
+	return container_of(chan, struct fh_dma_chan, chan);
+}
+
+struct fh_dma {
+	struct dma_device	dma;
+	void __iomem		*regs;
+	struct dma_pool		*desc_pool;
+	struct tasklet_struct	tasklet;
+	struct clk		*clk;
+
+	u8			all_chan_mask;
+
+	/* hardware configuration */
+	unsigned char		nr_masters;
+	unsigned char		data_width[4];
+
+	struct fh_dma_chan	chan[0];
+};
+
+static inline struct fh_dma_regs __iomem *__fh_regs(struct fh_dma *dw)
+{
+	return dw->regs;
+}
+
+#define dma_readl(dw, name) \
+	dma_readl_native(&(__fh_regs(dw)->name))
+#define dma_writel(dw, name, val) \
+	dma_writel_native((val), &(__fh_regs(dw)->name))
+
+#define channel_set_bit(dw, reg, mask) \
+	dma_writel(dw, reg, ((mask) << 8) | (mask))
+#define channel_clear_bit(dw, reg, mask) \
+	dma_writel(dw, reg, ((mask) << 8) | 0)
+
+static inline struct fh_dma *to_fh_dma(struct dma_device *ddev)
+{
+	return container_of(ddev, struct fh_dma, dma);
+}
+
+/* LLI == Linked List Item; a.k.a. DMA block descriptor */
+struct fh_lli {
+	/* values that are not changed by hardware */
+	u32		sar;
+	u32		dar;
+	u32		llp;		/* chain to next lli */
+	u32		ctllo;
+	/* values that may get written back: */
+	u32		ctlhi;
+	/* sstat and dstat can snapshot peripheral register state.
+	 * silicon config may discard either or both...
+	 */
+	u32		sstat;
+	u32		dstat;
+};
+
+struct fh_desc {
+	/* FIRST values the hardware uses */
+	struct fh_lli			lli;
+
+	/* THEN values for driver housekeeping */
+	struct list_head		desc_node;
+	struct list_head		tx_list;
+	struct dma_async_tx_descriptor	txd;
+	size_t				len;
+	size_t				total_len;
+};
+
+#define to_fh_desc(h)	list_entry(h, struct fh_desc, desc_node)
+
+static inline struct fh_desc *
+txd_to_fh_desc(struct dma_async_tx_descriptor *txd)
+{
+	return container_of(txd, struct fh_desc, txd);
+}
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/fh_gmac.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/fh_gmac.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/fh_gmac.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/fh_gmac.h	2021-07-13 23:40:30.650336818 +0300
@@ -0,0 +1,33 @@
+#ifndef __FH_GMAC_PLATFORM_DATA
+#define __FH_GMAC_PLATFORM_DATA
+
+#include <linux/platform_device.h>
+
+enum {
+	gmac_phyt_reg_basic_ctrl = 0,
+	gmac_phyt_reg_basic_status = 1,
+	gmac_phyt_reg_phy_id1 = 2,
+	gmac_phyt_reg_phy_id2 = 3,
+	gmac_phyt_rtl8201_rmii_mode = 16,
+	gmac_phyt_ti83848_rmii_mode = 17,
+	gmac_phyt_rtl8201_power_saving = 24,
+	gmac_phyt_rtl8201_page_select = 31,
+	gmac_phyt_ip101g_page_select = 20
+};
+
+enum {
+	gmac_speed_10m,
+	gmac_speed_100m
+};
+
+struct fh_gmac_platform_data {
+	int interface;
+	int phyid;
+	void (*early_init)(struct fh_gmac_platform_data *plat_data);
+	void (*plat_init)(struct fh_gmac_platform_data *plat_data);
+	void (*set_rmii_speed)(int speed);
+	void (*phy_reset)(void);
+};
+
+#endif
+
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/fhmci.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/fhmci.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/fhmci.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/fhmci.h	2021-07-13 23:40:30.650336818 +0300
@@ -0,0 +1,178 @@
+#ifndef _FH_MCI_H_
+#define _FH_MCI_H_
+
+extern int trace_level;
+#define FHMCI_TRACE_LEVEL 5
+/*
+   0 - all message
+   1 - dump all register read/write
+   2 - flow trace
+   3 - timeout err and protocol err
+   */
+
+#define FHMCI_TRACE_FMT KERN_INFO
+#define ID_SD0        0
+#define ID_SD1        1
+
+#define POWER_ON	1
+#define POWER_OFF	0
+
+#define CARD_UNPLUGED	1
+#define CARD_PLUGED	0
+
+#define ENABLE		1
+#define DISABLE		0
+
+#define FH_MCI_DETECT_TIMEOUT	(HZ/4)
+
+#define FH_MCI_REQUEST_TIMEOUT	(5 * HZ)
+
+#define MAX_RETRY_COUNT   100
+#define MAX_MCI_HOST	(2)	/* max num of host on soc */
+
+#define fhmci_trace(level, msg...) do { \
+	if ((level) >= trace_level) { \
+		printk(FHMCI_TRACE_FMT "%s:%d: ", __func__, __LINE__); \
+		printk(msg); \
+		printk("\n"); \
+	} \
+} while (0)
+
+#define fhmci_assert(cond) do { \
+	if (!(cond)) {\
+		printk(KERN_ERR "Assert:fhmci:%s:%d\n", \
+				__func__, \
+				__LINE__); \
+		BUG(); \
+	} \
+} while (0)
+
+#define fhmci_error(s...) do { \
+	printk(KERN_ERR "fhmci:%s:%d: ", __func__, __LINE__); \
+	printk(s); \
+	printk("\n"); \
+} while (0)
+
+#define fhmci_readl(addr) ({unsigned int reg = readl((unsigned int)addr); \
+	fhmci_trace(1, "readl(0x%04X) = 0x%08X", (unsigned int)addr, reg); \
+	reg; })
+
+#define fhmci_writel(v, addr) do { \
+	writel(v, (unsigned int)addr); \
+	fhmci_trace(1, "writel(0x%04X) = 0x%08X",\
+			(unsigned int)addr, (unsigned int)(v)); \
+} while (0)
+
+
+struct fhmci_des {
+	unsigned long idmac_des_ctrl;
+	unsigned long idmac_des_buf_size;
+	unsigned long idmac_des_buf_addr;
+	unsigned long idmac_des_next_addr;
+};
+
+struct fhmci_host {
+	struct mmc_host		*mmc;
+	spinlock_t		lock;
+	struct mmc_request	*mrq;
+	struct mmc_command	*cmd;
+	struct mmc_data		*data;
+	void __iomem		*base;
+	unsigned int		card_status;
+	struct scatterlist	*dma_sg;
+	unsigned int		dma_sg_num;
+	unsigned int		dma_alloc_size;
+	unsigned int		dma_dir;
+	dma_addr_t		dma_paddr;
+	unsigned int		*dma_vaddr;
+	struct timer_list	timer;
+	unsigned int		irq;
+	unsigned int		irq_status;
+	unsigned int		is_tuning;
+	wait_queue_head_t	intr_wait;
+	unsigned long		pending_events;
+	unsigned int		id;
+	struct fh_mci_board *pdata;
+	unsigned int (*get_cd)(struct fhmci_host *host);
+	unsigned int (*get_ro)(struct fhmci_host *host);
+#define	FHMCI_PEND_DTO_b	(0)
+#define	FHMCI_PEND_DTO_m	(1 << FHMCI_PEND_DTO_b)
+};
+
+/* Board platform data */
+struct fh_mci_board {
+    unsigned int num_slots;
+
+    unsigned int quirks; /* Workaround / Quirk flags */
+    unsigned int bus_hz; /* Bus speed */
+
+    unsigned int caps;  /* Capabilities */
+
+    /* delay in mS before detecting cards after interrupt */
+    unsigned int detect_delay_ms;
+
+    int (*init)(unsigned int slot_id,void* irq_handler_t , void *);
+    unsigned int (*get_ro)(struct fhmci_host *host);
+    unsigned int (*get_cd)(struct fhmci_host *host);
+    int (*get_ocr)(unsigned int slot_id);
+    int (*get_bus_wd)(unsigned int slot_id);
+    /*
+     * Enable power to selected slot and set voltage to desired level.
+     * Voltage levels are specified using MMC_VDD_xxx defines defined
+     * in linux/mmc/host.h file.
+     */
+    void (*setpower)(unsigned int slot_id, unsigned int volt);
+    void (*exit)(unsigned int slot_id);
+    void (*select_slot)(unsigned int slot_id);
+
+    struct dw_mci_dma_ops *dma_ops;
+    struct dma_pdata *data;
+    struct block_settings *blk_settings;
+    int fifo_depth;
+};
+
+union cmd_arg_s {
+	unsigned int cmd_arg;
+	struct cmd_bits_arg {
+		unsigned int cmd_index:6;
+		unsigned int response_expect:1;
+		unsigned int response_length:1;
+		unsigned int check_response_crc:1;
+		unsigned int data_transfer_expected:1;
+		unsigned int read_write:1;
+		unsigned int transfer_mode:1;
+		unsigned int send_auto_stop:1;
+		unsigned int wait_prvdata_complete:1;
+		unsigned int stop_abort_cmd:1;
+		unsigned int send_initialization:1;
+		unsigned int card_number:5;
+		unsigned int update_clk_reg_only:1; /* bit 21 */
+		unsigned int read_ceata_device:1;
+		unsigned int ccs_expected:1;
+		unsigned int enable_boot:1;
+		unsigned int expect_boot_ack:1;
+		unsigned int disable_boot:1;
+		unsigned int boot_mode:1;
+		unsigned int volt_switch:1;
+		unsigned int use_hold_reg:1;
+		unsigned int reserved:1;
+		unsigned int start_cmd:1; /* HSB */
+	} bits;
+};
+
+struct mmc_ctrl {
+	unsigned int slot_idx;       /*0: mmc0;  1: mmc1*/
+	unsigned int mmc_ctrl_state; /*0: enable mmc_rescan;  1: disable mmc_rescan*/
+};
+
+enum mmc_ctrl_state {
+	RESCAN_ENABLE = 0,
+	RESCAN_DISABLE
+};
+
+struct platform_device *get_mci_device(unsigned int index);
+int storage_dev_set_mmc_rescan(struct mmc_ctrl *m_ctrl);
+int read_mci_ctrl_states(int id_mmc_sd);
+
+#endif
+
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/fh_predefined.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/fh_predefined.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/fh_predefined.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/fh_predefined.h	2021-07-13 23:40:30.650336818 +0300
@@ -0,0 +1,40 @@
+/*
+ * fh_predefined.h
+ *
+ *  Created on: May 22, 2014
+ *      Author: duobao
+ */
+
+#ifndef FH_PREDEFINED_H_
+#define FH_PREDEFINED_H_
+
+typedef unsigned char		UINT8;
+typedef unsigned short	UINT16;
+typedef unsigned int		UINT32;
+typedef unsigned long long	UINT64;
+
+typedef char			SINT8;
+typedef short			SINT16;
+typedef int			SINT32;
+typedef long long		SINT64;
+#define FALSE 			(0)
+#define TRUE 			(!FALSE)
+#define reg_read(addr) (*((volatile UINT32 *)(addr)))
+#define reg_write(addr,value) (*(volatile UINT32 *)(addr)=(value))
+
+#define GET_REG(addr) reg_read(addr)
+#define SET_REG(addr,value) reg_write(addr,value)
+#define SET_REG_M(addr,value,mask) reg_write(addr,(reg_read(addr)&(~(mask)))|((value)&(mask)))
+#define SET_REG_B(addr,element,highbit,lowbit) SET_REG_M((addr),((element)<<(lowbit)),(((1<<((highbit)-(lowbit)+1))-1)<<(lowbit)))
+
+#define GET_REG8(addr) (*((volatile UINT8 *)(addr)))
+#define SET_REG8(addr,value) (*(volatile UINT8 *)(addr)=(value))
+
+#define LD8(addr) 		(*((volatile u8 *)(addr)))
+#define ST8(addr,value)		(*(volatile u8 *)(addr)=(value))
+#define LD16(addr) 		(*((volatile u16 *)(addr)))
+#define ST16(addr,value)	(*(volatile u16 *)(addr)=(value))
+#define LD32(addr)		(*((volatile u32 *)(addr)))
+#define ST32(addr,value)	(*(volatile u32 *)(addr)=(value))
+
+#endif /* FH_PREDEFINED_H_ */
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/fh_sadc.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/fh_sadc.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/fh_sadc.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/fh_sadc.h	2021-07-13 23:40:30.650336818 +0300
@@ -0,0 +1,83 @@
+/*
+ * fh_sadc.h
+ *
+ *  Created on: Mar 13, 2015
+ *      Author: duobao
+ */
+
+#ifndef FH_SADC_H_
+#define FH_SADC_H_
+
+#include <linux/io.h>
+#include <linux/scatterlist.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/scatterlist.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include <linux/bug.h>
+#include <linux/completion.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+
+/****************************************************************************
+ * #define section
+ *	add constant #define here if any
+ ***************************************************************************/
+#define FH_SADC_PROC_FILE    "driver/sadc"
+#define MAX_CHANNEL_NO		(8)
+#define SADC_REF			(3300)
+#define SADC_MAX_AD_VALUE	(0x3ff)
+#define LOOP_MODE			(0x55)
+#define ISR_MODE			(0xAA)
+
+
+#define SADC_TIMEOUT  		0x55
+/****************************************************************************
+ * ADT section
+ *	add Abstract Data Type definition here
+ ***************************************************************************/
+
+struct wrap_sadc_reg {
+	u32 sadc_cmd;
+	u32 sadc_control;
+	u32 sadc_ier;
+	u32 sadc_int_status;
+	u32 sadc_dout0;
+	u32 sadc_dout1;
+	u32 sadc_dout2;
+	u32 sadc_dout3;
+	u32 sadc_debuge0;
+	u32 sadc_status;
+	u32 sadc_cnt;
+	u32 sadc_timeout;
+};
+
+struct wrap_sadc_obj {
+	void *regs;
+	u32 irq_no;
+	u32 active_channel_no;
+	u32 active_channel_status;
+	uint16_t channel_data[MAX_CHANNEL_NO];
+	u32 error_rec;
+	u32 en_isr;
+	u32 sample_mode;
+	spinlock_t lock;
+	struct completion done;
+	struct proc_dir_entry *proc_file;
+};
+
+#ifdef CONFIG_FH_SADC
+long fh_sadc_get_value(int channel);
+#else
+long fh_sadc_get_value(int channel)
+{
+	return 0;
+}
+#endif
+
+#endif /* fh_SADC_H_ */
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/fh_simple_timer.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/fh_simple_timer.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/fh_simple_timer.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/fh_simple_timer.h	2021-07-13 23:40:30.654336845 +0300
@@ -0,0 +1,45 @@
+/*
+ * fh_simple_timer.h
+ *
+ *  Created on: Jan 22, 2017
+ *      Author: duobao
+ */
+
+#ifndef FH_SIMPLE_TIMER_H_
+#define FH_SIMPLE_TIMER_H_
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/time.h>
+#include <linux/ktime.h>
+#include <linux/timerqueue.h>
+#include <mach/pmu.h>
+#include <mach/timex.h>
+#include <mach/io.h>
+#include <mach/fh_predefined.h>
+
+enum simple_timer_state {
+	SIMPLE_TIMER_STOP,
+	SIMPLE_TIMER_START,
+	SIMPLE_TIMER_ERROR,
+};
+
+struct fh_simple_timer
+{
+	struct timerqueue_node		node;
+	ktime_t it_interval;	/* timer period */
+	ktime_t it_value;	/* timer expiration */
+	ktime_t it_delay;
+	void (*function) (void *);
+	void *param;
+};
+
+
+int fh_simple_timer_interrupt(void);
+int fh_simple_timer_create(struct fh_simple_timer* tim);
+int fh_timer_start(void);
+int fh_simple_timer_init(void);
+
+#endif /* FH_SIMPLE_TIMER_H_ */
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/fh_wdt.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/fh_wdt.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/fh_wdt.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/fh_wdt.h	2021-07-13 23:40:30.654336845 +0300
@@ -0,0 +1,12 @@
+#ifndef __FH_WDT_PLATFORM_DATA
+#define __FH_WDT_PLATFORM_DATA
+
+#include <linux/platform_device.h>
+
+struct fh_wdt_platform_data {
+	void (*resume)(void);
+	void (*pause)(void);
+};
+
+#endif
+
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/gpio.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/gpio.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/gpio.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/gpio.h	2021-07-13 23:40:30.650336818 +0300
@@ -0,0 +1,259 @@
+/*
+ * TI DaVinci GPIO Support
+ *
+ * Copyright (c) 2006 David Brownell
+ * Copyright (c) 2007, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __FH_GPIO_H
+#define __FH_GPIO_H
+
+#include <linux/io.h>
+#include <linux/spinlock.h>
+
+#include <asm-generic/gpio.h>
+
+#include <mach/irqs.h>
+#include <mach/fh_predefined.h>
+
+/*
+ * GPIO Direction
+ */
+#define GPIO_DIR_INPUT          0
+#define GPIO_DIR_OUTPUT         1
+
+/*
+ * GPIO interrupt type
+ */
+#define GPIO_INT_TYPE_LEVEL     0
+#define GPIO_INT_TYPE_EDGE      1
+
+/*
+ * GPIO interrupt polarity
+ */
+#define GPIO_INT_POL_LOW        0
+#define GPIO_INT_POL_HIGH       1
+
+#define OFFSET_GPIO_SWPORTA_DR         (0x0000)
+#define OFFSET_GPIO_SWPORTA_DDR        (0x0004)
+#define OFFSET_GPIO_PORTA_CTL          (0x0008)
+#define OFFSET_GPIO_SWPORTB_DR         (0x000C)
+#define OFFSET_GPIO_SWPORTB_DDR        (0x0010)
+#define OFFSET_GPIO_PORTB_CTL          (0x0014)
+#define OFFSET_GPIO_INTEN              (0x0030)
+#define OFFSET_GPIO_INTMASK            (0x0034)
+#define OFFSET_GPIO_INTTYPE_LEVEL      (0x0038)
+#define OFFSET_GPIO_INT_POLARITY       (0x003C)
+#define OFFSET_GPIO_INTSTATUS          (0x0040)
+#define OFFSET_GPIO_RAWINTSTATUS       (0x0044)
+#define OFFSET_GPIO_DEBOUNCE           (0x0048)
+#define OFFSET_GPIO_PORTA_EOI          (0x004C)
+#define OFFSET_GPIO_EXT_PORTA          (0x0050)
+#define OFFSET_GPIO_EXT_PORTB          (0x0054)
+
+static inline void FH_GPIO_SetValue(unsigned int base, int bit, int val)
+{
+	unsigned int reg;
+
+	reg = GET_REG(base + OFFSET_GPIO_SWPORTA_DR);
+	reg = val ? (reg | (1 << bit)) : (reg & ~(1 << bit));
+	SET_REG(base + OFFSET_GPIO_SWPORTA_DR, reg);
+}
+
+static inline int FH_GPIO_GetValue(unsigned int base, int bit)
+{
+	return (GET_REG(base + OFFSET_GPIO_EXT_PORTA) >> bit) & 0x1;
+}
+
+static inline void FH_GPIO_SetDirection(unsigned int base, int bit, int dir)
+{
+	unsigned int reg;
+
+	reg = GET_REG(base + OFFSET_GPIO_SWPORTA_DDR);
+	reg = dir ? reg | (1 << bit) : reg & ~(1 << bit);
+	SET_REG(base + OFFSET_GPIO_SWPORTA_DDR, reg);
+}
+
+static inline int FH_GPIO_GetDirection(unsigned int base, int bit)
+{
+	return (GET_REG(base + OFFSET_GPIO_SWPORTA_DDR) >> bit) & 0x1;
+}
+
+static inline void FH_GPIOB_SetValue(unsigned int base, int bit, int val)
+{
+	unsigned int reg;
+
+	reg = GET_REG(base + OFFSET_GPIO_SWPORTB_DR);
+	reg = val ? (reg | (1 << bit)) : (reg & ~(1 << bit));
+	SET_REG(base + OFFSET_GPIO_SWPORTB_DR, reg);
+}
+
+static inline int FH_GPIOB_GetValue(unsigned int base, int bit)
+{
+	return (GET_REG(base + OFFSET_GPIO_EXT_PORTB) >> bit) & 0x1;
+}
+
+static inline void FH_GPIOB_SetDirection(unsigned int base, int bit, int dir)
+{
+	unsigned int reg;
+
+	reg = GET_REG(base + OFFSET_GPIO_SWPORTB_DDR);
+	reg = dir ? reg | (1 << bit) : reg & ~(1 << bit);
+	SET_REG(base + OFFSET_GPIO_SWPORTB_DDR, reg);
+}
+
+static inline int FH_GPIOB_GetDirection(unsigned int base, int bit)
+{
+	return (GET_REG(base + OFFSET_GPIO_SWPORTB_DDR) >> bit) & 0x1;
+}
+
+static inline void FH_GPIO_EnableDebounce(unsigned int base, int bit, int bool)
+{
+	unsigned int reg;
+
+	reg = GET_REG(base + OFFSET_GPIO_DEBOUNCE);
+	reg = bool ? reg | (1 << bit) : reg & ~(1 << bit);
+	SET_REG(base + OFFSET_GPIO_DEBOUNCE, reg);
+}
+
+static inline void FH_GPIO_SetInterruptType(unsigned int base, int bit,
+		int type)
+{
+	unsigned int reg;
+
+	reg = GET_REG(base + OFFSET_GPIO_INTTYPE_LEVEL);
+	reg = type ? reg | (1 << bit) : reg & ~(1 << bit);
+	SET_REG(base + OFFSET_GPIO_INTTYPE_LEVEL, reg);
+}
+
+static inline void FH_GPIO_SetInterruptPolarity(unsigned int base, int bit,
+		int pol)
+{
+	unsigned int reg;
+
+	reg = GET_REG(base + OFFSET_GPIO_INT_POLARITY);
+	reg = pol ? reg | (1 << bit) : reg & ~(1 << bit);
+	SET_REG(base + OFFSET_GPIO_INT_POLARITY, reg);
+}
+
+static inline void FH_GPIO_EnableInterruptMask(unsigned int base, int bit,
+		int bool)
+{
+	unsigned int reg;
+
+	reg = GET_REG(base + OFFSET_GPIO_INTMASK);
+	reg = bool ? reg | (1 << bit) : reg & ~(1 << bit);
+	SET_REG(base + OFFSET_GPIO_INTMASK, reg);
+}
+
+static inline void FH_GPIO_EnableInterrupt(unsigned int base, int bit, int bool)
+{
+	unsigned int reg;
+
+	reg = GET_REG(base + OFFSET_GPIO_INTEN);
+	reg = bool ? reg | (1 << bit) : reg & ~(1 << bit);
+	SET_REG(base + OFFSET_GPIO_INTEN, reg);
+}
+
+static inline void FH_GPIO_SetEnableInterrupts(unsigned int base,
+		unsigned int val)
+{
+	SET_REG(base + OFFSET_GPIO_INTEN, val);
+}
+
+static inline unsigned int FH_GPIO_GetEnableInterrupts(unsigned int base)
+{
+	return GET_REG(base + OFFSET_GPIO_INTEN);
+}
+
+static inline unsigned int FH_GPIO_GetInterruptStatus(unsigned int base)
+{
+	return GET_REG(base + OFFSET_GPIO_INTSTATUS);
+}
+
+static inline void FH_GPIO_ClearInterrupt(unsigned int base, int bit)
+{
+	unsigned int reg;
+
+	reg = GET_REG(base + OFFSET_GPIO_PORTA_EOI);
+	reg |= (1 << bit);
+	SET_REG(base + OFFSET_GPIO_PORTA_EOI, reg);
+}
+
+#define GPIO_NAME "FH_GPIO"
+
+
+struct gpio_irq_info {
+	int irq_gpio;
+	int irq_line;
+	int irq_type;
+	int irq_gpio_val;
+	int irq_gpio_mode;
+};
+
+struct fh_gpio_chip {
+	struct gpio_chip chip;
+	void __iomem *base;
+
+	struct platform_device *pdev;
+	int irq;
+	spinlock_t lock;
+
+	u32 gpio_wakeups;
+	u32 gpio_backups;
+};
+
+/*
+ * The get/set/clear functions will inline when called with constant
+ * parameters referencing built-in GPIOs, for low-overhead bitbanging.
+ *
+ * gpio_set_value() will inline only on traditional Davinci style controllers
+ * with distinct set/clear registers.
+ *
+ * Otherwise, calls with variable parameters or referencing external
+ * GPIOs (e.g. on GPIO expander chips) use outlined functions.
+ */
+static inline void gpio_set_value(unsigned gpio, int value)
+{
+    __gpio_set_value(gpio, value);
+}
+
+/* Returns zero or nonzero; works for gpios configured as inputs OR
+ * as outputs, at least for built-in GPIOs.
+ *
+ * NOTE: for built-in GPIOs, changes in reported values are synchronized
+ * to the GPIO clock.  This is easily seen after calling gpio_set_value()
+ * and then immediately gpio_get_value(), where the gpio_get_value() will
+ * return the old value until the GPIO clock ticks and the new value gets
+ * latched.
+ */
+static inline int gpio_get_value(unsigned gpio)
+{
+    return __gpio_get_value(gpio);
+}
+
+static inline int gpio_cansleep(unsigned gpio)
+{
+    return 0;
+}
+
+static inline int gpio_to_irq(unsigned gpio)
+{
+    return __gpio_to_irq(gpio);
+}
+
+static inline int irq_to_gpio(unsigned irq)
+{
+    return 0;
+}
+
+void fh_gpio_irq_suspend(void);
+void fh_gpio_irq_resume(void);
+
+#endif
+
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/hardware.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/hardware.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/hardware.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/hardware.h	2021-07-13 23:40:30.650336818 +0300
@@ -0,0 +1,18 @@
+/*
+*	Copyright (c) 2010 Shanghai Fullhan Microelectronics Co., Ltd.
+*				All Rights Reserved. Confidential.
+*
+*This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation version 2.
+*
+* This program is distributed "as is" WITHOUT ANY WARRANTY of any
+* kind, whether express or implied; without even the implied warranty
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#endif /* __ASM_ARCH_HARDWARE_H */
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/i2c.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/i2c.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/i2c.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/i2c.h	2021-07-13 23:40:30.654336845 +0300
@@ -0,0 +1,327 @@
+/*
+*	Copyright (c) 2010 Shanghai Fullhan Microelectronics Co., Ltd.
+*				All Rights Reserved. Confidential.
+*
+*This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation version 2.
+*
+* This program is distributed "as is" WITHOUT ANY WARRANTY of any
+* kind, whether express or implied; without even the implied warranty
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+
+#ifndef __ASM_ARCH_I2C_H
+#define __ASM_ARCH_I2C_H
+#include "fh_predefined.h"
+
+//I2C
+#define     REG_I2C_CON             (0x0000)
+#define     REG_I2C_TAR             (0x0004)
+#define     REG_I2C_SAR             (0x0008)
+#define     REG_I2C_HS_MADDR        (0x000C)
+#define     REG_I2C_DATA_CMD        (0x0010)
+#define     REG_I2C_SS_SCL_HCNT     (0x0014)
+#define     REG_I2C_SS_SCL_LCNT     (0x0018)
+#define     REG_I2C_FS_SCL_HCNT     (0x001C)
+#define     REG_I2C_FS_SCL_LCNT     (0x0020)
+#define     REG_I2C_HS_SCL_HCNT     (0x0024)
+#define     REG_I2C_HS_SCL_LCNT     (0x0028)
+#define     REG_I2C_INTR_STAT       (0x002c)
+#define     REG_I2C_INTR_MASK       (0x0030)
+#define     REG_I2C_RAW_INTR_STAT   (0x0034)
+#define     REG_I2C_RX_TL           (0x0038)
+#define     REG_I2C_TX_TL           (0x003c)
+#define     REG_I2C_CLR_INTR        (0x0040)
+#define     REG_I2C_ENABLE          (0x006c)
+#define     REG_I2C_STATUS          (0x0070)
+#define     REG_I2C_TXFLR           (0x0074)
+#define     REG_I2C_RXFLR           (0x0078)
+#define     REG_I2C_DMA_CR          (0x0088)
+#define     REG_I2C_DMA_TDLR        (0x008c)
+#define     REG_I2C_DMA_RDLR        (0x0090)
+
+#define DW_IC_INTR_NONE         0x0
+
+
+enum BUS_STATUS {
+	I2C_BUSY,
+	I2C_IDLE
+};
+enum RESULT {
+	SUCCESS,
+	FAILURE
+};
+enum ENABLE_SET {
+	DISABLE,
+	ENABLE
+};
+enum SPEED_MODE {
+	SSPEED = 1,
+	FSPEED = 2,
+	HSPEED = 3,
+};
+
+UINT32 I2c_Disable(UINT32 base_addr);
+
+void I2c_SetSpeed(UINT32 base_addr, UINT8 model);
+void I2c_SetDeviceId(UINT32 base_addr, UINT32 deviceID);
+void I2c_Enable(UINT32 enable);
+UINT32 I2c_GetStatus(UINT32 base_addr);
+void I2c_SetIr(UINT32 base_addr, UINT16 mask);
+UINT32 I2c_Disable(UINT32 base_addr);
+
+void I2c_Init(UINT32 base_addr, UINT16 slave_addr, enum SPEED_MODE speed,
+	      int txtl, int rxtl);
+
+/* function Macro */
+/*******************************************************************************
+* Function Name  : I2c_GetTxFifoDepth
+* Description    : get tx fifo depth
+* Input          : base addr
+* Output         : None
+* Return         : None
+*
+ *******************************************************************************/
+#define I2c_GetTxFifoDepth( base_addr)   (((GET_REG(base_addr + \
+		DW_IC_COMP_PARAM_1)>> 16) & 0xff) + 1)
+
+/*******************************************************************************
+* Function Name  : I2c_GetRxFifoDepth
+* Description    : get rx fifo depth
+* Input          : base addr
+* Output         : None
+* Return         : None
+*
+ *******************************************************************************/
+#define I2c_GetRxFifoDepth( base_addr)   (((GET_REG(base_addr + \
+		DW_IC_COMP_PARAM_1)>> 8) & 0xff) + 1)
+/*******************************************************************************
+* Function Name  : I2c_SetDeviceId
+* Description    : set the slave addr
+* Input          : deviceID:slave addr
+* Output         : None
+* Return         : None
+*
+ *******************************************************************************/
+#define I2c_SetDeviceId( base_addr,deviceID)   SET_REG(base_addr + REG_I2C_TAR,deviceID)  //set IIC  slave address
+
+/*******************************************************************************
+* Function Name  : I2c_Read
+* Description    : read data from I2C bus
+* Input          : None
+* Output         : None
+* Return         : data:I2C  data
+*
+ *******************************************************************************/
+
+#define I2c_Read(base_addr )   (GET_REG(base_addr + REG_I2C_DATA_CMD)&0xff)  //DW_I2C_DATA_CMD
+/*******************************************************************************
+* Function Name  : I2c_SetSsSclHcnt
+* Description    : set i2c ss scl hcnt
+* Input          : hcnt
+* Output         : None
+* Return         : data:I2C  data
+*
+ *******************************************************************************/
+
+#define I2c_SetSsHcnt(base_addr, hcnt)  SET_REG(base_addr + DW_IC_SS_SCL_HCNT,hcnt)
+
+/*******************************************************************************
+* Function Name  : I2c_SetSsSclLcnt
+* Description    : set i2c ss scl lcnt
+* Input          : lcnt
+* Output         : None
+* Return         : data:I2C  data
+*
+ *******************************************************************************/
+
+#define I2c_SetSsLcnt(base_addr, lcnt)  SET_REG(base_addr + DW_IC_SS_SCL_LCNT,lcnt)
+/*******************************************************************************
+* Function Name  : I2c_SetFsSclHcnt
+* Description    : set i2c fs scl hcnt
+* Input          : hcnt
+* Output         : None
+* Return         : data:I2C  data
+*
+ *******************************************************************************/
+
+#define I2c_SetFsHcnt(base_addr, hcnt)  SET_REG(base_addr + DW_IC_FS_SCL_HCNT,hcnt)
+
+/*******************************************************************************
+* Function Name  : I2c_SetFsSclLcnt
+* Description    : set i2c fs scl lcnt
+* Input          : lcnt
+* Output         : None
+* Return         : data:I2C  data
+*
+ *******************************************************************************/
+
+#define I2c_SetFsLcnt(base_addr, lcnt)  SET_REG(base_addr + DW_IC_FS_SCL_LCNT,lcnt)
+/*******************************************************************************
+* Function Name  : I2c_Disable
+* Description    : disable I2C bus
+* Input          : None
+* Output         : None
+* Return         : None
+*
+ *******************************************************************************/
+#define I2c_DisEnable(base_addr)  SET_REG(base_addr + REG_I2C_ENABLE,DISABLE);
+/*******************************************************************************
+* Function Name  : I2c_Enable
+* Description    : set the I2C bus enable
+* Input          : enable
+* Output         : None
+* Return         : None
+*
+ *******************************************************************************/
+#define I2c_Enable(base_addr)  SET_REG(base_addr + REG_I2C_ENABLE,ENABLE);
+/*******************************************************************************
+* Function Name  : I2c_Write
+* Description    : Write data to I2C bus
+* Input          : data:wirte out data
+* Output         : None
+* Return         : None
+*
+ *******************************************************************************/
+#define I2c_Write(base_addr, data)  SET_REG(base_addr + REG_I2C_DATA_CMD,data)
+
+/*******************************************************************************
+* Function Name  : I2c_GetTxTl
+* Description    : Get TX_TL
+* Input          : TX_TL
+* Return         : None
+ *******************************************************************************/
+#define I2c_GetTxTl(base_addr )     (GET_REG(base_addr + REG_I2C_TX_TL)&0xff);
+/*******************************************************************************
+* Function Name  : I2c_GetRxTl
+* Description    : Get RX_TL
+* Input          : RX_TL
+* Return         : None
+ *******************************************************************************/
+#define I2c_GetRxTl(base_addr )     (GET_REG(base_addr + REG_I2C_RX_TL)&0xff);
+/*******************************************************************************
+* Function Name  : I2c_GetRxFLR
+* Description    : Get RX_FLR
+* Input          : base_addr
+* Return         : None
+ *******************************************************************************/
+#define I2c_GetRxFLR(base_addr)     (GET_REG(base_addr + DW_IC_RXFLR)&0xff);
+/*******************************************************************************
+* Function Name  : I2c_GetTxFLR
+* Description    : Get TX_FLR
+* Input          : base_addr
+* Return         : None
+ *******************************************************************************/
+#define I2c_GetTxFLR(base_addr)     (GET_REG(base_addr + DW_IC_TXFLR)&0xff);
+/*******************************************************************************
+* Function Name  : I2c_SetTxRxTl
+* Description    : set TX_TL RX_TL
+* Input          : TX_TL, RX_TL
+* Return         : None
+ *******************************************************************************/
+#define I2c_SetTxRxTl(base_addr ,txtl,rxtl)    \
+    SET_REG(base_addr + REG_I2C_TX_TL, txtl);   \
+    SET_REG(base_addr + REG_I2C_RX_TL, rxtl)
+
+/*******************************************************************************
+* Function Name  : I2c_IsActiveMst
+* Description    : if master mode is active, return 1
+* Input          : none
+* Return         : MST_ACTIVITY (IC_STATUS[5])
+ *******************************************************************************/
+#define I2c_IsActiveMst(base_addr)   (GET_REG(base_addr + REG_I2C_STATUS)>>5 & 1)
+
+/*******************************************************************************
+* Function Name  : I2c_SetCon
+* Description    : set config
+* Input          : config
+* Return         : None
+ *******************************************************************************/
+#define I2c_SetCon(base_addr,config)      SET_REG(base_addr + REG_I2C_CON,config)
+/*******************************************************************************
+* Function Name  : I2c_GetCon
+* Description    : get config
+* Input          : config
+* Return         : None
+ *******************************************************************************/
+#define I2c_GetCon(base_addr)      GET_REG(base_addr + REG_I2C_CON)
+
+/*******************************************************************************
+* Function Name  : I2c_Status
+* Description    : get i2c status
+* Input          : None
+* Return         : None
+ *******************************************************************************/
+#define I2c_Status(base_addr)     GET_REG(base_addr + REG_I2C_STATUS)
+
+/*******************************************************************************
+* Function Name  : I2c_SetTar
+* Description    : set target address
+* Input          : id
+* Return         : None
+ *******************************************************************************/
+#define I2c_SetTar(base_addr, id)      SET_REG(base_addr + REG_I2C_TAR,id)
+
+/*******************************************************************************
+* Function Name  : I2c_SetIntrMask
+* Description    : set interrupt mask
+* Input          : mask
+* Return         : None
+ *******************************************************************************/
+#define I2c_SetIntrMask(base_addr,mask)   SET_REG(base_addr + REG_I2C_INTR_MASK,mask)
+
+/*******************************************************************************
+* Function Name  : I2c_ClrIntr
+* Description    : clear interrupt
+* Input          : mask
+* Return         : None
+ *******************************************************************************/
+#define I2c_ClrIntr(base_addr,mask)   GET_REG(base_addr + mask)
+/*******************************************************************************
+* Function Name  : I2c_REG_STATUS
+* Description    : clear interrupt
+* Input          : mask
+* Return         : None
+ *******************************************************************************/
+#define I2c_GetTxAbrtSource(base_addr)   GET_REG(base_addr + DW_IC_TX_ABRT_SOURCE)
+
+/*******************************************************************************
+* Function Name  : I2c_TxEmpty
+* Description    : TX_EMPTY interrupt assert
+* Input          : none
+* Return         : TX_EMPTY
+ *******************************************************************************/
+#define I2c_TxEmpty(base_addr)   (GET_REG(base_addr + REG_I2C_RAW_INTR_STAT) & M_TX_EMPTY)
+
+/*******************************************************************************
+* Function Name  : I2c_RxFull
+* Description    : RX_FULL interrupt assert
+* Input          : none
+* Return         : RX_FULL
+ *******************************************************************************/
+#define I2c_RxFull(base_addr)    (GET_REG(base_addr + REG_I2C_RAW_INTR_STAT) & M_RX_FULL)
+/*******************************************************************************
+* Function Name  : I2c_RxEmpty
+* Description    : RX_EMPTY interrupt assert
+* Input          : none
+* Return         : RX_EMPTY
+ *******************************************************************************/
+#define I2c_RxEmpty(base_addr)    (GET_REG(base_addr + REG_I2C_RAW_INTR_STAT) & M_RX_OVER)
+
+/* register define */
+typedef union {
+	struct {
+		UINT32 MASTER_MODE      	: 1;
+		UINT32 SPEED            	: 2;
+		UINT32 IC_10BITADDR_SLAVE   : 1;
+		UINT32 IC_10BITADDR_MASTER  : 1;
+		UINT32 IC_RESTART_EN        : 1;
+		UINT32 IC_SLAVE_DISABLE     : 1;
+		UINT32 reserved_31_7        : 25;
+	} x;
+	UINT32 dw;
+} Reg_I2c_Con;
+
+#endif /* __ASM_ARCH_I2C_H */
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/io.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/io.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/io.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/io.h	2021-07-13 23:40:30.646336791 +0300
@@ -0,0 +1,126 @@
+/*
+ * fh io definitions
+ *
+ * Copyright (C) 2014 Fullhan Microelectronics Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#ifndef __ASM_ARCH_IO_H
+#define __ASM_ARCH_IO_H
+
+#include <mach/chip.h>
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+/*
+ * We don't actually have real ISA nor PCI buses, but there is so many
+ * drivers out there that might just work if we fake them...
+ */
+#define __io(a)			__typesafe_io(a)
+#define __mem_pci(a)		(a)
+#define __mem_isa(a)		(a)
+
+#ifndef CONFIG_JLINK_DEBUG
+#define FH_VIRT 		0xFE000000
+
+#define		VA_INTC_REG_BASE	(FH_VIRT + 0x00000)
+#define		VA_TIMER_REG_BASE	(FH_VIRT + 0x10000)
+#define		VA_UART0_REG_BASE	(FH_VIRT + 0x20000)
+//#define		VA_GMAC_REG_BASE	(FH_VIRT + 0x30000)
+//#define		VA_SPI0_REG_BASE	(FH_VIRT + 0x40000)
+//#define		VA_GPIO_REG_BASE	(FH_VIRT + 0x50000)
+//#define		VA_DMAC_REG_BASE	(FH_VIRT + 0x60000)
+//#define		VA_SDC0_REG_BASE	(FH_VIRT + 0x70000)
+//#define		VA_I2C_REG_BASE		(FH_VIRT + 0x80000)
+#define		VA_PMU_REG_BASE		(FH_VIRT + 0x90000)
+//#define		VA_SDC1_REG_BASE	(FH_VIRT + 0xa0000)
+//
+#define		VA_UART1_REG_BASE	(FH_VIRT + 0xb0000)
+#define		VA_PAE_REG_BASE		(FH_VIRT + 0xc0000)
+
+#define		VA_RAM_REG_BASE		(FH_VIRT + 0xd0000)
+#define		VA_DDRC_REG_BASE	(FH_VIRT + 0xe0000)
+#define		VA_UART2_REG_BASE	(FH_VIRT + 0xf0000)
+#ifdef CONFIG_ARCH_FH
+#define VA_CONSOLE_REG_BASE 		VA_UART1_REG_BASE
+#else
+#define VA_CONSOLE_REG_BASE 		VA_UART0_REG_BASE
+#endif
+
+#define I2C_OFFSET	(VA_I2C_REG_BASE - I2C_REG_BASE)
+#define VI2C(x)		(x + I2C_OFFSET)
+
+#define INTC_OFFSET	(VA_INTC_REG_BASE - INTC_REG_BASE)
+#define VINTC(x)	(x + INTC_OFFSET)
+
+#define TIME_OFFSET	(VA_TIMER_REG_BASE - TIMER_REG_BASE)
+#define VTIMER(x)	(x + TIME_OFFSET)
+
+#define UART0_OFFSET	(VA_UART0_REG_BASE - UART0_REG_BASE)
+#define VUART0(x)	(x + UART0_OFFSET)
+
+#define UART1_OFFSET	(VA_UART1_REG_BASE - UART1_REG_BASE)
+#define VUART1(x)	(x + UART1_OFFSET)
+
+#define UART2_OFFSET	(VA_UART2_REG_BASE - UART2_REG_BASE)
+#define VUART2(x)	(x + UART2_OFFSET)
+
+#define SPI0_OFFSET	(VA_SPI0_REG_BASE - SPI0_REG_BASE)
+#define VSPI0(x)	(x + SPI0_OFFSET)
+
+#define GMAC_OFFSET	(VA_GMAC_REG_BASE - GMAC_REG_BASE)
+#define VGMAC(x)	(x + GMAC_OFFSET)
+
+#define DMAC_OFFSET	(VA_DMAC_REG_BASE - DMAC_REG_BASE)
+#define VDMAC(x)	(x + DMAC_OFFSET)
+
+#define SDC0_OFFSET	(VA_SDC0_REG_BASE - SDC0_REG_BASE)
+#define VSDC0(x)	(x + SDC0_OFFSET)
+
+#define SDC1_OFFSET	(VA_SDC1_REG_BASE - SDC1_REG_BASE)
+#define VSDC1(x)	(x + SDC1_OFFSET)
+
+#define GPIO_OFFSET	(VA_GPIO_REG_BASE - GPIO_REG_BASE)
+#define VGPIO(x)	(x + GPIO_OFFSET)
+
+#define PMU_OFFSET	(VA_PMU_REG_BASE - PMU_REG_BASE)
+#define VPMU(x)		(x + PMU_OFFSET)
+
+#define PAE_OFFSET	(VA_PAE_REG_BASE - PAE_REG_BASE)
+#define VPAE(x)		(x + PAE_OFFSET)
+
+#else
+#define		VA_INTC_REG_BASE		INTC_REG_BASE
+#define		VA_TIMER_REG_BASE		TIMER_REG_BASE
+#define		VA_UART0_REG_BASE		UART0_REG_BASE
+#define		VA_UART1_REG_BASE		UART1_REG_BASE
+#define		VA_GMAC_REG_BASE		GMAC_REG_BASE
+#define		VA_DMAC_REG_BASE		DMAC_REG_BASE
+#define		VA_I2C_REG_BASE			I2C_REG_BASE
+#define		VA_SDC0_REG_BASE		SDC0_REG_BASE
+
+#define		VA_SPI0_REG_BASE		SPI0_REG_BASE
+
+#define		VA_GPIO_REG_BASE		GPIO0_REG_BASE
+#define		VA_PMU_REG_BASE			PMU_REG_BASE
+
+//#define		VA_GPIO_REG_BASE		(FH_VIRT + 0x500000)
+
+#define VINTC(x)		 x
+#define VTIMER(x)		x
+#define VUART0(x)		x
+#define VUART1(x)		x
+#define VGMAC(x)		x
+
+#define VDMAC(x)		x
+#define VI2C(x)			x
+#define VSDC0(x)			x
+
+#define VSPI0(x)		x
+#define VPMU(x)		x
+
+#endif
+#endif /* __ASM_ARCH_IO_H */
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/iomux.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/iomux.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/iomux.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/iomux.h	2021-07-13 23:40:30.654336845 +0300
@@ -0,0 +1,165 @@
+#ifndef IOMUX_H_
+#define IOMUX_H_
+#include <linux/types.h>
+#include <linux/io.h>
+#include <mach/io.h>
+
+#define IOMUX_PADTYPE(n)		(Iomux_PadType##n *)
+#define IOMUX_PUPD_NONE			0
+#define IOMUX_PUPD_DOWN			1
+#define IOMUX_PUPD_UP			2
+#define IOMUX_PUPD_KEEPER		3
+//#define IOMUX_DEBUG
+
+
+typedef union {
+	struct {
+		__u32	sr		: 1;
+		__u32	reserved_3_1	: 3;
+
+		__u32	e8_e4		: 2;
+		__u32	reserved_31_6	: 24;
+
+	} bit;
+	__u32 dw;
+} Iomux_PadType5;
+
+typedef union {
+	struct {
+		__u32	sr		: 1;
+		__u32	reserved_3_1	: 3;
+
+		__u32	e8_e4		: 2;
+		__u32	reserved_7_6	: 2;
+
+		__u32	mfs		: 1;
+		__u32	reserved_31_9	: 23;
+
+	} bit;
+	__u32 dw;
+} Iomux_PadType8;
+
+
+typedef union {
+	struct {
+		__u32	smt		: 1;
+		__u32	reserved_3_1	: 3;
+
+		__u32	ie		: 1;
+		__u32	reserved_7_5	: 3;
+
+		__u32	pu_pd		: 2;
+		__u32	reserved_31_10	: 22;
+
+	} bit;
+	__u32 dw;
+} Iomux_PadType9;
+
+
+typedef union {
+	struct {
+		__u32	e4_e2		: 2;
+		__u32	reserved_3_2	: 2;
+
+		__u32	smt		: 1;
+		__u32	reserved_7_5	: 3;
+
+		__u32	ie		: 1;
+		__u32	reserved_11_9	: 3;
+
+		__u32	mfs		: 2;
+		__u32	reserved_31_14	: 18;
+
+	} bit;
+	__u32 dw;
+} Iomux_PadType13;
+
+typedef union {
+	struct {
+		__u32	sr		: 1;
+		__u32	reserved_3_1	: 3;
+
+		__u32	e8_e4		: 2;
+		__u32	reserved_7_6	: 2;
+
+		__u32	smt		: 1;
+		__u32	reserved_11_9	: 3;
+
+		__u32	ie		: 1;
+		__u32	e		: 1;	//only for PAD_MAC_REF_CLK_CFG (0x00a4)
+		__u32	reserved_15_12	: 2;
+
+		__u32	pu_pd		: 2;
+		__u32	reserved_31_18	: 14;
+
+	} bit;
+	__u32 dw;
+} Iomux_PadType17;
+
+typedef union {
+	struct {
+		__u32	sr		: 1;
+		__u32	reserved_3_1	: 3;
+
+		__u32	e4_e2		: 2;
+		__u32	reserved_7_6	: 2;
+
+		__u32	smt		: 1;
+		__u32	reserved_11_9	: 3;
+
+		__u32	ie		: 1;
+		__u32	reserved_15_13	: 3;
+
+		__u32	pu_pd		: 2;
+		__u32	reserved_19_18	: 2;
+
+		__u32	mfs		: 1;
+		__u32	reserved_31_21	: 11;
+
+	} bit;
+	__u32 dw;
+} Iomux_PadType20;
+
+
+typedef union {
+	struct {
+		__u32	sr		: 1;
+		__u32	reserved_3_1	: 3;
+
+		__u32	e4_e2		: 2;
+		__u32	reserved_7_6	: 2;
+
+		__u32	smt		: 1;
+		__u32	reserved_11_9	: 3;
+
+		__u32	ie		: 1;
+		__u32	reserved_15_13	: 3;
+
+		__u32	pu_pd		: 2;
+		__u32	reserved_19_18	: 2;
+
+		__u32	mfs		: 2;
+		__u32	reserved_31_21	: 10;
+
+	} bit;
+	__u32 dw;
+} Iomux_PadType21;
+
+typedef struct {
+	u32 *reg;
+	u32 reg_offset;
+	char *func_name[4];
+	int reg_type;
+	int func_sel;
+	int drv_cur;
+	int pupd;
+} Iomux_Pad;
+
+typedef struct {
+	void __iomem *base;
+	Iomux_Pad *pads;
+} Iomux_Object;
+
+void fh_iomux_init(Iomux_Object *iomux_obj);
+
+#endif /* IOMUX_H_ */
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/irqs.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/irqs.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/irqs.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/irqs.h	2021-07-13 23:40:30.650336818 +0300
@@ -0,0 +1,43 @@
+/*
+ * fh interrupt controller definitions
+ *
+ * Copyright (C) 2014 Fullhan Microelectronics Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+#include <mach/chip.h>
+
+#define		REG_IRQ_EN_LOW				(INTC_REG_BASE + 0x0000)
+#define		REG_IRQ_EN_HIGH				(INTC_REG_BASE + 0x0004)
+#define		REG_IRQ_IRQMASK_LOW			(INTC_REG_BASE + 0x0008)
+#define		REG_IRQ_IRQMASK_HIGH		(INTC_REG_BASE + 0x000C)
+#define		REG_IRQ_IRQFORCE_LOW		(INTC_REG_BASE + 0x0010)
+#define		REG_IRQ_IRQFORCE_HIGH		(INTC_REG_BASE + 0x0014)
+#define		REG_IRQ_RAWSTATUS_LOW		(INTC_REG_BASE + 0x0018)
+#define		REG_IRQ_RAWSTATUS_HIGH		(INTC_REG_BASE + 0x001C)
+#define		REG_IRQ_STATUS_LOW			(INTC_REG_BASE + 0x0020)
+#define		REG_IRQ_STATUS_HIGH			(INTC_REG_BASE + 0x0024)
+#define		REG_IRQ_MASKSTATUS_LOW		(INTC_REG_BASE + 0x0028)
+#define		REG_IRQ_MASKSTATUS_HIGH		(INTC_REG_BASE + 0x002C)
+#define		REG_IRQ_FINSTATUS_LOW		(INTC_REG_BASE + 0x0030)
+#define		REG_IRQ_FINSTATUS_HIGH		(INTC_REG_BASE + 0x0034)
+#define		REG_FIQ_EN_LOW				(INTC_REG_BASE + 0x02C0)
+#define		REG_FIQ_EN_HIGH				(INTC_REG_BASE + 0x02C4)
+#define		REG_FIQ_FIQMASK_LOW			(INTC_REG_BASE + 0x02C8)
+#define		REG_FIQ_FIQMASK_HIGH		(INTC_REG_BASE + 0x02CC)
+#define		REG_FIQ_FIQFORCE_LOW		(INTC_REG_BASE + 0x02D0)
+#define		REG_FIQ_FIQFORCE_HIGH		(INTC_REG_BASE + 0x02D4)
+#define		REG_FIQ_RAWSTATUS_LOW		(INTC_REG_BASE + 0x02D8)
+#define		REG_FIQ_RAWSTATUS_HIGH		(INTC_REG_BASE + 0x02DC)
+#define		REG_FIQ_STATUS_LOW			(INTC_REG_BASE + 0x02E0)
+#define		REG_FIQ_STATUS_HIGH			(INTC_REG_BASE + 0x02E4)
+#define		REG_FIQ_FINSTATUS_LOW		(INTC_REG_BASE + 0x02E8)
+#define		REG_FIQ_FINSTATUS_HIGH		(INTC_REG_BASE + 0x02EC)
+
+#endif /* __ASM_ARCH_IRQS_H */
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/memory.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/memory.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/memory.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/memory.h	2021-07-13 23:40:30.650336818 +0300
@@ -0,0 +1,27 @@
+/*
+ * fh memory space definitions
+ *
+ * Copyright (C) 2014 Fullhan Microelectronics Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/**************************************************************************
+ * Included Files
+ **************************************************************************/
+#include <asm/page.h>
+#include <asm/sizes.h>
+
+/**************************************************************************
+ * Definitions
+ **************************************************************************/
+#define FH_DDR_BASE	0xA0000000
+
+#define PLAT_PHYS_OFFSET FH_DDR_BASE
+
+#endif /* __ASM_ARCH_MEMORY_H */
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/pinctrl.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/pinctrl.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/pinctrl.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/pinctrl.h	2021-07-13 23:40:30.646336791 +0300
@@ -0,0 +1,118 @@
+#ifndef PINCTRL_H_
+#define PINCTRL_H_
+#include "pinctrl_osdep.h"
+#include <linux/seq_file.h>
+
+#define PINCTRL_UNUSED      (-1)
+
+#define PUPD_NONE           (0)
+#define PUPD_UP             (1)
+#define PUPD_DOWN           (2)
+
+#define INPUT_DISABLE       (0)
+#define INPUT_ENABLE        (1)
+#define OUTPUT_DISABLE      (0)
+#define OUTPUT_ENABLE       (1)
+
+#define FUNC0               (0)
+#define FUNC1               (1)
+#define FUNC2               (2)
+#define FUNC3               (3)
+#define FUNC4               (4)
+#define FUNC5               (5)
+#define FUNC6               (6)
+#define FUNC7               (7)
+
+#define NEED_CHECK_PINLIST  (1)
+
+#define MAX_FUNC_NUM    8
+
+#define PINCTRL_FUNC(name, id, sel, pupd)           \
+PinCtrl_Pin PAD##id##_##name =                      \
+{                                                   \
+    .pad_id         = id,                           \
+    .func_name      = #name,                        \
+    .reg_offset     = (id * 4),                     \
+    .func_sel       = sel,                          \
+    .pullup_pulldown= pupd,			    \
+}
+
+#define PINCTRL_MUX(pname, sel, ...)                \
+PinCtrl_Mux MUX_##pname =                           \
+{                                                   \
+    .mux_pin = { __VA_ARGS__ },                     \
+    .cur_pin = sel,                                 \
+}
+
+#define PINCTRL_DEVICE(name, count, ...)            \
+typedef struct                                      \
+{                                                   \
+    char *dev_name;                                 \
+    int mux_count;                                  \
+    OS_LIST list;                                   \
+    PinCtrl_Mux *mux[count];                        \
+} PinCtrl_Device_##name;                            \
+PinCtrl_Device_##name pinctrl_dev_##name =          \
+{                                                   \
+     .dev_name = #name,                             \
+     .mux_count = count,                            \
+     .mux = { __VA_ARGS__ },                        \
+}
+
+typedef union {
+    struct
+    {
+        unsigned int        : 12;   //0~11
+        unsigned int ie     : 1;    //12
+        unsigned int        : 3;    //13~15
+        unsigned int pdn    : 1;    //16
+        unsigned int        : 3;    //17~19
+        unsigned int pun    : 1;    //20
+        unsigned int        : 3;    //21~23
+        unsigned int mfs    : 4;    //24~27
+        unsigned int oe     : 1;    //28
+        unsigned int        : 3;    //29~31
+    } bit;
+    unsigned int dw;
+} PinCtrl_Register;
+
+typedef struct
+{
+	char *func_name;
+	PinCtrl_Register *reg;
+	int pad_id			: 12;
+	unsigned int reg_offset		: 12;
+	int func_sel			: 4;
+	int input_enable		: 1;
+	int output_enable		: 1;
+	int pullup_pulldown		: 2;
+}PinCtrl_Pin;
+
+typedef struct
+{
+    //todo: int lock;
+    int cur_pin;
+    PinCtrl_Pin *mux_pin[MUX_NUM];
+} PinCtrl_Mux;
+
+typedef struct
+{
+    void *vbase;
+    void *pbase;
+    PinCtrl_Pin *pinlist[PAD_NUM];
+} PinCtrl_Object;
+
+typedef struct
+{
+    char *dev_name;
+    int mux_count;
+    OS_LIST list;
+    void *mux;
+}PinCtrl_Device;
+
+void fh_pinctrl_init(unsigned int base);
+void fh_pinctrl_prt(struct seq_file *sfile);
+int fh_pinctrl_smux(char *devname, char* muxname, int muxsel, unsigned int flag);
+int fh_pinctrl_sdev(char *devname, unsigned int flag);
+void fh_pinctrl_init_devicelist(OS_LIST *list);
+#endif /* PINCTRL_H_ */
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/pinctrl_osdep.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/pinctrl_osdep.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/pinctrl_osdep.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/pinctrl_osdep.h	2021-07-13 23:40:30.650336818 +0300
@@ -0,0 +1,23 @@
+#ifndef PINCTRL_OSDEP_H_
+#define PINCTRL_OSDEP_H_
+
+#include <linux/list.h>
+#include <linux/kernel.h>
+#include <mach/fh_predefined.h>
+#include <linux/string.h>
+
+#define OS_LIST_INIT LIST_HEAD_INIT
+#define OS_LIST struct list_head
+#define OS_PRINT printk
+#define OS_LIST_EMPTY INIT_LIST_HEAD
+#define OS_NULL NULL
+
+#define PINCTRL_ADD_DEVICE(name)                    	\
+        list_add(&pinctrl_dev_##name.list,		\
+	list)
+
+#define PAD_NUM             (77)
+
+#define MUX_NUM             (6)
+
+#endif /* PINCTRL_OSDEP_H_ */
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/pmu.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/pmu.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/pmu.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/pmu.h	2021-07-13 23:40:30.650336818 +0300
@@ -0,0 +1,15 @@
+
+#ifndef _FH_PMU_H_
+#define _FH_PMU_H_
+
+#include <linux/types.h>
+
+void fh_pmu_set_reg(u32 offset, u32 data);
+u32 fh_pmu_get_reg(u32 offset);
+int fh_pmu_init(void);
+
+void fh_pmu_stop(void);
+
+void fh_pae_set_reg(u32 offset, u32 data);
+
+#endif /* _FH_PMU_H_ */
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/rtc.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/rtc.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/rtc.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/rtc.h	2021-07-13 23:40:30.650336818 +0300
@@ -0,0 +1,238 @@
+/*
+ * rtc.h
+ *
+ *  Created on: Aug 18, 2016
+ *      Author: fullhan
+ */
+
+#ifndef ARCH_ARM_MACH_FH_INCLUDE_MACH_RTC_H_
+#define ARCH_ARM_MACH_FH_INCLUDE_MACH_RTC_H_
+#include "fh_predefined.h"
+
+/*
+ * Registers offset
+ */
+#define  FH_RTC_COUNTER            0x0
+#define  FH_RTC_OFFSET             0x4
+#define  FH_RTC_POWER_FAIL         0x8
+#define  FH_RTC_ALARM_COUNTER      0xC
+#define  FH_RTC_INT_STAT           0x10
+#define  FH_RTC_INT_EN             0x14
+#define  FH_RTC_SYNC               0x18
+#define  FH_RTC_DEBUG              0x1C
+#define  FH_RTC_USER_REG           0x20
+
+#define SEC_BIT_START		0
+#define SEC_VAL_MASK		0x3f
+
+#define MIN_BIT_START		6
+#define MIN_VAL_MASK		0xfc0
+
+#define HOUR_BIT_START		12
+#define HOUR_VAL_MASK		0x1f000
+
+#define DAY_BIT_START		17
+#define DAY_VAL_MASK		0xfffe0000
+
+#define FH_RTC_ISR_SEC_POS  	1<<0
+#define FH_RTC_ISR_MIN_POS  	1<<1
+#define	FH_RTC_ISR_HOUR_POS  	1<<2
+#define	FH_RTC_ISR_DAY_POS  	1<<3
+#define	FH_RTC_ISR_ALARM_POS    1<<4
+#define	FH_RTC_ISR_SEC_MASK 	1<<27
+#define	FH_RTC_ISR_MIN_MASK 	1<<28
+#define	FH_RTC_ISR_HOUR_MASK 	1<<29
+#define	FH_RTC_ISR_DAY_MASK 	1<<30
+#define	FH_RTC_ISR_ALARM_MASK 	1<<31
+
+// input: val=fh_rtc_get_time(base_addr)
+#define FH_GET_RTC_SEC(val)		 ((val & SEC_VAL_MASK) >> SEC_BIT_START)
+#define FH_GET_RTC_MIN(val)		 ((val & MIN_VAL_MASK) >> MIN_BIT_START)
+#define FH_GET_RTC_HOUR(val)	 ((val & HOUR_VAL_MASK) >> HOUR_BIT_START)
+#define FH_GET_RTC_DAY(val)	 	 ((val & DAY_VAL_MASK) >> DAY_BIT_START)
+
+#define ELAPSED_LEAP_YEARS(y) (((y -1)/4)-((y-1)/100)+((y+299)/400)-17)
+
+#define FH_RTC_PROC_FILE    "driver/fh_rtc"
+
+struct fh_rtc_platform_data
+{
+	u32 clock_in;
+	char *clk_name;
+	char *dev_name;
+	u32 base_year;
+	u32 base_month;
+	u32 base_day;
+	int sadc_channel;
+};
+enum
+{
+	init_done=1,
+	initing=0
+
+};
+
+/*******************************************************************************
+* Function Name  : fh_rtc_interrupt_disabel
+* Description    : disabale rtc interrupt
+* Input          : rtc base addr
+* Output         : None
+* Return         : None
+*
+ *******************************************************************************/
+#define  fh_rtc_interrupt_disabel(base_addr)                   SET_REG(base_addr+REG_RTC_INT_EN,DISABLE)
+
+/*******************************************************************************
+* Function Name  : fh_rtc_get_time
+* Description    : get rtc current time
+* Input          : rtc base addr
+* Output         : None
+* Return         : None
+*
+ *******************************************************************************/
+#define  fh_rtc_get_time(base_addr)                  			GET_REG(base_addr+FH_RTC_COUNTER)
+
+/*******************************************************************************
+* Function Name  : fh_rtc_set_time
+* Description    : set rtc current time
+* Input          : rtc base addr
+* Output         : None
+* Return         : None
+*
+ *******************************************************************************/
+#define  fh_rtc_set_time(base_addr,value)                  		SET_REG(base_addr+FH_RTC_COUNTER,value)
+
+/*******************************************************************************
+* Function Name  : fh_rtc_set_alarm_time
+* Description    : set rtc alarm
+* Input          : rtc base addr
+* Output         : None
+* Return         : None
+*
+ *******************************************************************************/
+#define  fh_rtc_set_alarm_time(base_addr,value)                  SET_REG(base_addr+FH_RTC_ALARM_COUNTER,value)
+
+/*******************************************************************************
+* Function Name  : fh_rtc_get_alarm_time
+* Description    : get alarm register
+* Input          : rtc base addr
+* Output         : None
+* Return         : None
+*
+ *******************************************************************************/
+#define  fh_rtc_get_alarm_time(base_addr)                 		 GET_REG(base_addr+FH_RTC_ALARM_COUNTER)
+
+/*******************************************************************************
+* Function Name  : fh_rtc_get_int_status
+* Description    : get rtc current interrupt status
+* Input          : rtc base addr
+* Output         : None
+* Return         : None
+*
+ *******************************************************************************/
+#define  fh_rtc_get_int_status(base_addr)                  		  GET_REG(base_addr+FH_RTC_INT_STAT)
+/*******************************************************************************
+* Function Name  : fh_rtc_enable_interrupt
+* Description    : enable rtc interrupt
+* Input          : rtc base addr
+* Output         : None
+* Return         : None
+*
+ *******************************************************************************/
+#define  fh_rtc_enable_interrupt(base_addr,value)                 SET_REG(base_addr+FH_RTC_INT_EN,value|GET_REG(base_addr+FH_RTC_INT_EN))
+/*******************************************************************************
+* Function Name  : fh_rtc_disenable_interrupt
+* Description    : disable interrupt
+* Input          : rtc base addr
+* Output         : None
+* Return         : None
+*
+ *******************************************************************************/
+#define  fh_rtc_disenable_interrupt(base_addr,value)             SET_REG(base_addr+FH_RTC_INT_EN,(~value)&GET_REG(base_addr+FH_RTC_INT_EN))
+
+/*******************************************************************************
+* Function Name  : fh_rtc_get_enabled_interrupt
+* Description    : get rtc current interrupt enabled
+* Input          : rtc base addr
+* Output         : None
+* Return         : None
+*
+ *******************************************************************************/
+#define  fh_rtc_get_enabled_interrupt(base_addr)                 GET_REG(base_addr+FH_RTC_INT_EN)
+/*******************************************************************************
+* Function Name  : fh_rtc_set_mask_interrupt
+* Description    : set rtc interrupt mask
+* Input          : rtc base addr
+* Output         : None
+* Return         : None
+*
+ *******************************************************************************/
+#define  fh_rtc_set_mask_interrupt(base_addr,value)             SET_REG(base_addr+FH_RTC_INT_EN,value|GET_REG(base_addr+FH_RTC_INT_EN))
+/*******************************************************************************
+* Function Name  : fh_rtc_clear_interrupt_status
+* Description    : clear rtc interrupt status
+* Input          : rtc base addr
+* Output         : None
+* Return         : None
+*
+ *******************************************************************************/
+#define  fh_rtc_clear_interrupt_status(base_addr,value)         SET_REG(base_addr+FH_RTC_INT_STAT,(~value)&GET_REG(base_addr+FH_RTC_INT_STAT))
+/*******************************************************************************
+* Function Name  : fh_rtc_get_offset
+* Description    : get rtc offset
+* Input          : rtc base addr
+* Output         : None
+* Return         : None
+*
+ *******************************************************************************/
+#define  fh_rtc_get_offset(base_addr)                  			GET_REG(base_addr+FH_RTC_OFFSET)
+/*******************************************************************************
+* Function Name  : fh_rtc_get_power_fail
+* Description    : get rtc power fail register
+* Input          : rtc base addr
+* Output         : None
+* Return         : None
+*
+ *******************************************************************************/
+#define  fh_rtc_get_power_fail(base_addr)                  		GET_REG(base_addr+FH_RTC_POWER_FAIL)
+
+/*******************************************************************************
+* Function Name  : fh_rtc_get_sync
+* Description    : get rtc sync register value
+* Input          : rtc base addr
+* Output         : None
+* Return         : None
+*
+ *******************************************************************************/
+#define  fh_rtc_get_sync(base_addr)                  			GET_REG(base_addr+FH_RTC_SYNC)
+
+/*******************************************************************************
+* Function Name  : fh_rtc_set_sync
+* Description    : set rtc sync register value
+* Input          : rtc base addr,init_done/initing
+* Output         : None
+* Return         : None
+*
+ *******************************************************************************/
+#define  fh_rtc_set_sync(base_addr,value)                  		SET_REG(base_addr+FH_RTC_SYNC,value)
+
+/*******************************************************************************
+* Function Name  : fh_rtc_get_debug
+* Description    : get rtc debug register value
+* Input          : rtc base addr
+* Output         : None
+* Return         : None
+*
+ *******************************************************************************/
+#define  fh_rtc_get_debug(base_addr)                  			GET_REG(base_addr+FH_RTC_DEBUG)
+
+/*******************************************************************************
+* Function Name  : fh_rtc_set_debug
+* Description    : set rtc debug register value
+* Input          : rtc base addr,x pclk
+* Output         : None
+* Return         : None
+*
+ *******************************************************************************/
+#define  fh_rtc_set_debug(base_addr,value)     					SET_REG(base_addr+FH_RTC_DEBUG,value)
+#endif /* ARCH_ARM_MACH_FH_INCLUDE_MACH_RTC_H_ */
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/spi.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/spi.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/spi.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/spi.h	2021-07-13 23:40:30.654336845 +0300
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2009 Texas Instruments.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __ARCH_ARM_FH_SPI_H
+#define __ARCH_ARM_FH_SPI_H
+
+#include <linux/io.h>
+#include <linux/scatterlist.h>
+
+#define SPI_MASTER_CONTROLLER_MAX_SLAVE		(2)
+#define SPI_TRANSFER_USE_DMA			(0x77888877)
+
+struct fh_spi_cs {
+	u32 GPIO_Pin;
+	char *name;
+};
+
+struct fh_spi_chip {
+	u8 poll_mode;	/* 0 for contoller polling mode */
+	u8 type;	/* SPI/SSP/Micrwire */
+	u8 enable_dma;
+	void *cs_control;
+//	void (*cs_control)(u32 command);
+};
+
+struct fh_spi_platform_data {
+	u32 apb_clock_in;
+	u32 fifo_len;
+	u32 slave_max_num;
+	struct fh_spi_cs cs_data[SPI_MASTER_CONTROLLER_MAX_SLAVE];
+	//below is dma transfer needed
+	u32 dma_transfer_enable;
+	u32 rx_handshake_num;
+	u32 tx_handshake_num;
+	u32 bus_no;
+	char *clk_name;
+	u32 rx_dma_channel;
+	u32 tx_dma_channel;
+
+};
+
+#endif	/* __ARCH_ARM_FH_SPI_H */
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/sram.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/sram.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/sram.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/sram.h	2021-07-13 23:40:30.654336845 +0300
@@ -0,0 +1,25 @@
+/*
+ * mach/sram.h - FH simple SRAM allocator
+ *
+ * Copyright (C) 2014 Fullhan Microelectronics Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#ifndef __MACH_SRAM_H
+#define __MACH_SRAM_H
+
+/*
+ * SRAM allocations return a CPU virtual address, or NULL on error.
+ * If a DMA address is requested and the SRAM supports DMA, its
+ * mapped address is also returned.
+ *
+ * Errors include SRAM memory not being available, and requesting
+ * DMA mapped SRAM on systems which don't allow that.
+ */
+extern void *sram_alloc(size_t len, dma_addr_t *dma);
+extern void sram_free(void *addr, size_t len);
+
+#endif /* __MACH_SRAM_H */
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/system.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/system.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/system.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/system.h	2021-07-13 23:40:30.654336845 +0300
@@ -0,0 +1,40 @@
+/*
+ * mach/system.h
+ *
+ * Copyright (C) 2014 Fullhan Microelectronics Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <mach/io.h>
+#include <mach/fh_predefined.h>
+#include <mach/pmu.h>
+#include <linux/compiler.h>
+#include <linux/types.h>
+#include <asm/mach/time.h>
+#include <asm/proc-fns.h>
+
+extern void fh_intc_init(void);
+
+void fh_irq_suspend(void);
+void fh_irq_resume(void);
+
+extern unsigned int fh_cpu_suspend_sz;
+extern void fh_cpu_suspend(void);
+
+static inline void arch_idle(void)
+{
+	/* cpu_do_idle(); */
+}
+
+static inline void arch_reset(char mode, const char *cmd)
+{
+	fh_pmu_set_reg(REG_PMU_SWRST_MAIN_CTRL, 0x7fffffff);
+}
+
+#endif /* __ASM_ARCH_SYSTEM_H */
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/timex.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/timex.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/timex.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/timex.h	2021-07-13 23:40:30.654336845 +0300
@@ -0,0 +1,22 @@
+/*
+ * FH timer subsystem
+ *
+ * Copyright (C) 2014 Fullhan Microelectronics Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#ifndef __ASM_ARCH_TIMEX_H
+#define __ASM_ARCH_TIMEX_H
+
+#define TIMER0_CLK			(1000000)
+#define TIMER1_CLK			(1000000)
+#define PAE_PTS_CLK			(1000000)
+
+#define CLOCK_TICK_RATE			TIMER0_CLK
+
+extern struct sys_timer fh_timer;
+
+#endif /* __ASM_ARCH_TIMEX_H__ */
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/uncompress.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/uncompress.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/uncompress.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/uncompress.h	2021-07-13 23:40:30.650336818 +0300
@@ -0,0 +1,57 @@
+/*
+ * Serial port stubs for kernel decompress status messages
+ *
+ * Initially based on:
+ * arch/arm/plat-omap/include/mach/uncompress.h
+ *
+ * Original copyrights follow.
+ *
+ * Copyright (C) 2000 RidgeRun, Inc.
+ * Author: Greg Lonnon <glonnon@ridgerun.com>
+ *
+ * Rewritten by:
+ * Author: <source@mvista.com>
+ * 2004 (c) MontaVista Software, Inc.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/types.h>
+
+#include <asm/mach-types.h>
+#include <mach/chip.h>
+
+#define     REG_UART_THR		(0x0000)
+#define     REG_UART_USR		(0x007c)
+
+#define REG_UART0_THR	(*(unsigned char *)(CONSOLE_REG_BASE + REG_UART_THR))
+#define REG_UART0_USR	(*(unsigned char *)(CONSOLE_REG_BASE + REG_UART_USR))
+
+static void putc(char c)
+{
+	while (!(REG_UART0_USR & (1 << 1)))
+		barrier();
+
+	REG_UART0_THR = c;
+}
+
+static inline void flush(void)
+{
+	while (!(REG_UART0_USR & (1 << 2)))
+		barrier();
+}
+
+static inline void set_uart_info(u32 phys, void *__iomem virt)
+{
+
+}
+
+static inline void __arch_decomp_setup(unsigned long arch_id)
+{
+
+}
+
+#define arch_decomp_setup()	__arch_decomp_setup(arch_id)
+#define arch_decomp_wdog()
diff -uraN linux-3.0.8/arch/arm/mach-fh/include/mach/vmalloc.h linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/vmalloc.h
--- linux-3.0.8/arch/arm/mach-fh/include/mach/vmalloc.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/include/mach/vmalloc.h	2021-07-13 23:40:30.646336791 +0300
@@ -0,0 +1,16 @@
+/*
+ * DaVinci vmalloc definitions
+ *
+ * Author: Kevin Hilman, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <mach/hardware.h>
+
+/* Allow vmalloc range until the IO virtual range minus a 2M "hole" */
+///#define VMALLOC_END	  (IO_VIRT - (2<<20))
+
+#define VMALLOC_END            (PAGE_OFFSET + 0x3e000000)
diff -uraN linux-3.0.8/arch/arm/mach-fh/iomux.c linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/iomux.c
--- linux-3.0.8/arch/arm/mach-fh/iomux.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/iomux.c	2021-07-13 23:40:30.642336765 +0300
@@ -0,0 +1,854 @@
+#include <mach/iomux.h>
+#include <mach/pmu.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/printk.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+
+
+Iomux_Pad fh_iomux_cfg[] = {
+	{
+		.func_name = { "RESETN", "", "", "", },
+		.reg_type  = 9,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_UP,
+		.drv_cur   = -1,
+	},
+	{
+		.func_name = { "TEST", "", "", "", },
+		.reg_type  = 9,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = -1,
+	},
+	{
+		.func_name = { "CIS_CLK", "", "", "", },
+		.reg_type  = 5,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_NONE,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "CIS_HSYNC", "GPIO20", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "CIS_VSYNC", "GPIO21", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "CIS_PCLK", "", "", "", },
+		.reg_type  = 9,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 0,
+	},
+	{
+		.func_name = { "CIS_D0", "GPIO22", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "CIS_D1", "GPIO23", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "CIS_D2", "GPIO24", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "CIS_D3", "GPIO25", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "CIS_D4", "GPIO26", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "CIS_D5", "GPIO27", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "CIS_D6", "GPIO28", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "CIS_D7", "GPIO29", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "CIS_D8", "GPIO30", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "CIS_D9", "GPIO31", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "CIS_D10", "GPIO32", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "CIS_D11", "GPIO33", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "MAC_REF_CLK", "", "", "", },
+		.reg_type  = 17,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_NONE,
+		.drv_cur   = 3,
+	},
+	{
+		.func_name = { "MAC_MDC", "GPIO34", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_NONE,
+		.drv_cur   = 0,
+	},
+	{
+		.func_name = { "MAC_MDIO", "", "", "", },
+		.reg_type  = 17,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "MAC_COL", "GPIO35", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "MAC_CRS", "GPIO36", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "MAC_RXCK", "", "", "", },
+		.reg_type  = 9,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = -1,
+	},
+	{
+		.func_name = { "MAC_RXD0", "", "", "", },
+		.reg_type  = 17,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = -1,
+	},
+
+	{
+		.func_name = { "MAC_RXD1", "GPIO38", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "MAC_RXD2", "GPIO39", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "MAC_RXD3", "GPIO40", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "MAC_RXDV", "GPIO41", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "MAC_TXCK", "", "", "", },
+		.reg_type  = 9,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = -1,
+	},
+	{
+		.func_name = { "MAC_TXD0", "GPIO42", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "MAC_TXD1", "GPIO43", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "MAC_TXD2", "GPIO44", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "MAC_TXD3", "GPIO45", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "MAC_TXEN", "GPIO46", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "MAC_RXER", "GPIO47", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "GPIO0", "ARC_JTAG_TCK", "GPIO0", "CIS_SSI0_CSN1", },
+		.reg_type  = 21,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_NONE,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "GPIO1", "ARC_JTAG_TRSTN", "GPIO1", "CIS_SSI0_RXD", },
+		.reg_type  = 21,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_NONE,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "GPIO2", "ARC_JTAG_TMS", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_NONE,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "GPIO3", "ARC_JTAG_TDI", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "GPIO4", "ARC_JTAG_TDO", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "JTAG_TCK", "GPIO5", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 1,
+		.pupd 	   = IOMUX_PUPD_NONE,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "JTAG_TRSTN", "GPIO6", "PWM_OUT3", "", },
+		.reg_type  = 20,
+		.func_sel  = 1,
+		.pupd 	   = IOMUX_PUPD_NONE,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "JTAG_TMS", "GPIO7", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 1,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "JTAG_TDI", "GPIO8", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 1,
+		.pupd 	   = IOMUX_PUPD_NONE,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "JTAG_TDO", "GPIO9", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 1,
+		.pupd 	   = IOMUX_PUPD_NONE,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "GPIO10", "UART1_OUT", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 1,
+		.pupd 	   = IOMUX_PUPD_UP,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "GPIO11", "UART1_IN", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 1,
+		.pupd 	   = IOMUX_PUPD_UP,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "GPIO12", "PWM_OUT0", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 1,
+		.pupd 	   = IOMUX_PUPD_NONE,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "GPIO13", "PWM_OUT1", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 1,
+		.pupd 	   = IOMUX_PUPD_NONE,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "GPIO14", "PWM_OUT2", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 1,
+		.pupd 	   = IOMUX_PUPD_NONE,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "RESERVED", "", "", "", },
+		.reg_type  = 20,
+		.func_sel  = -1,
+	},
+	{
+		.func_name = { "RESERVED", "", "", "", },
+		.reg_type  = 20,
+		.func_sel  = -1,
+	},
+	{
+		.func_name = { "RESERVED", "", "", "", },
+		.reg_type  = 20,
+		.func_sel  = -1,
+	},
+	{
+		.func_name = { "RESERVED", "", "", "", },
+		.reg_type  = 20,
+		.func_sel  = -1,
+	},
+	{
+		.func_name = { "RESERVED", "", "", "", },
+		.reg_type  = 20,
+		.func_sel  = -1,
+	},
+	{
+		.func_name = { "UART0_IN", "GPIO48", "UART0_IN", " I2S_WS", },
+		.reg_type  = 21,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_UP,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "UART0_OUT", "GPIO49", "UART0_OUT", "I2S_CLK", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_UP,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "CIS_SCL", "GPIO56", "CIS_SCL", "CIS_SSI0_CLK", },
+		.reg_type  = 13,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_NONE,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "CIS_SDA", "GPIO57", "CIS_SDA", "CIS_SSI0_TXD", },
+		.reg_type  = 13,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_NONE,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "SCL1", "GPIO50", "SCL1", "I2S_DI", },
+		.reg_type  = 21,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_NONE,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "SDA1", "GPIO51", "I2S_DO", "", },
+		.reg_type  = 21,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_NONE,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "SSI0_CLK", "", "", "", },
+		.reg_type  = 5,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_NONE,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "SSI0_TXD", "", "", "", },
+		.reg_type  = 5,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_NONE,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "SSI0_CSN0", "GPIO54", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 1,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "SSI0_CSN1", "GPIO55", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 1,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "SSI0_RXD", "", "", "", },
+		.reg_type  = 17,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = -1,
+	},
+	{
+		.func_name = { "SD0_CD", "GPIO52", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "SD0_WP", "GPIO53", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "SD0_CLK", "", "", "", },
+		.reg_type  = 5,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_NONE,
+		.drv_cur   = 3,
+	},
+	{
+		.func_name = { "SD0_CMD_RSP", "", "", "", },
+		.reg_type  = 17,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_UP,
+		.drv_cur   = 3,
+	},
+	{
+		.func_name = { "SD0_DATA0", "", "", "", },
+		.reg_type  = 17,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_UP,
+		.drv_cur   = 3,
+	},
+	{
+		.func_name = { "SD0_DATA1", "", "", "", },
+		.reg_type  = 17,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_UP,
+		.drv_cur   = 2,
+	},
+	{
+		.func_name = { "SD0_DATA2", "", "", "", },
+		.reg_type  = 17,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_UP,
+		.drv_cur   = 3,
+	},
+	{
+		.func_name = { "SD0_DATA3", "", "", "", },
+		.reg_type  = 17,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_UP,
+		.drv_cur   = 3,
+	},
+	{
+		.func_name = { "SD1_CLK", "SSI1_CLK", "", "", },
+		.reg_type  = 8,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_NONE,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "SD1_CD", "GPIO_58", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "SD1_WP", "GPIO_59", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+	{
+		.func_name = { "SD1_DATA0", "SSI1_TXD", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_UP,
+		.drv_cur   = 3,
+	},
+	{
+		.func_name = { "SD1_DATA1", "SSI1_CSN0", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_UP,
+		.drv_cur   = 3,
+	},
+	{
+		.func_name = { "SD1_DATA2", "SSI1_CSN1", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_UP,
+		.drv_cur   = 3,
+	},
+	{
+		.func_name = { "SD1_DATA3", "", "", "", },
+		.reg_type  = 17,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_UP,
+		.drv_cur   = 3,
+	},
+	{
+		.func_name = { "SD1_CMD_RSP", "SSI1_RXD", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_UP,
+		.drv_cur   = 3,
+	},
+	{
+		.func_name = { "RESERVED", "", "", "", },
+		.reg_type  = 20,
+		.func_sel  = -1,
+	},
+	{
+		.func_name = { "RESERVED", "", "", "", },
+		.reg_type  = 20,
+		.func_sel  = -1,
+	},
+	{
+		.func_name = { "RESERVED", "", "", "", },
+		.reg_type  = 20,
+		.func_sel  = -1,
+	},
+	{
+		.func_name = { "RESERVED", "", "", "", },
+		.reg_type  = 20,
+		.func_sel  = -1,
+	},
+	{
+		.func_name = { "CLK_SW0", "", "", "", },
+		.reg_type  = 9,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_UP,
+		.drv_cur   = -1,
+	},
+	{
+		.func_name = { "CLK_SW1", "", "", "", },
+		.reg_type  = 9,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_UP,
+		.drv_cur   = -1,
+	},
+	{
+		.func_name = { "CLK_SW2", "", "", "", },
+		.reg_type  = 9,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_UP,
+		.drv_cur   = -1,
+	},
+	{
+		.func_name = { "CLK_SW3", "", "", "", },
+		.reg_type  = 9,
+		.func_sel  = 0,
+		.pupd 	   = IOMUX_PUPD_UP,
+		.drv_cur   = -1,
+	},
+	{
+		.func_name = { "RESERVED", "", "", "", },
+		.reg_type  = 20,
+		.func_sel  = -1,
+	},
+	{
+		.func_name = { "MAC_TXER", "GPIO37", "", "", },
+		.reg_type  = 20,
+		.func_sel  = 1,
+		.pupd 	   = IOMUX_PUPD_DOWN,
+		.drv_cur   = 1,
+	},
+};
+
+
+static void fh_iomux_setmfs(Iomux_Object *iomux_obj, Iomux_Pad *pad)
+{
+	switch (pad->reg_type) {
+	case 8:
+		(IOMUX_PADTYPE(8)pad->reg)->bit.mfs = pad->func_sel;
+		break;
+	case 13:
+		(IOMUX_PADTYPE(13)pad->reg)->bit.mfs = pad->func_sel;
+		break;
+	case 20:
+		(IOMUX_PADTYPE(20)pad->reg)->bit.mfs = pad->func_sel;
+		break;
+	case 21:
+		(IOMUX_PADTYPE(21)pad->reg)->bit.mfs = pad->func_sel;
+		break;
+	default:
+		break;
+	}
+
+}
+
+#ifdef IOMUX_DEBUG
+
+static int fh_iomux_getmfs(Iomux_Object *iomux_obj, Iomux_Pad *pad)
+{
+	int mfs;
+
+	switch (pad->reg_type) {
+	case 8:
+		mfs = (IOMUX_PADTYPE(8)pad->reg)->bit.mfs;
+		break;
+	case 13:
+		mfs = (IOMUX_PADTYPE(13)pad->reg)->bit.mfs;
+		break;
+	case 20:
+		mfs = (IOMUX_PADTYPE(20)pad->reg)->bit.mfs;
+		break;
+	case 21:
+		mfs = (IOMUX_PADTYPE(21)pad->reg)->bit.mfs;
+		break;
+	default:
+		mfs = -1;
+		break;
+
+	}
+	return mfs;
+}
+
+
+static void fh_iomux_print(Iomux_Object *iomux_obj)
+{
+	int i;
+	u32 reg;
+
+	printk("\tPad No.\t\tFunction Select\t\tRegister\n");
+
+	for (i = 0; i < ARRAY_SIZE(fh_iomux_cfg); i++) {
+		int curr_func;
+
+		curr_func = fh_iomux_getmfs(iomux_obj, &iomux_obj->pads[i]);
+		reg = readl((u32)iomux_obj->pads[i].reg);
+
+		if (curr_func < 0)
+			printk("\t%d\t\t%-8s(no mfs)\t0x%08x\n", i, iomux_obj->pads[i].func_name[0],
+			       reg);
+		else
+			printk("\t%d\t\t%-16s\t0x%08x\n", i, iomux_obj->pads[i].func_name[curr_func],
+			       reg);
+
+	}
+
+}
+
+#endif
+
+static void fh_iomux_setcur(Iomux_Object *iomux_obj, Iomux_Pad *pad)
+{
+	switch (pad->reg_type) {
+	case 5:
+		(IOMUX_PADTYPE(5)pad->reg)->bit.e8_e4 = pad->drv_cur;
+		break;
+	case 8:
+		(IOMUX_PADTYPE(8)pad->reg)->bit.e8_e4 = pad->drv_cur;
+		break;
+	case 13:
+		(IOMUX_PADTYPE(13)pad->reg)->bit.e4_e2 = pad->drv_cur;
+		break;
+	case 17:
+		(IOMUX_PADTYPE(17)pad->reg)->bit.e8_e4 = pad->drv_cur;
+		break;
+	case 20:
+		(IOMUX_PADTYPE(20)pad->reg)->bit.e4_e2 = pad->drv_cur;
+		break;
+	case 21:
+		(IOMUX_PADTYPE(21)pad->reg)->bit.e4_e2 = pad->drv_cur;
+		break;
+	default:
+		break;
+	}
+
+}
+
+static void fh_iomux_setpupd(Iomux_Object *iomux_obj, Iomux_Pad *pad)
+{
+	switch (pad->reg_type) {
+	case 9:
+		(IOMUX_PADTYPE(9)pad->reg)->bit.pu_pd = pad->pupd;
+		break;
+	case 17:
+		(IOMUX_PADTYPE(17)pad->reg)->bit.pu_pd = pad->pupd;
+		break;
+	case 20:
+		(IOMUX_PADTYPE(20)pad->reg)->bit.pu_pd = pad->pupd;
+		break;
+	case 21:
+		(IOMUX_PADTYPE(21)pad->reg)->bit.pu_pd = pad->pupd;
+		break;
+	default:
+		break;
+	}
+}
+
+static void fh_iomux_setrest(Iomux_Object *iomux_obj, Iomux_Pad *pad)
+{
+	switch (pad->reg_type) {
+	case 5:
+		(IOMUX_PADTYPE(5)pad->reg)->bit.sr = 0;
+		break;
+	case 8:
+		(IOMUX_PADTYPE(8)pad->reg)->bit.sr = 0;
+		break;
+	case 9:
+		(IOMUX_PADTYPE(9)pad->reg)->bit.ie = 1;
+		(IOMUX_PADTYPE(9)pad->reg)->bit.smt = 1;
+		break;
+	case 13:
+		(IOMUX_PADTYPE(13)pad->reg)->bit.ie = 1;
+		(IOMUX_PADTYPE(13)pad->reg)->bit.smt = 1;
+		break;
+	case 17:
+		(IOMUX_PADTYPE(17)pad->reg)->bit.sr = 0;
+		(IOMUX_PADTYPE(17)pad->reg)->bit.ie = 1;
+		(IOMUX_PADTYPE(17)pad->reg)->bit.e = 1;
+		(IOMUX_PADTYPE(17)pad->reg)->bit.smt = 1;
+		break;
+	case 20:
+		(IOMUX_PADTYPE(20)pad->reg)->bit.sr = 0;
+		(IOMUX_PADTYPE(20)pad->reg)->bit.ie = 1;
+		(IOMUX_PADTYPE(20)pad->reg)->bit.smt = 1;
+		break;
+	case 21:
+		(IOMUX_PADTYPE(21)pad->reg)->bit.sr = 0;
+		(IOMUX_PADTYPE(21)pad->reg)->bit.ie = 1;
+		(IOMUX_PADTYPE(21)pad->reg)->bit.smt = 1;
+		break;
+	default:
+		break;
+	}
+
+}
+
+void fh_iomux_init(Iomux_Object *iomux_obj)
+{
+	int i;
+	u32 reg = 0;
+
+	iomux_obj->pads = fh_iomux_cfg;
+
+	for (i = 0; i < ARRAY_SIZE(fh_iomux_cfg); i++) {
+		iomux_obj->pads[i].reg_offset = i * 4;
+		iomux_obj->pads[i].reg = &reg;
+
+#if defined(CONFIG_FH_PWM_NUM) && CONFIG_FH_PWM_NUM == 4
+	//for pwm3 only
+	if(fh_iomux_cfg[i].func_sel == 2
+		&& iomux_obj->pads[i].reg_offset == 0xa8)
+	{
+		fh_pmu_set_reg(0x128, 0x00101110);
+		fh_iomux_cfg[i].func_sel = 1;
+	}
+#endif
+
+        if(iomux_obj->pads[i].func_sel < 0)
+            continue;
+
+		fh_iomux_setmfs(iomux_obj, &fh_iomux_cfg[i]);
+		fh_iomux_setcur(iomux_obj, &fh_iomux_cfg[i]);
+		fh_iomux_setpupd(iomux_obj, &fh_iomux_cfg[i]);
+		fh_iomux_setrest(iomux_obj, &fh_iomux_cfg[i]);
+		fh_pmu_set_reg(0x5c + iomux_obj->pads[i].reg_offset, reg);
+	}
+#ifdef CONFIG_FH_GMAC_RMII
+	//(IOMUX_PADTYPE(17)(iomux_obj->pads[18]).reg)->bit.e = 1;
+	reg = fh_pmu_get_reg(REG_PMU_PAD_MAC_REF_CLK_CFG);
+	reg |= (1 << 13);
+	fh_pmu_set_reg(REG_PMU_PAD_MAC_REF_CLK_CFG, reg);
+#else
+	//(IOMUX_PADTYPE(17)(iomux_obj->pads[18]).reg)->bit.e = 0;
+	reg = fh_pmu_get_reg(REG_PMU_PAD_MAC_REF_CLK_CFG);
+	reg &= ~(1 << 13);
+	fh_pmu_set_reg(REG_PMU_PAD_MAC_REF_CLK_CFG, reg);
+#endif
+#ifdef IOMUX_DEBUG
+	fh_iomux_print(iomux_obj);
+#endif
+}
diff -uraN linux-3.0.8/arch/arm/mach-fh/irq.c linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/irq.c
--- linux-3.0.8/arch/arm/mach-fh/irq.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/irq.c	2021-07-13 23:40:30.646336791 +0300
@@ -0,0 +1,151 @@
+/*
+ * Fullhan FH board support
+ *
+ * Copyright (C) 2014 Fullhan Microelectronics Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+
+#include <mach/hardware.h>
+#include <mach/system.h>
+#include <asm/mach/irq.h>
+
+#include <mach/chip.h>
+#include <mach/fh_predefined.h>
+#include <mach/irqs.h>
+
+static void fh_intc_ack(struct irq_data *d)
+{
+
+}
+static void fh_intc_enable(struct irq_data *d)
+{
+	if (d->irq >= NR_INTERNAL_IRQS)
+		return;
+
+	if (d->irq > 31) {
+		SET_REG_M(VINTC(REG_IRQ_EN_HIGH), 1 << (d->irq - 32),
+			  1 << (d->irq - 32));
+	} else
+		SET_REG_M(VINTC(REG_IRQ_EN_LOW), 1 << d->irq, 1 << d->irq);
+
+}
+static void fh_intc_disable(struct irq_data *d)
+{
+	if (d->irq >= NR_INTERNAL_IRQS)
+		return;
+	if (d->irq > 31)
+		SET_REG_M(VINTC(REG_IRQ_EN_HIGH), 0, 1 << (d->irq - 32));
+	else
+		SET_REG_M(VINTC(REG_IRQ_EN_LOW), 0, 1 << d->irq);
+}
+
+static void fh_intc_mask(struct irq_data *d)
+{
+	if (d->irq >= NR_INTERNAL_IRQS)
+		return;
+	if (d->irq > 31) {
+		SET_REG_M(VINTC(REG_IRQ_IRQMASK_HIGH), 1 << (d->irq - 32),
+			  1 << (d->irq - 32));
+	} else
+		SET_REG_M(VINTC(REG_IRQ_IRQMASK_LOW), 1 << d->irq, 1 << d->irq);
+}
+
+static void fh_intc_unmask(struct irq_data *d)
+{
+	if (d->irq >= NR_INTERNAL_IRQS)
+		return;
+	if (d->irq > 31)
+		SET_REG_M(VINTC(REG_IRQ_IRQMASK_HIGH), 0, 1 << (d->irq - 32));
+	else
+		SET_REG_M(VINTC(REG_IRQ_IRQMASK_LOW), 0, 1 << d->irq);
+}
+
+#ifdef CONFIG_PM
+
+static u32 wakeups_high;
+static u32 wakeups_low;
+static u32 backups_high;
+static u32 backups_low;
+
+static int fh_intc_set_wake(struct irq_data *d, unsigned value)
+{
+	if (unlikely(d->irq >= NR_IRQS))
+		return -EINVAL;
+
+	if (value) {
+		if (d->irq > 31)
+			wakeups_high |= (1 << (d->irq - 32));
+		else
+			wakeups_low |= (1 << d->irq);
+	} else {
+		if (d->irq > 31)
+			wakeups_high &= ~(1 << (d->irq - 32));
+		else
+			wakeups_low &= ~(1 << d->irq);
+	}
+	return 0;
+}
+
+void fh_irq_suspend(void)
+{
+	backups_high = GET_REG(VINTC(REG_IRQ_EN_HIGH));
+	backups_low = GET_REG(VINTC(REG_IRQ_EN_LOW));
+
+	SET_REG(VINTC(REG_IRQ_EN_HIGH), wakeups_high);
+	SET_REG(VINTC(REG_IRQ_EN_LOW), wakeups_low);
+}
+
+void fh_irq_resume(void)
+{
+	SET_REG(VINTC(REG_IRQ_EN_HIGH), backups_high);
+	SET_REG(VINTC(REG_IRQ_EN_LOW), backups_low);
+}
+
+#else
+#define fh_intc_set_wake   NULL
+#endif
+
+static struct irq_chip fh_irq_chip = {
+	.name		= "FH_INTC",
+	.irq_ack	= fh_intc_ack,
+	.irq_mask	= fh_intc_mask,
+	.irq_unmask	= fh_intc_unmask,
+
+	.irq_enable = fh_intc_enable,
+	.irq_disable = fh_intc_disable,
+	.irq_set_wake = fh_intc_set_wake,
+};
+
+void __init fh_intc_init(void)
+{
+	int i;
+
+	//disable all interrupts
+	SET_REG(VINTC(REG_IRQ_EN_LOW), 0x0);
+	SET_REG(VINTC(REG_IRQ_EN_HIGH), 0x0);
+
+	for (i = 0; i < NR_IRQS; i++) {
+		irq_set_chip_and_handler(i, &fh_irq_chip, handle_level_irq);
+		set_irq_flags(i, IRQF_VALID | IRQF_PROBE);
+	}
+
+}
diff -uraN linux-3.0.8/arch/arm/mach-fh/Kconfig linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/Kconfig
--- linux-3.0.8/arch/arm/mach-fh/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/Kconfig	2021-07-13 23:40:30.646336791 +0300
@@ -0,0 +1,52 @@
+if ARCH_FULLHAN
+
+config CPU_FH8833
+	select CPU_V6
+	bool	
+menu "FullHan Implementations"
+
+comment "FullHan Core Type"
+
+choice
+	prompt "Select Fullhan Chip:"
+	default ARCH_FH8833
+
+config ARCH_FH8833
+	bool "FullHan FH8833 based system"
+	select CPU_FH8833
+
+endchoice
+
+comment "FullHan Board Type"
+
+config USE_PTS_AS_CLOCKSOURCE
+	bool "use pts as clock source"
+	default n
+	
+config FH_SIMPLE_TIMER
+	bool "use fh self-defined simple timer"
+	default n
+
+config MACH_FH8833
+	bool "FullHan FH8833 board"
+	default y
+	depends on ARCH_FH8833
+	select MISC_DEVICES
+	select I2C
+	help
+	  Configure this option to specify the whether the board used
+	  for development is FH8833
+
+	  
+config  MACH_FH_NAND
+	bool "USE NAND FLASH"
+	default n
+	help
+	  use NAND FLASH 
+
+config JLINK_DEBUG
+	bool "Use jlink to debug kernel."
+
+endmenu
+
+endif
diff -uraN linux-3.0.8/arch/arm/mach-fh/Makefile linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/Makefile
--- linux-3.0.8/arch/arm/mach-fh/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/Makefile	2021-07-13 23:40:30.646336791 +0300
@@ -0,0 +1,19 @@
+#
+# Makefile for the linux kernel.
+#
+#
+
+# Common objects
+obj-y 			:= time.o clock.o \
+			   sram.o irq.o pmu.o pm.o sram.o
+# gpio.o
+# Chip specific
+obj-$(CONFIG_ARCH_FH8833)       += fh8833.o
+# Board specific
+obj-$(CONFIG_MACH_FH8833) 	+= board-fh8833.o pinctrl.o
+obj-$(CONFIG_FH_SIMPLE_TIMER) 	+= fh_simple_timer.o
+
+# Power Management
+obj-$(CONFIG_CPU_FREQ)		+= cpufreq.o
+obj-$(CONFIG_CPU_IDLE)		+= cpuidle.o
+obj-$(CONFIG_SUSPEND)		+= pm.o sleep.o
diff -uraN linux-3.0.8/arch/arm/mach-fh/Makefile.boot linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/Makefile.boot
--- linux-3.0.8/arch/arm/mach-fh/Makefile.boot	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/Makefile.boot	2021-07-13 23:40:30.646336791 +0300
@@ -0,0 +1,4 @@
+   zreladdr-y	:= 0xA0008000
+params_phys-y	:= 0xA0000100
+initrd_phys-y	:= 0xA0800000
+
diff -uraN linux-3.0.8/arch/arm/mach-fh/pinctrl.c linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/pinctrl.c
--- linux-3.0.8/arch/arm/mach-fh/pinctrl.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/pinctrl.c	2021-07-13 23:40:30.646336791 +0300
@@ -0,0 +1,299 @@
+#ifdef CONFIG_MACH_FH8830
+#ifdef CONFIG_MACH_FH8830_QFN
+#include <mach/fh8830_iopad_qfn.h>
+#else
+#include <mach/fh8830_iopad_bga.h>
+#endif
+#endif
+
+#ifdef CONFIG_MACH_FH8833
+#include <mach/fh8833_iopad_mipi.h>
+#endif
+
+#include <mach/pinctrl.h>
+#include <linux/module.h>
+
+/* #define  FH_PINCTRL_DEBUG */
+#ifdef FH_PINCTRL_DEBUG
+#define PRINT_DBG(fmt,args...)  OS_PRINT(fmt,##args)
+#else
+#define PRINT_DBG(fmt,args...)  do{} while(0)
+#endif
+
+static PinCtrl_Object pinctrl_obj;
+OS_LIST fh_pinctrl_devices = OS_LIST_INIT(fh_pinctrl_devices);
+
+static int fh_pinctrl_func_select(PinCtrl_Pin *pin, unsigned int flag)
+{
+    unsigned int reg;
+
+    if(!pin)
+    {
+        OS_PRINT("ERROR: pin is null\n\n");
+        return -1;
+    }
+
+    if(flag & NEED_CHECK_PINLIST)
+    {
+        if(pinctrl_obj.pinlist[pin->pad_id])
+        {
+            OS_PRINT("ERROR: pad %d has already been set\n\n", pin->pad_id);
+            return -2;
+        }
+    }
+
+    reg = GET_REG(pinctrl_obj.vbase + pin->reg_offset);
+
+    pin->reg = (PinCtrl_Register *)&reg;
+
+    pin->reg->bit.mfs = pin->func_sel;
+
+    if(pin->pullup_pulldown == PUPD_DOWN)
+    {
+	    pin->reg->bit.pdn = 0;
+    }
+    else if(pin->pullup_pulldown == PUPD_UP)
+    {
+	    pin->reg->bit.pun = 0;
+    }
+    else
+    {
+	    pin->reg->bit.pdn = 1;
+	    pin->reg->bit.pun = 1;
+    }
+
+    pin->reg->bit.ie = 1;
+
+    SET_REG(pinctrl_obj.vbase + pin->reg_offset, pin->reg->dw);
+
+    pinctrl_obj.pinlist[pin->pad_id] = pin;
+
+    return 0;
+}
+
+static int fh_pinctrl_mux_switch(PinCtrl_Mux *mux, unsigned int flag)
+{
+    if(mux->cur_pin > MUX_NUM)
+    {
+        OS_PRINT("ERROR: selected function is not exist, sel_func=%d\n\n", mux->cur_pin);
+        return -3;
+    }
+
+    if(!mux->mux_pin[mux->cur_pin])
+    {
+        OS_PRINT("ERROR: mux->mux_pin[%d] has no pin\n\n", mux->cur_pin);
+        return -4;
+    }
+
+    PRINT_DBG("\t%s[%d]\n", mux->mux_pin[mux->cur_pin]->func_name, mux->cur_pin);
+    return fh_pinctrl_func_select(mux->mux_pin[mux->cur_pin], flag);
+}
+
+
+static int fh_pinctrl_device_switch(PinCtrl_Device *dev, unsigned int flag)
+{
+    int i, ret;
+    for(i=0; i<dev->mux_count; i++)
+    {
+        unsigned int *mux_addr = (unsigned int *)((unsigned int)dev
+                + sizeof(*dev) - 4 + i*4);
+        PinCtrl_Mux *mux = (PinCtrl_Mux *)(*mux_addr);
+
+        ret = fh_pinctrl_mux_switch(mux, flag);
+        if(ret)
+        {
+            return ret;
+        }
+    }
+
+    return 0;
+}
+
+static PinCtrl_Device * fh_pinctrl_get_device_by_name(char *name)
+{
+    PinCtrl_Device *dev = OS_NULL;
+
+    list_for_each_entry(dev, &fh_pinctrl_devices, list)
+    {
+        if(!strcmp(name, dev->dev_name))
+        {
+            return dev;
+        }
+    }
+
+    return 0;
+}
+
+int fh_pinctrl_check_pinlist(void)
+{
+    int i;
+    for(i=0; i<PAD_NUM; i++)
+    {
+        if(!pinctrl_obj.pinlist[i])
+        {
+        	PRINT_DBG("ERROR: pad %d is still empty\n", i);
+        }
+    }
+
+    return 0;
+}
+
+static int fh_pinctrl_init_devices(char** devlist, int listsize, unsigned int flag)
+{
+    int i, ret;
+    PinCtrl_Device *dev;
+
+    memset(pinctrl_obj.pinlist, 0, sizeof(pinctrl_obj.pinlist));
+
+    for(i=0; i<listsize; i++)
+    {
+        dev = fh_pinctrl_get_device_by_name(devlist[i]);
+
+        if(!dev)
+        {
+            OS_PRINT("ERROR: cannot find device %s\n", devlist[i]);
+            return -5;
+        }
+
+        PRINT_DBG("%s:\n", dev->dev_name);
+        ret = fh_pinctrl_device_switch(dev, flag);
+        PRINT_DBG("\n");
+        if(ret)
+        {
+            return ret;
+        }
+
+    }
+
+    fh_pinctrl_check_pinlist();
+
+    return 0;
+
+}
+
+static void fh_pinctrl_init_pin(void)
+{
+    int i;
+
+    for(i=0; i<PAD_NUM; i++)
+    {
+        PinCtrl_Pin *pin = pinctrl_obj.pinlist[i];
+        if(!pin)
+        {
+        	unsigned int reg;
+        	PRINT_DBG("ERROR: pad %d is empty\n", i);
+        	reg = GET_REG(pinctrl_obj.vbase + i * 4);
+        	reg &= ~(0x1000);
+        	SET_REG(pinctrl_obj.vbase + i * 4, reg);
+        	continue;
+        }
+        pin->reg->dw = GET_REG(pinctrl_obj.vbase +
+                pin->reg_offset);
+
+        pin->input_enable = pin->reg->bit.ie;
+        pin->output_enable = pin->reg->bit.oe;
+    }
+}
+
+
+void fh_pinctrl_init(unsigned int base)
+{
+    pinctrl_obj.vbase = pinctrl_obj.pbase = (void *)base;
+
+    fh_pinctrl_init_devicelist(&fh_pinctrl_devices);
+    fh_pinctrl_init_devices(fh_pinctrl_selected_devices,
+            ARRAY_SIZE(fh_pinctrl_selected_devices),
+            NEED_CHECK_PINLIST);
+    fh_pinctrl_init_pin();
+}
+
+void fh_pinctrl_prt(struct seq_file *sfile)
+{
+    int i;
+    seq_printf(sfile, "%2s\t%8s\t%4s\t%8s\t%4s\t%4s\t%4s\t%4s\n",
+		    "id", "name", "addr", "reg", "sel", "ie", "oe", "pupd");
+    for(i=0; i<PAD_NUM; i++)
+    {
+        if(!pinctrl_obj.pinlist[i])
+        {
+                OS_PRINT("ERROR: pad %d is empty\n", i);
+		continue;
+        }
+        seq_printf(sfile, "%02d\t%8s\t0x%08x\t0x%08x\t%04d\t%04d\t%04d\t%04d\n",
+                pinctrl_obj.pinlist[i]->pad_id,
+                pinctrl_obj.pinlist[i]->func_name,
+                pinctrl_obj.pinlist[i]->reg_offset + 0xf0000080,
+                GET_REG(pinctrl_obj.vbase + pinctrl_obj.pinlist[i]->reg_offset),
+                pinctrl_obj.pinlist[i]->func_sel,
+                pinctrl_obj.pinlist[i]->input_enable,
+                pinctrl_obj.pinlist[i]->output_enable,
+                pinctrl_obj.pinlist[i]->pullup_pulldown);
+    }
+
+}
+
+
+int fh_pinctrl_smux(char *devname, char* muxname, int muxsel, unsigned int flag)
+{
+    PinCtrl_Device *dev;
+    int i, ret;
+
+    dev = fh_pinctrl_get_device_by_name(devname);
+
+    if(!dev)
+    {
+        OS_PRINT("ERROR: cannot find device %s\n", devname);
+        return -4;
+    }
+
+    for(i=0; i<dev->mux_count; i++)
+    {
+        unsigned int *mux_addr = (unsigned int *)((unsigned int)dev
+                + sizeof(*dev) - 4 + i*4);
+        PinCtrl_Mux *mux = (PinCtrl_Mux *)(*mux_addr);
+
+        if(!strcmp(muxname, mux->mux_pin[0]->func_name))
+        {
+            mux->cur_pin = muxsel;
+            ret = fh_pinctrl_mux_switch(mux, flag);
+            return ret;
+        }
+    }
+
+    if(i == dev->mux_count)
+    {
+        OS_PRINT("ERROR: cannot find mux %s of device %s\n", muxname, devname);
+        return -6;
+    }
+
+    fh_pinctrl_check_pinlist();
+
+    return 0;
+}
+EXPORT_SYMBOL(fh_pinctrl_smux);
+
+int fh_pinctrl_sdev(char *devname, unsigned int flag)
+{
+    PinCtrl_Device *dev;
+    int ret;
+
+    dev = fh_pinctrl_get_device_by_name(devname);
+    if(!dev)
+    {
+        OS_PRINT("ERROR: cannot find device %s\n", devname);
+        return -7;
+    }
+
+    OS_PRINT("%s:\n", dev->dev_name);
+    ret = fh_pinctrl_device_switch(dev, flag);
+    OS_PRINT("\n");
+    if(ret)
+    {
+        return ret;
+    }
+
+    fh_pinctrl_check_pinlist();
+
+    return 0;
+}
+EXPORT_SYMBOL(fh_pinctrl_sdev);
diff -uraN linux-3.0.8/arch/arm/mach-fh/pm.c linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/pm.c
--- linux-3.0.8/arch/arm/mach-fh/pm.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/pm.c	2021-07-13 23:40:30.646336791 +0300
@@ -0,0 +1,223 @@
+/*
+ * FH Power Management Routines
+ *
+ * Copyright (C) 2014 Fullhan Microelectronics Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/pm.h>
+#include <linux/suspend.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+
+#include <asm/cacheflush.h>
+#include <asm/delay.h>
+
+#include <mach/sram.h>
+#include <mach/system.h>
+#include <mach/io.h>
+#include <mach/gpio.h>
+#include <mach/ddrc.h>
+#include <mach/pmu.h>
+
+#ifdef CONFIG_PM
+static u32 old_clk_gate = 0;
+
+static void (*fh_sram_suspend)(void);
+
+static inline void fh_pm_pll0_to_xtal(void)
+{
+	u32 reg;
+
+	reg = fh_pmu_get_reg(REG_PMU_SYS_CTRL);
+	reg &= ~(0x1);
+	fh_pmu_set_reg(REG_PMU_SYS_CTRL, reg);
+}
+
+static inline void fh_pm_xtal_to_pll0(void)
+{
+	u32 reg;
+
+	reg = fh_pmu_get_reg(REG_PMU_SYS_CTRL);
+	reg |= 0x1;
+	fh_pmu_set_reg(REG_PMU_SYS_CTRL, reg);
+}
+
+static inline void fh_pm_gate_clocks(void)
+{
+	u32 reg;
+	old_clk_gate = fh_pmu_get_reg(REG_PMU_CLK_GATE);
+	reg = fh_pmu_get_reg(REG_PMU_CLK_GATE);
+	reg |= 0x7fff3fb1;
+	fh_pmu_set_reg(REG_PMU_CLK_GATE, reg);
+}
+
+static inline void fh_pm_ungate_clocks(void)
+{
+	u32 reg;
+
+	reg = old_clk_gate;
+	fh_pmu_set_reg(REG_PMU_CLK_GATE, reg);
+}
+
+
+static void fh_sram_push(void *dest, void *src, unsigned int size)
+{
+	memcpy(dest, src, size);
+	flush_icache_range((unsigned long)dest, (unsigned long)(dest + size));
+}
+
+static int fh_pm_valid_state(suspend_state_t state)
+{
+	switch (state) {
+	case PM_SUSPEND_ON:
+	case PM_SUSPEND_STANDBY:
+	case PM_SUSPEND_MEM:
+		return 1;
+
+	default:
+		return 0;
+	}
+}
+
+static void fh_pm_suspend_to_ram(void)
+{
+	fh_pm_pll0_to_xtal();
+	fh_pm_gate_clocks();
+
+	fh_sram_suspend();
+
+	fh_pm_ungate_clocks();
+	fh_pm_xtal_to_pll0();
+}
+
+static inline void fh_ddrc_selfrefresh_enable(void)
+{
+	u32 reg;
+
+	/*
+	 * Ensure that the Cadence DDR Controller is idle,
+	 * that is when the controller_busy signal is low.
+	 */
+	do {
+		reg = readl(VA_DDRC_REG_BASE + OFFSET_DENAL_CTL_57);
+	} while (reg & DDRC_CONTROLLER_BUSY);
+
+	/*
+	 * Put the memories into self-refresh mode
+	 * by issuing one of the self-refresh entry commands
+	 * through the Low Power Control Module
+	 */
+	writel(DDRC_LPI_SR_WAKEUP_TIME | DDRC_LP_CMD_SELFREFRESH | DDRC_CKSRX_DELAY,
+	       VA_DDRC_REG_BASE + OFFSET_DENAL_CTL_31);
+
+	//wait no more
+	/*
+	do
+	{
+	    reg = readl(VA_DDRC_REG_BASE + OFFSET_DENAL_CTL_97);
+	}
+	while(reg & DDRC_CKE_STATUS);
+	*/
+}
+
+static inline void fh_ddrc_selfrefresh_disable(void)
+{
+	//Exit any low power state
+	writel(DDRC_LPI_SR_WAKEUP_TIME | DDRC_LP_CMD_EXITLOWPOWER | DDRC_CKSRX_DELAY,
+	       VA_DDRC_REG_BASE + OFFSET_DENAL_CTL_31);
+}
+
+static void fh_pm_suspend_to_cache(void)
+{
+	asm volatile("mov r1, #0\n\t"
+		     "mcr p15, 0, r1, c7, c10, 4\n\t"
+		     "mcr p15, 0, r1, c7, c0, 4\n\t"
+		     : /* no output */
+		     : /* no input */
+		     : "r1");
+
+	fh_ddrc_selfrefresh_enable();
+
+	asm volatile("mov r1, #0\n\t"
+		     "mcr p15, 0, r1, c7, c10, 4\n\t"
+		     "mcr p15, 0, r1, c7, c0, 4\n\t"
+		     : /* no output */
+		     : /* no input */
+		     : "r1");
+	fh_ddrc_selfrefresh_disable();
+}
+
+static int fh_pm_enter(suspend_state_t state)
+{
+	int ret = 0;
+
+	fh_irq_suspend();
+	fh_gpio_irq_suspend();
+
+	switch (state) {
+	case PM_SUSPEND_ON:
+		cpu_do_idle();
+		break;
+	case PM_SUSPEND_STANDBY:
+		fh_pm_suspend_to_cache();
+		break;
+	case PM_SUSPEND_MEM:
+		fh_pm_suspend_to_ram();
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	fh_gpio_irq_resume();
+	fh_irq_resume();
+
+	return ret;
+}
+
+static const struct platform_suspend_ops fh_pm_ops = {
+	.enter		= fh_pm_enter,
+	.valid		= fh_pm_valid_state,
+};
+
+static int __init fh_pm_probe(struct platform_device *pdev)
+{
+	fh_sram_suspend = sram_alloc(fh_cpu_suspend_sz, NULL);
+	if (!fh_sram_suspend) {
+		dev_err(&pdev->dev, "cannot allocate SRAM memory\n");
+		return -ENOMEM;
+	}
+	fh_sram_push(fh_sram_suspend, fh_cpu_suspend,
+		       fh_cpu_suspend_sz);
+	suspend_set_ops(&fh_pm_ops);
+
+	return 0;
+}
+
+static int __exit fh_pm_remove(struct platform_device *pdev)
+{
+	sram_free(fh_sram_suspend, fh_cpu_suspend_sz);
+	return 0;
+}
+
+static struct platform_driver fh_pm_driver = {
+	.driver =
+	{
+		.name	 = "pm-fh",
+		.owner	 = THIS_MODULE,
+	},
+	.remove = __exit_p(fh_pm_remove),
+};
+
+static int __init fh_pm_init(void)
+{
+	return platform_driver_probe(&fh_pm_driver, fh_pm_probe);
+}
+late_initcall(fh_pm_init);
+#endif
diff -uraN linux-3.0.8/arch/arm/mach-fh/pmu.c linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/pmu.c
--- linux-3.0.8/arch/arm/mach-fh/pmu.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/pmu.c	2021-07-13 23:40:30.646336791 +0300
@@ -0,0 +1,57 @@
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/io.h>
+
+#include <mach/io.h>
+#include <mach/chip.h>
+
+static int fh_pmu_flag_stop = 0;
+
+void fh_pmu_stop(void)
+{
+	fh_pmu_flag_stop = 1;
+}
+EXPORT_SYMBOL(fh_pmu_stop);
+
+void fh_pmu_set_reg(u32 offset, u32 data)
+{
+	if (fh_pmu_flag_stop)
+		return;
+
+	if (offset > PMU_REG_SIZE) {
+		pr_err("fh_pmu_set_reg: offset is out of range");
+		return;
+	}
+	writel(data, VPMU(PMU_REG_BASE + offset));
+}
+EXPORT_SYMBOL(fh_pmu_set_reg);
+
+u32 fh_pmu_get_reg(u32 offset)
+{
+	if (fh_pmu_flag_stop)
+		return 0;
+
+	if (offset > PMU_REG_SIZE) {
+		pr_err("fh_pmu_get_reg: offset is out of range");
+		return 0;
+	}
+	return readl(VPMU(PMU_REG_BASE + offset));
+}
+EXPORT_SYMBOL(fh_pmu_get_reg);
+
+void fh_pae_set_reg(u32 offset, u32 data)
+{
+	if (offset > 0x60) {
+		pr_err("fh_pae_set_reg: offset is out of range");
+		return;
+	}
+	writel(data, VPAE(PAE_REG_BASE + offset));
+}
+EXPORT_SYMBOL(fh_pae_set_reg);
+
+int fh_pmu_init(void)
+{
+	return 0;
+}
diff -uraN linux-3.0.8/arch/arm/mach-fh/sleep.S linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/sleep.S
--- linux-3.0.8/arch/arm/mach-fh/sleep.S	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/sleep.S	2021-07-13 23:40:30.646336791 +0300
@@ -0,0 +1,144 @@
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <mach/chip.h>
+#include <mach/io.h>
+#include <mach/ddrc.h>
+
+#ifdef CONFIG_PM
+#define PMU_MASK_SWITCH_PLL0	0x1
+#define PMU_MASK_DDR_SEL		0x1000000
+#define PMU_MASK_DDR_DIV		0xff
+#define PMU_MASK_PLL1_PDN		0x80000000
+
+
+	.macro wait_ddrc_idle
+1:	ldr	r3, [r1, #OFFSET_DENAL_CTL_57]
+	tst	r3, #DDRC_CONTROLLER_BUSY
+	bne	1b
+	.endm
+
+
+	.macro enable_ddrc_selfrefresh
+	ldr r3, .fh_ddrc_cmd_en_self_refresh
+	str	r3, [r1, #OFFSET_DENAL_CTL_31]
+	.endm
+
+
+	.macro wait_ddrc_cke
+1:	ldr	r3, [r1, #OFFSET_DENAL_CTL_97]
+	tst	r3, #DDRC_CKE_STATUS
+	bne	1b
+	.endm
+
+
+	.macro disable_ddrc_selfrefresh
+	ldr r3, .fh_ddrc_cmd_dis_self_refresh
+	str	r3, [r1, #OFFSET_DENAL_CTL_31]
+	.endm
+
+
+	.macro ddr_to_pll0
+	ldr r3, [r2, #REG_PMU_CLK_SEL]
+	bic	r3, r3, #PMU_MASK_DDR_SEL
+	str	r3, [r2, #REG_PMU_CLK_SEL]
+	.endm
+
+
+	.macro ddr_to_pll1
+	ldr r3, [r2, #REG_PMU_CLK_SEL]
+	orr	r3, r3, #PMU_MASK_DDR_SEL
+	str	r3, [r2, #REG_PMU_CLK_SEL]
+	.endm
+
+#if 1
+	.macro ddr_dec_feq
+	ldr r3, [r2, #REG_PMU_CLK_DIV1]
+	orr	r3, r3, #PMU_MASK_DDR_DIV
+	str	r3, [r2, #REG_PMU_CLK_SEL]
+	.endm
+
+
+	.macro ddr_inc_feq
+	ldr r3, [r2, #REG_PMU_CLK_DIV1]
+	bic	r3, r3, #PMU_MASK_DDR_DIV
+	orr	r3, r3, #0x1
+	str	r3, [r2, #REG_PMU_CLK_SEL]
+	.endm
+
+
+	.macro pll1_power_down
+	ldr r3, [r2, #REG_PMU_PLL1_CTRL]
+	bic	r3, r3, #PMU_MASK_PLL1_PDN
+	str	r3, [r2, #REG_PMU_PLL1_CTRL]
+	.endm
+
+
+	.macro pll1_power_on
+	ldr r3, [r2, #REG_PMU_PLL1_CTRL]
+	orr	r3, r3, #PMU_MASK_PLL1_PDN
+	str	r3, [r2, #REG_PMU_PLL1_CTRL]
+	.endm
+#endif
+
+	.text
+ENTRY(fh_cpu_suspend)
+
+	stmfd	sp!, {r0-r12, lr}		@ save registers on stack
+
+	/*
+
+	 * Register usage:
+	 *  R1 = Base address of DDRC
+	 *  R2 = Base register for PMU
+	 *  R3 = temporary register
+	 *  R4 = temporary register
+	 *
+	 *  R9 = Test address
+	 */
+
+	ldr	r1, .fh_va_base_ddrc
+	ldr	r2, .fh_va_base_pmu
+	ldr r9, .fh_va_test_addr
+
+	wait_ddrc_idle
+	enable_ddrc_selfrefresh
+	wait_ddrc_cke
+
+	@ddr_dec_feq
+	ddr_to_pll0
+
+	@pll1_power_down
+
+	mcr p15, 0, r0, c7, c10, 4		@ Data Synchronization Barrier operation
+	mcr	p15, 0, r0, c7, c0, 4		@ Wait-for-Interrupt
+
+	@pll1_power_on
+
+    @ddr_inc_feq
+	ddr_to_pll1
+
+	disable_ddrc_selfrefresh
+
+    ldmfd   sp!, {r0-r12, pc}
+
+ENDPROC(fh_cpu_suspend)
+
+.fh_va_base_ddrc:
+	.word VA_DDRC_REG_BASE
+
+.fh_va_base_pmu:
+	.word VA_PMU_REG_BASE
+
+.fh_va_test_addr:
+	.word 0xc03efef0
+
+.fh_ddrc_cmd_en_self_refresh:
+    .word 0x3000a01
+
+.fh_ddrc_cmd_dis_self_refresh:
+    .word 0x3000101
+
+ENTRY(fh_cpu_suspend_sz)
+	.word	. - fh_cpu_suspend
+ENDPROC(fh_cpu_suspend_sz)
+#endif
diff -uraN linux-3.0.8/arch/arm/mach-fh/sram.c linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/sram.c
--- linux-3.0.8/arch/arm/mach-fh/sram.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/sram.c	2021-07-13 23:40:30.646336791 +0300
@@ -0,0 +1,53 @@
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/genalloc.h>
+#include <asm-generic/sizes.h>
+#include <mach/sram.h>
+#include <mach/chip.h>
+#include <mach/io.h>
+
+static struct gen_pool *sram_pool;
+
+void *sram_alloc(size_t len, dma_addr_t *dma)
+{
+	unsigned long vaddr;
+
+	if (!sram_pool)
+		return NULL;
+
+	vaddr = gen_pool_alloc(sram_pool, len);
+	if (!vaddr)
+		return NULL;
+
+	return (void *)vaddr;
+}
+EXPORT_SYMBOL(sram_alloc);
+
+void sram_free(void *addr, size_t len)
+{
+	gen_pool_free(sram_pool, (unsigned long) addr, len);
+}
+EXPORT_SYMBOL(sram_free);
+
+
+/*
+ * REVISIT This supports CPU and DMA access to/from SRAM, but it
+ * doesn't (yet?) support some other notable uses of SRAM:  as TCM
+ * for data and/or instructions; and holding code needed to enter
+ * and exit suspend states (while DRAM can't be used).
+ */
+static int __init sram_init(void)
+{
+	int status = 0;
+
+	sram_pool = gen_pool_create(ilog2(SRAM_GRANULARITY), -1);
+	if (!sram_pool)
+		status = -ENOMEM;
+
+	if (sram_pool)
+		status = gen_pool_add(sram_pool, VA_RAM_REG_BASE, SRAM_SIZE, -1);
+	WARN_ON(status < 0);
+	return status;
+}
+core_initcall(sram_init);
+
diff -uraN linux-3.0.8/arch/arm/mach-fh/time.c linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/time.c
--- linux-3.0.8/arch/arm/mach-fh/time.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/mach-fh/time.c	2021-07-13 23:40:30.646336791 +0300
@@ -0,0 +1,278 @@
+/*
+ * FH timer subsystem
+ *
+ * Copyright (C) 2014 Fullhan Microelectronics Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/clocksource.h>
+#include <linux/clockchips.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/time.h>
+#include <linux/irqreturn.h>
+#include <linux/delay.h>
+
+#include <asm/system.h>
+#include <asm/mach-types.h>
+#include <asm/sched_clock.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/time.h>
+
+#include <mach/hardware.h>
+#include <mach/timex.h>
+#include <mach/chip.h>
+#include <mach/fh_predefined.h>
+#include <mach/irqs.h>
+#include <mach/pmu.h>
+#include <mach/clock.h>
+#include <mach/fh_simple_timer.h>
+
+#define TIMERN_REG_BASE(n)		(TIMER_REG_BASE + 0x14 * n)
+
+#define	REG_TIMER_LOADCNT(n)		(TIMERN_REG_BASE(n) + 0x00)
+#define	REG_TIMER_CUR_VAL(n)		(TIMERN_REG_BASE(n) + 0x04)
+#define	REG_TIMER_CTRL_REG(n)		(TIMERN_REG_BASE(n) + 0x08)
+#define	REG_TIMER_EOI_REG(n)		(TIMERN_REG_BASE(n) + 0x0C)
+#define	REG_TIMER_INTSTATUS(n)		(TIMERN_REG_BASE(n) + 0x10)
+
+#define REG_TIMERS_INTSTATUS		(TIMER_REG_BASE + 0xa0)
+
+#define REG_PAE_PTS_REG 0xe7000040
+
+static struct clock_event_device clockevent_fh;
+static struct clocksource clocksource_fh;
+#ifndef CONFIG_USE_PTS_AS_CLOCKSOURCE
+static unsigned int prev_cycle = 0;
+#endif
+
+struct clk *timer0_clk, *timer1_clk, *pts_clk;
+
+/*
+ * clockevent
+ */
+
+static int fh_set_next_event(unsigned long cycles,
+			     struct clock_event_device *evt)
+{
+
+	/* SET_REG_M(VTIMER(REG_TIMER_CTRL_REG(1)), 0x00, 0x1); */
+	SET_REG(VTIMER(REG_TIMER_LOADCNT(1)), cycles);
+	SET_REG_M(VTIMER(REG_TIMER_CTRL_REG(1)), 0x01, 0x1);
+
+#if defined(CONFIG_ARCH_FH8833)
+	fh_pmu_set_reg(REG_PMU_SWRST_MAIN_CTRL, 0xfffbffff);
+	while (fh_pmu_get_reg(REG_PMU_SWRST_MAIN_CTRL) != 0xffffffff)
+		;
+#endif
+
+#if defined(CONFIG_ARCH_FH8810)
+	unsigned int curr_val;
+
+	curr_val = GET_REG(VTIMER(REG_TIMER_CUR_VAL(1))) ;
+	if (curr_val >  0x80000000) {
+		panic("timer curr %u, want cycles %lu\n", curr_val, cycles);
+
+		SET_REG_M(VTIMER(REG_TIMER_CTRL_REG(1)), 0x01, 0x1);
+		SET_REG(VTIMER(REG_TIMER_LOADCNT(1)), cycles);
+
+		fh_pmu_set_reg(REG_PMU_SWRST_MAIN_CTRL, 0xfff7ffff);
+		while (fh_pmu_get_reg(REG_PMU_SWRST_MAIN_CTRL) != 0xffffffff)
+			;
+	}
+#endif
+	return 0;
+}
+
+static void fh_set_mode(enum clock_event_mode mode,
+			struct clock_event_device *evt)
+{
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+
+		SET_REG(VTIMER(REG_TIMER_CTRL_REG(1)), 0x3);
+		SET_REG(VTIMER(REG_TIMER_LOADCNT(1)), TIMER1_CLK / HZ);
+
+#if defined(CONFIG_ARCH_FH8833)
+		fh_pmu_set_reg(REG_PMU_SWRST_MAIN_CTRL, 0xfffbffff);
+		while (fh_pmu_get_reg(REG_PMU_SWRST_MAIN_CTRL) != 0xffffffff)
+			;
+#endif
+
+#if defined(CONFIG_ARCH_FH8810)
+		fh_pmu_set_reg(REG_PMU_SWRST_MAIN_CTRL, 0xfff7ffff);
+		while (fh_pmu_get_reg(REG_PMU_SWRST_MAIN_CTRL) != 0xffffffff)
+			;
+#endif
+		break;
+	case CLOCK_EVT_MODE_ONESHOT:
+		break;
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_SHUTDOWN:
+		SET_REG(VTIMER(REG_TIMER_CTRL_REG(1)), 0x0);
+		break;
+	case CLOCK_EVT_MODE_RESUME:
+		SET_REG(VTIMER(REG_TIMER_CTRL_REG(1)), 0x3);
+		break;
+	}
+}
+
+
+static irqreturn_t fh_clock_timer_interrupt_handle(int irq, void *dev_id)
+{
+	unsigned int status;
+	status = GET_REG(VTIMER(REG_TIMERS_INTSTATUS));
+
+
+#ifdef CONFIG_FH_SIMPLE_TIMER
+	if (status & (1 << SIMPLE_TIMER_BASE))
+		fh_simple_timer_interrupt();
+#endif
+	if (status & 0x2) {
+		GET_REG(VTIMER(REG_TIMER_EOI_REG(1)));
+		clockevent_fh.event_handler(&clockevent_fh);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction fh_eventtimer_irq = {
+	.name           = "System Timer Tick",
+	.flags          =  IRQF_SHARED | IRQF_DISABLED | IRQF_TIMER,
+	.handler        = fh_clock_timer_interrupt_handle,
+	.dev_id		= &clockevent_fh,
+};
+
+
+static void fh_timer_resources(void)
+{
+
+}
+static DEFINE_CLOCK_DATA(cd);
+
+static void notrace fh_update_sched_clock(void)
+{
+	const cycle_t cyc = clocksource_fh.read(&clocksource_fh);
+	update_sched_clock(&cd, cyc, (u32)~0);
+}
+
+unsigned long long notrace sched_clock(void)
+{
+	const cycle_t cyc = clocksource_fh.read(&clocksource_fh);
+
+	return cyc_to_sched_clock(&cd, cyc, (u32)~0);
+}
+
+static void fh_clocksource_init(void)
+{
+#ifdef CONFIG_USE_PTS_AS_CLOCKSOURCE
+	unsigned long clock_tick_rate = pts_clk->frequency;
+#else
+	unsigned long clock_tick_rate = timer0_clk->frequency;
+	prev_cycle = 0;
+#endif
+
+	if (clocksource_register_hz(&clocksource_fh, clock_tick_rate))
+		panic("register clocksouce :%s error\n", clocksource_fh.name);
+
+	printk(KERN_INFO "timer mult: 0x%x, timer shift: 0x%x\n",
+			clocksource_fh.mult, clocksource_fh.shift);
+
+	/* force check the mult/shift of clocksource */
+	init_fixed_sched_clock(&cd, fh_update_sched_clock, 32, clock_tick_rate,
+			       clocksource_fh.mult, clocksource_fh.shift);
+}
+
+static cycle_t fh_clocksource_read(struct clocksource *cs)
+{
+#ifdef CONFIG_USE_PTS_AS_CLOCKSOURCE
+	return GET_REG(VPAE(REG_PAE_PTS_REG));
+#else
+	unsigned int cycle;
+	cycle = ~GET_REG(VTIMER(REG_TIMER_CUR_VAL(0)));
+#ifdef CONFIG_ARCH_FH8810
+	if (unlikely(prev_cycle > cycle))
+		cycle = ~GET_REG(VTIMER(REG_TIMER_CUR_VAL(0)));
+	prev_cycle = cycle;
+#endif
+	return cycle;
+#endif
+}
+
+static void fh_clockevent_init(void)
+{
+	setup_irq(TMR0_IRQ, &fh_eventtimer_irq);
+	clockevent_fh.mult = div_sc(timer1_clk->frequency,
+			NSEC_PER_SEC, clockevent_fh.shift);
+	clockevent_fh.max_delta_ns = clockevent_delta2ns(0xffffffff,
+				       &clockevent_fh);
+
+	clockevent_fh.min_delta_ns = clockevent_delta2ns(0xf, &clockevent_fh);
+
+	clockevent_fh.cpumask = cpumask_of(0);
+	clockevents_register_device(&clockevent_fh);
+}
+
+
+static void __init fh_timer_init(void)
+{
+
+	timer0_clk = clk_get(NULL, "tmr0_clk");
+	timer1_clk = clk_get(NULL, "tmr0_clk");
+	pts_clk = clk_get(NULL, "pts_clk");
+
+#ifdef CONFIG_USE_PTS_AS_CLOCKSOURCE
+	clk_set_rate(pts_clk, PAE_PTS_CLK);
+	clk_enable(pts_clk);
+#endif
+
+	clk_set_rate(timer0_clk, TIMER0_CLK);
+	clk_enable(timer0_clk);
+
+	clk_set_rate(timer1_clk, TIMER1_CLK);
+	clk_enable(timer1_clk);
+	timer0_clk->frequency = 1000000;
+	timer1_clk->frequency = 1000000;
+	if (IS_ERR(timer0_clk) || IS_ERR(timer1_clk) || IS_ERR(pts_clk))
+		pr_err("fh_timer: clock is not defined\n");
+
+
+	fh_timer_resources();
+	fh_clocksource_init();
+	fh_clockevent_init();
+#ifdef CONFIG_FH_SIMPLE_TIMER
+	fh_simple_timer_init();
+#endif
+}
+
+
+
+static struct clocksource clocksource_fh = {
+	.name		= "fh_clocksource",
+	.rating		= 300,
+	.read		= fh_clocksource_read,
+	.mask		= CLOCKSOURCE_MASK(32),
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+
+static struct clock_event_device clockevent_fh = {
+	.name			= "fh_clockevent",
+	.features       = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
+	.shift			= 32,
+	.set_next_event	= fh_set_next_event,
+	.set_mode		= fh_set_mode,
+};
+
+struct sys_timer fh_timer = {
+	.init   = fh_timer_init,
+};
diff -uraN linux-3.0.8/arch/arm/Makefile linux-3.0.8-fh8632-V1.0_20180330/arch/arm/Makefile
--- linux-3.0.8/arch/arm/Makefile	2021-07-14 21:51:58.551121084 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/Makefile	2021-07-13 23:40:30.386335060 +0300
@@ -139,6 +139,7 @@
 machine-$(CONFIG_ARCH_DOVE)		:= dove
 machine-$(CONFIG_ARCH_EBSA110)		:= ebsa110
 machine-$(CONFIG_ARCH_EP93XX)		:= ep93xx
+machine-$(CONFIG_ARCH_FULLHAN)		:= fh
 machine-$(CONFIG_ARCH_GEMINI)		:= gemini
 machine-$(CONFIG_ARCH_H720X)		:= h720x
 machine-$(CONFIG_ARCH_INTEGRATOR)	:= integrator
diff -uraN linux-3.0.8/arch/arm/tools/mach-types linux-3.0.8-fh8632-V1.0_20180330/arch/arm/tools/mach-types
--- linux-3.0.8/arch/arm/tools/mach-types	2021-07-14 21:51:59.439123655 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/arm/tools/mach-types	2021-07-13 23:40:30.382335033 +0300
@@ -1113,3 +1113,6 @@
 thales_adc		MACH_THALES_ADC		THALES_ADC		3492
 ubisys_p9d_evp		MACH_UBISYS_P9D_EVP	UBISYS_P9D_EVP		3493
 atdgp318		MACH_ATDGP318		ATDGP318		3494
+fh8810			MACH_FH8810		FH8810			9999
+fh8830			MACH_FH8830		FH8830			9999
+fh8833			MACH_FH8833		FH8833			9999
\ No newline at end of file
diff -uraN linux-3.0.8/arch/sh/boot/compressed/vmlinux.scr linux-3.0.8-fh8632-V1.0_20180330/arch/sh/boot/compressed/vmlinux.scr
--- linux-3.0.8/arch/sh/boot/compressed/vmlinux.scr	2021-07-14 21:52:01.075128390 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/sh/boot/compressed/vmlinux.scr	1970-01-01 03:00:00.000000000 +0300
@@ -1,10 +0,0 @@
-SECTIONS
-{
-  .rodata..compressed : {
-	input_len = .;
-	LONG(input_data_end - input_data) input_data = .;
-	*(.data)
-	output_len = . - 4;
-	input_data_end = .;
-	}
-}
diff -uraN linux-3.0.8/arch/sh/boot/romimage/vmlinux.scr linux-3.0.8-fh8632-V1.0_20180330/arch/sh/boot/romimage/vmlinux.scr
--- linux-3.0.8/arch/sh/boot/romimage/vmlinux.scr	2021-07-14 21:52:01.075128390 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/arch/sh/boot/romimage/vmlinux.scr	1970-01-01 03:00:00.000000000 +0300
@@ -1,8 +0,0 @@
-SECTIONS
-{
-  .text : {
-	zero_page_pos = .;
-	*(.data)
-	end_data = .;
-	}
-}
diff -uraN linux-3.0.8/Documentation/DocBook/dvb/dvbstb.pdf linux-3.0.8-fh8632-V1.0_20180330/Documentation/DocBook/dvb/dvbstb.pdf
--- linux-3.0.8/Documentation/DocBook/dvb/dvbstb.pdf	2021-07-14 21:51:58.091119753 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/Documentation/DocBook/dvb/dvbstb.pdf	1970-01-01 03:00:00.000000000 +0300
@@ -1,75 +0,0 @@
-%PDF-1.3
-%
-5 0 obj
-<</Length 6 0 R/Filter /FlateDecode>>
-stream
-xVMo7Wh0i	AZn$av/~1~wP8;}\R"Ojkq6I9w$Otn]e
-'4
-1,%UCd4YY2w_^RoBS@1{(oV )u0+Ou-)4Or`;1fr}FIK\
-S-\C;BsASg[Y$bqRjeKQI15hMJG9k]	$2o?'gKyBsFR,":K[+FtsN/?9`8IdX GigI:K=CD1${h0l4k)'%Y6ksA[syu>4s>	LkE4jFULD7S?LjT%H3'[
-	5kI)du8c )U Rm
-{Nm9J2h6s21D9X!AJmNz(pd
-LP/ZBc%ZhH[5!K147uxk1Wpd@Mk|('f"'x|Abh8hu[o?J_Bv9d{4_/~|"??DD#*o4lz}ys7;+WKThr{>-r+Pendstream
-endobj
-6 0 obj
-902
-endobj
-4 0 obj
-<</Type/Page/MediaBox [0 0 305 152]
-/Parent 3 0 R
-/Resources<</ProcSet[/PDF /Text]
-/ExtGState 9 0 R
-/Font 10 0 R
->>
-/Contents 5 0 R
->>
-endobj
-3 0 obj
-<< /Type /Pages /Kids [
-4 0 R
-] /Count 1
->>
-endobj
-1 0 obj
-<</Type /Catalog /Pages 3 0 R
->>
-endobj
-7 0 obj
-<</Type/ExtGState
-/OPM 1>>endobj
-9 0 obj
-<</R7
-7 0 R>>
-endobj
-10 0 obj
-<</R8
-8 0 R>>
-endobj
-8 0 obj
-<</BaseFont/Times-Roman/Type/Font
-/Subtype/Type1>>
-endobj
-2 0 obj
-<</Producer(ESP Ghostscript 815.02)
-/CreationDate(D:20090906204709)
-/ModDate(D:20090906204709)>>endobj
-xref
-0 11
-0000000000 65535 f 
-0000001215 00000 n 
-0000001429 00000 n 
-0000001156 00000 n 
-0000001006 00000 n 
-0000000015 00000 n 
-0000000987 00000 n 
-0000001263 00000 n 
-0000001363 00000 n 
-0000001304 00000 n 
-0000001333 00000 n 
-trailer
-<< /Size 11 /Root 1 0 R /Info 2 0 R
-/ID [(ZIPJ)(ZIPJ)]
->>
-startxref
-1540
-%%EOF
diff -uraN linux-3.0.8/Documentation/DocBook/v4l/bayer.pdf linux-3.0.8-fh8632-V1.0_20180330/Documentation/DocBook/v4l/bayer.pdf
--- linux-3.0.8/Documentation/DocBook/v4l/bayer.pdf	2021-07-14 21:51:58.099119775 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/Documentation/DocBook/v4l/bayer.pdf	1970-01-01 03:00:00.000000000 +0300
@@ -1,188 +0,0 @@
-%PDF-1.4
-%
-
-5 0 obj <<
-/Length 38        
-/Filter /FlateDecode
->>
-stream
-x+2T0 BC]S3]3\.}\C|@. f
-endstream
-endobj
-4 0 obj <<
-/Type /Page
-/Contents 5 0 R
-/Resources 3 0 R
-/MediaBox [0 0 424 106]
-/Parent 6 0 R
-/Group 2 0 R
->> endobj
-1 0 obj <<
-/Type /XObject
-/Subtype /Form
-/FormType 1
-/PTEX.FileName (./bayer.pdf)
-/PTEX.PageNumber 1
-/PTEX.InfoDict 7 0 R
-/BBox [0 0 595 842]
-/Group 2 0 R
-/Resources <<
-/Font << /F1 8 0 R>>
-/ProcSet [ /PDF /Text ]
->>
-/Length 1328
-/Filter /FlateDecode
->>
-stream
-xX4+G;bHJ,;c{FR:tU_TSLzqi1FuE:/j~o'_O&]5|!CmOJe*KuC}SSTOi-HI6mRbb.xA;_isiW`9)&Nwpf!cVGh-E8G7VisG?pfIvcjm&dwW]Eh=n04w:#?!6la/p^XdgTH5h-^N9n2by-k	E8'X_~oIO@P2@c6{	5}Jf@xAsR\u$	!7s&zhlj9b
-\eZ9t^gbR&Rl3Dxz-GPR4$!y">SLKZb;Q},w8;TD!m*o2!"nh+Qa}*fzN0Dl?#A:^i|Y+,<J7BZzBZ7xZ?r}+BjT7>.r{jIh;2`M70V6N5McnY`:?]S0m7kW|/V9j`cge?$8!a]`?$`^lIhc	D9SO)V6uFn-lQ_h[!aKDj,_trDmkr.Nc-ccK'8<(gG[Q8zlXbK*HwwISqLYS-l6Deq0woGFodqomkdH!%T9r0e'8z6rfw|-!wP0Hk0iYB9,#Kl	,6	~m'%x@5-[B4cPB2\Kc_u:,i~F}t.]z:	FohwqRc-%WAi+|
-endstream
-endobj
-7 0 obj
-<<
-/Author <feff004c0061007500720065006e0074002000500069006e00630068006100720074>
-/Creator <feff0044007200610077>
-/Producer <feff004f00700065006e004f00660066006900630065002e006f0072006700200033002e0032>
-/CreationDate (D:20100921012411+02'00')
->>
-endobj
-8 0 obj
-<<
-/Type /Font
-/Subtype /TrueType
-/BaseFont /BAAAAA+ArialMT
-/FirstChar 0
-/LastChar 3
-/Widths [ 750 722 666 777]
-/FontDescriptor 9 0 R
-/ToUnicode 10 0 R
->>
-endobj
-9 0 obj
-<<
-/Type /FontDescriptor
-/FontName /BAAAAA+ArialMT
-/Flags 4
-/FontBBox [ -664 -324 2027 1037]
-/ItalicAngle 0
-/Ascent 905
-/Descent -211
-/CapHeight 1037
-/StemV 80
-/FontFile2 11 0 R
->>
-endobj
-10 0 obj
-<<
-/Length 234
-/Filter /FlateDecode
->>
-stream
-x]Pj0[^C/!. N>@ Z.YRH3s+EaG8,Byv2IHvqjF7V8</|qwKJ_8ap'-5!W{X$FRE;~beJj.KUmqrRm+-r
-endstream
-endobj
-11 0 obj
-<<
-/Length 12 0 R
-/Filter /FlateDecode
-/Length1 18896
->>
-stream
-x{y|T{g>	&@&% %`BYr3d2,*.q,VkE"AZ}U\JTd{g |;LR  }SHE VOgz=?X`4"}=w>	r@'^Hh@\HhW	]ql:z'zo$E?c_({&`(b/{.?4$#gc*A=9"|1w#6z<~xQ8
-O3q8p/\wH	C$'z*%v$-vC
-:X^`##^UGm;?atG2\m!w$<F6$;Z`Axv$\%G#g+6#d>YF-K:va5
-?7HL39/c]cKX1Jg V3%*uWa*uhCgt'^K!-m9KrIYEYK`Ds7;(mb'h2=.|_|DB?}d43bg$=H|Ft.}OS|XAF7nG3A"W%r|DhJO.aSq)^b@VwfGcczhezX6;$T$b!?J$ j9A#O<j3R?w{qN?,a`V bx\b+u{utu'ioc{FFi\2^W`b=d].)!
-rFv`$#r#Oa~KN)4\Nt^B }]0IB0M(	E
-^!"(^xOT^Q1Q43Dh[xnzz5M=CWX/<9)'6:W/@BR~r#t!Y	gDt.ZH3i+U~c))eCLvd!@kP]x!xSL$Y}HXUSq,\OF<0u6RI&DA+ZJ_SoH\r|?]1K/O#nqN!w5p$?M!8.&O1E<[K\a[t^z(OvP)ZOx}:)X9+.	q^sB
-rOB.h/G2<n^`'	|P;mBDet."x=MX$VX%oX32 jT8sVhC5fhd%TW7rR{Bd.9mtSZjJrRb%Phm"h^zi[e$	IMy"R'g&s:NsJV)RU%#~kCxox
-.]RtJ7XoWJa81	$"YV0ZL8Bk)SH1cm`DF;zM{cCQV!NkWK#iv\MD_1p5y7Kn5AW=-olrnG+?&	Cnn"i8kamGs	UAlnP!Q<a^)FFB$XZ]CWtbjr"v28=	P[Yg9)gLY)]pj$LD8;#KEX)%V5J59?WE1#HB}d> ?NE_d$^j8#v{s6.eG3Ia`5V[,,7:vu,AW8*ffc3L|y+ 1LS]:jm^]jb6iW4,2]F>E1yQwXBRHXw43#K`	6mJ4*\uXn#wffq`J4?:JjJMCCh4eLi3V8#7EnXHmP>uOXzQzc
-H41uP)'#^9dM.:hZ.%tKz6oicpcxsz=aYHHJ%7{1}@F<Q</3i}y7i=w)J,25ic'#u0mwiw<6Qid)=mjzzZzZrB>5f&^NH)J(dgl7IpP8#["nMM,M|}
-a%j*2jHzVvg&lJu$i5iZumH<953rj2R5Sj4	s-xC22XrZlZ`y6:W>Ju+}z]ewcuGVrm#s:p6$\U^|sv9VbuH.A|	ku&3		S2
-JJf,t0fmEZ7kS=kJ"YazMzF@	.cJRYEoqj1U@O=v?KvU_$meGs
-wg,~CrsOCa+P;Mdq
-
-E %TRO V\T(	DN*POI$1Z=-ZxSZryo~ Zss}T4f1(;e2Xy"O$X,P(`l
-5^%X`thQ([)ffu^oO!\P.=c'}ldw3'd;g-k[ugH:
-?~E)KY$hh:P?`{Q$sn=,2Ej"A}COH"jVhcD>Tbp6L!5Gng46ixIexCHSjx*lL[5i#a0p
-t:H6mp=_2]FbwOFHsU;
-
-Y"'gqH]sC7p9X^pQ5sc?pQ2pQ[1G99]\Y1G#94s$4sT<Ob S941_s|
-q|*q9x&v&x64sq;9K823f2pk'6o
-N%x\o/~BPpW{2CBJ/GCIq$EZ(@rU}sPaZ+_kz _nlu8sxka={,V-Hu  Vs`GxuJiL>RGn$-bpxu	VlWs:(LZlRE&~)pzzZxKz%q~>m[A&znIG97?"!ZInn^Yd6%2]%20Z>dn0V>-
-MW],CfkV2b\kB50^/h8JD
-{USxYEX?h_,ehb|vM[T{Lxzqukj9UpM@6eafO;Iusg;O/lGoJ?e+:$CgST=XxeC[jss/n7x(pNMGT
-lCz,!K1{xmKvxufVe:J^uJSwh.{L6/H5lQ1c}<VyA{ieW9x. 3Q P3^aWLO67!c1|R	VlYm.;A#^-)AjM}F|F]l<39.>;NglSy~4TOsTnh{KQg"6kgiWn~Edbg@tRk{zPbEL e|[
-'ju~M2T)D>*;)&gPihgf_sv\(Sg.E>Yur.i?le'I7{]?4P;I VqjGwQXDU*V'*c9=GTo='j99qHvl4 ?]BOqQ<2&Q>_d)6o3~Tw-	98*of{K5o0U0Z  &vcsD/~?l)=S\${>_Y.5Aa`Vo_Q~\7fv6R]_
-J@oWno1(i?TWWJ3[N7	\'9w6xdVVK~*~[rKAd]*MjkVKr%^sN$)R_pnmW.o(en[ZP7a?(d #u+wo\'=^"B./;CpnA^TQ~(|_Aff'5[An'"!`#euAN;)~nBOQn+xQ;rW>eb$Xqsw+~g	v^6?K.J
-g%/K}`Nd}>TPn7@g<Jv7m+)T!'EQ"::A
-=i
-`xy#WQtAOd*~e }htAw	f>]b``lp=} [
-O`/g`@C\iy}]U+UM+[ek[W$$0AG[;
-5(zClU#,8xb~q#WVR.sX.pep1:X9)8E8],^ajzBAfzqGMp83
-9bVmv/$waufc^O-KtsFW[+wwYM`U\~[1q3P	"<PC]}AYj=Xh?7(Eh"=k[H	p5x9_3\P_7ne@=sa&<h?X3d&h^z`-cXZ7fIUsf=;!a]3g3oUsk$~Fy|WU/WA7+ckAK"{h
-GG\|>\|W__|W__|W__|+Iq_hs(	_"WX e%L/vH<  _xoy!ZO,8Em*-{!9xA8p8;:FwCYn.P5j\eUSKT3*OL<V)d	[B4B @Fq
-m
-"
-cjHJze]"f'zJW#E{xKkI }G#Fxm=T ,A(i=&k`2|	oako[obF@HUMa+4\!YyY9J3,(}d7_7
-^EG5^0#D5\yE`6a5A5m.L,K/W`<Hpp	{8?;Pa3KV!lAGns
-y7r<hfkLb'Qm8d;c[c]1@5[cmUb\j+ Fi 4Q >m))*1S$$aw.^DIN$\@~Tc(qpM$ a	p!	K1J-#wih#j?q(9I2~%[w)}>ixA1A`=B_aa1Q=r@6
-%[A8FL|V3x_[1o. Z@ :!#>JR}R .FtLZgQi.(HHod<`_9JGH*[uyG)?i4*!CWo2bl#g=_m~y'1d![Nlf^k`5wy$y59d&UZuU(55V*ln3L5fMTc1h48u4zag?7N/V3H2LisR9.)iu$YHF34-TG*{sq@[(2<@H[X?s}I5Mh:>OmnmxzG!f=LB46&f]Gaa1KZF7tt4$g33@2||E
-Y|		P8Hpad'	dIy/B"9aYY \,$gXn5	d'_I9I9<QFNky+;agi[gzYtX /xlza66ot(#rCeUMuS\	t-t^tU1]UL22xn6j&%bvY:f|y.d;$!I. :6{MkS;Z	`!nt7AR0}p1AHIksdR;K-)q4zL%#!h-!Ac<?!'G/uBQ>.C;	dpA)7iqj
-bpUM
-endstream
-endobj
-12 0 obj
-8269
-endobj
-2 0 obj
-<<
-/S /Transparency
-/CS /DeviceRGB
-/I true
->>endobj
-3 0 obj <<
-/XObject << /Im1 1 0 R >>
-/ProcSet [ /PDF ]
->> endobj
-6 0 obj <<
-/Type /Pages
-/Count 1
-/Kids [4 0 R]
->> endobj
-13 0 obj <<
-/Type /Catalog
-/Pages 6 0 R
->> endobj
-14 0 obj <<
-/Producer (pdfTeX-1.40.9)
-/Creator (TeX)
-/CreationDate (D:20100921012446+02'00')
-/ModDate (D:20100921012446+02'00')
-/Trapped /False
-/PTEX.Fullbanner (This is pdfTeX, Version 3.1415926-1.40.9-2.2 (Web2C 7.5.7) kpathsea version 3.5.7)
->> endobj
-xref
-0 15
-0000000000 65535 f 
-0000000250 00000 n 
-0000011172 00000 n 
-0000011232 00000 n 
-0000000133 00000 n 
-0000000016 00000 n 
-0000011297 00000 n 
-0000001857 00000 n 
-0000002118 00000 n 
-0000002288 00000 n 
-0000002484 00000 n 
-0000002791 00000 n 
-0000011151 00000 n 
-0000011354 00000 n 
-0000011404 00000 n 
-trailer
-<< /Size 15
-/Root 13 0 R
-/Info 14 0 R
-/ID [<5E864FB09E46AD0EF63FFAC3E7546AD8> <5E864FB09E46AD0EF63FFAC3E7546AD8>] >>
-startxref
-11659
-%%EOF
diff -uraN linux-3.0.8/Documentation/DocBook/v4l/crop.pdf linux-3.0.8-fh8632-V1.0_20180330/Documentation/DocBook/v4l/crop.pdf
--- linux-3.0.8/Documentation/DocBook/v4l/crop.pdf	2021-07-14 21:51:58.103119787 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/Documentation/DocBook/v4l/crop.pdf	1970-01-01 03:00:00.000000000 +0300
@@ -1,112 +0,0 @@
-%PDF-1.3
-%
-6 0 obj
-<</Length 7 0 R/Filter /FlateDecode>>
-stream
-xI7W1`k3d#20C"rUZO(h$k?o\nqmE?l'v%l'3-g8}br)ud=rYJVk0)F3)dsQfwMH7O'Z/)MS=k!TPo_gI:w+#imEJe+ J4#(8__.`G01Q^B}a8qjbIsEu:MXYN|oKllKd{:+KB4BYP~+X#K%CB+rz??m*p/B^Yx>TK1 	\f1!q^KJfKa	'0f4a	l+aX,!HtA't@A`$$& 1zuGgQ8Ik:IEP+I,S}I%i $PM&Cy~9C!98n,bh.Fy:-I"!)<Lcq	@Xd$R\Ye'0MGkt.^nMhk0aX+Lpa9Hy#F#YHi#	BJ"5@"'om\5"D-rLq\bofG4Z2.9$}IvL2`1G$cIWb1U$c*I5	4+dIIsbsK'|@_^)dA3&NL}VPJfX>/81Y8ZU.	e;q`X>#dLAdl_($xo5 h&Yk&1U<lf+%`)$cnE-j9'9/8/o9{39;{9[{\Zd<:6m_,`iO-|j$8M:<$iCNs0P<z3V<2ZyikyqqoA3Qpfm9I<i[CyEqqULny\pYs\8D[2oPi]G 9[KYl<yd'Qsdm9iN3J3K.LC-[f<?h^Yd3K^#W$cG)(u3
-$lj&)+L>.v?5P	[SY](vc5^{ f|vw}]EmL	c(yacLD6-:6K2}}v/JMj HeYA(V>|8DU7Lckh_v[j'?>by<n7/5kn7ccdO_n}w>}{jbW^4h]o<^jn`tW][M`xw/p/endstream
-endobj
-7 0 obj
-1830
-endobj
-5 0 obj
-<</Type/Page/MediaBox [0 0 411.78 189.51]
-/Parent 3 0 R
-/Resources<</ProcSet[/PDF /Text]
-/ExtGState 11 0 R
-/Font 12 0 R
->>
-/Contents 6 0 R
->>
-endobj
-3 0 obj
-<< /Type /Pages /Kids [
-5 0 R
-] /Count 1
->>
-endobj
-1 0 obj
-<</Type /Catalog /Pages 3 0 R
->>
-endobj
-4 0 obj
-<</Type/ExtGState/Name/R4/TR/Identity/OPM 1/SM 0.02>>
-endobj
-11 0 obj
-<</R4
-4 0 R>>
-endobj
-12 0 obj
-<</R10
-10 0 R>>
-endobj
-9 0 obj
-<</Type/FontDescriptor/FontName/BXVUOF+Helvetica/FontBBox[-174 -285 1028 953]/Flags 32
-/Ascent 953
-/CapHeight 741
-/Descent -285
-/ItalicAngle 0
-/StemV 104
-/MissingWidth 278
-/XHeight 539
-/CharSet(/period/two/four/underscore/a/b/c/d/e/f/l/m/n/o/p/r/s/t/u/v)
-/FontFile3 8 0 R>>
-endobj
-8 0 obj
-<</Subtype/Type1C/Filter/FlateDecode/Length 13 0 R>>stream
-x]TPSW!*A^&1
-@KI2]->%	)(Zm`tU"R(v-e]L	PBvw'	[gs}GDP"hF$\"><1Vg$lLH |1CJ,>[h)++Qgf,[USPsda5-&$JK\c%XzoYh(P-B"86Djy'rJi:sBH5uE/)eQ~[T\Rj5L9+GPJMm*PiT:AeRYTX8xKNPN>|}}#;?MmHI$u\
-&~qr{ANZKP0;7T[d#wYIKC%~r?x6m
-x~(%$zT`fS#643 9{=GuR>Dun1xIKFBwx6O]|{8m	J<
-&kqxsG87|9W~}6FG3_JoA
-{yG`TNaw!hgAO^>XN-Hs(OF?|:2-)#S8!1GYpTGxa8%0eF.M@h;?9IU+=|=C}YS**.h'Bp +]bQAcJ#!hr*liz=.!mg0LU#05>EB8v690
-r
-fdT)_M7#ohk{oljU>lbWG=_s[397[/jNx	KSX	r5(/RkQWM]2UFl{'	)$X]plpHN+"&DOGm*)?4U.EIV8B4Yc!Nvsiq}BXW7O+k}AqM;dLY]F'b-Y`"c66Ag}]w#xCqWBpyQ	I4hyNX`^O,'JyLd{?^1$sowU1?ft7wt4(mywZ1%+o;b\A|g"=71\kkMi(H@5O,-F#(#^6M!m_pb;=O6	OaZEBX8='?mr[knm]9tZ
-*c~RL{mm<46D*#b%#|:@`'U:_\DCHp#-luT9M:1u
-endstream
-endobj
-13 0 obj
-1690
-endobj
-10 0 obj
-<</Subtype/Type1/BaseFont/BXVUOF+Helvetica/Type/Font/Name/R10/FontDescriptor 9 0 R/FirstChar 32/LastChar 251/Widths[
-278 278 355 556 556 889 667 221 333 333 389 584 278 333 278 278
-556 556 556 556 556 556 556 556 556 556 278 278 584 584 584 556
-1015 667 667 722 722 667 611 778 722 278 500 667 556 833 722 778
-667 778 722 667 611 722 667 944 667 667 611 278 278 278 469 556
-222 556 556 500 556 556 278 556 556 222 222 500 222 833 556 556
-556 556 333 500 278 556 500 722 500 500 500 334 260 334 584 278
-278 278 278 278 278 278 278 278 278 278 278 278 278 278 278 278
-278 278 278 278 278 278 278 278 278 278 278 278 278 278 278 278
-278 333 556 556 167 556 556 556 556 191 333 556 333 333 500 500
-278 556 556 556 278 278 537 350 222 333 333 556 1000 1000 278 611
-278 333 333 333 333 333 333 333 333 278 333 333 278 333 333 333
-1000 278 278 278 278 278 278 278 278 278 278 278 278 278 278 278
-278 1000 278 370 278 278 278 278 556 778 1000 365 278 278 278 278
-278 889 278 278 278 278 278 278 222 611 944 611]
->>
-endobj
-2 0 obj
-<</Producer(GNU Ghostscript 7.05)>>endobj
-xref
-0 14
-0000000000 65535 f 
-0000002151 00000 n 
-0000005438 00000 n 
-0000002092 00000 n 
-0000002199 00000 n 
-0000001935 00000 n 
-0000000015 00000 n 
-0000001915 00000 n 
-0000002619 00000 n 
-0000002330 00000 n 
-0000004415 00000 n 
-0000002268 00000 n 
-0000002298 00000 n 
-0000004394 00000 n 
-trailer
-<< /Size 14 /Root 1 0 R /Info 2 0 R
->>
-startxref
-5488
-%%EOF
diff -uraN linux-3.0.8/Documentation/DocBook/v4l/fieldseq_bt.pdf linux-3.0.8-fh8632-V1.0_20180330/Documentation/DocBook/v4l/fieldseq_bt.pdf
--- linux-3.0.8/Documentation/DocBook/v4l/fieldseq_bt.pdf	2021-07-14 21:51:58.103119787 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/Documentation/DocBook/v4l/fieldseq_bt.pdf	1970-01-01 03:00:00.000000000 +0300
@@ -1,150 +0,0 @@
-%PDF-1.4
-%
-5 0 obj
-<</Length 6 0 R/Filter /FlateDecode>>
-stream
-xoAE9ZpHpbZVVsfw9*P^^roWWtW|1n4&7EFKI+&)PW%tbkba4sCs}{*9[c[GMx\}*Su8o8n?1&2!jA`(!-%W
-0",C
-Ph\J6EGztG}!U112!+/wq3t'a|x\2\C$T7zTCc.@C7:MCq\6@Cmhj&DZBtYU	,^ZioZTMiow&Z<2PJB&B!3
-!"9!|.lB9L~kqkjh0X^!`@(d^@4bz0LVKFj0_4{:ih0,g!3@={d!{j-(?"diX!bcEC+B!2V4BlhhwlCBod j@X4M/P hP
-zHJA)\AAR6=Ik+5ijjC#F!04bB!bg4gZ.4g!3@={d!{*:.-)5`B!4&	8W2a`)`r+6BlC'niih)'a`
-4**x+*eVP@d@00RHyjXyj^JWkhYI8:,c2Lb26B5rU 0ZaJ69LhC(4$LhCB*P4u[UJL)B$HJA1),gU6i_*z)4L,wIf!b!y0C49"!"!mn-!EC(D6hsD6Ki&)a&)a&)k 6>))L-eS Il
-I32)U+ =hR'2eRC E5B5O
-Ox%_C0akH5B,B!24&n!h4LC r!b9F0424!"cOCK<er_vo]vM[>MqM]uD\+Svu~j{)W
-~~	Kiz7sS2l-'[mQ#-_>t}]NW-;PZC/mP%B\A>y/foqE(pMdr3vdk2LUKw$Xi!P3TLhj*n&U!|TnWd`rHC!VE*dU`>f10bNZ4%HypuSk&Rea8	P *jPd5;ZZr$3w)qfRhoM-RkJ
-+m)~I:acT^_pwqWVly5!|BC~BkA8!- 4t[Ahhfh&Bx2L.4OHi):"DHC#Ah4::ogCmz6% ?il}`s.o?
-4@mpAZ>(@}i;TJqjxYaDs!JuRLeh~WC aG[m+A,f8{\O*^ybL{d^yPh"f<BCB!A!!!:uaf!b
-#!>b
-#!>b
-B!b
-"7HABW_)h)He)h)h)h)h2oa/o"a/o"x23>1C>vUGzH
-c"-fi;!bvHc"-fi;&^vH{cb-&i7Hs4B1s4t('l9z
-@V>Yb2B
-VHQR6Rp)|	WN@NU9[H6GFZIA@4),a*6);% %lRXwp?D@
-K_:{i}\m^=i0,}Gv!o}b}?^|l{y{}San\gu:~qO|O_3?4k	Z$]UJJ~;^{fr6:v_k7|si7o>}xss?>~|@B.lg9'V9kY<=qOs;o9&kSi7x{:v/nendstream
-endobj
-6 0 obj
-2873
-endobj
-4 0 obj
-<</Type/Page/MediaBox [0 0 565 604]
-/Parent 3 0 R
-/Resources<</ProcSet[/PDF /Text]
-/ExtGState 10 0 R
-/Font 11 0 R
->>
-/Contents 5 0 R
->>
-endobj
-3 0 obj
-<< /Type /Pages /Kids [
-4 0 R
-] /Count 1
->>
-endobj
-1 0 obj
-<</Type /Catalog /Pages 3 0 R
-/Metadata 13 0 R
->>
-endobj
-7 0 obj
-<</Type/ExtGState
-/OPM 1>>endobj
-10 0 obj
-<</R7
-7 0 R>>
-endobj
-11 0 obj
-<</R8
-8 0 R>>
-endobj
-8 0 obj
-<</BaseFont/VADRUT+Helvetica/FontDescriptor 9 0 R/Type/Font
-/FirstChar 32/LastChar 118/Widths[
-278 0 0 0 0 0 0 0 333 333 0 0 278 0 278 278
-0 0 556 0 556 0 0 0 0 0 278 0 0 0 0 0
-0 667 667 722 722 667 611 0 0 278 0 0 556 833 722 778
-667 778 722 667 611 0 667 0 0 0 0 0 0 0 0 556
-0 556 556 0 556 556 278 556 0 222 0 0 222 833 556 556
-556 0 333 500 278 556 500]
-/Encoding/WinAnsiEncoding/Subtype/Type1>>
-endobj
-9 0 obj
-<</Type/FontDescriptor/FontName/VADRUT+Helvetica/FontBBox[-22 -218 762 741]/Flags 4
-/Ascent 741
-/CapHeight 741
-/Descent -218
-/ItalicAngle 0
-/StemV 114
-/MissingWidth 278
-/CharSet(/A/B/C/D/E/F/I/L/M/N/O/P/Q/R/S/T/V/a/b/colon/comma/d/e/f/four/g/i/l/m/n/o/p/parenleft/parenright/period/r/s/slash/space/t/two/u/underscore/v)/FontFile3 12 0 R>>
-endobj
-12 0 obj
-<</Filter/FlateDecode
-/Subtype/Type1C/Length 2862>>stream
-x{TgA	Hy	XA<TE%@*WWXU/0ol'hm]+k%3g7Mh6IJKY6p&XQ$Q.'Q'_&2!&A5vqM{&:39gSBvM@fV~i6kmu5m26D%'d(r
- 0yaPvyrE.KOX"_9ek<E9SRA+eO-Qn{T05LES!;5ZLyP1TI-SR*fPT %FS<eLXQs(g#eDIC]@G%EF^FNW!3dhNF{.5/41FPj* UO".r!V)`EpxGtr16aab[0!Bj5oi]uCUk]3Y*E5=F
-]n5"!Acf8]g&\# k 6*2B6Rk) n*fmK9'J?a+}|d8? lb%C*e8oWNNF-sB9<lq Tp9:};/a<nKT;H@R	!8v>]"H25%A1gn^h.[fyF>S0TF'A!<ZF?^'t0XF<D49G%ZQ@|xv`O4,HCa
-E?d`zg
-V\QFzxdL{A,P5f.f_4#{
-0 -gp&F	q0Q40
-d@>1d%~l	L<iS&l#"n2j3xn-8IW0ELg\+-(-7=F\Pg"7\
-"J$l]fbgHpQ5`;3Nz/xp'!/Q	TtVZ@ )l<lR!ev8H1LTu)H=$ZOsJd0:Nr8oe;+
-f$}\HoJGT-H2xgz=`vl/r-#XX5k
-w;m*|wUwa'PSxNDaL0475s,.9}\m$f
-_Gv?Rrl	ndl6A`rV0gO/:VVgCj@%\w&sW/C(H/N.>`8/3+zx#3Ncf6cf{-6y]G_m(ipV	q
-&|)N\'8~:/mW<\	1N1m ''Qa@6*6I
-{PvEB`|%;zW%8cmy(*vyEyv|w%c$R:;'u:DTaGKG|Jk%Sb*NU[I=B0\Sw%@PA6FOsW$NOt0p*86I%Pa3@nz&<43C\}Sv|^!Jz	iC^$Z38h^.I'7am @hRZ(E_XSDCOo<:lnPb;"?Tm]}.I<	XF+!nt+'x]_p?}R
-]pkN)i!B(7Y w`=J#e3@cU4|IMgCJ	0/E4aK4D
-XJH`/|OG3,lY8cXN#y
-nUj8Ft.\R;~v#.epy)Y;p\'2ce,JZ[o82j)'|N)<,.}TZSW^wL{c2&Zd"q`*0NS8NfiHc)y0bozp9)D_j&/cnOJ[\~'lPp16^Z{5&X?}0e&"q}"Z"MO$P*^NxU{90sxf,Z+JjNPg|[}qO"<E;XRtbt3|L-qv^cK |5`rIS47i+&pdC@3!!=%`;%Ad&!S(!wVw,\rso0(hyQfBg#;u0L8&-as^+39B"LqC&&=GLR f4
-endstream
-endobj
-13 0 obj
-<</Type/Metadata
-/Subtype/XML/Length 1388>>stream
-<?xpacket begin='' id='W5M0MpCehiHzreSzNTczkc9d'?>
-<?adobe-xap-filters esc="CRLF"?>
-<x:xmpmeta xmlns:x='adobe:ns:meta/' x:xmptk='XMP toolkit 2.9.1-13, framework 1.6'>
-<rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#' xmlns:iX='http://ns.adobe.com/iX/1.0/'>
-<rdf:Description rdf:about='c12df38f-72ef-11e7-0000-2fd3d476d9f6' xmlns:pdf='http://ns.adobe.com/pdf/1.3/' pdf:Producer='GNU Ghostscript 8.56'/>
-<rdf:Description rdf:about='c12df38f-72ef-11e7-0000-2fd3d476d9f6' xmlns:xap='http://ns.adobe.com/xap/1.0/' xap:ModifyDate='2007-07-25T17:19:31Z' xap:CreateDate='2007-07-25T17:19:31Z'><xap:CreatorTool>fig2dev Version 3.2 Patchlevel 5-alpha7</xap:CreatorTool></rdf:Description>
-<rdf:Description rdf:about='c12df38f-72ef-11e7-0000-2fd3d476d9f6' xmlns:xapMM='http://ns.adobe.com/xap/1.0/mm/' xapMM:DocumentID='c12df38f-72ef-11e7-0000-2fd3d476d9f6'/>
-<rdf:Description rdf:about='c12df38f-72ef-11e7-0000-2fd3d476d9f6' xmlns:dc='http://purl.org/dc/elements/1.1/' dc:format='application/pdf'><dc:title><rdf:Alt><rdf:li xml:lang='x-default'>fieldseq_bt.fig</rdf:li></rdf:Alt></dc:title><dc:creator><rdf:Seq><rdf:li>michael@localhost \(\)</rdf:li></rdf:Seq></dc:creator></rdf:Description>
-</rdf:RDF>
-</x:xmpmeta>
-                                                                        
-                                                                        
-<?xpacket end='w'?>
-endstream
-endobj
-2 0 obj
-<</Producer(GNU Ghostscript 8.56)
-/CreationDate(D:20070725171931Z)
-/ModDate(D:20070725171931Z)
-/Title(fieldseq_bt.fig)
-/Creator(fig2dev Version 3.2 Patchlevel 5-alpha7)
-/Author(michael@localhost \(\))>>endobj
-xref
-0 14
-0000000000 65535 f 
-0000003188 00000 n 
-0000008535 00000 n 
-0000003129 00000 n 
-0000002978 00000 n 
-0000000015 00000 n 
-0000002958 00000 n 
-0000003253 00000 n 
-0000003354 00000 n 
-0000003769 00000 n 
-0000003294 00000 n 
-0000003324 00000 n 
-0000004123 00000 n 
-0000007070 00000 n 
-trailer
-<< /Size 14 /Root 1 0 R /Info 2 0 R
-/ID [<F400597AE915C24B8A26CFB871E66BBB><F400597AE915C24B8A26CFB871E66BBB>]
->>
-startxref
-8752
-%%EOF
diff -uraN linux-3.0.8/Documentation/DocBook/v4l/fieldseq_tb.pdf linux-3.0.8-fh8632-V1.0_20180330/Documentation/DocBook/v4l/fieldseq_tb.pdf
--- linux-3.0.8/Documentation/DocBook/v4l/fieldseq_tb.pdf	2021-07-14 21:51:58.107119799 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/Documentation/DocBook/v4l/fieldseq_tb.pdf	1970-01-01 03:00:00.000000000 +0300
@@ -1,151 +0,0 @@
-%PDF-1.4
-%
-5 0 obj
-<</Length 6 0 R/Filter /FlateDecode>>
-stream
-xQo+$Q"EoI.p7}Avq_j>@`./|in7}wCw/_o2!6S9:k5Cihkvwxfe)@S4"
-(dDQ9Q_}45
-mnbel5RR(3mVF@C(}!!#1<&@6<u%8i)=AMCwx| !c	c6=D!uCFd(}J&ph/[V)n"}Z>C z1Q1xcs
-BQ7\!>\!aCs=}Z[LxM!p!h#%-{XR-GF=$ZklGS>pH8M1.*($Z<az1ybB5w-s 3aQLuyCKE)6<aM="M=tC=*zHXeSl!bM=$ZDU6hUC"zHXeSAfPCD6CM=g:cm!C(z[sD%&[qm!b(z1wk5<~}!>TyDjyH=a!!0/zWPh)Abr>@uCh3`<sP%3yqh)OaQ!&CHF@CG",kX"<7CGC&.fn.K59ysO}2I~=w5yv)c/;!o4!Cv<|kS4>rux<ZZ_K1wkS}f7+="!}@H'{H'{H'{Eb?CF}!oUyD<"g>cCxkbyDjyH-5eP#="!jC R{>{>{J{h{!=xH[oL{EbCCbCCbC
-yr*7*D1sjc?)twPJ5VLF="1yDj!C R@fHMB~<LoYC(%@CHZEr5C(KZ@="!rHJxVK$+Sk$/HhT/[q[Z4*cBbE)S:^!XPY*fwC ]#AgbYtvshle<yDyjmG%G>Rq!8t#Ag8
-<AmVxo@'Scf\)P;!tN
-=VqjU20q@#8$)P*NlKAP\B[%UuJPX=>JXRp8*X*J
-1R*p=PKBE)TPQ
-TUB,
-@D!0Q
-m)TPQ
-TUBp@kt
-
-U[)T:PQ
-TU2~RX&atQ'S
-e8/
-eJa_B2Po`BRpF;/N)P9<n:UN)t8':R#U	
-Tx@8*<DU
-Ot,(K}<2H4"
-(ObfC(e9ZdD0IQXQ-4@rC!=HmxDjKCGb'CGbC(VZE2?yD*?yD*?yE"?yD*?yD*?yD*?yD*?yh#H@C(q!8TyD*<"G_8S9Ckr@rP$r@jaZCxkT-!(J`q!/fy4ys9w!uc
-=!OYg2NNpdD8y(N9JP$C8p"<"a2X1(V"<"HDQMMcuzh8_vh>4LRQi.Kqsi8r2ZX//_JRFVzq(eZe)S	Ai^y`5cc}_xo?~l_no<cTrn3%IOno_n_^|q=~q}}09^4~!GE_]gXPrqIGq.]s~-iU=\_g|zw~:=}{vwW_w^~>;mzrw|qrkw}se%c"`P?Vow:;oU0Utu_q0endstream
-endobj
-6 0 obj
-2760
-endobj
-4 0 obj
-<</Type/Page/MediaBox [0 0 566 600]
-/Parent 3 0 R
-/Resources<</ProcSet[/PDF /Text]
-/ExtGState 10 0 R
-/Font 11 0 R
->>
-/Contents 5 0 R
->>
-endobj
-3 0 obj
-<< /Type /Pages /Kids [
-4 0 R
-] /Count 1
->>
-endobj
-1 0 obj
-<</Type /Catalog /Pages 3 0 R
-/Metadata 13 0 R
->>
-endobj
-7 0 obj
-<</Type/ExtGState
-/OPM 1>>endobj
-10 0 obj
-<</R7
-7 0 R>>
-endobj
-11 0 obj
-<</R8
-8 0 R>>
-endobj
-8 0 obj
-<</BaseFont/SEXXTC+Helvetica/FontDescriptor 9 0 R/Type/Font
-/FirstChar 32/LastChar 118/Widths[
-278 0 0 0 0 0 0 0 333 333 0 0 278 0 278 278
-0 0 556 0 556 0 0 0 0 0 278 0 0 0 0 0
-0 667 667 722 722 667 611 778 0 278 0 0 556 833 722 778
-667 778 722 667 611 0 667 0 0 0 0 0 0 0 0 556
-0 556 556 0 556 556 278 556 0 222 0 0 222 833 556 556
-556 0 333 500 278 556 500]
-/Encoding/WinAnsiEncoding/Subtype/Type1>>
-endobj
-9 0 obj
-<</Type/FontDescriptor/FontName/SEXXTC+Helvetica/FontBBox[-22 -218 762 741]/Flags 4
-/Ascent 741
-/CapHeight 741
-/Descent -218
-/ItalicAngle 0
-/StemV 114
-/MissingWidth 278
-/CharSet(/A/B/C/D/E/F/G/I/L/M/N/O/P/Q/R/S/T/V/a/b/colon/comma/d/e/f/four/g/i/l/m/n/o/p/parenleft/parenright/period/r/s/slash/space/t/two/u/underscore/v)/FontFile3 12 0 R>>
-endobj
-12 0 obj
-<</Filter/FlateDecode
-/Subtype/Type1C/Length 2959>>stream
-xViTW> Q$ 
-(l* qbbL4n[4
-F06`78m(	yyf&9~Une~!&Vx$9Demc K@ dXgy)G;dde-KMv$>\\!:Q!!*95'=1O70kTU)RgO_,:gNhnz\OgQ&Gf&gf1A;f3GL03D3!'3x1Lx3s3`1H&11gXf ca2S7
-%cv4bwQ_$)tM0K0;,u^rk8>	rWrd'3cYY8[Z,"+\4^>K`A)(q9+;R&f
-2'$CXr`Rk)|$uXBOl[awV]p9wvaGem~(Vhf>B"t%ycMR"(u8Xj)M:Mz;Yw-h:t+P--w+da' 72NOB7)q)
-B^VnMY8=Wv#k\+X$^$(pn):V_'dlwFQ	4=[-O!@Npig@zL"A/?8]}M11OD'yG>+S$h</3zN:0)Z^K.*vo"hM:sD,Kjf3/!F_yUzxdDG @Ud)fZq Zg$*5iSa"MuQpS	0T,L(@")Bhe9X.dY{_ YlwTYp%2Lpgl@1BZqZv7xz|H/<$GF<Bj{wKABDd<%$:K
-!B~h}Cv[8A8HA!D(9N3Da
-NO]H$BVPDD;(l!TO5L;zQ.vc;:~OwEL(~us2}1qN{Q_~R%4"qU^:V
-0lb#qC`?N4wOr5^vPm"Pccqu846uvFpG?^'ShX'J%n'=Lkm?dcoDLi(-}4[q~Y`\~x&B(L^sLl+5+wuO8RTB9B7Hm{]y$qQ[=q9<2&xtV@L$6T	TN
-T	+JY+aJ[2bs%	*Mk/E)OKH>P+_wC[/
-^2v6ZI}XK+PjrVVf(@rRtbGZeA=H[Nm,\[j^9Q?\M*li{U7h$X,VscWb?5ti|-u+HE?s+IdG#RDi.i~$/t,,n.6PQ>HbU5mH]g
-m0.uW%
- EYmS:FmF2(;TFI1KDytyU#YKBW]NAQ()wiz*wY;z)h}RZ3$L.x<GEq>Mf:-<.'>)7f^n=-SP`;Dy&^z 3]\v.4t|g"BX[z^g2$06+A)6k,\E@gq~/6J`48GIy5`F+Z8Hq+7omECp "sSR+37oZ}p		O/g*rx.4nK8#ky
-dGWMya]`+E_:>"# XDk/d+tT8A3M~9CH9wri>hjOBMK<skTPb'MFV?-pK+(</ELqD0?sV0
-m>[+s|WbH+[;T5{<3iSg>~HxcS|aMoU%)Mt$'aA	{K%ZyWQg:	<'Pw~bpY$Yd@so!3F0e	x- ~^~N][Vm^(Bzu],7fVfGK6lVr4	,~BlDX.jPrMmM{--[` 6
-endstream
-endobj
-13 0 obj
-<</Type/Metadata
-/Subtype/XML/Length 1388>>stream
-<?xpacket begin='' id='W5M0MpCehiHzreSzNTczkc9d'?>
-<?adobe-xap-filters esc="CRLF"?>
-<x:xmpmeta xmlns:x='adobe:ns:meta/' x:xmptk='XMP toolkit 2.9.1-13, framework 1.6'>
-<rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#' xmlns:iX='http://ns.adobe.com/iX/1.0/'>
-<rdf:Description rdf:about='b1aeaa8f-72ef-11e7-0000-51c8be12fc20' xmlns:pdf='http://ns.adobe.com/pdf/1.3/' pdf:Producer='GNU Ghostscript 8.56'/>
-<rdf:Description rdf:about='b1aeaa8f-72ef-11e7-0000-51c8be12fc20' xmlns:xap='http://ns.adobe.com/xap/1.0/' xap:ModifyDate='2007-07-25T17:19:05Z' xap:CreateDate='2007-07-25T17:19:05Z'><xap:CreatorTool>fig2dev Version 3.2 Patchlevel 5-alpha7</xap:CreatorTool></rdf:Description>
-<rdf:Description rdf:about='b1aeaa8f-72ef-11e7-0000-51c8be12fc20' xmlns:xapMM='http://ns.adobe.com/xap/1.0/mm/' xapMM:DocumentID='b1aeaa8f-72ef-11e7-0000-51c8be12fc20'/>
-<rdf:Description rdf:about='b1aeaa8f-72ef-11e7-0000-51c8be12fc20' xmlns:dc='http://purl.org/dc/elements/1.1/' dc:format='application/pdf'><dc:title><rdf:Alt><rdf:li xml:lang='x-default'>fieldseq_tb.fig</rdf:li></rdf:Alt></dc:title><dc:creator><rdf:Seq><rdf:li>michael@localhost \(\)</rdf:li></rdf:Seq></dc:creator></rdf:Description>
-</rdf:RDF>
-</x:xmpmeta>
-                                                                        
-                                                                        
-<?xpacket end='w'?>
-endstream
-endobj
-2 0 obj
-<</Producer(GNU Ghostscript 8.56)
-/CreationDate(D:20070725171905Z)
-/ModDate(D:20070725171905Z)
-/Title(fieldseq_tb.fig)
-/Creator(fig2dev Version 3.2 Patchlevel 5-alpha7)
-/Author(michael@localhost \(\))>>endobj
-xref
-0 14
-0000000000 65535 f 
-0000003075 00000 n 
-0000008523 00000 n 
-0000003016 00000 n 
-0000002865 00000 n 
-0000000015 00000 n 
-0000002845 00000 n 
-0000003140 00000 n 
-0000003241 00000 n 
-0000003658 00000 n 
-0000003181 00000 n 
-0000003211 00000 n 
-0000004014 00000 n 
-0000007058 00000 n 
-trailer
-<< /Size 14 /Root 1 0 R /Info 2 0 R
-/ID [<9348BD7CCE2B07175ADFEF4DF463CEA4><9348BD7CCE2B07175ADFEF4DF463CEA4>]
->>
-startxref
-8740
-%%EOF
diff -uraN linux-3.0.8/Documentation/DocBook/v4l/pipeline.pdf linux-3.0.8-fh8632-V1.0_20180330/Documentation/DocBook/v4l/pipeline.pdf
--- linux-3.0.8/Documentation/DocBook/v4l/pipeline.pdf	2021-07-14 21:51:58.111119811 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/Documentation/DocBook/v4l/pipeline.pdf	1970-01-01 03:00:00.000000000 +0300
@@ -1,220 +0,0 @@
-%PDF-1.4
-%
-
-5 0 obj <<
-/Length 37        
-/Filter /FlateDecode
->>
-stream
-x+2T0 BC]# 6TH5Tp
- f
-endstream
-endobj
-4 0 obj <<
-/Type /Page
-/Contents 5 0 R
-/Resources 3 0 R
-/MediaBox [0 0 617 285]
-/Parent 6 0 R
-/Group 2 0 R
->> endobj
-1 0 obj <<
-/Type /XObject
-/Subtype /Form
-/FormType 1
-/PTEX.FileName (./pipeline-hq.pdf)
-/PTEX.PageNumber 1
-/PTEX.InfoDict 7 0 R
-/BBox [0 0 842 595]
-/Group 2 0 R
-/Resources <<
-/Font << /F1 8 0 R>>
-/ProcSet [ /PDF /Text ]
->>
-/Length 2413
-/Filter /FlateDecode
->>
-stream
-xYMo$MM6 |s" #I1
-_SVK-VbWOr-^.qm)y2Y]r[vikQ.}^RV.R}:saU!}wmQJer[^|_sM7ZxXF~ju0x	{?nAhh{q5e~Yp-krNcw~n}//|cT,?Fm:[8k9mje}>pXkw1j-:>.n8BwTj`[
-(*q8_H{GR/;E,=x;qNFb58<To{XZv5_c/;?tr5+E_j{mC H%0W"0 `&AT_1iO%8k*5St/:(Q2}UhfvwE _>a`q7nFb59D60Y==	V~4J5(Er Ys6C%nUI:U8]~y@LCq\P$uvHdRlyPeg^Mi`Sj`$ 5wsw=$(gR>+L02A/60(VKMG*qj;U /b~KBDa_*9+HQ}OF~@YYrB$8I%cb0W8>40@t&[;sBuCtd*{X8L
-w%wgH#(fY+|U3_al8	B?51@U$eNa_l$HP(L|- Q'N~R8@b[sqBjK+u ? P*Q)CE~cXXn `t@( 0=d	[Q$5@THk*Q_-v:>+48?No\_pj1)c1L"	daU$nOS%GCxRS5j_3<s*mV>T:bCT8=\#>(RhR6U!SkAt1%c16!|mJ`f19qSZ{G5*,`dil2Kl" ^Kkc6w }RLQ !Jpu]&L;7
-;)RgQ6>	6+mc]KZHzm\@wHC+JhS/<SjohC\8JSJ;)NgG4h0yrJ/W2*(>rBu D0zy#jgX|)f+XOZ^*gIq	
-E'Z e	('*e3# OMo:>
-WVg&P[ lg$ p/1'J,9Yg&|%X*1wP#O, R'XCz3Y2`O4`	? ?+5MoST.	5<VQ	?b-|G4~G?_ZD\
-!7v^:8nVWf2P38aFM=
-NXX2awXQKo`/,GKB{xfT}X2/|2?a:(+N@y>/L@M0F'_1!B?e0XF
-
-W
-_zDGUmsz+.
-/C-bk
-X<%GgtX8Qn_Grn'(^3} wxEd7^SIIZyRxk:xV`5eDGU?}+R%C~R Ae2SQ
-+j_0_@Q~Vk"}j4Eesv]-T2
-endstream
-endobj
-7 0 obj
-<<
-/Author <feff004c0061007500720065006e0074002000500069006e00630068006100720074>
-/Creator <feff0044007200610077>
-/Producer <feff004f00700065006e004f00660066006900630065002e006f0072006700200033002e0032>
-/CreationDate (D:20100920165003+02'00')
->>
-endobj
-8 0 obj
-<<
-/Type /Font
-/Subtype /TrueType
-/BaseFont /BAAAAA+Arial-BoldMT
-/FirstChar 0
-/LastChar 26
-/Widths [ 750 722 610 556 333 610 389 610 556 610 556 556 666 556 556 277 777 333 277 556 556 556 556 556 556 556 556]
-/FontDescriptor 9 0 R
-/ToUnicode 10 0 R
->>
-endobj
-9 0 obj
-<<
-/Type /FontDescriptor
-/FontName /BAAAAA+Arial-BoldMT
-/Flags 4
-/FontBBox [ -627 -376 2032 1047]
-/ItalicAngle 0
-/Ascent 905
-/Descent -211
-/CapHeight 1047
-/StemV 80
-/FontFile2 11 0 R
->>
-endobj
-10 0 obj
-<<
-/Length 341
-/Filter /FlateDecode
->>
-stream
-x]Mn0FtqB	!$HYG= gRg{>8./I55+:TNOo\l=yoam,VG3\!_X}uw;$*
-a<5!br7+xU``tDy""kGl|(4I6"pJUx7-g;[3e*A~d%uz33Te`p=KWGdOq
-$+?d%_<+v9A<b?}h]v{0E7\
-endstream
-endobj
-11 0 obj
-<<
-/Length 12 0 R
-/Filter /FlateDecode
-/Length1 28364
->>
-stream
-xy|TE8^Uw:eH!, `ZIC."Qq &Ac\u|:qp\Fho|~v[:9Nm7hXQ!+yCX?bTvdm_~7!5hY2PYcf+44GS Ff1~y[gsUP@}V{`cru#;D(_	'VwuumTNerRhuzdN$Zmv%;Yy/JF(vjDCSB(+%^zga ;t+h,fhZy[OP0.oC/A1*AK~
-O?vRHexd~}Zu0\TcE~	t;:X44@|wb /@& 7Zn@``wQkI#W!{fZV>
-6:	%,)>3b3^{]`=_]-GYc5~?#+:vm^44Y~A/?hZ3`{A\` m/"`z
-t[t}-8	//DKZA-=(tF?C`?^2 +p'$9W?d7%!;r&tS4Do/A'DEH-";%3~>OvfE@vwo ^Tgi&.?_/YzM.sKV;!0k'=]G$w8yqiLn= Fy#|-	.-=*{VvF>W"NqWccEh$:O	z 'Yq&]q^/ ow{!8 @ $@zQ2y Ar|tn!w	w)kspfoqsorspj6>7{d~HlT[r"w+{*:6[*p28`}o! ++*`=OrN6	?$ u^!n(DIrG\<!>pzoFo+_"<V	|_GA\GF >`,}h(sFFga?: _G(73SQI?ra.C{aa|^i2j%%]QX$@GX'zxs? ^m]|3w@gBedede&!xV@l@976B`fA/F `o8q:	a~%Sz^?Q;	HaFAA1&WJ
-]Z`@CJWtlDq~`Q
-*]EBSp}N$t^R`c(e(Gy3tVy9iYtO[p$'9v5`6zVV)rr<MBri MD&F&K)PqJqhnnP"Uz|\_vPeo"ITohjh:7Pk  y`<b} 8=UJ2-UIn?7'+=#3?b1T+"
-6A7rFn1M>m%pYC&[m:eS{*{HBdti^7}0jPbrf#7"R+/-MWgu&0s NH$rV	w,T&eQpsh+ !ZT$80FNeT"Bp,$X,B^~\H(h0?"0z! m	H-EL/M]DQ6#d(  :m?;vS<"PlYhu}i==+h	&xAvH(lxrOK&I5&$,P%	#IlV>3npcv)B9i$vr10&I;>9i8KUC M8B=]UM9)R}gBJ@-7
-4 Qb	HG9VQJ,J' #Kg. 7~n7(C 0W6i4b9Rg8$&
-R2 ]A4QWkq]-:"
-tQ#88dvHHEZll\e$\\07 .6:R p2p a	HIa)E&{"8+zbII?c!]tp|?V~U""DFCE	+~NrNm[>3QJ~%NV&^FHxH-Rp6%u%$9lO/1riTv7hU!kF?bBhAtoZT8sF&_60qq~5wsc{w{Rzl!Dn{6sU
-K_tZe|n.['VQ+kZ[[-7(]UWkjiLov{Ft\-3v]6--HOsz-fx}}wgL;mnHv$G6{u8+-ANMxdu1	u:<3:]i&wiu<DO8Ql[02Rcb
-gr1W8	og0F5AJ)@x?:KcahkMqm"jgD_<25\UNo[N\9:Aas[E*&]V[2HhO)pPl&uY].98']`"6
-EJW#l|_Z~7w^|zGXdB?{M/zx5w`zeQ1TkRtH[
-Q^|;!
-~[Q>m
-yfi'y^aI\}k_V5t^|YBT3oOzy]VOjbE57x+	]_	H4l"p$";gMD6sJVhdEl\QgP"F4EVW#WA.b+,,-\eeE,F`)s`<,Fg.CtHO"8c0RgF4L\d_}EJ5kN{2Z/9U|6NI^Q]22@%$J%*Tk8MhxU<Orp:qqD7+;csH_G4ZmvJze\A2jA1-)jv
-|*Puxsy2o677f#bnO5l`?NFLp
-6%PvlVZH-7w@]8.g&MA#cY&^0gY>rEk~X[%V%?beRYi(S_K1):V"QH/pqBln.;jW%tZJa A->Zln|)K&O^v85B {MlE$G?N_Z0j]$.\	+d#ZOWG}LuL7T*-xP^M;$?|Q	tdCrR(M_OYL-cPoH~,jzsIOv3 P"3)B1idEP<HSY#l[rDwR;SwRP|-=!ne)x$l*A_6 
-3:
-IJQ1 0RlUe>46"hIO'"(i1"\l*5L.WMx`OGtC[<1.0LnxY}>q/Fm:fWZW(U}RunI%bb"R(qJELdWPj4f6Tjt)NI.>=6('2.]HR Zc%>VLF3ct@~}v:3Wn
-t\^=vEvg~pwec^/Ez$;{>>aK*Jwt5Z[k]RR*[HT=WU%zKg2;a?l-V\|1P3F<ig'4ztdf5UrYd7wgQ5(d6'v|Z^3by}UL9!^
-Ufl6Je#J#
-3LE.^#<;G<za<xZ\1cfzI~|=b/HE?-^p4r(^H%,o++VZw(kmN_);Z%b
- $KzI{O[6Z~tOSUUx=Miti{t{TjN&8gZcJ;|QZ,u%\uS(Mx;c<
->,5sU/b6llE4FX0OnGcfy$CjME+n)d4GR<q	a('@eRP;.:\f@>,
-tj;-*7SRH`&{C8HI 4=Z~EGi/)'9p[bgwoi$sw=/7H+-_c?+ j	@6f2W;N1cTO'JZmkCZls[e79XYUzv%SR/Gj1S(f@DCE1GABV(TI
-'=|gOgO ?K~_\pe "V~zOwO~D>/\^3b/\8cAwy;*KVS,K:%-H^[&LGbZ;w:w;$|)I+r5S>-#7'/Ok$)M9tzJH)L6WR )S")OSRrp\ 
-7=Htvz$'xVwab">E:]]ZdVZu&[:EleA(BzHs_vXf%9ynZ	'x?gt{Pk-R2$~la\7&41_rK~1*7>Eu54T^TUdpt.J.q(n5B9_s,>G,0NF"Qq2K$,@&/tR~:cT(oLgyMxOQ}&MmIJy*dIl2_wmm{ivQ`}j*Ij0!&s"tjC|5-33@xs\	omZH;{Kz]LR?N)Q(df3$[M-yNGcjT``z_G$46fXBb"]7<-
-yL)I4RwfXeWG^I^=ZZz'~KqtI2|+nkm{Cobs2x}6'&qgm?GY+_{~H/s>K c(/c*oJL"{UOAx~~qHHHY;%/q.+
-2HwrV/@K4!LOr}wR,X-)5!#`H0Z^)z\|L;A:aZzCsN#u<;2!\aB0d`@KyT44NfiS!DPRb'gg^ ifY]13
-9/Wo37;ohUF?q`~}Z,]Xe<xy%.vl7X(NSmq'*)6y7!:V3L#dPu^gV[WeFH 1-J.u.uf-T~"Z8~TL.cFHItA''bh'#,]h?s_&6S@Ffh1sGz0VYOylbcj2c%3n4N7l7N>W|pOYy[7=?z'n}=v#oI+alRnS>"{D[;	t{B?b:Ki4TR2-KhJ;d}{m3~`&@v+)?$Qm%6nMT:hqU}:T#vx2P$fDDK=uO\8N\9@cgB,< b1}I.Cf+',8pd7opj/{\~%kvk {v\y7lBh[/>~[qF'S*]R.~|Ug+"=_+TW.g+%xEznuPVY/SWDV/QS/Uazb8FI1Qk*Z#=8LQ`M/De!D%k4Rhn,2GJJ>$/R5`nqihLCx>?h9S:0a([|}[~~k]'= ^5_cwB|/Exx}GUcoT"NG9Whz[;{d{%2=0jz=A(i4n>A~m<nQC;sxc ?:;^d/b;^^3~<~z{c-e4";Rn|g+"D~Y_Z_78vU[w-tn4xa}Q:*[Lq{Gb_}hz17(DMhL7X7*([;V|r5/skN=uqN;#nlwJv$OEjHQr+Qb^%&dXYb!FjH#6:2	UD\_	clhO9ia6aVaA^	z@%Ic)xA{GoM6G~UK69wk-y5?yU'^K/_U_iuWoX{`+bjC/ZO\NV~Ztt^0Q"\5:sV7o8#Z6H!Furg!%ezlTR<NCLqv8ZOg0esRBA#Q\d*J@f5c{U:=3~_E%oQ;tCZgVji~yMF()K!2MP?%&9J7nbSC+\Uxx| #Mbs%s}y-YqA,UotQ4Y\@6yPWMP{s'IwTT\
-)E?Y${=C.wr)h+`=PD ;</]4-1b;ssdoWw*+WjTuJ>]fxIql'F>mFm	!?[8J	P6J8,Uep9wI=p%.	WC Zke$\.3\>a&0J8'y|	!25np9K6np%J0EU$p5	IMOxt/pw zg$ZvJ81\j#e]n@yd}p+	[b	b^"`_	qeu\(0c}u*`_$#`_kMXC~/`2k@9!<J1\KPAS
-J8znd.t2<<	gp']	y>fx"[a	0-VJ?m
-;}SO>0v	v?S<H830]e	o2<O%|`MpOv\\	I8?+'p?+{U%oe8KN}~h
-fzJ=jeb:%*o'>b`=9RdDNh MG.@VZ2Y22J7  Pgs|OSh	h%gBj:,x
-(le51&isU?qY`7ZmthB SFu$@QW=T8|Ysa =T}wvyL]@O(]j!{s;jI%i1 LzBSIH-*$aqu,P$_{Ty6T7KclHnqL YFJ##H.A[( fS<[xdcok;,iYa J`|fizOw44kHZi|?&(hI$vJ+	1^Vj6&}b<L&b$m@3zKu^Zt$}%H'< i;>d0[C`:lbVkc4]lqW2CEwF2L;mrs"|g}L-fqRnXL=$nu*{|M=MFxo;H mbqw0mu]?;XniZ3qGb>lyCl8Sa\cTS#lN@R`u0Yb>x31"}=P*(^E
-ZpT{1kG:?I\]'};&-3}-hq4CRZ6Jp"&f{KWOF9B3o":n?~^#5SFE:f1.j2P&[G{gm4X.Y$mH1MZ&ll9W<zD]L!)wl.H1%K#Ith)=%Wg?WYsj:');62['kwK5c2CjE2j^3jwl}O^,7CSt9_};561-g8?WOQ&9|1* Pb1D?Yj$=^Phh8M]5PwvtICBW[sPDt0ayg[/mv \x	mmp,l)w9i`w0oV8&<md*kec3|Ph		kBwpm'!+uk	!k`k]SBew/@0Pskg['jXjVaEgG8NezEPTh	ko@:;Bko{[fXTB=@ }t!P{,00~os
-}p+SC{gg8AA=m`G8f@z ;24{dn&6@0}{'Lh	S5Anu0u0l ol	vVlt
-kC}@huA]G]]APcGs&;D%7bm|jcKG8Vp)^*lo3#a' =f1j{`m`SsJPOW[NA;}=].HZ@pL;;hypva;[ma{5=tydAk,_X~aZhaEUBW-uVPM@PXAi<[-:2]~r6So=}wKp`_~@XRO 7\Mpzgu .H5l'&\d$|`a5eA=B#Obz!X'`>?
-XBOW9A+@(o%D}Etvwj`F'YcgmV:Ww;8*+i>\^{=l{iP/|JBhqkX`mO., I2'}/)pd*.&L[P\PRYRT"Q:T'_nFZcA)IY	^sh&[s?jC=Rw<4<L?~~~~~~~?!>Y\0^F9TmSC_vWqw%[yIo/u]9|S5OuyE/J}~3Z[jhO}5Rn;Oi&!/?{WX&:)>d'F{BqwP(Q"b4
-Nv
-G(2f$@C.B7'X?2Cqdh/+p\ wT S Z NP9apWe\"!WYQ!JY>>OPVva 8%*t	8$U*MC8 Oqj~X+^aGT{\Uq
-}KJtddwQ`yC"
-urG5@4~+mwV!*rY 
-n l 4  Hv=&>.y2q4x!YG8gM0:Uz*}Z}aS\B@^yfK'Q!TgOq\*D
-@ua
-9NC$oS	gU	&(9>#,O&`.9FE##T
-.9 z#  r!# @tVX/_B\bK<<KA0o |4O\dK  3%<y49L"Cz*BdHA!9x.$y<@!Z{]c0&?#\M,"3yh}Iul'E{!!
-%nHnE2PlXr3<t&=PD(!$R>k"h<.!x'z0j(lr-	Pr5k	C88GptGpt1.6{/MM	8	8	8GpGp1::cuQuC8D"p!28DGp Gp0( (`Q C 8 p!088a#08adFf^($pqqq8N2q8N_q`9,q`9,8c9,0Sf([PQQezPpD#pD#8"AA11c9n/?wiA	+1}5W^v3x%M>ec0\J<*1[!BY.(<E| %FfiAQxZ!8 y||ilID(t{nPgH1[qvIh:-|_Ogl\"bE:	Dwo<Lt'`9PvCJ	B(P2X[67iOB")
-=KRy2PfZ 2WUi~,(CS8xlu!W1< e*Sz	.uSlez)u6Lp:0CJr6*JI('B!7}q7XNt}{+ ^&v= .w)=$	ma,qu+ukrocSFbk=q-r\\>$qy\r]1DvDWTx[$ *>dlv9
-"MHQXfQWjjR)WJDJ9O<>I_$h$p5f|\mF5=#X3G5~~dfD[)Du6V?FM#7m!nqnPf/33VW$=X}*Q!/)H,_b #DOEUh;USYd( SG%x2t^`:7@!/u	 0N0h
-xVzG
-7x&46$.F6dId6'i\qK8%h||{s(
-BiZ\+M[)#`eOp`s~vOT@U7xNVMWymbl.UV~r]F*s26WU}]%,F>Q>2m&(^#Z
---]h_#.5sIG^&|4ZDoD/iY}n;
-UP^=;rM${yMd&^jC[x*UHl:} (E5dP> vv>'f(p#}CL2%<?#~J]HX)CK3sKhwCk7=Jws(Wa?"Pr
-x">l<	H8q;+^
-endstream
-endobj
-12 0 obj
-15128
-endobj
-2 0 obj
-<<
-/S /Transparency
-/CS /DeviceRGB
-/I true
->>endobj
-3 0 obj <<
-/XObject << /Im1 1 0 R >>
-/ProcSet [ /PDF ]
->> endobj
-6 0 obj <<
-/Type /Pages
-/Count 1
-/Kids [4 0 R]
->> endobj
-13 0 obj <<
-/Type /Catalog
-/Pages 6 0 R
->> endobj
-14 0 obj <<
-/Producer (pdfTeX-1.40.9)
-/Creator (TeX)
-/CreationDate (D:20100920165011+02'00')
-/ModDate (D:20100920165011+02'00')
-/Trapped /False
-/PTEX.Fullbanner (This is pdfTeX, Version 3.1415926-1.40.9-2.2 (Web2C 7.5.7) kpathsea version 3.5.7)
->> endobj
-xref
-0 15
-0000000000 65535 f 
-0000000249 00000 n 
-0000019332 00000 n 
-0000019392 00000 n 
-0000000132 00000 n 
-0000000016 00000 n 
-0000019457 00000 n 
-0000002947 00000 n 
-0000003208 00000 n 
-0000003476 00000 n 
-0000003677 00000 n 
-0000004091 00000 n 
-0000019310 00000 n 
-0000019514 00000 n 
-0000019564 00000 n 
-trailer
-<< /Size 15
-/Root 13 0 R
-/Info 14 0 R
-/ID [<0546033AF57A51BFE9A464749C091B3F> <0546033AF57A51BFE9A464749C091B3F>] >>
-startxref
-19819
-%%EOF
diff -uraN linux-3.0.8/Documentation/DocBook/v4l/vbi_525.pdf linux-3.0.8-fh8632-V1.0_20180330/Documentation/DocBook/v4l/vbi_525.pdf
--- linux-3.0.8/Documentation/DocBook/v4l/vbi_525.pdf	2021-07-14 21:51:58.119119833 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/Documentation/DocBook/v4l/vbi_525.pdf	1970-01-01 03:00:00.000000000 +0300
@@ -1,70 +0,0 @@
-%PDF-1.2
-%
-4 0 obj
-<</Length 5 0 R/Filter /FlateDecode>>
-stream
-x7)j/ y Mvq$6 yP:l^bv?%5t|Z?Vzgl{OS,cKK9{%JP<jC-Tv([PCylE7 p6~.
-r
-;4",G<f=qF<YhxG<m{xG<gG<-UnJ}}jD8^Ewc`+qhxI'}X=C#$9r\8|?A3,}~X`h LNAP3` LA0>f|KA\#0{L1'>3hlfPTC(N$=E '(!S)IEQRi(J8QE!PLI(C(NEQz	#eC2P0Is3[{of>Bq4:xO$a,Bmfh45(C@C@CyoA@nC#-[hm^B{x4P#^F]x#>ZXZb^T.l]^N0,i iuZx]3o[Yjzt0jB;s/VL(:rbEQt|P\VEQTbEQTbE(.L(*B(*Bv|fPmzf?,UbDeah?aMbDdfxAEfX;Ix!XO2
-o,Y|1Nz$tz688~|S9&
-K/MG6cJ!&D8.H~DW1.X ZHQa5`H\l]r'4zmJVx AN!F`+l &t]6)bS]C n1Q+"Ls63QHw.C#\BnS*lCEh;M
-:CWm6$MK2ddbc]dl}H&$I+UaySX^P*ltoTm<H
-
-IceQgPypn\Tp^d[V1Ph(.;U|xg`8e&LmL::A"	Knl5b-a6<y8u,2(6D{wW*PMz6Yw:V)=]KCUje-u,F	f))[;tyv3u+_e:I'IXY^u$,p{E<FDm-ZA;o|Rogm5}N]B-ojjRbDUB~wfw	`}VDFJy6Ce(0Z	6P_4}
-&CGs|
-]&CWK~A.}1LCG+^}6{-*{(h>~` dy(0v7
-`*,jm(h>~4p0;;}(Q}(|qEsE&_);RjWggGfI-vnVO-@N 'P&5HX55TtHDyS\LXb!QVdWFLS$I$]:gT![&-D!"A=\BB)ax/Q6^u/Q^^"FZHZ@JelU"[m$4m3=0kf5aosPuLQxROB
->|m#Ekyn|lgRpo#E>^n_M}<{bEy=<E:cEb+t^ed<:^?hyB!)L!Z:JJRl:Yq_Jn4ZViP&Iv;l<Y\T=
-N]JDz-h7\UrataF~Ys@vym|ItpK:U/s(U*fp],59rACQs8sb^pC[!BqT<^FWRx
-ny`T3E+Omp&t86}<|,3,endstream
-endobj
-5 0 obj
-2640
-endobj
-3 0 obj
-<<
-/Type /Page
-/MediaBox [0 0 595 842]
-/Parent 2 0 R
-/Resources << /ProcSet [/PDF /Text]
-/Font <<
-/R6 6 0 R
->>
->>
-/Contents 4 0 R
->>
-endobj
-6 0 obj
-<</Type/Font/Name/R6/Subtype/Type1/BaseFont/Helvetica>>
-endobj
-2 0 obj
-<< /Type /Pages /Kids [
-3 0 R
-] /Count 1
->>
-endobj
-1 0 obj
-<< /Type /Catalog /Pages 2 0 R
->>
-endobj
-7 0 obj
-<< /CreationDate (D:20051113052913)
-/Producer (GNU Ghostscript 5.10)
->>
-endobj
-xref
-0 8
-0000000000 65535 f 
-0000003023 00000 n 
-0000002964 00000 n 
-0000002745 00000 n 
-0000000015 00000 n 
-0000002725 00000 n 
-0000002893 00000 n 
-0000003072 00000 n 
-trailer
-<< /Size 8 /Root 1 0 R /Info 7 0 R
->>
-startxref
-3159
-%%EOF
diff -uraN linux-3.0.8/Documentation/DocBook/v4l/vbi_625.pdf linux-3.0.8-fh8632-V1.0_20180330/Documentation/DocBook/v4l/vbi_625.pdf
--- linux-3.0.8/Documentation/DocBook/v4l/vbi_625.pdf	2021-07-14 21:51:58.119119833 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/Documentation/DocBook/v4l/vbi_625.pdf	1970-01-01 03:00:00.000000000 +0300
@@ -1,77 +0,0 @@
-%PDF-1.2
-%
-4 0 obj
-<</Length 5 0 R/Filter /FlateDecode>>
-stream
-xZexK;@lsU%qt:}Hu*w?}<~{B/SL^f ob~i` @yz0a8KVRIJj	Q}XHTV$.:i]8b)vp6RBRK;)w[Iy'W#J#GB{G<G<G<uyxN[fP1;jkt5|?){cy
-cK\P'][99]f#K\.?jW s$&Q@9GV?(U@8Q@95?
-(@8 /~PNtnr-~
-*v \XDLZnD}I"aq*%aq2%aq:%$R88DYVa)bXXe	bXZe	b'TDPd|0d*tR2/Z	+Z	+wvbzw&a%U(+)~zXIy'cTvR?V`HwRnx=!{C9z&8,G<qZj7RG4\FDCW
-uAho}~{.!	G pc +#9
-(pP @8r1G&pP@8rd3G/'p\p!)+4\u;%7,N$V_Ynai'\YR)W$20,N,)+KAY|ai9_YR,)	e7.-Ke//k;g`'>j\:B 3Up%P>b2_y -C'h2KWK])5u~9
-j)?U?bz*]ZlRWz
-NWr8SU(0s;~%@VJ S8~)B58\E0! ~!?}A(UDgbzn6 4]zA9P<#RcDDdpvX-XwBE*^8YxiiD!ul
-J]MJ7|QKP'"FM jS\9B/Fr"bT5 6%'"F6w jK<BxMmM|IF8X0651T:n[m b wn$\jC 5av"bqk"9Bx)@XcRmgZ=J(JdgT
-RB)YD:P*)E~0+0K Ua3"3Bs?eGa
-C!a(ChSxSL!OW3d
-v$!.Hg3@	U3W$ZY9{:V;
-63!R;DjG?Fi3k2!uclHHn,c @@ZxCOpd@Ba*TB&$HD&L!PS4D@$Dz`)B$82:`)4Bf^`}d:o2
-|C	Pt^ d2md[m1RV$a)=
-aG7[yS%c(xm-\Kiy"+ZAxd8P6e`5.6<2?XlgW,"b["a?w3"1epEjG{(aAp0iPQk2Jh*Y]a`=uPtn#{zZuMMb)Cw"5"FKgF=^~75!j93#4l9Hlur:
-
-P?9cn@%+@DR+* FgFgaMgj}j4;Y
-9oXI#j|"9sn]g2cJfFY(tmkr^wyID.K~$J,Y^kq$72s%d~%'H07Z?8[X8<0CP`"%NzYnisErf<bhiP4MKShT(KAsGo
-)< kpF	j$I z	W?}<_31G~vdzc}|_^[sL?wq\aoO##~<Vqcli ycm\\@@ U Nu(K`&gd'O;__}Y
-.d>/g?9{vCoX;Op#~ 'w_!)U_.^.`IB|ARmnH
-LB8Ys'Tn>O}@?-9gV)W2myrjfA5.9sle	Wvendstream
-endobj
-5 0 obj
-2928
-endobj
-3 0 obj
-<<
-/Type /Page
-/MediaBox [0 0 595 842]
-/Parent 2 0 R
-/Resources << /ProcSet [/PDF /Text]
-/Font <<
-/R6 6 0 R
->>
->>
-/Contents 4 0 R
->>
-endobj
-6 0 obj
-<</Type/Font/Name/R6/Subtype/Type1/BaseFont/Helvetica>>
-endobj
-2 0 obj
-<< /Type /Pages /Kids [
-3 0 R
-] /Count 1
->>
-endobj
-1 0 obj
-<< /Type /Catalog /Pages 2 0 R
->>
-endobj
-7 0 obj
-<< /CreationDate (D:20051113052919)
-/Producer (GNU Ghostscript 5.10)
->>
-endobj
-xref
-0 8
-0000000000 65535 f 
-0000003311 00000 n 
-0000003252 00000 n 
-0000003033 00000 n 
-0000000015 00000 n 
-0000003013 00000 n 
-0000003181 00000 n 
-0000003360 00000 n 
-trailer
-<< /Size 8 /Root 1 0 R /Info 7 0 R
->>
-startxref
-3447
-%%EOF
diff -uraN linux-3.0.8/Documentation/DocBook/v4l/vbi_hsync.pdf linux-3.0.8-fh8632-V1.0_20180330/Documentation/DocBook/v4l/vbi_hsync.pdf
--- linux-3.0.8/Documentation/DocBook/v4l/vbi_hsync.pdf	2021-07-14 21:51:58.119119833 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/Documentation/DocBook/v4l/vbi_hsync.pdf	1970-01-01 03:00:00.000000000 +0300
@@ -1,162 +0,0 @@
-%PDF-1.3
-%
-6 0 obj
-<</Length 7 0 R/Filter /FlateDecode>>
-stream
-xVn0+xk[.K\RM86q,`p!&V:yl>}qnr:6k(vGMA#(dH'k"P&cCr"+w%sR"#r@KEN9i<y8KW_hof0wni8X!3``@z
-+'`W9s1`GXP4 V#d\|\n10y_KE
-!-zFQc$U' Y2}\;Gw`)q
-@PL\EID	RA0-.F2&\EC/vkO&w]Wf0q/{jcs'ag}=*DLZ8f"y-yz2Cr+U^)+! xh<EH#1ZOX"&gf7v,f'IL}9
-fM(Tq%A:ACA&+j$S.3"SPGP*e(isD
-~|$ .w06.3GWDX/X-}cpK(];i"odV*FM.V/vSp[7,6xVmsvz.A^]6g4.D `VV`5[bH!hv~upLh&KlHkN-{ej?3Yendstream
-endobj
-7 0 obj
-888
-endobj
-5 0 obj
-<</Type/Page/MediaBox [0 0 154.43 116.33]
-/Parent 3 0 R
-/Resources<</ProcSet[/PDF /Text]
-/ExtGState 15 0 R
-/Font 16 0 R
->>
-/Contents 6 0 R
->>
-endobj
-3 0 obj
-<< /Type /Pages /Kids [
-5 0 R
-] /Count 1
->>
-endobj
-1 0 obj
-<</Type /Catalog /Pages 3 0 R
->>
-endobj
-4 0 obj
-<</Type/ExtGState/Name/R4/TR/Identity/OPM 1/SM 0.02>>
-endobj
-12 0 obj
-<</Type/FontDescriptor/FontName/GLNMVZ+Helvetica-Bold/FontBBox[-173 -307 1176 949]/Flags 32
-/Ascent 949
-/CapHeight 741
-/Descent -307
-/ItalicAngle 0
-/StemV 150
-/MissingWidth 1000
-/XHeight 549
-/CharSet(/e/f/o/s/t)
-/FontFile3 11 0 R>>
-endobj
-11 0 obj
-<</Subtype/Type1C/Filter/FlateDecode/Length 14 0 R>>stream
-xUkHQ0,u;%-M:/Dyn[nN'&^0G8R!Zi
-Q/YK+0B#FDH,B9Z5K =X2{ "ewC;`Vuf0,<<@J5uU$uXX2'WD[&hw@k+JF192lOAI2HQGk346?nL@7Xd,!aT?DS*:Dv^Rv,he}}aeU+,voaa,;JR|}Zs`bA$-oN*?.bvqy _qzO?xIT_{U&e/|!m_	E}fox^,YIQ;@NO7'`Dx58:ebS1]?dQ<B&{^fVyC_[_W>@<}CLLER>:4zS:1xCn~&l:wVE-\XW|JZ+;yD ^^z!BE
-endstream
-endobj
-14 0 obj
-701
-endobj
-15 0 obj
-<</R4
-4 0 R>>
-endobj
-16 0 obj
-<</R10
-10 0 R/R13
-13 0 R>>
-endobj
-9 0 obj
-<</Type/FontDescriptor/FontName/PQWMGX+Helvetica/FontBBox[-174 -285 1028 953]/Flags 32
-/Ascent 953
-/CapHeight 741
-/Descent -285
-/ItalicAngle 0
-/StemV 104
-/MissingWidth 278
-/XHeight 539
-/CharSet(/space/period/B/L/S/W/a/b/c/e/g/h/i/k/l/n/p/r/s/t/u/v/y)
-/FontFile3 8 0 R>>
-endobj
-8 0 obj
-<</Subtype/Type1C/Filter/FlateDecode/Length 17 0 R>>stream
-xUPSgoN ^#**(*>xAG$IAZ~XWF
-FjkkAkDZS[=7~a_jNg9P(@zMJBJIiTe~(~U/DHc'7RBzyP6L93's-Z$K/|E40):Rk\"[NjU,K]62342GBVt&Y!!skJ&= KLd
-ZeV:MC|N2dUyuZzlESUT@VPT,xj>LP
-*SPJ@yQAT@(:J5p'`U}IeA:.oC}NvpaS#}4'9
-x_,o$KC>'tl4q'*)/`#cCrhCMu(qz5pIJ-w;[21j$w:}
-}KO[Z9btD#=0R.Y5-
-Xi=.:hOl}PG@a }=t|=?{`F,w6i_Q~<z4Tm<1C,sY(hD2Pf|}vO
-qqT@>s*3u#9Y~({gN1)Lr?
-kh/%C %R{Z 4jmNBe"{E%{W.xRRh.O`_W1z%7L&@#q)0F6bQ2|<R=`	k|_q NhR|~|_,~zjZ/XX^Co=e(	r3%%nvKN3 _8">\/BRE0L[o`/*=7Q'+AQy*Tdo6}8=9NIf<3A-`y![!X5 H;c8Z2aFj+]RoB6'3IvTXGW1]k`2b	:<g%F_Q+@v29n2#;46*/mT|kf;$p*&}~F f!Bn%j:jkt38YT6Kwh=)_sAAbC]f;o!cY2Om`08CFG `/%P.s$>K!]7eZ?iPi7FKQRMvg.>eU[,bY D+g[7u;Qbg`#~;s?T|*vGpiof8](F]#PW 3#g	7lEXyC-\ &&,
-q+0be=_9A[!L!JDf/4~@<d4cxEbB"1G4}ecw}>*/w"VA
-_118B-1>OaYliM1(TV\/gJz#aUloR]NU7b0x*bHo$jU'G>8Y3y	H; K[2\Q]B?H9,_[)K(,~^D, 	N(~!ML VhD?K]OI< =B3q@g7Qm?<zE{
-endstream
-endobj
-17 0 obj
-1951
-endobj
-10 0 obj
-<</Subtype/Type1/BaseFont/PQWMGX+Helvetica/Type/Font/Name/R10/FontDescriptor 9 0 R/FirstChar 32/LastChar 251/Widths[
-278 278 355 556 556 889 667 221 333 333 389 584 278 333 278 278
-556 556 556 556 556 556 556 556 556 556 278 278 584 584 584 556
-1015 667 667 722 722 667 611 778 722 278 500 667 556 833 722 778
-667 778 722 667 611 722 667 944 667 667 611 278 278 278 469 556
-222 556 556 500 556 556 278 556 556 222 222 500 222 833 556 556
-556 556 333 500 278 556 500 722 500 500 500 334 260 334 584 278
-278 278 278 278 278 278 278 278 278 278 278 278 278 278 278 278
-278 278 278 278 278 278 278 278 278 278 278 278 278 278 278 278
-278 333 556 556 167 556 556 556 556 191 333 556 333 333 500 500
-278 556 556 556 278 278 537 350 222 333 333 556 1000 1000 278 611
-278 333 333 333 333 333 333 333 333 278 333 333 278 333 333 333
-1000 278 278 278 278 278 278 278 278 278 278 278 278 278 278 278
-278 1000 278 370 278 278 278 278 556 778 1000 365 278 278 278 278
-278 889 278 278 278 278 278 278 222 611 944 611]
->>
-endobj
-13 0 obj
-<</Subtype/Type1/BaseFont/GLNMVZ+Helvetica-Bold/Type/Font/Name/R13/FontDescriptor 12 0 R/FirstChar 32/LastChar 251/Widths[
-278 333 474 556 556 889 722 278 333 333 389 584 278 333 278 278
-556 556 556 556 556 556 556 556 556 556 333 333 584 584 584 611
-975 722 722 722 722 667 611 778 722 278 556 722 611 833 722 778
-667 778 722 667 611 722 667 944 667 667 611 333 278 333 584 556
-278 556 611 556 611 556 333 611 611 278 278 556 278 889 611 611
-611 611 389 556 333 611 556 778 556 556 500 389 280 389 584 1000
-1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000
-1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000
-1000 333 556 556 167 556 556 556 556 238 500 556 333 333 611 611
-1000 556 556 556 278 1000 556 350 278 500 500 556 1000 1000 1000 611
-1000 333 333 333 333 333 333 333 333 1000 333 333 1000 333 333 333
-1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000
-1000 1000 1000 370 1000 1000 1000 1000 611 778 1000 365 1000 1000 1000 1000
-1000 889 1000 1000 1000 278 1000 1000 278 611 944 611]
->>
-endobj
-2 0 obj
-<</Producer(GNU Ghostscript 7.05)>>endobj
-xref
-0 18
-0000000000 65535 f 
-0000001208 00000 n 
-0000006917 00000 n 
-0000001149 00000 n 
-0000001256 00000 n 
-0000000992 00000 n 
-0000000015 00000 n 
-0000000973 00000 n 
-0000002738 00000 n 
-0000002453 00000 n 
-0000004795 00000 n 
-0000001573 00000 n 
-0000001325 00000 n 
-0000005818 00000 n 
-0000002360 00000 n 
-0000002380 00000 n 
-0000002410 00000 n 
-0000004774 00000 n 
-trailer
-<< /Size 18 /Root 1 0 R /Info 2 0 R
->>
-startxref
-6967
-%%EOF
diff -uraN linux-3.0.8/drivers/crypto/fh_aes.c linux-3.0.8-fh8632-V1.0_20180330/drivers/crypto/fh_aes.c
--- linux-3.0.8/drivers/crypto/fh_aes.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/crypto/fh_aes.c	2021-07-13 23:40:36.498373482 +0300
@@ -0,0 +1,1548 @@
+/*****************************************************************************
+ *  Include Section
+ *  add all #include here
+ *****************************************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/errno.h>
+#include <linux/in.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/skbuff.h>
+#include <linux/highmem.h>
+#include <linux/proc_fs.h>
+#include <linux/ctype.h>
+#include <linux/version.h>
+#include <linux/spinlock.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/bitops.h>
+#include <linux/io.h>
+#include <linux/irqreturn.h>
+#include <asm/irq.h>
+#include <asm/page.h>
+#include <crypto/hash.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/scatterlist.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <crypto/rng.h>
+#include "fh_aes.h"
+
+/*****************************************************************************
+ * Define section
+ * add all #define here
+ *****************************************************************************/
+
+#define CRYPTO_QUEUE_LEN    (1)
+#define CRYPTION_POS		(0)
+#define METHOD_POS			(1)
+#define EMODE_POS			(4)
+
+#define aes_readl(aes, name) \
+	__raw_readl(&(((struct fh_aes_reg *)aes->regs)->name))
+
+#define aes_writel(aes, name, val) \
+	__raw_writel((val), &(((struct fh_aes_reg *)aes->regs)->name))
+
+#define aes_readw(aes, name) \
+	__raw_readw(&(((struct fh_aes_reg *)aes->regs)->name))
+
+#define aes_writew(aes, name, val) \
+	__raw_writew((val), &(((struct fh_aes_reg *)aes->regs)->name))
+
+#define aes_readb(aes, name) \
+	__raw_readb(&(((struct fh_aes_reg *)aes->regs)->name))
+
+#define aes_writeb(aes, name, val) \
+	__raw_writeb((val), &(((struct fh_aes_reg *)aes->regs)->name))
+
+
+#ifdef CONFIG_FH_EFUSE
+#define FH_AESV2
+#else
+#undef FH_AESV2
+#endif
+
+#define FH_AES_ALLIGN_SIZE			64
+#define FH_AES_MALLOC_SIZE			4096
+#define FH_AES_CTL_MAX_PROCESS_SIZE		(FH_AES_MALLOC_SIZE - 1)
+
+#ifdef FH_AESV2
+#include   <../drivers/misc/fh_efuse.h>
+extern struct wrap_efuse_obj s_efuse_obj;
+#endif
+/****************************************************************************
+ * ADT section
+ * add definition of user defined Data Type that only be used in this file  here
+ ***************************************************************************/
+
+enum {
+	ENCRYPT = 0 << CRYPTION_POS,
+	DECRYPT = 1 << CRYPTION_POS,
+};
+
+enum {
+	ECB_MODE = 0 << EMODE_POS,
+	CBC_MODE = 1 << EMODE_POS,
+	CTR_MODE = 2 << EMODE_POS,
+	CFB_MODE = 4 << EMODE_POS,
+	OFB_MODE = 5 << EMODE_POS,
+};
+
+enum {
+	DES_METHOD = 0 << METHOD_POS,
+	TRIPLE_DES_METHOD = 1 << METHOD_POS,
+	AES_128_METHOD = 4 << METHOD_POS,
+	AES_192_METHOD = 5 << METHOD_POS,
+	AES_256_METHOD = 6 << METHOD_POS,
+};
+
+/*****************************************************************************
+
+ *  static fun;
+ *****************************************************************************/
+
+static int fh_aes_handle_req(struct fh_aes_dev *dev,
+			     struct ablkcipher_request *req);
+/*aes*/
+static int fh_aes_crypt(struct ablkcipher_request *req, unsigned long mode);
+static int fh_aes_ecb_encrypt(struct ablkcipher_request *req);
+static int fh_aes_ecb_decrypt(struct ablkcipher_request *req);
+static int fh_aes_cbc_encrypt(struct ablkcipher_request *req);
+static int fh_aes_cbc_decrypt(struct ablkcipher_request *req);
+static int fh_aes_ctr_encrypt(struct ablkcipher_request *req);
+static int fh_aes_ctr_decrypt(struct ablkcipher_request *req);
+static int fh_aes_ofb_encrypt(struct ablkcipher_request *req);
+static int fh_aes_ofb_decrypt(struct ablkcipher_request *req);
+static int fh_aes_cfb_encrypt(struct ablkcipher_request *req);
+static int fh_aes_cfb_decrypt(struct ablkcipher_request *req);
+
+/*des*/
+static int fh_des_ecb_encrypt(struct ablkcipher_request *req);
+static int fh_des_ecb_decrypt(struct ablkcipher_request *req);
+static int fh_des_cbc_encrypt(struct ablkcipher_request *req);
+static int fh_des_cbc_decrypt(struct ablkcipher_request *req);
+static int fh_des_ofb_encrypt(struct ablkcipher_request *req);
+static int fh_des_ofb_decrypt(struct ablkcipher_request *req);
+static int fh_des_cfb_encrypt(struct ablkcipher_request *req);
+static int fh_des_cfb_decrypt(struct ablkcipher_request *req);
+
+/*tri des*/
+static int fh_des_tri_ecb_encrypt(struct ablkcipher_request *req);
+static int fh_des_tri_ecb_decrypt(struct ablkcipher_request *req);
+static int fh_des_tri_cbc_encrypt(struct ablkcipher_request *req);
+static int fh_des_tri_cbc_decrypt(struct ablkcipher_request *req);
+static int fh_des_tri_ofb_encrypt(struct ablkcipher_request *req);
+static int fh_des_tri_ofb_decrypt(struct ablkcipher_request *req);
+static int fh_des_tri_cfb_encrypt(struct ablkcipher_request *req);
+static int fh_des_tri_cfb_decrypt(struct ablkcipher_request *req);
+static int fh_aes_setkey(struct crypto_ablkcipher *cipher, const uint8_t *key,
+			 unsigned int keylen);
+static int fh_aes_cra_init(struct crypto_tfm *tfm);
+static void fh_aes_tx(struct fh_aes_dev *dev);
+static void fh_aes_rx(struct fh_aes_dev *dev);
+static irqreturn_t fh_aes_interrupt(int irq, void *dev_id);
+static void aes_biglittle_swap(u8 *buf);
+static int fh_set_indata(struct fh_aes_dev *dev, struct scatterlist *sg);
+static int fh_set_outdata(struct fh_aes_dev *dev, struct scatterlist *sg);
+static void fh_set_aes_key_reg(struct fh_aes_dev *dev, uint8_t *key,
+			       uint8_t *iv, unsigned int keylen);
+static void fh_set_dma_indata(struct fh_aes_dev *dev,
+			      struct scatterlist *sg);
+static void fh_set_dma_outdata(struct fh_aes_dev *dev,
+			       struct scatterlist *sg);
+static void fh_unset_indata(struct fh_aes_dev *dev);
+static void fh_unset_outdata(struct fh_aes_dev *dev);
+static void fh_aes_complete(struct fh_aes_dev *dev, int err);
+static void fh_aes_crypt_start(struct fh_aes_dev *dev, unsigned long mode);
+static void fh_aes_tasklet_cb(unsigned long data);
+
+#define fh_des_setkey  fh_aes_setkey
+/*****************************************************************************
+ * Global variables section - Local
+ * define global variables(will be refered only in this file) here,
+ * static keyword should be used to limit scope of local variable to this file
+ * e.g.
+ *  static uint8_t ufoo;
+ *****************************************************************************/
+struct fh_aes_dev  *pobj_aes_dev = NULL;
+static struct crypto_alg algs[] = {
+	{
+		.cra_name		= "ecb(aes)",
+		.cra_driver_name	= "ecb-aes-fh",
+		.cra_priority		= 100,
+		.cra_flags		= CRYPTO_ALG_TYPE_ABLKCIPHER |
+					CRYPTO_ALG_ASYNC,
+		.cra_blocksize		= AES_BLOCK_SIZE,
+		.cra_ctxsize		= sizeof(struct fh_aes_ctx),
+		.cra_alignmask		= 0x0f,
+		.cra_type		= &crypto_ablkcipher_type,
+		.cra_module		= THIS_MODULE,
+		.cra_init		= fh_aes_cra_init,
+		.cra_u.ablkcipher = {
+			.min_keysize	= AES_MIN_KEY_SIZE,
+			.max_keysize	= AES_MAX_KEY_SIZE,
+			.setkey		= fh_aes_setkey,
+			.encrypt	= fh_aes_ecb_encrypt,
+			.decrypt	= fh_aes_ecb_decrypt,
+		}
+	},
+	{
+		.cra_name		= "cbc(aes)",
+		.cra_driver_name	= "cbc-aes-fh",
+		.cra_priority		= 100,
+		.cra_flags		= CRYPTO_ALG_TYPE_ABLKCIPHER |
+					CRYPTO_ALG_ASYNC,
+
+		.cra_blocksize		= AES_BLOCK_SIZE,
+		.cra_ctxsize		= sizeof(struct fh_aes_ctx),
+		.cra_alignmask		= 0x0f,
+		.cra_type		= &crypto_ablkcipher_type,
+		.cra_module		= THIS_MODULE,
+		.cra_init		= fh_aes_cra_init,
+		.cra_u.ablkcipher = {
+			.min_keysize	= AES_MIN_KEY_SIZE,
+			.max_keysize	= AES_MAX_KEY_SIZE,
+			.ivsize		= AES_BLOCK_SIZE,
+			.setkey		= fh_aes_setkey,
+			.encrypt	= fh_aes_cbc_encrypt,
+			.decrypt	= fh_aes_cbc_decrypt,
+		}
+	},
+	{
+		.cra_name		= "ctr(aes)",
+		.cra_driver_name	= "ctr-aes-fh",
+		.cra_priority		= 100,
+		.cra_flags		= CRYPTO_ALG_TYPE_ABLKCIPHER |
+					CRYPTO_ALG_ASYNC,
+		.cra_blocksize		= AES_BLOCK_SIZE,
+		.cra_ctxsize		= sizeof(struct fh_aes_ctx),
+		.cra_alignmask		= 0x0f,
+		.cra_type		= &crypto_ablkcipher_type,
+		.cra_module		= THIS_MODULE,
+		.cra_init		= fh_aes_cra_init,
+		.cra_u.ablkcipher = {
+			.min_keysize	= AES_MIN_KEY_SIZE,
+			.max_keysize	= AES_MAX_KEY_SIZE,
+			.ivsize		= AES_BLOCK_SIZE,
+			.setkey		= fh_aes_setkey,
+			.encrypt	= fh_aes_ctr_encrypt,
+			.decrypt	= fh_aes_ctr_decrypt,
+		}
+	},
+	{
+		.cra_name		= "ofb(aes)",
+		.cra_driver_name	= "ofb-aes-fh",
+		.cra_priority		= 100,
+		.cra_flags		= CRYPTO_ALG_TYPE_ABLKCIPHER |
+					CRYPTO_ALG_ASYNC,
+		.cra_blocksize		= AES_BLOCK_SIZE,
+		.cra_ctxsize		= sizeof(struct fh_aes_ctx),
+		.cra_alignmask		= 0x0f,
+		.cra_type		= &crypto_ablkcipher_type,
+		.cra_module		= THIS_MODULE,
+		.cra_init		= fh_aes_cra_init,
+		.cra_u.ablkcipher = {
+			.min_keysize	= AES_MIN_KEY_SIZE,
+			.max_keysize	= AES_MAX_KEY_SIZE,
+			.ivsize		= AES_BLOCK_SIZE,
+			.setkey		= fh_aes_setkey,
+			.encrypt	= fh_aes_ofb_encrypt,
+			.decrypt	= fh_aes_ofb_decrypt,
+		}
+	},
+	{
+		.cra_name		= "cfb(aes)",
+		.cra_driver_name	= "cfb-aes-fh",
+		.cra_priority		= 100,
+		.cra_flags		= CRYPTO_ALG_TYPE_ABLKCIPHER |
+					CRYPTO_ALG_ASYNC,
+		.cra_blocksize		= AES_BLOCK_SIZE,
+		.cra_ctxsize		= sizeof(struct fh_aes_ctx),
+		.cra_alignmask		= 0x0f,
+		.cra_type		= &crypto_ablkcipher_type,
+		.cra_module		= THIS_MODULE,
+		.cra_init		= fh_aes_cra_init,
+		.cra_u.ablkcipher = {
+			.min_keysize	= AES_MIN_KEY_SIZE,
+			.max_keysize	= AES_MAX_KEY_SIZE,
+			.ivsize		= AES_BLOCK_SIZE,
+			.setkey		= fh_aes_setkey,
+			.encrypt	= fh_aes_cfb_encrypt,
+			.decrypt	= fh_aes_cfb_decrypt,
+		}
+	},
+	{
+		.cra_name		= "ecb(des)",
+		.cra_driver_name	= "ecb-des-fh",
+		.cra_priority		= 100,
+		.cra_flags		= CRYPTO_ALG_TYPE_ABLKCIPHER |
+					CRYPTO_ALG_ASYNC,
+
+		.cra_blocksize		= DES_BLOCK_SIZE,
+		.cra_ctxsize		= sizeof(struct fh_aes_ctx),
+		.cra_alignmask		= 0x0f,
+		.cra_type		= &crypto_ablkcipher_type,
+		.cra_module		= THIS_MODULE,
+		.cra_init		= fh_aes_cra_init,
+		.cra_u.ablkcipher = {
+			.min_keysize	= DES_KEY_SIZE,
+			.max_keysize	= DES_KEY_SIZE,
+			.setkey		= fh_des_setkey,
+			.encrypt	= fh_des_ecb_encrypt,
+			.decrypt	= fh_des_ecb_decrypt,
+		}
+	},
+	{
+		.cra_name		= "cbc(des)",
+		.cra_driver_name	= "cbc-des-fh",
+		.cra_priority		= 100,
+		.cra_flags		= CRYPTO_ALG_TYPE_ABLKCIPHER |
+					CRYPTO_ALG_ASYNC,
+		.cra_blocksize		= DES_BLOCK_SIZE,
+		.cra_ctxsize		= sizeof(struct fh_aes_ctx),
+		.cra_alignmask		= 0x0f,
+		.cra_type		= &crypto_ablkcipher_type,
+		.cra_module		= THIS_MODULE,
+		.cra_init		= fh_aes_cra_init,
+		.cra_u.ablkcipher = {
+			.min_keysize	= DES_KEY_SIZE,
+			.max_keysize	= DES_KEY_SIZE,
+			.ivsize		= DES_BLOCK_SIZE,
+			.setkey		= fh_des_setkey,
+			.encrypt	= fh_des_cbc_encrypt,
+			.decrypt	= fh_des_cbc_decrypt,
+		}
+	},
+	{
+		.cra_name		= "ofb(des)",
+		.cra_driver_name	= "ofb-des-fh",
+		.cra_priority		= 100,
+		.cra_flags		= CRYPTO_ALG_TYPE_ABLKCIPHER |
+					CRYPTO_ALG_ASYNC,
+		.cra_blocksize		= DES_BLOCK_SIZE,
+		.cra_ctxsize		= sizeof(struct fh_aes_ctx),
+		.cra_alignmask		= 0x0f,
+		.cra_type		= &crypto_ablkcipher_type,
+		.cra_module		= THIS_MODULE,
+		.cra_init		= fh_aes_cra_init,
+		.cra_u.ablkcipher = {
+			.min_keysize	= DES_KEY_SIZE,
+			.max_keysize	= DES_KEY_SIZE,
+			.ivsize		= DES_BLOCK_SIZE,
+			.setkey		= fh_des_setkey,
+			.encrypt	= fh_des_ofb_encrypt,
+			.decrypt	= fh_des_ofb_decrypt,
+		}
+	},
+	{
+		.cra_name		= "cfb(des)",
+		.cra_driver_name	= "cfb-des-fh",
+		.cra_priority		= 100,
+		.cra_flags		= CRYPTO_ALG_TYPE_ABLKCIPHER |
+					CRYPTO_ALG_ASYNC,
+		.cra_blocksize		= DES_BLOCK_SIZE,
+		.cra_ctxsize		= sizeof(struct fh_aes_ctx),
+		.cra_alignmask		= 0x0f,
+		.cra_type		= &crypto_ablkcipher_type,
+		.cra_module		= THIS_MODULE,
+		.cra_init		= fh_aes_cra_init,
+		.cra_u.ablkcipher = {
+			.min_keysize	= DES_KEY_SIZE,
+			.max_keysize	= DES_KEY_SIZE,
+			.ivsize		= DES_BLOCK_SIZE,
+			.setkey		= fh_des_setkey,
+			.encrypt	= fh_des_cfb_encrypt,
+			.decrypt	= fh_des_cfb_decrypt,
+		}
+	},
+	{
+		.cra_name			= "ecb(des3)",
+		.cra_driver_name	= "ecb-des3-fh",
+		.cra_priority		= 100,
+		.cra_flags		= CRYPTO_ALG_TYPE_ABLKCIPHER |
+					CRYPTO_ALG_ASYNC,
+
+		.cra_blocksize		= DES3_EDE_BLOCK_SIZE,
+		.cra_ctxsize		= sizeof(struct fh_aes_ctx),
+		.cra_alignmask		= 0x0f,
+		.cra_type		= &crypto_ablkcipher_type,
+		.cra_module		= THIS_MODULE,
+		.cra_init		= fh_aes_cra_init,
+		.cra_u.ablkcipher = {
+			.min_keysize	= DES3_EDE_KEY_SIZE,
+			.max_keysize	= DES3_EDE_KEY_SIZE,
+			.setkey		= fh_des_setkey,
+			.encrypt	= fh_des_tri_ecb_encrypt,
+			.decrypt	= fh_des_tri_ecb_decrypt,
+		}
+	},
+	{
+		.cra_name			= "cbc(des3)",
+		.cra_driver_name	= "cbc-des3-fh",
+		.cra_priority		= 100,
+		.cra_flags		= CRYPTO_ALG_TYPE_ABLKCIPHER |
+					CRYPTO_ALG_ASYNC,
+		.cra_blocksize		= DES3_EDE_BLOCK_SIZE,
+		.cra_ctxsize		= sizeof(struct fh_aes_ctx),
+		.cra_alignmask		= 0x0f,
+		.cra_type		= &crypto_ablkcipher_type,
+		.cra_module		= THIS_MODULE,
+		.cra_init		= fh_aes_cra_init,
+		.cra_u.ablkcipher = {
+			.min_keysize	= DES3_EDE_KEY_SIZE,
+			.max_keysize	= DES3_EDE_KEY_SIZE,
+			.ivsize		= DES3_EDE_BLOCK_SIZE,
+			.setkey		= fh_des_setkey,
+			.encrypt	= fh_des_tri_cbc_encrypt,
+			.decrypt	= fh_des_tri_cbc_decrypt,
+		}
+	},
+	{
+		.cra_name			= "ofb(des3)",
+		.cra_driver_name	= "ofb-des3-fh",
+		.cra_priority		= 100,
+		.cra_flags		= CRYPTO_ALG_TYPE_ABLKCIPHER |
+					CRYPTO_ALG_ASYNC,
+		.cra_blocksize		= DES3_EDE_BLOCK_SIZE,
+		.cra_ctxsize		= sizeof(struct fh_aes_ctx),
+		.cra_alignmask		= 0x0f,
+		.cra_type		= &crypto_ablkcipher_type,
+		.cra_module		= THIS_MODULE,
+		.cra_init		= fh_aes_cra_init,
+		.cra_u.ablkcipher = {
+			.min_keysize	= DES3_EDE_KEY_SIZE,
+			.max_keysize	= DES3_EDE_KEY_SIZE,
+			.ivsize		= DES3_EDE_BLOCK_SIZE,
+			.setkey		= fh_des_setkey,
+			.encrypt	= fh_des_tri_ofb_encrypt,
+			.decrypt	= fh_des_tri_ofb_decrypt,
+		}
+	},
+	{
+		.cra_name			= "cfb(des3)",
+		.cra_driver_name	= "cfb-des3-fh",
+		.cra_priority		= 100,
+		.cra_flags		= CRYPTO_ALG_TYPE_ABLKCIPHER |
+					CRYPTO_ALG_ASYNC,
+		.cra_blocksize		= DES3_EDE_BLOCK_SIZE,
+		.cra_ctxsize		= sizeof(struct fh_aes_ctx),
+		.cra_alignmask		= 0x0f,
+		.cra_type		= &crypto_ablkcipher_type,
+		.cra_module		= THIS_MODULE,
+		.cra_init		= fh_aes_cra_init,
+		.cra_u.ablkcipher = {
+			.min_keysize	= DES3_EDE_KEY_SIZE,
+			.max_keysize	= DES3_EDE_KEY_SIZE,
+			.ivsize		= DES3_EDE_BLOCK_SIZE,
+			.setkey		= fh_des_setkey,
+			.encrypt	= fh_des_tri_cfb_encrypt,
+			.decrypt	= fh_des_tri_cfb_decrypt,
+		}
+	},
+};
+
+#ifdef CONFIG_FH_AES_SELF_TEST
+extern void fh_aes_self_test_all(void);
+#endif
+
+/* function body */
+static int fh_aes_handle_req(struct fh_aes_dev *dev,
+			     struct ablkcipher_request *req)
+{
+	unsigned long flags;
+	int err;
+	spin_lock_irqsave(&dev->lock, flags);
+	if (dev->busy) {
+		err = -EAGAIN;
+		spin_unlock_irqrestore(&dev->lock, flags);
+		goto exit;
+	}
+	dev->busy = true;	/*true :1 ;false :0.*/
+	err = ablkcipher_enqueue_request(&dev->queue, req);
+	spin_unlock_irqrestore(&dev->lock, flags);
+	tasklet_schedule(&dev->tasklet);
+exit:
+	return err;
+}
+
+static int fh_aes_crypt(struct ablkcipher_request *req, unsigned long mode)
+{
+	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(req);
+	struct fh_aes_ctx *ctx = crypto_ablkcipher_ctx(tfm);
+	struct fh_aes_reqctx *reqctx = ablkcipher_request_ctx(req);
+	struct fh_aes_dev *dev = ctx->dev;
+	AES_DBG("%s\n", __func__);
+	dev->reqctx = reqctx;
+	/*if (!(mode & CFB_MODE)) {*/
+		if ((!IS_ALIGNED(req->nbytes, AES_BLOCK_SIZE))
+		    && (!IS_ALIGNED(req->nbytes, DES_BLOCK_SIZE))) {
+			pr_err("request size is not exact amount of AES blocks\n");
+			return -EINVAL;
+		}
+	/*}*/
+	AES_DBG("reqctx->mode value: %x\n", (unsigned int_t)mode);
+	reqctx->mode = mode;
+	return fh_aes_handle_req(dev, req);
+}
+
+static int fh_aes_ecb_encrypt(struct ablkcipher_request *req)
+{
+	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(req);
+	struct fh_aes_ctx *ctx = crypto_ablkcipher_ctx(tfm);
+	u32 method = 0;
+	switch (ctx->keylen) {
+	case AES_KEYSIZE_128:
+		method = AES_128_METHOD;
+		break;
+	case AES_KEYSIZE_192:
+		method = AES_192_METHOD;
+		break;
+	case AES_KEYSIZE_256:
+		method = AES_256_METHOD;
+		break;
+	default:
+		break;
+	}
+	return fh_aes_crypt(req, method | ECB_MODE | ENCRYPT);
+}
+
+
+static int fh_aes_ecb_decrypt(struct ablkcipher_request *req)
+{
+	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(req);
+	struct fh_aes_ctx *ctx = crypto_ablkcipher_ctx(tfm);
+	u32 method = 0;
+
+	switch (ctx->keylen) {
+	case AES_KEYSIZE_128:
+		method = AES_128_METHOD;
+		break;
+	case AES_KEYSIZE_192:
+		method = AES_192_METHOD;
+		break;
+	case AES_KEYSIZE_256:
+		method = AES_256_METHOD;
+		break;
+	default:
+		break;
+	}
+	return fh_aes_crypt(req, method | ECB_MODE | DECRYPT);
+}
+
+static int fh_aes_cbc_encrypt(struct ablkcipher_request *req)
+{
+	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(req);
+	struct fh_aes_ctx *ctx = crypto_ablkcipher_ctx(tfm);
+	u32 method = 0;
+
+	switch (ctx->keylen) {
+	case AES_KEYSIZE_128:
+		method = AES_128_METHOD;
+		break;
+	case AES_KEYSIZE_192:
+		method = AES_192_METHOD;
+		break;
+	case AES_KEYSIZE_256:
+		method = AES_256_METHOD;
+		break;
+	default:
+		break;
+	}
+	return fh_aes_crypt(req, method | CBC_MODE | ENCRYPT);
+}
+
+static int fh_aes_cbc_decrypt(struct ablkcipher_request *req)
+{
+	struct crypto_ablkcipher *tfm;
+	struct fh_aes_ctx *ctx;
+	u32 method;
+
+	tfm = crypto_ablkcipher_reqtfm(req);
+	ctx = crypto_ablkcipher_ctx(tfm);
+	method = 0;
+	AES_DBG("%s\n", __func__);
+	switch (ctx->keylen) {
+	case AES_KEYSIZE_128:
+		method = AES_128_METHOD;
+		break;
+	case AES_KEYSIZE_192:
+		method = AES_192_METHOD;
+		break;
+	case AES_KEYSIZE_256:
+		method = AES_256_METHOD;
+		break;
+	default:
+		break;
+	}
+
+	return fh_aes_crypt(req, method | CBC_MODE | DECRYPT);
+}
+
+static int fh_aes_ctr_encrypt(struct ablkcipher_request *req)
+{
+	struct crypto_ablkcipher *tfm;
+	struct fh_aes_ctx *ctx;
+	u32 method;
+	tfm = crypto_ablkcipher_reqtfm(req);
+	ctx = crypto_ablkcipher_ctx(tfm);
+	method = 0;
+
+	switch (ctx->keylen) {
+	case AES_KEYSIZE_128:
+		method = AES_128_METHOD;
+		break;
+	case AES_KEYSIZE_192:
+		method = AES_192_METHOD;
+		break;
+	case AES_KEYSIZE_256:
+		method = AES_256_METHOD;
+		break;
+	default:
+		break;
+	}
+
+	return fh_aes_crypt(req, method | CTR_MODE | ENCRYPT);
+}
+
+static int fh_aes_ctr_decrypt(struct ablkcipher_request *req)
+{
+	struct crypto_ablkcipher *tfm;
+	struct fh_aes_ctx *ctx;
+	u32 method;
+
+	tfm = crypto_ablkcipher_reqtfm(req);
+	ctx = crypto_ablkcipher_ctx(tfm);
+	method = 0;
+	AES_DBG("%s\n", __func__);
+	switch (ctx->keylen) {
+	case AES_KEYSIZE_128:
+		method = AES_128_METHOD;
+		break;
+	case AES_KEYSIZE_192:
+		method = AES_192_METHOD;
+		break;
+	case AES_KEYSIZE_256:
+		method = AES_256_METHOD;
+		break;
+	default:
+		break;
+	}
+	return fh_aes_crypt(req, method | CTR_MODE | DECRYPT);
+}
+
+static int fh_aes_ofb_encrypt(struct ablkcipher_request *req)
+{
+	struct crypto_ablkcipher *tfm;
+	struct fh_aes_ctx *ctx;
+	u32 method;
+
+	tfm = crypto_ablkcipher_reqtfm(req);
+	ctx = crypto_ablkcipher_ctx(tfm);
+	method = 0;
+
+	switch (ctx->keylen) {
+	case AES_KEYSIZE_128:
+		method = AES_128_METHOD;
+		break;
+	case AES_KEYSIZE_192:
+		method = AES_192_METHOD;
+		break;
+	case AES_KEYSIZE_256:
+		method = AES_256_METHOD;
+		break;
+	default:
+		break;
+	}
+	return fh_aes_crypt(req, method | OFB_MODE | ENCRYPT);
+}
+
+static int fh_aes_ofb_decrypt(struct ablkcipher_request *req)
+{
+	struct crypto_ablkcipher *tfm;
+	struct fh_aes_ctx *ctx;
+	u32 method;
+
+	tfm = crypto_ablkcipher_reqtfm(req);
+	ctx = crypto_ablkcipher_ctx(tfm);
+	method = 0;
+
+	AES_DBG("%s\n", __func__);
+	switch (ctx->keylen) {
+	case AES_KEYSIZE_128:
+		method = AES_128_METHOD;
+		break;
+	case AES_KEYSIZE_192:
+		method = AES_192_METHOD;
+		break;
+	case AES_KEYSIZE_256:
+		method = AES_256_METHOD;
+		break;
+	default:
+		break;
+	}
+
+	return fh_aes_crypt(req, method | OFB_MODE | DECRYPT);
+}
+
+static int fh_aes_cfb_encrypt(struct ablkcipher_request *req)
+{
+	struct crypto_ablkcipher *tfm;
+	struct fh_aes_ctx *ctx;
+	u32 method;
+
+	tfm = crypto_ablkcipher_reqtfm(req);
+	ctx = crypto_ablkcipher_ctx(tfm);
+	method = 0;
+
+	switch (ctx->keylen) {
+	case AES_KEYSIZE_128:
+		method = AES_128_METHOD;
+		break;
+	case AES_KEYSIZE_192:
+		method = AES_192_METHOD;
+		break;
+	case AES_KEYSIZE_256:
+		method = AES_256_METHOD;
+		break;
+	default:
+		break;
+	}
+	return fh_aes_crypt(req, method | CFB_MODE | ENCRYPT);
+}
+
+static int fh_aes_cfb_decrypt(struct ablkcipher_request *req)
+{
+	struct crypto_ablkcipher *tfm;
+	struct fh_aes_ctx *ctx;
+	u32 method;
+
+	tfm = crypto_ablkcipher_reqtfm(req);
+	ctx = crypto_ablkcipher_ctx(tfm);
+	method = 0;
+
+	AES_DBG("%s\n", __func__);
+	switch (ctx->keylen) {
+	case AES_KEYSIZE_128:
+		method = AES_128_METHOD;
+		break;
+	case AES_KEYSIZE_192:
+		method = AES_192_METHOD;
+		break;
+	case AES_KEYSIZE_256:
+		method = AES_256_METHOD;
+		break;
+	default:
+		break;
+	}
+
+	return fh_aes_crypt(req, method | CFB_MODE | DECRYPT);
+}
+static int fh_des_ecb_encrypt(struct ablkcipher_request *req)
+{
+	u32 method;
+	method = 0;
+	method = DES_METHOD;
+
+	return fh_aes_crypt(req, method | ECB_MODE | ENCRYPT);
+}
+
+static int fh_des_ecb_decrypt(struct ablkcipher_request *req)
+{
+	u32 method;
+	method = 0;
+	method = DES_METHOD;
+
+	return fh_aes_crypt(req, method | ECB_MODE | DECRYPT);
+}
+
+static int fh_des_cbc_encrypt(struct ablkcipher_request *req)
+{
+	u32 method;
+	method = 0;
+	method = DES_METHOD;
+
+	return fh_aes_crypt(req, method | CBC_MODE | ENCRYPT);
+}
+
+static int fh_des_cbc_decrypt(struct ablkcipher_request *req)
+{
+	u32 method;
+	method = 0;
+	method = DES_METHOD;
+
+	return fh_aes_crypt(req, method | CBC_MODE | DECRYPT);
+}
+
+static int fh_des_ofb_encrypt(struct ablkcipher_request *req)
+{
+	u32 method;
+	method = 0;
+	method = DES_METHOD;
+
+	return fh_aes_crypt(req, method | OFB_MODE | ENCRYPT);
+}
+
+static int fh_des_ofb_decrypt(struct ablkcipher_request *req)
+{
+	u32 method;
+	method = 0;
+	method = DES_METHOD;
+
+	return fh_aes_crypt(req, method | OFB_MODE | DECRYPT);
+}
+
+static int fh_des_cfb_encrypt(struct ablkcipher_request *req)
+{
+	u32 method;
+	method = 0;
+	method = DES_METHOD;
+
+	return fh_aes_crypt(req, method | CFB_MODE | ENCRYPT);
+}
+
+static int fh_des_cfb_decrypt(struct ablkcipher_request *req)
+{
+	u32 method;
+	method = 0;
+	method = DES_METHOD;
+
+	return fh_aes_crypt(req, method | CFB_MODE | DECRYPT);
+}
+static int fh_des_tri_ecb_encrypt(struct ablkcipher_request *req)
+{
+	u32 method;
+	method = 0;
+	method = TRIPLE_DES_METHOD;
+	return fh_aes_crypt(req, method | ECB_MODE | ENCRYPT);
+}
+
+static int fh_des_tri_ecb_decrypt(struct ablkcipher_request *req)
+{
+	u32 method;
+	method = 0;
+	method = TRIPLE_DES_METHOD;
+	return fh_aes_crypt(req, method | ECB_MODE | DECRYPT);
+}
+
+static int fh_des_tri_cbc_encrypt(struct ablkcipher_request *req)
+{
+	u32 method;
+	method = 0;
+	method = TRIPLE_DES_METHOD;
+	return fh_aes_crypt(req, method | CBC_MODE | ENCRYPT);
+}
+
+static int fh_des_tri_cbc_decrypt(struct ablkcipher_request *req)
+{
+	u32 method;
+	method = 0;
+	method = TRIPLE_DES_METHOD;
+	return fh_aes_crypt(req, method | CBC_MODE | DECRYPT);
+}
+
+static int fh_des_tri_ofb_encrypt(struct ablkcipher_request *req)
+{
+	u32 method;
+	method = 0;
+	method = TRIPLE_DES_METHOD;
+	return fh_aes_crypt(req, method | OFB_MODE | ENCRYPT);
+}
+
+static int fh_des_tri_ofb_decrypt(struct ablkcipher_request *req)
+{
+	u32 method;
+	method = 0;
+	method = TRIPLE_DES_METHOD;
+	return fh_aes_crypt(req, method | OFB_MODE | DECRYPT);
+}
+
+static int fh_des_tri_cfb_encrypt(struct ablkcipher_request *req)
+{
+	u32 method;
+	method = 0;
+	method = TRIPLE_DES_METHOD;
+	return fh_aes_crypt(req, method | CFB_MODE | ENCRYPT);
+}
+
+static int fh_des_tri_cfb_decrypt(struct ablkcipher_request *req)
+{
+	u32 method;
+	method = 0;
+	method = TRIPLE_DES_METHOD;
+	return fh_aes_crypt(req, method | CFB_MODE | DECRYPT);
+}
+static int fh_aes_setkey(struct crypto_ablkcipher *cipher, const uint8_t *key,
+			 unsigned int keylen)
+{
+	struct crypto_tfm *tfm = crypto_ablkcipher_tfm(cipher);
+	struct fh_aes_ctx *ctx = crypto_tfm_ctx(tfm);
+	int i = 0;
+	AES_DBG("%s\n", __func__);
+	if (keylen != AES_KEYSIZE_128 && keylen != AES_KEYSIZE_192
+	    && keylen != AES_KEYSIZE_256 && keylen != DES_KEY_SIZE
+	    && keylen != DES3_EDE_KEY_SIZE)
+		return -EINVAL;
+
+	for (; i < keylen; i++)
+		AES_DBG("%x", key[i]);
+	AES_DBG("\n");
+
+	memcpy(ctx->aes_key, key, keylen);
+	ctx->keylen = keylen;
+
+	return 0;
+}
+
+static int fh_aes_cra_init(struct crypto_tfm *tfm)
+{
+	struct fh_aes_ctx *ctx = crypto_tfm_ctx(tfm);
+	ctx->dev = pobj_aes_dev;
+	tfm->crt_ablkcipher.reqsize = sizeof(struct fh_aes_reqctx);
+	AES_DBG("%s\n", __func__);
+
+	return 0;
+}
+
+static void fh_aes_tx(struct fh_aes_dev *dev)
+{
+	int err = 0;
+	unsigned int i = 0;
+	struct ablkcipher_request *req = dev->req;
+	struct scatterlist *temp_sg = req->dst;
+	fh_unset_outdata(dev);
+	do {
+		sg_copy_from_buffer(temp_sg, 1, &dev->ctl_dst_xbuf[i],
+		sg_dma_len(temp_sg));
+		i += sg_dma_len(temp_sg);
+		temp_sg = sg_next(temp_sg);
+	} while (temp_sg != NULL);
+
+	fh_aes_complete(dev, err);
+}
+
+static void fh_aes_rx(struct fh_aes_dev *dev)
+{
+	fh_unset_indata(dev);
+}
+
+static irqreturn_t fh_aes_interrupt(int irq, void *dev_id)
+{
+
+	u32 isr_status;
+	unsigned long flags;
+	struct platform_device *pdev = (struct platform_device *) dev_id;
+	struct fh_aes_dev *dev = platform_get_drvdata(pdev);
+
+	u32 isr = dev->en_isr;
+	AES_DBG("%s\n", __func__);
+	spin_lock_irqsave(&dev->lock, flags);
+	aes_writel(dev, dma_control, 0);
+	isr_status = aes_readl(dev, intr_src);
+	aes_writel(dev, intr_clear_status, 0x07);
+	aes_writel(dev, intr_enable, 0);
+	if (isr_status & 0x02)
+		AES_DBG("dma rev hreap error...\n");
+	if (isr_status & 0x04)
+		AES_DBG("dma stop src ..\n");
+	if (isr_status & 0x01) {
+		AES_DBG("dma done..\n");
+		fh_aes_rx(dev);
+		fh_aes_tx(dev);
+		if (dev->busy == true) {
+			/*begin the next transfer...*/
+			aes_writel(dev, intr_enable, isr);
+			/*enable dma go..*/
+			aes_writel(dev, dma_control, 1);
+		}
+
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return IRQ_HANDLED;
+}
+
+static void aes_biglittle_swap(u8 *buf)
+{
+	u8 tmp, tmp1;
+	tmp = buf[0];
+	tmp1 = buf[1];
+	buf[0] = buf[3];
+	buf[1] = buf[2];
+	buf[2] = tmp1;
+	buf[3] = tmp;
+}
+
+static int fh_set_indata(struct fh_aes_dev *dev, struct scatterlist *sg)
+{
+	int err;
+	unsigned int i = 0;
+	unsigned int len = 0;
+	struct scatterlist *temp_sg = sg;
+	unsigned char *src_xbuf;
+	src_xbuf = &dev->ctl_src_xbuf[0];
+	do {
+		if (len + sg_dma_len(temp_sg) > FH_AES_CTL_MAX_PROCESS_SIZE) {
+			printk("%s: total size > driver size 0x%x\n", __func__, FH_AES_CTL_MAX_PROCESS_SIZE);
+			err = -ENOMEM;
+			goto exit;
+		}
+		sg_copy_to_buffer(temp_sg, 1, &src_xbuf[i], sg_dma_len(temp_sg));
+		len += sg_dma_len(temp_sg);
+		i += sg_dma_len(temp_sg);
+		temp_sg = sg_next(temp_sg);
+	} while (temp_sg != NULL);
+
+	sg_init_one(&dev->src_sg[0], &src_xbuf[0], len);
+	err = dma_map_sg(dev->dev, &dev->src_sg[0], 1, DMA_TO_DEVICE);
+	if (!err) {
+		err = -ENOMEM;
+		goto exit;
+	}
+	dev->sg_src = &dev->src_sg[0];
+	err = 0;
+exit:
+	return err;
+}
+
+static int fh_set_outdata(struct fh_aes_dev *dev, struct scatterlist *sg)
+{
+	int err;
+	sg_init_one(&dev->dst_sg[0], &dev->ctl_dst_xbuf[0], FH_AES_CTL_MAX_PROCESS_SIZE);
+	err = dma_map_sg(dev->dev, &dev->dst_sg[0], 1, DMA_FROM_DEVICE);
+	if (!err) {
+		err = -ENOMEM;
+		goto exit;
+	}
+	dev->sg_dst = &dev->dst_sg[0];
+	err = 0;
+exit:
+	return err;
+}
+
+static void fh_set_aes_key_reg(struct fh_aes_dev *dev, uint8_t *key,
+			       uint8_t *iv, unsigned int keylen)
+{
+
+	int i;
+	u32 method;
+	u32 temp_key_buf[32];
+	u32 temp_iv_buf[32];
+	u32 *p_dst = NULL;
+	u32 key_size = 0;
+	if (dev->iv_flag == true) {
+		/*set iv*/
+		/*if aes mode ....set 128 bit iv,  des set 64bit iv..*/
+		AES_DBG("set iv reg\n");
+		if ((dev->control_reg & AES_128_METHOD)
+		    || ((dev->control_reg & AES_192_METHOD))
+		    || (dev->control_reg & AES_256_METHOD)) {
+			AES_DBG("aes iv mode...\n");
+
+			memcpy((u8 *)&temp_iv_buf[0], iv, 16);
+			p_dst = &temp_iv_buf[0];
+			for (i = 0; i < 16 / sizeof(u32); i++)
+				aes_biglittle_swap((u8 *)(p_dst + i));
+			memcpy((u8 *)&((struct fh_aes_reg *) dev->regs)->initial_vector0,
+			       temp_iv_buf, 16);
+		} else {
+			AES_DBG("des iv mode...\n");
+
+			memcpy((u8 *)&temp_iv_buf[0], iv, 8);
+			p_dst = &temp_iv_buf[0];
+			for (i = 0; i < 8 / sizeof(u32); i++)
+				aes_biglittle_swap((u8 *)(p_dst + i));
+
+			memcpy((u8 *)&((struct fh_aes_reg *) dev->regs)->initial_vector0,
+			       temp_iv_buf, 8);
+
+		}
+	}
+	/*set key...*/
+	method = dev->control_reg & 0x0e;
+	AES_DBG("set key reg\n");
+
+	switch (method) {
+	case AES_128_METHOD:
+		AES_DBG("set key aes 128 mode..\n");
+		key_size = 16;
+
+		break;
+	case AES_192_METHOD:
+		AES_DBG("set key aes 192 mode..\n");
+		key_size = 24;
+		break;
+
+	case AES_256_METHOD:
+		AES_DBG("set key aes 256 mode..\n");
+		key_size = 32;
+		break;
+
+	case DES_METHOD:
+		AES_DBG("set key des normal mode..\n");
+		key_size = 8;
+		break;
+
+	case TRIPLE_DES_METHOD:
+		AES_DBG("set key des triple mode..\n");
+		key_size = 24;
+		break;
+
+	default:
+		AES_DBG("error method!!\n");
+		break;
+
+	}
+#ifdef FH_AESV2
+
+	if (s_efuse_obj.open_flag == USE_CPU_SET_KEY) {
+		memcpy((u8 *)&temp_key_buf[0], key, key_size);
+		p_dst = &temp_key_buf[0];
+		for (i = 0; i < key_size / sizeof(u32); i++)
+			aes_biglittle_swap((u8 *)(p_dst + i));
+		memcpy((u8 *)&((struct fh_aes_reg *) dev->regs)->security_key0,
+		       (u8 *)&temp_key_buf[0],
+		       key_size);
+	} else {
+		s_efuse_obj.trans_key_start_no = 0;
+		s_efuse_obj.trans_key_size = key_size / 4;
+		efuse_trans_key(&s_efuse_obj,
+				s_efuse_obj.trans_key_start_no,
+				s_efuse_obj.trans_key_size);
+	}
+
+#else
+	memcpy((u8 *)&temp_key_buf[0], key, key_size);
+	p_dst = &temp_key_buf[0];
+	for (i = 0; i < key_size / sizeof(u32); i++)
+		aes_biglittle_swap((u8 *)(p_dst + i));
+
+	memcpy((u8 *)&((struct fh_aes_reg *) dev->regs)->security_key0,
+	       (u8 *)&temp_key_buf[0],
+	       key_size);
+
+#endif
+
+
+}
+
+static void fh_set_dma_indata(struct fh_aes_dev *dev,
+			      struct scatterlist *sg)
+{
+	aes_writel(dev, dma_src_add, sg_dma_address(sg));
+	AES_DBG("%s :dma trans size is :%x\n", __func__, sg_dma_len(sg));
+	aes_writel(dev, dma_trans_size, sg_dma_len(sg));
+}
+
+static void fh_set_dma_outdata(struct fh_aes_dev *dev,
+			       struct scatterlist *sg)
+{
+	aes_writel(dev, dma_dst_add, sg_dma_address(sg));
+}
+
+static void fh_unset_indata(struct fh_aes_dev *dev)
+{
+	dma_unmap_sg(dev->dev, dev->sg_src, 1, DMA_TO_DEVICE);
+}
+
+static void fh_unset_outdata(struct fh_aes_dev *dev)
+{
+	dma_unmap_sg(dev->dev, dev->sg_dst, 1, DMA_FROM_DEVICE);
+}
+
+static void fh_aes_complete(struct fh_aes_dev *dev, int err)
+{
+	if (dev->req->base.complete)
+		dev->req->base.complete(&dev->req->base, err);
+	dev->busy = false;
+}
+
+static void fh_aes_crypt_start(struct fh_aes_dev *dev, unsigned long mode)
+{
+
+	struct ablkcipher_request *req = dev->req;
+	u32 control_reg;
+	u32 outfifo_thold = 0;
+	u32 infifo_thold = 0;
+	u32 isr;
+	int err;
+	unsigned long flags;
+	control_reg = 0;
+
+	if ((mode & CBC_MODE) || (mode & CTR_MODE) || (mode & CFB_MODE)
+	    || (mode & OFB_MODE)) {
+		control_reg |= 1 << 7;
+		dev->iv_flag = true;
+	} else
+		dev->iv_flag = false;
+
+	/*emode & method*/
+	control_reg |= (unsigned int) mode;
+	dev->control_reg = control_reg;
+	outfifo_thold = 0;
+	infifo_thold = 8;
+	isr = dev->en_isr;
+	spin_lock_irqsave(&dev->lock, flags);
+	AES_DBG("control_reg:0x%x\n", control_reg);
+	aes_writel(dev, encrypt_control, control_reg);
+	/*set key...*/
+	fh_set_aes_key_reg(dev, dev->ctx->aes_key, req->info, dev->ctx->keylen);
+	err = fh_set_indata(dev, req->src);
+	if (err)
+		goto indata_error;
+
+	err = fh_set_outdata(dev, req->dst);
+	if (err)
+		goto outdata_error;
+
+	fh_set_dma_indata(dev, dev->sg_src);
+	fh_set_dma_outdata(dev, dev->sg_dst);
+
+	/*set fifo..*/
+	AES_DBG("outfifo thold:%x\n", outfifo_thold);
+	AES_DBG("infifo thold:%x\n", infifo_thold);
+	aes_writel(dev, fifo_threshold, outfifo_thold << 8 | infifo_thold);
+	/*set isr..*/
+	AES_DBG("intr enable:%x\n", isr);
+	aes_writel(dev, intr_enable, isr);
+	/*enable dma go..*/
+	aes_writel(dev, dma_control, 1);
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return;
+
+outdata_error:
+	AES_DBG("outdata_error ..\n");
+	fh_unset_indata(dev);
+
+indata_error:
+	AES_DBG("indata_error ..\n");
+	fh_aes_complete(dev, err);
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+}
+
+static void fh_aes_tasklet_cb(unsigned long data)
+{
+
+	struct fh_aes_dev *dev = (struct fh_aes_dev *) data;
+	struct crypto_async_request *async_req, *backlog;
+	struct fh_aes_reqctx *reqctx;
+	unsigned long flags;
+
+	AES_DBG("%s\n", __func__);
+	spin_lock_irqsave(&dev->lock, flags);
+	backlog = crypto_get_backlog(&dev->queue);
+	AES_DBG("backlog add is :%x\n", (u32)backlog);
+	/*get the req need to handle*/
+	async_req = crypto_dequeue_request(&dev->queue);
+	spin_unlock_irqrestore(&dev->lock, flags);
+	if (!async_req)
+		return;
+	if (backlog) {
+		if (backlog->complete)
+			backlog->complete(backlog, -EINPROGRESS);
+	}
+
+	dev->req = ablkcipher_request_cast(async_req);
+	dev->ctx = crypto_tfm_ctx(dev->req->base.tfm);
+	reqctx = ablkcipher_request_ctx(dev->req);
+	fh_aes_crypt_start(dev, reqctx->mode);
+}
+
+/*add chenjn dsp use...*/
+typedef struct {
+	unsigned int base;
+	void *vbase;
+	unsigned int size;
+} MEM_INFO;
+typedef struct {
+	MEM_INFO mem;
+	unsigned char *remap_base; /**<*/
+} RW_MEM_INFO;
+
+struct tcrypt_result {
+	struct completion completion;
+	int err;
+};
+
+int aes_128_ecb_encrypt(char *key_128, RW_MEM_INFO in, 
+	RW_MEM_INFO out, unsigned int data_len_align16);
+
+
+int fh_aes_ctl_mem_init(struct fh_aes_dev *pdata)
+{
+	unsigned int t1;
+	unsigned int t2;
+	unsigned int t3;
+	unsigned int t4;
+
+	t1 = (unsigned int)kmalloc(FH_AES_MALLOC_SIZE + FH_AES_ALLIGN_SIZE, GFP_KERNEL);
+	if (!t1)
+		goto err1;
+
+	t2 = (unsigned int)kmalloc(FH_AES_MALLOC_SIZE + FH_AES_ALLIGN_SIZE, GFP_KERNEL);
+	if (!t2)
+		goto err2;
+
+
+	t3 = ((t1 + FH_AES_ALLIGN_SIZE - 1) & (~(FH_AES_ALLIGN_SIZE - 1)));
+	t4 = ((t2 + FH_AES_ALLIGN_SIZE - 1) & (~(FH_AES_ALLIGN_SIZE - 1)));
+
+	pdata->ctl_raw_src_xbuf = (unsigned char *)t1;
+	pdata->ctl_raw_dst_xbuf = (unsigned char *)t2;
+	pdata->ctl_src_xbuf = (unsigned char *)t3;
+	pdata->ctl_dst_xbuf = (unsigned char *)t4;
+	return 0;
+err2:
+	kfree((void *)t1);
+err1:
+	return -1;
+
+}
+
+static int __devinit fh_aes_probe(struct platform_device *pdev)
+{
+
+	int i, j, err = -ENODEV;
+	struct fh_aes_dev *pdata;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	struct resource *ioarea;
+
+	AES_DBG("aes probe get in..\n");
+	if (pobj_aes_dev) {
+		dev_err(&pdev->dev, "second crypto dev..\n");
+		return -EEXIST;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "get platform source error..\n");
+		return -ENODEV;
+	}
+
+	ioarea = request_mem_region(res->start, resource_size(res), pdev->name);
+	if (!ioarea) {
+		dev_err(&pdev->dev, "aes region already claimed\n");
+		/*BUG_ON(ioarea);*/
+		return -EBUSY;
+	}
+
+	pdata = kzalloc(sizeof(struct fh_aes_dev), GFP_KERNEL);
+	if (!pdata) {
+		err = -ENOMEM;
+		goto err_malloc;
+	}
+
+	spin_lock_init(&pdata->lock);
+	pdata->regs = ioremap(res->start, resource_size(res));
+
+	if (!pdata->regs) {
+		dev_err(&pdev->dev, "aes region already mapped\n");
+		err = -EINVAL;
+		goto err_iomap;
+	}
+	pdata->irq_no = platform_get_irq(pdev, 0);
+	if (pdata->irq_no < 0) {
+		err = pdata->irq_no;
+		dev_warn(dev, "aes interrupt is not available.\n");
+		goto err_irq;
+	}
+	/*only enable dma done isr..*/
+	pdata->en_isr = 1 << 0;
+	err = request_irq(pdata->irq_no, fh_aes_interrupt, 0,
+			  dev_name(&pdev->dev), pdev);
+
+	if (err) {
+		dev_dbg(&pdev->dev, "request_irq failed, %d\n", err);
+		goto err_irq;
+	}
+	/*bind to plat dev..*/
+	pdata->dev = dev;
+	/*bing to static para..only one aes controller in fh..*/
+	pobj_aes_dev = pdata;
+	platform_set_drvdata(pdev, pdata);
+
+	tasklet_init(&pdata->tasklet, fh_aes_tasklet_cb, (unsigned long) pdata);
+	crypto_init_queue(&pdata->queue, CRYPTO_QUEUE_LEN);
+	for (i = 0; i < ARRAY_SIZE(algs); i++) {
+		INIT_LIST_HEAD(&algs[i].cra_list);
+		err = crypto_register_alg(&algs[i]);
+
+		if (err) {
+			dev_warn(dev, "register alg error...\n");
+			goto err_algs;
+		}
+	}
+
+	err = fh_aes_ctl_mem_init(pdata);
+	if (err) {
+		dev_err(&pdev->dev, "aes malloc mem error..\n");
+		goto err_algs;
+	}
+	pr_info("aes driver registered\n");
+
+#ifdef CONFIG_FH_AES_SELF_TEST
+
+	fh_aes_self_test_all();
+#endif
+
+	return 0;
+err_algs:
+	for (j = 0; j < i; j++)
+		crypto_unregister_alg(&algs[j]);
+	tasklet_kill(&pdata->tasklet);
+	platform_set_drvdata(pdev, NULL);
+	pobj_aes_dev = NULL;
+	free_irq(pdata->irq_no, pdata);
+
+err_irq:
+	iounmap(pdata->regs);
+
+err_iomap:
+	kfree(pdata);
+
+err_malloc:
+	release_mem_region(res->start, resource_size(res));
+	return err;
+}
+
+static int __devexit fh_aes_remove(struct platform_device *pdev)
+{
+
+	int i;
+	struct fh_aes_dev *pdata = platform_get_drvdata(pdev);
+	struct resource *res;
+
+	for (i = 0; i < ARRAY_SIZE(algs); i++)
+		crypto_unregister_alg(&algs[i]);
+
+	tasklet_kill(&pdata->tasklet);
+	platform_set_drvdata(pdev, NULL);
+	pobj_aes_dev = NULL;
+	free_irq(pdata->irq_no, pdata);
+	iounmap(pdata->regs);
+	kfree(pdata->ctl_raw_src_xbuf);
+	kfree(pdata->ctl_raw_dst_xbuf);
+	pdata->ctl_raw_src_xbuf = NULL;
+	pdata->ctl_raw_dst_xbuf = NULL;
+	pdata->ctl_src_xbuf = NULL;
+	pdata->ctl_dst_xbuf = NULL;
+	kfree(pdata);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, resource_size(res));
+
+	return 0;
+}
+
+static struct platform_driver fh_aes_driver = {
+	.driver = {
+		.name = "fh_aes",
+		.owner = THIS_MODULE,
+	},
+	.probe = fh_aes_probe,
+	.remove = __devexit_p(fh_aes_remove),
+};
+
+static int __init fh_aes_init(void)
+{
+	return platform_driver_register(&fh_aes_driver);
+}
+late_initcall(fh_aes_init);
+
+static void __exit fh_aes_exit(void)
+{
+	platform_driver_unregister(&fh_aes_driver);
+}
+module_exit(fh_aes_exit);
+
+static void tcrypt_complete(struct crypto_async_request *req, int err)
+{
+	struct tcrypt_result *res = req->data;
+	if (err == -EINPROGRESS)
+		return;
+	complete(&res->completion);
+}
+
+int aes_128_ecb_encrypt(char *key_128, RW_MEM_INFO in, RW_MEM_INFO out, unsigned int data_len_align16)
+{
+	static char *xbuf;
+	static char *dst_xbuf;
+	static struct crypto_ablkcipher *tfm;
+	static struct ablkcipher_request *req;
+	static int malloc_flag;
+	/*const char *algo = NULL;*/
+	struct scatterlist sg[8];
+	struct scatterlist dst_sg[8];
+	void *data;
+	void *dst_data;
+	struct tcrypt_result wait_result;
+
+	/*malloc buf...*/
+	if (malloc_flag != 0)
+		goto work_go;
+	malloc_flag = 1;
+	xbuf = (void *)__get_free_page(GFP_KERNEL);
+	if (!xbuf) {
+		printk("no pages.\n");
+		return -1;
+	}
+
+	dst_xbuf = (void *)__get_free_page(GFP_KERNEL);
+	if (!dst_xbuf) {
+		free_page((unsigned long)xbuf);
+		printk("no pages.\n");
+		return -1;
+	}
+
+	tfm = crypto_alloc_ablkcipher("ecb-aes-fh",
+					CRYPTO_ALG_TYPE_ABLKCIPHER |
+					CRYPTO_ALG_ASYNC, 0);
+	if (IS_ERR(tfm)) {
+		printk("aes_test: failed to alloc cipher!\n");
+		free_page((unsigned long)xbuf);
+		free_page((unsigned long)dst_xbuf);
+		return -1;
+	}
+	req = ablkcipher_request_alloc(tfm, GFP_KERNEL);
+	if (!req) {
+		printk(KERN_ERR "alg: skcipher: Failed to allocate request "
+			"for\n");
+		return -1;
+	}
+
+work_go:
+	init_completion(&wait_result.completion);
+	crypto_ablkcipher_setkey(tfm, (u8 *)key_128, 16);
+	ablkcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+					tcrypt_complete, &wait_result);
+	data = xbuf;
+	dst_data = dst_xbuf;
+	/*encrypt*/
+	memcpy(data, in.remap_base, data_len_align16);
+	sg_init_one(&sg[0], data, data_len_align16);
+	sg_init_one(&dst_sg[0], dst_data, data_len_align16);
+	ablkcipher_request_set_crypt(req, sg, dst_sg, data_len_align16, NULL);
+	crypto_ablkcipher_encrypt(req);
+	wait_for_completion(&wait_result.completion);
+	memcpy(out.remap_base, dst_data, data_len_align16);
+
+	return 0;
+
+}
+EXPORT_SYMBOL(aes_128_ecb_encrypt);
+
+
+MODULE_AUTHOR("yu.zhang <zhangy@fullhan.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Fullhan AES driver support");
diff -uraN linux-3.0.8/drivers/crypto/fh_aes.h linux-3.0.8-fh8632-V1.0_20180330/drivers/crypto/fh_aes.h
--- linux-3.0.8/drivers/crypto/fh_aes.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/crypto/fh_aes.h	2021-07-13 23:40:36.498373482 +0300
@@ -0,0 +1,119 @@
+/*
+ * fh_aes.h
+ *
+ *  Created on: 3.12.2015
+ *      Author: duobao
+ */
+
+#ifndef FH_AES_H_
+#define FH_AES_H_
+
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-mapping.h>
+#include <linux/io.h>
+#include <linux/crypto.h>
+#include <linux/interrupt.h>
+#include <crypto/algapi.h>
+#include <crypto/aes.h>
+#include <crypto/des.h>
+#include <crypto/ctr.h>
+
+struct fh_aes_reg {
+	u32 encrypt_control;		/*0*/
+	u32 reserved_4_8;			/*4*/
+	u32 fifo_status;			/*8*/
+	u32 parity_error;			/*c*/
+	u32 security_key0;			/*10*/
+	u32 security_key1;			/*14*/
+	u32 security_key2;			/*18*/
+	u32 security_key3;			/*1c*/
+	u32 security_key4;			/*20*/
+	u32 security_key5;			/*24*/
+	u32 security_key6;			/*28*/
+	u32 security_key7;			/*2c*/
+	u32 initial_vector0;		/*30*/
+	u32 initial_vector1;		/*34*/
+	u32 initial_vector2;		/*38*/
+	u32 initial_vector3;		/*3c*/
+	u32 reserved_40_44;			/*40*/
+	u32 reserved_44_48;			/*44*/
+	u32 dma_src_add;			/*48*/
+	u32 dma_dst_add;			/*4c*/
+	u32 dma_trans_size;			/*50*/
+	u32 dma_control;			/*54*/
+	u32 fifo_threshold;			/*58*/
+	u32 intr_enable;			/*5c*/
+	u32 intr_src;				/*60*/
+	u32 mask_intr_status;		/*64*/
+	u32 intr_clear_status;		/*68*/
+	u32 reserved_6c_70;			/*6c*/
+	u32 revision;				/*70*/
+	u32 feature;				/*74*/
+	u32 reserved_78_7c;			/*78*/
+	u32 reserved_7c_80;			/*7c*/
+	u32 last_initial_vector0;	/*80*/
+	u32 last_initial_vector1;	/*84*/
+	u32 last_initial_vector2;	/*88*/
+	u32 last_initial_vector3;	/*8c*/
+};
+
+/*requst ctx.....*/
+struct fh_aes_reqctx {
+	unsigned long mode;
+};
+/*aes ctx....*/
+struct fh_aes_ctx {
+	struct fh_aes_dev *dev;              /*bind to aes dev..*/
+	uint8_t aes_key[AES_MAX_KEY_SIZE];		/*rec key value..*/
+	int keylen;		/*rec key len.*/
+};
+
+struct fh_aes_dev {
+	/*common driver paras..*/
+	void *regs;
+	struct device *dev;	/*bind to the platform dev...*/
+	struct clk *clk;
+	bool busy;		/*software sync the hardware....*/
+	spinlock_t lock;	/*just lock...*/
+	u32 irq_no;		/*board info...*/
+	u32 en_isr;		/*software rec the isr src*/
+	bool iv_flag;
+	u32 control_reg;
+	/*crypto need below...*/
+	struct fh_aes_ctx *ctx;		/*bind to the aes ctx...*/
+	struct fh_aes_reqctx *reqctx;	/*bind to the req ctx..*/
+	struct scatterlist *sg_src;	/*rec the src data need to be handled*/
+	struct scatterlist *sg_dst;	/*rec the dst data need to be handled*/
+	struct tasklet_struct tasklet;	/*async process the crypto*/
+	struct ablkcipher_request *req;	/*active req...*/
+	struct crypto_queue queue;
+	unsigned char *ctl_src_xbuf;
+	unsigned char *ctl_dst_xbuf;
+	unsigned char *ctl_raw_src_xbuf;
+	unsigned char *ctl_raw_dst_xbuf;
+	struct scatterlist src_sg[1];
+	struct scatterlist dst_sg[1];
+};
+
+
+/*#define FH_AES_SELF_TEST*/
+/*#define FH_AES_DEBUG*/
+#ifdef FH_AES_DEBUG
+#define AES_DBG(fmt, args...)  printk(fmt, ## args)
+#else
+#define AES_DBG(fmt, args...)  do { } while (0)
+#endif
+
+#define AES_PRINT_RESULT(fmt, args...)  printk(fmt, ## args)
+
+#endif /* fh_AES_H_ */
+
+
diff -uraN linux-3.0.8/drivers/crypto/fh_aes_test.c linux-3.0.8-fh8632-V1.0_20180330/drivers/crypto/fh_aes_test.c
--- linux-3.0.8/drivers/crypto/fh_aes_test.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/crypto/fh_aes_test.c	2021-07-13 23:40:36.498373482 +0300
@@ -0,0 +1,1369 @@
+/*
+ * fh_aes_test.c
+ *
+ *  Created on: May 7, 2015
+ *      Author: yu.zhang
+ */
+#ifdef CONFIG_FH_AES_SELF_TEST
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/errno.h>
+#include <linux/in.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/skbuff.h>
+#include <linux/highmem.h>
+#include <linux/proc_fs.h>
+#include <linux/ctype.h>
+#include <linux/version.h>
+#include <linux/spinlock.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/bitops.h>
+#include <linux/io.h>
+#include <linux/irqreturn.h>
+#include <asm/irq.h>
+#include <asm/page.h>
+#include <crypto/hash.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/scatterlist.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <crypto/rng.h>
+#include "fh_aes.h"
+//cbc aes 128
+#define AES_IV0			0x00010203
+#define AES_IV1			0x04050607
+#define AES_IV2			0x08090a0b
+#define AES_IV3			0x0c0d0e0f
+
+#define AES_KEY0		0x2b7e1516
+#define AES_KEY1		0x28aed2a6
+#define AES_KEY2		0xabf71588
+#define AES_KEY3		0x09cf4f3c
+
+
+static const unsigned char aes_cbc_iv_buf[] = {
+	0x00,0x01,0x02,0x03, 0x04,0x05,0x06,0x07, 0x08,0x09,0x0a,0x0b, 0x0c,0x0d,0x0e,0x0f,
+};
+
+static const unsigned char aes_cbc_key_buf[] = {
+	0x2b,0x7e,0x15,0x16, 0x28,0xae,0xd2,0xa6, 0xab,0xf7,0x15,0x88, 0x09,0xcf,0x4f,0x3c,
+};
+
+
+//ecb aes 256
+#define AES_ECB_KEY0	0x603deb10
+#define AES_ECB_KEY1	0x15ca71be
+#define AES_ECB_KEY2	0x2b73aef0
+#define AES_ECB_KEY3	0x857d7781
+#define AES_ECB_KEY4	0x1f352c07
+#define AES_ECB_KEY5	0x3b6108d7
+#define AES_ECB_KEY6	0x2d9810a3
+#define AES_ECB_KEY7	0x0914dff4
+
+
+static const unsigned char aes_ecb_key_buf[] = {
+	0x60,0x3d,0xeb,0x10, 0x15,0xca,0x71,0xbe, 0x2b,0x73,0xae,0xf0, 0x85,0x7d,0x77,0x81,
+	0x1f,0x35,0x2c,0x07, 0x3b,0x61,0x08,0xd7, 0x2d,0x98,0x10,0xa3, 0x09,0x14,0xdf,0xf4,
+};
+
+//ctr aes 192
+#define AES_CTR_KEY0 	0x8e73b0f7
+#define AES_CTR_KEY1 	0xda0e6452
+#define AES_CTR_KEY2 	0xc810f32b
+#define AES_CTR_KEY3 	0x809079e5
+#define AES_CTR_KEY4 	0x62f8ead2
+#define AES_CTR_KEY5 	0x522c6b7b
+
+#define AES_CTR_IV0		0xf0f1f2f3
+#define AES_CTR_IV1		0xf4f5f6f7
+#define AES_CTR_IV2		0xf8f9fafb
+#define AES_CTR_IV3		0xfcfdfeff
+
+
+static const unsigned char aes_ctr_iv_buf[] = {
+	0xf0,0xf1,0xf2,0xf3, 0xf4,0xf5,0xf6,0xf7, 0xf8,0xf9,0xfa,0xfb, 0xfc,0xfd,0xfe,0xff,
+};
+
+static const unsigned char aes_ctr_key_buf[] = {
+	0x8e,0x73,0xb0,0xf7, 0xda,0x0e,0x64,0x52, 0xc8,0x10,0xf3,0x2b, 0x80,0x90,0x79,0xe5,
+	0x62,0xf8,0xea,0xd2, 0x52,0x2c,0x6b,0x7b,
+};
+
+
+//cfb aes 192
+//#define AES_CFB_KEY0 	0x8e73b0f7
+//#define AES_CFB_KEY1 	0xda0e6452
+//#define AES_CFB_KEY2	0xc810f32b
+//#define AES_CFB_KEY3 	0x809079e5
+//#define AES_CFB_KEY4 	0x62f8ead2
+//#define AES_CFB_KEY5	0x522c6b7b
+//
+//#define AES_CFB_IV0		0x00010203
+//#define AES_CFB_IV1		0x04050607
+//#define AES_CFB_IV2		0x08090a0b
+//#define AES_CFB_IV3		0x0c0d0e0f
+
+//ofb aes 256
+#define AES_OFB_256_KEY0 0x603deb10
+#define AES_OFB_256_KEY1 0x15ca71be
+#define AES_OFB_256_KEY2 0x2b73aef0
+#define AES_OFB_256_KEY3 0x857d7781
+#define AES_OFB_256_KEY4 0x1f352c07
+#define AES_OFB_256_KEY5 0x3b6108d7
+#define AES_OFB_256_KEY6 0x2d9810a3
+#define AES_OFB_256_KEY7 0x0914dff4
+
+#define AES_OFB_IV0		0x00010203
+#define AES_OFB_IV1		0x04050607
+#define AES_OFB_IV2		0x08090a0b
+#define AES_OFB_IV3		0x0c0d0e0f
+
+static const unsigned char aes_ofb_iv_buf[] = {
+	0x00,0x01,0x02,0x03, 0x04,0x05,0x06,0x07, 0x08,0x09,0x0a,0x0b, 0x0c,0x0d,0x0e,0x0f,
+};
+
+static const unsigned char aes_ofb_key_buf[] = {
+	0x60,0x3d,0xeb,0x10, 0x15,0xca,0x71,0xbe, 0x2b,0x73,0xae,0xf0, 0x85,0x7d,0x77,0x81,
+	0x1f,0x35,0x2c,0x07, 0x3b,0x61,0x08,0xd7, 0x2d,0x98,0x10,0xa3, 0x09,0x14,0xdf,0xf4,
+};
+
+//des ecb
+#define DES_ECB_KEY0 	0x01010101
+#define DES_ECB_KEY1 	0x01010101
+
+static const unsigned char des_ecb_key_buf[] = {
+	0x01,0x01,0x01,0x01, 0x01,0x01,0x01,0x01,
+};
+//des cbc
+#define DES_CBC_KEY0 	0x01234567
+#define DES_CBC_KEY1 	0x89abcdef
+
+#define DES_CBC_IV0		0x12345678
+#define DES_CBC_IV1		0x90abcdef
+
+
+static const unsigned char des_cbc_key_buf[] = {
+	0x01,0x23,0x45,0x67, 0x89,0xab,0xcd,0xef,
+};
+
+static const unsigned char des_cbc_iv_buf[] = {
+	0x12,0x34,0x56,0x78, 0x90,0xab,0xcd,0xef,
+};
+
+
+//ofb cbc
+#define DES_OFB_KEY0 	0x01234567
+#define DES_OFB_KEY1 	0x89abcdef
+
+#define DES_OFB_IV0		0x12345678
+#define DES_OFB_IV1		0x90abcdef
+
+static const unsigned char des_ofb_key_buf[] = {
+	0x01,0x23,0x45,0x67, 0x89,0xab,0xcd,0xef,
+};
+
+static const unsigned char des_ofb_iv_buf[] = {
+	0x12,0x34,0x56,0x78, 0x90,0xab,0xcd,0xef,
+};
+
+//ecb tri-des
+#define DES_TRI_ECB_KEY0	 0x01234567
+#define DES_TRI_ECB_KEY1 	 0x89abcdef
+
+#define DES_TRI_ECB_KEY2	 0x23456789
+#define DES_TRI_ECB_KEY3	 0xabcdef01
+
+#define DES_TRI_ECB_KEY4	 0x456789ab
+#define DES_TRI_ECB_KEY5	 0xcdef0123
+
+static const unsigned char des3_ecb_key_buf[] = {
+	0x01,0x23,0x45,0x67, 0x89,0xab,0xcd,0xef, 0x23,0x45,0x67,0x89, 0xab,0xcd,0xef,0x01,
+	0x45,0x67,0x89,0xab, 0xcd,0xef,0x01,0x23,
+};
+
+//cbc tri-des
+#define DES_TRI_CBC_KEY0	 0x01234567
+#define DES_TRI_CBC_KEY1 	 0x89abcdef
+
+#define DES_TRI_CBC_KEY2	 0x23456789
+#define DES_TRI_CBC_KEY3	 0xabcdef01
+
+#define DES_TRI_CBC_KEY4	 0x456789ab
+#define DES_TRI_CBC_KEY5	 0xcdef0123
+
+#define DES_TRI_CBC_IV0		0x12345678
+#define DES_TRI_CBC_IV1		0x90abcdef
+
+static const unsigned char des3_cbc_key_buf[] = {
+	0x01,0x23,0x45,0x67, 0x89,0xab,0xcd,0xef, 0x23,0x45,0x67,0x89, 0xab,0xcd,0xef,0x01,
+	0x45,0x67,0x89,0xab, 0xcd,0xef,0x01,0x23,
+};
+static const unsigned char des3_cbc_iv_buf[] = {
+	0x12,0x34,0x56,0x78, 0x90,0xab,0xcd,0xef,
+};
+#define XBUFSIZE	128
+
+struct tcrypt_result {
+	struct completion completion;
+	int err;
+};
+
+static inline void hexdump(unsigned char *buf, unsigned int len);
+static void tcrypt_complete(struct crypto_async_request *req, int err);
+static int testmgr_alloc_buf(char *buf[XBUFSIZE]);
+static int fh_aes_cbc128_self_test(void);
+static int fh_aes_ecb256_self_test(void);
+
+static struct tcrypt_result result;
+static const unsigned char plain_text[]  = {
+		0x6b,0xc1,0xbe,0xe2, 0x2e,0x40,0x9f,0x96, 0xe9,0x3d,0x7e,0x11, 0x73,0x93,0x17,0x2a,
+		0xae,0x2d,0x8a,0x57, 0x1e,0x03,0xac,0x9c, 0x9e,0xb7,0x6f,0xac, 0x45,0xaf,0x8e,0x51,
+		0x30,0xc8,0x1c,0x46, 0xa3,0x5c,0xe4,0x11, 0xe5,0xfb,0xc1,0x19, 0x1a,0x0a,0x52,0xef,
+		0xf6,0x9f,0x24,0x45, 0xdf,0x4f,0x9b,0x17, 0xad,0x2b,0x41,0x7b, 0xe6,0x6c,0x37,0x10,
+};
+
+static const unsigned char cipher_text[] = {
+		0x76,0x49,0xab,0xac, 0x81,0x19,0xb2,0x46, 0xce,0xe9,0x8e,0x9b, 0x12,0xe9,0x19,0x7d,
+		0x50,0x86,0xcb,0x9b, 0x50,0x72,0x19,0xee, 0x95,0xdb,0x11,0x3a, 0x91,0x76,0x78,0xb2,
+		0x73,0xbe,0xd6,0xb8, 0xe3,0xc1,0x74,0x3b, 0x71,0x16,0xe6,0x9e, 0x22,0x22,0x95,0x16,
+		0x3f,0xf1,0xca,0xa1, 0x68,0x1f,0xac,0x09, 0x12,0x0e,0xca,0x30, 0x75,0x86,0xe1,0xa7,
+};
+
+static const unsigned char plain_ecb_256_text[] = {
+		0x6b,0xc1,0xbe,0xe2, 0x2e,0x40,0x9f,0x96, 0xe9,0x3d,0x7e,0x11, 0x73,0x93,0x17,0x2a,
+		0xae,0x2d,0x8a,0x57, 0x1e,0x03,0xac,0x9c, 0x9e,0xb7,0x6f,0xac, 0x45,0xaf,0x8e,0x51,
+		0x30,0xc8,0x1c,0x46, 0xa3,0x5c,0xe4,0x11, 0xe5,0xfb,0xc1,0x19, 0x1a,0x0a,0x52,0xef,
+		0xf6,0x9f,0x24,0x45, 0xdf,0x4f,0x9b,0x17, 0xad,0x2b,0x41,0x7b, 0xe6,0x6c,0x37,0x10,
+};
+
+static const unsigned char cipher_ecb_256_text[] = {
+		0xf3,0xee,0xd1,0xbd, 0xb5,0xd2,0xa0,0x3c, 0x06,0x4b,0x5a,0x7e, 0x3d,0xb1,0x81,0xf8,
+		0x59,0x1c,0xcb,0x10, 0xd4,0x10,0xed,0x26, 0xdc,0x5b,0xa7,0x4a, 0x31,0x36,0x28,0x70,
+		0xb6,0xed,0x21,0xb9, 0x9c,0xa6,0xf4,0xf9, 0xf1,0x53,0xe7,0xb1, 0xbe,0xaf,0xed,0x1d,
+		0x23,0x30,0x4b,0x7a, 0x39,0xf9,0xf3,0xff, 0x06,0x7d,0x8d,0x8f, 0x9e,0x24,0xec,0xc7,
+};
+
+static const unsigned char plain_ctr_192_text[] = {
+		0x6b,0xc1,0xbe,0xe2, 0x2e,0x40,0x9f,0x96, 0xe9,0x3d,0x7e,0x11, 0x73,0x93,0x17,0x2a,
+		0xae,0x2d,0x8a,0x57, 0x1e,0x03,0xac,0x9c, 0x9e,0xb7,0x6f,0xac, 0x45,0xaf,0x8e,0x51,
+		0x30,0xc8,0x1c,0x46, 0xa3,0x5c,0xe4,0x11, 0xe5,0xfb,0xc1,0x19, 0x1a,0x0a,0x52,0xef,
+		0xf6,0x9f,0x24,0x45, 0xdf,0x4f,0x9b,0x17, 0xad,0x2b,0x41,0x7b, 0xe6,0x6c,0x37,0x10,
+};
+
+static const unsigned char cipher_ctr_192_text[] = {
+		0x1a,0xbc,0x93,0x24,	0x17,0x52,0x1c,0xa2,	0x4f,0x2b,0x04,0x59,	0xfe,0x7e,0x6e,0x0b,
+		0x09,0x03,0x39,0xec,	0x0a,0xa6,0xfa,0xef,	0xd5,0xcc,0xc2,0xc6,	0xf4,0xce,0x8e,0x94,
+		0x1e,0x36,0xb2,0x6b,	0xd1,0xeb,0xc6,0x70,	0xd1,0xbd,0x1d,0x66,	0x56,0x20,0xab,0xf7,
+		0x4f,0x78,0xa7,0xf6,	0xd2,0x98,0x09,0x58,	0x5a,0x97,0xda,0xec,	0x58,0xc6,0xb0,0x50,
+};
+
+static const unsigned char plain_ofb_256_text[] = {
+		0x6b,0xc1,0xbe,0xe2, 0x2e,0x40,0x9f,0x96, 0xe9,0x3d,0x7e,0x11, 0x73,0x93,0x17,0x2a,
+		0xae,0x2d,0x8a,0x57, 0x1e,0x03,0xac,0x9c, 0x9e,0xb7,0x6f,0xac, 0x45,0xaf,0x8e,0x51,
+		0x30,0xc8,0x1c,0x46, 0xa3,0x5c,0xe4,0x11, 0xe5,0xfb,0xc1,0x19, 0x1a,0x0a,0x52,0xef,
+		0xf6,0x9f,0x24,0x45, 0xdf,0x4f,0x9b,0x17, 0xad,0x2b,0x41,0x7b, 0xe6,0x6c,0x37,0x10,
+};
+
+static const unsigned char cipher_ofb_256_text[] = {
+		0xdc,0x7e,0x84,0xbf,0xda,0x79,0x16,0x4b,0x7e,0xcd,0x84,0x86,0x98,0x5d,0x38,0x60,
+		0x4f,0xeb,0xdc,0x67,0x40,0xd2,0x0b,0x3a,0xc8,0x8f,0x6a,0xd8,0x2a,0x4f,0xb0,0x8d,
+		0x71,0xab,0x47,0xa0,0x86,0xe8,0x6e,0xed,0xf3,0x9d,0x1c,0x5b,0xba,0x97,0xc4,0x08,
+		0x01,0x26,0x14,0x1d,0x67,0xf3,0x7b,0xe8,0x53,0x8f,0x5a,0x8b,0xe7,0x40,0xe4,0x84,
+};
+
+static const unsigned char plain_des_ecb_text[] = {
+		0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+};
+
+static const unsigned char cipher_des_ecb_text[] = {
+		0x95,0xF8,0xA5,0xE5,0xDD,0x31,0xD9,0x00,0xDD,0x7F,0x12,0x1C,0xA5,0x01,0x56,0x19,
+		0x2E,0x86,0x53,0x10,0x4F,0x38,0x34,0xEA,0x4B,0xD3,0x88,0xFF,0x6C,0xD8,0x1D,0x4F,
+		0x20,0xB9,0xE7,0x67,0xB2,0xFB,0x14,0x56,0x55,0x57,0x93,0x80,0xD7,0x71,0x38,0xEF,
+		0x6C,0xC5,0xDE,0xFA,0xAF,0x04,0x51,0x2F,0x0D,0x9F,0x27,0x9B,0xA5,0xD8,0x72,0x60,
+};
+
+static const unsigned char plain_des_cbc_text[] = {
+		0x4e,0x6f,0x77,0x20,0x69,0x73,0x20,0x74,0x68,0x65,0x20,0x74,0x69,0x6d,0x65,0x20,
+		0x66,0x6f,0x72,0x20,0x61,0x6c,0x6c,0x20,
+};
+
+static const unsigned char cipher_des_cbc_text[] = {
+		0xe5,0xc7,0xcd,0xde,0x87,0x2b,0xf2,0x7c,0x43,0xe9,0x34,0x00,0x8c,0x38,0x9c,0x0f,
+		0x68,0x37,0x88,0x49,0x9a,0x7c,0x05,0xf6,
+};
+
+static const unsigned char  plain_des_ofb_text[] = {
+		0x4e,0x6f,0x77,0x20,0x69,0x73,0x20,0x74,0x43,0xe9,0x34,0x00,0x8c,0x38,0x9c,0x0f,
+			0x68,0x37,0x88,0x49,0x9a,0x7c,0x05,0xf6,
+};
+
+static const unsigned char cipher_des_ofb_text[] = {
+		0xf3,0x09,0x62,0x49,0xc7,0xf4,0x6e,0x51,0x1e,0x7e,0x5e,0x50,0xcb,0xbe,0xc4,0x10,
+		0x33,0x35,0xa1,0x8a,0xde,0x4a,0x91,0x15,
+};
+
+static const unsigned char plain_des_tri_ecb_text[] = {
+		0x4e,0x6f,0x77,0x20,0x69,0x73,0x20,0x74,0x43,0xe9,0x34,0x00,0x8c,0x38,0x9c,0x0f,
+		0x68,0x37,0x88,0x49,0x9a,0x7c,0x05,0xf6,
+};
+
+static const unsigned char cipher_des_tri_ecb_text[] = {
+		0x31,0x4f,0x83,0x27,0xfa,0x7a,0x09,0xa8,0xd5,0x89,0x5f,0xad,0xe9,0x8f,0xae,0xdf,
+		0x98,0xf4,0x70,0xeb,0x35,0x53,0xa5,0xda,
+};
+
+static const unsigned char plain_des_tri_cbc_text[] = {
+		0x4e,0x6f,0x77,0x20,0x69,0x73,0x20,0x74,0x43,0xe9,0x34,0x00,0x8c,0x38,0x9c,0x0f,
+		0x68,0x37,0x88,0x49,0x9a,0x7c,0x05,0xf6,
+};
+
+static const unsigned char cipher_des_tri_cbc_text[] = {
+		0xf3,0xc0,0xff,0x02,0x6c,0x02,0x30,0x89,0xc4,0x3a,0xdd,0x8f,0xd8,0xcd,0x5e,0x43,
+		0x2b,0xfd,0x41,0xd3,0x13,0x0b,0xcf,0x40,
+};
+
+static inline void hexdump(unsigned char *buf, unsigned int len)
+{
+	while (len--)
+		AES_DBG("%02x", *buf++);
+	AES_DBG("\n");
+}
+
+static void tcrypt_complete(struct crypto_async_request *req, int err)
+{
+	struct tcrypt_result *res = req->data;
+	if (err == -EINPROGRESS)
+		return;
+//      res->err = err;
+	AES_DBG("crypt all over....\n");
+	complete(&res->completion);
+
+}
+
+static int testmgr_alloc_buf(char *buf[XBUFSIZE])
+{
+	int i;
+	for (i = 0; i < XBUFSIZE; i++) {
+		buf[i] = (void *)__get_free_page(GFP_KERNEL);
+		if (!buf[i])
+			goto err_free_buf;
+	}
+
+	return 0;
+err_free_buf:
+	while (i-- > 0)
+		free_page((unsigned long)buf[i]);
+
+	return -ENOMEM;
+}
+
+static int fh_aes_cbc128_self_test(void)
+{
+	struct crypto_ablkcipher *tfm;
+	struct ablkcipher_request *req;
+	const char *algo;
+
+	struct scatterlist sg[8];
+	struct scatterlist dst_sg[8];
+
+	u32 key[4] = { AES_KEY0, AES_KEY1, AES_KEY2, AES_KEY3 };
+	u32 iv[4] = { AES_IV0, AES_IV1, AES_IV2, AES_IV3 };
+	//void * memcpy(void * dest, const void *src, size_t n)
+
+	char *xbuf[XBUFSIZE];
+	char *dst_xbuf[XBUFSIZE];
+	//int ret = -ENOMEM;
+	void *data;
+	void *dst_data;
+	memcpy(&key[0],&aes_cbc_key_buf[0],sizeof(aes_cbc_key_buf));
+	memcpy(&iv[0],&aes_cbc_iv_buf[0],sizeof(aes_cbc_iv_buf));
+	if (testmgr_alloc_buf(xbuf)) {
+		AES_DBG("no pages.\n");
+		return -1;
+	}
+
+	if (testmgr_alloc_buf(dst_xbuf)) {
+		AES_DBG("no pages.\n");
+		return -1;
+	}
+
+	AES_DBG("aes self test get in...\n");
+	AES_DBG(" *_* step 1\n");
+	tfm =
+		crypto_alloc_ablkcipher("cbc-aes-fh",
+					CRYPTO_ALG_TYPE_ABLKCIPHER |
+					CRYPTO_ALG_ASYNC, 0);
+	if (IS_ERR(tfm)) {
+		AES_DBG("aes_test: failed to alloc cipher!\n");
+		return -1;
+	}
+
+	AES_DBG(" *_* step 2\n");
+	algo = crypto_tfm_alg_driver_name(crypto_ablkcipher_tfm(tfm));
+	init_completion(&result.completion);
+
+	AES_DBG(" *_* step 3\n");
+	crypto_ablkcipher_setkey(tfm, (u8 *) key, 16);
+
+	AES_DBG(" *_* step 4\n");
+	req = ablkcipher_request_alloc(tfm, GFP_KERNEL);
+	if (!req) {
+		AES_DBG(KERN_ERR "alg: skcipher: Failed to allocate request "
+			"for %s\n", algo);
+		return -1;
+	}
+
+	AES_DBG(" *_* step 5\n");
+	ablkcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+					tcrypt_complete, &result);
+
+	AES_DBG(" *_* step 6\n");
+	data = xbuf[0];
+	dst_data = dst_xbuf[0];
+
+	//encrypt
+	memcpy(data, plain_text, 64);
+	memset(dst_data, 0, 64);
+	sg_init_one(&sg[0], data, 64);
+	sg_init_one(&dst_sg[0], dst_data, 64);
+
+	AES_DBG(" *_* step 7\n");
+	ablkcipher_request_set_crypt(req, sg, dst_sg, 64, (void *)iv);
+
+	AES_DBG(" *_* step 8\n");
+	crypto_ablkcipher_encrypt(req);
+
+	wait_for_completion(&result.completion);
+
+	if (memcmp(dst_data, cipher_text, 64))
+		AES_PRINT_RESULT(" encrypt error....\n");
+	else
+		AES_PRINT_RESULT(" encrypt ok....\n");
+
+	//decrypt
+	memcpy(data, cipher_text, 64);
+	memset(dst_data, 0, 64);
+	sg_init_one(&sg[0], data, 64);
+	sg_init_one(&dst_sg[0], dst_data, 64);
+	AES_DBG(" *_* step 8\n");
+	ablkcipher_request_set_crypt(req, sg, dst_sg, 64, (void *)iv);
+	AES_DBG(" *_* step 9\n");
+	crypto_ablkcipher_decrypt(req);
+	wait_for_completion(&result.completion);
+
+	if (memcmp(dst_data, plain_text, 64))
+		AES_PRINT_RESULT(" decrypt error....\n");
+	else
+		AES_PRINT_RESULT(" decrypt ok....\n");
+
+	return 0;
+
+}
+
+static int fh_aes_ecb256_self_test(void)
+{
+	struct crypto_ablkcipher *tfm;
+	struct ablkcipher_request *req;
+	const char *algo;
+	struct scatterlist sg[8];
+	struct scatterlist dst_sg[8];
+	u32 key[8] = {
+		AES_ECB_KEY0, AES_ECB_KEY1, AES_ECB_KEY2, AES_ECB_KEY3,
+		AES_ECB_KEY4, AES_ECB_KEY5, AES_ECB_KEY6, AES_ECB_KEY7
+	};
+	//const u32 iv[4] = {AES_IV0,AES_IV1,AES_IV2,AES_IV3};
+
+
+	//memcpy(&iv[0],&aes_cbc_iv_buf[0],sizeof(aes_cbc_iv_buf));
+
+	char *xbuf[XBUFSIZE];
+	char *dst_xbuf[XBUFSIZE];
+
+	//int ret = -ENOMEM;
+	void *data;
+	void *dst_data;
+	memcpy(&key[0],&aes_ecb_key_buf[0],sizeof(aes_ecb_key_buf));
+	if (testmgr_alloc_buf(xbuf)) {
+		AES_DBG("no pages.\n");
+		return -1;
+	}
+
+	if (testmgr_alloc_buf(dst_xbuf)) {
+		AES_DBG("no pages.\n");
+		return -1;
+	}
+
+	AES_DBG("aes self test get in...\n");
+	AES_DBG(" *_* step 1\n");
+	tfm =
+		crypto_alloc_ablkcipher("ecb-aes-fh",
+					CRYPTO_ALG_TYPE_ABLKCIPHER |
+					CRYPTO_ALG_ASYNC, 0);
+	if (IS_ERR(tfm)) {
+		AES_DBG("aes_test: failed to alloc cipher!\n");
+		return -1;
+	}
+
+	AES_DBG(" *_* step 2\n");
+	algo = crypto_tfm_alg_driver_name(crypto_ablkcipher_tfm(tfm));
+	init_completion(&result.completion);
+
+	AES_DBG(" *_* step 3\n");
+	crypto_ablkcipher_setkey(tfm, (u8 *) key, 32);
+
+	AES_DBG(" *_* step 4\n");
+	req = ablkcipher_request_alloc(tfm, GFP_KERNEL);
+	if (!req) {
+		AES_DBG(KERN_ERR "alg: skcipher: Failed to allocate request "
+			"for %s\n", algo);
+		return -1;
+	}
+
+	AES_DBG(" *_* step 5\n");
+	ablkcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+					tcrypt_complete, &result);
+
+	AES_DBG(" *_* step 6\n");
+	data = xbuf[0];
+	dst_data = dst_xbuf[0];
+
+	//encrypt
+	memcpy(data, plain_ecb_256_text, 64);
+	memset(dst_data, 0, 64);
+	sg_init_one(&sg[0], data, 64);
+	sg_init_one(&dst_sg[0], dst_data, 64);
+
+	AES_DBG(" *_* step 7\n");
+	ablkcipher_request_set_crypt(req, sg, dst_sg, 64, NULL);
+
+	AES_DBG(" *_* step 8\n");
+	crypto_ablkcipher_encrypt(req);
+
+	wait_for_completion(&result.completion);
+
+	if (memcmp(dst_data, cipher_ecb_256_text, 64))
+		AES_PRINT_RESULT(" encrypt error....\n");
+	else
+		AES_PRINT_RESULT(" encrypt ok....\n");
+
+	//decrypt
+	memcpy(data, cipher_ecb_256_text, 64);
+	memset(dst_data, 0, 64);
+	sg_init_one(&sg[0], data, 64);
+	sg_init_one(&dst_sg[0], dst_data, 64);
+
+	AES_DBG(" *_* step 8\n");
+	ablkcipher_request_set_crypt(req, sg, dst_sg, 64, NULL);
+
+	AES_DBG(" *_* step 9\n");
+	crypto_ablkcipher_decrypt(req);
+
+	wait_for_completion(&result.completion);
+
+	if (memcmp(dst_data, plain_ecb_256_text, 64))
+		AES_PRINT_RESULT(" decrypt error....\n");
+	else
+		AES_PRINT_RESULT(" decrypt ok....\n");
+
+	return 0;
+
+}
+
+static int fh_aes_ofb256_self_test(void)
+{
+	struct crypto_ablkcipher *tfm;
+	struct ablkcipher_request *req;
+	const char *algo;
+	struct scatterlist sg[8];
+	struct scatterlist dst_sg[8];
+	u32 key[8] = {
+		AES_OFB_256_KEY0, AES_OFB_256_KEY1, AES_OFB_256_KEY2,
+		AES_OFB_256_KEY3,
+		AES_OFB_256_KEY4, AES_OFB_256_KEY5, AES_OFB_256_KEY6,
+		AES_OFB_256_KEY7
+	};
+	u32 iv[4] =
+	{ AES_OFB_IV0, AES_OFB_IV1, AES_OFB_IV2, AES_OFB_IV3 };
+	char *xbuf[XBUFSIZE];
+	char *dst_xbuf[XBUFSIZE];
+	void *data;
+	void *dst_data;
+	memcpy(&key[0],&aes_ofb_key_buf[0],sizeof(aes_ofb_key_buf));
+	memcpy(&iv[0],&aes_ofb_iv_buf[0],sizeof(aes_ofb_iv_buf));
+	if (testmgr_alloc_buf(xbuf)) {
+		AES_DBG("no pages.\n");
+		return -1;
+	}
+
+	if (testmgr_alloc_buf(dst_xbuf)) {
+		AES_DBG("no pages.\n");
+		return -1;
+	}
+
+	AES_DBG("aes self test get in...\n");
+	AES_DBG(" *_* step 1\n");
+	tfm =
+		crypto_alloc_ablkcipher("ofb-aes-fh",
+					CRYPTO_ALG_TYPE_ABLKCIPHER |
+					CRYPTO_ALG_ASYNC, 0);
+	if (IS_ERR(tfm)) {
+		AES_DBG("aes_test: failed to alloc cipher!\n");
+		return -1;
+	}
+
+	AES_DBG(" *_* step 2\n");
+	algo = crypto_tfm_alg_driver_name(crypto_ablkcipher_tfm(tfm));
+	init_completion(&result.completion);
+
+	AES_DBG(" *_* step 3\n");
+	crypto_ablkcipher_setkey(tfm, (u8 *) key, 32);
+
+	AES_DBG(" *_* step 4\n");
+	req = ablkcipher_request_alloc(tfm, GFP_KERNEL);
+	if (!req) {
+		AES_DBG(KERN_ERR "alg: skcipher: Failed to allocate request "
+			"for %s\n", algo);
+		return -1;
+	}
+
+	AES_DBG(" *_* step 5\n");
+	ablkcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+					tcrypt_complete, &result);
+
+	AES_DBG(" *_* step 6\n");
+	data = xbuf[0];
+	dst_data = dst_xbuf[0];
+	//encrypt
+	memcpy(data, plain_ofb_256_text, 64);
+	memset(dst_data, 0, 64);
+	sg_init_one(&sg[0], data, 64);
+	sg_init_one(&dst_sg[0], dst_data, 64);
+
+	AES_DBG(" *_* step 7\n");
+	ablkcipher_request_set_crypt(req, sg, dst_sg, 64, (void *)iv);
+
+	AES_DBG(" *_* step 8\n");
+	crypto_ablkcipher_encrypt(req);
+	wait_for_completion(&result.completion);
+	if (memcmp(dst_data, cipher_ofb_256_text, 64))
+		AES_PRINT_RESULT(" encrypt error....\n");
+	else
+		AES_PRINT_RESULT(" encrypt ok....\n");
+	//decrypt
+	memcpy(data, cipher_ofb_256_text, 64);
+	memset(dst_data, 0, 64);
+	sg_init_one(&sg[0], data, 64);
+	sg_init_one(&dst_sg[0], dst_data, 64);
+	AES_DBG(" *_* step 8\n");
+	ablkcipher_request_set_crypt(req, sg, dst_sg, 64, (void *)iv);
+	AES_DBG(" *_* step 9\n");
+	crypto_ablkcipher_decrypt(req);
+
+	wait_for_completion(&result.completion);
+
+	if (memcmp(dst_data, plain_ofb_256_text, 64))
+		AES_PRINT_RESULT(" decrypt error....\n");
+	else
+		AES_PRINT_RESULT(" decrypt ok....\n");
+
+	return 0;
+}
+
+static int fh_des_ecb_self_test(void)
+{
+	struct crypto_ablkcipher *tfm;
+	struct ablkcipher_request *req;
+	const char *algo;
+	struct scatterlist sg[8];
+	struct scatterlist dst_sg[8];
+	u32 key[2] = { DES_ECB_KEY0, DES_ECB_KEY1 };
+	char *xbuf[XBUFSIZE];
+	char *dst_xbuf[XBUFSIZE];
+	void *data;
+	void *dst_data;
+
+
+	memcpy(&key[0],&des_ecb_key_buf[0],sizeof(des_ecb_key_buf));
+	//memcpy(&iv[0],&aes_ofb_iv_buf[0],sizeof(aes_ofb_iv_buf));
+
+	if (testmgr_alloc_buf(xbuf)) {
+		AES_DBG("no pages.\n");
+		return -1;
+	}
+
+	if (testmgr_alloc_buf(dst_xbuf)) {
+		AES_DBG("no pages.\n");
+		return -1;
+	}
+
+	AES_DBG("aes self test get in...\n");
+
+	AES_DBG(" *_* step 1\n");
+	tfm =
+		crypto_alloc_ablkcipher("ecb-des-fh",
+					CRYPTO_ALG_TYPE_ABLKCIPHER |
+					CRYPTO_ALG_ASYNC, 0);
+	if (IS_ERR(tfm)) {
+		AES_DBG("aes_test: failed to alloc cipher!\n");
+		return -1;
+	}
+
+	AES_DBG(" *_* step 2\n");
+	algo = crypto_tfm_alg_driver_name(crypto_ablkcipher_tfm(tfm));
+	init_completion(&result.completion);
+
+	AES_DBG(" *_* step 3\n");
+	crypto_ablkcipher_setkey(tfm, (u8 *) key, 8);
+
+	AES_DBG(" *_* step 4\n");
+	req = ablkcipher_request_alloc(tfm, GFP_KERNEL);
+	if (!req) {
+		AES_DBG(KERN_ERR "alg: skcipher: Failed to allocate request "
+			"for %s\n", algo);
+		return -1;
+	}
+
+	AES_DBG(" *_* step 5\n");
+	ablkcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+					tcrypt_complete, &result);
+
+	AES_DBG(" *_* step 6\n");
+	data = xbuf[0];
+	dst_data = dst_xbuf[0];
+
+	//encrypt
+	memcpy(data, plain_des_ecb_text, 64);
+	memset(dst_data, 0, 64);
+	sg_init_one(&sg[0], data, 64);
+	sg_init_one(&dst_sg[0], dst_data, 64);
+
+	AES_DBG(" *_* step 7\n");
+	ablkcipher_request_set_crypt(req, sg, dst_sg, 64, NULL);
+
+	AES_DBG(" *_* step 8\n");
+	crypto_ablkcipher_encrypt(req);
+
+	wait_for_completion(&result.completion);
+
+	if (memcmp(dst_data, cipher_des_ecb_text, 64))
+		AES_PRINT_RESULT(" encrypt error....\n");
+	else
+		AES_PRINT_RESULT(" encrypt ok....\n");
+
+	//decrypt
+	memcpy(data, cipher_des_ecb_text, 64);
+	memset(dst_data, 0, 64);
+	sg_init_one(&sg[0], data, 64);
+	sg_init_one(&dst_sg[0], dst_data, 64);
+
+	AES_DBG(" *_* step 8\n");
+	ablkcipher_request_set_crypt(req, sg, dst_sg, 64, NULL);
+
+	AES_DBG(" *_* step 9\n");
+	crypto_ablkcipher_decrypt(req);
+
+	wait_for_completion(&result.completion);
+
+	if (memcmp(dst_data, plain_des_ecb_text, 64))
+		AES_PRINT_RESULT(" decrypt error....\n");
+	else
+		AES_PRINT_RESULT(" decrypt ok....\n");
+
+	return 0;
+
+}
+
+static int fh_des_cbc_self_test(void)
+{
+	struct crypto_ablkcipher *tfm;
+	struct ablkcipher_request *req;
+	const char *algo;
+	struct scatterlist sg[8];
+	struct scatterlist dst_sg[8];
+	u32 key[2] = { DES_CBC_KEY0, DES_CBC_KEY1 };
+	u32 iv[2] = { DES_CBC_IV0, DES_CBC_IV1 };
+	char *xbuf[XBUFSIZE];
+	char *dst_xbuf[XBUFSIZE];
+	void *data;
+	void *dst_data;
+
+
+	memcpy(&key[0],&des_cbc_key_buf[0],sizeof(des_cbc_key_buf));
+	memcpy(&iv[0],&des_cbc_iv_buf[0],sizeof(des_cbc_iv_buf));
+
+	if (testmgr_alloc_buf(xbuf)) {
+		AES_DBG("no pages.\n");
+		return -1;
+	}
+
+	if (testmgr_alloc_buf(dst_xbuf)) {
+		AES_DBG("no pages.\n");
+		return -1;
+	}
+
+	AES_DBG("aes self test get in...\n");
+
+	AES_DBG(" *_* step 1\n");
+	tfm =
+		crypto_alloc_ablkcipher("cbc-des-fh",
+					CRYPTO_ALG_TYPE_ABLKCIPHER |
+					CRYPTO_ALG_ASYNC, 0);
+	if (IS_ERR(tfm)) {
+		AES_DBG("aes_test: failed to alloc cipher!\n");
+		return -1;
+	}
+
+	AES_DBG(" *_* step 2\n");
+	algo = crypto_tfm_alg_driver_name(crypto_ablkcipher_tfm(tfm));
+	init_completion(&result.completion);
+
+	AES_DBG(" *_* step 3\n");
+	crypto_ablkcipher_setkey(tfm, (u8 *) key, 8);
+
+	AES_DBG(" *_* step 4\n");
+	req = ablkcipher_request_alloc(tfm, GFP_KERNEL);
+	if (!req) {
+		AES_DBG(KERN_ERR "alg: skcipher: Failed to allocate request "
+			"for %s\n", algo);
+		return -1;
+	}
+
+	AES_DBG(" *_* step 5\n");
+	ablkcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+					tcrypt_complete, &result);
+
+	AES_DBG(" *_* step 6\n");
+	data = xbuf[0];
+	dst_data = dst_xbuf[0];
+
+	//encrypt
+	memcpy(data, plain_des_cbc_text, 24);
+	memset(dst_data, 0, 24);
+	sg_init_one(&sg[0], data, 24);
+	sg_init_one(&dst_sg[0], dst_data, 24);
+
+	AES_DBG(" *_* step 7\n");
+	ablkcipher_request_set_crypt(req, sg, dst_sg, 24, (void *)iv);
+
+	AES_DBG(" *_* step 8\n");
+	crypto_ablkcipher_encrypt(req);
+
+	wait_for_completion(&result.completion);
+
+	if (memcmp(dst_data, cipher_des_cbc_text, 24))
+		AES_PRINT_RESULT(" encrypt error....\n");
+	else
+		AES_PRINT_RESULT(" encrypt ok....\n");
+
+	//decrypt
+	memcpy(data, cipher_des_cbc_text, 24);
+	memset(dst_data, 0, 24);
+	sg_init_one(&sg[0], data, 24);
+	sg_init_one(&dst_sg[0], dst_data, 24);
+
+	AES_DBG(" *_* step 8\n");
+	ablkcipher_request_set_crypt(req, sg, dst_sg, 24, (void *)iv);
+
+	AES_DBG(" *_* step 9\n");
+	crypto_ablkcipher_decrypt(req);
+
+	wait_for_completion(&result.completion);
+
+	if (memcmp(dst_data, plain_des_cbc_text, 24))
+		AES_PRINT_RESULT(" decrypt error....\n");
+	else
+		AES_PRINT_RESULT(" decrypt ok....\n");
+
+	return 0;
+}
+
+static int fh_des_ofb_self_test(void)
+{
+	struct crypto_ablkcipher *tfm;
+	struct ablkcipher_request *req;
+	const char *algo;
+	struct scatterlist sg[8];
+	struct scatterlist dst_sg[8];
+	u32 key[2] = { DES_OFB_KEY0, DES_OFB_KEY1 };
+	u32 iv[2] = { DES_OFB_IV0, DES_OFB_IV1 };
+	char *xbuf[XBUFSIZE];
+	char *dst_xbuf[XBUFSIZE];
+	void *data;
+	void *dst_data;
+
+	memcpy(&key[0],&des_ofb_key_buf[0],sizeof(des_ofb_key_buf));
+	memcpy(&iv[0],&des_ofb_iv_buf[0],sizeof(des_ofb_iv_buf));
+
+	if (testmgr_alloc_buf(xbuf)) {
+		AES_DBG("no pages.\n");
+		return -1;
+	}
+
+	if (testmgr_alloc_buf(dst_xbuf)) {
+		AES_DBG("no pages.\n");
+		return -1;
+	}
+	AES_DBG("aes self test get in...\n");
+	AES_DBG(" *_* step 1\n");
+	tfm =
+		crypto_alloc_ablkcipher("ofb-des-fh",
+					CRYPTO_ALG_TYPE_ABLKCIPHER |
+					CRYPTO_ALG_ASYNC, 0);
+	if (IS_ERR(tfm)) {
+		AES_DBG("aes_test: failed to alloc cipher!\n");
+		return -1;
+	}
+
+	AES_DBG(" *_* step 2\n");
+	algo = crypto_tfm_alg_driver_name(crypto_ablkcipher_tfm(tfm));
+	init_completion(&result.completion);
+
+	AES_DBG(" *_* step 3\n");
+	crypto_ablkcipher_setkey(tfm, (u8 *) key, 8);
+
+	AES_DBG(" *_* step 4\n");
+	req = ablkcipher_request_alloc(tfm, GFP_KERNEL);
+	if (!req) {
+		AES_DBG(KERN_ERR "alg: skcipher: Failed to allocate request "
+			"for %s\n", algo);
+		return -1;
+	}
+
+	AES_DBG(" *_* step 5\n");
+	ablkcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+					tcrypt_complete, &result);
+
+	AES_DBG(" *_* step 6\n");
+	data = xbuf[0];
+	dst_data = dst_xbuf[0];
+
+	//encrypt
+	memcpy(data, plain_des_ofb_text, 24);
+	memset(dst_data, 0, 24);
+	sg_init_one(&sg[0], data, 24);
+	sg_init_one(&dst_sg[0], dst_data, 24);
+
+	AES_DBG(" *_* step 7\n");
+	ablkcipher_request_set_crypt(req, sg, dst_sg, 24, (void *)iv);
+	AES_DBG(" *_* step 8\n");
+	crypto_ablkcipher_encrypt(req);
+	wait_for_completion(&result.completion);
+	if (memcmp(dst_data, cipher_des_ofb_text, 24))
+		AES_PRINT_RESULT(" encrypt error....\n");
+	else
+		AES_PRINT_RESULT(" encrypt ok....\n");
+
+	//decrypt
+	memcpy(data, cipher_des_ofb_text, 24);
+	memset(dst_data, 0, 24);
+	sg_init_one(&sg[0], data, 24);
+	sg_init_one(&dst_sg[0], dst_data, 24);
+	AES_DBG(" *_* step 8\n");
+	ablkcipher_request_set_crypt(req, sg, dst_sg, 24, (void *)iv);
+
+	AES_DBG(" *_* step 9\n");
+	crypto_ablkcipher_decrypt(req);
+	wait_for_completion(&result.completion);
+	if (memcmp(dst_data, plain_des_ofb_text, 24))
+		AES_PRINT_RESULT(" decrypt error....\n");
+	else
+		AES_PRINT_RESULT(" decrypt ok....\n");
+
+	return 0;
+
+}
+
+static int fh_des_tri_ecb_self_test(void)
+{
+	struct crypto_ablkcipher *tfm;
+	struct ablkcipher_request *req;
+	const char *algo;
+	struct scatterlist sg[8];
+	struct scatterlist dst_sg[8];
+	u32 key[6] = {
+		DES_TRI_ECB_KEY0, DES_TRI_ECB_KEY1, DES_TRI_ECB_KEY2,
+		DES_TRI_ECB_KEY3, DES_TRI_ECB_KEY4, DES_TRI_ECB_KEY5
+	};
+	char *xbuf[XBUFSIZE];
+	char *dst_xbuf[XBUFSIZE];
+	void *data;
+	void *dst_data;
+
+	memcpy(&key[0],&des3_ecb_key_buf[0],sizeof(des3_ecb_key_buf));
+	//memcpy(&iv[0],&des_ofb_iv_buf[0],sizeof(des_ofb_iv_buf));
+	if (testmgr_alloc_buf(xbuf)) {
+		AES_DBG("no pages.\n");
+		return -1;
+	}
+
+	if (testmgr_alloc_buf(dst_xbuf)) {
+		AES_DBG("no pages.\n");
+		return -1;
+	}
+
+	AES_DBG("aes self test get in...\n");
+
+	AES_DBG(" *_* step 1\n");
+	tfm =
+		crypto_alloc_ablkcipher("ecb-des3-fh",
+					CRYPTO_ALG_TYPE_ABLKCIPHER |
+					CRYPTO_ALG_ASYNC, 0);
+	if (IS_ERR(tfm)) {
+		AES_DBG("aes_test: failed to alloc cipher!\n");
+		return -1;
+	}
+
+	AES_DBG(" *_* step 2\n");
+	algo = crypto_tfm_alg_driver_name(crypto_ablkcipher_tfm(tfm));
+	init_completion(&result.completion);
+
+	AES_DBG(" *_* step 3\n");
+	crypto_ablkcipher_setkey(tfm, (u8 *) key, 24);
+
+	AES_DBG(" *_* step 4\n");
+	req = ablkcipher_request_alloc(tfm, GFP_KERNEL);
+	if (!req) {
+		AES_DBG(KERN_ERR "alg: skcipher: Failed to allocate request "
+			"for %s\n", algo);
+		return -1;
+	}
+
+	AES_DBG(" *_* step 5\n");
+	ablkcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+					tcrypt_complete, &result);
+
+	AES_DBG(" *_* step 6\n");
+	data = xbuf[0];
+	dst_data = dst_xbuf[0];
+
+	//encrypt
+	memcpy(data, plain_des_tri_ecb_text, 24);
+	memset(dst_data, 0, 24);
+	sg_init_one(&sg[0], data, 24);
+	sg_init_one(&dst_sg[0], dst_data, 24);
+
+	AES_DBG(" *_* step 7\n");
+	ablkcipher_request_set_crypt(req, sg, dst_sg, 24, (void *)NULL);
+
+	AES_DBG(" *_* step 8\n");
+	crypto_ablkcipher_encrypt(req);
+
+	wait_for_completion(&result.completion);
+
+	if (memcmp(dst_data, cipher_des_tri_ecb_text, 24))
+		AES_PRINT_RESULT(" encrypt error....\n");
+	else
+		AES_PRINT_RESULT(" encrypt ok....\n");
+
+	//decrypt
+	memcpy(data, cipher_des_tri_ecb_text, 24);
+	memset(dst_data, 0, 24);
+	sg_init_one(&sg[0], data, 24);
+	sg_init_one(&dst_sg[0], dst_data, 24);
+
+	AES_DBG(" *_* step 8\n");
+	ablkcipher_request_set_crypt(req, sg, dst_sg, 24, (void *)NULL);
+
+	AES_DBG(" *_* step 9\n");
+	crypto_ablkcipher_decrypt(req);
+
+	wait_for_completion(&result.completion);
+
+	if (memcmp(dst_data, plain_des_tri_ecb_text, 24))
+		AES_PRINT_RESULT(" decrypt error....\n");
+	else
+		AES_PRINT_RESULT(" decrypt ok....\n");
+
+	return 0;
+
+}
+
+static int fh_des_tri_cbc_self_test(void)
+{
+	struct crypto_ablkcipher *tfm;
+	struct ablkcipher_request *req;
+	const char *algo;
+	struct scatterlist sg[8];
+	struct scatterlist dst_sg[8];
+	u32 key[6] = {
+		DES_TRI_CBC_KEY0, DES_TRI_CBC_KEY1, DES_TRI_CBC_KEY2,
+		DES_TRI_CBC_KEY3, DES_TRI_CBC_KEY4, DES_TRI_CBC_KEY5
+	};
+	u32 iv[2] = { DES_TRI_CBC_IV0, DES_TRI_CBC_IV1 };
+	char *xbuf[XBUFSIZE];
+	char *dst_xbuf[XBUFSIZE];
+	void *data;
+	void *dst_data;
+
+
+	memcpy(&key[0],&des3_cbc_key_buf[0],sizeof(des3_cbc_key_buf));
+	memcpy(&iv[0],&des3_cbc_iv_buf[0],sizeof(des3_cbc_iv_buf));
+
+
+	if (testmgr_alloc_buf(xbuf)) {
+		AES_DBG("no pages.\n");
+		return -1;
+	}
+
+	if (testmgr_alloc_buf(dst_xbuf)) {
+		AES_DBG("no pages.\n");
+		return -1;
+	}
+
+	AES_DBG("aes self test get in...\n");
+
+	AES_DBG(" *_* step 1\n");
+	tfm =
+		crypto_alloc_ablkcipher("cbc-des3-fh",
+					CRYPTO_ALG_TYPE_ABLKCIPHER |
+					CRYPTO_ALG_ASYNC, 0);
+	if (IS_ERR(tfm)) {
+		AES_DBG("aes_test: failed to alloc cipher!\n");
+		return -1;
+	}
+
+	AES_DBG(" *_* step 2\n");
+	algo = crypto_tfm_alg_driver_name(crypto_ablkcipher_tfm(tfm));
+	init_completion(&result.completion);
+
+	AES_DBG(" *_* step 3\n");
+	crypto_ablkcipher_setkey(tfm, (u8 *) key, 24);
+
+	AES_DBG(" *_* step 4\n");
+	req = ablkcipher_request_alloc(tfm, GFP_KERNEL);
+	if (!req) {
+		AES_DBG(KERN_ERR "alg: skcipher: Failed to allocate request "
+			"for %s\n", algo);
+		return -1;
+	}
+
+	AES_DBG(" *_* step 5\n");
+	ablkcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+					tcrypt_complete, &result);
+
+	AES_DBG(" *_* step 6\n");
+	data = xbuf[0];
+	dst_data = dst_xbuf[0];
+
+	//encrypt
+	memcpy(data, plain_des_tri_cbc_text, 24);
+	memset(dst_data, 0, 24);
+	sg_init_one(&sg[0], data, 24);
+	sg_init_one(&dst_sg[0], dst_data, 24);
+
+	AES_DBG(" *_* step 7\n");
+	ablkcipher_request_set_crypt(req, sg, dst_sg, 24, (void *)iv);
+
+	AES_DBG(" *_* step 8\n");
+	crypto_ablkcipher_encrypt(req);
+
+	wait_for_completion(&result.completion);
+
+	if (memcmp(dst_data, cipher_des_tri_cbc_text, 24))
+		AES_PRINT_RESULT(" encrypt error....\n");
+	else
+		AES_PRINT_RESULT(" encrypt ok....\n");
+
+	//decrypt
+	memcpy(data, cipher_des_tri_cbc_text, 24);
+	memset(dst_data, 0, 24);
+	sg_init_one(&sg[0], data, 24);
+	sg_init_one(&dst_sg[0], dst_data, 24);
+
+	AES_DBG(" *_* step 8\n");
+	ablkcipher_request_set_crypt(req, sg, dst_sg, 24, (void *)iv);
+
+	AES_DBG(" *_* step 9\n");
+	crypto_ablkcipher_decrypt(req);
+
+	wait_for_completion(&result.completion);
+
+	if (memcmp(dst_data, plain_des_tri_cbc_text, 24))
+		AES_PRINT_RESULT(" decrypt error....\n");
+	else
+		AES_PRINT_RESULT(" decrypt ok....\n");
+
+	return 0;
+
+}
+
+#if(0)
+
+typedef struct
+{
+	unsigned int base;
+	void * vbase;
+	unsigned int size;
+}MEM_INFO;
+typedef struct {
+	MEM_INFO mem;
+	unsigned char *remap_base; /**<*/
+} RW_MEM_INFO;
+
+
+static  unsigned char aes_128_key_buf[] = {
+	0x2b,0x7e,0x15,0x16, 0x28,0xae,0xd2,0xa6, 0xab,0xf7,0x15,0x88, 0x09,0xcf,0x4f,0x3c,
+};
+static  unsigned char plain_aes_128_text[]  = {
+		0x6b,0xc1,0xbe,0xe2, 0x2e,0x40,0x9f,0x96, 0xe9,0x3d,0x7e,0x11, 0x73,0x93,0x17,0x2a,
+		0xae,0x2d,0x8a,0x57, 0x1e,0x03,0xac,0x9c, 0x9e,0xb7,0x6f,0xac, 0x45,0xaf,0x8e,0x51,
+		0x30,0xc8,0x1c,0x46, 0xa3,0x5c,0xe4,0x11, 0xe5,0xfb,0xc1,0x19, 0x1a,0x0a,0x52,0xef,
+		0xf6,0x9f,0x24,0x45, 0xdf,0x4f,0x9b,0x17, 0xad,0x2b,0x41,0x7b, 0xe6,0x6c,0x37,0x10,
+};
+
+static  unsigned char cipher_aes_128_text[]  = {
+		0x3A,0xD7,0x7B,0xB4, 0x0D,0x7A,0x36,0x60, 0xA8,0x9E,0xCA,0xF3, 0x24,0x66,0xEF,0x97,
+		0xf5,0xd3,0xd5,0x85, 0x03,0xb9,0x69,0x9d, 0xe7,0x85,0x89,0x5a, 0x96,0xfd,0xba,0xaf,
+		0x43,0xb1,0xcd,0x7f, 0x59,0x8e,0xce,0x23, 0x88,0x1b,0x00,0xe3, 0xed,0x03,0x06,0x88,
+		0x7b,0x0c,0x78,0x5e, 0x27,0xe8,0xad,0x3f, 0x82,0x23,0x20,0x71, 0x04,0x72,0x5d,0xd4,
+};
+
+int aes_128_ecb_encrypt(char *key_128,RW_MEM_INFO in,
+	RW_MEM_INFO out,unsigned int data_len_align16){
+
+	static char *xbuf;
+	static char *dst_xbuf;
+	static struct crypto_ablkcipher *tfm;
+	static struct ablkcipher_request *req;
+	static malloc_flag = 0;
+	const char *algo;
+	struct scatterlist sg[8];
+	struct scatterlist dst_sg[8];
+	void *data;
+	void *dst_data;
+	struct tcrypt_result wait_result;
+
+//malloc buf...
+	if(malloc_flag != 0){
+		goto work_go;
+	}
+	malloc_flag = 1;
+	xbuf = (void *)__get_free_page(GFP_KERNEL);
+	if (!xbuf) {
+		printk("no pages.\n");
+		return -1;
+	}
+
+	dst_xbuf = (void *)__get_free_page(GFP_KERNEL);
+	if (!dst_xbuf) {
+		free_page((unsigned long)xbuf);
+		printk("no pages.\n");
+		return -1;
+	}
+
+	tfm =
+		crypto_alloc_ablkcipher("ecb-aes-fh",
+					CRYPTO_ALG_TYPE_ABLKCIPHER |
+					CRYPTO_ALG_ASYNC, 0);
+	if (IS_ERR(tfm)) {
+		printk("aes_test: failed to alloc cipher!\n");
+		free_page((unsigned long)xbuf);
+		free_page((unsigned long)dst_xbuf);
+		return -1;
+	}
+	req = ablkcipher_request_alloc(tfm, GFP_KERNEL);
+	if (!req) {
+		printk(KERN_ERR "alg: skcipher: Failed to allocate request "
+			"for %s\n", algo);
+		return -1;
+	}
+
+
+work_go:
+	printk("aes self test get in...\n");
+	printk(" *_* step 1\n");
+
+	printk(" *_* step 2\n");
+	algo = crypto_tfm_alg_driver_name(crypto_ablkcipher_tfm(tfm));
+	init_completion(&wait_result.completion);
+
+	printk(" *_* step 3\n");
+	crypto_ablkcipher_setkey(tfm, (u8 *)key_128, 16);
+
+	printk(" *_* step 4\n");
+
+
+	printk(" *_* step 5\n");
+	ablkcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+					tcrypt_complete, &wait_result);
+
+	printk(" *_* step 6\n");
+	data = xbuf;
+	dst_data = dst_xbuf;
+
+	//encrypt
+	memcpy(data, in.remap_base, data_len_align16);
+	//memset(dst_data, 0, data_len_align16);
+	sg_init_one(&sg[0], data, data_len_align16);
+	sg_init_one(&dst_sg[0], dst_data, data_len_align16);
+
+	printk(" *_* step 7\n");
+	ablkcipher_request_set_crypt(req, sg, dst_sg, data_len_align16, NULL);
+
+	printk(" *_* step 8\n");
+	crypto_ablkcipher_encrypt(req);
+
+	wait_for_completion(&wait_result.completion);
+
+	memcpy(out.remap_base, dst_data, data_len_align16);
+
+	return 0;
+
+}
+#endif
+
+
+
+void fh_aes_self_test_all(void)
+{
+	unsigned char temp_buf[64] = {0};
+	int i;
+	pr_info("aes cbc128 self test go...\n");
+	fh_aes_cbc128_self_test();
+	pr_info("aes ecb256 self test go...\n");
+	fh_aes_ecb256_self_test();
+	pr_info("aes ctr192 self test go...\n");
+	fh_aes_ofb256_self_test();
+	pr_info("aes ofb 256 self test go...\n");
+	fh_aes_ofb256_self_test();
+	pr_info("des ecb self test go...\n");
+	fh_des_ecb_self_test();
+	pr_info("des cbc self test go...\n");
+	fh_des_cbc_self_test();
+	pr_info("des ofb self test go...\n");
+	fh_des_ofb_self_test();
+	pr_info("des tri ecb self test go...\n");
+	fh_des_tri_ecb_self_test();
+	pr_info("des tri cbc self test go...\n");
+	fh_des_tri_cbc_self_test();
+#if(0)
+	RW_MEM_INFO in;
+	RW_MEM_INFO out;
+	in.remap_base = &plain_aes_128_text[0];
+	out.remap_base = &temp_buf[0];
+
+	pr_info("chenjn self test go.....\n");
+
+	aes_128_ecb_encrypt(&aes_128_key_buf[0], in,
+			out,64);
+	for (i = 0; i < sizeof(temp_buf); i++)
+	printk("cipher data[%d]:0x%x\n",i, temp_buf[i]);
+
+#endif
+
+}
+
+#endif
diff -uraN linux-3.0.8/drivers/crypto/Kconfig linux-3.0.8-fh8632-V1.0_20180330/drivers/crypto/Kconfig
--- linux-3.0.8/drivers/crypto/Kconfig	2021-07-14 21:52:01.963130960 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/crypto/Kconfig	2021-07-13 23:40:36.502373506 +0300
@@ -292,4 +292,24 @@
 	  Select this to offload Samsung S5PV210 or S5PC110 from AES
 	  algorithms execution.
 
+config FH_AES
+	tristate "FH AES support"
+	select CRYPTO_BLKCIPHER
+	select CRYPTO_AES
+	select CRYPTO_DES
+#	select CRYPTO_AUTHENC
+#	select CRYPTO_ALGAPI
+	select CRYPTO_CBC
+	select CRYPTO_ECB
+	select CRYPTO_SEQIV
+	
+	help
+	  To compile this driver as a module, choose M here: the module will
+	  be called fh_aes.
+	  
+
+config FH_AES_SELF_TEST
+	bool "fh aes self test"
+	depends on FH_AES 
+
 endif # CRYPTO_HW
diff -uraN linux-3.0.8/drivers/crypto/Makefile linux-3.0.8-fh8632-V1.0_20180330/drivers/crypto/Makefile
--- linux-3.0.8/drivers/crypto/Makefile	2021-07-14 21:52:01.963130960 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/crypto/Makefile	2021-07-13 23:40:36.498373482 +0300
@@ -13,3 +13,6 @@
 obj-$(CONFIG_CRYPTO_DEV_OMAP_AES) += omap-aes.o
 obj-$(CONFIG_CRYPTO_DEV_PICOXCELL) += picoxcell_crypto.o
 obj-$(CONFIG_CRYPTO_DEV_S5P) += s5p-sss.o
+
+obj-$(CONFIG_FH_AES)		+= fh_aes.o
+obj-$(CONFIG_FH_AES_SELF_TEST)		+= fh_aes_test.o
diff -uraN linux-3.0.8/drivers/dma/dmaengine.c linux-3.0.8-fh8632-V1.0_20180330/drivers/dma/dmaengine.c
--- linux-3.0.8/drivers/dma/dmaengine.c	2021-07-14 21:52:01.975130995 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/dma/dmaengine.c	2021-07-13 23:40:34.834363488 +0300
@@ -45,6 +45,9 @@
  * See Documentation/dmaengine.txt for more details
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/dma-mapping.h>
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/mm.h>
@@ -61,9 +64,9 @@
 #include <linux/slab.h>
 
 static DEFINE_MUTEX(dma_list_mutex);
+static DEFINE_IDR(dma_idr);
 static LIST_HEAD(dma_device_list);
 static long dmaengine_ref_count;
-static struct idr dma_idr;
 
 /* --- sysfs implementation --- */
 
@@ -170,7 +173,8 @@
 #define dma_device_satisfies_mask(device, mask) \
 	__dma_device_satisfies_mask((device), &(mask))
 static int
-__dma_device_satisfies_mask(struct dma_device *device, dma_cap_mask_t *want)
+__dma_device_satisfies_mask(struct dma_device *device,
+			    const dma_cap_mask_t *want)
 {
 	dma_cap_mask_t has;
 
@@ -260,10 +264,13 @@
 	do {
 		status = dma_async_is_tx_complete(chan, cookie, NULL, NULL);
 		if (time_after_eq(jiffies, dma_sync_wait_timeout)) {
-			printk(KERN_ERR "dma_sync_wait_timeout!\n");
+			pr_err("%s: timeout!\n", __func__);
 			return DMA_ERROR;
 		}
-	} while (status == DMA_IN_PROGRESS);
+		if (status != DMA_IN_PROGRESS)
+			break;
+		cpu_relax();
+	} while (1);
 
 	return status;
 }
@@ -311,7 +318,7 @@
 	}
 
 	if (err) {
-		pr_err("dmaengine: initialization failure\n");
+		pr_err("initialization failure\n");
 		for_each_dma_cap_mask(cap, dma_cap_mask_all)
 			if (channel_table[cap])
 				free_percpu(channel_table[cap]);
@@ -331,6 +338,20 @@
 }
 EXPORT_SYMBOL(dma_find_channel);
 
+/*
+ * net_dma_find_channel - find a channel for net_dma
+ * net_dma has alignment requirements
+ */
+struct dma_chan *net_dma_find_channel(void)
+{
+	struct dma_chan *chan = dma_find_channel(DMA_MEMCPY);
+	if (chan && !is_dma_copy_aligned(chan->device, 1, 1, 1))
+		return NULL;
+
+	return chan;
+}
+EXPORT_SYMBOL(net_dma_find_channel);
+
 /**
  * dma_issue_pending_all - flush all pending operations across all channels
  */
@@ -442,7 +463,8 @@
 		}
 }
 
-static struct dma_chan *private_candidate(dma_cap_mask_t *mask, struct dma_device *dev,
+static struct dma_chan *private_candidate(const dma_cap_mask_t *mask,
+					  struct dma_device *dev,
 					  dma_filter_fn fn, void *fn_param)
 {
 	struct dma_chan *chan;
@@ -484,7 +506,8 @@
  * @fn: optional callback to disposition available channels
  * @fn_param: opaque parameter to pass to dma_filter_fn
  */
-struct dma_chan *__dma_request_channel(dma_cap_mask_t *mask, dma_filter_fn fn, void *fn_param)
+struct dma_chan *__dma_request_channel(const dma_cap_mask_t *mask,
+				       dma_filter_fn fn, void *fn_param)
 {
 	struct dma_device *device, *_d;
 	struct dma_chan *chan = NULL;
@@ -505,12 +528,12 @@
 			err = dma_chan_get(chan);
 
 			if (err == -ENODEV) {
-				pr_debug("%s: %s module removed\n", __func__,
-					 dma_chan_name(chan));
+				pr_debug("%s: %s module removed\n",
+					 __func__, dma_chan_name(chan));
 				list_del_rcu(&device->global_node);
 			} else if (err)
-				pr_err("dmaengine: failed to get %s: (%d)\n",
-				       dma_chan_name(chan), err);
+				pr_debug("%s: failed to get %s: (%d)\n",
+					 __func__, dma_chan_name(chan), err);
 			else
 				break;
 			if (--device->privatecnt == 0)
@@ -520,13 +543,34 @@
 	}
 	mutex_unlock(&dma_list_mutex);
 
-	pr_debug("%s: %s (%s)\n", __func__, chan ? "success" : "fail",
+	pr_debug("%s: %s (%s)\n",
+		 __func__,
+		 chan ? "success" : "fail",
 		 chan ? dma_chan_name(chan) : NULL);
 
 	return chan;
 }
 EXPORT_SYMBOL_GPL(__dma_request_channel);
+#if 0
+/**
+ * dma_request_slave_channel - try to allocate an exclusive slave channel
+ * @dev:	pointer to client device structure
+ * @name:	slave channel name
+ */
+struct dma_chan *dma_request_slave_channel(struct device *dev, const char *name)
+{
+	/* If device-tree is present get slave info from here */
+	if (dev->of_node)
+		return of_dma_request_slave_channel(dev->of_node, name);
+
+	/* If device was enumerated by ACPI get slave info from here */
+	if (ACPI_HANDLE(dev))
+		return acpi_dma_request_slave_chan_by_name(dev, name);
 
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(dma_request_slave_channel);
+#endif
 void dma_release_channel(struct dma_chan *chan)
 {
 	mutex_lock(&dma_list_mutex);
@@ -563,8 +607,8 @@
 				list_del_rcu(&device->global_node);
 				break;
 			} else if (err)
-				pr_err("dmaengine: failed to get %s: (%d)\n",
-				       dma_chan_name(chan), err);
+				pr_debug("%s: failed to get %s: (%d)\n",
+				       __func__, dma_chan_name(chan), err);
 		}
 	}
 
@@ -647,19 +691,19 @@
 static int get_dma_id(struct dma_device *device)
 {
 	int rc;
+	int dma_id;
 
- idr_retry:
-	if (!idr_pre_get(&dma_idr, GFP_KERNEL))
-		return -ENOMEM;
 	mutex_lock(&dma_list_mutex);
-	rc = idr_get_new(&dma_idr, NULL, &device->dev_id);
-	mutex_unlock(&dma_list_mutex);
-	if (rc == -EAGAIN)
-		goto idr_retry;
-	else if (rc != 0)
-		return rc;
 
-	return 0;
+    if (!idr_pre_get(&dma_idr, GFP_KERNEL))
+        return -ENOMEM;
+
+    rc = idr_get_new(&dma_idr, NULL, &dma_id);
+	if (rc >= 0)
+		device->dev_id = dma_id;
+
+	mutex_unlock(&dma_list_mutex);
+	return rc < 0 ? rc : 0;
 }
 
 /**
@@ -692,12 +736,12 @@
 		!device->device_prep_dma_interrupt);
 	BUG_ON(dma_has_cap(DMA_SG, device->cap_mask) &&
 		!device->device_prep_dma_sg);
-	BUG_ON(dma_has_cap(DMA_SLAVE, device->cap_mask) &&
-		!device->device_prep_slave_sg);
 	BUG_ON(dma_has_cap(DMA_CYCLIC, device->cap_mask) &&
 		!device->device_prep_dma_cyclic);
 	BUG_ON(dma_has_cap(DMA_SLAVE, device->cap_mask) &&
 		!device->device_control);
+	BUG_ON(dma_has_cap(DMA_INTERLEAVE, device->cap_mask) &&
+		!device->device_prep_interleaved_dma);
 
 	BUG_ON(!device->device_alloc_chan_resources);
 	BUG_ON(!device->device_free_chan_resources);
@@ -1000,7 +1044,7 @@
 	while (tx->cookie == -EBUSY) {
 		if (time_after_eq(jiffies, dma_sync_wait_timeout)) {
 			pr_err("%s timeout waiting for descriptor submission\n",
-				__func__);
+			       __func__);
 			return DMA_ERROR;
 		}
 		cpu_relax();
@@ -1049,8 +1093,6 @@
 
 static int __init dma_bus_init(void)
 {
-	idr_init(&dma_idr);
-	mutex_init(&dma_list_mutex);
 	return class_register(&dma_devclass);
 }
 arch_initcall(dma_bus_init);
diff -uraN linux-3.0.8/drivers/dma/dmaengine.h linux-3.0.8-fh8632-V1.0_20180330/drivers/dma/dmaengine.h
--- linux-3.0.8/drivers/dma/dmaengine.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/dma/dmaengine.h	2021-07-13 23:40:34.830363463 +0300
@@ -0,0 +1,89 @@
+/*
+ * The contents of this file are private to DMA engine drivers, and is not
+ * part of the API to be used by DMA engine users.
+ */
+#ifndef DMAENGINE_H
+#define DMAENGINE_H
+
+#include <linux/bug.h>
+#include <linux/dmaengine.h>
+
+/**
+ * dma_cookie_init - initialize the cookies for a DMA channel
+ * @chan: dma channel to initialize
+ */
+static inline void dma_cookie_init(struct dma_chan *chan)
+{
+	chan->cookie = DMA_MIN_COOKIE;
+	chan->completed_cookie = DMA_MIN_COOKIE;
+}
+
+/**
+ * dma_cookie_assign - assign a DMA engine cookie to the descriptor
+ * @tx: descriptor needing cookie
+ *
+ * Assign a unique non-zero per-channel cookie to the descriptor.
+ * Note: caller is expected to hold a lock to prevent concurrency.
+ */
+static inline dma_cookie_t dma_cookie_assign(struct dma_async_tx_descriptor *tx)
+{
+	struct dma_chan *chan = tx->chan;
+	dma_cookie_t cookie;
+
+	cookie = chan->cookie + 1;
+	if (cookie < DMA_MIN_COOKIE)
+		cookie = DMA_MIN_COOKIE;
+	tx->cookie = chan->cookie = cookie;
+
+	return cookie;
+}
+
+/**
+ * dma_cookie_complete - complete a descriptor
+ * @tx: descriptor to complete
+ *
+ * Mark this descriptor complete by updating the channels completed
+ * cookie marker.  Zero the descriptors cookie to prevent accidental
+ * repeated completions.
+ *
+ * Note: caller is expected to hold a lock to prevent concurrency.
+ */
+static inline void dma_cookie_complete(struct dma_async_tx_descriptor *tx)
+{
+	BUG_ON(tx->cookie < DMA_MIN_COOKIE);
+	tx->chan->completed_cookie = tx->cookie;
+	tx->cookie = 0;
+}
+
+/**
+ * dma_cookie_status - report cookie status
+ * @chan: dma channel
+ * @cookie: cookie we are interested in
+ * @state: dma_tx_state structure to return last/used cookies
+ *
+ * Report the status of the cookie, filling in the state structure if
+ * non-NULL.  No locking is required.
+ */
+static inline enum dma_status dma_cookie_status(struct dma_chan *chan,
+	dma_cookie_t cookie, struct dma_tx_state *state)
+{
+	dma_cookie_t used, complete;
+
+	used = chan->cookie;
+	complete = chan->completed_cookie;
+	barrier();
+	if (state) {
+		state->last = complete;
+		state->used = used;
+		state->residue = 0;
+	}
+	return dma_async_is_complete(cookie, complete, used);
+}
+
+static inline void dma_set_residue(struct dma_tx_state *state, u32 residue)
+{
+	if (state)
+		state->residue = residue;
+}
+
+#endif
diff -uraN linux-3.0.8/drivers/dma/dw_dmac_regs.h linux-3.0.8-fh8632-V1.0_20180330/drivers/dma/dw_dmac_regs.h
--- linux-3.0.8/drivers/dma/dw_dmac_regs.h	2021-07-14 21:52:01.975130995 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/dma/dw_dmac_regs.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,235 +0,0 @@
-/*
- * Driver for the Synopsys DesignWare AHB DMA Controller
- *
- * Copyright (C) 2005-2007 Atmel Corporation
- * Copyright (C) 2010-2011 ST Microelectronics
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include <linux/dw_dmac.h>
-
-#define DW_DMA_MAX_NR_CHANNELS	8
-
-/*
- * Redefine this macro to handle differences between 32- and 64-bit
- * addressing, big vs. little endian, etc.
- */
-#define DW_REG(name)		u32 name; u32 __pad_##name
-
-/* Hardware register definitions. */
-struct dw_dma_chan_regs {
-	DW_REG(SAR);		/* Source Address Register */
-	DW_REG(DAR);		/* Destination Address Register */
-	DW_REG(LLP);		/* Linked List Pointer */
-	u32	CTL_LO;		/* Control Register Low */
-	u32	CTL_HI;		/* Control Register High */
-	DW_REG(SSTAT);
-	DW_REG(DSTAT);
-	DW_REG(SSTATAR);
-	DW_REG(DSTATAR);
-	u32	CFG_LO;		/* Configuration Register Low */
-	u32	CFG_HI;		/* Configuration Register High */
-	DW_REG(SGR);
-	DW_REG(DSR);
-};
-
-struct dw_dma_irq_regs {
-	DW_REG(XFER);
-	DW_REG(BLOCK);
-	DW_REG(SRC_TRAN);
-	DW_REG(DST_TRAN);
-	DW_REG(ERROR);
-};
-
-struct dw_dma_regs {
-	/* per-channel registers */
-	struct dw_dma_chan_regs	CHAN[DW_DMA_MAX_NR_CHANNELS];
-
-	/* irq handling */
-	struct dw_dma_irq_regs	RAW;		/* r */
-	struct dw_dma_irq_regs	STATUS;		/* r (raw & mask) */
-	struct dw_dma_irq_regs	MASK;		/* rw (set = irq enabled) */
-	struct dw_dma_irq_regs	CLEAR;		/* w (ack, affects "raw") */
-
-	DW_REG(STATUS_INT);			/* r */
-
-	/* software handshaking */
-	DW_REG(REQ_SRC);
-	DW_REG(REQ_DST);
-	DW_REG(SGL_REQ_SRC);
-	DW_REG(SGL_REQ_DST);
-	DW_REG(LAST_SRC);
-	DW_REG(LAST_DST);
-
-	/* miscellaneous */
-	DW_REG(CFG);
-	DW_REG(CH_EN);
-	DW_REG(ID);
-	DW_REG(TEST);
-
-	/* optional encoded params, 0x3c8..0x3 */
-};
-
-/* Bitfields in CTL_LO */
-#define DWC_CTLL_INT_EN		(1 << 0)	/* irqs enabled? */
-#define DWC_CTLL_DST_WIDTH(n)	((n)<<1)	/* bytes per element */
-#define DWC_CTLL_SRC_WIDTH(n)	((n)<<4)
-#define DWC_CTLL_DST_INC	(0<<7)		/* DAR update/not */
-#define DWC_CTLL_DST_DEC	(1<<7)
-#define DWC_CTLL_DST_FIX	(2<<7)
-#define DWC_CTLL_SRC_INC	(0<<7)		/* SAR update/not */
-#define DWC_CTLL_SRC_DEC	(1<<9)
-#define DWC_CTLL_SRC_FIX	(2<<9)
-#define DWC_CTLL_DST_MSIZE(n)	((n)<<11)	/* burst, #elements */
-#define DWC_CTLL_SRC_MSIZE(n)	((n)<<14)
-#define DWC_CTLL_S_GATH_EN	(1 << 17)	/* src gather, !FIX */
-#define DWC_CTLL_D_SCAT_EN	(1 << 18)	/* dst scatter, !FIX */
-#define DWC_CTLL_FC(n)		((n) << 20)
-#define DWC_CTLL_FC_M2M		(0 << 20)	/* mem-to-mem */
-#define DWC_CTLL_FC_M2P		(1 << 20)	/* mem-to-periph */
-#define DWC_CTLL_FC_P2M		(2 << 20)	/* periph-to-mem */
-#define DWC_CTLL_FC_P2P		(3 << 20)	/* periph-to-periph */
-/* plus 4 transfer types for peripheral-as-flow-controller */
-#define DWC_CTLL_DMS(n)		((n)<<23)	/* dst master select */
-#define DWC_CTLL_SMS(n)		((n)<<25)	/* src master select */
-#define DWC_CTLL_LLP_D_EN	(1 << 27)	/* dest block chain */
-#define DWC_CTLL_LLP_S_EN	(1 << 28)	/* src block chain */
-
-/* Bitfields in CTL_HI */
-#define DWC_CTLH_DONE		0x00001000
-#define DWC_CTLH_BLOCK_TS_MASK	0x00000fff
-
-/* Bitfields in CFG_LO. Platform-configurable bits are in <linux/dw_dmac.h> */
-#define DWC_CFGL_CH_PRIOR_MASK	(0x7 << 5)	/* priority mask */
-#define DWC_CFGL_CH_PRIOR(x)	((x) << 5)	/* priority */
-#define DWC_CFGL_CH_SUSP	(1 << 8)	/* pause xfer */
-#define DWC_CFGL_FIFO_EMPTY	(1 << 9)	/* pause xfer */
-#define DWC_CFGL_HS_DST		(1 << 10)	/* handshake w/dst */
-#define DWC_CFGL_HS_SRC		(1 << 11)	/* handshake w/src */
-#define DWC_CFGL_MAX_BURST(x)	((x) << 20)
-#define DWC_CFGL_RELOAD_SAR	(1 << 30)
-#define DWC_CFGL_RELOAD_DAR	(1 << 31)
-
-/* Bitfields in CFG_HI. Platform-configurable bits are in <linux/dw_dmac.h> */
-#define DWC_CFGH_DS_UPD_EN	(1 << 5)
-#define DWC_CFGH_SS_UPD_EN	(1 << 6)
-
-/* Bitfields in SGR */
-#define DWC_SGR_SGI(x)		((x) << 0)
-#define DWC_SGR_SGC(x)		((x) << 20)
-
-/* Bitfields in DSR */
-#define DWC_DSR_DSI(x)		((x) << 0)
-#define DWC_DSR_DSC(x)		((x) << 20)
-
-/* Bitfields in CFG */
-#define DW_CFG_DMA_EN		(1 << 0)
-
-#define DW_REGLEN		0x400
-
-enum dw_dmac_flags {
-	DW_DMA_IS_CYCLIC = 0,
-};
-
-struct dw_dma_chan {
-	struct dma_chan		chan;
-	void __iomem		*ch_regs;
-	u8			mask;
-	u8			priority;
-	bool			paused;
-
-	spinlock_t		lock;
-
-	/* these other elements are all protected by lock */
-	unsigned long		flags;
-	dma_cookie_t		completed;
-	struct list_head	active_list;
-	struct list_head	queue;
-	struct list_head	free_list;
-	struct dw_cyclic_desc	*cdesc;
-
-	unsigned int		descs_allocated;
-};
-
-static inline struct dw_dma_chan_regs __iomem *
-__dwc_regs(struct dw_dma_chan *dwc)
-{
-	return dwc->ch_regs;
-}
-
-#define channel_readl(dwc, name) \
-	readl(&(__dwc_regs(dwc)->name))
-#define channel_writel(dwc, name, val) \
-	writel((val), &(__dwc_regs(dwc)->name))
-
-static inline struct dw_dma_chan *to_dw_dma_chan(struct dma_chan *chan)
-{
-	return container_of(chan, struct dw_dma_chan, chan);
-}
-
-struct dw_dma {
-	struct dma_device	dma;
-	void __iomem		*regs;
-	struct tasklet_struct	tasklet;
-	struct clk		*clk;
-
-	u8			all_chan_mask;
-
-	struct dw_dma_chan	chan[0];
-};
-
-static inline struct dw_dma_regs __iomem *__dw_regs(struct dw_dma *dw)
-{
-	return dw->regs;
-}
-
-#define dma_readl(dw, name) \
-	readl(&(__dw_regs(dw)->name))
-#define dma_writel(dw, name, val) \
-	writel((val), &(__dw_regs(dw)->name))
-
-#define channel_set_bit(dw, reg, mask) \
-	dma_writel(dw, reg, ((mask) << 8) | (mask))
-#define channel_clear_bit(dw, reg, mask) \
-	dma_writel(dw, reg, ((mask) << 8) | 0)
-
-static inline struct dw_dma *to_dw_dma(struct dma_device *ddev)
-{
-	return container_of(ddev, struct dw_dma, dma);
-}
-
-/* LLI == Linked List Item; a.k.a. DMA block descriptor */
-struct dw_lli {
-	/* values that are not changed by hardware */
-	dma_addr_t	sar;
-	dma_addr_t	dar;
-	dma_addr_t	llp;		/* chain to next lli */
-	u32		ctllo;
-	/* values that may get written back: */
-	u32		ctlhi;
-	/* sstat and dstat can snapshot peripheral register state.
-	 * silicon config may discard either or both...
-	 */
-	u32		sstat;
-	u32		dstat;
-};
-
-struct dw_desc {
-	/* FIRST values the hardware uses */
-	struct dw_lli			lli;
-
-	/* THEN values for driver housekeeping */
-	struct list_head		desc_node;
-	struct list_head		tx_list;
-	struct dma_async_tx_descriptor	txd;
-	size_t				len;
-};
-
-static inline struct dw_desc *
-txd_to_dw_desc(struct dma_async_tx_descriptor *txd)
-{
-	return container_of(txd, struct dw_desc, txd);
-}
diff -uraN linux-3.0.8/drivers/dma/fh_dmac.c linux-3.0.8-fh8632-V1.0_20180330/drivers/dma/fh_dmac.c
--- linux-3.0.8/drivers/dma/fh_dmac.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/dma/fh_dmac.c	2021-07-13 23:40:34.830363463 +0300
@@ -0,0 +1,1846 @@
+/*
+ * Core driver for the Synopsys DesignWare DMA Controller
+ *
+ * Copyright (C) 2007-2008 Atmel Corporation
+ * Copyright (C) 2010-2011 ST Microelectronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dmaengine.h>
+#include "dmaengine.h"
+#include <mach/fh_dmac_regs.h>
+
+/*
+ * This supports the Synopsys "DesignWare AHB Central DMA Controller",
+ * (FH_ahb_dmac) which is used with various AMBA 2.0 systems (not all
+ * of which use ARM any more).  See the "Databook" from Synopsys for
+ * information beyond what licensees probably provide.
+ *
+ * The driver has currently been tested only with the Atmel AT32AP7000,
+ * which does not support descriptor writeback.
+ */
+
+static inline unsigned int fhc_get_dms(struct fh_dma_slave *slave)
+{
+	return slave ? slave->dst_master : 0;
+}
+
+static inline unsigned int fhc_get_sms(struct fh_dma_slave *slave)
+{
+	return slave ? slave->src_master : 1;
+}
+
+static inline void fhc_set_masters(struct fh_dma_chan *fhc)
+{
+	struct fh_dma *fhd = to_fh_dma(fhc->chan.device);
+	struct fh_dma_slave *dms = fhc->chan.private;
+	unsigned char mmax = fhd->nr_masters - 1;
+
+	if (fhc->request_line == ~0) {
+		fhc->src_master = min_t(unsigned char, mmax, fhc_get_sms(dms));
+		fhc->dst_master = min_t(unsigned char, mmax, fhc_get_dms(dms));
+	}
+}
+
+#define FHC_DEFAULT_CTLLO(_chan) ({				\
+		struct fh_dma_chan *_fhc = to_fh_dma_chan(_chan);	\
+		struct dma_slave_config	*_sconfig = &_fhc->dma_sconfig;	\
+		bool _is_slave = is_slave_direction(_fhc->direction);	\
+		u8 _smsize = _is_slave ? _sconfig->src_maxburst :	\
+			FH_DMA_MSIZE_16;			\
+		u8 _dmsize = _is_slave ? _sconfig->dst_maxburst :	\
+			FH_DMA_MSIZE_16;			\
+								\
+		(FHC_CTLL_DST_MSIZE(_dmsize)			\
+		 | FHC_CTLL_SRC_MSIZE(_smsize)			\
+		 | FHC_CTLL_LLP_D_EN				\
+		 | FHC_CTLL_LLP_S_EN				\
+		 | FHC_CTLL_DMS(_fhc->dst_master)		\
+		 | FHC_CTLL_SMS(_fhc->src_master));		\
+	})
+
+#define FHC_DEFAULT_CTLLO_OLD(private) ({				\
+		struct fh_dma_slave *__slave = (private);	\
+		int dms = __slave ? __slave->dst_master : 0;	\
+		int sms = __slave ? __slave->src_master : 1;	\
+		u8 smsize = __slave ? __slave->src_msize : FH_DMA_MSIZE_16; \
+		u8 dmsize = __slave ? __slave->dst_msize : FH_DMA_MSIZE_16; \
+								\
+		(FHC_CTLL_DST_MSIZE(dmsize)			\
+		 | FHC_CTLL_SRC_MSIZE(smsize)			\
+		 | FHC_CTLL_LLP_D_EN				\
+		 | FHC_CTLL_LLP_S_EN				\
+		 | FHC_CTLL_DMS(dms)				\
+		 | FHC_CTLL_SMS(sms));				\
+	})
+
+/*
+ * Number of descriptors to allocate for each channel. This should be
+ * made configurable somehow; preferably, the clients (at least the
+ * ones using slave transfers) should be able to give us a hint.
+ */
+#define NR_DESCS_PER_CHANNEL	4096
+
+/*----------------------------------------------------------------------*/
+
+static struct device *chan2dev(struct dma_chan *chan)
+{
+	return &chan->dev->device;
+}
+static struct device *chan2parent(struct dma_chan *chan)
+{
+	return chan->dev->device.parent;
+}
+
+static struct fh_desc *fhc_first_active(struct fh_dma_chan *fhc)
+{
+	return to_fh_desc(fhc->active_list.next);
+}
+
+static struct fh_desc *fhc_desc_get(struct fh_dma_chan *fhc)
+{
+	struct fh_desc *desc, *_desc;
+	struct fh_desc *ret = NULL;
+	unsigned int i = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&fhc->lock, flags);
+	list_for_each_entry_safe(desc, _desc, &fhc->free_list, desc_node) {
+		i++;
+		if (async_tx_test_ack(&desc->txd)) {
+			list_del(&desc->desc_node);
+			ret = desc;
+			break;
+		}
+		dev_dbg(chan2dev(&fhc->chan), "desc %p not ACKed\n", desc);
+	}
+	spin_unlock_irqrestore(&fhc->lock, flags);
+
+	dev_vdbg(chan2dev(&fhc->chan), "scanned %u descriptors on freelist\n", i);
+
+	return ret;
+}
+
+/*
+ * Move a descriptor, including any children, to the free list.
+ * `desc' must not be on any lists.
+ */
+static void fhc_desc_put(struct fh_dma_chan *fhc, struct fh_desc *desc)
+{
+	unsigned long flags;
+
+	if (desc) {
+		struct fh_desc *child;
+
+		spin_lock_irqsave(&fhc->lock, flags);
+		list_for_each_entry(child, &desc->tx_list, desc_node)
+			dev_vdbg(chan2dev(&fhc->chan),
+					"moving child desc %p to freelist\n",
+					child);
+		list_splice_init(&desc->tx_list, &fhc->free_list);
+		dev_vdbg(chan2dev(&fhc->chan), "moving desc %p to freelist\n", desc);
+		list_add(&desc->desc_node, &fhc->free_list);
+		spin_unlock_irqrestore(&fhc->lock, flags);
+	}
+}
+
+static void fhc_initialize(struct fh_dma_chan *fhc)
+{
+	struct fh_dma *fhd = to_fh_dma(fhc->chan.device);
+	struct fh_dma_slave *dms = fhc->chan.private;
+	u32 cfghi = FHC_CFGH_FIFO_MODE;
+	u32 cfglo = FHC_CFGL_CH_PRIOR(fhc->priority);
+
+	if (fhc->initialized == true)
+		return;
+
+	if (dms) {
+		cfghi = dms->cfg_hi;
+		cfglo |= dms->cfg_lo & ~FHC_CFGL_CH_PRIOR_MASK;
+	} else {
+		if (fhc->direction == DMA_MEM_TO_DEV)
+			cfghi = FHC_CFGH_DST_PER(fhc->request_line);
+		else if (fhc->direction == DMA_DEV_TO_MEM)
+			cfghi = FHC_CFGH_SRC_PER(fhc->request_line);
+	}
+
+	channel_writel(fhc, CFG_LO, cfglo);
+	channel_writel(fhc, CFG_HI, cfghi);
+
+	/* Enable interrupts */
+	channel_set_bit(fhd, MASK.XFER, fhc->mask);
+	channel_set_bit(fhd, MASK.BLOCK, fhc->mask);
+	channel_set_bit(fhd, MASK.ERROR, fhc->mask);
+
+	fhc->initialized = true;
+}
+
+/*----------------------------------------------------------------------*/
+
+static inline unsigned int fhc_fast_fls(unsigned long long v)
+{
+	/*
+	 * We can be a lot more clever here, but this should take care
+	 * of the most common optimization.
+	 */
+	if (!(v & 7))
+		return 3;
+	else if (!(v & 3))
+		return 2;
+	else if (!(v & 1))
+		return 1;
+	return 0;
+}
+
+static inline void fhc_dump_chan_regs(struct fh_dma_chan *fhc)
+{
+	dev_err(chan2dev(&fhc->chan),
+		"  SAR: 0x%x DAR: 0x%x LLP: 0x%x CTL: 0x%x:%08x\n",
+		channel_readl(fhc, SAR),
+		channel_readl(fhc, DAR),
+		channel_readl(fhc, LLP),
+		channel_readl(fhc, CTL_HI),
+		channel_readl(fhc, CTL_LO));
+}
+
+static inline void fhc_chan_disable(struct fh_dma *fhd, struct fh_dma_chan *fhc)
+{
+	channel_clear_bit(fhd, CH_EN, fhc->mask);
+	while (dma_readl(fhd, CH_EN) & fhc->mask)
+		cpu_relax();
+}
+
+/*----------------------------------------------------------------------*/
+
+/* Perform single block transfer */
+static inline void fhc_do_single_block(struct fh_dma_chan *fhc,
+				       struct fh_desc *desc)
+{
+	struct fh_dma	*fhd = to_fh_dma(fhc->chan.device);
+	u32		ctllo;
+
+	/* Software emulation of LLP mode relies on interrupts to continue
+	 * multi block transfer. */
+	ctllo = desc->lli.ctllo | FHC_CTLL_INT_EN;
+
+	channel_writel(fhc, SAR, desc->lli.sar);
+	channel_writel(fhc, DAR, desc->lli.dar);
+	channel_writel(fhc, CTL_LO, ctllo);
+	channel_writel(fhc, CTL_HI, desc->lli.ctlhi);
+	channel_set_bit(fhd, CH_EN, fhc->mask);
+
+	/* Move pointer to next descriptor */
+	fhc->tx_node_active = fhc->tx_node_active->next;
+}
+
+/* Called with fhc->lock held and bh disabled */
+static void fhc_dostart(struct fh_dma_chan *fhc, struct fh_desc *first)
+{
+	struct fh_dma	*fhd = to_fh_dma(fhc->chan.device);
+	unsigned long	was_soft_llp;
+
+	/* ASSERT:  channel is idle */
+	if (dma_readl(fhd, CH_EN) & fhc->mask) {
+		dev_err(chan2dev(&fhc->chan),
+			"BUG: Attempted to start non-idle channel\n");
+		fhc_dump_chan_regs(fhc);
+
+		/* The tasklet will hopefully advance the queue... */
+		return;
+	}
+
+	if (fhc->nollp) {
+		was_soft_llp = test_and_set_bit(FH_DMA_IS_SOFT_LLP,
+						&fhc->flags);
+		if (was_soft_llp) {
+			dev_err(chan2dev(&fhc->chan),
+				"BUG: Attempted to start new LLP transfer "
+				"inside ongoing one\n");
+			return;
+		}
+
+		fhc_initialize(fhc);
+
+		fhc->residue = first->total_len;
+		fhc->tx_node_active = &first->tx_list;
+
+		/* Submit first block */
+		fhc_do_single_block(fhc, first);
+
+		return;
+	}
+
+	fhc_initialize(fhc);
+
+	channel_writel(fhc, LLP, first->txd.phys);
+	channel_writel(fhc, CTL_LO,
+			FHC_CTLL_LLP_D_EN | FHC_CTLL_LLP_S_EN);
+	channel_writel(fhc, CTL_HI, 0);
+	channel_set_bit(fhd, CH_EN, fhc->mask);
+}
+
+/*----------------------------------------------------------------------*/
+
+static void
+fhc_descriptor_complete(struct fh_dma_chan *fhc, struct fh_desc *desc,
+		bool callback_required)
+{
+	dma_async_tx_callback		callback = NULL;
+	void				*param = NULL;
+	struct dma_async_tx_descriptor	*txd = &desc->txd;
+	struct fh_desc			*child;
+	unsigned long			flags;
+
+	dev_vdbg(chan2dev(&fhc->chan), "descriptor %u complete\n", txd->cookie);
+
+	spin_lock_irqsave(&fhc->lock, flags);
+	dma_cookie_complete(txd);
+	if (callback_required) {
+		callback = txd->callback;
+		param = txd->callback_param;
+	}
+
+	/* async_tx_ack */
+	list_for_each_entry(child, &desc->tx_list, desc_node)
+		async_tx_ack(&child->txd);
+	async_tx_ack(&desc->txd);
+
+	list_splice_init(&desc->tx_list, &fhc->free_list);
+	list_move(&desc->desc_node, &fhc->free_list);
+
+	if (!is_slave_direction(fhc->direction)) {
+		struct device *parent = chan2parent(&fhc->chan);
+		if (!(txd->flags & DMA_COMPL_SKIP_DEST_UNMAP)) {
+			if (txd->flags & DMA_COMPL_DEST_UNMAP_SINGLE)
+				dma_unmap_single(parent, desc->lli.dar,
+					desc->total_len, DMA_FROM_DEVICE);
+			else
+				dma_unmap_page(parent, desc->lli.dar,
+					desc->total_len, DMA_FROM_DEVICE);
+		}
+		if (!(txd->flags & DMA_COMPL_SKIP_SRC_UNMAP)) {
+			if (txd->flags & DMA_COMPL_SRC_UNMAP_SINGLE)
+				dma_unmap_single(parent, desc->lli.sar,
+					desc->total_len, DMA_TO_DEVICE);
+			else
+				dma_unmap_page(parent, desc->lli.sar,
+					desc->total_len, DMA_TO_DEVICE);
+		}
+	}
+
+	spin_unlock_irqrestore(&fhc->lock, flags);
+
+	if (callback)
+		callback(param);
+}
+
+static void fhc_complete_all(struct fh_dma *fhd, struct fh_dma_chan *fhc)
+{
+	struct fh_desc *desc, *_desc;
+	LIST_HEAD(list);
+	unsigned long flags;
+
+	spin_lock_irqsave(&fhc->lock, flags);
+	if (dma_readl(fhd, CH_EN) & fhc->mask) {
+		dev_err(chan2dev(&fhc->chan),
+			"BUG: XFER bit set, but channel not idle!\n");
+
+		/* Try to continue after resetting the channel... */
+		fhc_chan_disable(fhd, fhc);
+	}
+
+	/*
+	 * Submit queued descriptors ASAP, i.e. before we go through
+	 * the completed ones.
+	 */
+	list_splice_init(&fhc->active_list, &list);
+	if (!list_empty(&fhc->queue)) {
+		list_move(fhc->queue.next, &fhc->active_list);
+		fhc_dostart(fhc, fhc_first_active(fhc));
+	}
+
+	spin_unlock_irqrestore(&fhc->lock, flags);
+
+	list_for_each_entry_safe(desc, _desc, &list, desc_node)
+		fhc_descriptor_complete(fhc, desc, true);
+}
+
+/* Returns how many bytes were already received from source */
+static inline u32 fhc_get_sent(struct fh_dma_chan *fhc)
+{
+	u32 ctlhi = channel_readl(fhc, CTL_HI);
+	u32 ctllo = channel_readl(fhc, CTL_LO);
+
+	return (ctlhi & FHC_CTLH_BLOCK_TS_MASK) * (1 << (ctllo >> 4 & 7));
+}
+
+static void fhc_scan_descriptors(struct fh_dma *fhd, struct fh_dma_chan *fhc)
+{
+	dma_addr_t llp;
+	struct fh_desc *desc, *_desc;
+	struct fh_desc *child;
+	u32 status_xfer;
+	unsigned long flags;
+
+	spin_lock_irqsave(&fhc->lock, flags);
+	/*
+	 * Clear block interrupt flag before scanning so that we don't
+	 * miss any, and read LLP before RAW_XFER to ensure it is
+	 * valid if we decide to scan the list.
+	 */
+	dma_writel(fhd, CLEAR.BLOCK, fhc->mask);
+	llp = channel_readl(fhc, LLP);
+	status_xfer = dma_readl(fhd, RAW.XFER);
+
+	if (status_xfer & fhc->mask) {
+		/* Everything we've submitted is done */
+		dma_writel(fhd, CLEAR.XFER, fhc->mask);
+		if (test_bit(FH_DMA_IS_SOFT_LLP, &fhc->flags)) {
+			struct list_head *head, *active = fhc->tx_node_active;
+
+			/*
+			 * We are inside first active descriptor.
+			 * Otherwise something is really wrong.
+			 */
+			desc = fhc_first_active(fhc);
+
+			head = &desc->tx_list;
+			if (active != head) {
+				/* Update desc to reflect last sent one */
+				if (active != head->next)
+					desc = to_fh_desc(active->prev);
+
+				fhc->residue -= desc->len;
+
+				child = to_fh_desc(active);
+
+				/* Submit next block */
+				fhc_do_single_block(fhc, child);
+
+				spin_unlock_irqrestore(&fhc->lock, flags);
+				return;
+			}
+
+			/* We are done here */
+			clear_bit(FH_DMA_IS_SOFT_LLP, &fhc->flags);
+		}
+		fhc->residue = 0;
+
+		spin_unlock_irqrestore(&fhc->lock, flags);
+
+		fhc_complete_all(fhd, fhc);
+		return;
+	}
+
+	if (list_empty(&fhc->active_list)) {
+		fhc->residue = 0;
+		spin_unlock_irqrestore(&fhc->lock, flags);
+		return;
+	}
+
+	if (test_bit(FH_DMA_IS_SOFT_LLP, &fhc->flags)) {
+		dev_vdbg(chan2dev(&fhc->chan), "%s: soft LLP mode\n", __func__);
+		spin_unlock_irqrestore(&fhc->lock, flags);
+		return;
+	}
+
+	dev_vdbg(chan2dev(&fhc->chan), "%s: llp=0x%llx\n", __func__,
+			(unsigned long long)llp);
+
+	list_for_each_entry_safe(desc, _desc, &fhc->active_list, desc_node) {
+		/* Initial residue value */
+		fhc->residue = desc->total_len;
+
+		/* Check first descriptors addr */
+		if (desc->txd.phys == llp) {
+			spin_unlock_irqrestore(&fhc->lock, flags);
+			return;
+		}
+
+		/* Check first descriptors llp */
+		if (desc->lli.llp == llp) {
+			/* This one is currently in progress */
+			fhc->residue -= fhc_get_sent(fhc);
+			spin_unlock_irqrestore(&fhc->lock, flags);
+			return;
+		}
+
+		fhc->residue -= desc->len;
+		list_for_each_entry(child, &desc->tx_list, desc_node) {
+			if (child->lli.llp == llp) {
+				/* Currently in progress */
+				fhc->residue -= fhc_get_sent(fhc);
+				spin_unlock_irqrestore(&fhc->lock, flags);
+				return;
+			}
+			fhc->residue -= child->len;
+		}
+
+		/*
+		 * No descriptors so far seem to be in progress, i.e.
+		 * this one must be done.
+		 */
+		spin_unlock_irqrestore(&fhc->lock, flags);
+		fhc_descriptor_complete(fhc, desc, true);
+		spin_lock_irqsave(&fhc->lock, flags);
+	}
+
+	dev_err(chan2dev(&fhc->chan),
+		"BUG: All descriptors done, but channel not idle!\n");
+
+	/* Try to continue after resetting the channel... */
+	fhc_chan_disable(fhd, fhc);
+
+	if (!list_empty(&fhc->queue)) {
+		list_move(fhc->queue.next, &fhc->active_list);
+		fhc_dostart(fhc, fhc_first_active(fhc));
+	}
+	spin_unlock_irqrestore(&fhc->lock, flags);
+}
+
+static inline void fhc_dump_lli(struct fh_dma_chan *fhc, struct fh_lli *lli)
+{
+	dev_crit(chan2dev(&fhc->chan), "  desc: s0x%x d0x%x l0x%x c0x%x:%x\n",
+		 lli->sar, lli->dar, lli->llp, lli->ctlhi, lli->ctllo);
+
+}
+
+static void fhc_handle_error(struct fh_dma *fhd, struct fh_dma_chan *fhc)
+{
+	struct fh_desc *bad_desc;
+	struct fh_desc *child;
+	unsigned long flags;
+
+	fhc_scan_descriptors(fhd, fhc);
+
+	spin_lock_irqsave(&fhc->lock, flags);
+
+	/*
+	 * The descriptor currently at the head of the active list is
+	 * borked. Since we don't have any way to report errors, we'll
+	 * just have to scream loudly and try to carry on.
+	 */
+	bad_desc = fhc_first_active(fhc);
+	list_del_init(&bad_desc->desc_node);
+	list_move(fhc->queue.next, fhc->active_list.prev);
+
+	/* Clear the error flag and try to restart the controller */
+	dma_writel(fhd, CLEAR.ERROR, fhc->mask);
+	if (!list_empty(&fhc->active_list))
+		fhc_dostart(fhc, fhc_first_active(fhc));
+
+	/*
+	 * WARN may seem harsh, but since this only happens
+	 * when someone submits a bad physical address in a
+	 * descriptor, we should consider ourselves lucky that the
+	 * controller flagged an error instead of scribbling over
+	 * random memory locations.
+	 */
+	dev_WARN(chan2dev(&fhc->chan), "Bad descriptor submitted for DMA!\n"
+				       "  cookie: %d\n", bad_desc->txd.cookie);
+	fhc_dump_lli(fhc, &bad_desc->lli);
+	list_for_each_entry(child, &bad_desc->tx_list, desc_node)
+		fhc_dump_lli(fhc, &child->lli);
+
+	spin_unlock_irqrestore(&fhc->lock, flags);
+
+	/* Pretend the descriptor completed successfully */
+	fhc_descriptor_complete(fhc, bad_desc, true);
+}
+
+/* --------------------- Cyclic DMA API extensions -------------------- */
+
+inline dma_addr_t fh_dma_get_src_addr(struct dma_chan *chan)
+{
+	struct fh_dma_chan *fhc = to_fh_dma_chan(chan);
+	return channel_readl(fhc, SAR);
+}
+EXPORT_SYMBOL(fh_dma_get_src_addr);
+
+inline dma_addr_t fh_dma_get_dst_addr(struct dma_chan *chan)
+{
+	struct fh_dma_chan *fhc = to_fh_dma_chan(chan);
+	return channel_readl(fhc, DAR);
+}
+EXPORT_SYMBOL(fh_dma_get_dst_addr);
+
+/* Called with fhc->lock held and all DMAC interrupts disabled */
+static void fhc_handle_cyclic(struct fh_dma *fhd, struct fh_dma_chan *fhc,
+		u32 status_err, u32 status_xfer, u32 status_block)
+{
+	unsigned long flags;
+
+	if (status_block & fhc->mask) {
+		void (*callback) (void *param);
+		void *callback_param;
+
+		dev_vdbg(chan2dev(&fhc->chan), "new cyclic period llp 0x%08x\n",
+			 channel_readl(fhc, LLP));
+		dma_writel(fhd, CLEAR.BLOCK, fhc->mask);
+
+		callback = fhc->cdesc->period_callback;
+		callback_param = fhc->cdesc->period_callback_param;
+
+		if (callback)
+			callback(callback_param);
+	}
+
+	/*
+	 * Error and transfer complete are highly unlikely, and will most
+	 * likely be due to a configuration error by the user.
+	 */
+	if (unlikely(status_err & fhc->mask) ||
+			unlikely(status_xfer & fhc->mask)) {
+		int i;
+
+		dev_err(chan2dev(&fhc->chan), "cyclic DMA unexpected %s "
+				"interrupt, stopping DMA transfer\n",
+				status_xfer ? "xfer" : "error");
+
+		spin_lock_irqsave(&fhc->lock, flags);
+
+		fhc_dump_chan_regs(fhc);
+
+		fhc_chan_disable(fhd, fhc);
+
+		/* Make sure DMA does not restart by loading a new list */
+		channel_writel(fhc, LLP, 0);
+		channel_writel(fhc, CTL_LO, 0);
+		channel_writel(fhc, CTL_HI, 0);
+
+		dma_writel(fhd, CLEAR.ERROR, fhc->mask);
+		dma_writel(fhd, CLEAR.XFER, fhc->mask);
+		dma_writel(fhd, CLEAR.BLOCK, fhc->mask);
+
+		for (i = 0; i < fhc->cdesc->periods; i++)
+			fhc_dump_lli(fhc, &fhc->cdesc->desc[i]->lli);
+
+		spin_unlock_irqrestore(&fhc->lock, flags);
+	}
+}
+
+/* ------------------------------------------------------------------------- */
+
+static void fh_dma_tasklet(unsigned long data)
+{
+	struct fh_dma *fhd = (struct fh_dma *)data;
+	struct fh_dma_chan *fhc;
+	u32 status_xfer;
+	u32 status_err;
+	u32 status_block;
+	int i;
+
+	status_xfer = dma_readl(fhd, RAW.XFER);
+	status_block = dma_readl(fhd, RAW.BLOCK);
+	status_err = dma_readl(fhd, RAW.ERROR);
+
+	dev_vdbg(fhd->dma.dev, "%s: status_err=%x\n", __func__, status_err);
+
+	for (i = 0; i < fhd->dma.chancnt; i++) {
+		fhc = &fhd->chan[i];
+		if (test_bit(FH_DMA_IS_CYCLIC, &fhc->flags))
+			fhc_handle_cyclic(fhd, fhc, status_err,
+					status_xfer, status_block);
+		else if (status_err & (1 << i))
+			fhc_handle_error(fhd, fhc);
+		else if (status_xfer & (1 << i))
+			fhc_scan_descriptors(fhd, fhc);
+	}
+
+	/*
+	 * Re-enable interrupts.
+	 */
+	channel_set_bit(fhd, MASK.XFER, fhd->all_chan_mask);
+	channel_set_bit(fhd, MASK.BLOCK, fhd->all_chan_mask);
+	channel_set_bit(fhd, MASK.ERROR, fhd->all_chan_mask);
+}
+
+static irqreturn_t fh_dma_interrupt(int irq, void *dev_id)
+{
+	struct fh_dma *fhd = dev_id;
+	u32 status;
+
+	dev_vdbg(fhd->dma.dev, "%s: status=0x%x\n", __func__,
+			dma_readl(fhd, STATUS_INT));
+
+	/*
+	 * Just disable the interrupts. We'll turn them back on in the
+	 * softirq handler.
+	 */
+	channel_clear_bit(fhd, MASK.XFER, fhd->all_chan_mask);
+	channel_clear_bit(fhd, MASK.BLOCK, fhd->all_chan_mask);
+	channel_clear_bit(fhd, MASK.ERROR, fhd->all_chan_mask);
+
+	status = dma_readl(fhd, STATUS_INT);
+	if (status) {
+		dev_err(fhd->dma.dev,
+			"BUG: Unexpected interrupts pending: 0x%x\n",
+			status);
+
+		/* Try to recover */
+		channel_clear_bit(fhd, MASK.XFER, (1 << 8) - 1);
+		channel_clear_bit(fhd, MASK.BLOCK, (1 << 8) - 1);
+		channel_clear_bit(fhd, MASK.SRC_TRAN, (1 << 8) - 1);
+		channel_clear_bit(fhd, MASK.DST_TRAN, (1 << 8) - 1);
+		channel_clear_bit(fhd, MASK.ERROR, (1 << 8) - 1);
+	}
+
+	tasklet_schedule(&fhd->tasklet);
+
+	return IRQ_HANDLED;
+}
+
+/*----------------------------------------------------------------------*/
+
+static dma_cookie_t fhc_tx_submit(struct dma_async_tx_descriptor *tx)
+{
+	struct fh_desc		*desc = txd_to_fh_desc(tx);
+	struct fh_dma_chan	*fhc = to_fh_dma_chan(tx->chan);
+	dma_cookie_t		cookie;
+	unsigned long		flags;
+
+	spin_lock_irqsave(&fhc->lock, flags);
+	cookie = dma_cookie_assign(tx);
+
+	/*
+	 * REVISIT: We should attempt to chain as many descriptors as
+	 * possible, perhaps even appending to those already submitted
+	 * for DMA. But this is hard to do in a race-free manner.
+	 */
+	if (list_empty(&fhc->active_list)) {
+		dev_vdbg(chan2dev(tx->chan), "%s: started %u\n", __func__,
+				desc->txd.cookie);
+		list_add_tail(&desc->desc_node, &fhc->active_list);
+		fhc_dostart(fhc, fhc_first_active(fhc));
+	} else {
+		dev_vdbg(chan2dev(tx->chan), "%s: queued %u\n", __func__,
+				desc->txd.cookie);
+
+		list_add_tail(&desc->desc_node, &fhc->queue);
+	}
+
+	spin_unlock_irqrestore(&fhc->lock, flags);
+
+	return cookie;
+}
+
+static struct dma_async_tx_descriptor *
+fhc_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dest, dma_addr_t src,
+		size_t len, unsigned long flags)
+{
+	struct fh_dma_chan	*fhc = to_fh_dma_chan(chan);
+	struct fh_dma		*fhd = to_fh_dma(chan->device);
+	struct fh_desc		*desc;
+	struct fh_desc		*first;
+	struct fh_desc		*prev;
+	size_t			xfer_count;
+	size_t			offset;
+	unsigned int		src_width;
+	unsigned int		dst_width;
+	unsigned int		data_width;
+	u32			ctllo;
+
+	dev_vdbg(chan2dev(chan),
+			"%s: d0x%llx s0x%llx l0x%zx f0x%lx\n", __func__,
+			(unsigned long long)dest, (unsigned long long)src,
+			len, flags);
+
+	if (unlikely(!len)) {
+		dev_dbg(chan2dev(chan), "%s: length is zero!\n", __func__);
+		return NULL;
+	}
+
+	fhc->direction = DMA_MEM_TO_MEM;
+
+	data_width = min_t(unsigned int, fhd->data_width[fhc->src_master],
+			   fhd->data_width[fhc->dst_master]);
+
+	src_width = dst_width = min_t(unsigned int, data_width,
+				      fhc_fast_fls(src | dest | len));
+
+	ctllo = FHC_DEFAULT_CTLLO(chan)
+			| FHC_CTLL_DST_WIDTH(dst_width)
+			| FHC_CTLL_SRC_WIDTH(src_width)
+			| FHC_CTLL_DST_INC
+			| FHC_CTLL_SRC_INC
+			| FHC_CTLL_FC_M2M;
+	prev = first = NULL;
+
+	for (offset = 0; offset < len; offset += xfer_count << src_width) {
+		xfer_count = min_t(size_t, (len - offset) >> src_width,
+					   fhc->block_size);
+
+		desc = fhc_desc_get(fhc);
+		if (!desc)
+			goto err_desc_get;
+
+		desc->lli.sar = src + offset;
+		desc->lli.dar = dest + offset;
+		desc->lli.ctllo = ctllo;
+		desc->lli.ctlhi = xfer_count;
+		desc->len = xfer_count << src_width;
+
+		if (!first) {
+			first = desc;
+		} else {
+			prev->lli.llp = desc->txd.phys;
+			list_add_tail(&desc->desc_node,
+					&first->tx_list);
+		}
+		prev = desc;
+	}
+
+	if (flags & DMA_PREP_INTERRUPT)
+		/* Trigger interrupt after last block */
+		prev->lli.ctllo |= FHC_CTLL_INT_EN;
+
+	prev->lli.llp = 0;
+	first->txd.flags = flags;
+	first->total_len = len;
+
+	return &first->txd;
+
+err_desc_get:
+	fhc_desc_put(fhc, first);
+	return NULL;
+}
+
+static struct dma_async_tx_descriptor *
+fhc_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,
+		unsigned int sg_len, enum dma_transfer_direction direction,
+		unsigned long flags, void *context)
+{
+	struct fh_dma_chan	*fhc = to_fh_dma_chan(chan);
+	struct fh_dma		*fhd = to_fh_dma(chan->device);
+	struct dma_slave_config	*sconfig = &fhc->dma_sconfig;
+	struct fh_desc		*prev;
+	struct fh_desc		*first;
+	u32			ctllo;
+	dma_addr_t		reg;
+	unsigned int		reg_width;
+	unsigned int		mem_width;
+	unsigned int		data_width;
+	unsigned int		i;
+	struct scatterlist	*sg;
+	size_t			total_len = 0;
+	struct fh_dma_pri *fh_pri = (struct fh_dma_pri *)context;
+	dev_vdbg(chan2dev(chan), "%s\n", __func__);
+
+	if (unlikely(!is_slave_direction(direction) || !sg_len))
+		return NULL;
+
+	fhc->direction = direction;
+
+	prev = first = NULL;
+
+	switch (direction) {
+	case DMA_MEM_TO_DEV:
+		reg_width = __fls(sconfig->dst_addr_width);
+		reg = sconfig->dst_addr;
+        if(!fh_pri){
+            ctllo = (FHC_DEFAULT_CTLLO(chan)
+                | FHC_CTLL_DST_WIDTH(reg_width)
+                | FHC_CTLL_DST_FIX
+                | FHC_CTLL_SRC_INC);
+        }
+        else{
+            ctllo = (FHC_DEFAULT_CTLLO(chan) | FHC_CTLL_DST_WIDTH(reg_width));
+            ctllo |= fh_pri->sinc << 9;
+            ctllo |= fh_pri->dinc << 7;
+        }
+
+		ctllo |= sconfig->device_fc ? FHC_CTLL_FC(FH_DMA_FC_P_M2P) :
+			FHC_CTLL_FC(FH_DMA_FC_D_M2P);
+
+		data_width = fhd->data_width[fhc->src_master];
+
+		for_each_sg(sgl, sg, sg_len, i) {
+			struct fh_desc	*desc;
+			u32		len, dlen, mem;
+
+			mem = sg_dma_address(sg);
+			len = sg_dma_len(sg);
+
+			mem_width = min_t(unsigned int,
+					  data_width, fhc_fast_fls(mem | len));
+
+slave_sg_todev_fill_desc:
+			desc = fhc_desc_get(fhc);
+			if (!desc) {
+				dev_err(chan2dev(chan),
+					"not enough descriptors available\n");
+				goto err_desc_get;
+			}
+
+			desc->lli.sar = mem;
+			desc->lli.dar = reg;
+			desc->lli.ctllo = ctllo | FHC_CTLL_SRC_WIDTH(mem_width);
+			if ((len >> mem_width) > fhc->block_size) {
+				dlen = fhc->block_size << mem_width;
+				mem += dlen;
+				len -= dlen;
+			} else {
+				dlen = len;
+				len = 0;
+			}
+
+			desc->lli.ctlhi = dlen >> mem_width;
+			desc->len = dlen;
+
+			if (!first) {
+				first = desc;
+			} else {
+				prev->lli.llp = desc->txd.phys;
+				list_add_tail(&desc->desc_node,
+						&first->tx_list);
+			}
+			prev = desc;
+			total_len += dlen;
+
+			if (len)
+				goto slave_sg_todev_fill_desc;
+		}
+		break;
+	case DMA_DEV_TO_MEM:
+		reg_width = __fls(sconfig->src_addr_width);
+		reg = sconfig->src_addr;
+
+        if(!fh_pri){
+            ctllo = (FHC_DEFAULT_CTLLO(chan)
+                | FHC_CTLL_SRC_WIDTH(reg_width)
+                | FHC_CTLL_DST_INC
+                | FHC_CTLL_SRC_FIX);
+        }
+        else{
+            ctllo = (FHC_DEFAULT_CTLLO(chan) | FHC_CTLL_SRC_WIDTH(reg_width));
+            ctllo |= fh_pri->sinc << 9;
+            ctllo |= fh_pri->dinc << 7;
+        }
+
+
+		ctllo |= sconfig->device_fc ? FHC_CTLL_FC(FH_DMA_FC_P_P2M) :
+			FHC_CTLL_FC(FH_DMA_FC_D_P2M);
+
+		data_width = fhd->data_width[fhc->dst_master];
+
+		for_each_sg(sgl, sg, sg_len, i) {
+			struct fh_desc	*desc;
+			u32		len, dlen, mem;
+
+			mem = sg_dma_address(sg);
+			len = sg_dma_len(sg);
+
+			mem_width = min_t(unsigned int,
+					  data_width, fhc_fast_fls(mem | len));
+
+slave_sg_fromdev_fill_desc:
+			desc = fhc_desc_get(fhc);
+			if (!desc) {
+				dev_err(chan2dev(chan),
+						"not enough descriptors available\n");
+				goto err_desc_get;
+			}
+
+			desc->lli.sar = reg;
+			desc->lli.dar = mem;
+			desc->lli.ctllo = ctllo | FHC_CTLL_DST_WIDTH(mem_width);
+			if ((len >> reg_width) > fhc->block_size) {
+				dlen = fhc->block_size << reg_width;
+				mem += dlen;
+				len -= dlen;
+			} else {
+				dlen = len;
+				len = 0;
+			}
+			desc->lli.ctlhi = dlen >> reg_width;
+			desc->len = dlen;
+
+			if (!first) {
+				first = desc;
+			} else {
+				prev->lli.llp = desc->txd.phys;
+				list_add_tail(&desc->desc_node,
+						&first->tx_list);
+			}
+			prev = desc;
+			total_len += dlen;
+
+			if (len)
+				goto slave_sg_fromdev_fill_desc;
+		}
+		break;
+	default:
+		return NULL;
+	}
+
+	if (flags & DMA_PREP_INTERRUPT)
+		/* Trigger interrupt after last block */
+		prev->lli.ctllo |= FHC_CTLL_INT_EN;
+
+	prev->lli.llp = 0;
+	first->total_len = total_len;
+
+	return &first->txd;
+
+err_desc_get:
+	fhc_desc_put(fhc, first);
+	return NULL;
+}
+
+/*
+ * Fix sconfig's burst size according to fh_dmac. We need to convert them as:
+ * 1 -> 0, 4 -> 1, 8 -> 2, 16 -> 3.
+ *
+ * NOTE: burst size 2 is not supported by controller.
+ *
+ * This can be done by finding least significant bit set: n & (n - 1)
+ */
+static inline void convert_burst(u32 *maxburst)
+{
+	if (*maxburst > 1)
+		*maxburst = fls(*maxburst) - 2;
+	else
+		*maxburst = 0;
+}
+
+static int
+set_runtime_config(struct dma_chan *chan, struct dma_slave_config *sconfig)
+{
+	struct fh_dma_chan *fhc = to_fh_dma_chan(chan);
+
+	/* Check if chan will be configured for slave transfers */
+	if (!is_slave_direction(sconfig->direction))
+		return -EINVAL;
+
+	memcpy(&fhc->dma_sconfig, sconfig, sizeof(*sconfig));
+	fhc->direction = sconfig->direction;
+
+	/* Take the request line from slave_id member */
+	if (fhc->request_line == ~0)
+		fhc->request_line = sconfig->slave_id;
+
+	convert_burst(&fhc->dma_sconfig.src_maxburst);
+	convert_burst(&fhc->dma_sconfig.dst_maxburst);
+
+	return 0;
+}
+
+static inline void fhc_chan_pause(struct fh_dma_chan *fhc)
+{
+	u32 cfglo = channel_readl(fhc, CFG_LO);
+	unsigned int count = 20;	/* timeout iterations */
+
+	channel_writel(fhc, CFG_LO, cfglo | FHC_CFGL_CH_SUSP);
+	while (!(channel_readl(fhc, CFG_LO) & FHC_CFGL_FIFO_EMPTY) && count--)
+		udelay(2);
+
+	fhc->paused = true;
+}
+
+static inline void fhc_chan_resume(struct fh_dma_chan *fhc)
+{
+	u32 cfglo = channel_readl(fhc, CFG_LO);
+
+	channel_writel(fhc, CFG_LO, cfglo & ~FHC_CFGL_CH_SUSP);
+
+	fhc->paused = false;
+}
+
+static int fhc_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
+		       unsigned long arg)
+{
+	struct fh_dma_chan	*fhc = to_fh_dma_chan(chan);
+	struct fh_dma		*fhd = to_fh_dma(chan->device);
+	struct fh_desc		*desc, *_desc;
+	unsigned long		flags;
+	LIST_HEAD(list);
+
+	if (cmd == DMA_PAUSE) {
+		spin_lock_irqsave(&fhc->lock, flags);
+
+		fhc_chan_pause(fhc);
+
+		spin_unlock_irqrestore(&fhc->lock, flags);
+	} else if (cmd == DMA_RESUME) {
+		if (!fhc->paused)
+			return 0;
+
+		spin_lock_irqsave(&fhc->lock, flags);
+
+		fhc_chan_resume(fhc);
+
+		spin_unlock_irqrestore(&fhc->lock, flags);
+	} else if (cmd == DMA_TERMINATE_ALL) {
+		spin_lock_irqsave(&fhc->lock, flags);
+
+		clear_bit(FH_DMA_IS_SOFT_LLP, &fhc->flags);
+
+		fhc_chan_disable(fhd, fhc);
+
+		fhc_chan_resume(fhc);
+
+		/* active_list entries will end up before queued entries */
+		list_splice_init(&fhc->queue, &list);
+		list_splice_init(&fhc->active_list, &list);
+
+		spin_unlock_irqrestore(&fhc->lock, flags);
+
+		/* Flush all pending and queued descriptors */
+		list_for_each_entry_safe(desc, _desc, &list, desc_node)
+			fhc_descriptor_complete(fhc, desc, false);
+	} else if (cmd == DMA_SLAVE_CONFIG) {
+		return set_runtime_config(chan, (struct dma_slave_config *)arg);
+	} else {
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+static inline u32 fhc_get_residue(struct fh_dma_chan *fhc)
+{
+	unsigned long flags;
+	u32 residue;
+
+	spin_lock_irqsave(&fhc->lock, flags);
+
+	residue = fhc->residue;
+	if (test_bit(FH_DMA_IS_SOFT_LLP, &fhc->flags) && residue)
+		residue -= fhc_get_sent(fhc);
+
+	spin_unlock_irqrestore(&fhc->lock, flags);
+	return residue;
+}
+
+static enum dma_status
+fhc_tx_status(struct dma_chan *chan,
+	      dma_cookie_t cookie,
+	      struct dma_tx_state *txstate)
+{
+	struct fh_dma_chan	*fhc = to_fh_dma_chan(chan);
+	enum dma_status		ret;
+
+	ret = dma_cookie_status(chan, cookie, txstate);
+	if (ret != DMA_SUCCESS) {
+		fhc_scan_descriptors(to_fh_dma(chan->device), fhc);
+
+		ret = dma_cookie_status(chan, cookie, txstate);
+	}
+
+	if (ret != DMA_SUCCESS)
+		dma_set_residue(txstate, fhc_get_residue(fhc));
+
+	if (fhc->paused)
+		return DMA_PAUSED;
+
+	return ret;
+}
+
+static void fhc_issue_pending(struct dma_chan *chan)
+{
+	struct fh_dma_chan	*fhc = to_fh_dma_chan(chan);
+
+	if (!list_empty(&fhc->queue))
+		fhc_scan_descriptors(to_fh_dma(chan->device), fhc);
+}
+
+static int fhc_alloc_chan_resources(struct dma_chan *chan)
+{
+	struct fh_dma_chan	*fhc = to_fh_dma_chan(chan);
+	struct fh_dma		*fhd = to_fh_dma(chan->device);
+	struct fh_desc		*desc;
+	int			i;
+	unsigned long		flags;
+
+	dev_vdbg(chan2dev(chan), "%s\n", __func__);
+
+	/* ASSERT:  channel is idle */
+	if (dma_readl(fhd, CH_EN) & fhc->mask) {
+		dev_dbg(chan2dev(chan), "DMA channel not idle?\n");
+		return -EIO;
+	}
+
+	dma_cookie_init(chan);
+
+	/*
+	 * NOTE: some controllers may have additional features that we
+	 * need to initialize here, like "scatter-gather" (which
+	 * doesn't mean what you think it means), and status writeback.
+	 */
+
+	fhc_set_masters(fhc);
+
+	spin_lock_irqsave(&fhc->lock, flags);
+	i = fhc->descs_allocated;
+	while (fhc->descs_allocated < NR_DESCS_PER_CHANNEL) {
+		dma_addr_t phys;
+
+		spin_unlock_irqrestore(&fhc->lock, flags);
+
+		desc = dma_pool_alloc(fhd->desc_pool, GFP_ATOMIC, &phys);
+		if (!desc)
+			goto err_desc_alloc;
+
+		memset(desc, 0, sizeof(struct fh_desc));
+
+		INIT_LIST_HEAD(&desc->tx_list);
+		dma_async_tx_descriptor_init(&desc->txd, chan);
+		desc->txd.tx_submit = fhc_tx_submit;
+		desc->txd.flags = DMA_CTRL_ACK;
+		desc->txd.phys = phys;
+
+		fhc_desc_put(fhc, desc);
+
+		spin_lock_irqsave(&fhc->lock, flags);
+		i = ++fhc->descs_allocated;
+	}
+
+	spin_unlock_irqrestore(&fhc->lock, flags);
+
+	dev_dbg(chan2dev(chan), "%s: allocated %d descriptors\n", __func__, i);
+
+	return i;
+
+err_desc_alloc:
+	dev_info(chan2dev(chan), "only allocated %d descriptors\n", i);
+
+	return i;
+}
+
+static void fhc_free_chan_resources(struct dma_chan *chan)
+{
+	struct fh_dma_chan	*fhc = to_fh_dma_chan(chan);
+	struct fh_dma		*fhd = to_fh_dma(chan->device);
+	struct fh_desc		*desc, *_desc;
+	unsigned long		flags;
+	LIST_HEAD(list);
+
+	dev_dbg(chan2dev(chan), "%s: descs allocated=%u\n", __func__,
+			fhc->descs_allocated);
+
+	/* ASSERT:  channel is idle */
+	BUG_ON(!list_empty(&fhc->active_list));
+	BUG_ON(!list_empty(&fhc->queue));
+	BUG_ON(dma_readl(to_fh_dma(chan->device), CH_EN) & fhc->mask);
+
+	spin_lock_irqsave(&fhc->lock, flags);
+	list_splice_init(&fhc->free_list, &list);
+	fhc->descs_allocated = 0;
+	fhc->initialized = false;
+	fhc->request_line = ~0;
+
+	/* Disable interrupts */
+	channel_clear_bit(fhd, MASK.XFER, fhc->mask);
+	channel_clear_bit(fhd, MASK.BLOCK, fhc->mask);
+	channel_clear_bit(fhd, MASK.ERROR, fhc->mask);
+
+	spin_unlock_irqrestore(&fhc->lock, flags);
+
+	list_for_each_entry_safe(desc, _desc, &list, desc_node) {
+		dev_vdbg(chan2dev(chan), "  freeing descriptor %p\n", desc);
+		dma_pool_free(fhd->desc_pool, desc, desc->txd.phys);
+	}
+
+	dev_vdbg(chan2dev(chan), "%s: done\n", __func__);
+}
+
+
+/* --------------------- Cyclic DMA API extensions -------------------- */
+
+/**
+ * fh_dma_cyclic_start - start the cyclic DMA transfer
+ * @chan: the DMA channel to start
+ *
+ * Must be called with soft interrupts disabled. Returns zero on success or
+ * -errno on failure.
+ */
+int fh_dma_cyclic_start(struct dma_chan *chan)
+{
+	struct fh_dma_chan	*fhc = to_fh_dma_chan(chan);
+	struct fh_dma		*fhd = to_fh_dma(fhc->chan.device);
+	unsigned long		flags;
+
+	if (!test_bit(FH_DMA_IS_CYCLIC, &fhc->flags)) {
+		dev_err(chan2dev(&fhc->chan), "missing prep for cyclic DMA\n");
+		return -ENODEV;
+	}
+
+	spin_lock_irqsave(&fhc->lock, flags);
+
+	/* Assert channel is idle */
+	if (dma_readl(fhd, CH_EN) & fhc->mask) {
+		dev_err(chan2dev(&fhc->chan),
+			"BUG: Attempted to start non-idle channel\n");
+		fhc_dump_chan_regs(fhc);
+		spin_unlock_irqrestore(&fhc->lock, flags);
+		return -EBUSY;
+	}
+
+	dma_writel(fhd, CLEAR.ERROR, fhc->mask);
+	dma_writel(fhd, CLEAR.XFER, fhc->mask);
+	dma_writel(fhd, CLEAR.BLOCK, fhc->mask);
+
+	fhc_initialize(fhc);
+
+	/* Setup DMAC channel registers */
+	channel_writel(fhc, LLP, fhc->cdesc->desc[0]->txd.phys);
+	channel_writel(fhc, CTL_LO, FHC_CTLL_LLP_D_EN | FHC_CTLL_LLP_S_EN);
+	channel_writel(fhc, CTL_HI, 0);
+
+	channel_set_bit(fhd, CH_EN, fhc->mask);
+
+	spin_unlock_irqrestore(&fhc->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(fh_dma_cyclic_start);
+
+/**
+ * fh_dma_cyclic_stop - stop the cyclic DMA transfer
+ * @chan: the DMA channel to stop
+ *
+ * Must be called with soft interrupts disabled.
+ */
+void fh_dma_cyclic_stop(struct dma_chan *chan)
+{
+	struct fh_dma_chan	*fhc = to_fh_dma_chan(chan);
+	struct fh_dma		*fhd = to_fh_dma(fhc->chan.device);
+	unsigned long		flags;
+
+	spin_lock_irqsave(&fhc->lock, flags);
+
+	fhc_chan_disable(fhd, fhc);
+
+	spin_unlock_irqrestore(&fhc->lock, flags);
+}
+EXPORT_SYMBOL(fh_dma_cyclic_stop);
+
+/**
+ * fh_dma_cyclic_prep - prepare the cyclic DMA transfer
+ * @chan: the DMA channel to prepare
+ * @buf_addr: physical DMA address where the buffer starts
+ * @buf_len: total number of bytes for the entire buffer
+ * @period_len: number of bytes for each period
+ * @direction: transfer direction, to or from device
+ *
+ * Must be called before trying to start the transfer. Returns a valid struct
+ * fh_cyclic_desc if successful or an ERR_PTR(-errno) if not successful.
+ */
+struct fh_cyclic_desc *fh_dma_cyclic_prep(struct dma_chan *chan,
+		dma_addr_t buf_addr, size_t buf_len, size_t period_len,
+		enum dma_transfer_direction direction)
+{
+	struct fh_dma_chan		*fhc = to_fh_dma_chan(chan);
+	struct fh_dma_slave 		*fhs = chan->private;
+	struct fh_cyclic_desc		*cdesc;
+	struct fh_cyclic_desc		*retval = NULL;
+	struct fh_desc			*desc;
+	struct fh_desc			*last = NULL;
+	unsigned long			was_cyclic;
+	unsigned int			reg_width;
+	unsigned int			periods;
+	unsigned int			i;
+	unsigned long			flags;
+
+	spin_lock_irqsave(&fhc->lock, flags);
+	if (fhc->nollp) {
+		spin_unlock_irqrestore(&fhc->lock, flags);
+		dev_dbg(chan2dev(&fhc->chan),
+				"channel doesn't support LLP transfers\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	if (!list_empty(&fhc->queue) || !list_empty(&fhc->active_list)) {
+		spin_unlock_irqrestore(&fhc->lock, flags);
+		dev_dbg(chan2dev(&fhc->chan),
+				"queue and/or active list are not empty\n");
+		return ERR_PTR(-EBUSY);
+	}
+
+	was_cyclic = test_and_set_bit(FH_DMA_IS_CYCLIC, &fhc->flags);
+	spin_unlock_irqrestore(&fhc->lock, flags);
+	if (was_cyclic) {
+		dev_dbg(chan2dev(&fhc->chan),
+				"channel already prepared for cyclic DMA\n");
+		return ERR_PTR(-EBUSY);
+	}
+
+	retval = ERR_PTR(-EINVAL);
+
+	reg_width = fhs->reg_width;
+
+	if (unlikely(!is_slave_direction(direction)))
+		goto out_err;
+
+	fhc->direction = direction;
+
+	periods = buf_len / period_len;
+
+	/* Check for too big/unaligned periods and unaligned DMA buffer. */
+	if (period_len > (fhc->block_size << reg_width))
+		goto out_err;
+	if (unlikely(period_len & ((1 << reg_width) - 1)))
+		goto out_err;
+	if (unlikely(buf_addr & ((1 << reg_width) - 1)))
+		goto out_err;
+
+	retval = ERR_PTR(-ENOMEM);
+
+	if (periods > NR_DESCS_PER_CHANNEL)
+		goto out_err;
+
+	cdesc = kzalloc(sizeof(struct fh_cyclic_desc), GFP_KERNEL);
+	if (!cdesc)
+		goto out_err;
+
+	cdesc->desc = kzalloc(sizeof(struct fh_desc *) * periods, GFP_KERNEL);
+	if (!cdesc->desc)
+		goto out_err_alloc;
+
+	for (i = 0; i < periods; i++) {
+		desc = fhc_desc_get(fhc);
+		if (!desc)
+			goto out_err_desc_get;
+
+		switch (direction) {
+		case DMA_MEM_TO_DEV:
+			desc->lli.dar = fhs->tx_reg;
+			desc->lli.sar = buf_addr + (period_len * i);
+			desc->lli.ctllo = (FHC_DEFAULT_CTLLO_OLD(chan->private)
+					| FHC_CTLL_DST_WIDTH(reg_width)
+					| FHC_CTLL_SRC_WIDTH(reg_width)
+					| FHC_CTLL_DST_FIX
+					| FHC_CTLL_SRC_INC
+					| FHC_CTLL_FC(fhs->fc)
+					| FHC_CTLL_INT_EN);
+
+			break;
+		case DMA_DEV_TO_MEM:
+			desc->lli.dar = buf_addr + (period_len * i);
+			desc->lli.sar = fhs->rx_reg;
+			desc->lli.ctllo = (FHC_DEFAULT_CTLLO_OLD(chan->private)
+					| FHC_CTLL_SRC_WIDTH(reg_width)
+					| FHC_CTLL_DST_WIDTH(reg_width)
+					| FHC_CTLL_DST_INC
+					| FHC_CTLL_SRC_FIX
+					| FHC_CTLL_FC(fhs->fc)
+					| FHC_CTLL_INT_EN);
+
+
+			break;
+		default:
+			break;
+		}
+
+		desc->lli.ctlhi = (period_len >> reg_width);
+		cdesc->desc[i] = desc;
+
+		if (last)
+		{
+			last->lli.llp = desc->txd.phys;
+			dma_sync_single_for_device(chan2parent(chan),
+						   last->txd.phys,
+						   sizeof(last->lli),
+						   DMA_TO_DEVICE);
+		}
+
+		last = desc;
+	}
+
+	/* Let's make a cyclic list */
+	last->lli.llp = cdesc->desc[0]->txd.phys;
+	dma_sync_single_for_device(chan2parent(chan), last->txd.phys,
+				   sizeof(last->lli), DMA_TO_DEVICE);
+
+	dev_dbg(chan2dev(&fhc->chan), "cyclic prepared buf 0x%llx len %zu "
+			"period %zu periods %d\n", (unsigned long long)buf_addr,
+			buf_len, period_len, periods);
+
+	cdesc->periods = periods;
+	fhc->cdesc = cdesc;
+
+	return cdesc;
+
+out_err_desc_get:
+	while (i--)
+		fhc_desc_put(fhc, cdesc->desc[i]);
+out_err_alloc:
+	kfree(cdesc);
+out_err:
+	clear_bit(FH_DMA_IS_CYCLIC, &fhc->flags);
+	return (struct fh_cyclic_desc *)retval;
+}
+EXPORT_SYMBOL(fh_dma_cyclic_prep);
+
+/**
+ * fh_dma_cyclic_free - free a prepared cyclic DMA transfer
+ * @chan: the DMA channel to free
+ */
+void fh_dma_cyclic_free(struct dma_chan *chan)
+{
+	struct fh_dma_chan	*fhc = to_fh_dma_chan(chan);
+	struct fh_dma		*fhd = to_fh_dma(fhc->chan.device);
+	struct fh_cyclic_desc	*cdesc = fhc->cdesc;
+	int			i;
+	unsigned long		flags;
+
+	dev_dbg(chan2dev(&fhc->chan), "%s\n", __func__);
+
+	if (!cdesc)
+		return;
+
+	spin_lock_irqsave(&fhc->lock, flags);
+
+	fhc_chan_disable(fhd, fhc);
+
+	dma_writel(fhd, CLEAR.ERROR, fhc->mask);
+	dma_writel(fhd, CLEAR.XFER, fhc->mask);
+	dma_writel(fhd, CLEAR.BLOCK, fhc->mask);
+
+	spin_unlock_irqrestore(&fhc->lock, flags);
+
+	for (i = 0; i < cdesc->periods; i++)
+		fhc_desc_put(fhc, cdesc->desc[i]);
+
+	kfree(cdesc->desc);
+	kfree(cdesc);
+
+	clear_bit(FH_DMA_IS_CYCLIC, &fhc->flags);
+}
+EXPORT_SYMBOL(fh_dma_cyclic_free);
+
+/*----------------------------------------------------------------------*/
+
+static void fh_dma_off(struct fh_dma *fhd)
+{
+	int i;
+
+	dma_writel(fhd, CFG, 0);
+
+	channel_clear_bit(fhd, MASK.XFER, fhd->all_chan_mask);
+	channel_clear_bit(fhd, MASK.BLOCK, fhd->all_chan_mask);
+	channel_clear_bit(fhd, MASK.SRC_TRAN, fhd->all_chan_mask);
+	channel_clear_bit(fhd, MASK.DST_TRAN, fhd->all_chan_mask);
+	channel_clear_bit(fhd, MASK.ERROR, fhd->all_chan_mask);
+
+	while (dma_readl(fhd, CFG) & FH_CFG_DMA_EN)
+		cpu_relax();
+
+	for (i = 0; i < fhd->dma.chancnt; i++)
+		fhd->chan[i].initialized = false;
+}
+
+static int fh_dma_probe(struct platform_device *pdev)
+{
+	struct fh_dma_platform_data *pdata;
+	struct resource		*io;
+	struct fh_dma		*fhd;
+	size_t			size;
+	void __iomem		*regs;
+	bool			autocfg;
+	unsigned int		fh_params;
+	unsigned int		nr_channels;
+	unsigned int		max_blk_size = 0;
+	int			irq;
+	int			err;
+	int			i;
+
+	io = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!io)
+		return -EINVAL;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return irq;
+
+    if (!request_mem_region(io->start, FH_REGLEN, pdev->dev.driver->name))
+        return -EBUSY;
+
+    regs = ioremap(io->start, FH_REGLEN);
+    if (!regs) {
+        err = -ENOMEM;
+        goto err_release_r;
+    }
+
+	/* Apply default dma_mask if needed */
+	if (!pdev->dev.dma_mask) {
+		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
+		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
+	}
+
+	fh_params = dma_read_byaddr(regs, FH_PARAMS);
+	autocfg = fh_params >> FH_PARAMS_EN & 0x1;
+
+	dev_dbg(&pdev->dev, "FH_PARAMS: 0x%08x\n", fh_params);
+
+	pdata = dev_get_platdata(&pdev->dev);
+
+	if (!pdata && autocfg) {
+		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
+		if (!pdata)
+			return -ENOMEM;
+
+		/* Fill platform data with the default values */
+		pdata->is_private = true;
+		pdata->chan_allocation_order = CHAN_ALLOCATION_ASCENDING;
+		pdata->chan_priority = CHAN_PRIORITY_ASCENDING;
+	} else if (!pdata || pdata->nr_channels > FH_DMA_MAX_NR_CHANNELS)
+		return -EINVAL;
+
+	if (autocfg)
+		nr_channels = (fh_params >> FH_PARAMS_NR_CHAN & 0x7) + 1;
+	else
+		nr_channels = pdata->nr_channels;
+
+	size = sizeof(struct fh_dma) + nr_channels * sizeof(struct fh_dma_chan);
+	fhd = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);
+	if (!fhd)
+		return -ENOMEM;
+
+	fhd->clk = clk_get(&pdev->dev, "ahb_clk");
+	if (IS_ERR(fhd->clk))
+		return PTR_ERR(fhd->clk);
+	clk_enable(fhd->clk);
+
+	fhd->regs = regs;
+
+	/* Get hardware configuration parameters */
+	if (autocfg) {
+		max_blk_size = dma_readl(fhd, MAX_BLK_SIZE);
+
+		fhd->nr_masters = (fh_params >> FH_PARAMS_NR_MASTER & 3) + 1;
+		for (i = 0; i < fhd->nr_masters; i++) {
+			fhd->data_width[i] =
+				(fh_params >> FH_PARAMS_DATA_WIDTH(i) & 3) + 2;
+		}
+	} else {
+		fhd->nr_masters = pdata->nr_masters;
+		memcpy(fhd->data_width, pdata->data_width, 4);
+	}
+
+	/* Calculate all channel mask before DMA setup */
+	fhd->all_chan_mask = (1 << nr_channels) - 1;
+
+	/* Force dma off, just in case */
+	fh_dma_off(fhd);
+
+	/* Disable BLOCK interrupts as well */
+	channel_clear_bit(fhd, MASK.BLOCK, fhd->all_chan_mask);
+
+	err = devm_request_irq(&pdev->dev, irq, fh_dma_interrupt, 0,
+			       "fh_dmac", fhd);
+	if (err)
+		return err;
+
+	platform_set_drvdata(pdev, fhd);
+
+	/* Create a pool of consistent memory blocks for hardware descriptors */
+	fhd->desc_pool = dmam_pool_create("fh_dmac_desc_pool", &pdev->dev,
+					 sizeof(struct fh_desc), 4, 0);
+	if (!fhd->desc_pool) {
+		dev_err(&pdev->dev, "No memory for descriptors dma pool\n");
+		return -ENOMEM;
+	}
+
+	tasklet_init(&fhd->tasklet, fh_dma_tasklet, (unsigned long)fhd);
+
+	INIT_LIST_HEAD(&fhd->dma.channels);
+	for (i = 0; i < nr_channels; i++) {
+		struct fh_dma_chan	*fhc = &fhd->chan[i];
+		int			r = nr_channels - i - 1;
+
+		fhc->chan.device = &fhd->dma;
+		dma_cookie_init(&fhc->chan);
+		if (pdata->chan_allocation_order == CHAN_ALLOCATION_ASCENDING)
+			list_add_tail(&fhc->chan.device_node,
+					&fhd->dma.channels);
+		else
+			list_add(&fhc->chan.device_node, &fhd->dma.channels);
+
+		/* 7 is highest priority & 0 is lowest. */
+		if (pdata->chan_priority == CHAN_PRIORITY_ASCENDING)
+			fhc->priority = r;
+		else
+			fhc->priority = i;
+
+		fhc->ch_regs = &__fh_regs(fhd)->CHAN[i];
+		spin_lock_init(&fhc->lock);
+		fhc->mask = 1 << i;
+
+		INIT_LIST_HEAD(&fhc->active_list);
+		INIT_LIST_HEAD(&fhc->queue);
+		INIT_LIST_HEAD(&fhc->free_list);
+
+		channel_clear_bit(fhd, CH_EN, fhc->mask);
+
+		fhc->direction = DMA_TRANS_NONE;
+		fhc->request_line = ~0;
+
+		/* Hardware configuration */
+		if (autocfg) {
+			unsigned int fhc_params;
+
+			fhc_params = dma_read_byaddr(regs + r * sizeof(u32),
+						     FHC_PARAMS);
+
+			dev_dbg(&pdev->dev, "FHC_PARAMS[%d]: 0x%08x\n", i,
+					    fhc_params);
+
+			/* Decode maximum block size for given channel. The
+			 * stored 4 bit value represents blocks from 0x00 for 3
+			 * up to 0x0a for 4095. */
+			fhc->block_size =
+				(4 << ((max_blk_size >> 4 * i) & 0xf)) - 1;
+			fhc->nollp =
+				(fhc_params >> FHC_PARAMS_MBLK_EN & 0x1) == 0;
+		} else {
+			fhc->block_size = pdata->block_size;
+
+			/* Check if channel supports multi block transfer */
+			channel_writel(fhc, LLP, 0xfffffffc);
+			fhc->nollp =
+				(channel_readl(fhc, LLP) & 0xfffffffc) == 0;
+			channel_writel(fhc, LLP, 0);
+		}
+	}
+
+	/* Clear all interrupts on all channels. */
+	dma_writel(fhd, CLEAR.XFER, fhd->all_chan_mask);
+	dma_writel(fhd, CLEAR.BLOCK, fhd->all_chan_mask);
+	dma_writel(fhd, CLEAR.SRC_TRAN, fhd->all_chan_mask);
+	dma_writel(fhd, CLEAR.DST_TRAN, fhd->all_chan_mask);
+	dma_writel(fhd, CLEAR.ERROR, fhd->all_chan_mask);
+
+	dma_cap_set(DMA_MEMCPY, fhd->dma.cap_mask);
+	dma_cap_set(DMA_SLAVE, fhd->dma.cap_mask);
+	if (pdata->is_private)
+		dma_cap_set(DMA_PRIVATE, fhd->dma.cap_mask);
+	fhd->dma.dev = &pdev->dev;
+	fhd->dma.device_alloc_chan_resources = fhc_alloc_chan_resources;
+	fhd->dma.device_free_chan_resources = fhc_free_chan_resources;
+
+	fhd->dma.device_prep_dma_memcpy = fhc_prep_dma_memcpy;
+
+	fhd->dma.device_prep_slave_sg = fhc_prep_slave_sg;
+	fhd->dma.device_control = fhc_control;
+
+	fhd->dma.device_tx_status = fhc_tx_status;
+	fhd->dma.device_issue_pending = fhc_issue_pending;
+
+	dma_writel(fhd, CFG, FH_CFG_DMA_EN);
+
+	err = dma_async_device_register(&fhd->dma);
+
+	if(err)
+	    pr_err("dma register failed, ret %d\n", err);
+
+    dev_info(&pdev->dev, "FH DMA Controller, %d channels\n",
+         nr_channels);
+
+	return 0;
+
+err_release_r:
+    release_resource(io);
+    return err;
+}
+
+static int fh_dma_remove(struct platform_device *pdev)
+{
+	struct fh_dma		*fhd = platform_get_drvdata(pdev);
+	struct fh_dma_chan	*fhc, *_fhc;
+
+	fh_dma_off(fhd);
+	dma_async_device_unregister(&fhd->dma);
+
+	tasklet_kill(&fhd->tasklet);
+
+	list_for_each_entry_safe(fhc, _fhc, &fhd->dma.channels,
+			chan.device_node) {
+		list_del(&fhc->chan.device_node);
+		channel_clear_bit(fhd, CH_EN, fhc->mask);
+	}
+
+	return 0;
+}
+
+static void fh_dma_shutdown(struct platform_device *pdev)
+{
+	struct fh_dma	*fhd = platform_get_drvdata(pdev);
+
+	fh_dma_off(fhd);
+	clk_disable(fhd->clk);
+}
+
+static int fh_dma_suspend_noirq(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct fh_dma	*fhd = platform_get_drvdata(pdev);
+
+	fh_dma_off(fhd);
+	clk_disable(fhd->clk);
+
+	return 0;
+}
+
+static int fh_dma_resume_noirq(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct fh_dma	*fhd = platform_get_drvdata(pdev);
+
+	clk_enable(fhd->clk);
+	dma_writel(fhd, CFG, FH_CFG_DMA_EN);
+
+	return 0;
+}
+
+static const struct dev_pm_ops fh_dma_dev_pm_ops = {
+	.suspend_noirq = fh_dma_suspend_noirq,
+	.resume_noirq = fh_dma_resume_noirq,
+	.freeze_noirq = fh_dma_suspend_noirq,
+	.thaw_noirq = fh_dma_resume_noirq,
+	.restore_noirq = fh_dma_resume_noirq,
+	.poweroff_noirq = fh_dma_suspend_noirq,
+};
+
+static struct platform_driver fh_dma_driver = {
+	.probe		= fh_dma_probe,
+	.remove		= fh_dma_remove,
+	.shutdown	= fh_dma_shutdown,
+	.driver = {
+		.name	= "fh_dmac",
+		.pm	= &fh_dma_dev_pm_ops,
+	},
+};
+
+static int __init fh_dma_init(void)
+{
+	return platform_driver_register(&fh_dma_driver);
+}
+subsys_initcall(fh_dma_init);
+
+static void __exit fh_dma_exit(void)
+{
+	platform_driver_unregister(&fh_dma_driver);
+}
+module_exit(fh_dma_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("FH DMA Controller driver");
diff -uraN linux-3.0.8/drivers/dma/fh_dmac_regs.h linux-3.0.8-fh8632-V1.0_20180330/drivers/dma/fh_dmac_regs.h
--- linux-3.0.8/drivers/dma/fh_dmac_regs.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/dma/fh_dmac_regs.h	2021-07-13 23:40:34.822363413 +0300
@@ -0,0 +1,236 @@
+/*
+ * Driver for the Synopsys DesignWare AHB DMA Controller
+ *
+ * Copyright (C) 2005-2007 Atmel Corporation
+ * Copyright (C) 2010-2011 ST Microelectronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <mach/fh_dmac.h>
+
+#define FH_DMA_MAX_NR_CHANNELS	8
+
+/*
+ * Redefine this macro to handle differences between 32- and 64-bit
+ * addressing, big vs. little endian, etc.
+ */
+#define FH_REG(name)		u32 name; u32 __pad_##name
+
+/* Hardware register definitions. */
+struct fh_dma_chan_regs {
+	FH_REG(SAR);		/* Source Address Register */
+	FH_REG(DAR);		/* Destination Address Register */
+	FH_REG(LLP);		/* Linked List Pointer */
+	u32	CTL_LO;		/* Control Register Low */
+	u32	CTL_HI;		/* Control Register High */
+	FH_REG(SSTAT);
+	FH_REG(DSTAT);
+	FH_REG(SSTATAR);
+	FH_REG(DSTATAR);
+	u32	CFG_LO;		/* Configuration Register Low */
+	u32	CFG_HI;		/* Configuration Register High */
+	FH_REG(SGR);
+	FH_REG(DSR);
+};
+
+struct fh_dma_irq_regs {
+	FH_REG(XFER);
+	FH_REG(BLOCK);
+	FH_REG(SRC_TRAN);
+	FH_REG(DST_TRAN);
+	FH_REG(ERROR);
+};
+
+struct fh_dma_regs {
+	/* per-channel registers */
+	struct fh_dma_chan_regs	CHAN[FH_DMA_MAX_NR_CHANNELS];
+
+	/* irq handling */
+	struct fh_dma_irq_regs	RAW;		/* r */
+	struct fh_dma_irq_regs	STATUS;		/* r (raw & mask) */
+	struct fh_dma_irq_regs	MASK;		/* rw (set = irq enabled) */
+	struct fh_dma_irq_regs	CLEAR;		/* w (ack, affects "raw") */
+
+	FH_REG(STATUS_INT);			/* r */
+
+	/* software handshaking */
+	FH_REG(REQ_SRC);
+	FH_REG(REQ_DST);
+	FH_REG(SGL_REQ_SRC);
+	FH_REG(SGL_REQ_DST);
+	FH_REG(LAST_SRC);
+	FH_REG(LAST_DST);
+
+	/* miscellaneous */
+	FH_REG(CFG);
+	FH_REG(CH_EN);
+	FH_REG(ID);
+	FH_REG(TEST);
+
+	/* optional encoded params, 0x3c8..0x3 */
+};
+
+/* Bitfields in CTL_LO */
+#define FHC_CTLL_INT_EN		(1 << 0)	/* irqs enabled? */
+#define FHC_CTLL_DST_WIDTH(n)	((n)<<1)	/* bytes per element */
+#define FHC_CTLL_SRC_WIDTH(n)	((n)<<4)
+#define FHC_CTLL_DST_INC	(0<<7)		/* DAR update/not */
+#define FHC_CTLL_DST_DEC	(1<<7)
+#define FHC_CTLL_DST_FIX	(2<<7)
+#define FHC_CTLL_SRC_INC	(0<<9)		/* SAR update/not */
+#define FHC_CTLL_SRC_DEC	(1<<9)
+#define FHC_CTLL_SRC_FIX	(2<<9)
+#define FHC_CTLL_DST_MSIZE(n)	((n)<<11)	/* burst, #elements */
+#define FHC_CTLL_SRC_MSIZE(n)	((n)<<14)
+#define FHC_CTLL_S_GATH_EN	(1 << 17)	/* src gather, !FIX */
+#define FHC_CTLL_D_SCAT_EN	(1 << 18)	/* dst scatter, !FIX */
+#define FHC_CTLL_FC(n)		((n) << 20)
+#define FHC_CTLL_FC_M2M		(0 << 20)	/* mem-to-mem */
+#define FHC_CTLL_FC_M2P		(1 << 20)	/* mem-to-periph */
+#define FHC_CTLL_FC_P2M		(2 << 20)	/* periph-to-mem */
+#define FHC_CTLL_FC_P2P		(3 << 20)	/* periph-to-periph */
+/* plus 4 transfer types for peripheral-as-flow-controller */
+#define FHC_CTLL_DMS(n)		((n)<<23)	/* dst master select */
+#define FHC_CTLL_SMS(n)		((n)<<25)	/* src master select */
+#define FHC_CTLL_LLP_D_EN	(1 << 27)	/* dest block chain */
+#define FHC_CTLL_LLP_S_EN	(1 << 28)	/* src block chain */
+
+/* Bitfields in CTL_HI */
+#define FHC_CTLH_DONE		0x00001000
+#define FHC_CTLH_BLOCK_TS_MASK	0x00000fff
+
+/* Bitfields in CFG_LO. Platform-configurable bits are in <linux/FH_dmac.h> */
+#define FHC_CFGL_CH_PRIOR_MASK	(0x7 << 5)	/* priority mask */
+#define FHC_CFGL_CH_PRIOR(x)	((x) << 5)	/* priority */
+#define FHC_CFGL_CH_SUSP	(1 << 8)	/* pause xfer */
+#define FHC_CFGL_FIFO_EMPTY	(1 << 9)	/* pause xfer */
+#define FHC_CFGL_HS_DST		(1 << 10)	/* handshake w/dst */
+#define FHC_CFGL_HS_SRC		(1 << 11)	/* handshake w/src */
+#define FHC_CFGL_MAX_BURST(x)	((x) << 20)
+#define FHC_CFGL_RELOAD_SAR	(1 << 30)
+#define FHC_CFGL_RELOAD_DAR	(1 << 31)
+
+/* Bitfields in CFG_HI. Platform-configurable bits are in <linux/FH_dmac.h> */
+#define FHC_CFGH_DS_UPD_EN	(1 << 5)
+#define FHC_CFGH_SS_UPD_EN	(1 << 6)
+
+/* Bitfields in SGR */
+#define FHC_SGR_SGI(x)		((x) << 0)
+#define FHC_SGR_SGC(x)		((x) << 20)
+
+/* Bitfields in DSR */
+#define FHC_DSR_DSI(x)		((x) << 0)
+#define FHC_DSR_DSC(x)		((x) << 20)
+
+/* Bitfields in CFG */
+#define FH_CFG_DMA_EN		(1 << 0)
+
+#define FH_REGLEN		0x400
+
+enum fh_dmac_flags {
+	FH_DMA_IS_CYCLIC = 0,
+};
+
+struct fh_dma_chan {
+	struct dma_chan		chan;
+	void __iomem		*ch_regs;
+	u8			mask;
+	u8			priority;
+	bool			paused;
+	bool				initialized;
+	spinlock_t		lock;
+
+	/* these other elements are all protected by lock */
+	unsigned long		flags;
+	dma_cookie_t		completed;
+	struct list_head	active_list;
+	struct list_head	queue;
+	struct list_head	free_list;
+	struct fh_cyclic_desc	*cdesc;
+
+	unsigned int		descs_allocated;
+
+};
+
+static inline struct fh_dma_chan_regs __iomem *
+__fhc_regs(struct fh_dma_chan *fhc)
+{
+	return fhc->ch_regs;
+}
+
+#define channel_readl(fhc, name) \
+	readl(&(__fhc_regs(fhc)->name))
+#define channel_writel(fhc, name, val) \
+	writel((val), &(__fhc_regs(fhc)->name))
+
+static inline struct fh_dma_chan *to_fh_dma_chan(struct dma_chan *chan)
+{
+	return container_of(chan, struct fh_dma_chan, chan);
+}
+
+struct fh_dma {
+	struct dma_device	dma;
+	void __iomem		*regs;
+	struct tasklet_struct	tasklet;
+	struct clk		*clk;
+
+	u8			all_chan_mask;
+
+	struct fh_dma_chan	chan[0];
+};
+
+static inline struct fh_dma_regs __iomem *__fh_regs(struct fh_dma *fh)
+{
+	return fh->regs;
+}
+
+#define dma_readl(fh, name) \
+	readl(&(__fh_regs(fh)->name))
+#define dma_writel(fh, name, val) \
+	writel((val), &(__fh_regs(fh)->name))
+
+#define channel_set_bit(fh, reg, mask) \
+	dma_writel(fh, reg, ((mask) << 8) | (mask))
+#define channel_clear_bit(fh, reg, mask) \
+	dma_writel(fh, reg, ((mask) << 8) | 0)
+
+static inline struct fh_dma *to_fh_dma(struct dma_device *ddev)
+{
+	return container_of(ddev, struct fh_dma, dma);
+}
+
+/* LLI == Linked List Item; a.k.a. DMA block descriptor */
+struct fh_lli {
+	/* values that are not changed by hardware */
+	u32	sar;
+	u32	dar;
+	u32	llp;		/* chain to next lli */
+	u32		ctllo;
+	/* values that may get written back: */
+	u32		ctlhi;
+	/* sstat and dstat can snapshot peripheral register state.
+	 * silicon config may discard either or both...
+	 */
+	u32		sstat;
+	u32		dstat;
+};
+
+struct fh_desc {
+	/* FIRST values the hardware uses */
+	struct fh_lli			lli;
+
+	/* THEN values for driver housekeeping */
+	struct list_head		desc_node;
+	struct list_head		tx_list;
+	struct dma_async_tx_descriptor	txd;
+	size_t				len;
+};
+
+static inline struct fh_desc *
+txd_to_fh_desc(struct dma_async_tx_descriptor *txd)
+{
+	return container_of(txd, struct fh_desc, txd);
+}
diff -uraN linux-3.0.8/drivers/dma/Kconfig linux-3.0.8-fh8632-V1.0_20180330/drivers/dma/Kconfig
--- linux-3.0.8/drivers/dma/Kconfig	2021-07-14 21:52:01.971130984 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/dma/Kconfig	2021-07-13 23:40:34.834363488 +0300
@@ -89,6 +89,25 @@
 	  Support the Synopsys DesignWare AHB DMA controller.  This
 	  can be integrated in chips such as the Atmel AT32ap7000.
 
+config FH_DMAC
+	tristate "FH DesignWare AHB DMA support"
+	depends on HAVE_CLK
+	select DMA_ENGINE
+
+	help
+	  Support the Synopsys DesignWare AHB DMA controller.  This
+	  can be integrated in chips such as the FullHan.
+	  
+if FH_DMAC
+
+config FH_DMAC_MISC
+	bool "FH DMAC Misc Device Enable"
+	default y
+	help
+	  FH DMAC Misc Device Enable
+
+endif
+	  
 config AT_HDMAC
 	tristate "Atmel AHB DMA support"
 	depends on ARCH_AT91SAM9RL || ARCH_AT91SAM9G45
@@ -271,5 +290,7 @@
 	help
 	  Simple DMA test client. Say N unless you're debugging a
 	  DMA Device driver.
-
 endif
+
+
+
diff -uraN linux-3.0.8/drivers/dma/Makefile linux-3.0.8-fh8632-V1.0_20180330/drivers/dma/Makefile
--- linux-3.0.8/drivers/dma/Makefile	2021-07-14 21:52:01.971130984 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/dma/Makefile	2021-07-13 23:40:34.822363413 +0300
@@ -25,3 +25,4 @@
 obj-$(CONFIG_PL330_DMA) += pl330.o
 obj-$(CONFIG_PCH_DMA) += pch_dma.o
 obj-$(CONFIG_AMBA_PL08X) += amba-pl08x.o
+obj-$(CONFIG_FH_DMAC) += fh_dmac.o
\ No newline at end of file
diff -uraN linux-3.0.8/drivers/gpio/fh_gpio.c linux-3.0.8-fh8632-V1.0_20180330/drivers/gpio/fh_gpio.c
--- linux-3.0.8/drivers/gpio/fh_gpio.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/gpio/fh_gpio.c	2021-07-13 23:40:34.638362282 +0300
@@ -0,0 +1,507 @@
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <asm-generic/gpio.h>
+#include <mach/gpio.h>
+
+struct fh_gpio_chip *fh_gpio0, *fh_gpio1;
+
+static inline void __iomem* gpio_to_base(unsigned int gpio)
+{
+    if (gpio >= 32 && gpio < 64)
+    {
+        return fh_gpio1->base;
+    }
+    else if(gpio < 32)
+    {
+        return fh_gpio0->base;
+    }
+    else
+    {
+        pr_err("ERROR: incorrect GPIO num\n");
+        return NULL;
+    }
+}
+
+static int _set_gpio_irq_type(unsigned int gpio, unsigned int type)
+{
+    u32 int_type, int_polarity;
+    u32 bit = gpio % 32;
+    void __iomem* base;
+    base = gpio_to_base(gpio);
+
+    switch (type & IRQF_TRIGGER_MASK) {
+    case IRQ_TYPE_EDGE_BOTH:
+        int_type = GPIO_INT_TYPE_EDGE;
+        // toggle trigger
+        if (FH_GPIO_GetValue((u32)base, bit))
+            int_polarity = GPIO_INT_POL_LOW;
+        else
+            int_polarity = GPIO_INT_POL_HIGH;
+        break;
+    case IRQ_TYPE_EDGE_RISING:
+        int_type = GPIO_INT_TYPE_EDGE;
+        int_polarity = GPIO_INT_POL_HIGH;
+        break;
+    case IRQ_TYPE_EDGE_FALLING:
+        int_type = GPIO_INT_TYPE_EDGE;
+        int_polarity = GPIO_INT_POL_LOW;
+        break;
+    case IRQ_TYPE_LEVEL_HIGH:
+        int_type = GPIO_INT_TYPE_LEVEL;
+        int_polarity = GPIO_INT_POL_HIGH;
+        break;
+    case IRQ_TYPE_LEVEL_LOW:
+        int_type = GPIO_INT_TYPE_LEVEL;
+        int_polarity = GPIO_INT_POL_LOW;
+        break;
+    case IRQ_TYPE_NONE:
+        return 0;
+    default:
+        return -EINVAL;
+    }
+    FH_GPIO_SetInterruptType((u32)base, bit, int_type);
+    FH_GPIO_SetInterruptPolarity((u32)base, bit, int_polarity);
+    return 0;
+}
+
+int fh_set_gpio_irq(struct gpio_irq_info * info)
+{
+    void __iomem* base;
+    base = gpio_to_base(info->irq_gpio);
+
+    return _set_gpio_irq_type(info->irq_gpio, info->irq_type);
+}
+EXPORT_SYMBOL(fh_set_gpio_irq);
+
+void fh_irq_enable(unsigned int gpio)
+{
+    void __iomem* base;
+    int gpio_num = gpio % 32;
+    base = gpio_to_base(gpio);
+
+    FH_GPIO_EnableInterrupt((u32)base, gpio_num, TRUE);
+}
+EXPORT_SYMBOL(fh_irq_enable);
+
+void fh_irq_disable(unsigned int gpio)
+{
+    void __iomem* base;
+    int gpio_num = gpio % 32;
+    base = gpio_to_base(gpio);
+
+    FH_GPIO_EnableInterrupt((u32)base, gpio_num, FALSE);
+}
+EXPORT_SYMBOL(fh_irq_disable);
+
+void fh_clear_gpio_irq(int gpio_id)
+{
+    void __iomem* base;
+    int gpio_num = gpio_id % 32;
+    base = gpio_to_base(gpio_id);
+
+    FH_GPIO_ClearInterrupt((u32)base, gpio_num);
+}
+EXPORT_SYMBOL(fh_clear_gpio_irq);
+
+
+static inline void __iomem* irq_to_controller(struct irq_data* d)
+{
+    struct fh_gpio_chip *fh_gpio = irq_data_get_irq_chip_data(d);
+
+    if (likely(d->irq >= NR_INTERNAL_IRQS))
+        return fh_gpio->base;
+    pr_err("irq num: %d is not a gpio irq!\n", d->irq);
+    return 0;
+}
+
+static void gpio_irq_ack(struct irq_data* d)
+{
+    void __iomem* base;
+    struct fh_gpio_chip *fh_gpio = irq_data_get_irq_chip_data(d);
+    base = irq_to_controller(d);
+
+    FH_GPIO_ClearInterrupt((u32)base, d->irq - NR_INTERNAL_IRQS - fh_gpio->chip.base);
+}
+
+static void gpio_irq_enable(struct irq_data *d)
+{
+    void __iomem* base;
+    struct fh_gpio_chip *fh_gpio = irq_data_get_irq_chip_data(d);
+    base = irq_to_controller(d);
+
+    FH_GPIO_EnableInterrupt((u32)base, d->irq - NR_INTERNAL_IRQS - fh_gpio->chip.base, TRUE);
+}
+
+static void gpio_irq_disable(struct irq_data *d)
+{
+    void __iomem* base;
+    struct fh_gpio_chip *fh_gpio = irq_data_get_irq_chip_data(d);
+    base = irq_to_controller(d);
+
+    FH_GPIO_EnableInterrupt((u32)base, d->irq - NR_INTERNAL_IRQS - fh_gpio->chip.base, FALSE);
+}
+
+static void gpio_irq_mask(struct irq_data *d)
+{
+    void __iomem* base;
+    struct fh_gpio_chip *fh_gpio = irq_data_get_irq_chip_data(d);
+    base = irq_to_controller(d);
+
+    FH_GPIO_EnableInterruptMask((u32)base, d->irq - NR_INTERNAL_IRQS - fh_gpio->chip.base, TRUE);
+}
+
+static void gpio_irq_unmask(struct irq_data *d)
+{
+    void __iomem* base;
+    struct fh_gpio_chip *fh_gpio = irq_data_get_irq_chip_data(d);
+    base = irq_to_controller(d);
+
+    FH_GPIO_EnableInterruptMask((u32)base, d->irq - NR_INTERNAL_IRQS - fh_gpio->chip.base, FALSE);
+}
+
+static int gpio_irq_type(struct irq_data *d, unsigned int type)
+{
+    void __iomem* base;
+    base = irq_to_controller(d);
+
+    return _set_gpio_irq_type(d->irq - NR_INTERNAL_IRQS, type);
+}
+
+#ifdef CONFIG_PM
+
+static int gpio_irq_set_wake(struct irq_data *d, unsigned value)
+{
+    struct fh_gpio_chip *fh_gpio = irq_data_get_irq_chip_data(d);
+
+    if (unlikely(d->irq >= NR_IRQS))
+        return -EINVAL;
+
+    if (value)
+        fh_gpio->gpio_wakeups |= (1 << (d->irq - NR_INTERNAL_IRQS - fh_gpio->chip.base));
+    else
+        fh_gpio->gpio_wakeups &= ~(1 << (d->irq - NR_INTERNAL_IRQS - fh_gpio->chip.base));
+
+    return 0;
+}
+
+void fh_gpio_irq_suspend(void)
+{
+    fh_gpio0->gpio_backups = FH_GPIO_GetEnableInterrupts((u32)fh_gpio0->base);
+    fh_gpio1->gpio_backups = FH_GPIO_GetEnableInterrupts((u32)fh_gpio1->base);
+
+    FH_GPIO_SetEnableInterrupts((u32)fh_gpio0->base, fh_gpio0->gpio_wakeups);
+    FH_GPIO_SetEnableInterrupts((u32)fh_gpio1->base, fh_gpio1->gpio_wakeups);
+}
+
+void fh_gpio_irq_resume(void)
+{
+    FH_GPIO_SetEnableInterrupts((u32)fh_gpio0->base, fh_gpio0->gpio_backups);
+    FH_GPIO_SetEnableInterrupts((u32)fh_gpio1->base, fh_gpio1->gpio_backups);
+}
+
+#else
+#define gpio_irq_set_wake   NULL
+#endif
+
+static struct irq_chip gpio_irqchip = {
+    .name           = "FH_GPIO_INTC",
+    .irq_ack        = gpio_irq_ack,
+    .irq_enable     = gpio_irq_enable,
+    .irq_disable    = gpio_irq_disable,
+    .irq_mask       = gpio_irq_mask,
+    .irq_unmask     = gpio_irq_unmask,
+    .irq_set_type   = gpio_irq_type,
+    .irq_set_wake   = gpio_irq_set_wake,
+};
+
+static void gpio_toggle_trigger(unsigned int gpio, unsigned int offs)
+{
+    u32 int_polarity;
+    int gpio_num = gpio % 32;
+    void __iomem* base = gpio_to_base(gpio);
+
+    if (FH_GPIO_GetValue((u32)base, gpio))
+        int_polarity = GPIO_INT_POL_LOW;
+    else
+        int_polarity = GPIO_INT_POL_HIGH;
+
+    printk(">>>>> do trigger gpio=%d, set polarity=%x\n", offs, int_polarity);
+    FH_GPIO_SetInterruptPolarity((u32)base, gpio_num, int_polarity);
+}
+
+static inline u32 irq_get_trigger_type(unsigned int irq)
+{
+    struct irq_data *d = irq_get_irq_data(irq);
+    return d ? irqd_get_trigger_type(d) : 0;
+}
+
+static void gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
+{
+    struct irq_data *irqdata = irq_desc_get_irq_data(desc);
+    struct irq_chip *irqchip = irq_data_get_irq_chip(irqdata);
+    struct fh_gpio_chip *fh_gpio = irq_data_get_irq_chip_data(irqdata);
+    u32 irq_status;
+    int gpio_num, gpio;
+
+    irq_status = FH_GPIO_GetInterruptStatus((u32)fh_gpio->base);
+
+    if (unlikely(irq_status == 0)) {
+        pr_err("gpio irq status is zero.\n");
+        return;
+    }
+
+    /* temporarily mask (level sensitive) parent IRQ */
+    irqchip->irq_mask(irqdata);
+
+    gpio_num = fls(irq_status) - 1;
+
+    FH_GPIO_ClearInterrupt((u32)fh_gpio->base, gpio_num);
+
+    gpio = gpio_num + fh_gpio->chip.base;
+
+    generic_handle_irq(gpio_to_irq(gpio));
+
+    if ((irq_get_trigger_type(gpio_to_irq(gpio)) & IRQ_TYPE_SENSE_MASK)
+            == IRQ_TYPE_EDGE_BOTH)
+        gpio_toggle_trigger(gpio, gpio_num);
+
+    irqchip->irq_unmask(irqdata);
+    /* now it may re-trigger */
+}
+
+/*
+ * This lock class tells lockdep that GPIO irqs are in a different
+ * category than their parents, so it won't report false recursion.
+ */
+static struct lock_class_key gpio_lock_class;
+
+static void fh_gpio_irq_init(struct platform_device *pdev)
+{
+    int i, gpio_irq;
+    struct fh_gpio_chip *plat_data;
+
+    plat_data = pdev->dev.platform_data;
+
+    for (i = 0; i < 32; i++) {
+        gpio_irq = i + NR_INTERNAL_IRQS + 32 * pdev->id;
+        irq_set_lockdep_class(gpio_irq, &gpio_lock_class);
+        irq_set_chip_and_handler(gpio_irq, &gpio_irqchip, handle_simple_irq);
+        set_irq_flags(gpio_irq, IRQF_VALID);
+        irq_set_chip_data(gpio_irq, plat_data);
+    }
+
+    irq_set_chip_data(plat_data->irq, plat_data);
+    irq_set_chained_handler(plat_data->irq, gpio_irq_handler);
+    enable_irq_wake(plat_data->irq);
+}
+
+static int chip_to_irq(struct gpio_chip *c, unsigned offset)
+{
+    struct fh_gpio_chip* chip;
+    chip = container_of(c, struct fh_gpio_chip, chip);
+    return offset + NR_INTERNAL_IRQS + chip->chip.base;
+}
+
+static int chip_gpio_get(struct gpio_chip *c, unsigned offset)
+{
+    u32 bit = offset % 32;
+    struct fh_gpio_chip* chip;
+    chip = container_of(c, struct fh_gpio_chip, chip);
+
+    if(offset / 32)
+	    return FH_GPIOB_GetValue((u32)chip->base, bit);
+    else
+	    return FH_GPIO_GetValue((u32)chip->base, bit);
+}
+
+static void chip_gpio_set(struct gpio_chip *c, unsigned offset, int val)
+{
+    u32 bit = offset % 32;
+    struct fh_gpio_chip* chip;
+    chip = container_of(c, struct fh_gpio_chip, chip);
+    if(offset / 32)
+	    FH_GPIOB_SetValue((u32)chip->base, bit, val);
+    else
+	    FH_GPIO_SetValue((u32)chip->base, bit, val);
+}
+
+static int chip_direction_input(struct gpio_chip *c, unsigned offset)
+{
+    u32 bit = offset % 32;
+    unsigned long flags;
+    struct fh_gpio_chip* chip;
+    chip = container_of(c, struct fh_gpio_chip, chip);
+    spin_lock_irqsave(&chip->lock, flags);
+    if(offset / 32)
+	    FH_GPIOB_SetDirection((u32)chip->base, bit, GPIO_DIR_INPUT);
+    else
+	    FH_GPIO_SetDirection((u32)chip->base, bit, GPIO_DIR_INPUT);
+    spin_unlock_irqrestore(&chip->lock, flags);
+
+    return 0;
+}
+
+static int chip_direction_output(struct gpio_chip *c, unsigned offset, int val)
+{
+    u32 bit = offset % 32;
+    unsigned long flags;
+    struct fh_gpio_chip* chip;
+    chip = container_of(c, struct fh_gpio_chip, chip);
+
+    spin_lock_irqsave(&chip->lock, flags);
+    if(offset / 32)
+    {
+	    FH_GPIOB_SetDirection((u32)chip->base, bit, GPIO_DIR_OUTPUT);
+	    FH_GPIOB_SetValue((u32)chip->base, bit, val);
+    }
+    else
+    {
+	    FH_GPIO_SetDirection((u32)chip->base, bit, GPIO_DIR_OUTPUT);
+	    FH_GPIO_SetValue((u32)chip->base, bit, val);
+    }
+    spin_unlock_irqrestore(&chip->lock, flags);
+
+    return 0;
+}
+
+void fh_gpio_set(int gpio_id, int value)
+{
+    __gpio_set_value(gpio_id, value);
+}
+EXPORT_SYMBOL(fh_gpio_set);
+
+int fh_gpio_get(int gpio_id, int* value)
+{
+    *value = __gpio_get_value(gpio_id);
+    return 0;
+}
+EXPORT_SYMBOL(fh_gpio_get);
+
+int fh_gpio_reset(int gpio_id)
+{
+    return 0;
+}
+EXPORT_SYMBOL(fh_gpio_reset);
+
+static int __devinit fh_gpio_probe(struct platform_device *pdev)
+{
+    struct resource *res;
+    int err = -EIO;
+    struct fh_gpio_chip *plat_data;
+
+    /* There are two ways to get the GPIO base address; one is by
+     * fetching it from MSR_LBAR_GPIO, the other is by reading the
+     * PCI BAR info.  The latter method is easier (especially across
+     * different architectures), so we'll stick with that for now.  If
+     * it turns out to be unreliable in the face of crappy BIOSes, we
+     * can always go back to using MSRs.. */
+
+    plat_data = pdev->dev.platform_data;
+    plat_data->chip.get = chip_gpio_get;
+    plat_data->chip.set = chip_gpio_set;
+    plat_data->chip.direction_input = chip_direction_input;
+    plat_data->chip.direction_output = chip_direction_output;
+    plat_data->chip.to_irq = chip_to_irq;
+
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!res) {
+        dev_err(&pdev->dev, "can't fetch device resource info\n");
+        goto done;
+    }
+
+    if (!request_mem_region(res->start, resource_size(res), pdev->name)) {
+        dev_err(&pdev->dev, "can't request region\n");
+        goto done;
+    }
+
+    /* set up the driver-specific struct */
+    plat_data->base = ioremap(res->start, resource_size(res));
+
+    if(pdev->id)
+        fh_gpio1 = plat_data;
+    else
+        fh_gpio0 = plat_data;
+
+    plat_data->pdev = pdev;
+    spin_lock_init(&plat_data->lock);
+    res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+    if (!res) {
+        pr_err("%s: ERROR: getting resource failed"
+               "cannot get IORESOURCE_MEM\n", __func__);
+        goto release_region;
+    }
+    plat_data->irq = res->start;
+
+    /* finally, register with the generic GPIO API */
+    err = gpiochip_add(&plat_data->chip);
+    if (err) {
+        pr_err("GPIO support load fail.\n");
+        goto release_region;
+    }
+
+    fh_gpio_irq_init(pdev);
+    pr_debug("GPIO support successfully loaded.\n\tBase Addr: 0x%p\n",
+         plat_data->base);
+
+    return 0;
+
+release_region:
+    release_region(res->start, resource_size(res));
+done:
+    return err;
+}
+
+static int __devexit fh_gpio_remove(struct platform_device *pdev)
+{
+    struct resource *r;
+    int err;
+    struct fh_gpio_chip *plat_data;
+
+    plat_data = pdev->dev.platform_data;
+    err = gpiochip_remove(&plat_data->chip);
+    if (err) {
+        dev_err(&pdev->dev, "unable to remove gpio_chip\n");
+        return err;
+    }
+
+    iounmap(plat_data->base);
+
+    r = platform_get_resource(pdev, IORESOURCE_IO, 0);
+    release_region(r->start, resource_size(r));
+    return 0;
+}
+
+static struct platform_driver fh_gpio_driver = {
+    .driver = {
+        .name = GPIO_NAME,
+        .owner = THIS_MODULE,
+    },
+    .probe = fh_gpio_probe,
+    .remove = __devexit_p(fh_gpio_remove),
+};
+
+static int __init fh_gpio_init(void)
+{
+    return platform_driver_register(&fh_gpio_driver);
+}
+
+static void __exit fh_gpio_exit(void)
+{
+    platform_driver_unregister(&fh_gpio_driver);
+}
+
+module_init(fh_gpio_init);
+module_exit(fh_gpio_exit);
+
+MODULE_AUTHOR("QIN");
+MODULE_DESCRIPTION("FH GPIO Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform: FH");
diff -uraN linux-3.0.8/drivers/gpio/Kconfig linux-3.0.8-fh8632-V1.0_20180330/drivers/gpio/Kconfig
--- linux-3.0.8/drivers/gpio/Kconfig	2021-07-14 21:52:02.007131088 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/gpio/Kconfig	2021-07-13 23:40:34.642362306 +0300
@@ -85,6 +85,11 @@
 	tristate "IT8761E GPIO support"
 	help
 	  Say yes here to support GPIO functionality of IT8761E super I/O chip.
+	  
+config GPIO_FH
+	tristate "FH GPIO support"
+	help
+	  Say yes here to support GPIO functionality of FH.
 
 config GPIO_EXYNOS4
 	def_bool y
diff -uraN linux-3.0.8/drivers/gpio/Makefile linux-3.0.8-fh8632-V1.0_20180330/drivers/gpio/Makefile
--- linux-3.0.8/drivers/gpio/Makefile	2021-07-14 21:52:02.007131088 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/gpio/Makefile	2021-07-13 23:40:34.638362282 +0300
@@ -34,6 +34,7 @@
 obj-$(CONFIG_GPIO_CS5535)	+= cs5535-gpio.o
 obj-$(CONFIG_GPIO_BT8XX)	+= bt8xxgpio.o
 obj-$(CONFIG_GPIO_IT8761E)	+= it8761e_gpio.o
+obj-$(CONFIG_GPIO_FH)		+= fh_gpio.o
 obj-$(CONFIG_GPIO_VR41XX)	+= vr41xx_giu.o
 obj-$(CONFIG_GPIO_WM831X)	+= wm831x-gpio.o
 obj-$(CONFIG_GPIO_WM8350)	+= wm8350-gpiolib.o
diff -uraN linux-3.0.8/drivers/i2c/busses/i2c_fh_interrupt.c linux-3.0.8-fh8632-V1.0_20180330/drivers/i2c/busses/i2c_fh_interrupt.c
--- linux-3.0.8/drivers/i2c/busses/i2c_fh_interrupt.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/i2c/busses/i2c_fh_interrupt.c	2021-07-13 23:40:34.802363291 +0300
@@ -0,0 +1,928 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/clk.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <mach/i2c.h>
+//#define FH_I2C_DEBUG
+
+#ifdef FH_I2C_DEBUG
+#define PRINT_DBG(fmt, args...)  printk(fmt, ## args)
+#else
+#define PRINT_DBG(fmt, args...)  do { } while (0)
+#endif
+
+/*
+ * Registers offset
+ */
+#define DW_IC_CON		0x0
+#define DW_IC_TAR		0x4
+#define DW_IC_DATA_CMD		0x10
+#define DW_IC_SS_SCL_HCNT	0x14
+#define DW_IC_SS_SCL_LCNT	0x18
+#define DW_IC_FS_SCL_HCNT	0x1c
+#define DW_IC_FS_SCL_LCNT	0x20
+#define DW_IC_INTR_STAT		0x2c
+#define DW_IC_INTR_MASK		0x30
+#define DW_IC_RAW_INTR_STAT	0x34
+#define DW_IC_RX_TL		0x38
+#define DW_IC_TX_TL		0x3c
+#define DW_IC_CLR_INTR		0x40
+#define DW_IC_CLR_RX_UNDER	0x44
+#define DW_IC_CLR_RX_OVER	0x48
+#define DW_IC_CLR_TX_OVER	0x4c
+#define DW_IC_CLR_RD_REQ	0x50
+#define DW_IC_CLR_TX_ABRT	0x54
+#define DW_IC_CLR_RX_DONE	0x58
+#define DW_IC_CLR_ACTIVITY	0x5c
+#define DW_IC_CLR_STOP_DET	0x60
+#define DW_IC_CLR_START_DET	0x64
+#define DW_IC_CLR_GEN_CALL	0x68
+#define DW_IC_ENABLE		0x6c
+#define DW_IC_STATUS		0x70
+#define DW_IC_TXFLR		0x74
+#define DW_IC_RXFLR		0x78
+#define DW_IC_COMP_PARAM_1	0xf4
+#define DW_IC_TX_ABRT_SOURCE	0x80
+
+#define DW_IC_CON_MASTER		0x1
+#define DW_IC_CON_SPEED_STD		0x2
+#define DW_IC_CON_SPEED_FAST		0x4
+#define DW_IC_CON_10BITADDR_MASTER	0x10
+#define DW_IC_CON_RESTART_EN		0x20
+#define DW_IC_CON_SLAVE_DISABLE		0x40
+
+#define DW_IC_INTR_RX_UNDER	0x001
+#define DW_IC_INTR_RX_OVER	0x002
+#define DW_IC_INTR_RX_FULL	0x004
+#define DW_IC_INTR_TX_OVER	0x008
+#define DW_IC_INTR_TX_EMPTY	0x010
+#define DW_IC_INTR_RD_REQ	0x020
+#define DW_IC_INTR_TX_ABRT	0x040
+#define DW_IC_INTR_RX_DONE	0x080
+#define DW_IC_INTR_ACTIVITY	0x100
+#define DW_IC_INTR_STOP_DET	0x200
+#define DW_IC_INTR_START_DET	0x400
+#define DW_IC_INTR_GEN_CALL	0x800
+
+#define DW_IC_INTR_DEFAULT_MASK		(DW_IC_INTR_RX_FULL | \
+					 DW_IC_INTR_TX_EMPTY | \
+					 DW_IC_INTR_TX_ABRT | \
+					 DW_IC_INTR_STOP_DET)
+
+#define DW_IC_STATUS_ACTIVITY	0x1
+#define DW_IC_STATUS_MASTER_ACTIVITY   0x20
+
+#define DW_IC_ERR_TX_ABRT	0x1
+
+/*
+ * status codes
+ */
+#define STATUS_IDLE			0x0
+#define STATUS_WRITE_IN_PROGRESS	0x1
+#define STATUS_READ_IN_PROGRESS		0x2
+
+#define TIMEOUT			20 /* ms */
+
+/*
+ * hardware abort codes from the DW_IC_TX_ABRT_SOURCE register
+ *
+ * only expected abort codes are listed here
+ * refer to the datasheet for the full list
+ */
+#define ABRT_7B_ADDR_NOACK	0
+#define ABRT_10ADDR1_NOACK	1
+#define ABRT_10ADDR2_NOACK	2
+#define ABRT_TXDATA_NOACK	3
+#define ABRT_GCALL_NOACK	4
+#define ABRT_GCALL_READ		5
+#define ABRT_SBYTE_ACKDET	7
+#define ABRT_SBYTE_NORSTRT	9
+#define ABRT_10B_RD_NORSTRT	10
+#define ABRT_MASTER_DIS		11
+#define ARB_LOST		12
+
+#define DW_IC_TX_ABRT_7B_ADDR_NOACK	(1UL << ABRT_7B_ADDR_NOACK)
+#define DW_IC_TX_ABRT_10ADDR1_NOACK	(1UL << ABRT_10ADDR1_NOACK)
+#define DW_IC_TX_ABRT_10ADDR2_NOACK	(1UL << ABRT_10ADDR2_NOACK)
+#define DW_IC_TX_ABRT_TXDATA_NOACK	(1UL << ABRT_TXDATA_NOACK)
+#define DW_IC_TX_ABRT_GCALL_NOACK	(1UL << ABRT_GCALL_NOACK)
+#define DW_IC_TX_ABRT_GCALL_READ	(1UL << ABRT_GCALL_READ)
+#define DW_IC_TX_ABRT_SBYTE_ACKDET	(1UL << ABRT_SBYTE_ACKDET)
+#define DW_IC_TX_ABRT_SBYTE_NORSTRT	(1UL << ABRT_SBYTE_NORSTRT)
+#define DW_IC_TX_ABRT_10B_RD_NORSTRT	(1UL << ABRT_10B_RD_NORSTRT)
+#define DW_IC_TX_ABRT_MASTER_DIS	(1UL << ABRT_MASTER_DIS)
+#define DW_IC_TX_ARB_LOST		(1UL << ARB_LOST)
+
+#define DW_IC_TX_ABRT_NOACK		(DW_IC_TX_ABRT_7B_ADDR_NOACK | \
+					 DW_IC_TX_ABRT_10ADDR1_NOACK | \
+					 DW_IC_TX_ABRT_10ADDR2_NOACK | \
+					 DW_IC_TX_ABRT_TXDATA_NOACK | \
+					 DW_IC_TX_ABRT_GCALL_NOACK)
+
+static char *abort_sources[] = {
+	[ABRT_7B_ADDR_NOACK] =
+		"slave address not acknowledged (7bit mode)",
+	[ABRT_10ADDR1_NOACK] =
+		"first address byte not acknowledged (10bit mode)",
+	[ABRT_10ADDR2_NOACK] =
+		"second address byte not acknowledged (10bit mode)",
+	[ABRT_TXDATA_NOACK] =
+		"data not acknowledged",
+	[ABRT_GCALL_NOACK] =
+		"no acknowledgement for a general call",
+	[ABRT_GCALL_READ] =
+		"read after general call",
+	[ABRT_SBYTE_ACKDET] =
+		"start byte acknowledged",
+	[ABRT_SBYTE_NORSTRT] =
+		"trying to send start byte when restart is disabled",
+	[ABRT_10B_RD_NORSTRT] =
+		"trying to read when restart is disabled (10bit mode)",
+	[ABRT_MASTER_DIS] =
+		"trying to use disabled adapter",
+	[ARB_LOST] =
+		"lost arbitration",
+};
+
+/**
+ * struct fh_i2c_dev - private i2c-designware data
+ * @dev: driver model device node
+ * @base: IO registers pointer
+ * @cmd_complete: tx completion indicator
+ * @lock: protect this struct and IO registers
+ * @clk: input reference clock
+ * @cmd_err: run time hadware error code
+ * @msgs: points to an array of messages currently being transferred
+ * @msgs_num: the number of elements in msgs
+ * @msg_write_idx: the element index of the current tx message in the msgs
+ *	array
+ * @tx_buf_len: the length of the current tx buffer
+ * @tx_buf: the current tx buffer
+ * @msg_read_idx: the element index of the current rx message in the msgs
+ *	array
+ * @rx_buf_len: the length of the current rx buffer
+ * @rx_buf: the current rx buffer
+ * @msg_err: error status of the current transfer
+ * @status: i2c master status, one of STATUS_*
+ * @abort_source: copy of the TX_ABRT_SOURCE register
+ * @irq: interrupt number for the i2c master
+ * @adapter: i2c subsystem adapter node
+ * @tx_fifo_depth: depth of the hardware tx fifo
+ * @rx_fifo_depth: depth of the hardware rx fifo
+ */
+struct fh_i2c_dev {
+	struct device		*dev;
+	void __iomem		*base;
+	struct completion	cmd_complete;
+	struct mutex		lock;
+	struct clk		*clk;
+	int			cmd_err;
+	struct i2c_msg		*msgs;
+	int			msgs_num;
+	int			msg_write_idx;
+	u32			tx_buf_len;
+	u8			*tx_buf;
+	int			msg_read_idx;
+	u32			rx_buf_len;
+	u8			*rx_buf;
+	int			msg_err;
+	unsigned int		status;
+	u32			abort_source;
+	int			irq;
+	struct i2c_adapter	adapter;
+	unsigned int		tx_fifo_depth;
+	unsigned int		rx_fifo_depth;
+};
+
+
+static int i2c_fh_wait_master_not_active(struct fh_i2c_dev *dev)
+{
+    int timeout = 200;  //2000 us
+
+    while (I2c_IsActiveMst( dev->base))
+    {
+        if (timeout <= 0)
+        {
+            dev_warn(dev->dev, "timeout waiting for master not active\n");
+            return -ETIMEDOUT;
+        }
+        timeout--;
+        udelay(10);
+    }
+
+    return 0;
+}
+
+static u32
+i2c_fh_scl_hcnt(u32 ic_clk, u32 tSYMBOL, u32 tf, int cond, int offset)
+{
+	/*
+	 * DesignWare I2C core doesn't seem to have solid strategy to meet
+	 * the tHD;STA timing spec.  Configuring _HCNT based on tHIGH spec
+	 * will result in violation of the tHD;STA spec.
+	 */
+	if (cond)
+		/*
+		 * Conditional expression:
+		 *
+		 *   IC_[FS]S_SCL_HCNT + (1+4+3) >= IC_CLK * tHIGH
+		 *
+		 * This is based on the DW manuals, and represents an ideal
+		 * configuration.  The resulting I2C bus speed will be
+		 * faster than any of the others.
+		 *
+		 * If your hardware is free from tHD;STA issue, try this one.
+		 */
+		return (ic_clk * tSYMBOL + 5000) / 10000 - 8 + offset;
+	else
+		/*
+		 * Conditional expression:
+		 *
+		 *   IC_[FS]S_SCL_HCNT + 3 >= IC_CLK * (tHD;STA + tf)
+		 *
+		 * This is just experimental rule; the tHD;STA period turned
+		 * out to be proportinal to (_HCNT + 3).  With this setting,
+		 * we could meet both tHIGH and tHD;STA timing specs.
+		 *
+		 * If unsure, you'd better to take this alternative.
+		 *
+		 * The reason why we need to take into account "tf" here,
+		 * is the same as described in i2c_fh_scl_lcnt().
+		 */
+		return (ic_clk * (tSYMBOL + tf) + 5000) / 10000 - 3 + offset;
+}
+
+static u32 i2c_fh_scl_lcnt(u32 ic_clk, u32 tLOW, u32 tf, int offset)
+{
+	/*
+	 * Conditional expression:
+	 *
+	 *   IC_[FS]S_SCL_LCNT + 1 >= IC_CLK * (tLOW + tf)
+	 *
+	 * DW I2C core starts counting the SCL CNTs for the LOW period
+	 * of the SCL clock (tLOW) as soon as it pulls the SCL line.
+	 * In order to meet the tLOW timing spec, we need to take into
+	 * account the fall time of SCL signal (tf).  Default tf value
+	 * should be 0.3 us, for safety.
+	 */
+	return ((ic_clk * (tLOW + tf) + 5000) / 10000) - 1 + offset;
+}
+
+/**
+ * i2c_fh_init() - initialize the designware i2c master hardware
+ * @dev: device private data
+ *
+ * This functions configures and enables the I2C master.
+ * This function is called during I2C init function, and in case of timeout at
+ * run time.
+ */
+static void i2c_fh_init(struct fh_i2c_dev *dev)
+{
+	u32 input_clock_khz = clk_get_rate(dev->clk) / 1000;
+	u32 ic_con, hcnt, lcnt;
+
+	/* Disable the adapter */
+	i2c_fh_wait_master_not_active(dev);
+	I2c_DisEnable((unsigned int)dev->base);
+
+	/* set standard and fast speed deviders for high/low periods */
+
+	/* Standard-mode */
+	hcnt = i2c_fh_scl_hcnt(input_clock_khz,
+				40,	/* tHD;STA = tHIGH = 4.0 us */
+				3,	/* tf = 0.3 us */
+				0,	/* 0: DW default, 1: Ideal */
+				0);	/* No offset */
+	lcnt = i2c_fh_scl_lcnt(input_clock_khz,
+				47,	/* tLOW = 4.7 us */
+				3,	/* tf = 0.3 us */
+				0);	/* No offset */
+	I2c_SetSsHcnt( dev->base ,hcnt);
+	I2c_SetSsLcnt( dev->base ,lcnt);
+	pr_info("\tClock: %dkhz, Standard-mode HCNT:LCNT = %d:%d\n", input_clock_khz, hcnt, lcnt);
+
+	/* Fast-mode */
+	hcnt = i2c_fh_scl_hcnt(input_clock_khz,
+				6,	/* tHD;STA = tHIGH = 0.6 us */
+				3,	/* tf = 0.3 us */
+				0,	/* 0: DW default, 1: Ideal */
+				0);	/* No offset */
+	lcnt = i2c_fh_scl_lcnt(input_clock_khz,
+				13,	/* tLOW = 1.3 us */
+				3,	/* tf = 0.3 us */
+				0);	/* No offset */
+	I2c_SetFsHcnt( dev->base ,hcnt);
+	I2c_SetFsLcnt( dev->base ,lcnt);
+	//dev_dbg(dev->dev, "Fast-mode HCNT:LCNT = %d:%d\n", hcnt, lcnt);
+
+	/* Configure Tx/Rx FIFO threshold levels */
+
+	I2c_SetTxRxTl(dev->base  ,dev->tx_fifo_depth - 1,0);
+	/* configure the i2c master */
+	ic_con = DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |
+		/*DW_IC_CON_RESTART_EN |*/ DW_IC_CON_SPEED_FAST;/// DW_IC_CON_SPEED_STD;
+	I2c_SetCon(dev->base,ic_con);
+
+}
+
+/*
+ * Waiting for bus not busy
+ */
+static int i2c_fh_wait_bus_not_busy(struct fh_i2c_dev *dev)
+{
+	int timeout = TIMEOUT;
+
+	while (I2c_IsActiveMst( dev->base)) {
+		if (timeout <= 0) {
+			dev_warn(dev->dev, "timeout waiting for bus ready\n");
+			return -ETIMEDOUT;
+		}
+		timeout--;
+		msleep(1);
+	}
+
+	return 0;
+}
+
+static void i2c_fh_xfer_init(struct fh_i2c_dev *dev)
+{
+	struct i2c_msg *msgs = dev->msgs;
+	u32 ic_con;
+
+	/* Disable the adapter */
+	i2c_fh_wait_master_not_active(dev);
+	I2c_DisEnable((unsigned int)dev->base);
+
+	/* set the slave (target) address */
+	I2c_SetDeviceId(dev->base,msgs[dev->msg_write_idx].addr);
+
+	/* if the slave address is ten bit address, enable 10BITADDR */
+	ic_con = I2c_GetCon(dev->base);
+	if (msgs[dev->msg_write_idx].flags & I2C_M_TEN)
+		ic_con |= DW_IC_CON_10BITADDR_MASTER;
+	else
+		ic_con &= ~DW_IC_CON_10BITADDR_MASTER;
+	I2c_SetCon(dev->base,ic_con);
+
+	/* Enable the adapter */
+	I2c_Enable(dev->base);
+
+	/* Enable interrupts */
+	I2c_SetIntrMask(dev->base,DW_IC_INTR_DEFAULT_MASK);
+
+}
+
+/*
+ * Initiate (and continue) low level master read/write transaction.
+ * This function is only called from i2c_fh_isr, and pumping i2c_msg
+ * messages into the tx buffer.  Even if the size of i2c_msg data is
+ * longer than the size of the tx buffer, it handles everything.
+ */
+static void
+i2c_fh_xfer_msg(struct fh_i2c_dev *dev)
+{
+	struct i2c_msg *msgs = dev->msgs;
+	u32 intr_mask, cmd;
+	int tx_limit, rx_limit;
+	u32 addr = msgs[dev->msg_write_idx].addr;
+	u32 buf_len = dev->tx_buf_len;
+	u8 *buf = dev->tx_buf;;
+
+	PRINT_DBG("i2c_fh_xfer_msg start, dev->msgs_num: %d\n", dev->msgs_num);
+
+	intr_mask = DW_IC_INTR_DEFAULT_MASK;
+
+	for (; dev->msg_write_idx < dev->msgs_num; dev->msg_write_idx++)
+	{
+		/*
+		 * if target address has changed, we need to
+		 * reprogram the target address in the i2c
+		 * adapter when we are done with this transfer
+		 */
+		if (msgs[dev->msg_write_idx].addr != addr) {
+			dev_err(dev->dev,
+				"%s: invalid target address\n", __func__);
+			dev->msg_err = -EINVAL;
+			break;
+		}
+
+		if (msgs[dev->msg_write_idx].len == 0) {
+			dev_err(dev->dev,
+				"%s: invalid message length\n", __func__);
+			dev->msg_err = -EINVAL;
+			break;
+		}
+
+		if (!(dev->status & STATUS_WRITE_IN_PROGRESS))
+		{
+			/* new i2c_msg */
+			buf = msgs[dev->msg_write_idx].buf;
+			buf_len = msgs[dev->msg_write_idx].len;
+
+			PRINT_DBG("new msg: len: %d, buf: 0x%x\n", buf_len, buf[0]);
+		}
+
+		tx_limit = dev->tx_fifo_depth - I2c_GetTxTl(dev->base );
+		rx_limit = dev->rx_fifo_depth - I2c_GetRxTl(dev->base );
+
+		while (buf_len > 0 && tx_limit > 0 && rx_limit > 0)
+		{
+			if (msgs[dev->msg_write_idx].flags & I2C_M_RD)
+			{
+				cmd = 0x100;
+				rx_limit--;
+			}
+			else
+			{
+				cmd = *buf++;
+			}
+
+			tx_limit--; buf_len--;
+
+			if(!buf_len)
+				cmd |= 0x200;
+
+			I2c_Write(dev->base, cmd);
+		}
+		PRINT_DBG("\n");
+
+		dev->tx_buf = buf;
+		dev->tx_buf_len = buf_len;
+
+		if (buf_len > 0)
+		{
+			/* more bytes to be written */
+			dev->status |= STATUS_WRITE_IN_PROGRESS;
+			break;
+		}
+		else
+		{
+			dev->status &= ~STATUS_WRITE_IN_PROGRESS;
+		}
+	}
+
+	/*
+	 * If i2c_msg index search is completed, we don't need TX_EMPTY
+	 * interrupt any more.
+	 */
+
+	if (dev->msg_write_idx == dev->msgs_num)
+		intr_mask &= ~DW_IC_INTR_TX_EMPTY;
+
+	if (dev->msg_err)
+		intr_mask = 0;
+
+	I2c_SetIntrMask(dev->base,intr_mask);
+
+}
+
+static void
+i2c_fh_read(struct fh_i2c_dev *dev)
+{
+	struct i2c_msg *msgs = dev->msgs;
+	int rx_valid;
+
+	for (; dev->msg_read_idx < dev->msgs_num; dev->msg_read_idx++)
+	{
+		u32 len;
+		u8 *buf;
+
+		if (!(msgs[dev->msg_read_idx].flags & I2C_M_RD))
+			continue;
+
+		if (!(dev->status & STATUS_READ_IN_PROGRESS))
+		{
+			len = msgs[dev->msg_read_idx].len;
+			buf = msgs[dev->msg_read_idx].buf;
+		}
+		else
+		{
+			PRINT_DBG("STATUS_READ_IN_PROGRESS\n");
+			len = dev->rx_buf_len;
+			buf = dev->rx_buf;
+		}
+
+		rx_valid = I2c_GetRxFLR(dev->base);
+
+		if(rx_valid == 0)
+		{
+			PRINT_DBG("rx_valid == 0\n");
+		}
+
+		for (; len > 0 && rx_valid > 0; len--, rx_valid--)
+		{
+			*buf++ = I2c_Read(dev->base);
+		}
+
+		PRINT_DBG("i2c_fh_read, len: %d, buf[0]: 0x%x\n", msgs[dev->msg_read_idx].len, msgs[dev->msg_read_idx].buf[0]);
+
+		if (len > 0)
+		{
+			PRINT_DBG("len > 0\n");
+			dev->status |= STATUS_READ_IN_PROGRESS;
+			dev->rx_buf_len = len;
+			dev->rx_buf = buf;
+			return;
+		} else
+			dev->status &= ~STATUS_READ_IN_PROGRESS;
+	}
+}
+
+static int i2c_fh_handle_tx_abort(struct fh_i2c_dev *dev)
+{
+	unsigned long abort_source = dev->abort_source;
+	int i;
+
+	if (abort_source & DW_IC_TX_ABRT_NOACK) {
+		for_each_set_bit(i, &abort_source, ARRAY_SIZE(abort_sources))
+		{
+			PRINT_DBG(
+				"%s: %s\n", __func__, abort_sources[i]);
+		}
+		return -EREMOTEIO;
+	}
+
+	for_each_set_bit(i, &abort_source, ARRAY_SIZE(abort_sources))
+		dev_err(dev->dev, "%s: %s\n", __func__, abort_sources[i]);
+
+	if (abort_source & DW_IC_TX_ARB_LOST)
+		return -EAGAIN;
+	else if (abort_source & DW_IC_TX_ABRT_GCALL_READ)
+		return -EINVAL; /* wrong msgs[] data */
+	else
+		return -EIO;
+}
+
+/*
+ * Prepare controller for a transaction and call i2c_fh_xfer_msg
+ */
+static int
+i2c_fh_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
+{
+	struct fh_i2c_dev *dev = i2c_get_adapdata(adap);
+	int ret;
+
+	PRINT_DBG("-------i2c, %s: msgs: %d\n", __func__, num);
+
+	mutex_lock(&dev->lock);
+
+	INIT_COMPLETION(dev->cmd_complete);
+	dev->msgs = msgs;
+	dev->msgs_num = num;
+	dev->cmd_err = 0;
+	dev->msg_write_idx = 0;
+	dev->msg_read_idx = 0;
+	dev->msg_err = 0;
+	dev->status = STATUS_IDLE;
+	dev->abort_source = 0;
+
+	ret = i2c_fh_wait_bus_not_busy(dev);
+	if (ret < 0)
+	{
+		goto done;
+	}
+
+	/* start the transfers */
+	i2c_fh_xfer_init(dev);
+
+	/* wait for tx to complete */
+	ret = wait_for_completion_interruptible_timeout(&dev->cmd_complete, HZ);
+	if (ret == 0) {
+		dev_err(dev->dev, "controller timed out\n");
+		i2c_fh_init(dev);
+		ret = -ETIMEDOUT;
+		goto done;
+	} else if (ret < 0)
+		goto done;
+
+	if (dev->msg_err)
+	{
+		PRINT_DBG("dev->msg_err\n");
+		ret = dev->msg_err;
+		goto done;
+	}
+
+	/* no error */
+	if (likely(!dev->cmd_err)) {
+		/* Disable the adapter */
+	    i2c_fh_wait_master_not_active(dev);
+	    I2c_DisEnable(dev->base);
+		ret = num;
+		goto done;
+	}
+
+	/* We have an error */
+	if (dev->cmd_err == DW_IC_ERR_TX_ABRT)
+	{
+		PRINT_DBG("dev->cmd_err == DW_IC_ERR_TX_ABRT\n");
+		ret = i2c_fh_handle_tx_abort(dev);
+		goto done;
+	}
+
+	ret = -EIO;
+
+done:
+	PRINT_DBG("buf: 0x%x\n", dev->msgs[num - 1].buf[0]);
+	mutex_unlock(&dev->lock);
+
+	return ret;
+}
+
+static u32 i2c_fh_func(struct i2c_adapter *adap)
+{
+	return	I2C_FUNC_I2C |
+		I2C_FUNC_SMBUS_BYTE |
+		I2C_FUNC_SMBUS_BYTE_DATA |
+		I2C_FUNC_SMBUS_WORD_DATA |
+		I2C_FUNC_SMBUS_I2C_BLOCK;
+}
+
+static u32 i2c_fh_read_clear_intrbits(struct fh_i2c_dev *dev)
+{
+	u32 stat;
+
+	/*
+	 * The IC_INTR_STAT register just indicates "enabled" interrupts.
+	 * Ths unmasked raw version of interrupt status bits are available
+	 * in the IC_RAW_INTR_STAT register.
+	 *
+	 * That is,
+	 *   stat = readl(IC_INTR_STAT);
+	 * equals to,
+	 *   stat = readl(IC_RAW_INTR_STAT) & readl(IC_INTR_MASK);
+	 *
+	 * The raw version might be useful for debugging purposes.
+	 */
+	stat = readl(dev->base + DW_IC_INTR_STAT);
+
+	/*
+	 * Do not use the IC_CLR_INTR register to clear interrupts, or
+	 * you'll miss some interrupts, triggered during the period from
+	 * readl(IC_INTR_STAT) to readl(IC_CLR_INTR).
+	 *
+	 * Instead, use the separately-prepared IC_CLR_* registers.
+	 */
+	if (stat & DW_IC_INTR_RX_UNDER)
+		I2c_ClrIntr(dev->base,DW_IC_CLR_RX_UNDER);
+	if (stat & DW_IC_INTR_RX_OVER)
+		I2c_ClrIntr(dev->base , DW_IC_CLR_RX_OVER);
+	if (stat & DW_IC_INTR_TX_OVER)
+		I2c_ClrIntr(dev->base , DW_IC_CLR_TX_OVER);
+	if (stat & DW_IC_INTR_RD_REQ)
+		I2c_ClrIntr(dev->base , DW_IC_CLR_RD_REQ);
+	if (stat & DW_IC_INTR_TX_ABRT) {
+		/*
+		 * The IC_TX_ABRT_SOURCE register is cleared whenever
+		 * the IC_CLR_TX_ABRT is read.  Preserve it beforehand.
+		 */
+		dev->abort_source = readl(dev->base + DW_IC_TX_ABRT_SOURCE);
+		I2c_ClrIntr(dev->base , DW_IC_CLR_TX_ABRT);
+	}
+	if (stat & DW_IC_INTR_RX_DONE)
+		I2c_ClrIntr(dev->base ,DW_IC_CLR_RX_DONE);
+	if (stat & DW_IC_INTR_ACTIVITY)
+		I2c_ClrIntr(dev->base ,DW_IC_CLR_ACTIVITY);
+	if (stat & DW_IC_INTR_STOP_DET)
+		I2c_ClrIntr(dev->base , DW_IC_CLR_STOP_DET);
+	if (stat & DW_IC_INTR_START_DET)
+		I2c_ClrIntr(dev->base , DW_IC_CLR_START_DET);
+	if (stat & DW_IC_INTR_GEN_CALL)
+		I2c_ClrIntr(dev->base , DW_IC_CLR_GEN_CALL);
+
+	return stat;
+}
+
+/*
+ * Interrupt service routine. This gets called whenever an I2C interrupt
+ * occurs.
+ */
+static irqreturn_t i2c_fh_isr(int this_irq, void *dev_id)
+{
+	struct fh_i2c_dev *dev = dev_id;
+	u32 stat;
+
+	stat = i2c_fh_read_clear_intrbits(dev);
+	PRINT_DBG("-----------i2c, %s: stat=0x%x\n", __func__, stat);
+
+	if (stat & DW_IC_INTR_TX_ABRT)
+	{
+		PRINT_DBG("DW_IC_INTR_TX_ABRT\n");
+		dev->cmd_err |= DW_IC_ERR_TX_ABRT;
+		dev->status = STATUS_IDLE;
+
+		/*
+		 * Anytime TX_ABRT is set, the contents of the tx/rx
+		 * buffers are flushed.  Make sure to skip them.
+		 */
+		I2c_SetIntrMask( dev->base,DW_IC_INTR_NONE);
+		goto tx_aborted;
+	}
+
+	if (stat & DW_IC_INTR_RX_FULL)
+	{
+		PRINT_DBG("i2c_fh_read\n");
+		i2c_fh_read(dev);
+	}
+
+	if (stat & DW_IC_INTR_TX_EMPTY)
+	{
+		PRINT_DBG("i2c_fh_xfer_msg\n");
+		i2c_fh_xfer_msg(dev);
+	}
+
+	/*
+	 * No need to modify or disable the interrupt mask here.
+	 * i2c_fh_xfer_msg() will take care of it according to
+	 * the current transmit status.
+	 */
+
+tx_aborted:
+	if ((stat & (DW_IC_INTR_TX_ABRT | DW_IC_INTR_STOP_DET)) || dev->msg_err)
+		complete(&dev->cmd_complete);
+
+	return IRQ_HANDLED;
+}
+
+static struct i2c_algorithm i2c_fh_algo =
+{
+	.master_xfer	= i2c_fh_xfer,
+	.functionality	= i2c_fh_func,
+};
+
+static int __devinit fh_i2c_probe(struct platform_device *pdev)
+{
+	struct fh_i2c_dev *dev;
+	struct i2c_adapter *adap;
+	struct resource *mem, *ioarea;
+	int irq, r;
+
+	pr_info("I2C driver:\n\tplatform registration... ");
+
+	/* NOTE: driver uses the static register mapping */
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem)
+	{
+		dev_err(&pdev->dev, "no mem resource?\n");
+		return -EINVAL;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+	{
+		dev_err(&pdev->dev, "no irq resource?\n");
+		return irq; /* -ENXIO */
+	}
+
+	ioarea = request_mem_region(mem->start, resource_size(mem),
+			pdev->name);
+	if (!ioarea)
+	{
+		dev_err(&pdev->dev, "I2C region already claimed\n");
+		return -EBUSY;
+	}
+
+	dev = kzalloc(sizeof(struct fh_i2c_dev), GFP_KERNEL);
+	if (!dev)
+	{
+		r = -ENOMEM;
+		goto err_release_region;
+	}
+
+	init_completion(&dev->cmd_complete);
+	mutex_init(&dev->lock);
+	dev->dev = get_device(&pdev->dev);
+	dev->irq = irq;
+	platform_set_drvdata(pdev, dev);
+
+	if(pdev->id)
+		dev->clk = clk_get(NULL, "i2c1_clk");
+	else
+		dev->clk = clk_get(NULL, "i2c0_clk");
+
+
+	if (IS_ERR(dev->clk))
+	{
+		r = -ENODEV;
+		goto err_free_mem;
+	}
+	clk_enable(dev->clk);
+
+	dev->base = ioremap(mem->start, resource_size(mem));
+	if (dev->base == NULL)
+	{
+		dev_err(&pdev->dev, "failure mapping io resources\n");
+		r = -ENOMEM;
+		goto err_unuse_clocks;
+	}
+	{
+		dev->tx_fifo_depth = I2c_GetTxFifoDepth(dev->base);
+		dev->rx_fifo_depth = I2c_GetRxFifoDepth(dev->base);
+	}
+	i2c_fh_init(dev);
+
+	pr_info("\ttx fifo depth: %d, rx fifo depth: %d\n", dev->tx_fifo_depth, dev->rx_fifo_depth);
+
+	I2c_SetIntrMask( dev->base,DW_IC_INTR_NONE); /* disable IRQ */
+	r = request_irq(dev->irq, i2c_fh_isr, IRQF_DISABLED, pdev->name, dev);
+	if (r)
+	{
+		dev_err(&pdev->dev, "failure requesting irq %i\n", dev->irq);
+		goto err_iounmap;
+	}
+
+	adap = &dev->adapter;
+	i2c_set_adapdata(adap, dev);
+	adap->owner = THIS_MODULE;
+	adap->class = I2C_CLASS_HWMON;
+	strlcpy(adap->name, "FH I2C adapter",
+			sizeof(adap->name));
+	adap->algo = &i2c_fh_algo;
+	adap->dev.parent = &pdev->dev;
+
+	adap->nr = pdev->id;
+	r = i2c_add_numbered_adapter(adap);
+	if (r) {
+		dev_err(&pdev->dev, "failure adding adapter\n");
+		goto err_free_irq;
+	}
+
+	pr_info("\t%s - (dev. name: %s - id: %d, IRQ #%d\n"
+		   "\t\tIO base addr: 0x%p)\n", "I2C", pdev->name,
+		   pdev->id, dev->irq, dev->base);
+
+	return 0;
+
+err_free_irq:
+	free_irq(dev->irq, dev);
+err_iounmap:
+	iounmap(dev->base);
+err_unuse_clocks:
+	clk_disable(dev->clk);
+	clk_put(dev->clk);
+	dev->clk = NULL;
+err_free_mem:
+	platform_set_drvdata(pdev, NULL);
+	put_device(&pdev->dev);
+	kfree(dev);
+err_release_region:
+	release_mem_region(mem->start, resource_size(mem));
+
+	return r;
+}
+
+static int __devexit fh_i2c_remove(struct platform_device *pdev)
+{
+	struct fh_i2c_dev *dev = platform_get_drvdata(pdev);
+	struct resource *mem;
+
+	platform_set_drvdata(pdev, NULL);
+	i2c_del_adapter(&dev->adapter);
+	put_device(&pdev->dev);
+
+	clk_disable(dev->clk);
+	clk_put(dev->clk);
+	dev->clk = NULL;
+	i2c_fh_wait_master_not_active(dev);
+	writel(0, dev->base + DW_IC_ENABLE);
+	free_irq(dev->irq, dev);
+	kfree(dev);
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(mem->start, resource_size(mem));
+	return 0;
+}
+
+static struct platform_driver fh_i2c_driver =
+{
+	.remove		= __devexit_p(fh_i2c_remove),
+	.driver		=
+	{
+		.name	= "fh_i2c",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init fh_i2c_init_driver(void)
+{
+	return platform_driver_probe(&fh_i2c_driver, fh_i2c_probe);
+}
+module_init(fh_i2c_init_driver);
+
+static void __exit fh_i2c_exit_driver(void)
+{
+	platform_driver_unregister(&fh_i2c_driver);
+}
+module_exit(fh_i2c_exit_driver);
+
+MODULE_AUTHOR("QIN");
+MODULE_ALIAS("platform:fh");
+MODULE_DESCRIPTION("FH I2C bus adapter");
+MODULE_LICENSE("GPL");
diff -uraN linux-3.0.8/drivers/i2c/busses/Kconfig linux-3.0.8-fh8632-V1.0_20180330/drivers/i2c/busses/Kconfig
--- linux-3.0.8/drivers/i2c/busses/Kconfig	2021-07-14 21:52:02.231131737 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/i2c/busses/Kconfig	2021-07-13 23:40:34.814363365 +0300
@@ -298,7 +298,18 @@
 	  documented way to issue repeated START conditions, as needed
 	  to support combined I2C messages.  Use the i2c-gpio driver
 	  unless your system can cope with those limitations.
+	  
+config I2C_FH_INTERRUPT
+	tristate "FH I2C Driver with Interrupt"
+	help
+	  This supports the use of the I2C interface on Fullhan
+	  processors.	
+	  
+	  Only master mode is supported.
 
+	  This driver can also be built as a module.  If so, the module
+	  will be called
+	
 config I2C_AU1550
 	tristate "Au1550/Au1200 SMBus interface"
 	depends on SOC_AU1550 || SOC_AU1200
diff -uraN linux-3.0.8/drivers/i2c/busses/Makefile linux-3.0.8-fh8632-V1.0_20180330/drivers/i2c/busses/Makefile
--- linux-3.0.8/drivers/i2c/busses/Makefile	2021-07-14 21:52:02.231131737 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/i2c/busses/Makefile	2021-07-13 23:40:34.802363291 +0300
@@ -82,5 +82,6 @@
 obj-$(CONFIG_I2C_STUB)		+= i2c-stub.o
 obj-$(CONFIG_SCx200_ACB)	+= scx200_acb.o
 obj-$(CONFIG_SCx200_I2C)	+= scx200_i2c.o
+obj-$(CONFIG_I2C_FH_INTERRUPT)	+= i2c_fh_interrupt.o
 
 ccflags-$(CONFIG_I2C_DEBUG_BUS) := -DDEBUG
diff -uraN linux-3.0.8/drivers/Kconfig linux-3.0.8-fh8632-V1.0_20180330/drivers/Kconfig
--- linux-3.0.8/drivers/Kconfig	2021-07-14 21:52:01.791130463 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/Kconfig	2021-07-13 23:40:36.918375964 +0300
@@ -126,4 +126,6 @@
 
 source "drivers/clocksource/Kconfig"
 
+source "drivers/pwm/Kconfig"
+
 endmenu
diff -uraN linux-3.0.8/drivers/Makefile linux-3.0.8-fh8632-V1.0_20180330/drivers/Makefile
--- linux-3.0.8/drivers/Makefile	2021-07-14 21:52:01.791130463 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/Makefile	2021-07-13 23:40:34.490361371 +0300
@@ -6,6 +6,7 @@
 #
 
 obj-y				+= gpio/
+obj-y				+= pwm/
 obj-$(CONFIG_PCI)		+= pci/
 obj-$(CONFIG_PARISC)		+= parisc/
 obj-$(CONFIG_RAPIDIO)		+= rapidio/
diff -uraN linux-3.0.8/drivers/misc/fh_clk_miscdev.c linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_clk_miscdev.c
--- linux-3.0.8/drivers/misc/fh_clk_miscdev.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_clk_miscdev.c	2021-07-13 23:40:34.786363192 +0300
@@ -0,0 +1,166 @@
+#include <linux/miscdevice.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/printk.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <asm/uaccess.h>
+#include <linux/clk.h>
+
+#include "fh_clk_miscdev.h"
+
+//#define FH_CLK_DEBUG
+
+#if defined(FH_CLK_DEBUG)
+#define PRINT_CLK_DBG(fmt, args...)   \
+    do                                \
+    {                                 \
+        printk("FH_CLK_DEBUG: "); \
+        printk(fmt, ##args);      \
+    } while (0)
+#else
+#define PRINT_CLK_DBG(fmt, args...) \
+    do                              \
+    {                               \
+    } while (0)
+#endif
+
+static int fh_clk_miscdev_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int fh_clk_miscdev_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+
+static long fh_clk_miscdev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int ret = -ENODEV;
+	struct clk *clk;
+	struct clk_usr *uclk;
+
+	if (unlikely(_IOC_TYPE(cmd) != CLK_IOCTL_MAGIC))
+	{
+		pr_err("%s: ERROR: incorrect magic num %d (error: %d)\n",
+			   __func__, _IOC_TYPE(cmd), -ENOTTY);
+		return -ENOTTY;
+	}
+
+	if (unlikely(_IOC_NR(cmd) > CLK_IOCTL_MAXNR))
+	{
+		pr_err("%s: ERROR: incorrect cmd num %d (error: %d)\n",
+			   __func__, _IOC_NR(cmd), -ENOTTY);
+		return -ENOTTY;
+	}
+
+	if (_IOC_DIR(cmd) & _IOC_READ)
+	{
+		ret = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
+	}
+	else if(_IOC_DIR(cmd) & _IOC_WRITE)
+	{
+		ret = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
+	}
+
+	if(ret)
+	{
+		pr_err("%s: ERROR: user space access is not permitted %d (error: %d)\n",
+			   __func__, _IOC_NR(cmd), -EACCES);
+		return -EACCES;
+	}
+
+	switch(cmd)
+	{
+	case ENABLE_CLK:
+		uclk = (struct clk_usr __user *)arg;
+		clk = clk_get(NULL, uclk->name);
+		if(!IS_ERR(clk))
+		{
+			clk_enable(clk);
+			ret = 0;
+		}
+		break;
+	case DISABLE_CLK:
+		uclk = (struct clk_usr __user *)arg;
+		clk = clk_get(NULL, uclk->name);
+		if(!IS_ERR(clk))
+		{
+			clk_disable(clk);
+			ret = 0;
+		}
+		break;
+	case SET_CLK_RATE:
+		uclk = (struct clk_usr __user *)arg;
+		clk = clk_get(NULL, uclk->name);
+		ret = PTR_ERR(clk);
+		if(!IS_ERR(clk))
+		{
+			ret = clk_set_rate(clk, uclk->frequency);
+		}
+		PRINT_CLK_DBG("%s, set clk: %s, rate: %lu\n", __func__, uclk->name, uclk->frequency);
+		break;
+	case GET_CLK_RATE:
+		uclk = (struct clk_usr __user *)arg;
+		clk = clk_get(NULL, uclk->name);
+		ret = PTR_ERR(clk);
+		if(!IS_ERR(clk))
+		{
+			uclk->frequency = clk_get_rate(clk);
+			ret = 0;
+		}
+		PRINT_CLK_DBG("%s, get clk: %s, rate: %lu\n", __func__, uclk->name, uclk->frequency);
+	}
+
+
+	return ret;
+}
+
+static const struct file_operations fh_clk_fops =
+{
+	.owner 			= THIS_MODULE,
+	.open 			= fh_clk_miscdev_open,
+	.release 		= fh_clk_miscdev_release,
+	.unlocked_ioctl 	= fh_clk_miscdev_ioctl,
+};
+
+static struct miscdevice fh_clk_miscdev =
+{
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = DEVICE_NAME,
+	.fops = &fh_clk_fops,
+};
+
+int __init fh_clk_miscdev_init(void)
+{
+	int err;
+
+	err = misc_register(&fh_clk_miscdev);
+
+	if(err < 0)
+	{
+		pr_err("%s: ERROR: %s registration failed, ret=%d",
+			   __func__, DEVICE_NAME, err);
+		return -ENXIO;
+	}
+
+	pr_info("CLK misc driver init successfully\n");
+	return 0;
+}
+
+
+static void __exit fh_clk_miscdev_exit(void)
+{
+    misc_deregister(&fh_clk_miscdev);
+}
+module_init(fh_clk_miscdev_init);
+module_exit(fh_clk_miscdev_exit);
+
+MODULE_AUTHOR("QIN");
+MODULE_DESCRIPTION("Misc Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform: FH");
diff -uraN linux-3.0.8/drivers/misc/fh_clk_miscdev.h linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_clk_miscdev.h
--- linux-3.0.8/drivers/misc/fh_clk_miscdev.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_clk_miscdev.h	2021-07-13 23:40:34.770363094 +0300
@@ -0,0 +1,10 @@
+
+#ifndef FH_CLK_MISCDEV_H_
+#define FH_CLK_MISCDEV_H_
+
+#include <mach/clock.h>
+
+#define DEVICE_NAME		"fh_clk_miscdev"
+
+
+#endif /* FH_CLK_MISCDEV_H_ */
diff -uraN linux-3.0.8/drivers/misc/fh_dma_miscdev.c linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_dma_miscdev.c
--- linux-3.0.8/drivers/misc/fh_dma_miscdev.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_dma_miscdev.c	2021-07-13 23:40:34.782363168 +0300
@@ -0,0 +1,358 @@
+#include <linux/miscdevice.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/printk.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <asm/uaccess.h>
+
+
+#include "fh_dma_miscdev.h"
+
+#define MEMCPY_UNIT     (4095 * 4 * 64)         //4095 xfer * 32-bit * 64 desc
+
+//#define FH_DMA_DEBUG
+
+#ifdef FH_DMA_DEBUG
+#define PRINT_DMA_DBG(fmt, args...)     \
+    do                              \
+    {                               \
+        printk("FH_DMA_DEBUG: ");   \
+        printk(fmt, ## args);       \
+    }                               \
+    while(0)
+#else
+#define PRINT_DMA_DBG(fmt, args...)  do { } while (0)
+#endif
+
+
+static void fh_dma_callback(void *data)
+{
+    PRINT_DMA_DBG("dma transfer done, end=%lu\n", jiffies);
+    complete(data);
+}
+
+static int kick_off_dma(struct dma_chan *channel, unsigned int src_offset, unsigned int dst_offset, unsigned int size)
+{
+    int ret;
+    struct completion cmp;
+    struct dma_async_tx_descriptor *dma_tx_desc = NULL;
+    struct dma_device *dma_dev = channel->device;
+    dma_cookie_t cookie;
+    unsigned long timeout;
+    unsigned long flag;
+
+    flag = DMA_CTRL_ACK | DMA_PREP_INTERRUPT | DMA_COMPL_SKIP_DEST_UNMAP | DMA_COMPL_SKIP_SRC_UNMAP;
+
+    PRINT_DMA_DBG("try to copy 0x%x bytes: 0x%x --> 0x%x\n", MEMCPY_UNIT, src_offset, dst_offset);
+
+    dma_tx_desc = dma_dev->device_prep_dma_memcpy(channel, dst_offset, src_offset, size, flag);
+
+    PRINT_DMA_DBG("device_prep_dma_memcpy end\n");
+
+    if(!dma_tx_desc)
+    {
+        pr_err("ERROR: %s, device_prep_dma_memcpy fail\n", __func__);
+        ret = -ENODEV;
+        return ret;
+    }
+
+    init_completion(&cmp);
+    dma_tx_desc->callback = fh_dma_callback;
+    dma_tx_desc->callback_param = &cmp;
+    PRINT_DMA_DBG("tx_submit start\n");
+    cookie = dma_tx_desc->tx_submit(dma_tx_desc);
+    PRINT_DMA_DBG("tx_submit end\n");
+    if (dma_submit_error(cookie))
+    {
+        pr_err("ERROR: %s, tx_submit fail\n", __func__);
+        ret = -ENODEV;
+        return ret;
+    }
+    PRINT_DMA_DBG("dma_async_issue_pending start\n");
+    dma_async_issue_pending(channel);
+    PRINT_DMA_DBG("dma_async_issue_pending end, %d\n", DMA_MEMCPY_TIMEOUT);
+
+    timeout = wait_for_completion_timeout(&cmp, msecs_to_jiffies(DMA_MEMCPY_TIMEOUT));
+
+    PRINT_DMA_DBG("wait_for_completion_timeout end, timeout: %lu\n", timeout);
+
+    if(!timeout)
+    {
+        pr_err("ERROR: %s, dma transfer fail, timeout\n", __func__);
+        ret = -ENODEV;
+        return ret;
+    }
+
+    ret = dma_async_is_tx_complete(channel, cookie, NULL, NULL);
+
+    if(ret)
+    {
+        pr_err("ERROR: %s, dma transfer fail, incorrect status: %d\n", __func__, ret);
+        ret = -ENODEV;
+        return ret;
+    }
+
+    return 0;
+}
+
+
+static int fh_dma_start_transfer(struct dma_chan *channel, struct dma_memcpy* memcpy)
+{
+    int ret;
+    unsigned int i;
+
+    for(i=0; i<memcpy->size / MEMCPY_UNIT; i++)
+    {
+        ret = kick_off_dma(channel, memcpy->src_addr_phy + MEMCPY_UNIT*i, memcpy->dst_addr_phy + MEMCPY_UNIT*i, MEMCPY_UNIT);
+        if(ret)
+        {
+            return ret;
+        }
+    }
+
+    ret = kick_off_dma(channel, memcpy->src_addr_phy + MEMCPY_UNIT*i, memcpy->dst_addr_phy + MEMCPY_UNIT*i, memcpy->size % MEMCPY_UNIT);
+    return ret;
+}
+
+
+static bool chan_filter(struct dma_chan *chan, void *param)
+{
+    struct dma_memcpy* memcpy = param;
+    PRINT_DMA_DBG("chan_filter, channel id: %d\n", memcpy->chan_id);
+    if(memcpy->chan_id < 0)
+    {
+        return false;
+    }
+
+    if(memcpy->chan_id == chan->chan_id)
+    {
+        return true;
+    }
+    else
+    {
+        return false;
+    }
+
+}
+
+static int fh_dma_memcpy(struct dma_memcpy* memcpy)
+{
+    //fixme: ioctl should be atomic, otherwise channel will be changed.
+    struct dma_chan *dma_channel;
+    dma_cap_mask_t mask;
+    int ret;
+
+    PRINT_DMA_DBG("fh_dma_memcpy start\n");
+    PRINT_DMA_DBG("ioctl, memcpy->size: 0x%x\n", memcpy->size);
+
+
+    PRINT_DMA_DBG("fh_dma_request_channel start\n");
+    dma_cap_zero(mask);
+    PRINT_DMA_DBG("dma_cap_zero end\n");
+    dma_cap_set(DMA_MEMCPY, mask);
+    PRINT_DMA_DBG("dma_cap_set end\n");
+
+    dma_channel = dma_request_channel(mask, chan_filter, memcpy);
+
+    PRINT_DMA_DBG("dma_request_channel finished, channel_addr: 0x%x\n", (u32)dma_channel);
+
+    if(!dma_channel)
+    {
+        pr_err("ERROR: %s, No Channel Available, channel: %d\n", __func__, dma_channel->chan_id);
+        return -EBUSY;
+    }
+    memcpy->chan_id = dma_channel->chan_id;
+    PRINT_DMA_DBG("dma channel name: %s\n", dma_chan_name(dma_channel));
+
+    ret = fh_dma_start_transfer(dma_channel, memcpy);
+
+    if(ret)
+    {
+        pr_err("ERROR: %s, DMA Xfer Failed\n", __func__);
+    }
+
+    dma_channel->device->device_free_chan_resources(dma_channel);
+    dma_release_channel(dma_channel);
+
+    return ret;
+}
+
+static long fh_dma_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    int ret = 0;
+    struct dma_memcpy* memcpy;
+
+
+    if (unlikely(_IOC_TYPE(cmd) != DMA_IOCTL_MAGIC))
+    {
+        pr_err("%s: ERROR: incorrect magic num %d (error: %d)\n",
+               __func__, _IOC_TYPE(cmd), -ENOTTY);
+        return -ENOTTY;
+    }
+
+    if (unlikely(_IOC_NR(cmd) > DMA_IOCTL_MAXNR))
+    {
+        pr_err("%s: ERROR: incorrect cmd num %d (error: %d)\n",
+               __func__, _IOC_NR(cmd), -ENOTTY);
+        return -ENOTTY;
+    }
+
+    if (_IOC_DIR(cmd) & _IOC_READ)
+    {
+        ret = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
+    }
+    else if(_IOC_DIR(cmd) & _IOC_WRITE)
+    {
+        ret = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
+    }
+
+    if(ret)
+    {
+        pr_err("%s: ERROR: user space access is not permitted %d (error: %d)\n",
+               __func__, _IOC_NR(cmd), -EACCES);
+        return -EACCES;
+    }
+
+    switch(cmd)
+    {
+
+    case DMA_MEMCOPY:
+        memcpy = (struct dma_memcpy __user *)arg;
+        ret = fh_dma_memcpy(memcpy);
+        break;
+    }
+
+    return ret;
+}
+
+static int fh_dma_open(struct inode *inode, struct file *file)
+{
+    PRINT_DMA_DBG("fh_dma_open\n");
+    return 0;
+}
+
+static int fh_dma_release(struct inode *inode, struct file *filp)
+{
+    PRINT_DMA_DBG("fh_dma_release\n");
+    return 0;
+}
+
+
+static void *v_seq_start(struct seq_file *s, loff_t *pos)
+{
+    static unsigned long counter = 0;
+    if (*pos == 0)
+        return &counter;
+    else
+    {
+        *pos = 0;
+        return NULL;
+    }
+}
+
+static void *v_seq_next(struct seq_file *s, void *v, loff_t *pos)
+{
+    (*pos)++;
+    return NULL;
+}
+
+static void v_seq_stop(struct seq_file *s, void *v)
+{
+
+}
+
+static int v_seq_show(struct seq_file *sfile, void *v)
+{
+
+    seq_printf(sfile, "\nISP Status\n");
+    seq_printf(sfile, "\nCTRL: \n");
+
+#if 0
+    int i;
+    u32 data;
+    seq_printf(sfile, "ipf reg:\n");
+    for(i=0; i<10; i++)
+    {
+        data = GET_IPF_REG_V(i*4);
+        seq_printf(sfile, "0x%05x, 0x%08x\n", i*4, data);
+    }
+#endif
+
+    return 0;
+}
+
+static const struct seq_operations fh_dma_seq_ops =
+{
+    .start = v_seq_start,
+    .next = v_seq_next,
+    .stop = v_seq_stop,
+    .show = v_seq_show
+};
+
+static int isp_proc_open(struct inode *inode, struct file *file)
+{
+    return seq_open(file, &fh_dma_seq_ops);
+}
+
+static struct file_operations fh_dma_proc_ops =
+{
+    .owner = THIS_MODULE,
+    .open = isp_proc_open,
+    .read = seq_read,
+};
+
+static const struct file_operations fh_dma_fops =
+{
+    .owner                  = THIS_MODULE,
+    .open                   = fh_dma_open,
+    .release                = fh_dma_release,
+    .unlocked_ioctl         = fh_dma_ioctl,
+};
+
+static struct miscdevice fh_dma_device =
+{
+    .minor = MISC_DYNAMIC_MINOR,
+    .name = DEVICE_NAME,
+    .fops = &fh_dma_fops,
+};
+
+static int __init fh_dma_init(void)
+{
+    int ret;
+    struct proc_dir_entry *proc_file;
+    ret = misc_register(&fh_dma_device);
+
+    if(ret < 0)
+    {
+        pr_err("%s: ERROR: %s registration failed",
+            __func__, DEVICE_NAME);
+        return -ENXIO;
+    }
+
+    proc_file = create_proc_entry(PROC_FILE, 0644, NULL);
+
+    if (proc_file)
+        proc_file->proc_fops = &fh_dma_proc_ops;
+    else
+        pr_err("%s: ERROR: %s proc file create failed",
+               __func__, DEVICE_NAME);
+
+
+    return ret;
+}
+
+static void __exit fh_dma_exit(void)
+{
+    remove_proc_entry(PROC_FILE, NULL);
+    misc_deregister(&fh_dma_device);
+}
+module_init(fh_dma_init);
+module_exit(fh_dma_exit);
+
+MODULE_AUTHOR("QIN");
+MODULE_DESCRIPTION("Misc Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform: FH");
diff -uraN linux-3.0.8/drivers/misc/fh_dma_miscdev.h linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_dma_miscdev.h
--- linux-3.0.8/drivers/misc/fh_dma_miscdev.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_dma_miscdev.h	2021-07-13 23:40:34.766363069 +0300
@@ -0,0 +1,32 @@
+
+#ifndef FH_DMA_MISCDEV_H_
+#define FH_DMA_MISCDEV_H_
+
+#include <linux/dmaengine.h>
+
+
+#define DEVICE_NAME                 "fh_dma_misc"
+#define PROC_FILE                   "driver/dma_misc"
+
+#define DMA_IOCTL_MAGIC             'd'
+#define RESERVERD                   _IO(DMA_IOCTL_MAGIC, 0)
+#define REQUEST_CHANNEL             _IOWR(DMA_IOCTL_MAGIC, 1, __u32)
+#define DMA_MEMCOPY                 _IOWR(DMA_IOCTL_MAGIC, 2, __u32)
+
+#define DMA_IOCTL_MAXNR             14
+
+#define DMA_MEMCPY_TIMEOUT          5000 //msec
+
+struct dma_memcpy
+{
+    int chan_id;
+    void *src_addr_vir;
+    void *dst_addr_vir;
+    unsigned int size;
+    unsigned int src_addr_phy;
+    unsigned int dst_addr_phy;
+};
+
+
+
+#endif /* FH_DMA_MISCDEV_H_ */
diff -uraN linux-3.0.8/drivers/misc/fh_dw_i2s.c linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_dw_i2s.c
--- linux-3.0.8/drivers/misc/fh_dw_i2s.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_dw_i2s.c	2021-07-13 23:40:34.774363119 +0300
@@ -0,0 +1,1624 @@
+/**@file
+ * @Copyright (c) 2016 Shanghai Fullhan Microelectronics Co., Ltd.
+ * @brief
+ *
+ * @author      fullhan
+ * @date        2016-7-15
+ * @version     V1.0
+ * @version     V1.1  modify code style
+ * @note: misc audio driver for fh8830 embedded audio codec.
+ * @note History:
+ * @note     <author>   <time>    <version >   <desc>
+ * @note
+ * @warning: the codec is fixed to 24 bit, so remember to move the 24 bit data to 16 bit in
+ *   application layer, the next version CPU will sovle this bug.
+ */
+
+
+#include <linux/irqreturn.h>
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/file.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/uaccess.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/poll.h>
+#include <linux/ioctl.h>
+#include <linux/i2c.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <mach/fh_dmac.h>
+#include <mach/fh_predefined.h>
+
+#include "ac.h"
+struct i2c_adapter *codec_i2c_adapter;
+#define NR_DESCS_PER_CHANNEL 64
+#define DW_I2S_FH8833 0xf0900000
+#define FIX_SAMPLE_BIT       32
+
+#define ACW_HW_NUM_RX  0
+#define ACW_HW_NUM_TX  1
+#define ACW_DMA_CAP_CHANNEL 3
+#define ACW_DMA_PAY_CHANNEL 2
+
+#define ACW_CTRL 						0x0
+#define ACW_TXFIFO_CTRL 				0x4
+#define ACW_RXFIFO_CTRL 				0x8
+#define ACW_STATUS             			0x0c
+#define ACW_DAT_CTL				  		0x10
+#define ACW_DBG_CTL					  	0x14
+#define ACW_STATUS1					  	0x18
+#define ACW_STATUS2						0x1c
+
+#define ACW_DACL_FIFO 					0xf0a00100
+#define ACW_DACR_FIFO 					0xf0a00100
+#define ACW_ADC_FIFO					0xf0a00200
+
+#define AUDIO_DMA_PREALLOC_SIZE 128*1024
+
+#define ACW_INTR_RX_UNDERFLOW   0x10000
+#define ACW_INTR_RX_OVERFLOW    0x20000
+#define ACW_INTR_TX_UNDERFLOW   0x40000
+#define ACW_INTR_TX_OVERFLOW    0x80000
+
+ //#define FH_AUDIO_DEBUG
+#ifdef FH_AUDIO_DEBUG
+#define PRINT_AUDIO_DBG(fmt, args...)     \
+    do                              \
+    {                               \
+        printk("FH_AUDIO_DEBUG: ");   \
+        printk(fmt, ## args);       \
+    }                               \
+    while(0)
+#else
+#define PRINT_AUDIO_DBG(fmt, args...)  do { } while (0)
+#endif
+
+enum audio_type
+{
+    capture = 0,
+    playback,
+};
+
+int i2c_write_codec(u8 addr, u8 data) {
+		int rval;
+		struct i2c_msg msgs[1];
+		u8 send[2];
+		msgs[0].len = 2;
+		msgs[0].addr = 0x1b;
+		msgs[0].flags = 0;
+		msgs[0].buf = send;
+		send[0] = addr;
+		send[1] = data;
+		rval = i2c_transfer(codec_i2c_adapter, msgs, 1);
+		return rval;
+}
+
+enum audio_state
+{
+    STATE_NORMAL = 0,
+    STATE_XRUN,
+    STATE_STOP,
+    STATE_RUN,
+    STATE_PAUSE
+};
+
+struct infor_record_t
+{
+	int record_pid;
+	int play_pid;
+}infor_record;
+
+struct audio_config {
+	int rate;
+	int volume;
+	enum io_select io_type;
+    int frame_bit;
+    int channels;
+    int buffer_size;
+    int period_size;
+    int buffer_bytes;
+    int period_bytes;
+    int start_threshold;
+    int stop_threshold;
+};
+
+struct audio_ptr_t
+{
+	struct audio_config cfg;
+    enum audio_state state;
+    long size;
+    int hw_ptr;
+    int appl_ptr;
+    spinlock_t lock;
+    struct device dev;
+    u8 *area; /*virtual pointer*/
+    dma_addr_t addr; /*physical address*/
+    u8 * mmap_addr;
+};
+
+struct fh_audio_cfg
+{
+    struct audio_ptr_t capture;
+    struct audio_ptr_t playback;
+    wait_queue_head_t readqueue;
+    wait_queue_head_t writequeue;
+	struct semaphore sem_capture;
+	struct semaphore sem_playback;
+};
+
+struct fh_dma_chan
+{
+    struct dma_chan     *chan;
+    void __iomem        *ch_regs;
+    u8          mask;
+    u8          priority;
+    bool            paused;
+    bool                initialized;
+    spinlock_t      lock;
+    /* these other elements are all protected by lock */
+    unsigned long       flags;
+    dma_cookie_t        completed;
+    struct list_head    active_list;
+    struct list_head    queue;
+    struct list_head    free_list;
+    struct fh_cyclic_desc   *cdesc;
+    unsigned int        descs_allocated;
+};
+
+struct fh_acw_dma_transfer
+{
+    struct dma_chan *chan;
+    struct fh_dma_slave cfg;
+    struct scatterlist sgl;
+    struct dma_async_tx_descriptor *desc;
+};
+
+struct channel_assign
+{
+	int capture_channel;
+	int playback_channel;
+};
+
+struct audio_dev
+{
+	struct channel_assign channel_assign;
+    struct fh_audio_cfg audio_config;
+    struct miscdevice fh_audio_miscdev;
+};
+
+static const struct file_operations acw_fops;
+
+static struct audio_dev fh_audio_dev =
+{
+    .channel_assign = {
+        .capture_channel = ACW_DMA_CAP_CHANNEL,
+        .playback_channel = ACW_DMA_PAY_CHANNEL,
+    },
+    .fh_audio_miscdev = {
+        .fops       = &acw_fops,
+        .name       = "fh_audio",
+        .minor      = MISC_DYNAMIC_MINOR,
+    }
+
+};
+
+static struct
+{
+    spinlock_t      lock;
+    void __iomem        *regs;
+    struct clk      *clk;
+    unsigned long       in_use;
+    unsigned long       next_heartbeat;
+    struct timer_list   timer;
+    int         expect_close;
+    int         irq;
+} fh_audio_module;
+//#define STERO
+static struct fh_dma_chan *dma_rx_transfer = NULL;
+static struct fh_dma_chan *dma_tx_transfer = NULL;
+#ifdef 	STERO
+static struct fh_dma_chan *dma_tx_right_transfer = NULL;
+#endif
+static struct work_struct playback_wq;
+
+static struct audio_param_store
+{
+    int input_volume;
+    enum io_select input_io_type;
+} audio_param_store;
+
+#ifdef 	STERO
+static void fh_acw_tx_right_dma_done(void *arg);
+#define TX_RIGHT_CHANNEL_DMA_CHANNEL 0
+#endif
+static void fh_acw_tx_dma_done(void *arg);
+static void fh_acw_rx_dma_done(void *arg);
+static bool  fh_acw_dma_chan_filter(struct dma_chan *chan, void *filter_param);
+static void create_proc(void);
+static void remove_proc(void);
+
+void fh_acw_stop_playback(struct fh_audio_cfg *audio_config)
+{
+	unsigned int status;
+    if(audio_config->playback.state == STATE_STOP)
+    {
+        return;
+    }
+    audio_config->playback.state = STATE_STOP;
+    status = readl( fh_audio_module.regs + 0x8);
+    status &=(~(1<<0));
+    writel(status, fh_audio_module.regs + 0x8);//tx fifo disable
+    fh_dma_cyclic_stop(dma_tx_transfer->chan);
+    fh_dma_cyclic_free(dma_tx_transfer->chan);
+#ifdef 	STERO
+    fh_dma_cyclic_stop(dma_tx_right_transfer->chan);
+    fh_dma_cyclic_free(dma_tx_right_transfer->chan);
+#endif
+    up(&audio_config->sem_playback);
+}
+
+void fh_acw_stop_capture(struct fh_audio_cfg *audio_config)
+{
+
+    u32 rx_status,status;
+
+    if(audio_config->capture.state == STATE_STOP)
+    {
+        return;
+    }
+//    rx_status = readl( fh_audio_module.regs + ACW_RXFIFO_CTRL);//clear rx fifo
+//    rx_status =  rx_status|(1<<4);
+//    writel(rx_status,fh_audio_module.regs + ACW_RXFIFO_CTRL);
+
+    audio_config->capture.state = STATE_STOP;
+
+    status = readl( fh_audio_module.regs + 0x4);
+    status &=(~(1<<0));
+    writel(status, fh_audio_module.regs + 0x4);//tx fifo disable
+
+    fh_dma_cyclic_stop(dma_rx_transfer->chan);
+    fh_dma_cyclic_free(dma_rx_transfer->chan);
+    up(&audio_config->sem_capture);
+}
+
+void switch_io_type(enum audio_type type, enum io_select io_type)
+{
+#if 0
+#ifndef CONFIG_MACH_FH8830_FPGA
+	int reg;
+    if (capture == type)
+    {
+        reg = readl(fh_audio_module.regs + ACW_ADC_PATH_CTRL);
+        if (mic_in == io_type)
+        {
+            printk(KERN_INFO"audio input changed to mic_in\n");
+            writel( reg & (~(1<<1)),fh_audio_module.regs + ACW_ADC_PATH_CTRL);
+        }
+        else if (line_in == io_type)
+        {
+            printk(KERN_INFO"audio input changed to line_in\n");
+            writel(reg | (1<<1), fh_audio_module.regs + ACW_ADC_PATH_CTRL);
+        }
+    }
+    else
+    {
+        reg = readl(fh_audio_module.regs + ACW_DAC_PATH_CTRL);
+        if (speaker_out == io_type)
+        {
+            printk(KERN_INFO"audio output changed to speaker_out\n");
+            reg = reg & (~(3<<21));
+            writel(reg, fh_audio_module.regs + ACW_DAC_PATH_CTRL);
+            reg = reg | (1<<21);
+            writel(reg,fh_audio_module.regs + ACW_DAC_PATH_CTRL);
+            reg = reg | (1<<18);
+            writel(reg, fh_audio_module.regs + ACW_DAC_PATH_CTRL);/*unmute speaker*/
+            reg = reg | (3<<30);
+            writel(reg,fh_audio_module.regs + ACW_DAC_PATH_CTRL);/*mute line out*/
+        }
+        else if (line_out == io_type)
+        {
+            printk(KERN_INFO"audio output changed to line_out\n");
+            reg = reg & (~(3<<21));
+            writel(reg, fh_audio_module.regs + ACW_DAC_PATH_CTRL);/*mute speaker*/
+            reg = reg & (~(3<<30));
+            writel(reg, fh_audio_module.regs + ACW_DAC_PATH_CTRL);/*unmute line out*/
+        }
+    }
+#endif
+#endif
+}
+
+int get_factor_from_table(int rate)
+{
+    int factor;
+    switch(rate)
+    {
+        case 8000:
+            factor = 4;
+            break;
+        case 16000:
+            factor = 1;
+            break;
+        case 32000:
+            factor = 0;
+            break;
+        case 44100:
+            factor = 13;
+            break;
+        case 48000:
+            factor = 6;
+            break;
+        default:
+            factor = -EFAULT;
+            break;
+    }
+    return factor;
+}
+
+void switch_rate(enum audio_type type, int rate)
+{
+#if 0 
+#ifndef CONFIG_MACH_FH8830_FPGA
+	int reg, factor;
+    factor = get_factor_from_table(rate);
+    if (factor < 0)
+    {
+        printk(KERN_ERR "unsupported sample rate\n");
+        return;
+    }
+    reg = readl(fh_audio_module.regs + ACW_DIG_IF_CTRL);
+    if (capture == type)
+    {
+        printk(KERN_INFO"capture rate set to %d\n", rate);
+        reg = reg & (~(0xf<<0));
+        writel(reg, fh_audio_module.regs + ACW_DIG_IF_CTRL);/*adc and dac sample rate*/
+        reg = reg | (factor<<0);
+        writel(reg,fh_audio_module.regs + ACW_DIG_IF_CTRL);
+    }
+    else
+    {
+        printk(KERN_INFO"playback rate set to %d\n", rate);
+        reg = reg & (~(0xf<<8));
+        writel(reg, fh_audio_module.regs + ACW_DIG_IF_CTRL);/*adc and dac sample rate*/
+        reg = reg | (factor<<8);
+        writel(reg, fh_audio_module.regs + ACW_DIG_IF_CTRL);
+    }
+#endif
+#endif
+}
+
+int get_param_from_volume(int volume)
+{
+    int param, max_param, min_param, max_volume;
+	max_volume = 100;
+	if (volume < 0 || volume > max_volume)
+    {
+        printk(KERN_ERR "unsupported input volume\n");
+        return -EINVAL;
+    }
+	max_param = 63;
+    min_param = 0;
+	param = max_param - (max_volume - volume);
+	if (param <= min_param)
+    {
+        param = min_param;
+    }
+    return param;
+}
+
+void switch_input_volume(int volume)
+{
+#if 0
+#ifndef CONFIG_MACH_FH8830_FPGA
+    int reg, param;
+    param = get_param_from_volume(volume);
+    if (param < 0)
+    {
+        return;
+    }
+    printk(KERN_INFO"capture volume set to %d\n", volume);
+	reg = readl(fh_audio_module.regs + ACW_ADC_PATH_CTRL);
+    reg = reg & (~(0x3f<<8));
+    writel(reg, fh_audio_module.regs + ACW_ADC_PATH_CTRL);
+    reg = reg | (param<<8);
+    writel(reg,fh_audio_module.regs + ACW_ADC_PATH_CTRL);
+#endif
+#endif
+}
+
+void init_audio(enum audio_type type,struct fh_audio_cfg  *audio_config)
+{
+	writel(0x1,fh_audio_module.regs +0x0);
+#ifndef CONFIG_MACH_FH8830_FPGA
+    int reg;
+//    reg = readl(fh_audio_module.regs + ACW_CTRL);
+//    if ((reg & 0x80000000) == 0)
+//    {
+//        writel(0x80000000, fh_audio_module.regs + ACW_CTRL);/*enable audio*/
+//    }
+//    reg = readl(fh_audio_module.regs + ACW_MISC_CTRL);
+//    if (0x40400 != reg)
+//    {
+//        writel(0x40400,fh_audio_module.regs + ACW_MISC_CTRL);/*misc ctl*/
+//    }
+//    if (capture == type)
+//    {
+//        writel(0x61141b06,fh_audio_module.regs + ACW_ADC_PATH_CTRL);/*adc cfg*/
+//        writel(0x167f2307, fh_audio_module.regs + ACW_ADC_ALC_CTRL);/*adc alc*/
+//        writel(0, fh_audio_module.regs + ACW_RXFIFO_CTRL);/*rx fifo disable*/
+//        switch_input_volume(audio_config->capture.cfg.volume);
+//        switch_rate(capture, audio_config->capture.cfg.rate);
+//        switch_io_type(capture, audio_config->capture.cfg.io_type);
+//    }
+//    else
+//    {
+//        writel(0x3b403f09, fh_audio_module.regs + ACW_DAC_PATH_CTRL);/*dac cfg*/
+//        writel(0, fh_audio_module.regs + ACW_TXFIFO_CTRL);/*tx fifo disable*/
+//        switch_rate(playback, audio_config->playback.cfg.rate);
+//        switch_io_type(playback, audio_config->playback.cfg.io_type);
+//    }
+#endif
+
+}
+
+static inline long bytes_to_frames(int frame_bit, int bytes)
+{
+    return bytes * 8 /frame_bit;
+}
+
+static inline long  frames_to_bytes(int frame_bit, int frames)
+{
+    return frames * frame_bit / 8;
+}
+
+int avail_data_len(enum audio_type type,struct fh_audio_cfg *stream)
+{
+    int delta;
+    if (capture == type)
+    {
+        spin_lock(&stream->capture.lock);
+        delta = stream->capture.hw_ptr - stream->capture.appl_ptr;
+        spin_unlock(&stream->capture.lock);
+        if (delta < 0)
+        {
+            delta += stream->capture.size;
+        }
+        return delta;
+    }
+    else
+    {
+        spin_lock(&stream->playback.lock);
+        delta = stream->playback.appl_ptr - stream->playback.hw_ptr;
+        spin_unlock(&stream->playback.lock);
+        if (delta < 0)
+        {
+            delta += stream->playback.size;
+        }
+        return stream->playback.size - delta;
+    }
+}
+
+static int fh_audio_close(struct inode *ip, struct file *fp)
+{
+	struct miscdevice *miscdev = fp->private_data;
+	struct audio_dev	*dev = container_of(miscdev, struct audio_dev, fh_audio_miscdev);
+	struct fh_audio_cfg *audio_config = &dev->audio_config;
+	int pid;
+
+	pid= current->tgid;
+//#ifndef CONFIG_MACH_FH8830_FPGA
+//	//disable interrupts
+//	u32 reg;
+//    reg = readl(fh_audio_module.regs + ACW_CTRL);
+//    reg &= ~(0x3ff);
+//    writel(reg, fh_audio_module.regs + ACW_CTRL);
+//#endif
+	if( infor_record.play_pid == pid)
+	{
+		fh_acw_stop_playback(audio_config);
+
+	}
+	if (infor_record.record_pid==pid)
+	{
+		fh_acw_stop_capture(audio_config);
+	}
+	return 0;
+}
+
+int register_tx_dma(struct fh_audio_cfg  *audio_config)
+{
+	int ret;
+	struct fh_dma_slave *tx_config;
+
+	tx_config =  kzalloc(sizeof(struct fh_dma_slave), GFP_KERNEL);
+	if (!tx_config)
+	{
+		return -ENOMEM;
+	}
+#ifdef STERO
+	//right channel
+	struct dma_slave_config *tx_config_right;
+	tx_config_right =  kzalloc(sizeof(struct dma_slave_config), GFP_KERNEL);
+	if (!tx_config_right)
+	{
+		kfree(tx_config);
+		return -ENOMEM;
+	}
+	tx_config_right->slave_id = ACW_HW_NUM_TX;
+	tx_config_right->src_maxburst = FH_DMA_MSIZE_8;
+	tx_config_right->dst_maxburst = FH_DMA_MSIZE_8;
+	tx_config_right->dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	tx_config_right->device_fc = TRUE;
+	tx_config_right->dst_addr = ACW_DACR_FIFO;
+
+	dma_tx_right_transfer->cdesc =fh_dma_cyclic_prep(dma_tx_right_transfer->chan,audio_config->playback.addr,
+				audio_config->playback.cfg.buffer_bytes,audio_config->playback.cfg.period_bytes, DMA_TO_DEVICE);
+
+	if(dma_tx_transfer->cdesc <= 0)
+	{
+	    printk(KERN_ERR"cyclic desc err\n");
+	    ret = -ENOMEM;
+	    kfree(tx_config_right);
+	    goto fail;
+	}
+	dma_tx_transfer->cdesc->period_callback = fh_acw_tx_right_dma_done;
+	dma_tx_transfer->cdesc->period_callback_param = audio_config;
+	fh_dma_cyclic_start(dma_tx_right_transfer->chan);
+
+	kfree(tx_config_right);
+
+	/*must set NULL to tell DMA driver that we free the DMA slave*/
+	dma_tx_right_transfer->chan->private = NULL;
+#endif
+
+
+	tx_config->cfg_hi = FHC_CFGH_DST_PER(11);
+	tx_config->dst_msize = FH_DMA_MSIZE_8;
+	tx_config->src_msize = FH_DMA_MSIZE_8;
+	tx_config->reg_width = FH_DMA_SLAVE_WIDTH_32BIT;
+	tx_config->fc = FH_DMA_FC_D_M2P;
+	tx_config->tx_reg = 0xf09001c8;
+
+	dma_tx_transfer->chan->private =  tx_config;
+	if ((audio_config->playback.cfg.buffer_bytes < audio_config->playback.cfg.period_bytes) ||
+	(audio_config->playback.cfg.buffer_bytes <= 0) || (audio_config->playback.cfg.period_bytes <= 0) ||
+	(audio_config->playback.cfg.buffer_bytes/audio_config->playback.cfg.period_bytes > NR_DESCS_PER_CHANNEL))
+	{
+		printk(KERN_ERR "buffer_size and period_size are invalid\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	dma_tx_transfer->cdesc =fh_dma_cyclic_prep(dma_tx_transfer->chan,audio_config->playback.addr,
+			       audio_config->playback.cfg.buffer_bytes,audio_config->playback.cfg.period_bytes, DMA_MEM_TO_DEV);
+	if(dma_tx_transfer->cdesc <= 0)
+	{
+		printk(KERN_ERR "cyclic desc err\n");
+		ret = -ENOMEM;
+		goto fail;
+	}
+	dma_tx_transfer->cdesc->period_callback = fh_acw_tx_dma_done;
+	dma_tx_transfer->cdesc->period_callback_param = audio_config;
+	fh_dma_cyclic_start(dma_tx_transfer->chan);
+
+	kfree(tx_config);
+
+	/*must set NULL to tell DMA driver that we free the DMA slave*/
+	dma_tx_transfer->chan->private = NULL;
+	return 0;
+fail:
+	kfree(tx_config);
+	return ret;
+}
+
+int register_rx_dma( struct fh_audio_cfg  *audio_config)
+{
+    int ret,status;
+
+    struct fh_dma_slave *rx_config;
+    rx_config =  kzalloc(sizeof(struct fh_dma_slave), GFP_KERNEL);
+    if (!rx_config)
+    {
+        return -ENOMEM;
+    }
+
+    rx_config->cfg_hi = FHC_CFGH_SRC_PER(10);
+    rx_config->dst_msize = FH_DMA_MSIZE_8;
+    rx_config->src_msize = FH_DMA_MSIZE_8;
+    rx_config->reg_width = FH_DMA_SLAVE_WIDTH_32BIT;
+    rx_config->fc = FH_DMA_FC_D_P2M;
+    rx_config->rx_reg = 0xf09001c0;
+    dma_rx_transfer->chan->private =  rx_config;
+    if ((audio_config->capture.cfg.buffer_bytes < audio_config->capture.cfg.period_bytes) ||
+        (audio_config->capture.cfg.buffer_bytes <= 0) ||(audio_config->capture.cfg.period_bytes <= 0) ||
+        (audio_config->capture.cfg.buffer_bytes/audio_config->capture.cfg.period_bytes > NR_DESCS_PER_CHANNEL))
+    {
+        printk(KERN_ERR "buffer_size and period_size are invalid\n");
+        ret = -EINVAL;
+        goto fail;
+    }
+    dma_rx_transfer->cdesc = fh_dma_cyclic_prep(dma_rx_transfer->chan,audio_config->capture.addr,
+                               audio_config->capture.cfg.buffer_bytes, audio_config->capture.cfg.period_bytes,DMA_DEV_TO_MEM);
+    if(dma_rx_transfer->cdesc <= 0)
+    {
+        printk(KERN_ERR" cyclic desc err\n");
+        ret = -ENOMEM;
+        goto fail;
+    }
+    dma_rx_transfer->cdesc->period_callback = fh_acw_rx_dma_done;
+    dma_rx_transfer->cdesc->period_callback_param = audio_config;
+    fh_dma_cyclic_start(dma_rx_transfer->chan);
+
+    writel(0x1,fh_audio_module.regs + 0x4);/*enable rx fifo*/
+    writel(0x1,fh_audio_module.regs + 0x1c4);/*reset dma*/
+    writel(0x1,fh_audio_module.regs + 0x14);/*reset dma*/
+    writel(0x1,fh_audio_module.regs + 0x28);/*reset dma*/
+
+    if (rx_config)
+    {
+        kfree(rx_config);
+    }
+    /*must set NULL to tell DMA driver that we free the DMA slave*/
+    dma_rx_transfer->chan->private = NULL;
+    return 0;
+fail:
+    kfree(rx_config);
+    return ret;
+}
+
+
+void playback_start_wq_handler(struct work_struct *work)
+{
+    int avail;
+    unsigned int status;
+    while(1)
+    {
+        if (STATE_STOP == fh_audio_dev.audio_config.playback.state)
+        {
+            return;
+        }
+        avail = avail_data_len(playback, &fh_audio_dev.audio_config);
+        if (avail > fh_audio_dev.audio_config.playback.cfg.period_bytes)
+        {
+            msleep(0);
+        }
+        else
+        {
+        	   writel(0x1,fh_audio_module.regs + 0x8);/*enable rx fifo*/
+        	    writel(0x1,fh_audio_module.regs + 0x1cc);/*reset dma*/
+        	    writel(0x1,fh_audio_module.regs + 0x18);/*reset dma*/
+        	    writel(0x1,fh_audio_module.regs + 0x2c);/*reset dma*/
+
+            break;
+        }
+    }
+}
+
+int fh_acw_start_playback(struct fh_audio_cfg *audio_config)
+{
+    int ret;
+
+    if(audio_config->playback.state == STATE_RUN)
+    {
+        return 0;
+    }
+
+    if (audio_config->playback.cfg.buffer_bytes >= AUDIO_DMA_PREALLOC_SIZE)
+    {
+        printk("DMA prealloc buffer is smaller than  audio_config->buffer_bytes\n");
+        return -ENOMEM;
+    }
+    memset(audio_config->playback.area, 0, audio_config->playback.cfg.buffer_bytes);
+    audio_config->playback.size = audio_config->playback.cfg.buffer_bytes;
+    audio_config->playback.state = STATE_RUN;
+    ret = register_tx_dma(audio_config);
+    if (ret < 0)
+    {
+        return ret;
+    }
+    INIT_WORK(&playback_wq, playback_start_wq_handler);
+    schedule_work(&playback_wq);
+    return 0;
+}
+
+int fh_acw_start_capture(struct fh_audio_cfg *audio_config)
+{
+    if(audio_config->capture.state == STATE_RUN)
+    {
+        return 0;
+    }
+
+    if (audio_config->capture.cfg.buffer_bytes >= AUDIO_DMA_PREALLOC_SIZE)
+    {
+        printk("DMA prealloc buffer is smaller than  audio_config->buffer_bytes\n");
+        return -ENOMEM;
+    }
+    memset(audio_config->capture.area, 0, audio_config->capture.cfg.buffer_bytes);
+    audio_config->capture.size = audio_config->capture.cfg.buffer_bytes;
+
+    audio_config->capture.state = STATE_RUN;
+    return register_rx_dma(audio_config);
+}
+
+
+static void fh_acw_rx_dma_done(void *arg)
+{
+    struct fh_audio_cfg *audio_config;
+    audio_config = ( struct fh_audio_cfg *)arg;
+printk("%s",__func__);
+    spin_lock(&audio_config->capture.lock);
+    audio_config->capture.hw_ptr += audio_config->capture.cfg.period_bytes;
+    if (audio_config->capture.hw_ptr > audio_config->capture.size )
+    {
+        audio_config->capture.hw_ptr = audio_config->capture.hw_ptr - audio_config->capture.size;
+    }
+    spin_unlock(&audio_config->capture.lock);
+    if (waitqueue_active(&audio_config->readqueue))
+    {
+        int avail = avail_data_len(capture,audio_config);
+        if (avail > audio_config->capture.cfg.period_bytes)
+        {
+            wake_up_interruptible(&audio_config->readqueue);
+        }
+    }
+
+}
+#ifdef 	STERO
+static void fh_acw_tx_right_dma_done(void *arg)
+{
+	printk("tx_right_dam_done\n");
+
+}
+#endif
+
+static void fh_acw_tx_dma_done(void *arg)
+{
+	printk("%s",__func__);
+    struct fh_audio_cfg *audio_config;
+    audio_config = ( struct fh_audio_cfg *)arg;
+    spin_lock(&audio_config->playback.lock);
+    audio_config->playback.hw_ptr +=  audio_config->playback.cfg.period_bytes;
+    if (audio_config->playback.hw_ptr > audio_config->playback.size )
+    {
+        audio_config->playback.hw_ptr = audio_config->playback.hw_ptr - audio_config->playback.size;
+    }
+    spin_unlock(&audio_config->playback.lock);
+    if (waitqueue_active(&audio_config->writequeue))
+    {
+        int avail = avail_data_len(playback,audio_config);
+        if (avail > audio_config->playback.cfg.period_bytes)
+        {
+            wake_up_interruptible(&audio_config->writequeue);
+        }
+    }
+}
+
+bool  fh_acw_dma_chan_filter(struct dma_chan *chan, void *filter_param)
+{
+    int dma_channel = *(int *)filter_param;
+    bool ret = false;
+
+    if (chan->chan_id == dma_channel)
+    {
+        ret = true;
+    }
+    return ret;
+}
+
+int arg_config_support(struct fh_audio_cfg_arg * cfg)
+{
+	int ret;
+
+	ret = get_param_from_volume(cfg->volume);
+	if (ret < 0) {
+		return -EINVAL;
+	}
+	ret = get_factor_from_table(cfg->rate);
+	if (ret < 0) {
+		return -EINVAL;
+	}
+    return 0;
+}
+
+void reset_dma_buff(enum audio_type type, struct fh_audio_cfg *audio_config)
+{
+    if (capture == type)
+    {
+        audio_config->capture.appl_ptr = 0;
+        audio_config->capture.hw_ptr = 0;
+    }
+    else
+    {
+        audio_config->playback.appl_ptr = 0;
+        audio_config->playback.hw_ptr = 0;
+    }
+}
+
+unsigned int config_flag = 0;
+static long fh_audio_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    struct fh_audio_cfg_arg cfg;
+    struct miscdevice *miscdev = filp->private_data;
+    struct audio_dev  *dev = container_of(miscdev, struct audio_dev, fh_audio_miscdev);
+    struct fh_audio_cfg  *audio_config = &dev->audio_config;
+    int ret;
+    int value,pid;
+    int __user *p = (int __user *)arg;
+    int rx_status;
+
+#ifndef CONFIG_MACH_FH8830_FPGA
+    int tx_status;
+#endif
+    pid = current->tgid;
+    switch (cmd)
+    {
+        case AC_INIT_CAPTURE_MEM:
+
+            if (copy_from_user((void *)&cfg, (void __user *)arg, sizeof(struct fh_audio_cfg_arg)))
+            {
+                printk(KERN_ERR "copy err\n");
+                return -EIO;
+            }
+            if (0 == arg_config_support(&cfg))
+            {
+            	if (down_trylock(&audio_config->sem_capture))
+	            {
+	            	printk(KERN_ERR "another thread is running capture.\n");
+	                return -EBUSY;
+	            }
+            	infor_record.record_pid =  pid;
+                audio_config->capture.cfg.io_type = cfg.io_type;
+                audio_config->capture.cfg.volume = cfg.volume;
+                audio_config->capture.cfg.rate = cfg.rate;
+                audio_config->capture.cfg.channels = cfg.channels;
+                audio_config->capture.cfg.buffer_size = cfg.buffer_size;
+                audio_config->capture.cfg.frame_bit = FIX_SAMPLE_BIT;
+                audio_config->capture.cfg.period_size = cfg.period_size;
+                audio_config->capture.cfg.buffer_bytes = frames_to_bytes(audio_config->capture.cfg.frame_bit,audio_config->capture.cfg.buffer_size);
+                audio_config->capture.cfg.period_bytes = frames_to_bytes(audio_config->capture.cfg.frame_bit,audio_config->capture.cfg.period_size);
+                audio_config->capture.cfg.start_threshold =audio_config->capture.cfg.buffer_bytes;
+                audio_config->capture.cfg.stop_threshold = audio_config->capture.cfg.buffer_bytes;
+                reset_dma_buff(capture, audio_config);
+                init_waitqueue_head(&audio_config->readqueue);
+                spin_lock_init(&audio_config->capture.lock);
+                init_audio(capture, audio_config);
+                audio_param_store.input_io_type = audio_config->capture.cfg.io_type;
+                audio_param_store.input_volume = audio_config->capture.cfg.volume;
+                /* *  config sample  *  */
+                codec_i2c_adapter = i2c_get_adapter(0);
+                i2c_write_codec(0x20, 0x00);//config pll to 8k rate
+            	i2c_write_codec(0x22, 0x14);
+            	i2c_write_codec(0x23, 0x55);
+                i2c_write_codec(0x24, 0x0);
+                msleep(1000);
+                i2c_write_codec(0x20, 0x01);
+
+                i2c_write_codec(0x10, 0x11);
+                i2c_write_codec(0x17, 0xf0);
+                i2c_write_codec(0x0, 0x01);
+                i2c_write_codec(0x1, 0x5);
+                i2c_write_codec(0x1f, 0x1);
+                i2c_write_codec(0x2, 0x10);
+                /*  * config wrapper work format  *   */
+        	    writel(0x08,fh_audio_module.regs + 0x10);/*reset dma*/
+        	    writel(0x3,fh_audio_module.regs + 0x180);/*reset dma*/
+        	    writel(0x1f,fh_audio_module.regs + 0x188);/*reset dma*/
+        	    writel(0x1f,fh_audio_module.regs + 0x184);/*reset dma*/
+        	    writel(0x1,fh_audio_module.regs + 0x8);/*reset dma*/
+        	    writel(0x1,fh_audio_module.regs + 0xc);/*reset dma*/
+                config_flag = 1;
+            }
+            else
+            {
+                return -EINVAL;
+            }
+
+            break;
+        case AC_INIT_PLAYBACK_MEM:
+            if (copy_from_user((void *)&cfg, (void __user *)arg, sizeof(struct fh_audio_cfg_arg)))
+            {
+                printk(KERN_ERR "copy err\n");
+                return -EIO;
+            }
+            
+            if (0 == arg_config_support(&cfg))
+            {
+            	if (down_trylock(&audio_config->sem_playback))
+	            {
+	            	printk(KERN_ERR "another thread is running playback.\n");
+	                return -EBUSY;
+	            }
+            	infor_record.play_pid = pid;
+                audio_config->playback.cfg.io_type = cfg.io_type;
+                audio_config->playback.cfg.volume = cfg.volume;
+                audio_config->playback.cfg.rate = cfg.rate;
+                audio_config->playback.cfg.channels = cfg.channels;
+                audio_config->playback.cfg.buffer_size = cfg.buffer_size;
+                audio_config->playback.cfg.frame_bit = FIX_SAMPLE_BIT;
+                audio_config->playback.cfg.period_size = cfg.period_size;
+                audio_config->playback.cfg.buffer_bytes = frames_to_bytes(audio_config->playback.cfg.frame_bit,audio_config->playback.cfg.buffer_size);
+                audio_config->playback.cfg.period_bytes = frames_to_bytes(audio_config->playback.cfg.frame_bit,audio_config->playback.cfg.period_size);
+                audio_config->playback.cfg.start_threshold =audio_config->playback.cfg.buffer_bytes;
+                audio_config->playback.cfg.stop_threshold = audio_config->playback.cfg.buffer_bytes;
+                reset_dma_buff(playback, audio_config);
+                codec_i2c_adapter = i2c_get_adapter(0);
+                if(!config_flag){
+                	/* * config sample  *  */
+                	i2c_write_codec(0x20, 0x0);//config pll
+                  	i2c_write_codec(0x22, 0x14);
+                    i2c_write_codec(0x23, 0x55);
+                    i2c_write_codec(0x24, 0x0);
+					msleep(1000);
+					i2c_write_codec(0x20, 0x1);
+
+					i2c_write_codec(0x10, 0x11);
+					i2c_write_codec(0x17, 0xf0);
+					i2c_write_codec(0x0, 0x01);
+					i2c_write_codec(0x1, 0x5);
+					i2c_write_codec(0x1f, 0x1);
+
+					i2c_write_codec(0x2, 0x10);
+					/*  * config wrapper work format  *   */
+
+	        	    writel(0x08,fh_audio_module.regs + 0x10);/*reset dma*/
+	         	    writel(0x3,fh_audio_module.regs + 0x180);/*reset dma*/
+	        	    writel(0x1f,fh_audio_module.regs + 0x188);/*reset dma*/
+	        	    writel(0x1f,fh_audio_module.regs + 0x184);/*reset dma*/
+	        	    writel(0x1,fh_audio_module.regs + 0x8);/*reset dma*/
+	        	    writel(0x1,fh_audio_module.regs + 0xc);/*reset dma*/
+	                /** dont config again **/
+	                config_flag = 1;
+
+                }
+                init_waitqueue_head(&audio_config->writequeue);
+                spin_lock_init(&audio_config->playback.lock);
+                init_audio(playback, audio_config);
+            }
+            else
+            {
+                return -EINVAL;
+            }
+            break;
+        case AC_AI_EN:
+            if (infor_record.record_pid != pid){
+            	return -EBUSY;
+            }
+            return fh_acw_start_capture(audio_config);
+        case AC_AO_EN:
+			if (infor_record.play_pid != pid) {
+				return -EBUSY;
+			}
+			return fh_acw_start_playback(audio_config);
+        case AC_SET_VOL:
+			if (infor_record.record_pid != pid) {
+				return -EBUSY;
+			}
+            if (get_user(value, p))
+            {
+                return -EFAULT;
+            }
+			ret = get_param_from_volume(value);
+			if (ret < 0) {
+				return -EINVAL;
+			}
+            audio_param_store.input_volume = value;
+            switch_input_volume(audio_param_store.input_volume);
+            break;
+        case AC_SET_INPUT_MODE:
+			if (infor_record.record_pid != pid) {
+				return -EBUSY;
+			}
+            if (get_user(value, p))
+            {
+                return -EFAULT;
+            }
+			if (value != mic_in && value != line_in) {
+				return -EINVAL;
+			}
+            audio_param_store.input_io_type = value;
+            switch_io_type(capture, audio_param_store.input_io_type);
+            break;
+        case AC_SET_OUTPUT_MODE:
+			if (infor_record.play_pid != pid) {
+				return -EBUSY;
+			}
+            if (get_user(value, p))
+            {
+                return -EFAULT;
+            }
+			if (value != speaker_out && value != line_out) {
+				return -EINVAL;
+			}
+            switch_io_type(playback, value);
+            break;
+        case AC_AI_DISABLE:
+            printk("[ac_driver]AC_AI_DISABLE\n");
+			if (infor_record.record_pid != pid) {
+				return -EBUSY;
+			}
+			fh_acw_stop_capture(audio_config);
+            printk(" AC_AI_DISABLE\n");
+            break;
+        case AC_AO_DISABLE:
+            printk("[ac_driver]AC_AO_DISABLE\n");
+			if (infor_record.play_pid != pid) {
+				return -EBUSY;
+			}
+            fh_acw_stop_playback(audio_config);
+            printk(" AC_AO_DISABLE\n");
+            break;
+        case AC_AI_PAUSE:
+			if (infor_record.record_pid != pid) {
+				return -EBUSY;
+			}
+            printk(KERN_INFO "capture pause\n");
+            audio_config->capture.state = STATE_PAUSE;
+            rx_status = readl(fh_audio_module.regs + ACW_RXFIFO_CTRL);/*rx fifo disable*/
+            rx_status =  rx_status&(~(1<<0));
+            writel(rx_status, fh_audio_module.regs + ACW_RXFIFO_CTRL);/*rx fifo disable*/
+            break;
+        case AC_AI_RESUME:
+			if (infor_record.record_pid != pid) {
+				return -EBUSY;
+			}
+            printk(KERN_INFO "capture resume\n");
+            audio_config->capture.state = STATE_RUN;
+#ifndef CONFIG_MACH_FH8830_FPGA
+            rx_status = readl( fh_audio_module.regs + ACW_RXFIFO_CTRL);//clear rx fifo
+            rx_status =  rx_status|(1<<4);
+            writel(rx_status,fh_audio_module.regs + ACW_RXFIFO_CTRL);/*enable rx fifo*/
+            rx_status =  rx_status&(~(1<<4));
+            rx_status =  rx_status|(1<<0);
+            writel(rx_status,fh_audio_module.regs + ACW_RXFIFO_CTRL);/*enable rx fifo*/
+#endif
+            break;
+        case AC_AO_PAUSE:
+			if (infor_record.play_pid != pid) {
+				return -EBUSY;
+			}
+            audio_config->playback.state = STATE_PAUSE;
+            printk(KERN_INFO "playback pause\n");
+//#ifndef CONFIG_MACH_FH8830_FPGA
+//            tx_status = readl(fh_audio_module.regs + ACW_TXFIFO_CTRL);/*rx fifo disable*/
+//            tx_status =  tx_status&(~(1<<0));
+//            writel(tx_status, fh_audio_module.regs + ACW_TXFIFO_CTRL);/*tx fifo disable*/
+//#endif
+            break;
+        case AC_AO_RESUME:
+			if (infor_record.play_pid != pid) {
+				return -EBUSY;
+			}
+            printk(KERN_INFO "playback resume\n");
+            audio_config->playback.state = STATE_RUN;
+//#ifndef CONFIG_MACH_FH8830_FPGA
+//            tx_status = readl( fh_audio_module.regs + ACW_TXFIFO_CTRL);//clear rx fifo
+//            tx_status =  tx_status|(1<<0);
+//            writel(tx_status,fh_audio_module.regs + ACW_TXFIFO_CTRL); //enable tx fifo read enable
+//#endif
+            break;
+        default:
+            return -ENOTTY;
+    }
+    return 0;
+}
+
+static int fh_audio_open(struct inode *ip, struct file *fp)
+{
+
+    fp->private_data = &fh_audio_dev.fh_audio_miscdev;
+//    //enable interrupts
+
+    return 0;
+}
+
+static u32 fh_audio_poll(struct file *filp, poll_table *wait)
+{
+    struct miscdevice *miscdev = filp->private_data;
+    struct audio_dev  *dev = container_of(miscdev, struct audio_dev, fh_audio_miscdev);
+    struct fh_audio_cfg  *audio_config = &dev->audio_config;
+    u32 mask = 0;
+    long avail;
+    if (STATE_RUN == audio_config->capture.state)
+    {
+        poll_wait(filp,&audio_config->readqueue,wait);
+        avail = avail_data_len(capture, audio_config);
+        if (avail >  audio_config->capture.cfg.period_bytes)
+        {
+            mask |=  POLLIN | POLLRDNORM;
+        }
+    }
+    if (STATE_RUN == audio_config->playback.state)
+    {
+        poll_wait(filp,&audio_config->writequeue,wait);
+        avail = avail_data_len(playback, audio_config);
+        if (avail >  audio_config->playback.cfg.period_bytes)
+        {
+            mask |=  POLLOUT | POLLWRNORM;
+        }
+    }
+    return mask;
+}
+
+static int fh_audio_read(struct file *filp, char __user *buf, size_t len, loff_t *off)
+{
+
+    int ret;
+    struct miscdevice *miscdev = filp->private_data;
+    struct audio_dev  *dev = container_of(miscdev, struct audio_dev, fh_audio_miscdev);
+    struct fh_audio_cfg  *audio_config = &dev->audio_config;
+    int after,left;
+    int pid,avail;
+    pid = current->tgid;
+    if (infor_record.record_pid != pid){
+    	return -EBUSY;
+    }
+
+    avail = avail_data_len(capture, audio_config);
+    if (avail > len)
+    {
+        avail = len;
+    }
+    after = avail + audio_config->capture.appl_ptr;
+    if(after  > audio_config->capture.size)
+    {
+        left = avail - (audio_config->capture.size - audio_config->capture.appl_ptr);
+        ret = copy_to_user(buf, audio_config->capture.area+audio_config->capture.appl_ptr, audio_config->capture.size-audio_config->capture.appl_ptr);
+        ret = copy_to_user(buf+audio_config->capture.size-audio_config->capture.appl_ptr,audio_config->capture.area,left);
+        spin_lock(&audio_config->capture.lock);
+        audio_config->capture.appl_ptr = left;
+        spin_unlock(&audio_config->capture.lock);
+    }
+    else
+    {
+        ret = copy_to_user(buf,audio_config->capture.area+audio_config->capture.appl_ptr,avail);
+        spin_lock(&audio_config->capture.lock);
+        audio_config->capture.appl_ptr += avail;
+        spin_unlock(&audio_config->capture.lock);
+    }
+
+    return avail;
+
+}
+
+static int fh_audio_write(struct file *filp, const char __user *buf,
+                            size_t len, loff_t *off)
+{
+
+    struct miscdevice *miscdev = filp->private_data;
+    struct audio_dev  *dev = container_of(miscdev, struct audio_dev, fh_audio_miscdev);
+    struct fh_audio_cfg  *audio_config = &dev->audio_config;
+    int  ret;
+    int after,left;
+    int pid,avail;
+   pid = current->tgid;
+   if (infor_record.play_pid != pid){
+	return -EBUSY;
+   }
+    avail = avail_data_len(playback,audio_config);
+    if (0 == avail)
+    {
+        return 0;
+    }
+    if (avail > len)
+    {
+        avail = len;
+    }
+    after = avail+audio_config->playback.appl_ptr;
+    if(after  > audio_config->playback.size)
+    {
+        left = avail - (audio_config->playback.size-audio_config->playback.appl_ptr);
+        ret = copy_from_user(audio_config->playback.area+audio_config->playback.appl_ptr,buf,audio_config->playback.size-audio_config->playback.appl_ptr);
+        ret = copy_from_user(audio_config->playback.area,buf+audio_config->playback.size-audio_config->playback.appl_ptr,left);
+        spin_lock(&audio_config->playback.lock);
+        audio_config->playback.appl_ptr = left;
+        spin_unlock(&audio_config->playback.lock);
+    }
+    else
+    {
+        ret = copy_from_user(audio_config->playback.area+audio_config->playback.appl_ptr,buf,avail);
+        spin_lock(&audio_config->playback.lock);
+        audio_config->playback.appl_ptr += avail;
+        spin_unlock(&audio_config->playback.lock);
+    }
+
+     return avail;
+}
+
+static irqreturn_t fh_audio_interrupt(int irq, void *dev_id)
+{
+#ifndef CONFIG_MACH_FH8830_FPGA
+	u32 interrupts, rx_status;
+    struct fh_audio_cfg  *audio_config = &fh_audio_dev.audio_config;
+
+    interrupts = readl(fh_audio_module.regs + ACW_CTRL);
+    //interrupts &= ~(0x3ff) << 16;
+    writel(interrupts, fh_audio_module.regs + ACW_CTRL);
+
+    if(interrupts & ACW_INTR_RX_UNDERFLOW)
+    {
+        fh_acw_stop_capture(audio_config);
+        fh_acw_start_capture(audio_config);
+        PRINT_AUDIO_DBG("ACW_INTR_RX_UNDERFLOW\n");
+    }
+
+    if(interrupts & ACW_INTR_RX_OVERFLOW)
+    {
+        if (audio_config->capture.state == STATE_RUN) {
+            fh_acw_stop_capture(audio_config);
+            fh_acw_start_capture(audio_config);
+        } else {
+            rx_status = readl( fh_audio_module.regs + ACW_RXFIFO_CTRL);//clear rx fifo
+            rx_status =  rx_status|(1<<4);
+            writel(rx_status,fh_audio_module.regs + ACW_RXFIFO_CTRL);
+        }
+        PRINT_AUDIO_DBG("ACW_INTR_RX_OVERFLOW\n");
+    }
+
+    if(interrupts & ACW_INTR_TX_UNDERFLOW)
+    {
+        fh_acw_stop_playback(audio_config);
+        fh_acw_start_playback(audio_config);
+        PRINT_AUDIO_DBG("ACW_INTR_TX_UNDERFLOW\n");
+    }
+
+    if(interrupts & ACW_INTR_TX_OVERFLOW)
+    {
+        fh_acw_stop_playback(audio_config);
+        fh_acw_start_playback(audio_config);
+        PRINT_AUDIO_DBG("ACW_INTR_TX_OVERFLOW\n");
+    }
+
+    PRINT_AUDIO_DBG("interrupts: 0x%x\n", interrupts);
+#endif
+    return IRQ_HANDLED;
+}
+
+static const struct file_operations acw_fops =
+{
+    .owner      = THIS_MODULE,
+    .llseek     = no_llseek,
+    .unlocked_ioctl = fh_audio_ioctl,
+    .release = fh_audio_close,
+    .open = fh_audio_open,
+    .poll = fh_audio_poll,
+    .read = fh_audio_read,
+    .write = fh_audio_write,
+
+};
+
+static int __devinit fh_audio_drv_probe(struct platform_device *pdev)
+{
+    int ret;
+    struct resource *irq_res, *mem;
+
+    mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!mem)
+        return -EINVAL;
+    printk("acw probe\n");
+    if (!devm_request_mem_region(&pdev->dev, mem->start, resource_size(mem),
+                                 "fh_audio_module"))
+        return -ENOMEM;
+
+    fh_audio_module.regs = devm_ioremap(&pdev->dev, DW_I2S_FH8833, resource_size(mem));
+
+    if (!fh_audio_module.regs){
+    	ret = -ENOMEM;
+    	goto remap_fail;
+        }
+
+    fh_audio_module.clk = clk_get(NULL, "ac_clk");
+	if (!fh_audio_module.clk) {
+		ret = -EINVAL;
+		goto clk_fail;
+		}
+    clk_enable(fh_audio_module.clk);
+
+    spin_lock_init(&fh_audio_module.lock);
+
+    ret = misc_register(&fh_audio_dev.fh_audio_miscdev);
+
+    if (ret)
+        goto out_disable_clk;
+
+    irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+    if (!irq_res)
+    {
+        pr_err("%s: ERROR: getting resource failed"
+               "cannot get IORESOURCE_IRQ\n", __func__);
+        ret = -ENXIO;
+        goto out_disable_clk;
+    }
+
+    fh_audio_module.irq = irq_res->start;
+
+    ret = request_irq(fh_audio_module.irq, fh_audio_interrupt, IRQF_SHARED, "audio", &fh_audio_module);
+
+    return 0;
+
+out_disable_clk:
+    clk_disable(fh_audio_module.clk);
+	fh_audio_module.clk = NULL;
+clk_fail:
+	devm_iounmap(&pdev->dev, fh_audio_module.regs);
+	fh_audio_module.regs = NULL;
+remap_fail:
+	devm_release_mem_region(&pdev->dev, mem->start, resource_size(mem));
+    return ret;
+}
+
+static int __devexit fh_acw_drv_remove(struct platform_device *pdev)
+{
+	struct resource *mem;
+    misc_deregister(&fh_audio_dev.fh_audio_miscdev);
+
+    free_irq(fh_audio_module.irq, &fh_audio_module);
+
+	if (fh_audio_module.clk) {
+		clk_disable(fh_audio_module.clk);
+    	clk_put(fh_audio_module.clk);
+	}
+	if (fh_audio_module.regs) {
+		devm_iounmap(&pdev->dev, fh_audio_module.regs);
+	}
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (mem) {
+		devm_release_mem_region(&pdev->dev, mem->start, resource_size(mem));
+    }
+    printk("acw remove ok\n");
+    return 0;
+}
+
+static struct platform_driver fh_audio_driver =
+{
+    .probe      = fh_audio_drv_probe,
+    .remove     = __devexit_p(fh_acw_drv_remove),
+    .driver     = {
+        .name   = "fh_acw",
+        .owner  = THIS_MODULE,
+    }
+};
+
+void audio_prealloc_dma_buffer(struct fh_audio_cfg  *audio_config)
+{
+    int pg;
+    gfp_t gfp_flags;
+    pg = get_order(AUDIO_DMA_PREALLOC_SIZE);
+    gfp_flags = GFP_KERNEL | __GFP_COMP | __GFP_NORETRY | __GFP_NOWARN;
+    audio_config->capture.dev.coherent_dma_mask = DMA_BIT_MASK(32);
+    audio_config->capture.area  = dma_alloc_coherent(&audio_config->capture.dev, PAGE_SIZE << pg, &audio_config->capture.addr, gfp_flags );
+    if (!audio_config->capture.area)
+    {
+        printk(KERN_ERR"no enough mem for capture  buffer alloc\n");
+        return ;
+    }
+    audio_config->playback.dev.coherent_dma_mask = DMA_BIT_MASK(32);
+    audio_config->playback.area  = dma_alloc_coherent(&audio_config->playback.dev, PAGE_SIZE << pg, &audio_config->playback.addr, gfp_flags );
+    if (!audio_config->playback.area)
+    {
+        printk(KERN_ERR"no enough mem for  playback buffer alloc\n");
+        return ;
+    }
+}
+
+void audio_free_prealloc_dma_buffer(struct fh_audio_cfg  *audio_config)
+{
+    int pg;
+    pg = get_order(AUDIO_DMA_PREALLOC_SIZE);
+    dma_free_coherent(&audio_config->capture.dev, PAGE_SIZE<<pg, audio_config->capture.area, audio_config->capture.addr);
+    dma_free_coherent(&audio_config->playback.dev, PAGE_SIZE<<pg, audio_config->playback.area, audio_config->playback.addr);
+}
+
+static void init_audio_mutex(struct fh_audio_cfg  *audio_config)
+{
+    sema_init(&audio_config->sem_capture, 1);
+    sema_init(&audio_config->sem_playback, 1);
+}
+
+int audio_request_dma_channel(void)
+{
+    dma_cap_mask_t mask;
+    /*request audio rx dma channel*/
+    dma_rx_transfer = kzalloc(sizeof(struct fh_dma_chan), GFP_KERNEL);
+    if (!dma_rx_transfer)
+    {
+        printk(KERN_ERR"alloc  dma_rx_transfer failed\n");
+        goto mem_fail;
+    }
+    memset(dma_rx_transfer, 0, sizeof(struct fh_dma_chan));
+
+    dma_cap_zero(mask);
+    dma_cap_set(DMA_SLAVE, mask);
+    dma_rx_transfer->chan = dma_request_channel(mask, fh_acw_dma_chan_filter, &fh_audio_dev.channel_assign.capture_channel);
+    if (!dma_rx_transfer->chan)
+    {
+        printk(KERN_ERR"request audio rx dma channel failed \n");
+        goto channel_fail;
+    }
+
+    /*request audio tx dma channel*/
+    dma_tx_transfer = kzalloc(sizeof(struct fh_dma_chan), GFP_KERNEL);
+    if (!dma_tx_transfer)
+    {
+        printk(KERN_ERR"alloc  dma_tx_transfer failed\n");
+        goto mem_fail;
+    }
+    memset(dma_tx_transfer, 0, sizeof(struct fh_dma_chan));
+
+    dma_cap_zero(mask);
+    dma_cap_set(DMA_SLAVE, mask);
+    dma_tx_transfer->chan = dma_request_channel(mask, fh_acw_dma_chan_filter, &fh_audio_dev.channel_assign.playback_channel);
+    if (!dma_tx_transfer->chan)
+    {
+        printk(KERN_ERR"request dma channel failed \n");
+        return -EFAULT;
+    }
+#ifdef STERO
+    /*request audio tx dma channel*/
+    dma_tx_right_transfer = kzalloc(sizeof(struct fh_dma_chan), GFP_KERNEL);
+    if (!dma_tx_right_transfer)
+    {
+        printk(KERN_ERR"alloc  dma_tx_right_transfer failed\n");
+        goto mem_fail;
+    }
+    memset(dma_tx_right_transfer, 0, sizeof(struct fh_dma_chan));
+
+    dma_cap_zero(mask);
+    dma_cap_set(DMA_SLAVE, mask);
+    dma_tx_right_transfer->chan = dma_request_channel(mask, TX_RIGHT_CHANNEL_DMA_CHANNEL, &fh_audio_dev.channel_assign.playback_channel);
+    if (!dma_tx_right_transfer->chan)
+    {
+        printk(KERN_ERR"request dma channel dma_tx_right_transfer failed \n");
+        return -EFAULT;
+    }
+#endif
+    return 0;
+channel_fail:
+    if (!dma_rx_transfer->chan)
+    {
+        dma_release_channel(dma_rx_transfer->chan);
+		dma_rx_transfer->chan = NULL;
+    }
+    if (!dma_tx_transfer->chan)
+    {
+        dma_release_channel(dma_tx_transfer->chan);
+		dma_tx_transfer->chan = NULL;
+    }
+#ifdef STERO
+    if (!dma_tx_right_transfer->chan)
+    {
+        dma_release_channel(dma_tx_right_transfer->chan);
+		dma_tx_right_transfer->chan = NULL;
+    }
+#endif
+mem_fail:
+    if (dma_rx_transfer != NULL)
+    {
+        kfree(dma_rx_transfer);
+        dma_rx_transfer = NULL;
+    }
+    if (dma_tx_transfer != NULL)
+    {
+        kfree(dma_tx_transfer);
+        dma_tx_transfer = NULL;
+    }
+#ifdef 	STERO
+    if (dma_tx_right_transfer != NULL)
+    {
+        kfree(dma_tx_right_transfer);
+        dma_tx_right_transfer = NULL;
+    }
+#endif
+    return -EFAULT;
+}
+
+void audio_release_dma_channel(void)
+{
+    /*release audio tx dma channel*/
+    if (dma_tx_transfer != NULL)
+    {
+    	if (dma_tx_transfer->chan) {
+			dma_release_channel(dma_tx_transfer->chan);
+			dma_tx_transfer->chan = NULL;
+    	}
+        kfree(dma_tx_transfer);
+        dma_tx_transfer = NULL;
+    }
+
+    /*release audio rx dma channel*/
+    if (dma_rx_transfer != NULL)
+    {
+    	if (dma_rx_transfer->chan) {
+			dma_release_channel(dma_rx_transfer->chan);
+			dma_rx_transfer->chan = NULL;
+    	}
+        
+        kfree(dma_rx_transfer);
+        dma_rx_transfer = NULL;
+    }
+#ifdef STERO
+    /*release audio tx dma channel*/
+    if (dma_tx_right_transfer != NULL)
+    {
+    	if (dma_tx_right_transfer->chan) {
+			dma_release_channel(dma_tx_right_transfer->chan);
+			dma_tx_right_transfer->chan = NULL;
+    	}
+        kfree(dma_tx_right_transfer);
+        dma_tx_right_transfer = NULL;
+    }
+
+#endif
+
+}
+
+static int __init fh_audio_init(void)
+{
+    create_proc();
+    init_audio_mutex(&fh_audio_dev.audio_config);
+    audio_prealloc_dma_buffer(&fh_audio_dev.audio_config);
+    audio_request_dma_channel();
+    return platform_driver_register(&fh_audio_driver);
+}
+module_init(fh_audio_init);
+
+static void __exit fh_audio_exit(void)
+{
+
+    remove_proc();
+    audio_release_dma_channel();
+    audio_free_prealloc_dma_buffer(&fh_audio_dev.audio_config);
+    platform_driver_unregister(&fh_audio_driver);
+}
+module_exit(fh_audio_exit);
+
+MODULE_AUTHOR("FH_AUDIO");
+MODULE_DESCRIPTION("FH_AUDIO");
+MODULE_LICENSE("GPL");
+
+/****************************debug proc*****************************/
+#include <linux/proc_fs.h>
+
+struct proc_dir_entry *proc_ac_entry;
+#define proc_name "fh_audio"
+
+ssize_t proc_ac_read(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    ssize_t len = 0;
+	int i;
+
+	for (i = 0;i <= 0x20;i += 4) {
+		printk(KERN_INFO"0x%x reg = 0x%x\n",i, readl(fh_audio_module.regs + i));
+	}
+    return len;
+}
+
+static void create_proc(void)
+{
+    proc_ac_entry = create_proc_entry(proc_name, S_IRUGO, NULL);
+    if (!proc_ac_entry)
+    {
+        printk(KERN_ERR"create proc failed\n");
+    }
+    else
+    {
+        proc_ac_entry->read_proc = proc_ac_read;
+    }
+}
+
+static void remove_proc(void)
+{
+    remove_proc_entry(proc_name, NULL);
+}
+
diff -uraN linux-3.0.8/drivers/misc/fh_efuse.c linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_efuse.c
--- linux-3.0.8/drivers/misc/fh_efuse.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_efuse.c	2021-07-13 23:40:34.778363143 +0300
@@ -0,0 +1,545 @@
+/*
+ * fh_efuse.c
+ *
+ *  Created on: Mar 13, 2015
+ *      Author: duobao
+ */
+#include <linux/uaccess.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+/*****************************************************************************
+ *  Include Section
+ *  add all #include here
+ *****************************************************************************/
+#include   "fh_efuse.h"
+/*****************************************************************************
+ * Define section
+ * add all #define here
+ *****************************************************************************/
+
+#define wrap_readl(wrap, name) \
+	__raw_readl(&(((struct wrap_efuse_reg *)wrap->regs)->name))
+
+#define wrap_writel(wrap, name, val) \
+	__raw_writel((val), &(((struct wrap_efuse_reg *)wrap->regs)->name))
+
+#define wrap_readw(wrap, name) \
+	__raw_readw(&(((struct wrap_efuse_reg *)wrap->regs)->name))
+
+#define wrap_writew(wrap, name, val) \
+	__raw_writew((val), &(((struct wrap_efuse_reg *)wrap->regs)->name))
+
+#define wrap_readb(wrap, name) \
+	__raw_readb(&(((struct wrap_efuse_reg *)wrap->regs)->name))
+
+#define wrap_writeb(wrap, name, val) \
+	__raw_writeb((val), &(((struct wrap_efuse_reg *)wrap->regs)->name))
+
+#define FH_EFUSE_PLAT_DEVICE_NAME			"fh_efuse"
+#define FH_EFUSE_MISC_DEVICE_NAME			"fh_efuse"
+#define FH_EFUSE_MISC_DEVICE_NODE_NAME		"fh_efuse_node"
+/****************************************************************************
+ * ADT section
+ *  add definition of user defined Data Type
+ *  that only be used in this file  here
+ ***************************************************************************/
+
+
+
+
+
+struct wrap_efuse_reg {
+	u32 efuse_cmd;				/*0x0*/
+	u32 efuse_config;			/*0x4*/
+	u32 efuse_match_key;		/*0x8*/
+	u32 efuse_timing0;			/*0xc*/
+	u32 efuse_timing1;			/*0x10*/
+	u32 efuse_timing2;			/*0x14*/
+	u32 efuse_timing3;			/*0x18*/
+	u32 efuse_timing4;			/*0x1c*/
+	u32 efuse_timing5;			/*0x20*/
+	u32 efuse_timing6;			/*0x24*/
+	u32 efuse_dout;				/*0x28*/
+	u32 efuse_status0;			/*0x2c*/
+	u32 efuse_status1;			/*0x30*/
+	u32 efuse_status2;			/*0x34*/
+	u32 efuse_status3;			/*0x38*/
+	u32 efuse_status4;			/*0x3c*/
+	u32 efuse_mem_info;
+};
+
+
+
+
+enum {
+	CMD_TRANS_AESKEY = 4,
+	CMD_WFLGA_AUTO = 8,
+};
+
+struct wrap_efuse_obj s_efuse_obj;
+
+#define EFUSE_MAX_ENTRY			60
+
+
+/******************************************************************************
+ * Function prototype section
+ * add prototypes for all functions called by this file,execepting those
+ * declared in header file
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Global variables section - Exported
+ * add declaration of global variables that will be exported here
+ * e.g.
+ *  int8_t foo;
+ ****************************************************************************/
+
+/*****************************************************************************
+
+ *  static fun;
+ *****************************************************************************/
+static int fh_efuse_open(struct inode *inode, struct file *file);
+static int fh_efuse_release(struct inode *inode, struct file *filp);
+static long fh_efuse_ioctl(struct file *filp, unsigned int cmd,
+		unsigned long arg);
+/*****************************************************************************
+ * Global variables section - Local
+ * define global variables(will be refered only in this file) here,
+ * static keyword should be used to limit scope of local variable to this file
+ * e.g.
+ *  static uint8_t ufoo;
+ *****************************************************************************/
+
+static const struct file_operations fh_efuse_fops = {
+		.owner = THIS_MODULE,
+		.open = fh_efuse_open,
+		.release = fh_efuse_release,
+		.unlocked_ioctl = fh_efuse_ioctl,
+};
+
+static struct miscdevice fh_efuse_misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = FH_EFUSE_MISC_DEVICE_NAME,
+	/*.nodename = FH_EFUSE_MISC_DEVICE_NODE_NAME,*/
+	.fops = &fh_efuse_fops,
+};
+
+static int fh_efuse_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int fh_efuse_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+void efuse_detect_complete(struct wrap_efuse_obj *obj, int pos)
+{
+	unsigned int rdata;
+	unsigned int time = 0;
+    /*printk("efuse wait pos %x...\n",pos);*/
+	do {
+			time++;
+			rdata = wrap_readl(obj, efuse_status0);
+			if (time > 1000) {
+								printk("[efuse]:detect time out...pos: 0x%x\n", pos);
+								return;
+							}
+			udelay(10);
+	} while ((rdata&(1<<pos)) != 1<<pos);
+    /*printk("efuse wait pos done...\n",pos);*/
+}
+
+void auto_check_efuse_pro_bits(struct wrap_efuse_obj *obj, u32 *buff)
+{
+	/*first set auto check cmd*/
+	wrap_writel(obj, efuse_cmd, CMD_WFLGA_AUTO);
+	efuse_detect_complete(obj, 8);
+	/*
+	mdelay(300);
+	read status from hw status
+	bit 1 means could be writen....
+	*/
+	buff[0] = wrap_readl(obj, efuse_status1);
+	buff[1] = wrap_readl(obj, efuse_status2);
+}
+
+void efuse_write_key_byte(struct wrap_efuse_obj *obj, u32 entry, u8 data)
+{
+	u32 temp = 0;
+	temp = (u32)data;
+	/*0~255*/
+	temp &= ~0xffffff00;
+	temp <<= 12;
+	/*0~63*/
+	entry &= 0x3f;
+	temp |= (entry<<4) | (0x02);
+	/*
+	printk("efuse write entry: %x,data: %x\n",entry,data);
+
+	printk("efuse write data :%x\n",temp);
+	wrap_writel(obj,efuse_cmd,(data<<12) + (entry<<4) + (0x02));
+	*/
+	wrap_writel(obj, efuse_cmd, temp);
+	efuse_detect_complete(obj, 2);
+}
+
+void efuse_load_usrcmd(struct wrap_efuse_obj *obj)
+{
+	wrap_writel(obj, efuse_cmd, 1);
+	efuse_detect_complete(obj, 1);
+}
+
+void efuse_trans_key(struct wrap_efuse_obj *obj, u32 start_no, u32 size)
+{
+	int i ;
+	if (obj->map_para.open_flag == 0) {
+		printk("Default mode...\n");
+		for (i = 0; i < size; i++) {
+			wrap_writel(obj, efuse_config, ((start_no + i)<<28));
+			wrap_writel(obj, efuse_cmd, (i<<20) + 0x04);
+			efuse_detect_complete(obj, 4);
+			/*mdelay(100);*/
+		}
+	}
+	if (obj->map_para.open_flag != 0) {
+		printk("parse efuse map...\n");
+		switch (obj->map_para.open_flag) {
+		case  OPEN_4_ENTRY_TO_1_KEY:
+			for (i = 0; i < obj->map_para.map_size; i++) {
+				/*here aes key must be started from 0...just parse efuse entry.*/
+				printk("times:%d,efuse entry : %d\n", i, obj->map_para.map[i].efuse_entry);
+				wrap_writel(obj, efuse_config, ((obj->map_para.map[i].efuse_entry / 4) << 28));
+				wrap_writel(obj, efuse_cmd, (i<<20) + 0x04);
+				efuse_detect_complete(obj, 4);
+			}
+			break;
+		case OPEN_1_ENTRY_TO_1_KEY:
+			printk("not support here now..\n");
+			break;
+		default:
+			printk("parse error efuse map para..\n");
+			break;
+		}
+	} else {
+		for (i = 0; i < size; i++) {
+			wrap_writel(obj, efuse_config, ((start_no + i)<<28));
+			wrap_writel(obj, efuse_cmd, (i<<20) + 0x04);
+			efuse_detect_complete(obj, 4);
+			/*mdelay(100);*/
+		}
+	}
+}
+
+static void aes_biglittle_swap(u8 *buf)
+{
+	u8 tmp, tmp1;
+	tmp = buf[0];
+	tmp1 = buf[1];
+	buf[0] = buf[3];
+	buf[1] = buf[2];
+	buf[2] = tmp1;
+	buf[3] = tmp;
+}
+void efuse_get_lock_status(struct wrap_efuse_obj *obj, struct efuse_status * status)
+{
+	status->efuse_apb_lock = (wrap_readl(obj, efuse_status0)>>20) & 0x0f;
+	status->aes_ahb_lock = (wrap_readl(obj, efuse_status0)>>24) & 0x0f;
+}
+
+void efuse_read_entry(struct wrap_efuse_obj *obj, u32 key, u32 start_entry, u8 *buff, u32 size)
+{
+	/*
+	wrap_writel(obj,efuse_cmd,1);
+	set key..
+	*/
+	u32 data, i;
+
+	for (i = 0; i < size; i++) {
+		wrap_writel(obj, efuse_match_key, key);
+		wrap_writel(obj, efuse_cmd, ((start_entry + i)<<4) + 0x03);
+		efuse_detect_complete(obj, 3);
+		data = wrap_readl(obj, efuse_dout);
+		*buff++ = (u8)data;
+	}
+}
+
+long fh_efuse_ioctl(struct file *filp, unsigned int cmd,
+		unsigned long arg)
+{
+	int i;
+
+	EFUSE_INFO efuse_info = {0};
+	u32 *p_dst = NULL;
+	u8 *p_dst_8 = NULL;
+	unsigned int data;
+	u32 temp_swap_data[32] = {0};
+
+	if (copy_from_user((void *) &efuse_info, (void __user*) arg,
+			sizeof(EFUSE_INFO))) {
+		return -EFAULT;
+	}
+/*
+	printk(
+			"app before raw info is: entry: %x,,key size: %x,
+			trans_key_start: %x, no is : %x, src_key_add:%x\n",
+			efuse_info.efuse_entry_no,
+			efuse_info.key_size,
+			efuse_info.trans_key_start_no,
+			efuse_info.trans_key_size,
+			(u32)efuse_info.key_buff);
+*/
+	switch (cmd) {
+	case IOCTL_EFUSE_CHECK_PRO:
+		/*printk("efuse check pro...\n");*/
+		efuse_load_usrcmd(&s_efuse_obj);
+		auto_check_efuse_pro_bits(&s_efuse_obj, efuse_info.status.protect_bits);
+		/*
+		memcpy((void*)s_efuse_obj.status.protect_bits,
+		(void*)efuse_info.status.protect_bits,sizeof());
+		//mdelay(300);
+		*/
+		break;
+	case IOCTL_EFUSE_WRITE_KEY:
+		/*
+		printk("efuse write key...\n");
+		first check if could write....
+		write key...
+		printk("efuse entry no is %d\n",efuse_info.efuse_entry_no);
+		*/
+		/*add swap data....*/
+		memcpy((u8 *)&temp_swap_data[0], efuse_info.key_buff, efuse_info.key_size);
+		p_dst = &temp_swap_data[0];
+		for (i = 0; i < efuse_info.key_size / sizeof(u32); i++) {
+			aes_biglittle_swap((u8 *) (p_dst + i));
+			/*printk("swap data is %x\n",*(p_dst + i));*/
+		}
+		p_dst_8 = (u8 *)&temp_swap_data[0];
+
+		for (i = 0; i < efuse_info.key_size; i++) {
+			efuse_write_key_byte(&s_efuse_obj, efuse_info.efuse_entry_no + i, *(p_dst_8 + i));
+			/*mdelay(300);*/
+		}
+		s_efuse_obj.efuse_entry_no = efuse_info.efuse_entry_no;
+		s_efuse_obj.key_buff = efuse_info.key_buff;
+		s_efuse_obj.key_size = efuse_info.key_size;
+		efuse_load_usrcmd(&s_efuse_obj);
+		break;
+	case IOCTL_EFUSE_CHECK_LOCK:
+		/*printk("efuse check lock\n");*/
+		efuse_load_usrcmd(&s_efuse_obj);
+		efuse_get_lock_status(&s_efuse_obj, &efuse_info.status);
+		break;
+	case IOCTL_EFUSE_TRANS_KEY:
+		/*printk("efuse trans key\n");*/
+		efuse_trans_key(&s_efuse_obj, efuse_info.trans_key_start_no, efuse_info.trans_key_size);
+		/*
+		s_efuse_obj.trans_key_start_no = efuse_info.trans_key_start_no;
+		s_efuse_obj.trans_key_size = efuse_info.trans_key_size;
+	    efuse_info.status.open_flag = USE_EFUSE_SET_KEY;
+		*/
+		break;
+	case IOCTL_EFUSE_SWITCH_CPU_KEY_MODE:
+		s_efuse_obj.open_flag = USE_CPU_SET_KEY;
+		break;
+	case IOCTL_EFUSE_SWITCH_EFUSE_KEY_MODE:
+		s_efuse_obj.open_flag = USE_EFUSE_SET_KEY;
+		break;
+	case IOCTL_EFUSE_CHECK_ERROR:
+		break;
+	case IOCTL_EFUSE_READ_KEY:
+		/*printf("match is  : %x..\n",match_key);*/
+		efuse_read_entry(&s_efuse_obj, efuse_info.status.error, efuse_info.efuse_entry_no, efuse_info.key_buff, efuse_info.key_size);
+		p_dst = (u32 *)efuse_info.key_buff;
+		for (i = 0; i < efuse_info.key_size / sizeof(u32); i++) {
+			aes_biglittle_swap((u8 *) (p_dst + i));
+			/*printk("swap data is %x\n",*(p_dst + i));*/
+		}
+		/*memcpy(efuse_user_info,&efuse_info,sizeof(EFUSE_INFO));*/
+		break;
+	case IOCTL_EFUSE_SET_LOCK:
+		/*parse lock data...*/
+		data = efuse_info.status.aes_ahb_lock;
+		data <<= 4;
+		data &= 0xf0;
+		efuse_info.status.efuse_apb_lock &= 0x0f;
+		data |= efuse_info.status.efuse_apb_lock;
+		efuse_write_key_byte(&s_efuse_obj, 63, (u8)data);
+		break;
+	case IOCTL_EFUSE_SET_MAP_PARA_4_TO_1:
+		/*
+		check data correction. efuse entry must be %4 ==0
+		array key no from 0 to 8.
+		*/
+		if (efuse_info.map_para.map_size > MAX_EFUSE_MAP_SIZE) {
+			printk("error map size:0x%x..\n", efuse_info.map_para.map_size);
+			return -EFAULT;
+		}
+		for (i = 0; i < efuse_info.map_para.map_size; i++) {
+			if ((efuse_info.map_para.map[i].efuse_entry % 4 != 0)
+					|| (efuse_info.map_para.map[i].aes_key_no != i)) {
+				printk("map[%d]:entry[0x%x]:aes key[0x%x] para error..\n", i,
+						efuse_info.map_para.map[i].efuse_entry,
+						efuse_info.map_para.map[i].aes_key_no);
+				return -EFAULT;
+			}
+		}
+		/*cpy usr data to driver pri data...*/
+		memcpy(&s_efuse_obj.map_para,
+				&efuse_info.map_para, sizeof(efuse_info.map_para));
+		s_efuse_obj.map_para.open_flag = OPEN_4_ENTRY_TO_1_KEY;
+		break;
+	case IOCTL_EFUSE_SET_MAP_PARA_1_TO_1:
+		printk("not support this func now..\n");
+		break;
+	case IOCTL_EFUSE_CLR_MAP_PARA:
+		s_efuse_obj.map_para.open_flag = 0;
+		break;
+	default:
+		break;
+	}
+/*
+	printk(
+			"app after raw info is: entry: %x,,key size: %x,
+			trans_key_start: %x, no is : %x, src_key_add:%x\n",
+			efuse_info.efuse_entry_no,
+			efuse_info.key_size,
+			efuse_info.trans_key_start_no,
+			efuse_info.trans_key_size,
+			(u32)efuse_info.key_buff);
+*/
+
+	memcpy((void *)&s_efuse_obj.status, (void *)&efuse_info.status,
+			sizeof(struct efuse_status));
+
+	if (copy_to_user((void __user *) (&((EFUSE_INFO *)arg)->status),
+			(void *) &efuse_info.status, sizeof(struct efuse_status))) {
+			return -EFAULT;
+	}
+/*
+	copy_from_user((void *) &t_efuse_info, (void __user*) arg,
+				sizeof(EFUSE_INFO));
+
+	printk(
+			"########raw info is: entry: %x,,key size: %x,
+			trans_key_start: %x, no is : %x, src_key_add:%x,
+			pro_data0:%x,pro_data1:%x\n",
+			t_efuse_info.efuse_entry_no,
+			t_efuse_info.key_size,
+			t_efuse_info.trans_key_start_no,
+			t_efuse_info.trans_key_size,
+			(u32)t_efuse_info.key_buff,
+			t_efuse_info.status.protect_bits[0],
+			t_efuse_info.status.protect_bits[1]);
+*/
+	return 0;
+}
+/*****************************************************************************
+ *
+ *
+ *		function body
+ *
+ *
+ *****************************************************************************/
+static int __devinit fh_efuse_probe(struct platform_device *pdev)
+{
+	int err;
+	struct resource *res;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "efuse get platform source error..\n");
+		return -ENODEV;
+	}
+
+	res = request_mem_region(res->start, resource_size(res), pdev->name);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "efuse region already claimed\n");
+		return -EBUSY;
+	}
+
+	s_efuse_obj.regs = ioremap(res->start, resource_size(res));
+	if (s_efuse_obj.regs == NULL) {
+		err = -ENXIO;
+		goto fail_no_ioremap;
+	}
+
+	err = misc_register(&fh_efuse_misc);
+
+	if (err != 0) {
+		dev_err(&pdev->dev, "efuse register misc error\n");
+		return err;
+	}
+
+	platform_set_drvdata(pdev, &fh_efuse_misc);
+
+	return 0;
+
+fail_no_ioremap:
+	release_mem_region(res->start, resource_size(res));
+
+	return err;
+}
+
+static int __exit fh_efuse_remove(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct miscdevice *misc;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	misc = (struct miscdevice *)platform_get_drvdata(pdev);
+	misc_deregister(misc);
+	iounmap(s_efuse_obj.regs);
+	release_mem_region(res->start, resource_size(res));
+
+	return 0;
+}
+
+/*******************
+ *
+ *
+ * add platform cause of i need the board info...
+ * in the probe function. i will register the sadc misc drive...
+ * then the app can open the sadc misc device..
+ *
+ ******************/
+static struct platform_driver fh_efuse_driver = {
+	.driver	= {
+		.name	= FH_EFUSE_PLAT_DEVICE_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe = fh_efuse_probe,
+	.remove = __exit_p(fh_efuse_remove),
+};
+/*
+EXPORT_SYMBOL(auto_check_efuse_pro_bits);
+EXPORT_SYMBOL(efuse_write_key_byte);
+EXPORT_SYMBOL(efuse_load_usrcmd);
+EXPORT_SYMBOL(efuse_get_lock_status);
+EXPORT_SYMBOL(efuse_trans_key);
+
+EXPORT_SYMBOL(efuse_write_key_byte);
+EXPORT_SYMBOL(efuse_write_key_byte);
+EXPORT_SYMBOL(efuse_write_key_byte);
+EXPORT_SYMBOL(efuse_write_key_byte);
+*/
+
+static int __init fh_efuse_init(void)
+{
+	return platform_driver_register(&fh_efuse_driver);
+}
+
+static void __exit fh_efuse_exit(void)
+{
+	platform_driver_unregister(&fh_efuse_driver);
+}
+
+module_init(fh_efuse_init);
+module_exit(fh_efuse_exit);
+
+MODULE_DESCRIPTION("fh efuse driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("zhangy@fullhan.com");
+MODULE_ALIAS("platform:FH_efuse");
diff -uraN linux-3.0.8/drivers/misc/fh_efuse.h linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_efuse.h
--- linux-3.0.8/drivers/misc/fh_efuse.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_efuse.h	2021-07-13 23:40:34.790363216 +0300
@@ -0,0 +1,111 @@
+/*
+ * fh_efuse.h
+ *
+ *  Created on: Aug 9, 2016
+ *      Author: duobao
+ */
+
+#ifndef FH_EFUSE_H_
+#define FH_EFUSE_H_
+
+#include <linux/io.h>
+#include <linux/scatterlist.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/scatterlist.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include <linux/bug.h>
+#include <linux/completion.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+
+/****************************************************************************
+ * #define section
+ *	add constant #define here if any
+ ***************************************************************************/
+/*#define FH_EFUSE_PROC_FILE    "driver/efuse"*/
+#define MAX_EFUSE_MAP_SIZE		8
+
+#define IOCTL_EFUSE_CHECK_PRO						0
+#define IOCTL_EFUSE_WRITE_KEY						1
+#define IOCTL_EFUSE_CHECK_LOCK						2
+#define IOCTL_EFUSE_TRANS_KEY						3
+#define IOCTL_EFUSE_SWITCH_CPU_KEY_MODE				4
+#define IOCTL_EFUSE_SWITCH_EFUSE_KEY_MODE			5
+#define IOCTL_EFUSE_CHECK_ERROR						6
+#define IOCTL_EFUSE_READ_KEY						7
+#define IOCTL_EFUSE_SET_LOCK						8
+#define IOCTL_EFUSE_SET_MAP_PARA_4_TO_1					9
+#define IOCTL_EFUSE_SET_MAP_PARA_1_TO_1					10
+#define IOCTL_EFUSE_CLR_MAP_PARA					11
+
+#define OPEN_4_ENTRY_TO_1_KEY			0x55
+#define OPEN_1_ENTRY_TO_1_KEY			0xaa
+/****************************************************************************
+ * ADT section
+ *	add Abstract Data Type definition here
+ ***************************************************************************/
+
+struct efuse_status {
+	/*bit 1 means could write..0 not write*/
+	u32 protect_bits[2];
+	/*bit 1 means cpu couldn't read efuse entry data...*/
+	u32 efuse_apb_lock;
+	u32 aes_ahb_lock;
+	u32 error;
+};
+
+/*add efuse_aes_map struct*/
+struct efuse_aes_map {
+	u32 aes_key_no;
+	u32 efuse_entry;
+};
+
+struct efuse_aes_map_para {
+	u32 open_flag;
+	u32 map_size;
+	struct efuse_aes_map map[MAX_EFUSE_MAP_SIZE];
+};
+
+typedef struct {
+	u32 efuse_entry_no; /*from 0 ~ 31*/
+	u8 *key_buff;
+	u32 key_size;
+	u32 trans_key_start_no; /*from 0 ~ 7*/
+	u32 trans_key_size; /*max 8*/
+	struct efuse_aes_map_para map_para;
+	struct efuse_status status;
+} EFUSE_INFO;
+
+struct wrap_efuse_obj {
+	void *regs;
+	/*write key*/
+	u32 efuse_entry_no; /*from 0 ~ 31*/
+	u8 *key_buff;
+	u32 key_size;
+	/*trans key*/
+	u32 trans_key_start_no; /*from 0 ~ 7*/
+	u32 trans_key_size; /*max 8*/
+	struct efuse_aes_map_para map_para;
+	/*status*/
+	struct efuse_status status;
+
+#define USE_CPU_SET_KEY				0
+#define USE_EFUSE_SET_KEY			1
+	u32 open_flag;
+};
+/****************************************************************************
+ *  extern variable declaration section
+ ***************************************************************************/
+
+/****************************************************************************
+ *  section
+ *	add function prototype here if any
+ ***************************************************************************/
+void efuse_trans_key(struct wrap_efuse_obj *obj, u32 start_no, u32 size);
+#endif /* FH_EFUSE_H_ */
diff -uraN linux-3.0.8/drivers/misc/fh_fw_loader.c linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_fw_loader.c
--- linux-3.0.8/drivers/misc/fh_fw_loader.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_fw_loader.c	2021-07-13 23:40:34.782363168 +0300
@@ -0,0 +1,259 @@
+/*
+ * fw_loader.c
+ *
+ *  Created on: Aug 9, 2016
+ *      Author: duobao
+ */
+
+#include <linux/io.h>
+#include <linux/miscdevice.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/printk.h>
+#include <linux/module.h>
+#include <linux/firmware.h>
+#include <linux/slab.h>
+#include <mach/fh8830.h>
+#include <mach/pmu.h>
+#include <asm/delay.h>
+#include <asm/uaccess.h>
+
+#define DEVICE_NAME   "fw_loader"
+
+struct fwl_parameter
+{
+    unsigned int addr;
+    unsigned int size;
+};
+
+struct fwl_description
+{
+    char* name;
+    void *virt_addr;
+    unsigned int phy_addr;
+    const struct firmware *fw_entry;
+    struct fwl_parameter fwl_param;
+};
+
+//#define  FW_LOADER_DEBUG
+#ifdef FW_LOADER_DEBUG
+#define PRINT_DBG(fmt,args...)  printk(fmt,##args)
+#else
+#define PRINT_DBG(fmt,args...)  do{} while(0)
+#endif
+
+
+#define FWL_LOADER_IOCTL_MAGIC             'f'
+
+#define FWL_LOAD_FW          _IOWR(FWL_LOADER_IOCTL_MAGIC, 0, unsigned int)
+#define FWL_SET_PARAM        _IOWR(FWL_LOADER_IOCTL_MAGIC, 1, struct fwl_parameter)
+#define FWL_START_FW         _IOWR(FWL_LOADER_IOCTL_MAGIC, 2, unsigned int)
+
+#define FWL_LOADER_IOCTL_MAXNR             8
+
+
+/* Module parameters */
+#define FIRMWARE_NAME   "rtthread_arc.bin"
+static char* fw_name = FIRMWARE_NAME;
+module_param(fw_name, charp, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(fw_name, "firmware name");
+
+#define FIRMWARE_PHY_ADDRESS   0xa7800000
+static unsigned int fw_phy_addr = FIRMWARE_PHY_ADDRESS;
+module_param(fw_phy_addr, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(fw_phy_addr, "firmware address");
+
+static struct miscdevice fwl_loader_device;
+static struct fwl_description *fwl_desc;
+
+static int fwl_load_firmware(void)
+{
+    int ret = 0;
+
+    if(fwl_desc->fw_entry)
+        fwl_desc->virt_addr = ioremap(fwl_desc->phy_addr, fwl_desc->fw_entry->size);
+    else
+        pr_err("ERROR: SET_FW_ADDRESS, fw_entry is NULL\n");
+
+    if(!fwl_desc->virt_addr)
+        pr_err("ERROR: SET_FW_ADDRESS, ioremap failed\n");
+
+    memcpy(fwl_desc->virt_addr, fwl_desc->fw_entry->data, fwl_desc->fw_entry->size);
+
+    writel(fwl_desc->fwl_param.addr, fwl_desc->virt_addr + fwl_desc->fw_entry->size - 8);
+    writel(fwl_desc->fwl_param.size, fwl_desc->virt_addr + fwl_desc->fw_entry->size - 4);
+
+
+    iounmap(fwl_desc->virt_addr);
+    fwl_desc->virt_addr = NULL;
+
+    printk("firmware: %s loaded\n", fwl_desc->name);
+
+    return ret;
+}
+
+static int fwl_start_firmware(void)
+{
+    unsigned int arc_addr;
+    unsigned int reg;
+
+    arc_addr = ((fwl_desc->phy_addr & 0xffff) << 16) | (fwl_desc->phy_addr >> 16);
+
+    // ARC Reset
+    fh_pmu_set_reg(REG_PMU_SWRSTN_NSR, 0xFFBFFFFF);
+
+    fh_pmu_set_reg(REG_PMU_A625BOOT0 , 0x7940266B);
+    fh_pmu_set_reg(REG_PMU_A625BOOT1 , arc_addr);  // Configure ARC Bootcode start address
+    fh_pmu_set_reg(REG_PMU_A625BOOT2 , 0x0F802020);
+    fh_pmu_set_reg(REG_PMU_A625BOOT3 , arc_addr);
+
+    fh_pmu_set_reg(REG_PMU_REMAP , 0 );  // Disable A2X BUS Remap and Resize
+
+    // ARC reset released
+    fh_pmu_set_reg( REG_PMU_SWRSTN_NSR, 0xFFFFFFFF);
+
+    // wait ramloader done, about 1024 ARC CPU cycle
+    udelay(100);
+
+    // start ARC625
+    reg = fh_pmu_get_reg(REG_PMU_A625_START_CTRL);
+    reg &= ~(0xff);
+    reg |= 0x10;
+    fh_pmu_set_reg(REG_PMU_A625_START_CTRL, reg);
+
+    printk("firmware: %s started\n", fwl_desc->name);
+
+    return 0;
+}
+
+
+static long fwl_loader_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    int ret = 0;
+
+    if (unlikely(_IOC_TYPE(cmd) != FWL_LOADER_IOCTL_MAGIC))
+    {
+        pr_err("%s: ERROR: incorrect magic num %d (error: %d)\n",
+               __func__, _IOC_TYPE(cmd), -ENOTTY);
+        return -ENOTTY;
+    }
+
+    if (unlikely(_IOC_NR(cmd) > FWL_LOADER_IOCTL_MAXNR))
+    {
+        pr_err("%s: ERROR: incorrect cmd num %d (error: %d)\n",
+               __func__, _IOC_NR(cmd), -ENOTTY);
+        return -ENOTTY;
+    }
+
+    if (_IOC_DIR(cmd) & _IOC_READ)
+    {
+        ret = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
+    }
+    else if(_IOC_DIR(cmd) & _IOC_WRITE)
+    {
+        ret = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
+    }
+
+    if(ret)
+    {
+        pr_err("%s: ERROR: user space access is not permitted %d (error: %d)\n",
+               __func__, _IOC_NR(cmd), -EACCES);
+        return -EACCES;
+    }
+
+    switch(cmd)
+    {
+    case FWL_SET_PARAM:
+        PRINT_DBG("%s, FWL_SET_PARAM start\n", __func__);
+        ret = __copy_from_user(&fwl_desc->fwl_param,
+                (struct fwl_parameter __user *)arg,
+                sizeof(struct fwl_parameter));
+        break;
+    case FWL_LOAD_FW:
+        PRINT_DBG("%s, FWL_LOAD_FW start\n", __func__);
+        __get_user(fwl_desc->phy_addr, (unsigned int __user *)arg);
+        fwl_load_firmware();
+        break;
+    case FWL_START_FW:
+        PRINT_DBG("%s, FWL_START_FW start\n", __func__);
+        fwl_start_firmware();
+        break;
+
+    }
+
+    return ret;
+}
+
+static int fwl_loader_open(struct inode *inode, struct file *file)
+{
+
+    int ret;
+    PRINT_DBG("%s, start\n", __func__);
+
+    ret = request_firmware(&fwl_desc->fw_entry, fwl_desc->name, fwl_loader_device.this_device);
+
+    if(ret)
+    {
+        pr_err("ERROR: %s, request firmware failed, ret: %d\n", __func__, ret);
+    }
+
+    return ret;
+}
+
+static int fwl_loader_release(struct inode *inode, struct file *filp)
+{
+    release_firmware(fwl_desc->fw_entry);
+    return 0;
+}
+
+static const struct file_operations fwl_loader_fops =
+{
+    .owner                  = THIS_MODULE,
+    .open                   = fwl_loader_open,
+    .release                = fwl_loader_release,
+    .unlocked_ioctl         = fwl_loader_ioctl,
+};
+
+static struct miscdevice fwl_loader_device =
+{
+    .minor = MISC_DYNAMIC_MINOR,
+    .name = DEVICE_NAME,
+    .fops = &fwl_loader_fops,
+};
+
+static int __init fwl_loader_init(void)
+{
+    int ret;
+
+    fwl_desc = (struct fwl_description *)kzalloc(sizeof(struct fwl_description), GFP_KERNEL);
+    fwl_desc->name = fw_name;
+    fwl_desc->phy_addr = fw_phy_addr;
+
+    ret = misc_register(&fwl_loader_device);
+
+    if(ret < 0)
+    {
+            pr_err("%s: ERROR: %s registration failed",
+                       __func__, DEVICE_NAME);
+            return -ENXIO;
+    }
+
+
+
+    return ret;
+}
+
+static void __exit fwl_loader_exit(void)
+{
+    misc_deregister(&fwl_loader_device);
+    kfree(fwl_desc);
+    fwl_desc = NULL;
+}
+module_init(fwl_loader_init);
+module_exit(fwl_loader_exit);
+
+MODULE_AUTHOR("QIN");
+MODULE_DESCRIPTION("Misc Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform: FH");
diff -uraN linux-3.0.8/drivers/misc/fh_i2s.c linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_i2s.c
--- linux-3.0.8/drivers/misc/fh_i2s.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_i2s.c	2021-07-13 23:40:34.762363045 +0300
@@ -0,0 +1,1346 @@
+/**@file
+ * @Copyright (c) 2016 Shanghai Fullhan Microelectronics Co., Ltd.
+ * @brief
+ *
+ * @author      fullhan
+ * @date        2016-7-15
+ * @version     V1.0
+ * @version     V1.1  modify code style
+ * @note: misc i2s driver for fh8830 embedded i2s codec.
+ * @note History:
+ * @note     <author>   <time>    <version >   <desc>
+ * @note
+ * @warning: the codec is fixed to 24 bit, so remember to move the 24 bit data to 16 bit in
+ *   application layer, the next version CPU will sovle this bug.
+ */
+
+
+#include <linux/irqreturn.h>
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/file.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/uaccess.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/poll.h>
+#include <linux/ioctl.h>
+#include <linux/i2c.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <mach/fh_dmac.h>
+#include <mach/fh_predefined.h>
+
+#include "fh_i2s.h"
+
+
+#define NR_DESCS_PER_CHANNEL 64
+
+#define FIX_SAMPLE_BIT       32
+
+#define I2S_HW_NUM_RX  0
+#define I2S_HW_NUM_TX  1
+#define I2S_DMA_CAP_CHANNEL 2
+#define I2S_DMA_PAY_CHANNEL 3
+
+#define I2S_CTRL 						0x0
+#define I2S_TXFIFO_CTRL 				0x4
+#define I2S_RXFIFO_CTRL 				0x8
+#define I2S_STATUS             			0x0c
+#define I2S_DAT_CTL				  		0x10
+#define I2S_DBG_CTL					  	0x14
+#define I2S_STATUS1					  	0x18
+#define I2S_STATUS2						0x1c
+
+#define I2S_DACL_FIFO 					0xf0a00100
+#define I2S_DACR_FIFO 					0xf0a00300
+#define I2S_ADC_FIFO					0xf0a00200
+
+#define I2S_DMA_PREALLOC_SIZE 128*1024
+
+#define I2S_INTR_RX_UNDERFLOW   0x10000
+#define I2S_INTR_RX_OVERFLOW    0x20000
+#define I2S_INTR_TX_UNDERFLOW   0x40000
+#define I2S_INTR_TX_OVERFLOW    0x80000
+
+#define I2S_EXT_EN             1<<12
+#define I2S_EN				   1<<0
+#define I2S_DACL_CHEN_EN       1<<30
+#define I2S_DACR_CHEN_EN       1<<31
+#define I2S_ADC_CHEN_EN        1<<29
+#define I2S_SHIFT_BIT          6
+#define I2S_DAC_FIFO_CLEAR     1<<4
+#define I2S_ADC_FIFO_CLEAR     1<<4
+#define I2S_ADC_FIFO_EN		   1<<0
+#define I2S_DAC_FIFO_EN        1<<0
+#define FH_i2s_DEBUG
+#ifdef FH_i2s_DEBUG
+#define PRINT_i2s_DBG(fmt, args...)     \
+    do                              \
+    {                               \
+        printk("FH_i2s_DEBUG: ");   \
+        printk(fmt, ## args);       \
+    }                               \
+    while(0)
+#else
+#define PRINT_i2s_DBG(fmt, args...)  do { } while (0)
+#endif
+
+enum i2s_type
+{
+    capture = 0,
+    playback,
+};
+
+
+enum i2s_state
+{
+    STATE_NORMAL = 0,
+    STATE_XRUN,
+    STATE_STOP,
+    STATE_RUN,
+    STATE_PAUSE
+};
+
+struct i2s_infor_record_t
+{
+	int record_pid;
+	int play_pid;
+}i2s_infor_record;
+
+
+struct fh_dma_chan
+{
+    struct dma_chan     *chan;
+    void __iomem        *ch_regs;
+    u8          mask;
+    u8          priority;
+    bool            paused;
+    bool                initialized;
+    spinlock_t      lock;
+    /* these other elements are all protected by lock */
+    unsigned long       flags;
+    dma_cookie_t        completed;
+    struct list_head    active_list;
+    struct list_head    queue;
+    struct list_head    free_list;
+    struct fh_cyclic_desc   *cdesc;
+    unsigned int        descs_allocated;
+};
+
+struct i2s_config {
+	int rate;
+	int volume;
+    int frame_bit;
+    int channels;
+    int buffer_size;
+    int period_size;
+    int buffer_bytes;
+    int period_bytes;
+    int start_threshold;
+    int stop_threshold;
+};
+
+struct i2s_ptr_t
+{
+	struct i2s_config cfg;
+    enum i2s_state state;
+    long size;
+    int hw_ptr;
+    int appl_ptr;
+    spinlock_t lock;
+    struct device dev;
+    u8 *area; /*virtual pointer*/
+    dma_addr_t addr; /*physical address*/
+    u8 * mmap_addr;
+};
+
+struct fh_i2s_cfg
+{
+    struct i2s_ptr_t capture;
+    struct i2s_ptr_t playback;
+    wait_queue_head_t readqueue;
+    wait_queue_head_t writequeue;
+	struct semaphore sem_capture;
+	struct semaphore sem_playback;
+};
+
+struct fh_i2s_dma_chan
+{
+    struct dma_chan     *chan;
+    void __iomem        *ch_regs;
+    u8          mask;
+    u8          priority;
+    bool            paused;
+    bool                initialized;
+    spinlock_t      lock;
+    /* these other elements are all protected by lock */
+    unsigned long       flags;
+    dma_cookie_t        completed;
+    struct list_head    active_list;
+    struct list_head    queue;
+    struct list_head    free_list;
+    struct dma_async_tx_descriptor   *cdesc;
+    unsigned int        descs_allocated;
+};
+
+struct fh_I2S_dma_transfer
+{
+    struct dma_chan *chan;
+    struct fh_dma_slave cfg;
+    struct scatterlist sgl;
+    struct fh_cyclic_desc *desc;
+};
+
+struct channel_assign
+{
+	int capture_channel;
+	int playback_channel;
+};
+
+struct i2s_dev
+{
+	struct channel_assign channel_assign;
+    struct fh_i2s_cfg i2s_config;
+    struct miscdevice fh_i2s_miscdev;
+};
+
+static const struct file_operations I2S_fops;
+
+static struct i2s_dev fh_i2s_dev =
+{
+    .channel_assign = {
+        .capture_channel = I2S_DMA_CAP_CHANNEL,
+        .playback_channel = I2S_DMA_PAY_CHANNEL,
+    },
+    .fh_i2s_miscdev = {
+        .fops       = &I2S_fops,
+        .name       = "fh_fh8830_i2s",
+        .minor      = MISC_DYNAMIC_MINOR,
+    }
+
+};
+
+static struct
+{
+    spinlock_t      lock;
+    void __iomem        *regs;
+    struct clk      *clk;
+    unsigned long       in_use;
+    unsigned long       next_heartbeat;
+    struct timer_list   timer;
+    int         irq;
+} fh_i2s_module;
+static struct fh_dma_chan *dma_rx_transfer = NULL;
+static struct fh_dma_chan *dma_tx_transfer = NULL;
+static struct work_struct playback_wq;
+
+static struct i2s_param_store
+{
+    int input_volume;
+} i2s_param_store;
+
+
+static void fh_I2S_tx_dma_done(void *arg);
+static void fh_I2S_rx_dma_done(void *arg);
+static bool  fh_I2S_dma_chan_filter(struct dma_chan *chan, void *filter_param);
+
+void fh_I2S_stop_playback(struct fh_i2s_cfg *i2s_config)
+{
+
+    if(i2s_config->playback.state == STATE_STOP)
+    {
+        return;
+    }
+    i2s_config->playback.state = STATE_STOP;
+    writel(0, fh_i2s_module.regs + I2S_TXFIFO_CTRL);//tx fifo disable
+    fh_dma_cyclic_stop(dma_tx_transfer->chan);
+    fh_dma_cyclic_free(dma_tx_transfer->chan);
+    up(&i2s_config->sem_playback);
+}
+
+void fh_I2S_stop_capture(struct fh_i2s_cfg *i2s_config)
+{
+
+    u32 rx_status;
+    if(i2s_config->capture.state == STATE_STOP)
+    {
+        return;
+    }
+    rx_status = readl( fh_i2s_module.regs + I2S_RXFIFO_CTRL);//clear rx fifo
+    rx_status =  rx_status|I2S_ADC_FIFO_CLEAR;
+    writel(rx_status,fh_i2s_module.regs + I2S_RXFIFO_CTRL);
+
+    i2s_config->capture.state = STATE_STOP;
+
+    writel(0, fh_i2s_module.regs + I2S_RXFIFO_CTRL);//rx fifo disable
+
+    fh_dma_cyclic_stop(dma_rx_transfer->chan);
+    fh_dma_cyclic_free(dma_rx_transfer->chan);
+    up(&i2s_config->sem_capture);
+}
+
+
+int fh_i2s_get_factor_from_table(int rate)
+{
+	return 0;
+}
+
+void fh_switch_input_volume(int volume)
+{
+
+}
+
+void init_i2s(enum i2s_type type,struct fh_i2s_cfg  *i2s_config)
+{
+
+}
+
+static inline long bytes_to_frames(int frame_bit, int bytes)
+{
+    return bytes * 8 /frame_bit;
+}
+
+static inline long  fh_i2s_frames_to_bytes(int frame_bit, int frames)
+{
+    return frames * frame_bit / 8;
+}
+
+int i2s_avail_data_len(enum i2s_type type,struct fh_i2s_cfg *stream)
+{
+    int delta;
+    if (capture == type)
+    {
+        spin_lock(&stream->capture.lock);
+        delta = stream->capture.hw_ptr - stream->capture.appl_ptr;
+        spin_unlock(&stream->capture.lock);
+        if (delta < 0)
+        {
+            delta += stream->capture.size;
+        }
+        return delta;
+    }
+    else
+    {
+        spin_lock(&stream->playback.lock);
+        delta = stream->playback.appl_ptr - stream->playback.hw_ptr;
+        spin_unlock(&stream->playback.lock);
+        if (delta < 0)
+        {
+            delta += stream->playback.size;
+        }
+        return stream->playback.size - delta;
+    }
+}
+
+static int fh_i2s_close(struct inode *ip, struct file *fp)
+{
+	struct miscdevice *miscdev = fp->private_data;
+	struct i2s_dev	*dev = container_of(miscdev, struct i2s_dev, fh_i2s_miscdev);
+	struct fh_i2s_cfg *i2s_config = &dev->i2s_config;
+	int pid;
+
+	pid= current->tgid;
+
+	if( i2s_infor_record.play_pid == pid)
+	{
+		fh_I2S_stop_playback(i2s_config);
+
+	}
+	if (i2s_infor_record.record_pid==pid)
+	{
+		fh_I2S_stop_capture(i2s_config);
+	}
+	return 0;
+}
+
+int fh_i2s_register_tx_dma(struct fh_i2s_cfg  *i2s_config)
+{
+    int ret;
+    unsigned int reg;
+    struct fh_dma_slave *tx_slave;
+    tx_slave =  kzalloc(sizeof(struct fh_dma_slave), GFP_KERNEL);
+    if (!tx_slave)
+    {
+        return -ENOMEM;
+    }
+    tx_slave->cfg_hi = FHC_CFGH_DST_PER(I2S_HW_NUM_TX);
+    tx_slave->dst_msize = FH_DMA_MSIZE_8;
+    tx_slave->src_msize = FH_DMA_MSIZE_8;
+    tx_slave->reg_width = FH_DMA_SLAVE_WIDTH_32BIT;
+    tx_slave->fc = FH_DMA_FC_D_M2P;
+    tx_slave->tx_reg = I2S_DACL_FIFO;
+    dma_tx_transfer->chan->private =  tx_slave;
+
+    if ((i2s_config->playback.cfg.buffer_bytes < i2s_config->playback.cfg.period_bytes) ||
+        (i2s_config->playback.cfg.buffer_bytes <= 0) || (i2s_config->playback.cfg.period_bytes <= 0) ||
+        (i2s_config->playback.cfg.buffer_bytes/i2s_config->playback.cfg.period_bytes > NR_DESCS_PER_CHANNEL))
+    {
+        printk(KERN_ERR "buffer_size and period_size are invalid\n");
+        ret = -EINVAL;
+        goto fail;
+    }
+
+    dma_tx_transfer->cdesc =
+    	    fh_dma_cyclic_prep(dma_tx_transfer->chan,i2s_config->playback.addr,
+    	    		i2s_config->playback.cfg.buffer_bytes,i2s_config->playback.cfg.period_bytes, DMA_MEM_TO_DEV);
+    if(dma_tx_transfer->cdesc <= 0)
+    {
+        printk(KERN_ERR "cyclic desc err\n");
+        ret = -ENOMEM;
+        goto fail;
+    }
+    dma_tx_transfer->cdesc->period_callback = fh_I2S_tx_dma_done;
+    dma_tx_transfer->cdesc->period_callback_param = i2s_config;
+    fh_dma_cyclic_start(dma_tx_transfer->chan);
+    if (tx_slave)
+    {
+        kfree(tx_slave);
+    }
+
+    reg = readl(fh_i2s_module.regs + I2S_CTRL);
+    reg = reg <<I2S_SHIFT_BIT;
+    reg |= I2S_DACL_CHEN_EN;
+	writel(reg,fh_i2s_module.regs + I2S_CTRL);// enable left tx fifo
+
+	writel(0x1<<4,fh_i2s_module.regs +  I2S_TXFIFO_CTRL);// clear tx fifo
+	writel(0x20027,fh_i2s_module.regs + I2S_TXFIFO_CTRL);// enbale tx fifo
+
+    /*must set NULL to tell DMA driver that we free the DMA slave*/
+    dma_tx_transfer->chan->private = NULL;
+
+    return 0;
+fail:
+    return ret;
+}
+
+int fh_i2s_register_rx_dma( struct fh_i2s_cfg  *i2s_config)
+{
+    int ret;
+    unsigned int reg;
+    struct fh_dma_slave *rx_slave;
+    rx_slave =  kzalloc(sizeof(struct fh_dma_slave), GFP_KERNEL);
+    if (!rx_slave)
+    {
+        return -ENOMEM;
+    }
+
+    rx_slave->cfg_hi = FHC_CFGH_SRC_PER(I2S_HW_NUM_RX);
+    rx_slave->dst_msize = FH_DMA_MSIZE_8;
+    rx_slave->src_msize = FH_DMA_MSIZE_8;
+    rx_slave->reg_width = FH_DMA_SLAVE_WIDTH_32BIT;
+    rx_slave->fc = FH_DMA_FC_D_P2M;
+    rx_slave->rx_reg = I2S_ADC_FIFO;
+	dma_rx_transfer->chan->private =  rx_slave;
+
+    if ((i2s_config->capture.cfg.buffer_bytes < i2s_config->capture.cfg.period_bytes) ||
+        (i2s_config->capture.cfg.buffer_bytes <= 0) ||(i2s_config->capture.cfg.period_bytes <= 0) ||
+        (i2s_config->capture.cfg.buffer_bytes/i2s_config->capture.cfg.period_bytes > NR_DESCS_PER_CHANNEL))
+    {
+        printk(KERN_ERR "buffer_size and period_size are invalid\n");
+        ret = -EINVAL;
+        goto fail;
+    }
+
+    dma_rx_transfer->cdesc=
+    fh_dma_cyclic_prep(dma_rx_transfer->chan,i2s_config->capture.addr,
+    		i2s_config->capture.cfg.buffer_bytes,i2s_config->capture.cfg.period_bytes, DMA_DEV_TO_MEM);
+    if(dma_rx_transfer->cdesc <= 0)
+    {
+        printk(KERN_ERR" cyclic desc err\n");
+        ret = -ENOMEM;
+        goto fail;
+    }
+
+    dma_rx_transfer->cdesc->period_callback = fh_I2S_rx_dma_done;
+    dma_rx_transfer->cdesc->period_callback_param = i2s_config;
+    fh_dma_cyclic_start(dma_rx_transfer->chan);
+
+    reg = readl(fh_i2s_module.regs + I2S_CTRL);
+    reg = reg<<I2S_SHIFT_BIT;
+    reg |= I2S_ADC_CHEN_EN ;
+  	writel(reg,fh_i2s_module.regs + I2S_CTRL);//enbale dac fifo
+	writel(0x1<<4,fh_i2s_module.regs + I2S_RXFIFO_CTRL);// clear rx fifo
+	writel(0x20027,fh_i2s_module.regs + I2S_RXFIFO_CTRL);// enable rx fifo
+
+
+    if (rx_slave)
+    {
+        kfree(rx_slave);
+    }
+    /*must set NULL to tell DMA driver that we free the DMA slave*/
+    dma_rx_transfer->chan->private = NULL;
+    return 0;
+fail:
+    kfree(rx_slave);
+    return ret;
+}
+
+
+void fh_i2s_playback_start_wq_handler(struct work_struct *work)
+{
+    int avail;
+    while(1)
+    {
+        if (STATE_STOP == fh_i2s_dev.i2s_config.playback.state)
+        {
+            return;
+        }
+        avail = i2s_avail_data_len(playback, &fh_i2s_dev.i2s_config);
+        if (avail > fh_i2s_dev.i2s_config.playback.cfg.period_bytes)
+        {
+            msleep(0);
+        }
+        else
+        {
+            break;
+        }
+
+    }
+}
+
+int fh_I2S_start_playback(struct fh_i2s_cfg *i2s_config)
+{
+    int ret;
+
+    if(i2s_config->playback.state == STATE_RUN)
+    {
+        return 0;
+    }
+	if (i2s_config->playback.cfg.buffer_bytes >= I2S_DMA_PREALLOC_SIZE)
+    {
+        printk("DMA prealloc buffer is smaller than  i2s_config->buffer_bytes\n");
+        return -ENOMEM;
+    }
+    memset(i2s_config->playback.area, 0x0, i2s_config->playback.cfg.buffer_bytes);
+    i2s_config->playback.size = i2s_config->playback.cfg.buffer_bytes;
+    i2s_config->playback.state = STATE_RUN;
+    ret = fh_i2s_register_tx_dma(i2s_config);
+    if (ret < 0)
+    {
+        return ret;
+    }
+    INIT_WORK(&playback_wq, fh_i2s_playback_start_wq_handler);
+    schedule_work(&playback_wq);
+
+    return 0;
+}
+
+int fh_I2S_start_capture(struct fh_i2s_cfg *i2s_config)
+{
+    if(i2s_config->capture.state == STATE_RUN)
+    {
+        return 0;
+    }
+
+    if (i2s_config->capture.cfg.buffer_bytes >= I2S_DMA_PREALLOC_SIZE)
+    {
+        printk("DMA prealloc buffer is smaller than  i2s_config->buffer_bytes\n");
+        return -ENOMEM;
+    }
+    memset(i2s_config->capture.area, 0, i2s_config->capture.cfg.buffer_bytes);
+    i2s_config->capture.size = i2s_config->capture.cfg.buffer_bytes;
+
+    i2s_config->capture.state = STATE_RUN;
+    return fh_i2s_register_rx_dma(i2s_config);
+}
+
+
+static void fh_I2S_rx_dma_done(void *arg)
+{
+    struct fh_i2s_cfg *i2s_config;
+    i2s_config = ( struct fh_i2s_cfg *)arg;
+    spin_lock(&i2s_config->capture.lock);
+    i2s_config->capture.hw_ptr += i2s_config->capture.cfg.period_bytes;
+    if (i2s_config->capture.hw_ptr > i2s_config->capture.size )
+    {
+        i2s_config->capture.hw_ptr = i2s_config->capture.hw_ptr - i2s_config->capture.size;
+    }
+    spin_unlock(&i2s_config->capture.lock);
+    if (waitqueue_active(&i2s_config->readqueue))
+    {
+        int avail = i2s_avail_data_len(capture,i2s_config);
+        if (avail > i2s_config->capture.cfg.period_bytes)
+        {
+            wake_up_interruptible(&i2s_config->readqueue);
+        }
+    }
+
+}
+
+
+static void fh_I2S_tx_dma_done(void *arg)
+{
+
+	struct fh_i2s_cfg *i2s_config;
+    i2s_config = ( struct fh_i2s_cfg *)arg;
+	spin_lock(&i2s_config->playback.lock);
+    i2s_config->playback.hw_ptr +=  i2s_config->playback.cfg.period_bytes;
+    if (i2s_config->playback.hw_ptr > i2s_config->playback.size )
+    {
+        i2s_config->playback.hw_ptr = i2s_config->playback.hw_ptr - i2s_config->playback.size;
+    }
+    spin_unlock(&i2s_config->playback.lock);
+    if (waitqueue_active(&i2s_config->writequeue))
+    {
+        int avail = i2s_avail_data_len(playback,i2s_config);
+        if (avail > i2s_config->playback.cfg.period_bytes)
+        {
+            wake_up_interruptible(&i2s_config->writequeue);
+        }
+    }
+}
+
+bool  fh_I2S_dma_chan_filter(struct dma_chan *chan, void *filter_param)
+{
+    int dma_channel = *(int *)filter_param;
+    bool ret = false;
+
+    if (chan->chan_id == dma_channel)
+    {
+        ret = true;
+    }
+    return ret;
+}
+
+int fh_i2s_arg_config_support(struct fh_i2s_cfg_arg * cfg)
+{
+    return 0;
+}
+
+void fh_i2s_reset_dma_buff(enum i2s_type type, struct fh_i2s_cfg *i2s_config)
+{
+    if (capture == type)
+    {
+        i2s_config->capture.appl_ptr = 0;
+        i2s_config->capture.hw_ptr = 0;
+    }
+    else
+    {
+        i2s_config->playback.appl_ptr = 0;
+        i2s_config->playback.hw_ptr = 0;
+    }
+}
+
+static long fh_i2s_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    struct fh_i2s_cfg_arg cfg;
+    struct miscdevice *miscdev = filp->private_data;
+    struct i2s_dev  *dev = container_of(miscdev, struct i2s_dev, fh_i2s_miscdev);
+    struct fh_i2s_cfg  *i2s_config = &dev->i2s_config;
+    int pid;
+    int rx_status;
+    int tx_status;
+
+    pid = current->tgid;
+    switch (cmd)
+    {
+        case I2S_INIT_CAPTURE_MEM:
+
+            if (copy_from_user((void *)&cfg, (void __user *)arg, sizeof(struct fh_i2s_cfg_arg)))
+            {
+                printk(KERN_ERR "copy err\n");
+                return -EIO;
+            }
+            if (0 == fh_i2s_arg_config_support(&cfg))
+            {
+            	if (down_trylock(&i2s_config->sem_capture))
+	            {
+	            	printk(KERN_ERR "another thread is running capture.\n");
+	                return -EBUSY;
+	            }
+               	i2s_infor_record.record_pid =  pid;
+                i2s_config->capture.cfg.volume = cfg.volume;
+                i2s_config->capture.cfg.rate = cfg.rate;
+                i2s_config->capture.cfg.channels = cfg.channels;
+                i2s_config->capture.cfg.buffer_size = cfg.buffer_size;
+                i2s_config->capture.cfg.frame_bit = FIX_SAMPLE_BIT;
+                i2s_config->capture.cfg.period_size = cfg.period_size;
+                i2s_config->capture.cfg.buffer_bytes = fh_i2s_frames_to_bytes(i2s_config->capture.cfg.frame_bit,i2s_config->capture.cfg.buffer_size);
+                i2s_config->capture.cfg.period_bytes = fh_i2s_frames_to_bytes(i2s_config->capture.cfg.frame_bit,i2s_config->capture.cfg.period_size);
+                i2s_config->capture.cfg.start_threshold =i2s_config->capture.cfg.buffer_bytes;
+                i2s_config->capture.cfg.stop_threshold = i2s_config->capture.cfg.buffer_bytes;
+                fh_i2s_reset_dma_buff(capture, i2s_config);
+                init_waitqueue_head(&i2s_config->readqueue);
+                spin_lock_init(&i2s_config->capture.lock);
+                init_i2s(capture, i2s_config);
+                i2s_param_store.input_volume = i2s_config->capture.cfg.volume;
+                /* *  config sample  *  */
+
+            }
+            else
+            {
+                return -EINVAL;
+            }
+
+            break;
+        case I2S_INIT_PLAYBACK_MEM:
+            if (copy_from_user((void *)&cfg, (void __user *)arg, sizeof(struct fh_i2s_cfg_arg)))
+            {
+                printk(KERN_ERR "copy err\n");
+                return -EIO;
+            }
+            
+            if (0 == fh_i2s_arg_config_support(&cfg))
+            {
+            	if (down_trylock(&i2s_config->sem_playback))
+	            {
+	            	printk(KERN_ERR "another thread is running playback.\n");
+	                return -EBUSY;
+	            }
+            	i2s_infor_record.play_pid = pid;
+                i2s_config->playback.cfg.volume = cfg.volume;
+                i2s_config->playback.cfg.rate = cfg.rate;
+                i2s_config->playback.cfg.channels = cfg.channels;
+                i2s_config->playback.cfg.buffer_size = cfg.buffer_size;
+                i2s_config->playback.cfg.frame_bit = FIX_SAMPLE_BIT;
+                i2s_config->playback.cfg.period_size = cfg.period_size;
+                i2s_config->playback.cfg.buffer_bytes = fh_i2s_frames_to_bytes(i2s_config->playback.cfg.frame_bit,i2s_config->playback.cfg.buffer_size);
+                i2s_config->playback.cfg.period_bytes = fh_i2s_frames_to_bytes(i2s_config->playback.cfg.frame_bit,i2s_config->playback.cfg.period_size);
+                i2s_config->playback.cfg.start_threshold =i2s_config->playback.cfg.buffer_bytes;
+                i2s_config->playback.cfg.stop_threshold = i2s_config->playback.cfg.buffer_bytes;
+                fh_i2s_reset_dma_buff(playback, i2s_config);
+                init_waitqueue_head(&i2s_config->writequeue);
+                spin_lock_init(&i2s_config->playback.lock);
+                init_i2s(playback, i2s_config);
+
+            }
+            else
+            {
+                return -EINVAL;
+            }
+            break;
+        case I2S_AI_EN:
+            if (i2s_infor_record.record_pid != pid){
+            	return -EBUSY;
+            }
+            return fh_I2S_start_capture(i2s_config);
+        case I2S_AO_EN:
+			if (i2s_infor_record.play_pid != pid) {
+				return -EBUSY;
+			}
+			return fh_I2S_start_playback(i2s_config);
+
+        case I2S_AI_DISABLE:
+            printk("[ac_driver]AC_AI_DISABLE\n");
+			if (i2s_infor_record.record_pid != pid) {
+				return -EBUSY;
+			}
+			fh_I2S_stop_capture(i2s_config);
+            printk(" AC_AI_DISABLE\n");
+            break;
+        case I2S_AO_DISABLE:
+            printk("[ac_driver]AC_AO_DISABLE\n");
+			if (i2s_infor_record.play_pid != pid) {
+				return -EBUSY;
+			}
+            fh_I2S_stop_playback(i2s_config);
+            printk(" AC_AO_DISABLE\n");
+            break;
+        case I2S_AI_PAUSE:
+			if (i2s_infor_record.record_pid != pid) {
+				return -EBUSY;
+			}
+            printk(KERN_INFO "capture pause\n");
+            i2s_config->capture.state = STATE_PAUSE;
+            rx_status = readl(fh_i2s_module.regs + I2S_RXFIFO_CTRL);/*rx fifo disable*/
+            rx_status =  rx_status&(~I2S_ADC_FIFO_EN);
+            writel(rx_status, fh_i2s_module.regs + I2S_RXFIFO_CTRL);/*rx fifo disable*/
+            break;
+        case I2S_AI_RESUME:
+			if (i2s_infor_record.record_pid != pid) {
+				return -EBUSY;
+			}
+            printk(KERN_INFO "capture resume\n");
+            i2s_config->capture.state = STATE_RUN;
+            rx_status = readl( fh_i2s_module.regs + I2S_RXFIFO_CTRL);//clear rx fifo
+            rx_status =  rx_status|I2S_ADC_FIFO_CLEAR;
+            writel(rx_status,fh_i2s_module.regs + I2S_RXFIFO_CTRL);/*enable rx fifo*/
+            rx_status =  rx_status&(~I2S_ADC_FIFO_CLEAR);
+            rx_status =  rx_status|I2S_ADC_FIFO_EN;
+            writel(rx_status,fh_i2s_module.regs + I2S_RXFIFO_CTRL);/*enable rx fifo*/
+            break;
+        case I2S_AO_PAUSE:
+			if (i2s_infor_record.play_pid != pid) {
+				return -EBUSY;
+			}
+            i2s_config->playback.state = STATE_PAUSE;
+            printk(KERN_INFO "playback pause\n");
+            tx_status = readl(fh_i2s_module.regs + I2S_TXFIFO_CTRL);/*rx fifo disable*/
+            tx_status =  tx_status&(~I2S_DAC_FIFO_EN);
+            writel(tx_status, fh_i2s_module.regs + I2S_TXFIFO_CTRL);/*tx fifo disable*/
+            break;
+        case I2S_AO_RESUME:
+			if (i2s_infor_record.play_pid != pid) {
+				return -EBUSY;
+			}
+            printk(KERN_INFO "playback resume\n");
+            i2s_config->playback.state = STATE_RUN;
+            tx_status = readl( fh_i2s_module.regs + I2S_TXFIFO_CTRL);//clear rx fifo
+            tx_status =  tx_status|I2S_DAC_FIFO_EN;
+            writel(tx_status,fh_i2s_module.regs + I2S_TXFIFO_CTRL); //enable tx fifo read enable
+            break;
+        default:
+            return -ENOTTY;
+    }
+    return 0;
+}
+
+static int fh_i2s_open(struct inode *ip, struct file *fp)
+{
+
+    fp->private_data = &fh_i2s_dev.fh_i2s_miscdev;
+
+    return 0;
+}
+
+static u32 fh_i2s_poll(struct file *filp, poll_table *wait)
+{
+    struct miscdevice *miscdev = filp->private_data;
+    struct i2s_dev  *dev = container_of(miscdev, struct i2s_dev, fh_i2s_miscdev);
+    struct fh_i2s_cfg  *i2s_config = &dev->i2s_config;
+    u32 mask = 0;
+    long avail;
+    if (STATE_RUN == i2s_config->capture.state)
+    {
+        poll_wait(filp,&i2s_config->readqueue,wait);
+        avail = i2s_avail_data_len(capture, i2s_config);
+        if (avail >  i2s_config->capture.cfg.period_bytes)
+        {
+            mask |=  POLLIN | POLLRDNORM;
+        }
+    }
+    if (STATE_RUN == i2s_config->playback.state)
+    {
+        poll_wait(filp,&i2s_config->writequeue,wait);
+        avail = i2s_avail_data_len(playback, i2s_config);
+        if (avail >  i2s_config->playback.cfg.period_bytes)
+        {
+            mask |=  POLLOUT | POLLWRNORM;
+        }
+    }
+    return mask;
+}
+
+static int fh_i2s_read(struct file *filp, char __user *buf, size_t len, loff_t *off)
+{
+
+    int ret;
+    struct miscdevice *miscdev = filp->private_data;
+    struct i2s_dev  *dev = container_of(miscdev, struct i2s_dev, fh_i2s_miscdev);
+    struct fh_i2s_cfg  *i2s_config = &dev->i2s_config;
+    int after,left;
+    int pid,avail;
+    pid = current->tgid;
+    if (i2s_infor_record.record_pid != pid){
+    	return -EBUSY;
+    }
+
+    avail = i2s_avail_data_len(capture, i2s_config);
+    if (avail > len)
+    {
+        avail = len;
+    }
+    after = avail + i2s_config->capture.appl_ptr;
+    if(after  > i2s_config->capture.size)
+    {
+        left = avail - (i2s_config->capture.size - i2s_config->capture.appl_ptr);
+        ret = copy_to_user(buf, i2s_config->capture.area+i2s_config->capture.appl_ptr, i2s_config->capture.size-i2s_config->capture.appl_ptr);
+        ret = copy_to_user(buf+i2s_config->capture.size-i2s_config->capture.appl_ptr,i2s_config->capture.area,left);
+        spin_lock(&i2s_config->capture.lock);
+        i2s_config->capture.appl_ptr = left;
+        spin_unlock(&i2s_config->capture.lock);
+    }
+    else
+    {
+        ret = copy_to_user(buf,i2s_config->capture.area+i2s_config->capture.appl_ptr,avail);
+        spin_lock(&i2s_config->capture.lock);
+        i2s_config->capture.appl_ptr += avail;
+        spin_unlock(&i2s_config->capture.lock);
+    }
+
+    return avail;
+
+}
+
+static int fh_i2s_write(struct file *filp, const char __user *buf,
+                            size_t len, loff_t *off)
+{
+
+    struct miscdevice *miscdev = filp->private_data;
+    struct i2s_dev  *dev = container_of(miscdev, struct i2s_dev, fh_i2s_miscdev);
+    struct fh_i2s_cfg  *i2s_config = &dev->i2s_config;
+    int  ret;
+    int after,left;
+    int pid,avail;
+   pid = current->tgid;
+   if (i2s_infor_record.play_pid != pid){
+	return -EBUSY;
+   }
+    avail = i2s_avail_data_len(playback,i2s_config);
+    if (0 == avail)
+    {
+        return 0;
+    }
+    if (avail > len)
+    {
+        avail = len;
+    }
+    after = avail+i2s_config->playback.appl_ptr;
+    if(after  > i2s_config->playback.size)
+    {
+        left = avail - (i2s_config->playback.size-i2s_config->playback.appl_ptr);
+        ret = copy_from_user(i2s_config->playback.area+i2s_config->playback.appl_ptr,buf,i2s_config->playback.size-i2s_config->playback.appl_ptr);
+        ret = copy_from_user(i2s_config->playback.area,buf+i2s_config->playback.size-i2s_config->playback.appl_ptr,left);
+        spin_lock(&i2s_config->playback.lock);
+        i2s_config->playback.appl_ptr = left;
+        spin_unlock(&i2s_config->playback.lock);
+    }
+    else
+    {
+        ret = copy_from_user(i2s_config->playback.area+i2s_config->playback.appl_ptr,buf,avail);
+        spin_lock(&i2s_config->playback.lock);
+        i2s_config->playback.appl_ptr += avail;
+        spin_unlock(&i2s_config->playback.lock);
+    }
+
+     return avail;
+}
+
+static irqreturn_t fh_i2s_interrupt(int irq, void *dev_id)
+{
+#if 0
+#ifndef CONFIG_MACH_FH8830_FPGA
+	u32 interrupts, rx_status;
+    struct fh_i2s_cfg  *i2s_config = &fh_i2s_dev.i2s_config;
+
+    interrupts = readl(fh_i2s_module.regs + I2S_CTRL);
+    //interrupts &= ~(0x3ff) << 16;
+    writel(interrupts, fh_i2s_module.regs + I2S_CTRL);
+
+    if(interrupts & I2S_INTR_RX_UNDERFLOW)
+    {
+        fh_I2S_stop_capture(i2s_config);
+        fh_I2S_start_capture(i2s_config);
+        PRINT_i2s_DBG("I2S_INTR_RX_UNDERFLOW\n");
+    }
+
+    if(interrupts & I2S_INTR_RX_OVERFLOW)
+    {
+        if (i2s_config->capture.state == STATE_RUN) {
+            fh_I2S_stop_capture(i2s_config);
+            fh_I2S_start_capture(i2s_config);
+        } else {
+            rx_status = readl( fh_i2s_module.regs + I2S_RXFIFO_CTRL);//clear rx fifo
+            rx_status =  rx_status|(1<<4);
+            writel(rx_status,fh_i2s_module.regs + I2S_RXFIFO_CTRL);
+        }
+        PRINT_i2s_DBG("I2S_INTR_RX_OVERFLOW\n");
+    }
+
+    if(interrupts & I2S_INTR_TX_UNDERFLOW)
+    {
+        fh_I2S_stop_playback(i2s_config);
+        fh_I2S_start_playback(i2s_config);
+        PRINT_i2s_DBG("I2S_INTR_TX_UNDERFLOW\n");
+    }
+
+    if(interrupts & I2S_INTR_TX_OVERFLOW)
+    {
+        fh_I2S_stop_playback(i2s_config);
+        fh_I2S_start_playback(i2s_config);
+        PRINT_i2s_DBG("I2S_INTR_TX_OVERFLOW\n");
+    }
+
+    PRINT_i2s_DBG("interrupts: 0x%x\n", interrupts);
+#endif
+#endif
+    return IRQ_HANDLED;
+}
+
+static const struct file_operations I2S_fops =
+{
+    .owner      = THIS_MODULE,
+    .llseek     = no_llseek,
+    .unlocked_ioctl = fh_i2s_ioctl,
+    .release = fh_i2s_close,
+    .open = fh_i2s_open,
+    .poll = fh_i2s_poll,
+    .read = fh_i2s_read,
+    .write = fh_i2s_write,
+
+};
+
+static int __devinit fh_i2s_drv_probe(struct platform_device *pdev)
+{
+    int ret;
+    struct resource *irq_res, *mem;
+
+    mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!mem)
+        return -EINVAL;
+    printk("I2S probe\n");
+    if (!devm_request_mem_region(&pdev->dev, mem->start, resource_size(mem),
+                                 "fh_fh8830_i2s_module"))
+        return -ENOMEM;
+    printk("I2S :%d\n",__LINE__);
+    PRINT_i2s_DBG("%d\n",__LINE__);
+    fh_i2s_module.regs = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));
+    PRINT_i2s_DBG("probe: regs %p\n",fh_i2s_module.regs);
+    if (!fh_i2s_module.regs){
+    	ret = -ENOMEM;
+    	goto remap_fail;
+        }
+
+    fh_i2s_module.clk = clk_get(NULL, "ac_clk");
+	if (!fh_i2s_module.clk) {
+		ret = -EINVAL;
+		goto clk_fail;
+		}
+    clk_enable(fh_i2s_module.clk);
+    PRINT_i2s_DBG("%d\n",__LINE__);
+    spin_lock_init(&fh_i2s_module.lock);
+
+    ret = misc_register(&fh_i2s_dev.fh_i2s_miscdev);
+
+    if (ret)
+        goto out_disable_clk;
+
+    irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+    if (!irq_res)
+    {
+        pr_err("%s: ERROR: getting resource failed"
+               "cannot get IORESOURCE_IRQ\n", __func__);
+        ret = -ENXIO;
+        goto out_disable_clk;
+    }
+    fh_i2s_module.irq = irq_res->start;
+    ret = request_irq(fh_i2s_module.irq, fh_i2s_interrupt, IRQF_SHARED, "i2s", &fh_i2s_module);
+    ret = readl(fh_i2s_module.regs + I2S_DBG_CTL);
+    ret = ret | I2S_EXT_EN| I2S_EN;
+    writel(ret,fh_i2s_module.regs + I2S_DBG_CTL);
+    return 0;
+
+out_disable_clk:
+    clk_disable(fh_i2s_module.clk);
+	fh_i2s_module.clk = NULL;
+clk_fail:
+	devm_iounmap(&pdev->dev, fh_i2s_module.regs);
+	fh_i2s_module.regs = NULL;
+remap_fail:
+	devm_release_mem_region(&pdev->dev, mem->start, resource_size(mem));
+    return ret;
+}
+
+static int __devexit fh_I2S_drv_remove(struct platform_device *pdev)
+{
+	struct resource *mem;
+    misc_deregister(&fh_i2s_dev.fh_i2s_miscdev);
+
+    free_irq(fh_i2s_module.irq, &fh_i2s_module);
+
+	if (fh_i2s_module.clk) {
+		clk_disable(fh_i2s_module.clk);
+    	clk_put(fh_i2s_module.clk);
+	}
+	if (fh_i2s_module.regs) {
+		devm_iounmap(&pdev->dev, fh_i2s_module.regs);
+	}
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (mem) {
+		devm_release_mem_region(&pdev->dev, mem->start, resource_size(mem));
+    }
+    printk("I2S remove ok\n");
+    return 0;
+}
+
+static struct platform_driver fh_i2s_driver =
+{
+    .probe      = fh_i2s_drv_probe,
+    .remove     = __devexit_p(fh_I2S_drv_remove),
+    .driver     = {
+        .name   = "fh_fh8830_i2s",
+        .owner  = THIS_MODULE,
+    }
+};
+
+void i2s_prealloc_dma_buffer(struct fh_i2s_cfg  *i2s_config)
+{
+    int pg;
+    gfp_t gfp_flags;
+    pg = get_order(I2S_DMA_PREALLOC_SIZE);
+    gfp_flags = GFP_KERNEL | __GFP_COMP | __GFP_NORETRY | __GFP_NOWARN;
+    i2s_config->capture.dev.coherent_dma_mask = DMA_BIT_MASK(32);
+    i2s_config->capture.area  = dma_alloc_coherent(&i2s_config->capture.dev, PAGE_SIZE << pg, &i2s_config->capture.addr, gfp_flags );
+    if (!i2s_config->capture.area)
+    {
+        printk(KERN_ERR"no enough mem for capture  buffer alloc\n");
+        return ;
+    }
+    i2s_config->playback.dev.coherent_dma_mask = DMA_BIT_MASK(32);
+    i2s_config->playback.area  = dma_alloc_coherent(&i2s_config->playback.dev, PAGE_SIZE << pg, &i2s_config->playback.addr, gfp_flags );
+    if (!i2s_config->playback.area)
+    {
+        printk(KERN_ERR"no enough mem for  playback buffer alloc\n");
+        return ;
+    }
+}
+
+void i2s_free_prealloc_dma_buffer(struct fh_i2s_cfg  *i2s_config)
+{
+    int pg;
+    pg = get_order(I2S_DMA_PREALLOC_SIZE);
+    dma_free_coherent(&i2s_config->capture.dev, PAGE_SIZE<<pg, i2s_config->capture.area, i2s_config->capture.addr);
+    dma_free_coherent(&i2s_config->playback.dev, PAGE_SIZE<<pg, i2s_config->playback.area, i2s_config->playback.addr);
+}
+
+static void init_i2s_mutex(struct fh_i2s_cfg  *i2s_config)
+{
+    sema_init(&i2s_config->sem_capture, 1);
+    sema_init(&i2s_config->sem_playback, 1);
+}
+
+int i2s_request_dma_channel(void)
+{
+    dma_cap_mask_t mask;
+    /*request i2s rx dma channel*/
+    dma_rx_transfer = kzalloc(sizeof(struct fh_dma_chan), GFP_KERNEL);
+    if (!dma_rx_transfer)
+    {
+        printk(KERN_ERR"alloc  dma_rx_transfer failed\n");
+        goto mem_fail;
+    }
+    memset(dma_rx_transfer, 0, sizeof(struct fh_dma_chan));
+
+    dma_cap_zero(mask);
+    dma_cap_set(DMA_SLAVE, mask);
+    dma_rx_transfer->chan = dma_request_channel(mask, fh_I2S_dma_chan_filter, &fh_i2s_dev.channel_assign.capture_channel);
+    if (!dma_rx_transfer->chan)
+    {
+        printk(KERN_ERR"request i2s rx dma channel failed \n");
+        goto channel_fail;
+    }
+
+    /*request i2s tx dma channel*/
+    dma_tx_transfer = kzalloc(sizeof(struct fh_dma_chan), GFP_KERNEL);
+    if (!dma_tx_transfer)
+    {
+        printk(KERN_ERR"alloc  dma_tx_transfer failed\n");
+        goto mem_fail;
+    }
+    memset(dma_tx_transfer, 0, sizeof(struct fh_dma_chan));
+
+    dma_cap_zero(mask);
+    dma_cap_set(DMA_SLAVE, mask);
+    dma_tx_transfer->chan = dma_request_channel(mask, fh_I2S_dma_chan_filter, &fh_i2s_dev.channel_assign.playback_channel);
+    if (!dma_tx_transfer->chan)
+    {
+        printk(KERN_ERR"request dma channel failed \n");
+        return -EFAULT;
+    }
+
+    return 0;
+channel_fail:
+    if (!dma_rx_transfer->chan)
+    {
+        dma_release_channel(dma_rx_transfer->chan);
+		dma_rx_transfer->chan = NULL;
+    }
+    if (!dma_tx_transfer->chan)
+    {
+        dma_release_channel(dma_tx_transfer->chan);
+		dma_tx_transfer->chan = NULL;
+    }
+
+mem_fail:
+    if (dma_rx_transfer != NULL)
+    {
+        kfree(dma_rx_transfer);
+        dma_rx_transfer = NULL;
+    }
+    if (dma_tx_transfer != NULL)
+    {
+        kfree(dma_tx_transfer);
+        dma_tx_transfer = NULL;
+    }
+
+    return -EFAULT;
+}
+
+void i2s_release_dma_channel(void)
+{
+    /*release i2s tx dma channel*/
+    if (dma_tx_transfer != NULL)
+    {
+    	if (dma_tx_transfer->chan) {
+			dma_release_channel(dma_tx_transfer->chan);
+			dma_tx_transfer->chan = NULL;
+    	}
+        kfree(dma_tx_transfer);
+        dma_tx_transfer = NULL;
+    }
+
+    /*release i2s rx dma channel*/
+    if (dma_rx_transfer != NULL)
+    {
+    	if (dma_rx_transfer->chan) {
+			dma_release_channel(dma_rx_transfer->chan);
+			dma_rx_transfer->chan = NULL;
+    	}
+        
+        kfree(dma_rx_transfer);
+        dma_rx_transfer = NULL;
+    }
+
+
+}
+static void create_fh8830_i2s_proc(void);
+static void remove_fh8830_i2s_proc(void);
+static int __init fh_i2s_init(void)
+{
+    int status;
+	init_i2s_mutex(&fh_i2s_dev.i2s_config);
+
+    i2s_prealloc_dma_buffer(&fh_i2s_dev.i2s_config);
+
+    status = i2s_request_dma_channel();
+    if(status)
+    	printk("fh i2s init fail status=0x%x\n",status);
+    create_fh8830_i2s_proc();
+    return platform_driver_register(&fh_i2s_driver);
+}
+module_init(fh_i2s_init);
+
+static void __exit fh_i2s_exit(void)
+{
+
+    remove_fh8830_i2s_proc();
+    i2s_release_dma_channel();
+    i2s_free_prealloc_dma_buffer(&fh_i2s_dev.i2s_config);
+    platform_driver_unregister(&fh_i2s_driver);
+}
+module_exit(fh_i2s_exit);
+
+MODULE_AUTHOR("FH_i2s");
+MODULE_DESCRIPTION("FH_i2s");
+MODULE_LICENSE("GPL");
+
+/****************************debug proc*****************************/
+#include <linux/proc_fs.h>
+#include <asm/unistd.h>
+struct proc_dir_entry *proc_ac_entry;
+#define proc_name "fh_fh8830_i2s"
+#define I2S_TEST_LOOP 1
+#define I2S_TEST_OUT  0
+ssize_t proc_ac_read(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    ssize_t len = 0;
+	int i;
+	unsigned int reg;
+	unsigned int *data_addr;
+	unsigned int file_len;
+	struct file *fp;
+	loff_t pos;
+	mm_segment_t old_fs;
+	for (i = 0;i <= 0x1C;i += 4) {
+		printk(KERN_INFO"0x%x reg = 0x%x\n",i, readl(fh_i2s_module.regs + i));
+	}
+	for (i = 80;i <= 0xd0;i += 4) {
+			printk(KERN_INFO"0x%x reg = 0x%x\n",i, readl(fh_i2s_module.regs + i));
+		}
+	printk("loop test start __________\n");
+	writel(0xe0000000,fh_i2s_module.regs + I2S_CTRL);// ctrl
+	writel(0x1,fh_i2s_module.regs + I2S_TXFIFO_CTRL);// tx
+	writel(0x1,fh_i2s_module.regs + I2S_RXFIFO_CTRL);// rx
+	writel(0x1 <<12 |0x3,fh_i2s_module.regs + I2S_DBG_CTL);// loop
+
+	writel(0x1000000,0xfe0901ac);
+	i = 0;
+	data_addr = kzalloc(4096*4, GFP_KERNEL);
+	    if (!data_addr)
+	    {
+	        printk("alloc  dma_rx_transfer failed\n");
+	    }
+	    memset(data_addr, 0, 4096*4);
+	    mdelay(1000);
+	while (1) {
+#if I2S_TEST_LOOP
+		reg =0xff & readl(fh_i2s_module.regs + 0x0c);
+
+		if(reg >0){
+			reg = readl(fh_i2s_module.regs +0x200);
+			writel(reg,fh_i2s_module.regs + 0x100);
+		}
+
+#endif
+
+
+#if I2S_TEST_OUT
+		reg =0xff00 & readl(fh_i2s_module.regs + 0x0c);
+		reg = reg>>8;
+	//	printk("write dac date reg = %x \n ",reg);
+		if (reg < 0x40) {
+			writel(i, fh_i2s_module.regs + 0x100);
+			writel(i, fh_i2s_module.regs + 0x300);
+
+
+		}
+		i = i+0x200;
+		if(i >= 0xffffff)
+			i = 0;
+	//	printk("water level 0x%x\n",readl(fh_i2s_module.regs + 0x0c));
+
+#endif
+	}
+//TEST I2S_INPUT TO FILE
+	pos =0;
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	fp =  filp_open("/home/test",O_RDWR|O_CREAT,0644);
+	if(IS_ERR(fp)){
+		printk("file is error\n");
+		return 1;
+
+	}
+	 file_len = fp->f_op->write(fp,(void*)data_addr,4096,&pos);
+	 printk("write len is %d\n",len);
+	 set_fs(old_fs);
+	 filp_close(fp,NULL);
+	printk("loop test stop ___________\n");
+	for (i = 0;i <= 0x1C;i += 4) {
+		printk(KERN_INFO"0x%x reg = 0x%x\n",i, readl(fh_i2s_module.regs + i));
+	}
+	for (i = 80;i <= 0xd0;i += 4) {
+			printk(KERN_INFO"0x%x reg = 0x%x\n",i, readl(fh_i2s_module.regs + i));
+		}
+    return len;
+}
+
+static void create_fh8830_i2s_proc(void)
+{
+    proc_ac_entry = create_proc_entry(proc_name, S_IRUGO, NULL);
+    if (!proc_ac_entry)
+    {
+        printk(KERN_ERR"create proc failed\n");
+    }
+    else
+    {
+        proc_ac_entry->read_proc = proc_ac_read;
+    }
+}
+
+static void remove_fh8830_i2s_proc(void)
+{
+    remove_proc_entry(proc_name, NULL);
+}
diff -uraN linux-3.0.8/drivers/misc/fh_i2s.h linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_i2s.h
--- linux-3.0.8/drivers/misc/fh_i2s.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_i2s.h	2021-07-13 23:40:34.782363168 +0300
@@ -0,0 +1,35 @@
+#ifndef __FH_LINBA0_I2S_H
+#define __FH_LINBA0_I2S_H
+
+#define	FH_I2S_IOCTL_MEM_BASE	'M'
+#define	I2S_INIT_CAPTURE_MEM    	       _IOWR(FH_I2S_IOCTL_MEM_BASE, 0, int)
+#define	I2S_INIT_PLAYBACK_MEM           _IOWR(FH_I2S_IOCTL_MEM_BASE, 1, int)
+
+#define	FH_I2S_IOCTL_PARAM_BASE	'P'
+#define I2S_SET_VOL                     _IOWR(FH_I2S_IOCTL_PARAM_BASE, 0, int)
+#define I2S_SET_INPUT_MODE              _IOWR(FH_I2S_IOCTL_PARAM_BASE, 1, int)
+#define I2S_SET_OUTPUT_MODE             _IOWR(FH_I2S_IOCTL_PARAM_BASE, 2, int)
+
+#define	FH_I2S_IOCTL_ENA_BASE	'E'
+#define I2S_AI_EN                       _IOWR(FH_I2S_IOCTL_ENA_BASE, 0, int)
+#define I2S_AO_EN                       _IOWR(FH_I2S_IOCTL_ENA_BASE, 1, int)
+#define I2S_AI_DISABLE                  _IOWR(FH_I2S_IOCTL_ENA_BASE, 2, int)
+#define I2S_AO_DISABLE       		   _IOWR(FH_I2S_IOCTL_ENA_BASE, 3, int)
+#define I2S_AI_PAUSE               	   _IOWR(FH_I2S_IOCTL_ENA_BASE, 4, int)
+#define I2S_AI_RESUME          		   _IOWR(FH_I2S_IOCTL_ENA_BASE, 5, int)
+#define I2S_AO_PAUSE              	   _IOWR(FH_I2S_IOCTL_ENA_BASE, 6, int)
+#define I2S_AO_RESUME          		   _IOWR(FH_I2S_IOCTL_ENA_BASE, 7, int)
+
+
+struct fh_i2s_cfg_arg{
+
+	int volume;
+	int rate;
+	int frame_bit;
+	int channels;
+	int buffer_size;
+	int period_size;
+};
+
+#endif
+
diff -uraN linux-3.0.8/drivers/misc/fh_pinctrl_dev.c linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_pinctrl_dev.c
--- linux-3.0.8/drivers/misc/fh_pinctrl_dev.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_pinctrl_dev.c	2021-07-13 23:40:34.782363168 +0300
@@ -0,0 +1,279 @@
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/pwm.h>
+#include <linux/printk.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+#include <asm/uaccess.h>
+#include "fh_pinctrl_dev.h"
+
+#define FH_PINCTRL_PROC_FILE "driver/pinctrl"
+
+#undef  FH_PINCTRL_DEBUG
+#ifdef FH_PINCTRL_DEBUG
+#define PRINT_DBG(fmt,args...)  printk(fmt,##args)
+#else
+#define PRINT_DBG(fmt,args...)  do{} while(0)
+#endif
+
+struct proc_dir_entry *pinctrl_proc_file;
+
+static int fh_pinctrl_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int fh_pinctrl_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+
+static long fh_pinctrl_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+
+	if (unlikely(_IOC_TYPE(cmd) != PINCTRL_IOCTL_MAGIC))
+	{
+		pr_err("%s: ERROR: incorrect magic num %d (error: %d)\n",
+			   __func__, _IOC_TYPE(cmd), -ENOTTY);
+		return -ENOTTY;
+	}
+
+	if (unlikely(_IOC_NR(cmd) > PINCTRL_IOCTL_MAXNR))
+	{
+		pr_err("%s: ERROR: incorrect cmd num %d (error: %d)\n",
+			   __func__, _IOC_NR(cmd), -ENOTTY);
+		return -ENOTTY;
+	}
+
+	if (_IOC_DIR(cmd) & _IOC_READ)
+	{
+		ret = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
+	}
+	else if(_IOC_DIR(cmd) & _IOC_WRITE)
+	{
+		ret = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
+	}
+
+	if(ret)
+	{
+		pr_err("%s: ERROR: user space access is not permitted %d (error: %d)\n",
+			   __func__, _IOC_NR(cmd), -EACCES);
+		return -EACCES;
+	}
+
+	switch(cmd)
+	{
+
+	}
+
+	return ret;
+}
+
+static const struct file_operations fh_pinctrl_fops =
+{
+	.owner 			= THIS_MODULE,
+	.open 			= fh_pinctrl_open,
+	.release 		= fh_pinctrl_release,
+	.unlocked_ioctl 	= fh_pinctrl_ioctl,
+};
+
+static struct miscdevice fh_pinctrl_misc =
+{
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = DEVICE_NAME,
+	.fops = &fh_pinctrl_fops,
+};
+
+static void del_char(char* str,char ch)
+{
+	char *p = str;
+	char *q = str;
+	while(*q)
+	{
+		if (*q !=ch)
+		{
+			*p++ = *q;
+		}
+		q++;
+	}
+	*p='\0';
+}
+
+static ssize_t fh_pinctrl_proc_write(struct file *filp, const char *buf, size_t len, loff_t *off)
+{
+	int i;
+	char message[32] = {0};
+	char * const delim = ",";
+	char *cur = message;
+	char* param_str[4];
+	unsigned int param[4];
+
+	len = (len > 32) ? 32 : len;
+
+	if (copy_from_user(message, buf, len))
+		return -EFAULT;
+
+	for(i=0; i<4; i++)
+	{
+		param_str[i] = strsep(&cur, delim);
+		if(!param_str[i])
+		{
+			pr_err("%s: ERROR: parameter[%d] is empty\n", __func__, i);
+			pr_err("[dev/mux], [dev name], [mux name], [func sel]\n");
+			return -EINVAL;
+		}
+		else
+		{
+			del_char(param_str[i], ' ');
+			del_char(param_str[i], '\n');
+		}
+	}
+
+        if(!strcmp(param_str[0], "dev"))
+        {
+        	fh_pinctrl_sdev(param_str[1], 0);
+        }
+        else if(!strcmp(param_str[0], "mux"))
+        {
+		param[3] = (u32)simple_strtoul(param_str[3], NULL, 10);
+		if(param[3] < 0)
+		{
+			pr_err("ERROR: parameter[3] is incorrect\n");
+			return -EINVAL;
+		}
+        	fh_pinctrl_smux(param_str[1], param_str[2], param[3], 0);
+        }
+        else
+        {
+		pr_err("ERROR: parameter[0] is incorrect\n"
+			"[dev/mux], [dev name], [mux name], [func sel]\n");
+		return -EINVAL;
+        }
+
+	return len;
+}
+
+static void *v_seq_start(struct seq_file *s, loff_t *pos)
+{
+	static unsigned long counter = 0;
+	if (*pos == 0)
+		return &counter;
+	else
+	{
+		*pos = 0;
+		return NULL;
+	}
+}
+
+static void *v_seq_next(struct seq_file *s, void *v, loff_t *pos)
+{
+	(*pos)++;
+	return NULL;
+}
+
+static void v_seq_stop(struct seq_file *s, void *v)
+{
+
+}
+
+static int v_seq_show(struct seq_file *sfile, void *v)
+{
+
+	fh_pinctrl_prt(sfile);
+	return 0;
+}
+
+static const struct seq_operations isp_seq_ops =
+{
+	.start = v_seq_start,
+	.next = v_seq_next,
+	.stop = v_seq_stop,
+	.show = v_seq_show
+};
+
+static int fh_pinctrl_proc_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &isp_seq_ops);
+}
+
+static struct file_operations fh_pinctrl_proc_ops =
+{
+	.owner = THIS_MODULE,
+	.open = fh_pinctrl_proc_open,
+	.read = seq_read,
+	.write = fh_pinctrl_proc_write,
+	.release = seq_release,
+};
+
+
+static int __devinit fh_pinctrl_probe(struct platform_device *pdev)
+{
+	int err;
+
+	err = misc_register(&fh_pinctrl_misc);
+
+	if(err < 0)
+	{
+		pr_err("%s: ERROR: %s registration failed",
+			   __func__, DEVICE_NAME);
+		return -ENXIO;
+	}
+
+	pinctrl_proc_file = create_proc_entry(FH_PINCTRL_PROC_FILE, 0644, NULL);
+
+	if (pinctrl_proc_file)
+		pinctrl_proc_file->proc_fops = &fh_pinctrl_proc_ops;
+	else
+		pr_err("%s: ERROR: %s proc file create failed",
+				__func__, DEVICE_NAME);
+
+	return 0;
+}
+
+static int __exit fh_pinctrl_remove(struct platform_device *pdev)
+{
+	misc_deregister(&fh_pinctrl_misc);
+	return 0;
+}
+
+static struct platform_driver fh_pinctrl_driver =
+{
+	.driver	=
+	{
+		.name	= DEVICE_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe 		= fh_pinctrl_probe,
+	.remove		= __exit_p(fh_pinctrl_remove),
+};
+
+static int __init fh_pinctrl_dev_init(void)
+{
+	return platform_driver_register(&fh_pinctrl_driver);
+}
+
+static void __exit fh_pinctrl_dev_exit(void)
+{
+
+	platform_driver_unregister(&fh_pinctrl_driver);
+
+}
+
+module_init(fh_pinctrl_dev_init);
+module_exit(fh_pinctrl_dev_exit);
+
+
+MODULE_AUTHOR("fullhan");
+
+MODULE_DESCRIPTION("FH PINCTRL driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(MISC_DYNAMIC_MINOR);
diff -uraN linux-3.0.8/drivers/misc/fh_pinctrl_dev.h linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_pinctrl_dev.h
--- linux-3.0.8/drivers/misc/fh_pinctrl_dev.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_pinctrl_dev.h	2021-07-13 23:40:34.786363192 +0300
@@ -0,0 +1,18 @@
+
+#ifndef FH_PINCTRL_DEV_H_
+#define FH_PINCTRL_DEV_H_
+
+#include <linux/slab.h>
+#include <linux/ioctl.h>
+#include <mach/pinctrl.h>
+
+
+#define DEVICE_NAME					"fh_pinctrl"
+
+
+#define PINCTRL_IOCTL_MAGIC 				'p'
+
+#define PINCTRL_IOCTL_MAXNR 				8
+
+
+#endif /* FH_PINCTRL_DEV_H_ */
diff -uraN linux-3.0.8/drivers/misc/fh_sadc.c linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_sadc.c
--- linux-3.0.8/drivers/misc/fh_sadc.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/fh_sadc.c	2021-07-13 23:40:34.762363045 +0300
@@ -0,0 +1,537 @@
+/*
+ * fh_sadc.c
+ *
+ *  Created on: Mar 13, 2015
+ *      Author: duobao
+ */
+#include <linux/uaccess.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+/*****************************************************************************
+ *  Include Section
+ *  add all #include here
+ *****************************************************************************/
+#include   <mach/fh_sadc.h>
+/*****************************************************************************
+ * Define section
+ * add all #define here
+ *****************************************************************************/
+#define wrap_readl(wrap, name) \
+	__raw_readl(&(((struct wrap_sadc_reg *)wrap->regs)->name))
+
+#define wrap_writel(wrap, name, val) \
+	__raw_writel((val), &(((struct wrap_sadc_reg *)wrap->regs)->name))
+
+#define wrap_readw(wrap, name) \
+	__raw_readw(&(((struct wrap_sadc_reg *)wrap->regs)->name))
+
+#define wrap_writew(wrap, name, val) \
+	__raw_writew((val), &(((struct wrap_sadc_reg *)wrap->regs)->name))
+
+#define wrap_readb(wrap, name) \
+	__raw_readb(&(((struct wrap_sadc_reg *)wrap->regs)->name))
+
+#define wrap_writeb(wrap, name, val) \
+	__raw_writeb((val), &(((struct wrap_sadc_reg *)wrap->regs)->name))
+
+#define IOCTL_GET_SADC_DATA	1
+#define IOCTL_SADC_POWER_DOWN	0xff
+#define SADC_WRAP_BASE			(0xf1200000)
+#define SADC_IRQn			(23)
+#define SADC_MAX_CONTROLLER		(1)
+#define SADC_STATUS_COLESD		(0)
+#define SADC_STATUS_OPEN		(1)
+#define FH_SADC_PLAT_DEVICE_NAME		"fh_sadc"
+#define FH_SADC_MISC_DEVICE_NAME		"fh_sadc"
+/****************************************************************************
+ * ADT section
+ *  add definition of user defined Data Type that only be used in this file  here
+ ***************************************************************************/
+typedef struct{
+	int channel;
+	int sadc_data;
+} SADC_INFO;
+/******************************************************************************
+ * Function prototype section
+ * add prototypes for all functions called by this file,execepting those
+ * declared in header file
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Global variables section - Exported
+ * add declaration of global variables that will be exported here
+ * e.g.
+ *  int8_t foo;
+ ****************************************************************************/
+
+/*****************************************************************************
+
+ *  static fun;
+ *****************************************************************************/
+static u32 fh_sadc_isr_read_data(struct wrap_sadc_obj *sadc, u32 channel,u16 *buf);
+static int fh_sadc_open(struct inode *inode, struct file *file);
+static int fh_sadc_release(struct inode *inode, struct file *filp);
+static long fh_sadc_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
+/*****************************************************************************
+ * Global variables section - Local
+ * define global variables(will be refered only in this file) here,
+ * static keyword should be used to limit scope of local variable to this file
+ * e.g.
+ *  static uint8_t ufoo;
+ *****************************************************************************/
+static struct wrap_sadc_obj fh_sadc_obj;
+
+static const struct file_operations fh_sadc_fops = {
+	.owner 			= THIS_MODULE,
+	.open 			= fh_sadc_open,
+	.release 		= fh_sadc_release,
+	.unlocked_ioctl = fh_sadc_ioctl,
+};
+
+static struct miscdevice fh_sadc_misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = FH_SADC_MISC_DEVICE_NAME,
+	.fops = &fh_sadc_fops,
+};
+
+/*****************************************************************************
+ *
+ *
+ *		function body
+ *
+ *
+ *****************************************************************************/
+u32 fh_sadc_isr_read_data(struct wrap_sadc_obj *sadc, u32 channel,
+		u16 *buf) {
+	u32 xainsel = 1 << channel;
+	u32 xversel = 0;
+	u32 xpwdb = 1;
+	//cnt
+	u32 sel2sam_pre_cnt = 2;
+	u32 sam_cnt = 2;
+	u32 sam2sel_pos_cnt = 2;
+	//time out
+	u32 eoc_tos = 0xff;
+	u32 eoc_toe = 0xff;
+	u32 time_out = 0xffff;
+	//set isr en..
+	u32 sadc_isr = 0x01;
+	//start
+	u32 sadc_cmd = 0x01;
+	//get data
+	u32 temp_data = 0;
+	u32 ret_time;
+
+	//control...
+	wrap_writel(sadc, sadc_control, xainsel | (xversel << 8) | (xpwdb << 12));
+
+	wrap_writel(sadc, sadc_cnt,
+			sel2sam_pre_cnt | (sam_cnt << 8) | (sam2sel_pos_cnt << 16));
+
+	wrap_writel(sadc, sadc_timeout,
+			eoc_tos | (eoc_toe << 8) | (time_out << 16));
+
+	wrap_writel(sadc, sadc_ier, sadc_isr);
+
+	wrap_writel(sadc, sadc_cmd, sadc_cmd);
+
+	ret_time = wait_for_completion_timeout(&sadc->done,5000);
+	if(ret_time == 0){
+		printk("sadc timeout..\n");
+		return SADC_TIMEOUT;
+	}
+
+	switch (channel) {
+	case 0:
+	case 1:
+		//read channel 0 1
+		temp_data = wrap_readl(sadc, sadc_dout0);
+		break;
+
+	case 2:
+	case 3:
+		//read channel 2 3
+		temp_data = wrap_readl(sadc, sadc_dout1);
+		break;
+
+	case 4:
+	case 5:
+		//read channel 4 5
+		temp_data = wrap_readl(sadc, sadc_dout2);
+		break;
+
+	case 6:
+	case 7:
+		//read channel 6 7
+		temp_data = wrap_readl(sadc, sadc_dout3);
+		break;
+	default:
+		break;
+	}
+	if (channel % 2) {
+		//read low 16bit
+		*buf = (u16) (temp_data & 0xffff);
+	} else {
+		//read high 16bit
+		*buf = (u16) (temp_data >> 16);
+	}
+	return 0;
+
+}
+EXPORT_SYMBOL(fh_sadc_isr_read_data);
+
+int fh_sadc_enable(void)
+{
+    u32 control_reg;
+    struct wrap_sadc_obj *sadc = &fh_sadc_obj;
+
+    control_reg = wrap_readl(sadc, sadc_control);
+    control_reg |= 1 << 12;
+    wrap_writel(sadc, sadc_control, control_reg);
+    return 0;
+}
+EXPORT_SYMBOL(fh_sadc_enable);
+
+int fh_sadc_disable(void)
+{
+    u32 control_reg;
+    struct wrap_sadc_obj *sadc = &fh_sadc_obj;
+
+    control_reg = wrap_readl(sadc, sadc_control);
+    control_reg &= ~(1 << 12);
+    wrap_writel(sadc, sadc_control, control_reg);
+    return 0;
+}
+EXPORT_SYMBOL(fh_sadc_disable);
+
+static irqreturn_t fh_sadc_isr(int irq, void *dev_id) {
+
+	u32 isr_status;
+	struct wrap_sadc_obj *sadc = (struct wrap_sadc_obj *) dev_id;
+
+	isr_status = wrap_readl(sadc, sadc_int_status);
+	if (isr_status & 0x01) {
+
+		u32 sadc_isr = 0x00;
+		wrap_writel(sadc, sadc_ier, sadc_isr);
+
+		wrap_writel(sadc, sadc_int_status, isr_status);
+		complete(&(sadc->done));
+	} else {
+
+		printk("sadc maybe error!\n");
+	}
+
+	return IRQ_HANDLED;
+}
+
+long fh_sadc_get_value(int channel) {
+	unsigned int ret;
+	long w = 0;
+	u16 ad_raw_data;
+
+	if(channel < 0) {
+		printk("ERROR: %s, sadc channel no %d is incorrect\n",
+				__func__, channel);
+		return 0;
+	}
+
+	fh_sadc_enable();
+
+	ret = fh_sadc_isr_read_data(&fh_sadc_obj, channel, &ad_raw_data);
+
+	if(ret != 0) {
+		printk(KERN_INFO "sadc error code:0x%x\n",ret);
+	}
+	else {
+		w = ad_raw_data * SADC_REF / SADC_MAX_AD_VALUE;
+		printk(KERN_INFO "the value of sadc is: %ld\n", w);
+	}
+
+	return w;
+}
+EXPORT_SYMBOL(fh_sadc_get_value);
+
+static void del_char(char* str,char ch)
+{
+   char *p = str;
+   char *q = str;
+   while(*q)
+   {
+       if (*q !=ch)
+       {
+           *p++ = *q;
+       }
+       q++;
+   }
+   *p='\0';
+}
+
+static ssize_t fh_sadc_proc_write(struct file *filp, const char *buf, size_t len, loff_t *off)
+{
+    char message[32] = {0};
+    char * const delim = ",";
+    char *cur = message, *power_str;
+    int power;
+
+    len = (len > 32) ? 32 : len;
+
+    if (copy_from_user(message, buf, len))
+        return -EFAULT;
+
+    power_str = strsep(&cur, delim);
+    if(!power_str)
+    {
+        pr_err("%s: ERROR: parameter is empty\n", __func__);
+        return -EINVAL;
+    }
+    else
+    {
+        del_char(power_str, ' ');
+        del_char(power_str, '\n');
+        power = (u32)simple_strtoul(power_str, NULL, 10);
+        if(power < 0)
+        {
+            pr_err("%s: ERROR: parameter is incorrect\n", __func__);
+            return -EINVAL;
+        }
+    }
+
+    power ? fh_sadc_enable() : fh_sadc_disable();
+
+    return len;
+}
+
+static void *v_seq_start(struct seq_file *s, loff_t *pos)
+{
+    static unsigned long counter = 0;
+    if (*pos == 0)
+        return &counter;
+    else
+    {
+        *pos = 0;
+        return NULL;
+    }
+}
+
+static void *v_seq_next(struct seq_file *s, void *v, loff_t *pos)
+{
+    (*pos)++;
+    return NULL;
+}
+
+static void v_seq_stop(struct seq_file *s, void *v)
+{
+
+}
+
+static int v_seq_show(struct seq_file *sfile, void *v)
+{
+    int i;
+    u32 reg;
+    struct wrap_sadc_obj *sadc = &fh_sadc_obj;
+    u32 ret;
+
+    reg = wrap_readl(sadc, sadc_control) & 0x1000;
+
+    seq_printf(sfile, "\nSADC Status:\n");
+    seq_printf(sfile, "Power %s\n\n", reg ? "up" : "down");
+
+    for(i=0; i<8; i++)
+    {
+        u16 ad_raw_data;
+        ret = fh_sadc_isr_read_data(&fh_sadc_obj, i, &ad_raw_data);
+        if(ret != 0){
+        	seq_printf(sfile,"sadc error code:0x%x\n",ret);
+        }
+        else
+        	seq_printf(sfile, "channel: %d \tvalue: %u\n", i, ad_raw_data * SADC_REF / SADC_MAX_AD_VALUE);
+    }
+    return 0;
+}
+
+static const struct seq_operations isp_seq_ops =
+{
+    .start = v_seq_start,
+    .next = v_seq_next,
+    .stop = v_seq_stop,
+    .show = v_seq_show
+};
+
+static int fh_sadc_proc_open(struct inode *inode, struct file *file)
+{
+    return seq_open(file, &isp_seq_ops);
+}
+
+static struct file_operations fh_sadc_proc_ops =
+{
+	.owner = THIS_MODULE,
+	.open = fh_sadc_proc_open,
+	.read = seq_read,
+	.write = fh_sadc_proc_write,
+	.release = seq_release,
+};
+
+static int __devinit fh_sadc_probe(struct platform_device *pdev) {
+	int err;
+	struct resource *res;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "sadc get platform source error..\n");
+		return -ENODEV;
+	}
+
+	fh_sadc_obj.irq_no = platform_get_irq(pdev, 0);
+	if (fh_sadc_obj.irq_no < 0) {
+		dev_warn(&pdev->dev, "sadc interrupt is not available.\n");
+		return fh_sadc_obj.irq_no;
+	}
+
+	res = request_mem_region(res->start, resource_size(res), pdev->name);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "sadc region already claimed\n");
+		return -EBUSY;
+	}
+
+	fh_sadc_obj.regs = ioremap(res->start, resource_size(res));
+	if (fh_sadc_obj.regs == NULL) {
+		err = -ENXIO;
+		goto fail_no_ioremap;
+	}
+
+	init_completion(&fh_sadc_obj.done);
+	fh_sadc_obj.active_channel_no = 0;
+
+	err = request_irq(fh_sadc_obj.irq_no, fh_sadc_isr, 0, dev_name(&pdev->dev),
+			&fh_sadc_obj);
+	if (err) {
+		dev_dbg(&pdev->dev, "request_irq failed, %d\n", err);
+		err = -ENXIO;
+		goto err_irq;
+	}
+
+	err = misc_register(&fh_sadc_misc);
+
+	if (err < 0) {
+		pr_err("%s: ERROR: %s registration failed", __func__,
+				FH_SADC_MISC_DEVICE_NAME);
+		err = -ENXIO;
+		goto misc_error;
+	}
+
+	fh_sadc_obj.proc_file = create_proc_entry(FH_SADC_PROC_FILE, 0644, NULL);
+
+    if (fh_sadc_obj.proc_file)
+        fh_sadc_obj.proc_file->proc_fops = &fh_sadc_proc_ops;
+    else
+        pr_err("%s: ERROR: %s proc file create failed",
+               __func__, "SADC");
+
+	return 0;
+
+misc_error:
+	free_irq(fh_sadc_obj.irq_no, &fh_sadc_obj);
+
+err_irq:
+	iounmap(fh_sadc_obj.regs);
+
+fail_no_ioremap:
+	release_mem_region(res->start, resource_size(res));
+
+	return err;
+}
+
+static int __exit fh_sadc_remove(struct platform_device *pdev) {
+
+	struct resource *res;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	misc_deregister(&fh_sadc_misc);
+	free_irq(fh_sadc_obj.irq_no, &fh_sadc_obj);
+	iounmap(fh_sadc_obj.regs);
+	release_mem_region(res->start, resource_size(res));
+	return 0;
+
+}
+
+
+static int fh_sadc_open(struct inode *inode, struct file *file) {
+	return 0;
+}
+
+static int fh_sadc_release(struct inode *inode, struct file *filp) {
+	return 0;
+}
+
+static long fh_sadc_ioctl(struct file *filp, unsigned int cmd,
+		unsigned long arg) {
+
+	u32 ad_data;
+	u32 control_reg;
+	u16 ad_raw_data;
+	SADC_INFO sadc_info;
+	struct wrap_sadc_obj *sadc = &fh_sadc_obj;
+
+	if (cmd == IOCTL_GET_SADC_DATA) {
+		if (copy_from_user((void *) &sadc_info, (void __user*) arg,
+				sizeof(sadc_info))) {
+			return -EFAULT;
+		}
+
+		fh_sadc_isr_read_data(&fh_sadc_obj, sadc_info.channel, &ad_raw_data);
+		ad_data = ad_raw_data * SADC_REF;
+		ad_data /= SADC_MAX_AD_VALUE;
+		sadc_info.sadc_data = ad_data;
+		if (put_user(sadc_info.sadc_data,
+				(int __user* )(&((SADC_INFO* )arg)->sadc_data))) {
+			return -EFAULT;
+		}
+	}
+
+	else if (cmd == IOCTL_SADC_POWER_DOWN) {
+		control_reg = wrap_readl(sadc, sadc_control);
+		control_reg &= ~(1 << 12);
+		wrap_writel(sadc, sadc_control, control_reg);
+	}
+	return 0;
+}
+
+
+/*******************
+ *
+ *
+ * add platform cause of i need the board info...
+ * in the probe function. i will register the sadc misc drive...then the app can open the sadc misc device..
+ *
+ ******************/
+static struct platform_driver fh_sadc_driver =
+{
+	.driver	=
+	{
+		.name	= FH_SADC_PLAT_DEVICE_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe 		= fh_sadc_probe,
+	.remove		= __exit_p(fh_sadc_remove),
+};
+
+
+
+static int __init fh_sadc_init(void) {
+
+	return platform_driver_register(&fh_sadc_driver);
+}
+
+static void __exit fh_sadc_exit(void) {
+
+	platform_driver_unregister(&fh_sadc_driver);
+
+}
+
+module_init(fh_sadc_init);
+module_exit(fh_sadc_exit);
+
+MODULE_DESCRIPTION("fh sadc driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("zhangy@fullhan.com");
+MODULE_ALIAS("platform:FH_sadc");
diff -uraN linux-3.0.8/drivers/misc/Kconfig linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/Kconfig
--- linux-3.0.8/drivers/misc/Kconfig	2021-07-14 21:52:02.887133636 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/Kconfig	2021-07-13 23:40:34.790363216 +0300
@@ -157,6 +157,8 @@
 	  an Intel Atom (non-netbook) mobile device containing a MIPI
 	  P1149.7 standard implementation.
 
+
+
 config SGI_IOC4
 	tristate "SGI IOC4 Base IO support"
 	depends on PCI
@@ -404,6 +406,60 @@
 	  To compile this driver as a module, choose M here: the module will
 	  be called ep93xx_pwm.
 
+config FH_I2S_SLAVE
+	depends on ARCH_FH8830 || ARCH_FH8833
+	tristate "FH I2S SLAVE MODE support"
+	default n
+
+config FH_I2S_MASTER
+	depends on  ARCH_FH8833
+	tristate "FH I2S MASTER MODE support"
+	default n
+
+
+	  
+
+config FH_PINCTRL
+	tristate "FH Pinctrl support"
+	default n
+	help
+	  To compile this driver as a module, choose M here: the module will
+	  be called.
+	  
+	  
+config FH_SADC
+	depends on ARCH_FULLHAN
+    tristate "FH SADC support"
+	help
+	  To compile this driver as a module, choose M here: the module will
+	  be called fh_sadc.
+	  
+	  HW para:10bits precision, 8 channels, 5M clk in. 
+	  one conversion need almost (12/5M *1)second
+
+
+config FH_FIRMWARE_LOADER
+	tristate "Enable FH firmware loader"
+	default m
+	help
+	  enable firmware loader
+
+config FH_EFUSE
+	tristate "FH EFUSE support"
+	help
+	  To compile this driver as a module, choose M here: the module will
+	  be called fh_efuse.
+	  
+	  HW para:60 bytes could be programmed. 
+	  the "efuse2aes map" is fixed by hardware..EX. 0~4 : aes key0, 5~8 : aes key1.
+
+config FH_CLK_MISC
+	tristate "FH clk miscdev support"
+	default n
+	help
+	  To compile this driver as a module, choose M here: the module will
+	  be called.
+	  
 config DS1682
 	tristate "Dallas DS1682 Total Elapsed Time Recorder with Alarm"
 	depends on I2C && EXPERIMENTAL
diff -uraN linux-3.0.8/drivers/misc/Makefile linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/Makefile
--- linux-3.0.8/drivers/misc/Makefile	2021-07-14 21:52:02.887133636 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/misc/Makefile	2021-07-13 23:40:34.774363119 +0300
@@ -9,6 +9,7 @@
 0bj-$(CONFIG_INTEL_MID_PTI)	+= pti.o
 obj-$(CONFIG_ATMEL_PWM)		+= atmel_pwm.o
 obj-$(CONFIG_ATMEL_SSC)		+= atmel-ssc.o
+obj-$(CONFIG_ATMEL_ACW)		+= atmel-acw.o
 obj-$(CONFIG_ATMEL_TCLIB)	+= atmel_tclib.o
 obj-$(CONFIG_BMP085)		+= bmp085.o
 obj-$(CONFIG_ICS932S401)	+= ics932s401.o
@@ -31,6 +32,15 @@
 obj-$(CONFIG_ISL29020)		+= isl29020.o
 obj-$(CONFIG_SENSORS_TSL2550)	+= tsl2550.o
 obj-$(CONFIG_EP93XX_PWM)	+= ep93xx_pwm.o
+obj-$(CONFIG_FH_PINCTRL)		+= fh_pinctrl_dev.o
+obj-$(CONFIG_FH_I2S_MASTER)		+= fh_dw_i2s.o
+obj-$(CONFIG_FH_I2S_SLAVE)		+= fh_i2s.o
+obj-$(CONFIG_FH_SADC)		+= fh_sadc.o
+
+obj-$(CONFIG_FH_FIRMWARE_LOADER) += fh_fw_loader.o
+
+obj-$(CONFIG_FH_EFUSE)		+= fh_efuse.o
+
 obj-$(CONFIG_DS1682)		+= ds1682.o
 obj-$(CONFIG_TI_DAC7512)	+= ti_dac7512.o
 obj-$(CONFIG_C2PORT)		+= c2port/
@@ -46,3 +56,5 @@
 obj-$(CONFIG_AB8500_PWM)	+= ab8500-pwm.o
 obj-y				+= lis3lv02d/
 obj-y				+= carma/
+obj-$(CONFIG_FH_DMAC_MISC) += fh_dma_miscdev.o
+obj-$(CONFIG_FH_CLK_MISC) += fh_clk_miscdev.o
diff -uraN linux-3.0.8/drivers/mmc/core/core.c linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/core/core.c
--- linux-3.0.8/drivers/mmc/core/core.c	2021-07-14 21:52:02.919133728 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/core/core.c	2021-07-13 23:40:34.030358542 +0300
@@ -1557,6 +1557,9 @@
 }
 EXPORT_SYMBOL(mmc_set_blocklen);
 
+extern struct mmc_host *mmc_sd1;
+extern struct mmc_host *mmc_sd0;
+
 static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
 {
 	host->f_init = freq;
diff -uraN linux-3.0.8/drivers/mmc/core/core.h linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/core/core.h
--- linux-3.0.8/drivers/mmc/core/core.h	2021-07-14 21:52:02.919133728 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/core/core.h	2021-07-13 23:40:34.030358542 +0300
@@ -13,7 +13,7 @@
 
 #include <linux/delay.h>
 
-#define MMC_CMD_RETRIES        3
+#define MMC_CMD_RETRIES        0 //FIXME, by PeterJiang, don't retry...
 
 struct mmc_bus_ops {
 	int (*awake)(struct mmc_host *);
diff -uraN linux-3.0.8/drivers/mmc/core/sd.c linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/core/sd.c
--- linux-3.0.8/drivers/mmc/core/sd.c	2021-07-14 21:52:02.923133739 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/core/sd.c	2021-07-13 23:40:34.038358591 +0300
@@ -305,6 +305,8 @@
 
 		goto out;
 	}
+	if (status[13] & 0x02) //modify by kernel 3.0.101
+				card->sw_caps.hs_max_dtr = 50000000;
 
 	if (card->scr.sda_spec3) {
 		card->sw_caps.sd3_bus_mode = status[13];
@@ -348,11 +350,11 @@
 		}
 
 		card->sw_caps.sd3_curr_limit = status[7];
-	} else {
+	} /*else {//modify by kernel 3.0.101
 		if (status[13] & 0x02)
 			card->sw_caps.hs_max_dtr = 50000000;
 	}
-
+	 */
 out:
 	kfree(status);
 
diff -uraN linux-3.0.8/drivers/mmc/core/sdio.c linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/core/sdio.c
--- linux-3.0.8/drivers/mmc/core/sdio.c	2021-07-14 21:52:02.923133739 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/core/sdio.c	2021-07-13 23:40:34.034358566 +0300
@@ -111,7 +111,7 @@
 
 	cccr_vsn = data & 0x0f;
 
-	if (cccr_vsn > SDIO_CCCR_REV_1_20) {
+	if (cccr_vsn > SDIO_CCCR_REV_3_00) { /* to support SDIO 3.0 (luoc) */
 		printk(KERN_ERR "%s: unrecognised CCCR structure version %d\n",
 			mmc_hostname(card->host), cccr_vsn);
 		return -EINVAL;
@@ -881,3 +881,73 @@
 	return err;
 }
 
+int sdio_reset_comm(struct mmc_card *card)
+{
+	struct mmc_host *host = card->host;
+	u32 ocr;
+	int err;
+	printk("%s():\n", __func__);
+	printk("%s line %d.\n", __FILE__, __LINE__);
+	mmc_claim_host(host);
+	mmc_go_idle(host);
+	mmc_set_clock(host, host->f_min);
+	printk("%s line %d.\n", __FILE__, __LINE__);
+	err = mmc_send_io_op_cond(host, 0, &ocr);
+	if (err)
+		goto err;
+	printk("%s line %d.\n", __FILE__, __LINE__);
+	host->ocr = mmc_select_voltage(host, ocr);
+	if (!host->ocr) {
+		err = -EINVAL;
+		goto err;
+	}
+	printk("%s line %d.\n", __FILE__, __LINE__);
+	err = mmc_send_io_op_cond(host, host->ocr, &ocr);
+	if (err)
+		goto err;
+	if (mmc_host_is_spi(host)) {
+		err = mmc_spi_set_crc(host, use_spi_crc);
+		if (err)
+			goto err;
+	}
+	printk("%s line %d.\n", __FILE__, __LINE__);
+	if (!mmc_host_is_spi(host)) {
+		err = mmc_send_relative_addr(host, &card->rca);
+		if (err)
+			goto err;
+		mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
+	}
+	printk("%s line %d.\n", __FILE__, __LINE__);
+	if (!mmc_host_is_spi(host)) {
+		err = mmc_select_card(card);
+		if (err)
+			goto err;
+	}
+	/*
+	 * Switch to high-speed (if supported).
+	 */
+	printk("%s line %d.\n", __FILE__, __LINE__);
+	err = sdio_enable_hs(card);
+	if (err > 0)
+		mmc_sd_go_highspeed(card);
+	else if (err)
+		goto err;
+	/*
+	 * Change to the card's maximum speed.
+	 */
+	printk("%s line %d.\n", __FILE__, __LINE__);
+	mmc_set_clock(host, mmc_sdio_get_max_clock(card));
+	err = sdio_enable_4bit_bus(card);
+	if (err > 0)
+		mmc_set_bus_width(host, MMC_BUS_WIDTH_4);
+	else if (err)
+		goto err;
+	mmc_release_host(host);
+	return 0;
+err:
+	printk("%s: Error resetting SDIO communications (%d)\n",
+	       mmc_hostname(host), err);
+	mmc_release_host(host);
+	return err;
+}
+EXPORT_SYMBOL(sdio_reset_comm);
diff -uraN linux-3.0.8/drivers/mmc/host/fhmci/fhmci.c linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/host/fhmci/fhmci.c
--- linux-3.0.8/drivers/mmc/host/fhmci/fhmci.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/host/fhmci/fhmci.c	2021-07-13 23:40:34.050358664 +0300
@@ -0,0 +1,1503 @@
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+#include <linux/regulator/consumer.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/sd.h>
+#include <linux/mmc/card.h>
+#include <linux/slab.h>
+
+#include <linux/ioport.h>
+#include <linux/device.h>
+#include <linux/gpio.h>
+
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/kthread.h>
+#include <linux/workqueue.h>
+#include <linux/freezer.h>
+#include <asm/dma.h>
+#include <linux/io.h>
+#include <asm/irq.h>
+#include <asm/sizes.h>
+#include <linux/uaccess.h>
+#include <mach/hardware.h>
+#include <linux/mmc/card.h>
+#include <linux/clk.h>
+#include "fhmci_reg.h"
+#include <mach/fhmci.h>
+
+#include <mach/pmu.h>
+
+
+#ifndef FALSE
+#define FALSE   (0)
+#endif
+
+#ifndef TRUE
+#define TRUE    (!(FALSE))
+#endif
+
+#define SD_POWER_ON   1
+#define SD_POWER_OFF  0
+#define DRIVER_NAME	"fh_mci"
+
+static unsigned int retry_count = MAX_RETRY_COUNT;
+static unsigned int request_timeout = FH_MCI_REQUEST_TIMEOUT;
+int trace_level = FHMCI_TRACE_LEVEL;
+struct mmc_host *mmc_sd1 = NULL;
+struct mmc_host *mmc_sd0 = NULL;
+
+#ifdef MODULE
+
+MODULE_PARM_DESC(detect_timer, "card detect time (default:500ms))");
+
+module_param(retry_count, uint, 0600);
+MODULE_PARM_DESC(retry_count, "retry count times (default:100))");
+
+module_param(request_timeout, uint, 0600);
+MODULE_PARM_DESC(request_timeout, "Request timeout time (default:3s))");
+
+module_param(trace_level, int, 0600);
+MODULE_PARM_DESC(trace_level, "FHMCI_TRACE_LEVEL");
+
+#endif
+
+#include "fhmci_io.c"
+
+/* reset MMC host controler */
+static void fh_mci_sys_reset(struct fhmci_host *host)
+{
+	unsigned int reg_value;
+	unsigned long flags;
+
+	fhmci_trace(2, "reset");
+
+	local_irq_save(flags);
+
+	reg_value = fhmci_readl(host->base + MCI_BMOD);
+	reg_value |= BMOD_SWR;
+	fhmci_writel(reg_value, host->base + MCI_BMOD);
+	udelay(50);
+
+	reg_value = fhmci_readl(host->base + MCI_BMOD);
+	reg_value |= BURST_INCR;
+	fhmci_writel(reg_value, host->base + MCI_BMOD);
+
+	reg_value = fhmci_readl(host->base + MCI_CTRL);
+	reg_value |=  CTRL_RESET | FIFO_RESET | DMA_RESET;
+	fhmci_writel(reg_value, host->base + MCI_CTRL);
+
+	local_irq_restore(flags);
+}
+
+static void fh_mci_sys_undo_reset(struct fhmci_host *host)
+{
+	unsigned long flags;
+
+	fhmci_trace(2, "undo reset");
+
+	local_irq_save(flags);
+	local_irq_restore(flags);
+}
+
+static void fh_mci_ctrl_power(struct fhmci_host *host, unsigned int flag)
+{
+	fhmci_trace(2, "begin");
+
+}
+
+/**********************************************
+ *1: card off
+ *0: card on
+ ***********************************************/
+static unsigned int fh_mci_sys_card_detect(struct fhmci_host *host)
+{
+	unsigned int card_status = readl(host->base + MCI_CDETECT);
+	return card_status & FHMCI_CARD0;
+}
+
+/**********************************************
+ *1: card readonly
+ *0: card read/write
+ ***********************************************/
+static unsigned int fh_mci_ctrl_card_readonly(struct fhmci_host *host)
+{
+	unsigned int card_value = fhmci_readl(host->base + MCI_WRTPRT);
+	return card_value & FHMCI_CARD0;
+}
+
+static int fh_mci_wait_cmd(struct fhmci_host *host)
+{
+	int wait_retry_count = 0;
+	unsigned int reg_data = 0;
+	unsigned long flags;
+
+
+	fhmci_trace(2, "begin");
+	fhmci_assert(host);
+
+	while (1) {
+		/*
+		 * Check if CMD::start_cmd bit is clear.
+		 * start_cmd = 0 means MMC Host controller has loaded registers
+		 * and next command can be loaded in.
+		 */
+		reg_data = readl(host->base + MCI_CMD);
+		if ((reg_data & START_CMD) == 0)
+			return 0;
+
+		/* Check if Raw_Intr_Status::HLE bit is set. */
+		spin_lock_irqsave(&host->lock, flags);
+		reg_data = readl(host->base + MCI_RINTSTS);
+		if (reg_data & HLE_INT_STATUS) {
+			reg_data &= (~SDIO_INT_STATUS);
+			fhmci_writel(reg_data, host->base + MCI_RINTSTS);
+			spin_unlock_irqrestore(&host->lock, flags);
+
+			fhmci_trace(3, "Other CMD is running," \
+					"please operate cmd again!");
+			return 1;
+		}
+
+		spin_unlock_irqrestore(&host->lock, flags);
+		udelay(100);
+
+		/* Check if number of retries for this are over. */
+		wait_retry_count++;
+		if (wait_retry_count >= retry_count) {
+			fhmci_trace(3, "send cmd is timeout!");
+			return -1;
+		}
+	}
+}
+
+static void fh_mci_control_cclk(struct fhmci_host *host, unsigned int flag)
+{
+	unsigned int reg;
+	union cmd_arg_s cmd_reg;
+
+	fhmci_trace(2, "begin");
+	fhmci_assert(host);
+
+	reg = fhmci_readl(host->base + MCI_CLKENA);
+	if (flag == ENABLE)
+		reg |= CCLK_ENABLE;
+	else
+		reg &= 0xffff0000;
+	fhmci_writel(reg, host->base + MCI_CLKENA);
+
+	cmd_reg.cmd_arg = fhmci_readl(host->base + MCI_CMD);
+	cmd_reg.bits.start_cmd = 1;
+	cmd_reg.bits.update_clk_reg_only = 1;
+	fhmci_writel(cmd_reg.cmd_arg, host->base + MCI_CMD);
+	if (fh_mci_wait_cmd(host) != 0)
+		fhmci_trace(3, "disable or enable clk is timeout!");
+}
+
+static void fh_mci_set_cclk(struct fhmci_host *host, unsigned int cclk)
+{
+	unsigned int reg_value;
+	union cmd_arg_s clk_cmd;
+	struct fh_mci_board *pdata;
+
+	fhmci_trace(2, "begin");
+	fhmci_assert(host);
+	fhmci_assert(cclk);
+
+	pdata = host->pdata;
+
+	/*
+	 * set card clk divider value,
+	 * clk_divider = Fmmcclk/(Fmmc_cclk * 2)
+	 */
+
+	if (0 == host->id) {
+		if (pdata->bus_hz <= cclk)
+			reg_value = 0;
+		else {
+			reg_value = pdata->bus_hz / (cclk * 2);
+			if (pdata->bus_hz % (cclk * 2))
+				reg_value++;
+		}
+	} else if (1 == host->id) {
+		if (pdata->bus_hz <= cclk)
+			reg_value = 0;
+		else {
+			reg_value = pdata->bus_hz / (cclk * 2);
+			if (pdata->bus_hz % (cclk * 2))
+				reg_value++;
+		}
+	} else {
+		fhmci_error("fhmci host id error!");
+		return;
+	}
+
+	fhmci_writel(reg_value, host->base + MCI_CLKDIV);
+
+
+	clk_cmd.cmd_arg = fhmci_readl(host->base + MCI_CMD);
+	clk_cmd.bits.start_cmd = 1;
+	clk_cmd.bits.update_clk_reg_only = 1;
+	fhmci_writel(clk_cmd.cmd_arg, host->base + MCI_CMD);
+
+	if (fh_mci_wait_cmd(host) != 0)
+		fhmci_trace(3, "set card clk divider is failed!");
+}
+
+static void fh_mci_init_card(struct fhmci_host *host)
+{
+	unsigned int tmp_reg, tmp;
+	unsigned long flags;
+
+	fhmci_trace(2, "begin");
+	fhmci_assert(host);
+	tmp = fhmci_readl(host->base + MCI_PWREN);
+	fh_mci_sys_reset(host);
+	fh_mci_ctrl_power(host, POWER_OFF);
+	udelay(500);
+	/* card power on */
+	fh_mci_ctrl_power(host, POWER_ON);
+	udelay(200);
+
+	fh_mci_sys_undo_reset(host);
+
+	/* set phase shift */
+	/* set card read threshold */
+
+	/* clear MMC host intr */
+	fhmci_writel(ALL_INT_CLR, host->base + MCI_RINTSTS);
+
+	spin_lock_irqsave(&host->lock, flags);
+	host->pending_events = 0;
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	/* MASK MMC host intr */
+	tmp_reg = fhmci_readl(host->base + MCI_INTMASK);
+	tmp_reg &= ~ALL_INT_MASK;
+	tmp_reg |= DATA_INT_MASK;
+	fhmci_writel(tmp_reg, host->base + MCI_INTMASK);
+
+	/* enable inner DMA mode and close intr of MMC host controler */
+	tmp_reg = fhmci_readl(host->base + MCI_CTRL);
+	tmp_reg &= ~INTR_EN;
+	tmp_reg |= USE_INTERNAL_DMA | INTR_EN;
+	fhmci_writel(tmp_reg, host->base + MCI_CTRL);
+
+	/* set timeout param */
+	fhmci_writel(DATA_TIMEOUT | RESPONSE_TIMEOUT, host->base + MCI_TIMEOUT);
+
+	/* set FIFO param */
+	if (host->pdata->fifo_depth > 15)
+		tmp = 0x5;
+	else
+		tmp = 0x2;
+
+	tmp_reg = ((tmp << 28) | ((host->pdata->fifo_depth / 2) << 16)
+			| (((host->pdata->fifo_depth / 2) + 1) << 0));
+	fhmci_writel(tmp_reg, host->base + MCI_FIFOTH);
+}
+
+int read_mci_ctrl_states(int id_mmc_sd)
+{
+	if ((id_mmc_sd == ID_SD0) && (mmc_sd0 != NULL))
+		return mmc_sd0->rescan_disable;
+	else if ((id_mmc_sd == ID_SD1) && (mmc_sd1 != NULL))
+		return mmc_sd1->rescan_disable;
+
+	return -1;
+}
+
+int storage_dev_set_mmc_rescan(struct mmc_ctrl *m_ctrl)
+{
+	unsigned int tmp;
+	struct mmc_host *mmc_sd = NULL;
+	tmp = m_ctrl->mmc_ctrl_state;
+
+	if (m_ctrl->slot_idx == 1) {
+		if (mmc_sd1 != NULL)
+			mmc_sd = mmc_sd1;
+	} else if (m_ctrl->slot_idx == 0) {
+		if (mmc_sd0 != NULL)
+			mmc_sd = mmc_sd0;
+	}
+	if ((tmp != TRUE) && (tmp != FALSE))
+		return -1;
+
+	if (tmp == TRUE) {
+		if (mmc_sd != NULL) {
+			mmc_sd->rescan_disable = TRUE;
+			mmc_detect_change(mmc_sd, 0);
+		}
+	} else {
+		if (mmc_sd != NULL) {
+			mmc_sd->rescan_disable = FALSE;
+			mmc_detect_change(mmc_sd, 0);
+		}
+	}
+	return 0;
+}
+
+static void fh_mci_idma_start(struct fhmci_host *host)
+{
+	unsigned int tmp;
+
+	fhmci_trace(2, "begin");
+	fhmci_writel(host->dma_paddr, host->base + MCI_DBADDR);
+	tmp = fhmci_readl(host->base + MCI_BMOD);
+	tmp |= BMOD_DMA_EN;
+	fhmci_writel(tmp, host->base + MCI_BMOD);
+}
+
+static void fh_mci_idma_stop(struct fhmci_host *host)
+{
+	unsigned int tmp_reg;
+
+	fhmci_trace(2, "begin");
+	tmp_reg = fhmci_readl(host->base + MCI_BMOD);
+	tmp_reg &= ~BMOD_DMA_EN;
+	fhmci_writel(tmp_reg, host->base + MCI_BMOD);
+}
+
+static int fh_mci_setup_data(struct fhmci_host *host, struct mmc_data *data)
+{
+	unsigned int sg_phyaddr, sg_length;
+	unsigned int i, ret = 0;
+	unsigned int data_size;
+	unsigned int max_des, des_cnt;
+	struct fhmci_des *des;
+
+	fhmci_trace(2, "begin");
+	fhmci_assert(host);
+	fhmci_assert(data);
+
+	host->data = data;
+
+	if (data->flags & MMC_DATA_READ)
+		host->dma_dir = DMA_FROM_DEVICE;
+	else
+		host->dma_dir = DMA_TO_DEVICE;
+
+	host->dma_sg = data->sg;
+	host->dma_sg_num = dma_map_sg(mmc_dev(host->mmc),
+			data->sg, data->sg_len, host->dma_dir);
+	fhmci_assert(host->dma_sg_num);
+	fhmci_trace(2, "host->dma_sg_num is %d\n", host->dma_sg_num);
+	data_size = data->blksz * data->blocks;
+
+	if (data_size > (DMA_BUFFER * MAX_DMA_DES)) {
+		fhmci_error("mci request data_size is too big!\n");
+		ret = -1;
+		goto out;
+	}
+
+	fhmci_trace(2, "host->dma_paddr is 0x%08X,host->dma_vaddr is 0x%08X\n",
+			(unsigned int)host->dma_paddr,
+			(unsigned int)host->dma_vaddr);
+
+	max_des = (PAGE_SIZE/sizeof(struct fhmci_des));
+	des = (struct fhmci_des *)host->dma_vaddr;
+	des_cnt = 0;
+
+	for (i = 0; i < host->dma_sg_num; i++) {
+		sg_length = sg_dma_len(&data->sg[i]);
+		sg_phyaddr = sg_dma_address(&data->sg[i]);
+		fhmci_trace(2, "sg[%d] sg_length is 0x%08X, " \
+				"sg_phyaddr is 0x%08X\n", \
+				i, (unsigned int)sg_length, \
+				(unsigned int)sg_phyaddr);
+		while (sg_length) {
+			des[des_cnt].idmac_des_ctrl = DMA_DES_OWN
+				| DMA_DES_NEXT_DES;
+			des[des_cnt].idmac_des_buf_addr = sg_phyaddr;
+			/* idmac_des_next_addr is paddr for dma */
+			des[des_cnt].idmac_des_next_addr = host->dma_paddr
+				+ (des_cnt + 1) * sizeof(struct fhmci_des);
+
+			if (sg_length >= 0x1F00) {
+				des[des_cnt].idmac_des_buf_size = 0x1F00;
+				sg_length -= 0x1F00;
+				sg_phyaddr += 0x1F00;
+			} else {
+				/* FIXME:data alignment */
+				des[des_cnt].idmac_des_buf_size = sg_length;
+				sg_length = 0;
+			}
+
+			fhmci_trace(2, "des[%d] vaddr  is 0x%08X", i,
+					(unsigned int)&des[i]);
+			fhmci_trace(2, "des[%d].idmac_des_ctrl is 0x%08X",
+			       i, (unsigned int)des[i].idmac_des_ctrl);
+			fhmci_trace(2, "des[%d].idmac_des_buf_size is 0x%08X",
+				i, (unsigned int)des[i].idmac_des_buf_size);
+			fhmci_trace(2, "des[%d].idmac_des_buf_addr 0x%08X",
+				i, (unsigned int)des[i].idmac_des_buf_addr);
+			fhmci_trace(2, "des[%d].idmac_des_next_addr is 0x%08X",
+				i, (unsigned int)des[i].idmac_des_next_addr);
+			des_cnt++;
+		}
+
+		fhmci_assert(des_cnt < max_des);
+	}
+	des[0].idmac_des_ctrl |= DMA_DES_FIRST_DES;
+	des[des_cnt - 1].idmac_des_ctrl |= DMA_DES_LAST_DES;
+	des[des_cnt - 1].idmac_des_next_addr = 0;
+out:
+	return ret;
+}
+
+static int fh_mci_exec_cmd(struct fhmci_host *host, struct mmc_command *cmd,
+		struct mmc_data *data)
+{
+	volatile union cmd_arg_s cmd_regs;
+
+	fhmci_trace(2, "begin");
+	fhmci_assert(host);
+	fhmci_assert(cmd);
+
+	host->cmd = cmd;
+
+	fhmci_writel(cmd->arg, host->base + MCI_CMDARG);
+	fhmci_trace(2, "arg_reg 0x%x, val 0x%x\n", MCI_CMDARG, cmd->arg);
+	cmd_regs.cmd_arg = fhmci_readl(host->base + MCI_CMD);
+	if (data) {
+		cmd_regs.bits.data_transfer_expected = 1;
+		if (data->flags & (MMC_DATA_WRITE | MMC_DATA_READ))
+			cmd_regs.bits.transfer_mode = 0;
+
+		if (data->flags & MMC_DATA_STREAM)
+			cmd_regs.bits.transfer_mode = 1;
+
+		if (data->flags & MMC_DATA_WRITE)
+			cmd_regs.bits.read_write = 1;
+		else if (data->flags & MMC_DATA_READ)
+			cmd_regs.bits.read_write = 0;
+	} else {
+		cmd_regs.bits.data_transfer_expected = 0;
+		cmd_regs.bits.transfer_mode = 0;
+		cmd_regs.bits.read_write = 0;
+	}
+	cmd_regs.bits.send_auto_stop = 0;
+#ifdef CONFIG_SEND_AUTO_STOP
+	if ((host->mrq->stop) && (!(host->is_tuning)))
+		cmd_regs.bits.send_auto_stop = 1;
+#endif
+
+	if (cmd == host->mrq->stop) {
+		cmd_regs.bits.stop_abort_cmd = 1;
+		cmd_regs.bits.wait_prvdata_complete = 0;
+	} else {
+		cmd_regs.bits.stop_abort_cmd = 0;
+		cmd_regs.bits.wait_prvdata_complete = 1;
+	}
+
+	switch (mmc_resp_type(cmd)) {
+	case MMC_RSP_NONE:
+		cmd_regs.bits.response_expect = 0;
+		cmd_regs.bits.response_length = 0;
+		cmd_regs.bits.check_response_crc = 0;
+		break;
+	case MMC_RSP_R1:
+	case MMC_RSP_R1B:
+		cmd_regs.bits.response_expect = 1;
+		cmd_regs.bits.response_length = 0;
+		cmd_regs.bits.check_response_crc = 1;
+		break;
+	case MMC_RSP_R2:
+		cmd_regs.bits.response_expect = 1;
+		cmd_regs.bits.response_length = 1;
+		cmd_regs.bits.check_response_crc = 1;
+		break;
+	case MMC_RSP_R3:
+		cmd_regs.bits.response_expect = 1;
+		cmd_regs.bits.response_length = 0;
+		cmd_regs.bits.check_response_crc = 0;
+		break;
+	default:
+		fhmci_error("fh_mci: unhandled response type %02x\n",
+				mmc_resp_type(cmd));
+		return -EINVAL;
+	}
+
+	fhmci_trace(2, "send cmd of card is cmd->opcode = %d ", cmd->opcode);
+	if (cmd->opcode == MMC_GO_IDLE_STATE)
+		cmd_regs.bits.send_initialization = 1;
+	else
+		cmd_regs.bits.send_initialization = 0;
+	/* CMD 11 check switch voltage */
+	if (cmd->opcode == SD_SWITCH_VOLTAGE)
+		cmd_regs.bits.volt_switch = 1;
+	else
+		cmd_regs.bits.volt_switch = 0;
+
+
+	cmd_regs.bits.card_number = 0;
+	cmd_regs.bits.cmd_index = cmd->opcode;
+	cmd_regs.bits.start_cmd = 1;
+	cmd_regs.bits.update_clk_reg_only = 0;
+	fhmci_writel(DATA_INT_MASK, host->base + MCI_RINTSTS);
+	fhmci_writel(cmd_regs.cmd_arg, host->base + MCI_CMD);
+	fhmci_trace(2, "cmd_reg 0x%x, val 0x%x\n", MCI_CMD, cmd_regs.cmd_arg);
+
+	if (fh_mci_wait_cmd(host) != 0) {
+		fhmci_trace(3, "send card cmd is failed!");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void fh_mci_finish_request(struct fhmci_host *host,
+		struct mmc_request *mrq)
+{
+	fhmci_trace(2, "begin");
+	fhmci_assert(host);
+	fhmci_assert(mrq);
+
+	host->mrq = NULL;
+	host->cmd = NULL;
+	host->data = NULL;
+
+	mmc_request_done(host->mmc, mrq);
+}
+
+static void fh_mci_cmd_done(struct fhmci_host *host, unsigned int stat)
+{
+	unsigned int i;
+	struct mmc_command *cmd = host->cmd;
+
+	fhmci_trace(2, "begin");
+	fhmci_assert(host);
+	fhmci_assert(cmd);
+
+
+	for (i = 0; i < 4; i++) {
+		if (mmc_resp_type(cmd) == MMC_RSP_R2) {
+			cmd->resp[i] = fhmci_readl(host->base +
+					MCI_RESP3 - i * 0x4);
+			/* R2 must delay some time here ,when use UHI card,
+			   need check why */
+			udelay(1000);
+		} else
+			cmd->resp[i] = fhmci_readl(host->base +
+					MCI_RESP0 + i * 0x4);
+	}
+
+	if (stat & RTO_INT_STATUS) {
+		cmd->error = -ETIMEDOUT;
+		fhmci_trace(3, "irq cmd status stat = 0x%x is timeout error!",
+				stat);
+	} else if (stat & (RCRC_INT_STATUS | RE_INT_STATUS)) {
+		cmd->error = -EILSEQ;
+		fhmci_trace(3, "irq cmd status stat = 0x%x is response error!",
+				stat);
+	}
+	host->cmd = NULL;
+}
+
+
+static void fh_mci_data_done(struct fhmci_host *host, unsigned int stat)
+{
+	struct mmc_data *data = host->data;
+
+	fhmci_trace(2, "begin");
+	fhmci_assert(host);
+	fhmci_assert(data);
+
+
+	dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len, host->dma_dir);
+
+	if (stat & (HTO_INT_STATUS | DRTO_INT_STATUS)) {
+		data->error = -ETIMEDOUT;
+		fhmci_trace(3, "irq data status stat = 0x%x is timeout error!",
+				stat);
+	} else if (stat & (EBE_INT_STATUS | SBE_INT_STATUS | FRUN_INT_STATUS
+				| DCRC_INT_STATUS)) {
+#ifndef CONFIG_MACH_FH8830_FPGA
+		data->error = -EILSEQ;
+#endif
+		fhmci_trace(3, "irq data status stat = 0x%x is data error!",
+				stat);
+	}
+
+	if (!data->error)
+		data->bytes_xfered = data->blocks * data->blksz;
+	else
+		data->bytes_xfered = 0;
+
+	host->data = NULL;
+}
+
+
+static int fh_mci_wait_cmd_complete(struct fhmci_host *host)
+{
+	unsigned int cmd_retry_count = 0;
+	unsigned long cmd_jiffies_timeout;
+	unsigned int cmd_irq_reg = 0;
+	struct mmc_command *cmd = host->cmd;
+	unsigned long flags;
+	unsigned int cmd_done = 0;
+
+	fhmci_trace(2, "begin");
+	fhmci_assert(host);
+	fhmci_assert(cmd);
+
+	cmd_jiffies_timeout = jiffies + request_timeout;
+	while (1) {
+
+		do {
+			spin_lock_irqsave(&host->lock, flags);
+			cmd_irq_reg = readl(host->base + MCI_RINTSTS);
+
+			if (cmd_irq_reg & CD_INT_STATUS) {
+				fhmci_writel((CD_INT_STATUS | RTO_INT_STATUS
+					| RCRC_INT_STATUS | RE_INT_STATUS),
+					host->base + MCI_RINTSTS);
+				spin_unlock_irqrestore(&host->lock, flags);
+				cmd_done = 1;
+				break;
+/*				fh_mci_cmd_done(host, cmd_irq_reg);
+				return 0;*/
+			} else if (cmd_irq_reg & VOLT_SWITCH_INT_STATUS) {
+				fhmci_writel(VOLT_SWITCH_INT_STATUS, \
+						host->base + MCI_RINTSTS);
+				spin_unlock_irqrestore(&host->lock, flags);
+				cmd_done = 1;
+				break;
+/*				fh_mci_cmd_done(host, cmd_irq_reg);
+				return 0;*/
+			}
+			spin_unlock_irqrestore(&host->lock, flags);
+			cmd_retry_count++;
+		} while (cmd_retry_count < retry_count &&
+				host->get_cd(host) != CARD_UNPLUGED);
+
+		cmd_retry_count = 0;
+
+		if ((host->card_status == CARD_UNPLUGED)
+			|| (host->get_cd(host) == CARD_UNPLUGED)) {
+			cmd->error = -ETIMEDOUT;
+			return -1;
+		}
+		if (cmd_done) {
+			fh_mci_cmd_done(host, cmd_irq_reg);
+			return 0;
+		}
+
+		if (!time_before(jiffies, cmd_jiffies_timeout)) {
+			unsigned int i = 0;
+			for (i = 0; i < 4; i++) {
+				cmd->resp[i] = fhmci_readl(host->base \
+						+ MCI_RESP0 + i * 0x4);
+				printk(KERN_ERR "voltage switch read MCI_RESP");
+				printk(KERN_ERR "%d : 0x%x\n", i, cmd->resp[i]);
+			}
+			cmd->error = -ETIMEDOUT;
+			fhmci_trace(3, "wait cmd request complete is timeout!");
+			return -1;
+		}
+
+		schedule();
+	}
+}
+/*
+ * designware support send stop command automatically when
+ * read or wirte multi blocks
+ */
+#ifdef CONFIG_SEND_AUTO_STOP
+static int fh_mci_wait_auto_stop_complete(struct fhmci_host *host)
+{
+	unsigned int cmd_retry_count = 0;
+	unsigned long cmd_jiffies_timeout;
+	unsigned int cmd_irq_reg = 0;
+	unsigned long flags;
+
+	fhmci_trace(2, "begin");
+	fhmci_assert(host);
+
+	cmd_jiffies_timeout = jiffies + request_timeout;
+	while (1) {
+
+		do {
+			spin_lock_irqsave(&host->lock, flags);
+			cmd_irq_reg = readl(host->base + MCI_RINTSTS);
+			if (cmd_irq_reg & ACD_INT_STATUS) {
+				fhmci_writel((ACD_INT_STATUS | RTO_INT_STATUS
+					| RCRC_INT_STATUS | RE_INT_STATUS),
+					host->base + MCI_RINTSTS);
+				spin_unlock_irqrestore(&host->lock, flags);
+				return 0;
+			}
+			spin_unlock_irqrestore(&host->lock, flags);
+			cmd_retry_count++;
+		} while (cmd_retry_count < retry_count);
+
+		cmd_retry_count = 0;
+		if (host->card_status == CARD_UNPLUGED)
+			return -1;
+
+		if (!time_before(jiffies, cmd_jiffies_timeout)) {
+			fhmci_trace(3, "wait auto stop complete is timeout!");
+			return -1;
+		}
+
+		schedule();
+	}
+
+}
+#endif
+static int fh_mci_wait_data_complete(struct fhmci_host *host)
+{
+	unsigned int tmp_reg;
+	struct mmc_data *data = host->data;
+	long time = request_timeout;
+	unsigned long flags;
+
+	fhmci_trace(2, "begin");
+	fhmci_assert(host);
+	fhmci_assert(data);
+
+	time = wait_event_timeout(host->intr_wait,
+		test_bit(FHMCI_PEND_DTO_b, &host->pending_events),
+		time);
+
+	/* Mask MMC host data intr */
+	spin_lock_irqsave(&host->lock, flags);
+	tmp_reg = fhmci_readl(host->base + MCI_INTMASK);
+	tmp_reg &= ~DATA_INT_MASK;
+	fhmci_writel(tmp_reg, host->base + MCI_INTMASK);
+	host->pending_events &= ~FHMCI_PEND_DTO_m;
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	if (((time <= 0)
+		&& (!test_bit(FHMCI_PEND_DTO_b, &host->pending_events)))
+		|| (host->card_status == CARD_UNPLUGED)) {
+
+		data->error = -ETIMEDOUT;
+		fhmci_trace(3, "wait data request complete is timeout! 0x%08X",
+				host->irq_status);
+		fh_mci_idma_stop(host);
+		fh_mci_data_done(host, host->irq_status);
+		return -1;
+	}
+
+	fh_mci_idma_stop(host);
+	fh_mci_data_done(host, host->irq_status);
+	return 0;
+}
+
+
+static int fh_mci_wait_card_complete(struct fhmci_host *host,
+		struct mmc_data *data)
+{
+	unsigned int card_retry_count = 0;
+	unsigned long card_jiffies_timeout;
+	unsigned int card_status_reg = 0;
+
+	fhmci_trace(2, "begin");
+	fhmci_assert(host);
+	/* fhmci_assert(data); */
+
+	card_jiffies_timeout = jiffies + request_timeout;
+	while (1) {
+
+		do {
+			card_status_reg = readl(host->base + MCI_STATUS);
+			if (!(card_status_reg & DATA_BUSY)) {
+				fhmci_trace(2, "end");
+				return 0;
+			}
+			card_retry_count++;
+		} while (card_retry_count < retry_count);
+		card_retry_count = 0;
+
+		if (host->card_status == CARD_UNPLUGED) {
+			data->error = -ETIMEDOUT;
+			return -1;
+		}
+
+		if (!time_before(jiffies, card_jiffies_timeout)) {
+			if (data != NULL)
+				data->error = -ETIMEDOUT;
+			fhmci_trace(3, "wait card ready complete is timeout!");
+			return -1;
+		}
+
+		schedule();
+	}
+}
+
+static unsigned long t = 0;
+static unsigned long cmds = 0;
+static unsigned long long send_byte_count = 0;
+static struct timeval in_cmd, out_cmd;
+static struct timeval *x = &out_cmd, *y = &in_cmd;
+static unsigned long max = 0, sum = 0;
+static unsigned long called = 0, ended = 0;
+
+static void fh_mci_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct fhmci_host *host = mmc_priv(mmc);
+	int byte_cnt = 0;
+	#ifdef CONFIG_SEND_AUTO_STOP
+	int trans_cnt;
+	#endif
+	int fifo_count = 0, tmp_reg;
+	int ret = 0;
+	unsigned long flags;
+
+	if (host->id == 1) {
+		called++;
+		memset(x, 0, sizeof(struct timeval));
+		memset(y, 0, sizeof(struct timeval));
+		do_gettimeofday(y);
+	}
+
+	fhmci_trace(2, "begin");
+	fhmci_assert(mmc);
+	fhmci_assert(mrq);
+	fhmci_assert(host);
+
+	host->mrq = mrq;
+	host->irq_status = 0;
+
+
+	if (host->card_status == CARD_UNPLUGED) {
+		mrq->cmd->error = -ENODEV;
+		goto  request_end;
+	}
+#if 1
+	ret = fh_mci_wait_card_complete(host, mrq->data);
+
+	if (ret) {
+		mrq->cmd->error = ret;
+		goto request_end;
+	}
+#endif
+	/* prepare data */
+	if (mrq->data) {
+		ret = fh_mci_setup_data(host, mrq->data);
+		if (ret) {
+			mrq->data->error = ret;
+			fhmci_trace(3, "data setup is error!");
+			goto request_end;
+		}
+
+		byte_cnt = mrq->data->blksz * mrq->data->blocks;
+		fhmci_writel(byte_cnt, host->base + MCI_BYTCNT);
+		fhmci_writel(mrq->data->blksz, host->base + MCI_BLKSIZ);
+
+		tmp_reg = fhmci_readl(host->base + MCI_CTRL);
+		tmp_reg |= FIFO_RESET;
+		fhmci_writel(tmp_reg, host->base + MCI_CTRL);
+
+		do {
+			tmp_reg = fhmci_readl(host->base + MCI_CTRL);
+			fifo_count++;
+			if (fifo_count >= retry_count) {
+				printk(KERN_INFO "fifo reset is timeout!");
+				return;
+			}
+		} while (tmp_reg&FIFO_RESET);
+
+		/* start DMA */
+		fh_mci_idma_start(host);
+	} else {
+		fhmci_writel(0, host->base + MCI_BYTCNT);
+		fhmci_writel(0, host->base + MCI_BLKSIZ);
+	}
+
+	/* send command */
+	ret = fh_mci_exec_cmd(host, mrq->cmd, mrq->data);
+	if (ret) {
+		mrq->cmd->error = ret;
+		fh_mci_idma_stop(host);
+		fhmci_trace(3, "can't send card cmd! ret = %d", ret);
+		goto request_end;
+	}
+
+	/* wait command send complete */
+	ret = fh_mci_wait_cmd_complete(host);
+
+	/* start data transfer */
+	if (mrq->data) {
+		if (!(mrq->cmd->error)) {
+			/* Open MMC host data intr */
+			spin_lock_irqsave(&host->lock, flags);
+			tmp_reg = fhmci_readl(host->base + MCI_INTMASK);
+			tmp_reg |= DATA_INT_MASK;
+			fhmci_writel(tmp_reg, host->base + MCI_INTMASK);
+			spin_unlock_irqrestore(&host->lock, flags);
+		/* wait data transfer complete */
+		ret = fh_mci_wait_data_complete(host);
+		} else {
+			/* CMD error in data command */
+			fh_mci_idma_stop(host);
+		}
+
+		if (mrq->stop) {
+#ifdef CONFIG_SEND_AUTO_STOP
+			trans_cnt = fhmci_readl(host->base + MCI_TCBCNT);
+			/* send auto stop */
+			if ((trans_cnt == byte_cnt) && (!(host->is_tuning))) {
+				fhmci_trace(3, "byte_cnt = %d, trans_cnt = %d",
+						byte_cnt, trans_cnt);
+				ret = fh_mci_wait_auto_stop_complete(host);
+				if (ret) {
+					mrq->stop->error = -ETIMEDOUT;
+					goto request_end;
+				}
+			} else {
+#endif
+				/* send soft stop command */
+				fhmci_trace(3, "this time, send soft stop");
+				ret = fh_mci_exec_cmd(host, host->mrq->stop,
+						host->data);
+				if (ret) {
+					mrq->stop->error = ret;
+					goto request_end;
+				}
+				ret = fh_mci_wait_cmd_complete(host);
+				if (ret)
+					goto request_end;
+#ifdef CONFIG_SEND_AUTO_STOP
+			}
+#endif
+		}
+	}
+
+request_end:
+	/* clear MMC host intr */
+	spin_lock_irqsave(&host->lock, flags);
+	fhmci_writel(ALL_INT_CLR & (~SDIO_INT_STATUS),
+			host->base + MCI_RINTSTS);
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	fh_mci_finish_request(host, mrq);
+
+
+	if (host->id == 1) {
+		ended++;
+		do_gettimeofday(x);
+
+		/* Perform the carry for the later subtraction by updating y. */
+		if (x->tv_usec < y->tv_usec) {
+			int nsec = (y->tv_usec - x->tv_usec) / 1000000 + 1;
+			y->tv_usec -= 1000000 * nsec;
+			y->tv_sec += nsec;
+		}
+		if (x->tv_usec - y->tv_usec > 1000000) {
+			int nsec = (x->tv_usec - y->tv_usec) / 1000000;
+			y->tv_usec += 1000000 * nsec;
+			y->tv_sec -= nsec;
+		}
+		/* Compute the time remaining to wait.
+		 * tv_usec is certainly positive. */
+		if (((x->tv_sec - y->tv_sec) * 1000
+				+ x->tv_usec - y->tv_usec) > max) {
+			max = (x->tv_sec - y->tv_sec)
+					* 1000 + x->tv_usec - y->tv_usec;
+		}
+
+		sum += (x->tv_sec - y->tv_sec) * 1000 + x->tv_usec - y->tv_usec;
+
+		send_byte_count += byte_cnt;
+		cmds++;
+
+		if (jiffies - t > HZ) {
+			/*
+			 * pr_info("SDIO HOST send_byte_count:
+			 * %llu in %u cmds, max cost time: %lu,
+			 * sum: %lu, ave: %lu\ncalled: %lu, ended: %lu\n",
+			 * send_byte_count, cmds, max, sum,
+			 * sum / cmds, called, ended);
+			 */
+			t = jiffies;
+			send_byte_count = 0;
+			cmds = 0;
+			max = 0;
+			sum = 0;
+			called = 0;
+			ended = 0;
+		}
+	}
+}
+
+static void fh_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct fhmci_host *host = mmc_priv(mmc);
+	unsigned int tmp_reg;
+	u32 ctrl;
+
+	fhmci_trace(2, "begin");
+	fhmci_assert(mmc);
+	fhmci_assert(ios);
+	fhmci_assert(host);
+
+	fhmci_trace(3, "ios->power_mode = %d ", ios->power_mode);
+	switch (ios->power_mode) {
+	case MMC_POWER_OFF:
+		/*
+		 * Set controller working voltage as 3.3V before power off.
+		 */
+		ctrl = fhmci_readl(host->base + MCI_UHS_REG);
+		ctrl &= ~FH_SDXC_CTRL_VDD_180;
+		fhmci_trace(3, "set voltage %d[addr 0x%x]", ctrl, MCI_UHS_REG);
+		fhmci_writel(ctrl, host->base + MCI_UHS_REG);
+
+		fh_mci_ctrl_power(host, POWER_OFF);
+		break;
+	case MMC_POWER_UP:
+	case MMC_POWER_ON:
+		fh_mci_ctrl_power(host, POWER_ON);
+		break;
+	}
+	fhmci_trace(3, "ios->clock = %d ", ios->clock);
+	if (ios->clock) {
+
+		fh_mci_control_cclk(host, DISABLE);
+		fh_mci_set_cclk(host, ios->clock);
+		fh_mci_control_cclk(host, ENABLE);
+
+		/* speed mode check ,if it is DDR50 set DDR mode*/
+		if ((ios->timing == MMC_TIMING_UHS_DDR50)) {
+			ctrl = fhmci_readl(host->base + MCI_UHS_REG);
+			if (!(FH_SDXC_CTRL_DDR_REG & ctrl)) {
+				ctrl |= FH_SDXC_CTRL_DDR_REG;
+				fhmci_writel(ctrl, host->base + MCI_UHS_REG);
+			}
+		}
+	} else {
+		fh_mci_control_cclk(host, DISABLE);
+		if ((ios->timing != MMC_TIMING_UHS_DDR50)) {
+			ctrl = fhmci_readl(host->base + MCI_UHS_REG);
+			if (FH_SDXC_CTRL_DDR_REG & ctrl) {
+				ctrl &= ~FH_SDXC_CTRL_DDR_REG;
+				fhmci_writel(ctrl, host->base + MCI_UHS_REG);
+			}
+		}
+	}
+
+	/* set bus_width */
+	fhmci_trace(3, "ios->bus_width = %d ", ios->bus_width);
+	if (ios->bus_width == MMC_BUS_WIDTH_4) {
+		tmp_reg = fhmci_readl(host->base + MCI_CTYPE);
+		tmp_reg |= CARD_WIDTH;
+		fhmci_writel(tmp_reg, host->base + MCI_CTYPE);
+	} else {
+		tmp_reg = fhmci_readl(host->base + MCI_CTYPE);
+		tmp_reg &= ~CARD_WIDTH;
+		fhmci_writel(tmp_reg, host->base + MCI_CTYPE);
+	}
+}
+
+static void fhmci_enable_sdio_irq(struct mmc_host *host, int enable)
+{
+	struct fhmci_host *fh_host = mmc_priv(host);
+	unsigned int reg_value;
+	unsigned long flags;
+
+	if (enable) {
+		local_irq_save(flags);
+
+		reg_value = fhmci_readl(fh_host->base + MCI_INTMASK);
+		reg_value |= 0x10000;
+		fhmci_writel(reg_value, fh_host->base + MCI_INTMASK);
+		local_irq_restore(flags);
+	} else {
+		reg_value = fhmci_readl(fh_host->base + MCI_INTMASK);
+		reg_value &= ~0xffff0000;
+		fhmci_writel(reg_value, fh_host->base + MCI_INTMASK);
+	}
+
+}
+
+
+static int fh_mci_get_ro(struct mmc_host *mmc)
+{
+	unsigned ret;
+	struct fhmci_host *host = mmc_priv(mmc);
+
+	fhmci_trace(2, "begin");
+	fhmci_assert(mmc);
+
+	ret = host->get_ro(host);
+
+	return ret;
+}
+
+/**
+ * @brief get the status of SD card's CD pin
+ *
+ * @param [in] mmc host struct
+ *
+ * @return "1": sd card in the slot, "0": sd card is not in the slot, "2":status of sd card no changed
+ */
+static int fh_mci_get_cd(struct mmc_host *mmc)
+{
+	unsigned int i, curr_status, status[3] = {0}, detect_retry_count = 0;
+	struct fhmci_host *host = mmc_priv(mmc);
+
+	while (1) {
+		for (i = 0; i < 3; i++) {
+			status[i] = host->get_cd(host);
+			udelay(10);
+		}
+		if ((status[0] == status[1]) && (status[0] == status[2]))
+			break;
+
+		detect_retry_count++;
+		if (detect_retry_count >= retry_count) {
+			fhmci_error("this is a dithering,card detect error!");
+			goto err;
+		}
+	}
+	curr_status = status[0];
+	if (curr_status != host->card_status) {
+		host->card_status = curr_status;
+		if (curr_status != CARD_UNPLUGED) {
+			fh_mci_init_card(host);
+			printk(KERN_INFO "card%d connected!\n", host->id);
+			return 1;
+		} else {
+			printk(KERN_INFO "card%d disconnected!\n", host->id);
+			return 0;
+		}
+	}
+	if (mmc->card == NULL)
+		fh_mci_init_card(host);
+err:
+	return 2;
+}
+
+static const struct mmc_host_ops fh_mci_ops = {
+	.request = fh_mci_request,
+	.set_ios = fh_mci_set_ios,
+	.get_ro	 = fh_mci_get_ro,
+	.enable_sdio_irq = fhmci_enable_sdio_irq,
+	.get_cd  = fh_mci_get_cd,
+};
+
+static irqreturn_t hisd_irq(int irq, void *dev_id)
+{
+	struct fhmci_host *host = dev_id;
+	u32 state = 0;
+	int handle = 0;
+
+	state = fhmci_readl(host->base + MCI_RINTSTS);
+
+#ifndef CONFIG_SEND_AUTO_STOP
+	/* bugfix: when send soft stop to SD Card, Host will report
+	   sdio interrupt, This situation needs to be avoided */
+	if ((host->mmc->card != NULL)
+			&& (host->mmc->card->type == MMC_TYPE_SDIO)) {
+#endif
+		if (state & SDIO_INT_STATUS) {
+			if (fhmci_readl(host->base + MCI_INTMASK) & SDIO_INT_STATUS) {
+				fhmci_writel(SDIO_INT_STATUS, host->base + MCI_RINTSTS);
+				mmc_signal_sdio_irq(host->mmc);
+				handle = 1;
+			}
+		}
+#ifndef CONFIG_SEND_AUTO_STOP
+	}
+#endif
+
+	if (state & DATA_INT_MASK) {
+		handle = 1;
+		host->pending_events |= FHMCI_PEND_DTO_m;
+
+		host->irq_status = fhmci_readl(host->base + MCI_RINTSTS);
+		if (host->irq_status & (DCRC_INT_STATUS|SBE_INT_STATUS|EBE_INT_STATUS)) {
+#ifndef CONFIG_MACH_FH8830_FPGA
+			printk(KERN_ERR "SDC CRC error:%08x,.\n",
+				host->irq_status);
+#endif
+		}
+		fhmci_writel(DATA_INT_MASK , host->base + MCI_RINTSTS);
+
+		wake_up(&host->intr_wait);
+	}
+
+	/*if (state & 0x10000) {
+		handle = 1;
+		fhmci_writel(0x10000, host->base + MCI_RINTSTS);
+		mmc_signal_sdio_irq(host->mmc);
+	}*/
+
+	if (handle)
+		return IRQ_HANDLED;
+
+	return IRQ_NONE;
+}
+
+static int __devinit fh_mci_probe(struct platform_device *pdev)
+{
+	struct resource *regs;
+	struct mmc_host *mmc;
+	struct fhmci_host *host = NULL;
+	int ret = 0, irq;
+
+	fhmci_trace(2, "begin");
+	fhmci_assert(pdev);
+
+	mmc = mmc_alloc_host(sizeof(struct fhmci_host), &pdev->dev);
+	if (!mmc) {
+		fhmci_error("no mem for hi mci host controller!\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+	host = mmc_priv(mmc);
+	host->pdata = pdev->dev.platform_data;
+	mmc->ops = &fh_mci_ops;
+	mmc->rescan_disable = FALSE;
+	mmc->f_min = DIV_ROUND_UP(host->pdata->bus_hz, 510);
+	mmc->f_max = host->pdata->bus_hz;
+
+	if (host->pdata->caps)
+		mmc->caps = host->pdata->caps;
+	else
+		mmc->caps = 0;
+
+	mmc->caps |= MMC_CAP_SDIO_IRQ;
+
+	if (0 == pdev->id) {
+		mmc_sd0 = mmc;
+	} else if (1 == pdev->id) {
+		mmc_sd1 = mmc;
+	} else {
+		fhmci_error("fhmci host id error!");
+		goto out;
+	}
+	/* reload by this controller */
+	mmc->max_blk_count = 2048;
+	mmc->max_segs = 1024;
+	mmc->max_seg_size = mmc->max_blk_size * mmc->max_blk_count;
+	mmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;
+
+	mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
+	mmc->ocr = mmc->ocr_avail;
+
+	host->dma_vaddr = dma_alloc_coherent(&pdev->dev, PAGE_SIZE,
+			&host->dma_paddr, GFP_KERNEL);
+	if (!host->dma_vaddr) {
+		fhmci_error("no mem for fhmci dma!\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	host->mmc = mmc;
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!regs) {
+		fhmci_error("request resource error!\n");
+		ret = -ENXIO;
+		goto out;
+	}
+
+	host->id = pdev->id;
+	host->base = ioremap_nocache(regs->start, regs->end - regs->start + 1);
+	if (!host->base) {
+		fhmci_error("no mem for fhmci base!\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (host->pdata->init)
+		host->pdata->init(pdev->id, NULL, NULL);
+
+	if (host->pdata->get_cd)
+		host->get_cd = host->pdata->get_cd;
+	else
+		host->get_cd = fh_mci_sys_card_detect;
+
+	if (host->pdata->get_ro)
+		host->get_ro = host->pdata->get_ro;
+	else
+		host->get_ro = fh_mci_ctrl_card_readonly;
+
+	/* enable mmc clk */
+	fh_mci_sys_ctrl_init(host);
+
+	/* enable card */
+	spin_lock_init(&host->lock);
+	platform_set_drvdata(pdev, mmc);
+	mmc_add_host(mmc);
+
+	fhmci_writel(SD_POWER_ON, host->base + MCI_PWREN);
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		printk(KERN_ERR "no IRQ defined!\n");
+		goto out;
+	}
+
+	init_waitqueue_head(&host->intr_wait);
+
+	host->irq = irq;
+	ret = request_irq(irq, hisd_irq, 0, DRIVER_NAME, host);
+	if (ret) {
+		printk(KERN_ERR "request_irq error!\n");
+		goto out;
+	}
+
+
+	return 0;
+out:
+	if (host) {
+
+		if (host->base)
+			iounmap(host->base);
+
+		if (host->dma_vaddr)
+			dma_free_coherent(&pdev->dev, PAGE_SIZE,
+					host->dma_vaddr, host->dma_paddr);
+	}
+	if (mmc)
+		mmc_free_host(mmc);
+
+	return ret;
+}
+
+/* for wifi Cypress 43438/43455
+ * (Note: sd_id is the sdio index used by wifi)
+ */
+void fh_sdio_card_scan(int sd_id)
+{
+	printk(KERN_ERR "%s-%d mmc_sd0->caps 0x%x mmc_sd1->caps 0x%x\n",
+		__func__, __LINE__, mmc_sd0->caps, mmc_sd1->caps);
+	if (sd_id == 1) {
+		mmc_sd1->caps &= ~MMC_CAP_NEEDS_POLL;
+		mmc_sd1->caps &= ~MMC_CAP_NONREMOVABLE;
+		if (NULL != mmc_sd1) {
+			printk(KERN_ERR "%s-%d, enter\n", __func__, __LINE__);
+			mmc_detect_change(mmc_sd1, 0);
+		}
+		msleep(100);
+		mmc_sd1->caps |= MMC_CAP_NONREMOVABLE;
+	} else if (sd_id == 0) {
+		mmc_sd0->caps &= ~MMC_CAP_NEEDS_POLL;
+		mmc_sd0->caps &= ~MMC_CAP_NONREMOVABLE;
+		if (NULL != mmc_sd0) {
+			printk(KERN_ERR "%s-%d, enter\n", __func__, __LINE__);
+			mmc_detect_change(mmc_sd0, 0);
+		}
+		msleep(100);
+		mmc_sd0->caps |= MMC_CAP_NONREMOVABLE;
+	} else {
+		printk(KERN_ERR "%s-%d, sd_id invalid!\n", __func__, __LINE__);
+	}
+	printk(KERN_ERR "%s-%d mmc_sd0->caps 0x%x mmc_sd1->caps 0x%x\n",
+		__func__, __LINE__, mmc_sd0->caps, mmc_sd1->caps);
+
+	return;
+}
+EXPORT_SYMBOL_GPL(fh_sdio_card_scan);
+
+static int __devexit fh_mci_remove(struct platform_device *pdev)
+{
+	struct mmc_host *mmc = platform_get_drvdata(pdev);
+
+	fhmci_trace(2, "begin");
+	fhmci_assert(pdev);
+
+	platform_set_drvdata(pdev, NULL);
+
+	if (mmc) {
+		struct fhmci_host *host = mmc_priv(mmc);
+
+		free_irq(host->irq, host);
+		mmc_remove_host(mmc);
+		fh_mci_ctrl_power(host, POWER_OFF);
+		fh_mci_control_cclk(host, DISABLE);
+		iounmap(host->base);
+		dma_free_coherent(&pdev->dev, PAGE_SIZE, host->dma_vaddr,
+				host->dma_paddr);
+		mmc_free_host(mmc);
+	}
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int fh_mci_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct mmc_host *mmc = platform_get_drvdata(dev);
+	struct fhmci_host *host;
+	int ret = 0;
+
+	fhmci_trace(2, "begin");
+	fhmci_assert(dev);
+
+	if (mmc) {
+		ret = mmc_suspend_host(mmc);
+
+		host = mmc_priv(mmc);
+	}
+
+	fhmci_trace(2, "end");
+
+	return ret;
+}
+
+static int fh_mci_resume(struct platform_device *dev)
+{
+	struct mmc_host *mmc = platform_get_drvdata(dev);
+	struct fhmci_host *host;
+	int ret = 0;
+
+	fhmci_trace(2, "begin");
+	fhmci_assert(dev);
+
+	if (mmc) {
+		host = mmc_priv(mmc);
+		/* enable mmc clk */
+		fh_mci_sys_ctrl_init(host);
+		/* enable card */
+		fh_mci_init_card(host);
+
+		ret = mmc_resume_host(mmc);
+	}
+
+	fhmci_trace(2, "end");
+
+	return ret;
+}
+#else
+#define fh_mci_suspend	NULL
+#define fh_mci_resume	NULL
+#endif
+
+
+static struct platform_driver fh_mci_driver = {
+	.probe         = fh_mci_probe,
+	.remove        = fh_mci_remove,
+	.suspend       = fh_mci_suspend,
+	.resume        = fh_mci_resume,
+	.driver        = {
+		.name          = DRIVER_NAME,
+	},
+};
+
+static int __init fh_mci_init(void)
+{
+	int ret = 0;
+
+	fhmci_trace(2, "mci init begin");
+
+	ret = platform_driver_register(&fh_mci_driver);
+	if (ret)
+		fhmci_error("Platform driver register is failed!");
+
+	return ret;
+}
+
+static void __exit fh_mci_exit(void)
+{
+	fhmci_trace(2, "begin");
+	platform_driver_unregister(&fh_mci_driver);
+}
+module_init(fh_mci_init);
+module_exit(fh_mci_exit);
+MODULE_LICENSE("GPL");
diff -uraN linux-3.0.8/drivers/mmc/host/fhmci/fhmci_io.c linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/host/fhmci/fhmci_io.c
--- linux-3.0.8/drivers/mmc/host/fhmci/fhmci_io.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/host/fhmci/fhmci_io.c	2021-07-13 23:40:34.050358664 +0300
@@ -0,0 +1,63 @@
+
+#include <mach/clock.h>
+
+#define SIMPLE_0
+//#define SIMPLE_90
+//#define SIMPLE_180
+//#define SIMPLE_270
+
+static int fh_mci_sys_ctrl_init(struct fhmci_host *host)
+{
+
+	struct clk *sdc_clk;
+	u32 pctrl_gpio;
+	u32 drv_shift;
+	u32 sam_shift;
+	int ret;
+	u32 reg;
+	host->pdata->fifo_depth = (fhmci_readl(host->base + MCI_FIFOTH) & 0xfff0000) >> 16;
+	if (host->id == 0) {
+		pctrl_gpio = 5;
+		drv_shift = 20;
+		sam_shift = 16;
+		sdc_clk = clk_get(NULL, "sdc0_clk");
+
+	} else {
+		pctrl_gpio = 6;
+		drv_shift = 12;
+		sam_shift = 8;
+		sdc_clk = clk_get(NULL, "sdc1_clk");
+
+	}
+
+	//Power on.
+	ret = gpio_request(pctrl_gpio, NULL);
+	if (ret) {
+		fhmci_error("gpio requset err!");
+		return ret;
+	}
+	gpio_direction_output(pctrl_gpio, 0);
+	gpio_free(pctrl_gpio);
+
+	//adjust clock phase...
+	clk_enable(sdc_clk);
+	clk_set_rate(sdc_clk, 50000000);
+	reg = clk_get_clk_sel();
+	reg &= ~(3 << drv_shift);
+	reg &= ~(3 << sam_shift);
+	reg |= (2 << drv_shift); //now drv fixed to 180.
+#ifdef SIMPLE_0
+	reg |= (0 << sam_shift);
+#endif
+#ifdef SIMPLE_90
+	reg |= (1 << sam_shift);
+#endif
+#ifdef SIMPLE_180
+	reg |= (2 << sam_shift);
+#endif
+#ifdef SIMPLE_270
+	reg |= (3 << sam_shift);
+#endif
+	clk_set_clk_sel(reg);
+	return 0;
+}
diff -uraN linux-3.0.8/drivers/mmc/host/fhmci/fhmci_reg.h linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/host/fhmci/fhmci_reg.h
--- linux-3.0.8/drivers/mmc/host/fhmci/fhmci_reg.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/host/fhmci/fhmci_reg.h	2021-07-13 23:40:34.046358640 +0300
@@ -0,0 +1,182 @@
+#ifndef _FH_MCI_REG_H_
+#define _FH_MCI_REG_H_
+
+#define MCI_CTRL		0x00
+#define MCI_PWREN		0x04
+#define MCI_CLKDIV		0x08
+#define MCI_CLKSRC		0x0C
+#define MCI_CLKENA		0x10
+#define MCI_TIMEOUT		0x14
+#define MCI_CTYPE		0x18
+#define MCI_BLKSIZ		0x1c
+#define MCI_BYTCNT		0x20
+#define MCI_INTMASK		0x24
+#define MCI_CMDARG		0x28
+#define MCI_CMD			0x2C
+#define MCI_RESP0		0x30
+#define MCI_RESP1		0x34
+#define MCI_RESP2		0x38
+#define MCI_RESP3		0x3C
+#define MCI_MINTSTS		0x40
+#define MCI_RINTSTS		0x44
+#define MCI_STATUS		0x48
+#define MCI_FIFOTH		0x4C
+#define MCI_CDETECT		0x50
+#define MCI_WRTPRT		0x54
+#define MCI_GPIO		0x58
+#define MCI_TCBCNT		0x5C
+#define MCI_TBBCNT		0x60
+#define MCI_DEBNCE		0x64
+#define MCI_USRID		0x68
+#define MCI_VERID		0x6C
+#define MCI_HCON		0x70
+#define MCI_UHS_REG		0x74
+#define MCI_BMOD		0x80
+#define MCI_DBADDR		0x88
+#define MCI_IDSTS		0x8C
+#define MCI_IDINTEN		0x90
+#define MCI_DSCADDR		0x94
+#define MCI_BUFADDR		0x98
+#define MCI_READ_THRESHOLD_SIZE		0x100
+#define MCI_UHS_EXT		0x108
+/* MCI_UHS_REG(0x74) details */
+#define FH_SDXC_CTRL_VDD_180	(1<<0)
+#define FH_SDXC_CTRL_DDR_REG	(1<<16)
+
+/* MCI_BMOD(0x80) details */
+#define BMOD_SWR		(1<<0)
+#define BURST_INCR		(1<<1)
+#define BURST_8			(0x2<<8)
+
+/* MCI_CTRL(0x00) details */
+#define CTRL_RESET             (1<<0)
+#define FIFO_RESET             (1<<1)
+#define DMA_RESET              (1<<2)
+#define INTR_EN                (1<<4)
+#define USE_INTERNAL_DMA       (1<<25)
+
+/* IDMAC DEST1 details */
+#define DMA_BUFFER		0x2000
+#define MAX_DMA_DES		(20480)
+
+/* MCI_CDETECT(0x50) details */
+#define FHMCI_CARD0		(1<<0)
+
+/* MCI_TIMEOUT(0x14) details: */
+/*bit 31-8: data read timeout param*/
+#define DATA_TIMEOUT		(0xffffff<<8)
+
+/* bit 7-0: response timeout param */
+#define RESPONSE_TIMEOUT	0xff
+
+/* bit 0: enable of card clk*/
+#define CCLK_ENABLE		(1<<0)
+
+/* IDMAC DEST0 details */
+#define DMA_DES_OWN		(1<<31)
+#define DMA_DES_NEXT_DES	(1<<4)
+#define DMA_DES_FIRST_DES	(1<<3)
+#define DMA_DES_LAST_DES	(1<<2)
+
+/* MCI_BMOD(0x80) details */
+#define BMOD_DMA_EN		(1<<7)
+
+/* MCI_CTYPE(0x18) details */
+#define CARD_WIDTH		(0x1<<0)
+
+/* MCI_INTMASK(0x24) details:
+   bit 16-1: mask MMC host controller each interrupt
+*/
+#define ALL_INT_MASK				0x1ffff
+#define DTO_INT_MASK				(1<<3)
+
+/* bit[18:16] sampling phase */
+#define CLK_SMPL_PHS_MASK			(7<<16)
+
+/* MCI_CMD(0x2c) details:
+   bit 31: cmd execute or load start param of interface clk bit
+*/
+#define START_CMD		(1<<31)
+
+
+/* MCI_INTSTS(0x44) details */
+/***************************************************************/
+/* bit 16: sdio interrupt status */
+#define SDIO_INT_STATUS		(0x1<<16)
+
+/* bit 15: end-bit error (read)/write no CRC interrupt status */
+#define EBE_INT_STATUS		(0x1<<15)
+
+/* bit 14: auto command done interrupt status */
+#define ACD_INT_STATUS		(0x1<<14)
+
+/* bit 13: start bit error interrupt status */
+#define SBE_INT_STATUS		(0x1<<13)
+
+/* bit 12: hardware locked write error interrupt status */
+#define HLE_INT_STATUS		(0x1<<12)
+
+/* bit 11: FIFO underrun/overrun error interrupt status */
+#define FRUN_INT_STATUS		(0x1<<11)
+
+/* bit 10: data starvation-by-host timeout interrupt status */
+#define HTO_INT_STATUS		(0x1<<10)
+
+/* bit 10: volt_switch to 1.8v for sdxc */
+#define VOLT_SWITCH_INT_STATUS		(0x1<<10)
+
+/* bit 9: data read timeout interrupt status */
+#define DRTO_INT_STATUS		(0x1<<9)
+
+/* bit 8: response timeout interrupt status */
+#define RTO_INT_STATUS		(0x1<<8)
+
+/* bit 7: data CRC error interrupt status */
+#define DCRC_INT_STATUS		(0x1<<7)
+
+/* bit 6: response CRC error interrupt status */
+#define RCRC_INT_STATUS		(0x1<<6)
+
+/* bit 5: receive FIFO data request interrupt status */
+#define RXDR_INT_STATUS		(0x1<<5)
+
+/* bit 4: transmit FIFO data request interrupt status */
+#define TXDR_INT_STATUS		(0x1<<4)
+
+/* bit 3: data transfer Over interrupt status */
+#define DTO_INT_STATUS		(0x1<<3)
+
+/* bit 2: command done interrupt status */
+#define CD_INT_STATUS		(0x1<<2)
+
+/* bit 1: response error interrupt status */
+#define RE_INT_STATUS		(0x1<<1)
+#define DATA_INT_MASK	(DTO_INT_STATUS | DCRC_INT_STATUS \
+		| SBE_INT_STATUS | EBE_INT_STATUS)
+/***************************************************************/
+
+/* MCI_RINTSTS(0x44) details:bit 16-1: clear
+   MMC host controller each interrupt but
+   hardware locked write error interrupt
+*/
+#define ALL_INT_CLR       0x1efff
+
+#define PHASE_SHIFT		0x1030000
+#define READ_THRESHOLD_SIZE	0x2000001
+
+/* MCI_STATUS(0x48) details */
+#define DATA_BUSY		(0x1<<9)
+
+/* MCI_FIFOTH(0x4c) details */
+
+#define BURST_SIZE		(0x2<<28)
+#define RX_WMARK		(0x7<<16)
+#define TX_WMARK		0x8
+
+/*
+#define BURST_SIZE		(0x6<<28)
+#define RX_WMARK		(0x7f<<16)
+#define TX_WMARK		0x80
+*/
+
+#endif
diff -uraN linux-3.0.8/drivers/mmc/host/fhmci/Makefile linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/host/fhmci/Makefile
--- linux-3.0.8/drivers/mmc/host/fhmci/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/host/fhmci/Makefile	2021-07-13 23:40:34.050358664 +0300
@@ -0,0 +1,3 @@
+
+obj-y += fh_mci.o
+fh_mci-y := fhmci.o
diff -uraN linux-3.0.8/drivers/mmc/host/fh_mmc.c linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/host/fh_mmc.c
--- linux-3.0.8/drivers/mmc/host/fh_mmc.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/host/fh_mmc.c	2021-07-13 23:40:34.042358616 +0300
@@ -0,0 +1,2150 @@
+/*
+ * Synopsys DesignWare Multimedia Card Interface driver
+ *  (Based on NXP driver for lpc 31xx)
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ * Copyright (C) 2009, 2010 Imagination Technologies Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/blkdev.h>
+#include <linux/clk.h>
+#include <linux/debugfs.h>
+#define DEBUG
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/scatterlist.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/stat.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+#include <linux/bitops.h>
+#include <linux/regulator/consumer.h>
+#include <linux/proc_fs.h>
+#include <linux/gpio.h>
+
+#include "fh_mmc.h"
+#include "fh_mmc_reg.h"
+
+#define TEST_GPIO		4
+
+#define SDC_DESC_SIZE		(PAGE_SIZE * 2)
+#define T_END 10
+
+/* Common flag combinations */
+#define FH_MCI_DATA_ERROR_FLAGS	(SDMMC_INT_DTO | SDMMC_INT_DCRC | \
+				 SDMMC_INT_HTO | SDMMC_INT_SBE  | \
+				 SDMMC_INT_EBE)
+#define FH_MCI_CMD_ERROR_FLAGS	(SDMMC_INT_RTO | SDMMC_INT_RCRC | \
+				 SDMMC_INT_RESP_ERR)
+#define FH_MCI_ERROR_FLAGS	(FH_MCI_DATA_ERROR_FLAGS | \
+				 FH_MCI_CMD_ERROR_FLAGS  | SDMMC_INT_HLE)
+#define FH_MCI_SEND_STATUS	1
+#define FH_MCI_RECV_STATUS	2
+#define FH_MCI_DMA_THRESHOLD	16
+
+#ifdef CONFIG_MMC_FH_IDMAC
+struct idmac_desc {
+	u32		des0;	/* Control Descriptor */
+#define IDMAC_DES0_DIC	BIT(1)
+#define IDMAC_DES0_LD	BIT(2)
+#define IDMAC_DES0_FD	BIT(3)
+#define IDMAC_DES0_CH	BIT(4)
+#define IDMAC_DES0_ER	BIT(5)
+#define IDMAC_DES0_CES	BIT(30)
+#define IDMAC_DES0_OWN	BIT(31)
+
+	u32		des1;	/* Buffer sizes */
+#define IDMAC_SET_BUFFER1_SIZE(d, s) \
+	((d)->des1 = ((d)->des1 & 0x03ffe000) | ((s) & 0x1fff))
+
+	u32		des2;	/* buffer 1 physical address */
+
+	u32		des3;	/* buffer 2 physical address */
+};
+#endif /* CONFIG_MMC_FH_IDMAC */
+
+/**
+ * struct fh_mci_slot - MMC slot state
+ * @mmc: The mmc_host representing this slot.
+ * @host: The MMC controller this slot is using.
+ * @ctype: Card type for this slot.
+ * @mrq: mmc_request currently being processed or waiting to be
+ *	processed, or NULL when the slot is idle.
+ * @queue_node: List node for placing this node in the @queue list of
+ *	&struct fh_mci.
+ * @clock: Clock rate configured by set_ios(). Protected by host->lock.
+ * @flags: Random state bits associated with the slot.
+ * @id: Number of this slot.
+ * @last_detect_state: Most recently observed card detect state.
+ */
+struct fh_mci_slot {
+	struct mmc_host		*mmc;
+	struct fh_mci		*host;
+
+	u32			ctype;
+
+	struct mmc_request	*mrq;
+	struct list_head	queue_node;
+
+	unsigned int		clock;
+	unsigned long		flags;
+#define FH_MMC_CARD_PRESENT	0
+#define FH_MMC_CARD_NEED_INIT	1
+	int			id;
+	int			last_detect_state;
+};
+
+#if defined(CONFIG_DEBUG_FS)
+static int fh_mci_req_show(struct seq_file *s, void *v)
+{
+	struct fh_mci_slot *slot = s->private;
+	struct mmc_request *mrq;
+	struct mmc_command *cmd;
+	struct mmc_command *stop;
+	struct mmc_data	*data;
+
+	/* Make sure we get a consistent snapshot */
+	spin_lock_bh(&slot->host->lock);
+	mrq = slot->mrq;
+
+	if (mrq) {
+		cmd = mrq->cmd;
+		data = mrq->data;
+		stop = mrq->stop;
+
+		if (cmd)
+			seq_printf(s,
+				   "CMD%u(0x%x) flg %x rsp %x %x %x %x err %d\n",
+				   cmd->opcode, cmd->arg, cmd->flags,
+				   cmd->resp[0], cmd->resp[1], cmd->resp[2],
+				   cmd->resp[2], cmd->error);
+		if (data)
+			seq_printf(s, "DATA %u / %u * %u flg %x err %d\n",
+				   data->bytes_xfered, data->blocks,
+				   data->blksz, data->flags, data->error);
+		if (stop)
+			seq_printf(s,
+				   "CMD%u(0x%x) flg %x rsp %x %x %x %x err %d\n",
+				   stop->opcode, stop->arg, stop->flags,
+				   stop->resp[0], stop->resp[1], stop->resp[2],
+				   stop->resp[2], stop->error);
+	}
+
+	spin_unlock_bh(&slot->host->lock);
+
+	return 0;
+}
+
+static int fh_mci_req_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, fh_mci_req_show, inode->i_private);
+}
+
+static const struct file_operations fh_mci_req_fops = {
+	.owner		= THIS_MODULE,
+	.open		= fh_mci_req_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int fh_mci_regs_show(struct seq_file *s, void *v)
+{
+	seq_printf(s, "STATUS:\t0x%08x\n", SDMMC_STATUS);
+	seq_printf(s, "RINTSTS:\t0x%08x\n", SDMMC_RINTSTS);
+	seq_printf(s, "CMD:\t0x%08x\n", SDMMC_CMD);
+	seq_printf(s, "CTRL:\t0x%08x\n", SDMMC_CTRL);
+	seq_printf(s, "INTMASK:\t0x%08x\n", SDMMC_INTMASK);
+	seq_printf(s, "CLKENA:\t0x%08x\n", SDMMC_CLKENA);
+
+	return 0;
+}
+
+static int fh_mci_regs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, fh_mci_regs_show, inode->i_private);
+}
+
+static const struct file_operations fh_mci_regs_fops = {
+	.owner		= THIS_MODULE,
+	.open		= fh_mci_regs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static void fh_mci_init_debugfs(struct fh_mci_slot *slot)
+{
+	struct mmc_host	*mmc = slot->mmc;
+	struct fh_mci *host = slot->host;
+	struct dentry *root;
+	struct dentry *node;
+
+	root = mmc->debugfs_root;
+	if (!root)
+		return;
+
+	node = debugfs_create_file("regs", S_IRUSR, root, host,
+				   &fh_mci_regs_fops);
+	if (!node)
+		goto err;
+
+	node = debugfs_create_file("req", S_IRUSR, root, slot,
+				   &fh_mci_req_fops);
+	if (!node)
+		goto err;
+
+	node = debugfs_create_u32("state", S_IRUSR, root, (u32 *)&host->state);
+	if (!node)
+		goto err;
+
+	node = debugfs_create_x32("pending_events", S_IRUSR, root,
+				  (u32 *)&host->pending_events);
+	if (!node)
+		goto err;
+
+	node = debugfs_create_x32("completed_events", S_IRUSR, root,
+				  (u32 *)&host->completed_events);
+	if (!node)
+		goto err;
+
+	return;
+
+err:
+	dev_err(&mmc->class_dev, "failed to initialize debugfs for slot\n");
+}
+#endif /* defined(CONFIG_DEBUG_FS) */
+
+
+
+static void fh_mci_set_timeout(struct fh_mci *host)
+{
+	/* timeout (maximum) */
+	mci_writel(host, TMOUT, 0xffffffff);
+}
+
+static u32 fh_mci_prepare_command(struct mmc_host *mmc, struct mmc_command *cmd)
+{
+	struct mmc_data	*data;
+	u32 cmdr;
+	cmd->error = -EINPROGRESS;
+
+	cmdr = cmd->opcode;
+
+	if (cmdr == MMC_STOP_TRANSMISSION)
+		cmdr |= SDMMC_CMD_STOP;
+	else
+		cmdr |= SDMMC_CMD_PRV_DAT_WAIT;
+
+	if (cmd->flags & MMC_RSP_PRESENT) {
+		/* We expect a response, so set this bit */
+		cmdr |= SDMMC_CMD_RESP_EXP;
+		if (cmd->flags & MMC_RSP_136)
+			cmdr |= SDMMC_CMD_RESP_LONG;
+	}
+
+	if (cmd->flags & MMC_RSP_CRC)
+		cmdr |= SDMMC_CMD_RESP_CRC;
+
+	data = cmd->data;
+	if (data) {
+		cmdr |= SDMMC_CMD_DAT_EXP;
+		if (data->flags & MMC_DATA_STREAM)
+			cmdr |= SDMMC_CMD_STRM_MODE;
+		if (data->flags & MMC_DATA_WRITE)
+			cmdr |= SDMMC_CMD_DAT_WR;
+	}
+	cmdr |= SDMMC_CMD_USE_HOLD_REG;
+	return cmdr;
+}
+
+
+static void fh_mci_start_command(struct fh_mci *host,
+				 struct mmc_command *cmd, u32 cmd_flags)
+{
+	host->cmd = cmd;
+	dev_vdbg(&host->pdev->dev,
+		 "start command: ARGR=0x%08x CMDR=0x%08x\n",
+		 cmd->arg, cmd_flags);
+	mci_writel(host, CMDARG, cmd->arg);
+	wmb();
+
+	mci_writel(host, CMD, cmd_flags | SDMMC_CMD_START);
+}
+
+static void send_stop_cmd(struct fh_mci *host, struct mmc_data *data)
+{
+	fh_mci_start_command(host, data->stop, host->stop_cmdr);
+}
+
+/* DMA interface functions */
+static void fh_mci_stop_dma(struct fh_mci *host)
+{
+	if (host->use_dma) {
+		host->dma_ops->stop(host);
+		host->dma_ops->cleanup(host);
+	}
+
+	/* Data transfer was stopped by the interrupt handler */
+	set_bit(EVENT_XFER_COMPLETE, &host->pending_events);
+
+}
+
+#ifdef CONFIG_MMC_FH_IDMAC
+
+
+
+static void fh_mci_idmac_reset(struct fh_mci *host)
+{
+	u32 bmod = mci_readl(host, BMOD);
+	/* Software reset of DMA */
+	bmod |= SDMMC_IDMAC_SWRESET;
+	mci_writel(host, BMOD, bmod);
+
+}
+
+static void fh_mci_dma_cleanup(struct fh_mci *host)
+{
+	struct mmc_data *data = host->data;
+
+	if (data && host->dma_data_mapped)
+		dma_unmap_sg(&host->pdev->dev, data->sg, data->sg_len,
+			     ((data->flags & MMC_DATA_WRITE)
+			      ? DMA_TO_DEVICE : DMA_FROM_DEVICE));
+
+	host->dma_data_mapped =0;
+}
+
+static void fh_mci_idmac_stop_dma(struct fh_mci *host)
+{
+	u32 temp;
+
+	/* Disable and reset the IDMAC interface */
+	temp = mci_readl(host, CTRL);
+	temp &= ~SDMMC_CTRL_USE_IDMAC;
+	temp |= SDMMC_CTRL_DMA_RESET;
+	mci_writel(host, CTRL, temp);
+
+	/* Stop the IDMAC running */
+	temp = mci_readl(host, BMOD);
+	temp &= ~(SDMMC_IDMAC_ENABLE | SDMMC_IDMAC_FB);
+	temp |= SDMMC_IDMAC_SWRESET;
+	mci_writel(host, BMOD, temp);
+}
+
+static void fh_mci_idmac_complete_dma(struct fh_mci *host)
+{
+	struct mmc_data *data = host->data;
+
+	dev_vdbg(&host->pdev->dev, "DMA complete\n");
+
+	host->dma_ops->cleanup(host);
+
+	/*
+	 * If the card was removed, data will be NULL. No point in trying to
+	 * send the stop command or waiting for NBUSY in this case.
+	 */
+	if (data) {
+		set_bit(EVENT_XFER_COMPLETE, &host->pending_events);
+		tasklet_schedule(&host->tasklet);
+	}
+}
+
+static void fh_mci_translate_sglist(struct fh_mci *host, struct mmc_data *data,
+				    unsigned int sg_len)
+{
+	#define DMA_ONE_BUF_SIZE_MAX (0x2000 - 16)
+
+	int i;
+	int num = 0;
+	u32 seglen;
+	struct idmac_desc *desc = host->sg_cpu;
+	struct idmac_desc *ldesc = NULL;
+
+	for (i = 0; i < sg_len; i++) {
+		unsigned int length = sg_dma_len(&data->sg[i]);
+		u32 mem_addr = sg_dma_address(&data->sg[i]);
+
+		while (length > 0) {
+			//FIXME
+			//this should not happen
+			if (++num > host->ring_size) { 
+				panic("%s, line %d, too long DMA transfer!\n", 
+					 __FILE__, __LINE__);
+			}
+
+			seglen = length;
+			if (seglen > DMA_ONE_BUF_SIZE_MAX) {
+				seglen = DMA_ONE_BUF_SIZE_MAX;
+			}
+
+			/* Set the OWN bit and disable interrupts for this descriptor */
+			desc->des0 = IDMAC_DES0_OWN | IDMAC_DES0_DIC | IDMAC_DES0_CH;
+			/* Buffer length */
+			IDMAC_SET_BUFFER1_SIZE(desc, seglen);
+			/* Physical address to DMA to/from */
+			desc->des2 = mem_addr;
+
+			mem_addr += seglen;
+			length -= seglen;
+
+			ldesc = desc++;
+		}
+	}
+
+	/* Set first descriptor */
+	desc = host->sg_cpu;
+	desc->des0 |= IDMAC_DES0_FD;
+
+	/* Set last descriptor */
+	if (ldesc) {
+		ldesc->des0 |= IDMAC_DES0_LD;
+		ldesc->des0 &= ~IDMAC_DES0_DIC;
+	}
+
+	wmb();
+}
+
+static void fh_mci_idmac_start_dma(struct fh_mci *host, unsigned int sg_len)
+{
+	u32 temp;
+
+	fh_mci_translate_sglist(host, host->data, sg_len);
+
+	/* Select IDMAC interface */
+	temp = mci_readl(host, CTRL);
+	temp |= SDMMC_CTRL_USE_IDMAC;
+	mci_writel(host, CTRL, temp);
+
+	wmb();
+
+	/* Enable the IDMAC */
+	temp = mci_readl(host, BMOD);
+	temp |= SDMMC_IDMAC_ENABLE | SDMMC_IDMAC_FB;
+	mci_writel(host, BMOD, temp);
+	/* Start it running */
+	mci_writel(host, PLDMND, 1);
+}
+
+static int fh_mci_idmac_init(struct fh_mci *host)
+{
+	struct idmac_desc *p;
+	int i;
+
+	/* Number of descriptors in the ring buffer */
+	//host->ring_size = PAGE_SIZE / sizeof(struct idmac_desc);
+	host->ring_size = SDC_DESC_SIZE / sizeof(struct idmac_desc);
+
+	/* Forward link the descriptor list */
+	for (i = 0, p = host->sg_cpu; i < host->ring_size - 1; i++, p++)
+		p->des3 = host->sg_dma + (sizeof(struct idmac_desc) * (i + 1));
+
+	/* Set the last descriptor as the end-of-ring descriptor */
+	p->des3 = host->sg_dma;
+	p->des0 = IDMAC_DES0_ER;
+	fh_mci_idmac_reset(host);
+	/* Mask out interrupts - get Tx & Rx complete only */
+	mci_writel(host, IDINTEN, SDMMC_IDMAC_INT_NI | SDMMC_IDMAC_INT_RI |
+		   SDMMC_IDMAC_INT_TI);
+
+	/* Set the descriptor base address */
+	mci_writel(host, DBADDR, host->sg_dma);
+	return 0;
+}
+
+static struct fh_mci_dma_ops fh_mci_idmac_ops = {
+	.init = fh_mci_idmac_init,
+	.start = fh_mci_idmac_start_dma,
+	.stop = fh_mci_idmac_stop_dma,
+	.complete = fh_mci_idmac_complete_dma,
+	.cleanup = fh_mci_dma_cleanup,
+};
+#endif /* CONFIG_MMC_FH_IDMAC */
+
+static int fh_mci_pre_dma_transfer(struct fh_mci *host,
+				   struct mmc_data *data,
+				   bool next)
+{
+	struct scatterlist *sg;
+	unsigned int i, direction, sg_len;
+
+//#define SDIO_DMA
+//#define SDIO_PIO
+
+#ifdef SDIO_PIO
+	return -EINVAL;
+#else
+#ifdef SDIO_DMA
+
+#else
+	/*
+	 * We don't do DMA on "complex" transfers, i.e. with
+	 * non-word-aligned buffers or lengths. Also, we don't bother
+	 * with all the DMA setup overhead for short transfers.
+	 */
+	if (data->blocks * data->blksz < FH_MCI_DMA_THRESHOLD)
+		return -EINVAL;
+	if (data->blksz & 3)
+		return -EINVAL;
+	for_each_sg(data->sg, sg, data->sg_len, i) {
+		if (sg->offset & 3 || sg->length & 3)
+			return -EINVAL;
+	}
+#endif
+#endif
+	if (data->flags & MMC_DATA_READ)
+		direction = DMA_FROM_DEVICE;
+	else
+		direction = DMA_TO_DEVICE;
+
+	sg_len = dma_map_sg(&host->pdev->dev, data->sg, data->sg_len,
+			    direction);
+
+	host->dma_data_mapped = 1;
+	return sg_len;
+}
+
+
+
+static int fh_mci_submit_data_dma(struct fh_mci *host, struct mmc_data *data)
+{
+	int sg_len;
+	u32 temp;
+
+	host->using_dma = 0;
+
+	/* If we don't have a channel, we can't do DMA */
+	if (!host->use_dma)
+		return -ENODEV;
+
+	sg_len = fh_mci_pre_dma_transfer(host, data, 0);
+	if (sg_len < 0) {
+		host->dma_ops->stop(host);
+		return sg_len;
+	}
+
+	host->using_dma = 1;
+
+	dev_vdbg(&host->pdev->dev,
+		 "sd sg_cpu: %#lx sg_dma: %#lx sg_len: %d\n",
+		 (unsigned long)host->sg_cpu, (unsigned long)host->sg_dma,
+		 sg_len);
+
+#if 0
+	//test data blocksize
+	WARN((host->prev_blksz && (host->prev_blksz != data->blksz)),
+			"Block size changed, from %d to %d",
+			host->prev_blksz,
+			data->blksz);
+#endif
+
+	/* Enable the DMA interface */
+	temp = mci_readl(host, CTRL);
+	temp |= SDMMC_CTRL_DMA_ENABLE;
+	mci_writel(host, CTRL, temp);
+
+	/* Disable RX/TX IRQs, let DMA handle it */
+	temp = mci_readl(host, INTMASK);
+	temp  &= ~(SDMMC_INT_RXDR | SDMMC_INT_TXDR);
+	mci_writel(host, INTMASK, temp);
+	host->dma_ops->start(host, sg_len);
+	return 0;
+}
+
+static void fh_mci_submit_data(struct fh_mci *host, struct mmc_data *data)
+{
+	u32 temp;
+	int ret;
+	data->error = -EINPROGRESS;
+
+	WARN_ON(host->data);
+	host->sg = NULL;
+	host->data = data;
+
+	if (data->flags & MMC_DATA_READ)
+		host->dir_status = FH_MCI_RECV_STATUS;
+	else
+		host->dir_status = FH_MCI_SEND_STATUS;
+
+	ret = fh_mci_submit_data_dma(host, data);
+	if (ret) {
+		host->sg = data->sg;
+		host->pio_offset = 0;
+
+		mci_writel(host, RINTSTS, SDMMC_INT_TXDR | SDMMC_INT_RXDR);
+
+		temp = mci_readl(host, INTMASK);
+		temp |= SDMMC_INT_TXDR | SDMMC_INT_RXDR;
+		mci_writel(host, INTMASK, temp);
+		temp = mci_readl(host, CTRL);
+		temp &= ~SDMMC_CTRL_DMA_ENABLE;
+		mci_writel(host, CTRL, temp);
+		host->prev_blksz = 0;
+	}else {
+		/*
+		 * Keep the current block size.
+		 * It will be used to decide whether to update
+		 * fifoth register next time.
+		 */
+		host->prev_blksz = data->blksz;
+	}
+}
+
+static void mci_send_cmd(struct fh_mci_slot *slot, u32 cmd, u32 arg)
+{
+	struct fh_mci *host = slot->host;
+	unsigned long timeout = jiffies + msecs_to_jiffies(500);
+	unsigned int cmd_status = 0;
+
+	mci_writel(host, CMDARG, arg);
+	wmb();
+	mci_writel(host, CMD, SDMMC_CMD_START | cmd);
+
+	while (time_before(jiffies, timeout)) {
+		cmd_status = mci_readl(host, CMD);
+		if (!(cmd_status & SDMMC_CMD_START))
+			return;
+	}
+	dev_err(&slot->mmc->class_dev,
+		"Timeout sending command (cmd %#x arg %#x status %#x)\n",
+		cmd, arg, cmd_status);
+}
+
+static void fh_mci_setup_bus(struct fh_mci_slot *slot)
+{
+	struct fh_mci *host = slot->host;
+	u32 div;
+
+	if (slot->clock != host->current_speed) {
+		if (host->bus_hz % slot->clock)
+			/*
+			 * move the + 1 after the divide to prevent
+			 * over-clocking the card.
+			 */
+			div = ((host->bus_hz / slot->clock) >> 1) + 1;
+		else
+			div = (host->bus_hz  / slot->clock) >> 1;
+
+		dev_info(&slot->mmc->class_dev,
+			 "Bus speed (slot %d) = %dHz (slot req %dHz, actual %dHZ"
+			 " div = %d)\n", slot->id, host->bus_hz, slot->clock,
+			 div ? ((host->bus_hz / div) >> 1) : host->bus_hz, div);
+
+		/* disable clock */
+		mci_writel(host, CLKENA, 0);
+		mci_writel(host, CLKSRC, 0);
+
+		/* inform CIU */
+		mci_send_cmd(slot,
+			     SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT, 0);
+
+		/* set clock to desired speed */
+		mci_writel(host, CLKDIV, div);
+
+		/* inform CIU */
+		mci_send_cmd(slot,
+			     SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT, 0);
+
+		/* enable clock */
+		mci_writel(host, CLKENA, SDMMC_CLKEN_ENABLE |
+			   SDMMC_CLKEN_LOW_PWR);
+
+		/* inform CIU */
+		mci_send_cmd(slot,
+			     SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT, 0);
+
+		host->current_speed = slot->clock;
+	}
+
+	/* Set the current slot bus width */
+	mci_writel(host, CTYPE, slot->ctype);
+}
+
+
+static void fh_mci_start_request(struct fh_mci *host,
+				 struct fh_mci_slot *slot)
+{
+	struct mmc_request *mrq;
+	struct mmc_command *cmd;
+	struct mmc_data	*data;
+	u32 cmdflags;
+
+	mrq = slot->mrq;
+	if (host->pdata->select_slot)
+		host->pdata->select_slot(slot->id);
+	/* Slot specific timing and width adjustment */
+	// do_gettimeofday(&mrq->rq_times[3]);
+	fh_mci_setup_bus(slot);
+	host->cur_slot = slot;
+	host->mrq = mrq;
+
+	host->pending_events = 0;
+	host->completed_events = 0;
+	host->data_status = 0;
+	// do_gettimeofday(&mrq->rq_times[4]);
+	host->data_error_flag = 0;
+	data = mrq->data;
+	if (data) {
+		fh_mci_set_timeout(host);
+		mci_writel(host, BYTCNT, data->blksz*data->blocks);
+		mci_writel(host, BLKSIZ, data->blksz);
+	}
+	// do_gettimeofday(&mrq->rq_times[5]);
+	cmd = mrq->cmd;
+	cmdflags = fh_mci_prepare_command(slot->mmc, cmd);
+	/* this is the first command, send the initialization clock */
+	if (test_and_clear_bit(FH_MMC_CARD_NEED_INIT, &slot->flags))
+		cmdflags |= SDMMC_CMD_INIT;
+	// do_gettimeofday(&mrq->rq_times[6]);
+	if (data) {
+		fh_mci_submit_data(host, data);
+		wmb();
+	}
+	fh_mci_start_command(host, cmd, cmdflags);
+	if (mrq->stop){
+		host->stop_cmdr = fh_mci_prepare_command(slot->mmc, mrq->stop);
+	}
+
+}
+
+
+/* must be called with host->lock held */
+static void fh_mci_queue_request(struct fh_mci *host, struct fh_mci_slot *slot,
+				 struct mmc_request *mrq)
+{
+	dev_vdbg(&slot->mmc->class_dev, "queue request: state=%d\n",
+		 host->state);
+	slot->mrq = mrq;
+
+	if (host->state == STATE_IDLE) {
+		host->state = STATE_SENDING_CMD;
+		fh_mci_start_request(host, slot);
+	} else {
+		list_add_tail(&slot->queue_node, &host->queue);
+
+	}
+}
+
+static void fh_mci_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct fh_mci_slot *slot = mmc_priv(mmc);
+	struct fh_mci *host = slot->host;
+
+	WARN_ON(slot->mrq);
+	/*
+	 * The check for card presence and queueing of the request must be
+	 * atomic, otherwise the card could be removed in between and the
+	 * request wouldn't fail until another card was inserted.
+	 */
+	spin_lock_bh(&host->lock);
+	if (!test_bit(FH_MMC_CARD_PRESENT, &slot->flags)) {
+		spin_unlock_bh(&host->lock);
+		mrq->cmd->error = -ENOMEDIUM;
+		mmc_request_done(mmc, mrq);
+		return;
+	}
+
+	/* We don't support multiple blocks of weird lengths. */
+	fh_mci_queue_request(host, slot, mrq);
+	spin_unlock_bh(&host->lock);
+}
+
+static void fh_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	u32 regs;
+	struct fh_mci_slot *slot = mmc_priv(mmc);
+#if 0
+	struct clk* sdc_clk;
+	int sdc_id = slot->host->pdev->id;
+
+
+	if(sdc_id)
+	{
+		printk("fh_mci_set_ios, clk: %lu\n", ios->clock);
+		sdc_clk = clk_get(NULL, "sdc1_clk");
+		clk_set_rate(sdc_clk,ios->clock);
+	}
+	else
+	{
+		sdc_clk = clk_get(NULL, "sdc0_clk");
+		clk_set_rate(sdc_clk,ios->clock);
+	}
+#endif
+
+	switch (ios->bus_width) {
+	case MMC_BUS_WIDTH_4:
+		slot->ctype = SDMMC_CTYPE_4BIT;
+		break;
+	case MMC_BUS_WIDTH_8:
+		slot->ctype = SDMMC_CTYPE_8BIT;
+		break;
+	default:
+		/* set default 1 bit mode */
+		slot->ctype = SDMMC_CTYPE_1BIT;
+	}
+	/* DDR mode set */
+	if (ios->ddr) {
+		regs = mci_readl(slot->host, UHS_REG);
+		regs |= (0x1 << slot->id) << 16;
+		mci_writel(slot->host, UHS_REG, regs);
+	}
+
+	if (ios->clock) {
+		/*
+		 * Use mirror of ios->clock to prevent race with mmc
+		 * core ios update when finding the minimum.
+		 */
+		slot->clock = ios->clock;
+	}
+
+	switch (ios->power_mode) {
+	case MMC_POWER_UP:
+		set_bit(FH_MMC_CARD_NEED_INIT, &slot->flags);
+		break;
+	default:
+		break;
+	}
+}
+
+static int fh_mci_get_ro(struct mmc_host *mmc)
+{
+	int read_only;
+	struct fh_mci_slot *slot = mmc_priv(mmc);
+	struct fh_mci_board *brd = slot->host->pdata;
+
+	/* Use platform get_ro function, else try on board write protect */
+	if (brd->get_ro)
+		read_only = brd->get_ro(slot->id);
+	else
+		read_only =
+			mci_readl(slot->host, WRTPRT) & (1 << slot->id) ? 1 : 0;
+
+	dev_dbg(&mmc->class_dev, "card is %s\n",
+		read_only ? "read-only" : "read-write");
+
+	return read_only;
+}
+
+static int fh_mci_get_cd(struct mmc_host *mmc)
+{
+	int present;
+	struct fh_mci_slot *slot = mmc_priv(mmc);
+	struct fh_mci_board *brd = slot->host->pdata;
+	struct fh_mci *host = slot->host;
+
+	/* Use platform get_cd function, else try onboard card detect */
+	if (brd->quirks & FH_MCI_QUIRK_BROKEN_CARD_DETECTION)
+		present = 1;
+	else if (brd->get_cd)
+		present = !brd->get_cd(slot->id);
+	else
+		present = (mci_readl(slot->host, CDETECT) & (1 << slot->id))
+			== 0 ? 1 : 0;
+
+	spin_lock_bh(&host->lock);
+	if (present)
+		dev_dbg(&mmc->class_dev, "card is present\n");
+	else
+		dev_dbg(&mmc->class_dev, "card is not present\n");
+	spin_unlock_bh(&host->lock);
+
+	return present;
+}
+
+/*
+ * Disable lower power mode.
+ *
+ * Low power mode will stop the card clock when idle.  According to the
+ * description of the CLKENA register we should disable low power mode
+ * for SDIO cards if we need SDIO interrupts to work.
+ *
+ * This function is fast if low power mode is already disabled.
+ */
+static void fh_mci_disable_low_power(struct fh_mci_slot *slot)
+{
+	struct fh_mci *host = slot->host;
+	u32 clk_en_a;
+	const u32 clken_low_pwr = SDMMC_CLKEN_LOW_PWR << slot->id;
+
+	clk_en_a = mci_readl(host, CLKENA);
+
+	if (clk_en_a & clken_low_pwr) {
+		mci_writel(host, CLKENA, clk_en_a & ~clken_low_pwr);
+		mci_send_cmd(slot, SDMMC_CMD_UPD_CLK |
+			     SDMMC_CMD_PRV_DAT_WAIT, 0);
+	}
+}
+
+static void fh_mci_enable_sdio_irq(struct mmc_host *mmc, int enb)
+{
+	struct fh_mci_slot *slot = mmc_priv(mmc);
+	struct fh_mci *host = slot->host;
+	u32 int_mask;
+
+	/* Enable/disable Slot Specific SDIO interrupt */
+	int_mask = mci_readl(host, INTMASK);
+	if (enb) {
+		/*
+		 * Turn off low power mode if it was enabled.  This is a bit of
+		 * a heavy operation and we disable / enable IRQs a lot, so
+		 * we'll leave low power mode disabled and it will get
+		 * re-enabled again in fh_mci_setup_bus().
+		 */
+		fh_mci_disable_low_power(slot);
+
+		mci_writel(host, INTMASK,
+			   (int_mask | SDMMC_INT_SDIO(slot->id)));
+	} else {
+		mci_writel(host, INTMASK,
+			   (int_mask & ~SDMMC_INT_SDIO(slot->id)));
+	}
+}
+
+
+static const struct mmc_host_ops fh_mci_ops = {
+	.request	= fh_mci_request,
+	.set_ios	= fh_mci_set_ios,
+	.get_ro		= fh_mci_get_ro,
+	.get_cd		= fh_mci_get_cd,
+
+
+	.enable_sdio_irq	= fh_mci_enable_sdio_irq,
+};
+
+static void fh_mci_request_end(struct fh_mci *host, struct mmc_request *mrq)
+	__releases(&host->lock)
+	__acquires(&host->lock)
+{
+	struct fh_mci_slot *slot;
+	struct mmc_host	*prev_mmc = host->cur_slot->mmc;
+
+	if(host->data && host->data->error)
+		printk(KERN_ERR "fh SDC : func request_end\n");
+
+	WARN_ON(host->cmd || host->data);
+
+	host->cur_slot->mrq = NULL;
+	host->mrq = NULL;
+	if (!list_empty(&host->queue)) {
+		slot = list_entry(host->queue.next,
+				  struct fh_mci_slot, queue_node);
+		list_del(&slot->queue_node);
+		dev_vdbg(&host->pdev->dev, "list not empty: %s is next\n",
+			 mmc_hostname(slot->mmc));
+		host->state = STATE_SENDING_CMD;
+		fh_mci_start_request(host, slot);
+	} else {
+		dev_vdbg(&host->pdev->dev, "list empty\n");
+		host->state = STATE_IDLE;
+	}
+
+	spin_unlock(&host->lock);
+	mmc_request_done(prev_mmc, mrq);
+	spin_lock(&host->lock);
+}
+
+static void fh_mci_command_complete(struct fh_mci *host, struct mmc_command *cmd)
+{
+	u32 status = host->cmd_status;
+
+	host->cmd_status = 0;
+
+	/* Read the response from the card (up to 16 bytes) */
+	if (cmd->flags & MMC_RSP_PRESENT) {
+		if (cmd->flags & MMC_RSP_136) {
+			cmd->resp[3] = mci_readl(host, RESP0);
+			cmd->resp[2] = mci_readl(host, RESP1);
+			cmd->resp[1] = mci_readl(host, RESP2);
+			cmd->resp[0] = mci_readl(host, RESP3);
+		} else {
+			cmd->resp[0] = mci_readl(host, RESP0);
+			cmd->resp[1] = 0;
+			cmd->resp[2] = 0;
+			cmd->resp[3] = 0;
+		}
+
+	}
+
+	if (status & SDMMC_INT_RTO)
+		cmd->error = -ETIMEDOUT;
+	else if ((cmd->flags & MMC_RSP_CRC) && (status & SDMMC_INT_RCRC))
+		cmd->error = -EILSEQ;
+	else if (status & SDMMC_INT_RESP_ERR)
+		cmd->error = -EIO;
+	else
+		cmd->error = 0;
+
+	if (cmd->error) {
+		/* newer ip versions need a delay between retries */
+		if (host->quirks & FH_MCI_QUIRK_RETRY_DELAY)
+			mdelay(20);
+
+		if (cmd->data) {
+			host->data = NULL;
+			fh_mci_stop_dma(host);
+		}
+	}
+}
+
+static void fh_mci_tasklet_func(unsigned long priv)
+{
+	struct fh_mci *host = (struct fh_mci *)priv;
+	struct mmc_data	*data;
+	struct mmc_command *cmd;
+	enum fh_mci_state state;
+	enum fh_mci_state prev_state;
+	u32 status;
+
+	spin_lock(&host->lock);
+
+	state = host->state;
+	data = host->data;
+
+	do {
+		prev_state = state;
+
+		switch (state) {
+		case STATE_IDLE:
+			break;
+
+		case STATE_SENDING_CMD:
+			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,
+						&host->pending_events))
+				break;
+
+			cmd = host->cmd;
+			host->cmd = NULL;
+			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);
+			fh_mci_command_complete(host, host->mrq->cmd);
+
+
+			if (!host->mrq->data || cmd->error) {
+				fh_mci_request_end(host, host->mrq);
+				goto unlock;
+			}
+
+			prev_state = state = STATE_SENDING_DATA;
+			/* fall through */
+
+		case STATE_SENDING_DATA:
+			if (test_and_clear_bit(EVENT_DATA_ERROR,
+					       &host->pending_events)) {
+				printk(KERN_ERR "fh SDC : STATE_SENDING_DATA EVENT_DATA_ERROR\n");
+				fh_mci_stop_dma(host);
+				if (data->stop)
+					send_stop_cmd(host, data);
+				state = STATE_DATA_ERROR;
+				break;
+			}
+
+			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,
+						&host->pending_events))
+				break;
+
+			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);
+			prev_state = state = STATE_DATA_BUSY;
+			/* fall through */
+
+		case STATE_DATA_BUSY:
+			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,
+						&host->pending_events))
+				break;
+
+			host->data = NULL;
+			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);
+			status = host->data_status;
+
+			if (status & FH_MCI_DATA_ERROR_FLAGS) {
+				printk(KERN_ERR "fh SDC : STATE_DATA_BUSY\n");
+				if (status & SDMMC_INT_DTO) {
+					dev_err(&host->pdev->dev,
+						"data timeout error\n");
+					data->error = -ETIMEDOUT;
+				} else if (status & SDMMC_INT_DCRC) {
+					dev_err(&host->pdev->dev,
+						"data CRC error\n");
+					data->error = -EILSEQ;
+				} else {
+					dev_err(&host->pdev->dev,
+						"data FIFO error "
+						"(status=%08x)\n",
+						status);
+					data->error = -EIO;
+				}
+			} else {
+				data->bytes_xfered = data->blocks * data->blksz;
+				data->error = 0;
+			}
+
+			if (!data->stop) {
+				fh_mci_request_end(host, host->mrq);
+				goto unlock;
+			}
+
+			prev_state = state = STATE_SENDING_STOP;
+			if (!data->error)
+				send_stop_cmd(host, data);
+			/* fall through */
+
+		case STATE_SENDING_STOP:
+			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,
+						&host->pending_events))
+				break;
+
+			host->cmd = NULL;
+			fh_mci_command_complete(host, host->mrq->stop);
+			fh_mci_request_end(host, host->mrq);
+			goto unlock;
+
+		case STATE_DATA_ERROR:
+			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,
+						&host->pending_events))
+				break;
+			printk(KERN_ERR "fh SDC : STATE_DATA_ERROR\n");
+
+			state = STATE_DATA_BUSY;
+			break;
+		}
+	} while (state != prev_state);
+	host->state = state;
+unlock:
+	spin_unlock(&host->lock);
+	;
+
+}
+
+static void fh_mci_push_data16(struct fh_mci *host, void *buf, int cnt)
+{
+	u16 *pdata = (u16 *)buf;
+
+	WARN_ON(cnt % 2 != 0);
+
+	cnt = cnt >> 1;
+	while (cnt > 0) {
+		mci_writew(host, DATA, *pdata++);
+		cnt--;
+	}
+}
+
+static void fh_mci_pull_data16(struct fh_mci *host, void *buf, int cnt)
+{
+	u16 *pdata = (u16 *)buf;
+
+	WARN_ON(cnt % 2 != 0);
+
+	cnt = cnt >> 1;
+	while (cnt > 0) {
+		*pdata++ = mci_readw(host, DATA);
+		cnt--;
+	}
+}
+
+static void fh_mci_push_data32(struct fh_mci *host, void *buf, int cnt)
+{
+	u32 *pdata = (u32 *)buf;
+
+	WARN_ON(cnt % 4 != 0);
+	WARN_ON((unsigned long)pdata & 0x3);
+
+	cnt = cnt >> 2;
+	while (cnt > 0) {
+		mci_writel(host, DATA, *pdata++);
+		cnt--;
+	}
+}
+
+static void fh_mci_pull_data32(struct fh_mci *host, void *buf, int cnt)
+{
+	u32 *pdata = (u32 *)buf;
+
+	WARN_ON(cnt % 4 != 0);
+	WARN_ON((unsigned long)pdata & 0x3);
+
+	cnt = cnt >> 2;
+	while (cnt > 0) {
+		*pdata++ = mci_readl(host, DATA);
+		cnt--;
+	}
+}
+
+static void fh_mci_push_data64(struct fh_mci *host, void *buf, int cnt)
+{
+	u64 *pdata = (u64 *)buf;
+
+	WARN_ON(cnt % 8 != 0);
+
+	cnt = cnt >> 3;
+	while (cnt > 0) {
+		mci_writeq(host, DATA, *pdata++);
+		cnt--;
+	}
+}
+
+static void fh_mci_pull_data64(struct fh_mci *host, void *buf, int cnt)
+{
+	u64 *pdata = (u64 *)buf;
+
+	WARN_ON(cnt % 8 != 0);
+
+	cnt = cnt >> 3;
+	while (cnt > 0) {
+		*pdata++ = mci_readq(host, DATA);
+		cnt--;
+	}
+}
+
+static void fh_mci_read_data_pio(struct fh_mci *host)
+{
+	struct scatterlist *sg = host->sg;
+	void *buf = sg_virt(sg);
+	unsigned int offset = host->pio_offset;
+	struct mmc_data	*data = host->data;
+	int shift = host->data_shift;
+	u32 status;
+	unsigned int nbytes = 0, len=0;
+
+	do {
+		len = SDMMC_GET_FCNT(mci_readl(host, STATUS)) << shift;
+		if (offset + len <= sg->length) {
+
+			host->pull_data(host, (void *)(buf + offset), len);
+			offset += len;
+			nbytes += len;
+
+			if (offset == sg->length) {
+				flush_dcache_page(sg_page(sg));
+				host->sg = sg = sg_next(sg);
+				if (!sg)
+					goto done;
+
+				offset = 0;
+				buf = sg_virt(sg);
+			}
+		} else {
+			unsigned int remaining = sg->length - offset;
+			host->pull_data(host, (void *)(buf + offset),
+					remaining);
+			nbytes += remaining;
+
+			flush_dcache_page(sg_page(sg));
+			host->sg = sg = sg_next(sg);
+			if (!sg)
+				goto done;
+
+			offset = len - remaining;
+			buf = sg_virt(sg);
+			host->pull_data(host, buf, offset);
+			nbytes += offset;
+		}
+
+		status = mci_readl(host, MINTSTS);
+		mci_writel(host, RINTSTS, SDMMC_INT_RXDR);
+		if (status & FH_MCI_DATA_ERROR_FLAGS) {
+			host->data_status = status;
+			data->bytes_xfered += nbytes;
+			smp_wmb();
+			printk("data error in read pio\n");
+			set_bit(EVENT_DATA_ERROR, &host->pending_events);
+
+			tasklet_schedule(&host->tasklet);
+			return;
+		}
+	} while (status & SDMMC_INT_RXDR); /*if the RXDR is ready read again*/
+	len = SDMMC_GET_FCNT(mci_readl(host, STATUS));
+	host->pio_offset = offset;
+	data->bytes_xfered += nbytes;
+	return;
+
+done:
+	data->bytes_xfered += nbytes;
+	smp_wmb();
+	set_bit(EVENT_XFER_COMPLETE, &host->pending_events);
+}
+
+static void fh_mci_write_data_pio(struct fh_mci *host)
+{
+	struct scatterlist *sg = host->sg;
+	void *buf = sg_virt(sg);
+	unsigned int offset = host->pio_offset;
+	struct mmc_data	*data = host->data;
+	int shift = host->data_shift;
+	u32 status;
+	unsigned int nbytes = 0, len;
+
+	do {
+		len = SDMMC_FIFO_SZ -
+			(SDMMC_GET_FCNT(mci_readl(host, STATUS)) << shift);
+		if (offset + len <= sg->length) {
+			host->push_data(host, (void *)(buf + offset), len);
+
+
+			offset += len;
+			nbytes += len;
+			if (offset == sg->length) {
+				host->sg = sg = sg_next(sg);
+				if (!sg)
+					goto done;
+
+				offset = 0;
+				buf = sg_virt(sg);
+			}
+		} else {
+			unsigned int remaining = sg->length - offset;
+
+			host->push_data(host, (void *)(buf + offset),
+					remaining);
+			nbytes += remaining;
+			host->sg = sg = sg_next(sg);
+			if (!sg)
+				goto done;
+
+			offset = len - remaining;
+			buf = sg_virt(sg);
+			host->push_data(host, (void *)buf, offset);
+			nbytes += offset;
+		}
+
+		status = mci_readl(host, MINTSTS);
+		mci_writel(host, RINTSTS, SDMMC_INT_TXDR);
+		if (status & FH_MCI_DATA_ERROR_FLAGS) {
+			host->data_status = status;
+			data->bytes_xfered += nbytes;
+
+			smp_wmb();
+			printk("data error in write pio\n");
+			set_bit(EVENT_DATA_ERROR, &host->pending_events);
+
+			tasklet_schedule(&host->tasklet);
+			return;
+		}
+	} while (status & SDMMC_INT_TXDR); /* if TXDR write again */
+
+	host->pio_offset = offset;
+	data->bytes_xfered += nbytes;
+	//flag_int = mci_readl(host, INTMASK);
+	//mci_writel(host, INTMASK, flag_int|0x4);
+	return;
+
+done:
+	data->bytes_xfered += nbytes;
+	smp_wmb();
+	set_bit(EVENT_XFER_COMPLETE, &host->pending_events);
+}
+
+static void fh_mci_cmd_interrupt(struct fh_mci *host, u32 status)
+{
+	if (!host->cmd_status)
+		host->cmd_status = status;
+
+	smp_wmb();
+
+	set_bit(EVENT_CMD_COMPLETE, &host->pending_events);
+	tasklet_schedule(&host->tasklet);
+}
+
+
+static irqreturn_t fh_mci_interrupt(int irq, void *dev_id)
+{
+	struct fh_mci *host = dev_id;
+	u32 pending;
+	int i;
+	u32 cmd, arg, rint, resp0, resp1, resp2, resp3;
+	#ifdef SDC_CRC_TEST
+	struct clk *sdc_clk;
+	#endif
+
+	pending = mci_readl(host, MINTSTS); /* read-only mask reg */
+
+	if (pending) {
+		if (pending & FH_MCI_CMD_ERROR_FLAGS) {
+			mci_writel(host, RINTSTS, FH_MCI_CMD_ERROR_FLAGS);
+			host->cmd_status = pending;
+			smp_wmb();
+			set_bit(EVENT_CMD_COMPLETE, &host->pending_events);
+		}
+
+		if (pending & FH_MCI_DATA_ERROR_FLAGS) {
+#ifdef SDC_CRC_TEST
+			gpio_direction_output(TEST_GPIO, 1);
+			__gpio_set_value(TEST_GPIO, 1);
+#endif
+			host->data_error_flag = 1;
+			rint = mci_readl(host, RINTSTS);
+			/* if there is an error report DATA_ERROR */
+			mci_writel(host, RINTSTS, FH_MCI_DATA_ERROR_FLAGS);
+			host->data_status = pending;
+			smp_wmb();
+			cmd = mci_readl(host, CMD);
+			arg = mci_readl(host, CMDARG);
+			printk("data error in interrupt, cmd=0x%x, args=0x%x, rintsts=0x%x\n",
+					cmd, arg, rint);
+
+			resp0 = mci_readl(host, RESP0);
+			resp1 = mci_readl(host, RESP1);
+			resp2 = mci_readl(host, RESP2);
+			resp3 = mci_readl(host, RESP3);
+
+			printk("resp0=0x%x, resp1=0x%x, resp2=0x%x, resp3=0x%x\n",
+					resp0, resp1, resp2, resp3);
+			set_bit(EVENT_DATA_ERROR, &host->pending_events);
+			set_bit(EVENT_DATA_COMPLETE, &host->pending_events);
+#ifdef SDC_CRC_TEST
+			sdc_clk = clk_get(NULL, "sdc0_clk");
+			clk_disable(sdc_clk);
+
+			printk("!!!!!!!!!!!sdc stopped!!!!!!!!!!!!\n");
+			panic("really terrible\n");
+#endif
+			tasklet_schedule(&host->tasklet);
+
+		}
+
+		if (likely(pending & SDMMC_INT_DATA_OVER)) {
+			mci_writel(host, RINTSTS, SDMMC_INT_DATA_OVER);
+			if (!host->data_status)
+				host->data_status = pending;
+			smp_wmb();
+			if (host->dir_status == FH_MCI_RECV_STATUS) {
+				if (host->sg != NULL)
+					fh_mci_read_data_pio(host);
+			}
+			set_bit(EVENT_DATA_COMPLETE, &host->pending_events);
+			tasklet_schedule(&host->tasklet);
+		}
+
+		if (pending & SDMMC_INT_RXDR) {
+			mci_writel(host, RINTSTS, SDMMC_INT_RXDR);
+			if (host->dir_status == FH_MCI_RECV_STATUS && host->sg)
+				fh_mci_read_data_pio(host);
+		}
+
+		if (pending & SDMMC_INT_TXDR) {
+			mci_writel(host, RINTSTS, SDMMC_INT_TXDR);
+			if (host->dir_status == FH_MCI_SEND_STATUS && host->sg)
+				fh_mci_write_data_pio(host);
+		}
+
+		if (likely(pending & SDMMC_INT_CMD_DONE)) {
+			mci_writel(host, RINTSTS, SDMMC_INT_CMD_DONE);
+			fh_mci_cmd_interrupt(host, pending);
+		}
+
+		if (pending & SDMMC_INT_CD) {
+			mci_writel(host, RINTSTS, SDMMC_INT_CD);
+			tasklet_schedule(&host->card_tasklet);
+		}
+
+		/* Handle SDIO Interrupts */
+		for (i = 0; i < host->num_slots; i++) {
+			struct fh_mci_slot *slot = host->slot[i];
+			if (pending & SDMMC_INT_SDIO(i)) {
+				mci_writel(host, RINTSTS, SDMMC_INT_SDIO(i));
+				mmc_signal_sdio_irq(slot->mmc);
+			}
+		}
+
+	}
+#ifdef CONFIG_MMC_FH_IDMAC
+	/* Handle DMA interrupts */
+	pending = mci_readl(host, IDSTS);
+	if (likely(pending & (SDMMC_IDMAC_INT_TI | SDMMC_IDMAC_INT_RI))) {
+		mci_writel(host, IDSTS, SDMMC_IDMAC_INT_TI | SDMMC_IDMAC_INT_RI | SDMMC_IDMAC_INT_NI);
+		set_bit(EVENT_DATA_COMPLETE, &host->pending_events);
+		host->dma_ops->complete(host);
+	}
+#endif
+
+	return IRQ_HANDLED;
+}
+
+static void fh_mci_tasklet_card(unsigned long data)
+{
+	struct fh_mci *host = (struct fh_mci *)data;
+	int i;
+
+	for (i = 0; i < host->num_slots; i++) {
+		struct fh_mci_slot *slot = host->slot[i];
+		struct mmc_host *mmc = slot->mmc;
+		struct mmc_request *mrq;
+		int present;
+		u32 ctrl;
+		present = fh_mci_get_cd(mmc);
+		while (present != slot->last_detect_state) {
+			dev_dbg(&slot->mmc->class_dev, "card %s\n",
+				present ? "inserted" : "removed");
+
+			spin_lock(&host->lock);
+
+			/* Card change detected */
+			slot->last_detect_state = present;
+
+			/* Power up slot */
+			if (present != 0) {
+				if (host->pdata->setpower)
+					host->pdata->setpower(slot->id,
+							      mmc->ocr_avail);
+
+				set_bit(FH_MMC_CARD_PRESENT, &slot->flags);
+			}
+
+			/* Clean up queue if present */
+			mrq = slot->mrq;
+			if (mrq) {
+				if (mrq == host->mrq) {
+					host->data = NULL;
+					host->cmd = NULL;
+
+					switch (host->state) {
+					case STATE_IDLE:
+						break;
+					case STATE_SENDING_CMD:
+						mrq->cmd->error = -ENOMEDIUM;
+						if (!mrq->data)
+							break;
+						/* fall through */
+					case STATE_SENDING_DATA:
+						mrq->data->error = -ENOMEDIUM;
+						fh_mci_stop_dma(host);
+						break;
+					case STATE_DATA_BUSY:
+					case STATE_DATA_ERROR:
+						printk("STATE_DATA_ERROR in tasklet card\n");
+						if (mrq->data->error == -EINPROGRESS)
+							mrq->data->error = -ENOMEDIUM;
+						if (!mrq->stop)
+							break;
+						/* fall through */
+					case STATE_SENDING_STOP:
+						mrq->stop->error = -ENOMEDIUM;
+						break;
+					}
+
+					fh_mci_request_end(host, mrq);
+				} else {
+					list_del(&slot->queue_node);
+					mrq->cmd->error = -ENOMEDIUM;
+					if (mrq->data)
+						mrq->data->error = -ENOMEDIUM;
+					if (mrq->stop)
+						mrq->stop->error = -ENOMEDIUM;
+
+					spin_unlock(&host->lock);
+					mmc_request_done(slot->mmc, mrq);
+					spin_lock(&host->lock);
+				}
+			}
+
+			/* Power down slot */
+			if (present == 0) {
+				if (host->pdata->setpower)
+					host->pdata->setpower(slot->id, 0);
+				clear_bit(FH_MMC_CARD_PRESENT, &slot->flags);
+
+				/*
+				 * Clear down the FIFO - doing so generates a
+				 * block interrupt, hence setting the
+				 * scatter-gather pointer to NULL.
+				 */
+				host->sg = NULL;
+
+				ctrl = mci_readl(host, CTRL);
+				ctrl |= SDMMC_CTRL_FIFO_RESET;
+				mci_writel(host, CTRL, ctrl);
+
+#ifdef CONFIG_MMC_FH_IDMAC
+				ctrl = mci_readl(host, BMOD);
+				ctrl |= SDMMC_IDMAC_SWRESET; /* Software reset of DMA */
+				mci_writel(host, BMOD, ctrl);
+#endif
+
+			}
+
+			spin_unlock(&host->lock);
+			present = fh_mci_get_cd(mmc);
+		}
+
+		mmc_detect_change(slot->mmc,
+			msecs_to_jiffies(host->pdata->detect_delay_ms));
+	}
+}
+
+static int __init fh_mci_init_slot(struct fh_mci *host, unsigned int id)
+{
+	struct mmc_host *mmc;
+	struct fh_mci_slot *slot;
+
+	mmc = mmc_alloc_host(sizeof(struct fh_mci_slot), &host->pdev->dev);
+	if (!mmc)
+		return -ENOMEM;
+
+	slot = mmc_priv(mmc);
+	slot->id = id;
+	slot->mmc = mmc;
+	slot->host = host;
+
+	mmc->ops = &fh_mci_ops;
+	mmc->f_min = DIV_ROUND_UP(host->bus_hz, 510);
+	mmc->f_max = 50000000;//12500000;
+
+	if (host->pdata->get_ocr)
+		mmc->ocr_avail = host->pdata->get_ocr(id);
+	else
+		mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
+
+	/*
+	 * Start with slot power disabled, it will be enabled when a card
+	 * is detected.
+	 */
+	if (host->pdata->setpower)
+		host->pdata->setpower(id, 0);
+
+	if (host->pdata->caps)
+		mmc->caps = host->pdata->caps;
+	else
+		mmc->caps = 0;
+
+	if (host->pdata->get_bus_wd)
+		if (host->pdata->get_bus_wd(slot->id) >= 4)
+			mmc->caps |= MMC_CAP_4_BIT_DATA;
+
+	if (host->pdata->quirks & FH_MCI_QUIRK_HIGHSPEED)
+		mmc->caps |= MMC_CAP_SD_HIGHSPEED;
+
+#ifdef CONFIG_MMC_FH_IDMAC
+	/* Useful defaults if platform data is unset. */
+	mmc->max_segs = 64;
+	mmc->max_blk_size = 65536; /* BLKSIZ is 16 bits */
+	mmc->max_blk_count = 512;
+	mmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;
+	mmc->max_seg_size = mmc->max_req_size;
+#else
+	if (host->pdata->blk_settings) {
+		mmc->max_segs = host->pdata->blk_settings->max_segs;
+		mmc->max_blk_size = host->pdata->blk_settings->max_blk_size;
+		mmc->max_blk_count = host->pdata->blk_settings->max_blk_count;
+		mmc->max_req_size = host->pdata->blk_settings->max_req_size;
+		mmc->max_seg_size = host->pdata->blk_settings->max_seg_size;
+	} else {
+		/* Useful defaults if platform data is unset. */
+		mmc->max_segs = 64;
+		mmc->max_blk_size = 65536; /* BLKSIZ is 16 bits */
+		mmc->max_blk_count = 512;
+		mmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;
+		mmc->max_seg_size = mmc->max_req_size;
+	}
+#endif /* CONFIG_MMC_FH_IDMAC */
+
+	host->vmmc = regulator_get(mmc_dev(mmc), "vmmc");
+	if (IS_ERR(host->vmmc)) {
+		host->vmmc = NULL;
+	} else
+		regulator_enable(host->vmmc);
+
+	if (fh_mci_get_cd(mmc))
+		set_bit(FH_MMC_CARD_PRESENT, &slot->flags);
+	else
+		clear_bit(FH_MMC_CARD_PRESENT, &slot->flags);
+
+	host->slot[id] = slot;
+	mmc_add_host(mmc);
+
+#if defined(CONFIG_DEBUG_FS)
+	fh_mci_init_debugfs(slot);
+#endif
+
+	/* Card initially undetected */
+	slot->last_detect_state = 0;
+
+	/*
+	 * Card may have been plugged in prior to boot so we
+	 * need to run the detect tasklet
+	 */
+	tasklet_schedule(&host->card_tasklet);
+
+	return 0;
+}
+
+static void fh_mci_cleanup_slot(struct fh_mci_slot *slot, unsigned int id)
+{
+	/* Shutdown detect IRQ */
+	if (slot->host->pdata->exit)
+		slot->host->pdata->exit(id);
+
+	/* Debugfs stuff is cleaned up by mmc core */
+	mmc_remove_host(slot->mmc);
+	slot->host->slot[id] = NULL;
+	mmc_free_host(slot->mmc);
+}
+
+static void fh_mci_init_dma(struct fh_mci *host)
+{
+	/* Alloc memory for sg translation */
+	host->sg_cpu = dma_alloc_coherent(&host->pdev->dev, SDC_DESC_SIZE,
+					  &host->sg_dma, GFP_KERNEL);
+	if (!host->sg_cpu) {
+		dev_err(&host->pdev->dev, "%s: could not alloc DMA memory\n",
+			__func__);
+		goto no_dma;
+	}
+
+	/* Determine which DMA interface to use */
+#ifdef CONFIG_MMC_FH_IDMAC
+	host->dma_ops = &fh_mci_idmac_ops;
+	dev_info(&host->pdev->dev, "Using internal DMA controller.\n");
+#endif
+
+	if (!host->dma_ops)
+		goto no_dma;
+
+	if (host->dma_ops->init) {
+		if (host->dma_ops->init(host)) {
+			dev_err(&host->pdev->dev, "%s: Unable to initialize "
+				"DMA Controller.\n", __func__);
+			goto no_dma;
+		}
+	} else {
+		dev_err(&host->pdev->dev, "DMA initialization not found.\n");
+		goto no_dma;
+	}
+
+	host->use_dma = 1;
+	return;
+
+no_dma:
+	dev_info(&host->pdev->dev, "Using PIO mode.\n");
+	host->use_dma = 0;
+	return;
+}
+
+static bool mci_wait_reset(struct device *dev, struct fh_mci *host)
+{
+	unsigned long timeout = jiffies + msecs_to_jiffies(500);
+	unsigned int ctrl;
+
+	mci_writel(host, CTRL, (SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET |
+				SDMMC_CTRL_DMA_RESET));
+
+	/* wait till resets clear */
+	do {
+		ctrl = mci_readl(host, CTRL);
+		if (!(ctrl & (SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET |
+			      SDMMC_CTRL_DMA_RESET)))
+			return true;
+	} while (time_before(jiffies, timeout));
+
+	dev_err(dev, "Timeout resetting block (ctrl %#x)\n", ctrl);
+
+	return false;
+}
+
+static int fh_mci_probe(struct platform_device *pdev)
+{
+	struct fh_mci *host;
+	struct resource	*regs;
+	struct fh_mci_board *pdata;
+	int irq, ret, i, width;
+	u32 fifo_size;
+	u32 reg;
+	struct clk *sdc_clk;
+
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!regs)
+		return -ENXIO;
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return irq;
+
+	host = kzalloc(sizeof(struct fh_mci), GFP_KERNEL);
+	if (!host)
+		return -ENOMEM;
+
+	host->pdev = pdev;
+	host->pdata = pdata = pdev->dev.platform_data;
+	if (!pdata || !pdata->init) {
+		dev_err(&pdev->dev,
+			"Platform data must supply init function\n");
+		ret = -ENODEV;
+		goto err_freehost;
+	}
+
+	if (!pdata->select_slot && pdata->num_slots > 1) {
+		dev_err(&pdev->dev,
+			"Platform data must supply select_slot function\n");
+		ret = -ENODEV;
+		goto err_freehost;
+	}
+
+	if (!pdata->bus_hz) {
+		dev_err(&pdev->dev,
+			"Platform data must supply bus speed\n");
+		ret = -ENODEV;
+		goto err_freehost;
+	}
+
+	host->bus_hz = pdata->bus_hz;
+	host->quirks = pdata->quirks;
+
+	spin_lock_init(&host->lock);
+	INIT_LIST_HEAD(&host->queue);
+
+	pdata->init(pdev->id, NULL, NULL);
+
+	ret = -ENOMEM;
+	//enable clk
+
+	if(pdev->id){
+		ret = gpio_request(6, NULL);
+		if(ret){
+			printk("gpio requset err\n");
+		        ret = -ENODEV;
+		        return ret;
+		}
+		gpio_direction_output(6,0);//set power on
+		sdc_clk = clk_get(NULL, "sdc1_clk");
+		clk_enable(sdc_clk);
+//		*(int *)0xfe900020 =0x100000;//wait for modify
+
+		clk_set_rate(sdc_clk,50000000);
+		reg = clk_get_clk_sel();
+		reg |=1<<12;
+		reg &=~(1<<13);
+		clk_set_clk_sel(reg);
+	}
+	else
+	{
+		ret = gpio_request(5, NULL);
+		if(ret){
+			printk("gpio requset err\n");
+		        ret = -ENODEV;
+		        return ret;
+		}
+		gpio_direction_output(5,0);//set power on
+		sdc_clk = clk_get(NULL, "sdc0_clk");
+		clk_enable(sdc_clk);
+
+		clk_set_rate(sdc_clk,50000000);
+		reg = clk_get_clk_sel();
+		reg |=1<<20;
+		reg &=~(1<<21);
+
+#define SIMPLE_0
+//#define SIMPLE_90
+//#define SIMPLE_180
+//#define SIMPLE_270
+
+#ifdef SIMPLE_0
+		//0
+		reg &=~(1<<17);
+		reg &=~(1<<16);
+#endif
+#ifdef SIMPLE_90
+		//90
+		reg |=(1<<16);
+		reg &=~(1<<17);
+#endif
+#ifdef SIMPLE_180
+		//180
+		reg &=~(1<<16);
+		reg |=(1<<17);
+#endif
+#ifdef SIMPLE_270
+		//270
+		reg |=(1<<17);
+		reg |=(1<<16);
+#endif
+		clk_set_clk_sel(reg);
+
+	}
+
+	//io_remap
+	host->regs = ioremap(regs->start, regs->end - regs->start + 1);
+	//host->regs = 0xfe700000;
+	if (!host->regs)
+		goto err_freehost;
+
+	//host->dma_ops = pdata->dma_ops;
+	fh_mci_init_dma(host);
+
+	/*
+	 * Get the host data width - this assumes that HCON has been set with
+	 * the correct values.
+	 */
+	i = (mci_readl(host, HCON) >> 7) & 0x7;
+	if (!i) {
+		host->push_data = fh_mci_push_data16;
+		host->pull_data = fh_mci_pull_data16;
+		width = 16;
+		host->data_shift = 1;
+	} else if (i == 2) {
+		host->push_data = fh_mci_push_data64;
+		host->pull_data = fh_mci_pull_data64;
+		width = 64;
+		host->data_shift = 3;
+	} else {
+		/* Check for a reserved value, and warn if it is */
+		WARN((i != 1),
+
+		     "HCON reports a reserved host data width!\n"
+		     "Defaulting to 32-bit access.\n");
+		host->push_data = fh_mci_push_data32;
+		host->pull_data = fh_mci_pull_data32;
+		width = 32;
+		host->data_shift = 2;
+	}
+
+	/* Reset all blocks */
+	if (!mci_wait_reset(&pdev->dev, host)) {
+		ret = -ENODEV;
+		goto err_dmaunmap;
+	}
+
+	/* Clear the interrupts for the host controller */
+	mci_writel(host, RINTSTS, 0xFFFFFFFF);
+	mci_writel(host, INTMASK, 0); /* disable all mmc interrupt first */
+
+	/* Put in max timeout */
+	mci_writel(host, TMOUT, 0xFFFFFFFF);
+
+	/*
+	 * FIFO threshold settings  RxMark  = fifo_size / 2 - 1,
+	 *                          Tx Mark = fifo_size / 2 DMA Size = 8
+	 */
+	fifo_size = mci_readl(host, FIFOTH);
+	fifo_size = 1+((fifo_size >> 16) & 0x7ff);
+	host->fifoth_val =
+			SDMMC_SET_FIFOTH(0x2, fifo_size / 2 - 1, fifo_size / 2);
+	mci_writel(host, FIFOTH, host->fifoth_val);
+
+	/* disable clock to CIU */
+	mci_writel(host, CLKENA, 0);
+	mci_writel(host, CLKSRC, 0);
+
+	tasklet_init(&host->tasklet, fh_mci_tasklet_func, (unsigned long)host);
+	tasklet_init(&host->card_tasklet,
+		     fh_mci_tasklet_card, (unsigned long)host);
+
+	ret = request_irq(irq, fh_mci_interrupt, 0, "fh-mci", host);
+	if (ret)
+		goto err_dmaunmap;
+
+	platform_set_drvdata(pdev, host);
+
+	if (host->pdata->num_slots)
+		host->num_slots = host->pdata->num_slots;
+	else
+		host->num_slots = ((mci_readl(host, HCON) >> 1) & 0x1F) + 1;
+
+	/* We need at least one slot to succeed */
+	for (i = 0; i < host->num_slots; i++) {
+		ret = fh_mci_init_slot(host, i);
+		if (ret) {
+			ret = -ENODEV;
+			goto err_init_slot;
+		}
+	}
+
+	/*
+	 * Enable interrupts for command done, data over, data empty, card det,
+	 * receive ready and error such as transmit, receive timeout, crc error
+	 */
+	mci_writel(host, RINTSTS, 0xFFFFFFFF);
+	mci_writel(host, INTMASK, SDMMC_INT_CMD_DONE | SDMMC_INT_DATA_OVER |SDMMC_INT_RTO | SDMMC_INT_DTO |
+		   SDMMC_INT_TXDR | SDMMC_INT_RXDR |
+		   FH_MCI_ERROR_FLAGS | SDMMC_INT_CD);
+	mci_writel(host, CTRL, SDMMC_CTRL_INT_ENABLE); /* Enable mci interrupt */
+
+	dev_info(&pdev->dev, "FH MMC controller at irq %d, "
+		 "%d bit host data width\n", irq, width);
+	if (host->quirks & FH_MCI_QUIRK_IDMAC_DTO)
+		dev_info(&pdev->dev, "Internal DMAC interrupt fix enabled.\n");
+#ifdef SDC_CRC_TEST
+	ret = gpio_request(TEST_GPIO, "SDC_TEST");
+
+	if(ret)
+	{
+		printk("!!!!!!!!!!SDC gpio_request failed!!!!!!!!!\n");
+	}
+
+	gpio_direction_output(TEST_GPIO, 1);
+	__gpio_set_value(TEST_GPIO, 0);
+#endif
+	return 0;
+
+err_init_slot:
+	/* De-init any initialized slots */
+	while (i > 0) {
+		if (host->slot[i])
+			fh_mci_cleanup_slot(host->slot[i], i);
+		i--;
+	}
+	free_irq(irq, host);
+
+err_dmaunmap:
+	if (host->use_dma && host->dma_ops->exit)
+		host->dma_ops->exit(host);
+	dma_free_coherent(&host->pdev->dev, PAGE_SIZE,
+			  host->sg_cpu, host->sg_dma);
+	//iounmap(host->regs);
+
+	if (host->vmmc) {
+		regulator_disable(host->vmmc);
+		regulator_put(host->vmmc);
+	}
+
+
+err_freehost:
+	kfree(host);
+	return ret;
+}
+
+static int __exit fh_mci_remove(struct platform_device *pdev)
+{
+	struct fh_mci *host = platform_get_drvdata(pdev);
+	int i;
+
+	mci_writel(host, RINTSTS, 0xFFFFFFFF);
+	mci_writel(host, INTMASK, 0); /* disable all mmc interrupt first */
+
+	platform_set_drvdata(pdev, NULL);
+
+	for (i = 0; i < host->num_slots; i++) {
+		dev_dbg(&pdev->dev, "remove slot %d\n", i);
+		if (host->slot[i])
+			fh_mci_cleanup_slot(host->slot[i], i);
+	}
+
+	/* disable clock to CIU */
+	mci_writel(host, CLKENA, 0);
+	mci_writel(host, CLKSRC, 0);
+
+	free_irq(platform_get_irq(pdev, 0), host);
+	dma_free_coherent(&pdev->dev, SDC_DESC_SIZE, host->sg_cpu, host->sg_dma);
+
+	if (host->use_dma && host->dma_ops->exit)
+		host->dma_ops->exit(host);
+
+	if (host->vmmc) {
+		regulator_disable(host->vmmc);
+		regulator_put(host->vmmc);
+	}
+
+	//iounmap(host->regs);
+#ifdef SDC_CRC_TEST
+	gpio_free(TEST_GPIO);
+#endif
+
+	kfree(host);
+	return 0;
+}
+
+#if CONFIG_PM
+/*
+ * TODO: we should probably disable the clock to the card in the suspend path.
+ */
+static int fh_mci_suspend(struct platform_device *pdev, pm_message_t mesg)
+{
+	int i, ret;
+	struct fh_mci *host = platform_get_drvdata(pdev);
+
+	for (i = 0; i < host->num_slots; i++) {
+		struct fh_mci_slot *slot = host->slot[i];
+		if (!slot)
+			continue;
+		ret = mmc_suspend_host(slot->mmc);
+		if (ret < 0) {
+			while (--i >= 0) {
+				slot = host->slot[i];
+				if (slot)
+					mmc_resume_host(host->slot[i]->mmc);
+			}
+			return ret;
+		}
+	}
+
+	if (host->vmmc)
+		regulator_disable(host->vmmc);
+
+	return 0;
+}
+
+static int fh_mci_resume(struct platform_device *pdev)
+{
+	int i, ret;
+	struct fh_mci *host = platform_get_drvdata(pdev);
+
+	if (host->vmmc)
+		regulator_enable(host->vmmc);
+
+	if (host->dma_ops->init)
+		host->dma_ops->init(host);
+
+	if (!mci_wait_reset(&pdev->dev, host)) {
+		ret = -ENODEV;
+		return ret;
+	}
+
+	/* Restore the old value at FIFOTH register */
+	mci_writel(host, FIFOTH, host->fifoth_val);
+
+	mci_writel(host, RINTSTS, 0xFFFFFFFF);
+	mci_writel(host, INTMASK, SDMMC_INT_CMD_DONE | SDMMC_INT_DATA_OVER |SDMMC_INT_RTO | SDMMC_INT_DTO |
+		   SDMMC_INT_TXDR | SDMMC_INT_RXDR |
+		   FH_MCI_ERROR_FLAGS | SDMMC_INT_CD);
+	mci_writel(host, CTRL, SDMMC_CTRL_INT_ENABLE);
+
+	for (i = 0; i < host->num_slots; i++) {
+		struct fh_mci_slot *slot = host->slot[i];
+		if (!slot)
+			continue;
+		ret = mmc_resume_host(host->slot[i]->mmc);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+#else
+#define fh_mci_suspend	NULL
+#define fh_mci_resume	NULL
+#endif /* CONFIG_PM */
+
+static struct platform_driver fh_mci_driver = {
+	.remove		= __exit_p(fh_mci_remove),
+	.suspend	= fh_mci_suspend,
+	.resume		= fh_mci_resume,
+	.driver		= {
+		.name		= "fh_mmc",
+	},
+};
+
+static int __init fh_mci_init(void)
+{
+	return platform_driver_probe(&fh_mci_driver, fh_mci_probe);
+}
+
+static void __exit fh_mci_exit(void)
+{
+	platform_driver_unregister(&fh_mci_driver);
+}
+
+module_init(fh_mci_init);
+module_exit(fh_mci_exit);
+
+MODULE_DESCRIPTION("FH Multimedia Card Interface driver");
+MODULE_AUTHOR("NXP Semiconductor VietNam");
+MODULE_AUTHOR("Imagination Technologies Ltd");
+MODULE_LICENSE("GPL v2");
diff -uraN linux-3.0.8/drivers/mmc/host/fh_mmc.h linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/host/fh_mmc.h
--- linux-3.0.8/drivers/mmc/host/fh_mmc.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/host/fh_mmc.h	2021-07-13 23:40:34.050358664 +0300
@@ -0,0 +1,233 @@
+/*
+ * Synopsys DesignWare Multimedia Card Interface driver
+ *  (Based on NXP driver for lpc 31xx)
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ * Copyright (C) 2009, 2010 Imagination Technologies Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _LINUX_MMC_FH_MMC_H_
+#define _LINUX_MMC_FH_MMC_H_
+
+#include <linux/scatterlist.h>
+#include <linux/compiler.h>
+#include <linux/types.h>
+#include <linux/io.h>
+#include <linux/mmc/host.h>
+
+#define MAX_MCI_SLOTS	2
+
+enum fh_mci_state {
+	STATE_IDLE = 0,
+	STATE_SENDING_CMD,
+	STATE_SENDING_DATA,
+	STATE_DATA_BUSY,
+	STATE_SENDING_STOP,
+	STATE_DATA_ERROR,
+};
+
+enum {
+	EVENT_CMD_COMPLETE = 0,
+	EVENT_XFER_COMPLETE,
+	EVENT_DATA_COMPLETE,
+	EVENT_DATA_ERROR,
+	EVENT_XFER_ERROR
+};
+
+struct mmc_data;
+
+/**
+ * struct fh_mci - MMC controller state shared between all slots
+ * @lock: Spinlock protecting the queue and associated data.
+ * @regs: Pointer to MMIO registers.
+ * @sg: Scatterlist entry currently being processed by PIO code, if any.
+ * @pio_offset: Offset into the current scatterlist entry.
+ * @cur_slot: The slot which is currently using the controller.
+ * @mrq: The request currently being processed on @cur_slot,
+ *	or NULL if the controller is idle.
+ * @cmd: The command currently being sent to the card, or NULL.
+ * @data: The data currently being transferred, or NULL if no data
+ *	transfer is in progress.
+ * @use_dma: Whether DMA channel is initialized or not.
+ * @sg_dma: Bus address of DMA buffer.
+ * @sg_cpu: Virtual address of DMA buffer.
+ * @dma_ops: Pointer to platform-specific DMA callbacks.
+ * @cmd_status: Snapshot of SR taken upon completion of the current
+ *	command. Only valid when EVENT_CMD_COMPLETE is pending.
+ * @data_status: Snapshot of SR taken upon completion of the current
+ *	data transfer. Only valid when EVENT_DATA_COMPLETE or
+ *	EVENT_DATA_ERROR is pending.
+ * @stop_cmdr: Value to be loaded into CMDR when the stop command is
+ *	to be sent.
+ * @dir_status: Direction of current transfer.
+ * @tasklet: Tasklet running the request state machine.
+ * @card_tasklet: Tasklet handling card detect.
+ * @pending_events: Bitmask of events flagged by the interrupt handler
+ *	to be processed by the tasklet.
+ * @completed_events: Bitmask of events which the state machine has
+ *	processed.
+ * @state: Tasklet state.
+ * @queue: List of slots waiting for access to the controller.
+ * @bus_hz: The rate of @mck in Hz. This forms the basis for MMC bus
+ *	rate and timeout calculations.
+ * @current_speed: Configured rate of the controller.
+ * @num_slots: Number of slots available.
+ * @pdev: Platform device associated with the MMC controller.
+ * @pdata: Platform data associated with the MMC controller.
+ * @slot: Slots sharing this MMC controller.
+ * @data_shift: log2 of FIFO item size.
+ * @push_data: Pointer to FIFO push function.
+ * @pull_data: Pointer to FIFO pull function.
+ * @quirks: Set of quirks that apply to specific versions of the IP.
+ *
+ * Locking
+ * =======
+ *
+ * @lock is a softirq-safe spinlock protecting @queue as well as
+ * @cur_slot, @mrq and @state. These must always be updated
+ * at the same time while holding @lock.
+ *
+ * The @mrq field of struct fh_mci_slot is also protected by @lock,
+ * and must always be written at the same time as the slot is added to
+ * @queue.
+ *
+ * @pending_events and @completed_events are accessed using atomic bit
+ * operations, so they don't need any locking.
+ *
+ * None of the fields touched by the interrupt handler need any
+ * locking. However, ordering is important: Before EVENT_DATA_ERROR or
+ * EVENT_DATA_COMPLETE is set in @pending_events, all data-related
+ * interrupts must be disabled and @data_status updated with a
+ * snapshot of SR. Similarly, before EVENT_CMD_COMPLETE is set, the
+ * CMDRDY interrupt must be disabled and @cmd_status updated with a
+ * snapshot of SR, and before EVENT_XFER_COMPLETE can be set, the
+ * bytes_xfered field of @data must be written. This is ensured by
+ * using barriers.
+ */
+struct fh_mci {
+	spinlock_t		lock;
+	void __iomem		*regs;
+
+	struct scatterlist	*sg;
+	unsigned int		pio_offset;
+
+	struct fh_mci_slot	*cur_slot;
+	struct mmc_request	*mrq;
+	struct mmc_command	*cmd;
+	struct mmc_data		*data;
+
+	/* DMA interface members*/
+	int			use_dma;
+	int 		using_dma;
+	unsigned int		prev_blksz;
+
+	dma_addr_t		sg_dma;
+	void			*sg_cpu;
+	struct fh_mci_dma_ops	*dma_ops;
+#ifdef CONFIG_MMC_FH_IDMAC
+	unsigned int		ring_size;
+#else
+	struct fh_mci_dma_data	*dma_data;
+#endif
+	u32			cmd_status;
+	u32			data_status;
+	u32			stop_cmdr;
+	u32			dir_status;
+	struct tasklet_struct	tasklet;
+	struct tasklet_struct	card_tasklet;
+	unsigned long		pending_events;
+	unsigned long		completed_events;
+	enum fh_mci_state	state;
+	struct list_head	queue;
+
+	u32			bus_hz;
+	u32			current_speed;
+	u32			num_slots;
+	u32			fifoth_val;
+	struct platform_device	*pdev;
+	struct fh_mci_board	*pdata;
+	struct fh_mci_slot	*slot[MAX_MCI_SLOTS];
+
+	/* FIFO push and pull */
+	int			data_shift;
+	void (*push_data)(struct fh_mci *host, void *buf, int cnt);
+	void (*pull_data)(struct fh_mci *host, void *buf, int cnt);
+
+	/* Workaround flags */
+	u32			quirks;
+
+	struct regulator	*vmmc;	/* Power regulator */
+
+	int 		dma_data_mapped;
+	int 		data_error_flag;
+};
+
+/* DMA ops for Internal/External DMAC interface */
+struct fh_mci_dma_ops {
+	/* DMA Ops */
+	int (*init)(struct fh_mci *host);
+	void (*start)(struct fh_mci *host, unsigned int sg_len);
+	void (*complete)(struct fh_mci *host);
+	void (*stop)(struct fh_mci *host);
+	void (*cleanup)(struct fh_mci *host);
+	void (*exit)(struct fh_mci *host);
+};
+
+/* IP Quirks/flags. */
+/* DTO fix for command transmission with IDMAC configured */
+#define FH_MCI_QUIRK_IDMAC_DTO			BIT(0)
+/* delay needed between retries on some 2.11a implementations */
+#define FH_MCI_QUIRK_RETRY_DELAY		BIT(1)
+/* High Speed Capable - Supports HS cards (up to 50MHz) */
+#define FH_MCI_QUIRK_HIGHSPEED			BIT(2)
+/* Unreliable card detection */
+#define FH_MCI_QUIRK_BROKEN_CARD_DETECTION	BIT(3)
+
+
+struct dma_pdata;
+
+struct block_settings {
+	unsigned short	max_segs;	/* see blk_queue_max_segments */
+	unsigned int	max_blk_size;	/* maximum size of one mmc block */
+	unsigned int	max_blk_count;	/* maximum number of blocks in one req*/
+	unsigned int	max_req_size;	/* maximum number of bytes in one req*/
+	unsigned int	max_seg_size;	/* see blk_queue_max_segment_size */
+};
+
+/* Board platform data */
+struct fh_mci_board {
+	u32 num_slots;
+
+	u32 quirks; /* Workaround / Quirk flags */
+	unsigned int bus_hz; /* Bus speed */
+
+	unsigned int caps;	/* Capabilities */
+
+	/* delay in mS before detecting cards after interrupt */
+	u32 detect_delay_ms;
+
+	int (*init)(u32 slot_id,void* irq_handler_t , void *);
+	int (*get_ro)(u32 slot_id);
+	int (*get_cd)(u32 slot_id);
+	int (*get_ocr)(u32 slot_id);
+	int (*get_bus_wd)(u32 slot_id);
+	/*
+	 * Enable power to selected slot and set voltage to desired level.
+	 * Voltage levels are specified using MMC_VDD_xxx defines defined
+	 * in linux/mmc/host.h file.
+	 */
+	void (*setpower)(u32 slot_id, u32 volt);
+	void (*exit)(u32 slot_id);
+	void (*select_slot)(u32 slot_id);
+
+	struct fh_mci_dma_ops *dma_ops;
+	struct dma_pdata *data;
+	struct block_settings *blk_settings;
+};
+
+#endif /* _LINUX_MMC_FH_MMC_H_ */
diff -uraN linux-3.0.8/drivers/mmc/host/fh_mmc_reg.h linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/host/fh_mmc_reg.h
--- linux-3.0.8/drivers/mmc/host/fh_mmc_reg.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/host/fh_mmc_reg.h	2021-07-13 23:40:34.038358591 +0300
@@ -0,0 +1,174 @@
+/*
+ * Synopsys DesignWare Multimedia Card Interface driver
+ *  (Based on NXP driver for lpc 31xx)
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ * Copyright (C) 2009, 2010 Imagination Technologies Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _DW_MMC_H_
+#define _DW_MMC_H_
+
+#define SDMMC_CTRL		0x000
+#define SDMMC_PWREN		0x004
+#define SDMMC_CLKDIV		0x008
+#define SDMMC_CLKSRC		0x00c
+#define SDMMC_CLKENA		0x010
+#define SDMMC_TMOUT		0x014
+#define SDMMC_CTYPE		0x018
+#define SDMMC_BLKSIZ		0x01c
+#define SDMMC_BYTCNT		0x020
+#define SDMMC_INTMASK		0x024
+#define SDMMC_CMDARG		0x028
+#define SDMMC_CMD		0x02c
+#define SDMMC_RESP0		0x030
+#define SDMMC_RESP1		0x034
+#define SDMMC_RESP2		0x038
+#define SDMMC_RESP3		0x03c
+#define SDMMC_MINTSTS		0x040
+#define SDMMC_RINTSTS		0x044
+#define SDMMC_STATUS		0x048
+#define SDMMC_FIFOTH		0x04c
+#define SDMMC_CDETECT		0x050
+#define SDMMC_WRTPRT		0x054
+#define SDMMC_GPIO		0x058
+#define SDMMC_TCBCNT		0x05c
+#define SDMMC_TBBCNT		0x060
+#define SDMMC_DEBNCE		0x064
+#define SDMMC_USRID		0x068
+#define SDMMC_VERID		0x06c
+#define SDMMC_HCON		0x070
+#define SDMMC_UHS_REG		0x074
+#define SDMMC_RST_n         0x78
+#define SDMMC_BMOD		0x080
+#define SDMMC_PLDMND		0x084
+#define SDMMC_DBADDR		0x088
+#define SDMMC_IDSTS		0x08c
+#define SDMMC_IDINTEN		0x090
+#define SDMMC_DSCADDR		0x094
+#define SDMMC_BUFADDR		0x098
+#define SDMMC_DATA		0x200
+
+/* shift bit field */
+#define _SBF(f, v)		((v) << (f))
+
+/* Control register defines */
+#define SDMMC_CTRL_USE_IDMAC		BIT(25)
+#define SDMMC_CTRL_CEATA_INT_EN		BIT(11)
+#define SDMMC_CTRL_SEND_AS_CCSD		BIT(10)
+#define SDMMC_CTRL_SEND_CCSD		BIT(9)
+#define SDMMC_CTRL_ABRT_READ_DATA	BIT(8)
+#define SDMMC_CTRL_SEND_IRQ_RESP	BIT(7)
+#define SDMMC_CTRL_READ_WAIT		BIT(6)
+#define SDMMC_CTRL_DMA_ENABLE		BIT(5)
+#define SDMMC_CTRL_INT_ENABLE		BIT(4)
+#define SDMMC_CTRL_DMA_RESET		BIT(2)
+#define SDMMC_CTRL_FIFO_RESET		BIT(1)
+#define SDMMC_CTRL_RESET		BIT(0)
+/* Clock Enable register defines */
+#define SDMMC_CLKEN_LOW_PWR		BIT(16)
+#define SDMMC_CLKEN_ENABLE		BIT(0)
+/* time-out register defines */
+#define SDMMC_TMOUT_DATA(n)		_SBF(8, (n))
+#define SDMMC_TMOUT_DATA_MSK		0xFFFFFF00
+#define SDMMC_TMOUT_RESP(n)		((n) & 0xFF)
+#define SDMMC_TMOUT_RESP_MSK		0xFF
+/* card-type register defines */
+#define SDMMC_CTYPE_8BIT		BIT(16)
+#define SDMMC_CTYPE_4BIT		BIT(0)
+#define SDMMC_CTYPE_1BIT		0
+/* Interrupt status & mask register defines */
+//#define SDMMC_INT_SDIO			BIT(16)
+#define SDMMC_INT_SDIO(n)		BIT(16 + (n))
+#define SDMMC_INT_EBE			BIT(15)
+#define SDMMC_INT_ACD			BIT(14)
+#define SDMMC_INT_SBE			BIT(13)
+#define SDMMC_INT_HLE			BIT(12)
+#define SDMMC_INT_FRUN			BIT(11)
+#define SDMMC_INT_HTO			BIT(10)
+#define SDMMC_INT_DTO			BIT(9)
+#define SDMMC_INT_RTO			BIT(8)
+#define SDMMC_INT_DCRC			BIT(7)
+#define SDMMC_INT_RCRC			BIT(6)
+#define SDMMC_INT_RXDR			BIT(5)
+#define SDMMC_INT_TXDR			BIT(4)
+#define SDMMC_INT_DATA_OVER		BIT(3)
+#define SDMMC_INT_CMD_DONE		BIT(2)
+#define SDMMC_INT_RESP_ERR		BIT(1)
+#define SDMMC_INT_CD			BIT(0)
+#define SDMMC_INT_ERROR			0xbfc2
+/* Command register defines */
+#define SDMMC_CMD_START			BIT(31)
+#define SDMMC_CMD_USE_HOLD_REG	BIT(29)
+#define SDMMC_CMD_CCS_EXP		BIT(23)
+#define SDMMC_CMD_CEATA_RD		BIT(22)
+#define SDMMC_CMD_UPD_CLK		BIT(21)
+#define SDMMC_CMD_INIT			BIT(15)
+#define SDMMC_CMD_STOP			BIT(14)
+#define SDMMC_CMD_PRV_DAT_WAIT		BIT(13)
+#define SDMMC_CMD_SEND_STOP		BIT(12)
+#define SDMMC_CMD_STRM_MODE		BIT(11)
+#define SDMMC_CMD_DAT_WR		BIT(10)
+#define SDMMC_CMD_DAT_EXP		BIT(9)
+#define SDMMC_CMD_RESP_CRC		BIT(8)
+#define SDMMC_CMD_RESP_LONG		BIT(7)
+#define SDMMC_CMD_RESP_EXP		BIT(6)
+#define SDMMC_CMD_INDX(n)		((n) & 0x1F)
+/* Status register defines */
+#define SDMMC_GET_FCNT(x)		(((x)>>17) & 0x1FF)
+#define SDMMC_FIFO_SZ			32
+/* Internal DMAC interrupt defines */
+#define SDMMC_IDMAC_INT_AI		BIT(9)
+#define SDMMC_IDMAC_INT_NI		BIT(8)
+#define SDMMC_IDMAC_INT_CES		BIT(5)
+#define SDMMC_IDMAC_INT_DU		BIT(4)
+#define SDMMC_IDMAC_INT_FBE		BIT(2)
+#define SDMMC_IDMAC_INT_RI		BIT(1)
+#define SDMMC_IDMAC_INT_TI		BIT(0)
+/* Internal DMAC bus mode bits */
+#define SDMMC_IDMAC_ENABLE		BIT(7)
+#define SDMMC_IDMAC_FB			BIT(1)
+#define SDMMC_IDMAC_SWRESET		BIT(0)
+#define SDMMC_SET_FIFOTH(m, r, t)	(((m) & 0x7) << 28 | \
+					 ((r) & 0xFFF) << 16 | \
+					 ((t) & 0xFFF))
+
+/* Register access macros */
+#define mci_readl(dev, reg)			\
+	__raw_readl(dev->regs + SDMMC_##reg)
+#define mci_writel(dev, reg, value)			\
+	__raw_writel((value), dev->regs + SDMMC_##reg)
+
+/* 16-bit FIFO access macros */
+#define mci_readw(dev, reg)			\
+	__raw_readw(dev->regs + SDMMC_##reg)
+#define mci_writew(dev, reg, value)			\
+	__raw_writew((value), dev->regs + SDMMC_##reg)
+
+/* 64-bit FIFO access macros */
+#ifdef readq
+#define mci_readq(dev, reg)			\
+	__raw_readq(dev->regs + SDMMC_##reg)
+#define mci_writeq(dev, reg, value)			\
+	__raw_writeq((value), dev->regs + SDMMC_##reg)
+#else
+/*
+ * Dummy readq implementation for architectures that don't define it.
+ *
+ * We would assume that none of these architectures would configure
+ * the IP block with a 64bit FIFO width, so this code will never be
+ * executed on those machines. Defining these macros here keeps the
+ * rest of the code free from ifdefs.
+ */
+#define mci_readq(dev, reg)			\
+	(*(volatile u64 __force *)(dev->regs + SDMMC_##reg))
+#define mci_writeq(dev, reg, value)			\
+	(*(volatile u64 __force *)(dev->regs + SDMMC_##reg) = value)
+#endif
+
+#endif /* _DW_MMC_H_ */
diff -uraN linux-3.0.8/drivers/mmc/host/Kconfig linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/host/Kconfig
--- linux-3.0.8/drivers/mmc/host/Kconfig	2021-07-14 21:52:02.923133739 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/host/Kconfig	2021-07-13 23:40:34.058358714 +0300
@@ -518,6 +518,23 @@
 	  Designware Mobile Storage IP block. This disables the external DMA
 	  interface.
 
+config MMC_FH
+	tristate "FH Memory Card Interface"
+	depends on ARM
+	help
+	  This selects support for the Synopsys DesignWare Mobile Storage IP
+	  block, this provides host support for SD and MMC interfaces, in both
+	  PIO and external DMA modes.
+
+config MMC_FH_IDMAC
+	bool "Internal DMAC interface"
+	depends on MMC_FH
+	help
+	  This selects support for the internal DMAC block within the Synopsys
+	  Designware Mobile Storage IP block. This disables the external DMA
+	  interface.
+
+
 config MMC_SH_MMCIF
 	tristate "SuperH Internal MMCIF support"
 	depends on MMC_BLOCK && (SUPERH || ARCH_SHMOBILE)
diff -uraN linux-3.0.8/drivers/mmc/host/Makefile linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/host/Makefile
--- linux-3.0.8/drivers/mmc/host/Makefile	2021-07-14 21:52:02.923133739 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/mmc/host/Makefile	2021-07-13 23:40:34.042358616 +0300
@@ -39,6 +39,7 @@
 obj-$(CONFIG_MMC_VIA_SDMMC)	+= via-sdmmc.o
 obj-$(CONFIG_SDH_BFIN)		+= bfin_sdh.o
 obj-$(CONFIG_MMC_DW)		+= dw_mmc.o
+obj-$(CONFIG_MMC_FH)		+= fhmci/
 obj-$(CONFIG_MMC_SH_MMCIF)	+= sh_mmcif.o
 obj-$(CONFIG_MMC_JZ4740)	+= jz4740_mmc.o
 obj-$(CONFIG_MMC_VUB300)	+= vub300.o
diff -uraN linux-3.0.8/drivers/mtd/cmdlinepart.c linux-3.0.8-fh8632-V1.0_20180330/drivers/mtd/cmdlinepart.c
--- linux-3.0.8/drivers/mtd/cmdlinepart.c	2021-07-14 21:52:02.939133786 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/mtd/cmdlinepart.c	2021-07-13 23:40:34.574361888 +0300
@@ -48,7 +48,7 @@
 #define ERRP "mtd: "
 
 /* debug macro */
-#if 0
+#if 1
 #define dbg(x) do { printk("DEBUG-CMDLINE-PART: "); printk x; } while(0)
 #else
 #define dbg(x)
diff -uraN linux-3.0.8/drivers/mtd/devices/m25p80.c linux-3.0.8-fh8632-V1.0_20180330/drivers/mtd/devices/m25p80.c
--- linux-3.0.8/drivers/mtd/devices/m25p80.c	2021-07-14 21:52:02.943133797 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/mtd/devices/m25p80.c	2021-07-13 23:40:34.526361592 +0300
@@ -166,10 +166,26 @@
  */
 static inline int set_4byte(struct m25p *flash, u32 jedec_id, int enable)
 {
+	int ret;
 	switch (JEDEC_MFR(jedec_id)) {
 	case CFI_MFR_MACRONIX:
+	case CFI_MFR_ST: /* Micron, actually */
+	case 0xC8 /* GD */ :
 		flash->command[0] = enable ? OPCODE_EN4B : OPCODE_EX4B;
-		return spi_write(flash->spi, flash->command, 1);
+		ret = spi_write(flash->spi, flash->command, 1);
+		return ret;
+	case 0xEF /* winbond */:
+		flash->command[0] = enable ? OPCODE_EN4B : OPCODE_EX4B;
+		ret = spi_write(flash->spi, flash->command, 1);
+		if (!enable)
+		{
+			flash->command[0] = 0x06;
+			spi_write(flash->spi,flash->command, 1);
+			flash->command[0] = 0xc5;
+			flash->command[1] = 0x00;
+			ret =spi_write(flash->spi,flash->command, 2);
+		}
+		return ret;
 	default:
 		/* Spansion style */
 		flash->command[0] = OPCODE_BRWR;
@@ -178,6 +194,7 @@
 	}
 }
 
+
 /*
  * Service routine to read status register until ready, or timeout occurs.
  * Returns non-zero if error.
@@ -192,7 +209,7 @@
 	do {
 		if ((sr = read_sr(flash)) < 0)
 			break;
-		else if (!(sr & SR_WIP))
+		else if (!(sr & (SR_WIP | SR_WEL)))
 			return 0;
 
 		cond_resched();
@@ -202,6 +219,38 @@
 	return 1;
 }
 
+
+static  int reset_chip(struct m25p *flash, u32 jedec_id)
+{
+	int ret;
+	switch (JEDEC_MFR(jedec_id)) {
+	case 0x9F: /* S25FL128/256S spansion */
+		flash->command[0] = 0xFF; // MBR
+		ret = spi_write(flash->spi, flash->command, 1);
+		flash->command[0] = 0xF0;  // RESET
+		ret = spi_write(flash->spi, flash->command, 1);
+		printk( "now 0x%x FFF0 cmd\n", jedec_id);
+		return ret;
+	case 0xef:
+		flash->command[0] = 0x66;
+		ret = spi_write(flash->spi, flash->command, 1);
+		flash->command[0] = 0x99;
+		ret = spi_write(flash->spi, flash->command, 1);
+		udelay(100);
+		printk( "now 0x%x 6699 cmd\n", jedec_id);
+		return ret;
+	case CFI_MFR_MACRONIX:
+	case CFI_MFR_ST: /* Micron, actually */
+	default:
+		return 0;
+//       case 0xEF /* W25Q winbond */:
+//       case 0xC8 /* GD25Q128C */:
+//  case 0xC2 /* MX25L128 */:
+
+	}
+}
+
+
 /*
  * Erase the whole flash memory
  *
@@ -707,7 +756,7 @@
 	{ "s25fl129p0", INFO(0x012018, 0x4d00, 256 * 1024,  64, 0) },
 	{ "s25fl129p1", INFO(0x012018, 0x4d01,  64 * 1024, 256, 0) },
 	{ "s25fl016k",  INFO(0xef4015,      0,  64 * 1024,  32, SECT_4K) },
-	{ "s25fl064k",  INFO(0xef4017,      0,  64 * 1024, 128, SECT_4K) },
+	{ "s25fl064k",  INFO(0xef4017,      0,  64 * 1024, 128, 0) },
 
 	/* SST -- large erase sizes are "overlays", "sectors" are 4K */
 	{ "sst25vf040b", INFO(0xbf258d, 0, 64 * 1024,  8, SECT_4K) },
@@ -760,8 +809,13 @@
 	{ "w25x16", INFO(0xef3015, 0, 64 * 1024,  32, SECT_4K) },
 	{ "w25x32", INFO(0xef3016, 0, 64 * 1024,  64, SECT_4K) },
 	{ "w25q32", INFO(0xef4016, 0, 64 * 1024,  64, SECT_4K) },
+	{ "w25q32dw", INFO(0xef6016, 0, 64 * 1024,  64, SECT_4K) },
 	{ "w25x64", INFO(0xef3017, 0, 64 * 1024, 128, SECT_4K) },
-	{ "w25q64", INFO(0xef4017, 0, 64 * 1024, 128, SECT_4K) },
+	{ "w25q64", INFO(0xef4017, 0, 64 * 1024, 128, 0) },
+	{ "w25q80", INFO(0xef5014, 0, 64 * 1024,  16, SECT_4K) },
+	{ "w25q80bl", INFO(0xef4014, 0, 64 * 1024,  16, SECT_4K) },
+	{ "w25q128", INFO(0xef4018, 0, 64 * 1024, 256, 0) }, /// SECT_4K
+	{ "w25q256", INFO(0xef4019, 0, 64 * 1024, 512, 0) },
 
 	/* Catalyst / On Semiconductor -- non-JEDEC */
 	{ "cat25c11", CAT25_INFO(  16, 8, 16, 1) },
@@ -769,6 +823,10 @@
 	{ "cat25c09", CAT25_INFO( 128, 8, 32, 2) },
 	{ "cat25c17", CAT25_INFO( 256, 8, 32, 2) },
 	{ "cat25128", CAT25_INFO(2048, 8, 64, 2) },
+
+	//for GD flash..
+	{ "gd25q128", INFO(0xc84018, 0, 64 * 1024, 256, 0) }, /// SECT_4K
+
 	{ },
 };
 MODULE_DEVICE_TABLE(spi, m25p_ids);
@@ -909,6 +967,7 @@
 	flash->mtd.size = info->sector_size * info->n_sectors;
 	flash->mtd.erase = m25p80_erase;
 	flash->mtd.read = m25p80_read;
+	flash->mtd.priv = (void *)info->jedec_id;
 
 	/* sst flash chips use AAI word program */
 	if (JEDEC_MFR(info->jedec_id) == CFI_MFR_SST)
@@ -1005,6 +1064,20 @@
 		-ENODEV : 0;
 }
 
+static void m25p_shutdown(struct spi_device *spi)
+{
+	struct m25p	*flash = dev_get_drvdata(&spi->dev);
+	u32 jedec = (u32)flash->mtd.priv;
+
+	dev_err(&spi->dev, "[m25] shutdown here? \n");
+
+	if (flash->addr_width == 4){
+		set_4byte(flash, jedec, 0);
+		flash->addr_width =3 ;
+	}
+
+	reset_chip(flash, jedec);
+}
 
 static int __devexit m25p_remove(struct spi_device *spi)
 {
@@ -1030,7 +1103,8 @@
 	.id_table	= m25p_ids,
 	.probe	= m25p_probe,
 	.remove	= __devexit_p(m25p_remove),
-
+	// add shutdown method to reset spi flash
+	.shutdown = m25p_shutdown, ///
 	/* REVISIT: many of these chips have deep power-down modes, which
 	 * should clearly be entered on suspend() to minimize power use.
 	 * And also when they're otherwise idle...
diff -uraN linux-3.0.8/drivers/mtd/Kconfig linux-3.0.8-fh8632-V1.0_20180330/drivers/mtd/Kconfig
--- linux-3.0.8/drivers/mtd/Kconfig	2021-07-14 21:52:02.935133774 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/mtd/Kconfig	2021-07-13 23:40:34.558361789 +0300
@@ -330,6 +330,8 @@
 
 source "drivers/mtd/lpddr/Kconfig"
 
+source "drivers/mtd/spi-nand/Kconfig"
+
 source "drivers/mtd/ubi/Kconfig"
 
 endif # MTD
diff -uraN linux-3.0.8/drivers/mtd/Makefile linux-3.0.8-fh8632-V1.0_20180330/drivers/mtd/Makefile
--- linux-3.0.8/drivers/mtd/Makefile	2021-07-14 21:52:02.935133774 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/mtd/Makefile	2021-07-13 23:40:34.550361741 +0300
@@ -31,4 +31,5 @@
 
 obj-y		+= chips/ lpddr/ maps/ devices/ nand/ onenand/ tests/
 
+obj-$(CONFIG_MTD_SPI_NAND)	+= spi-nand/
 obj-$(CONFIG_MTD_UBI)		+= ubi/
diff -uraN linux-3.0.8/drivers/mtd/spi-nand/Kconfig linux-3.0.8-fh8632-V1.0_20180330/drivers/mtd/spi-nand/Kconfig
--- linux-3.0.8/drivers/mtd/spi-nand/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/mtd/spi-nand/Kconfig	2021-07-13 23:40:34.582361938 +0300
@@ -0,0 +1,7 @@
+menuconfig MTD_SPI_NAND
+	tristate "SPI-NAND device Support"
+	depends on MTD_NAND && SPI
+	help
+	  This is the framework for the SPI NAND which can be used by the SPI
+	  device drivers and the SPI-NAND device drivers.
+
diff -uraN linux-3.0.8/drivers/mtd/spi-nand/Makefile linux-3.0.8-fh8632-V1.0_20180330/drivers/mtd/spi-nand/Makefile
--- linux-3.0.8/drivers/mtd/spi-nand/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/mtd/spi-nand/Makefile	2021-07-13 23:40:34.582361938 +0300
@@ -0,0 +1,2 @@
+
+obj-$(CONFIG_MTD_SPI_NAND) += spi-nand-base.o spi-nand-bbt.o spi-nand-device.o spi-nand-ids.o
diff -uraN linux-3.0.8/drivers/mtd/spi-nand/spi-nand-base.c linux-3.0.8-fh8632-V1.0_20180330/drivers/mtd/spi-nand/spi-nand-base.c
--- linux-3.0.8/drivers/mtd/spi-nand/spi-nand-base.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/mtd/spi-nand/spi-nand-base.c	2021-07-13 23:40:34.578361912 +0300
@@ -0,0 +1,2073 @@
+/**
+* spi-nand-base.c
+*
+* Copyright (c) 2009-2014 Micron Technology, Inc.
+*
+* Derived from nand_base.c
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License
+* as published by the Free Software Foundation; either version 2
+* of the License, or (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/jiffies.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/spi-nand.h>
+#include <linux/mtd/bbm.h>
+#include <linux/spi/spi.h>
+#include <linux/slab.h>
+#include "spi-nand-ids.h"
+
+int fh_start_debug =0;
+//#define SPINAND_BBT_DEBUG
+#ifdef SPINAND_BBT_DEBUG
+#define fh_dev_debug	dev_err
+#else
+#define fh_dev_debug(...)
+#endif
+
+static int spi_nand_erase(struct mtd_info *mtd, struct erase_info *einfo);
+
+/**
+ * spi_nand_get_device - [GENERIC] Get chip for selected access
+ * @mtd: MTD device structure
+ * @new_state: the state which is requested
+ *
+ * Get the device and lock it for exclusive access
+ */
+static int spi_nand_get_device(struct mtd_info *mtd, int new_state)
+{
+	struct spi_nand_chip *this = mtd->priv;
+	DECLARE_WAITQUEUE(wait, current);
+
+	/*
+	 * Grab the lock and see if the device is available
+	 */
+	while (1) {
+		spin_lock(&this->chip_lock);
+		if (this->state == FL_READY) {
+			this->state = new_state;
+			spin_unlock(&this->chip_lock);
+			break;
+		}
+		if (new_state == FL_PM_SUSPENDED) {
+			spin_unlock(&this->chip_lock);
+			return (this->state == FL_PM_SUSPENDED) ? 0 : -EAGAIN;
+		}
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&this->wq, &wait);
+		spin_unlock(&this->chip_lock);
+		schedule();
+		remove_wait_queue(&this->wq, &wait);
+	}
+	return 0;
+}
+
+/**
+ * spi_nand_release_device - [GENERIC] release chip
+ * @mtd: MTD device structure
+ *
+ * Deselect, release chip lock and wake up anyone waiting on the device
+ */
+static void spi_nand_release_device(struct mtd_info *mtd)
+{
+	struct spi_nand_chip *this = mtd->priv;
+
+	/* Release the chip */
+	spin_lock(&this->chip_lock);
+	this->state = FL_READY;
+	wake_up(&this->wq);
+	spin_unlock(&this->chip_lock);
+}
+
+/**
+ * __spi_nand_do_read_page - [INTERN] read data from flash to buffer
+ * @mtd: MTD device structure
+ * @page_addr: page address/raw address
+ * @column :column address
+ * @raw: without ecc or not
+ * @corrected: how many bit error corrected
+ *
+ * read a page to buffer pointed by chip->buf
+ */
+static int __spi_nand_do_read_page(struct mtd_info *mtd, u32 page_addr,
+				   u32 colunm, bool raw, int *corrected)
+{
+	struct spi_nand_chip *chip = mtd->priv;
+	int ret, ecc_error;
+	u8 status;
+
+	fh_dev_debug(&chip->spi->dev, "Enter %s\n", __func__);
+
+	/*read data from chip*/
+	memset(chip->buf, 0, chip->page_size + chip->page_spare_size);
+	if (raw) {
+		ret = chip->disable_ecc(chip);
+		if (ret < 0) {
+			pr_debug("disable ecc failed\n");
+			return ret;
+		}
+	}
+	ret = chip->load_page(chip, page_addr);
+	if (ret < 0) {
+		pr_debug("error %d loading page 0x%x to cache\n",
+			 ret, page_addr);
+		return ret;
+	}
+	ret = chip->waitfunc(chip, &status);
+	if (ret < 0) {
+		pr_debug("error %d waiting page 0x%x to cache\n",
+			 ret, page_addr);
+		return ret;
+	}
+	chip->get_ecc_status(chip, status, corrected, &ecc_error);
+	/*
+	 * If there's an ECC error, print a message and notify MTD
+	 * about it. Then complete the read, to load actual data on
+	 * the buffer (instead of the status result).
+	 */
+	if (ecc_error) {
+		pr_warn("internal ECC error reading page 0x%x with status 0x%02x\n",
+			 page_addr, status);
+		mtd->ecc_stats.failed++;
+	} else if (*corrected)
+		mtd->ecc_stats.corrected += *corrected;
+	/* Get page from the device cache into our internal buffer */
+	ret = chip->read_cache(chip, page_addr, colunm,
+			       chip->page_size + chip->page_spare_size - colunm,
+			       chip->buf + colunm);
+	if (ret < 0) {
+		pr_debug("error %d reading page 0x%x from cache\n",
+			 ret, page_addr);
+		return ret;
+	}
+	if (raw) {
+		ret = chip->enable_ecc(chip);
+		if (ret < 0) {
+			pr_debug("enable ecc failed\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * spi_nand_do_read_page - [INTERN] read a page from flash to buffer
+ * @mtd: MTD device structure
+ * @page_addr: page address/raw address
+ * @raw: without ecc or not
+ * @corrected: how many bit error corrected
+ *
+ * read a page to buffer pointed by chip->buf
+ */
+static int spi_nand_do_read_page(struct mtd_info *mtd, u32 page_addr,
+				 bool raw, int *corrected)
+{
+	return __spi_nand_do_read_page(mtd, page_addr, 0, raw, corrected);
+}
+
+/**
+ * spi_nand_do_read_page_oob - [INTERN] read page oob from flash to buffer
+ * @mtd: MTD device structure
+ * @page_addr: page address/raw address
+ * @raw: without ecc or not
+ * @corrected: how many bit error corrected
+ *
+ * read page oob to buffer pointed by chip->oobbuf
+ */
+static int spi_nand_do_read_page_oob(struct mtd_info *mtd, u32 page_addr,
+				     bool raw, int *corrected)
+{
+	struct spi_nand_chip *chip = mtd->priv;
+
+	return __spi_nand_do_read_page(mtd, page_addr, chip->page_size,
+				       raw, corrected);
+}
+
+
+/**
+ * __spi_nand_do_write_page - [INTERN] write data from buffer to flash
+ * @mtd: MTD device structure
+ * @page_addr: page address/raw address
+ * @column :column address
+ * @raw: without ecc or not
+ *
+ * write data from buffer pointed by chip->buf to flash
+ */
+static int __spi_nand_do_write_page(struct mtd_info *mtd, u32 page_addr,
+				    u32 column, bool raw)
+{
+	struct spi_nand_chip *chip = mtd->priv;
+	u8 status;
+	bool p_fail = false;
+	bool p_timeout = false;
+	int ret = 0;
+
+	fh_dev_debug(&chip->spi->dev, "Enter %s, with buf \n", __func__);
+
+	if (raw) {
+		ret = chip->disable_ecc(chip);
+		if (ret < 0) {
+			pr_debug("disable ecc failed\n");
+			return ret;
+		}
+	}
+	ret = chip->write_enable(chip);
+	if (ret < 0) {
+		pr_debug("write enable command failed\n");
+		return ret;
+	}
+	/* Store the page to cache */
+	ret = chip->store_cache(chip, page_addr, column,
+				chip->page_size + chip->page_spare_size - column,
+				chip->buf + column);
+	if (ret < 0) {
+		pr_debug("error %d storing page 0x%x to cache\n",
+			 ret, page_addr);
+		return ret;
+	}
+	/* Get page from the device cache into our internal buffer */
+	ret = chip->write_page(chip, page_addr);
+	if (ret < 0) {
+		pr_debug("error %d reading page 0x%x from cache\n",
+			 ret, page_addr);
+		return ret;
+	}
+	ret = chip->waitfunc(chip, &status);
+	if (ret < 0) {
+		pr_info("error %d write page 0x%x timeout\n",
+			 ret, page_addr);
+		return ret;
+	}
+	if ((status & STATUS_P_FAIL_MASK) == STATUS_P_FAIL) {
+		pr_debug("program page 0x%x failed\n", page_addr);
+		p_fail = true;
+	}
+
+	if ((status & STATUS_OIP_MASK) == STATUS_BUSY) {
+			pr_debug("program page 0x%x timeout\n", page_addr);
+			p_timeout = true;
+		}
+	if (raw) {
+		ret = chip->enable_ecc(chip);
+		if (ret < 0) {
+			pr_debug("enable ecc failed\n");
+			return ret;
+		}
+	}
+	if ((p_fail==true)||(p_timeout==true))
+		ret = -EIO;
+
+	return ret;
+}
+
+/**
+ * spi_nand_do_write_page - [INTERN] write page from buffer to flash
+ * @mtd: MTD device structure
+ * @page_addr: page address/raw address
+ * @raw: without ecc or not
+ *
+ * write page from buffer pointed by chip->buf to flash
+ */
+static int spi_nand_do_write_page(struct mtd_info *mtd, u32 page_addr,
+				  bool raw)
+{
+	return __spi_nand_do_write_page(mtd, page_addr, 0, raw);
+}
+
+/**
+ * spi_nand_do_write_page_oob - [INTERN] write oob from buffer to flash
+ * @mtd: MTD device structure
+ * @page_addr: page address/raw address
+ * @raw: without ecc or not
+ *
+ * write oob from buffer pointed by chip->oobbuf to flash
+ */
+static int spi_nand_do_write_page_oob(struct mtd_info *mtd, u32 page_addr,
+				      bool raw)
+{
+	struct spi_nand_chip *chip = mtd->priv;
+
+	return __spi_nand_do_write_page(mtd, page_addr, chip->page_size, raw);
+}
+
+
+/**
+ * spi_nand_transfer_oob - [INTERN] Transfer oob to client buffer
+ * @chip: SPI-NAND device structure
+ * @oob: oob destination address
+ * @ops: oob ops structure
+ * @len: size of oob to transfer
+ */
+static void spi_nand_transfer_oob(struct spi_nand_chip *chip, u8 *oob,
+				  struct mtd_oob_ops *ops, size_t len)
+{
+	switch (ops->mode) {
+
+	case MTD_OOB_PLACE: /*MTD_OPS_PLACE_OOB:*/
+	case MTD_OOB_RAW: /*MTD_OPS_RAW:*/
+		memcpy(oob, chip->oobbuf + ops->ooboffs, len);
+		return;
+
+	case MTD_OOB_AUTO: { /*MTD_OPS_AUTO_OOB:*/
+		struct nand_oobfree *free = chip->ecclayout->oobfree;
+		uint32_t boffs = 0, roffs = ops->ooboffs;
+		size_t bytes = 0;
+
+		for (; free->length && len; free++, len -= bytes) {
+			/* Read request not from offset 0? */
+			if (unlikely(roffs)) {
+				if (roffs >= free->length) {
+					roffs -= free->length;
+					continue;
+				}
+				boffs = free->offset + roffs;
+				bytes = min_t(size_t, len,
+					      (free->length - roffs));
+				roffs = 0;
+			} else {
+				bytes = min_t(size_t, len, free->length);
+				boffs = free->offset;
+			}
+			memcpy(oob, chip->oobbuf + boffs, bytes);
+			oob += bytes;
+		}
+		return;
+	}
+	default:
+		BUG();
+	}
+}
+
+/**
+ * spi_nand_fill_oob - [INTERN] Transfer client buffer to oob
+ * @chip: SPI-NAND device structure
+ * @oob: oob data buffer
+ * @len: oob data write length
+ * @ops: oob ops structure
+ */
+static void spi_nand_fill_oob(struct spi_nand_chip *chip, uint8_t *oob,
+			      size_t len, struct mtd_oob_ops *ops)
+{
+	fh_dev_debug(&chip->spi->dev, "Enter %s\n", __func__);
+	memset(chip->oobbuf, 0xff, chip->page_spare_size);
+
+	switch (ops->mode) {
+
+	case MTD_OOB_PLACE:
+	case MTD_OOB_RAW:
+		memcpy(chip->oobbuf + ops->ooboffs, oob, len);
+		return;
+
+	case MTD_OOB_AUTO: {
+		struct nand_oobfree *free = chip->ecclayout->oobfree;
+		uint32_t boffs = 0, woffs = ops->ooboffs;
+		size_t bytes = 0;
+
+		for (; free->length && len; free++, len -= bytes) {
+			/* Write request not from offset 0? */
+			if (unlikely(woffs)) {
+				if (woffs >= free->length) {
+					woffs -= free->length;
+					continue;
+				}
+				boffs = free->offset + woffs;
+				bytes = min_t(size_t, len,
+					      (free->length - woffs));
+				woffs = 0;
+			} else {
+				bytes = min_t(size_t, len, free->length);
+				boffs = free->offset;
+			}
+			memcpy(chip->oobbuf + boffs, oob, bytes);
+			oob += bytes;
+		}
+		return;
+	}
+	default:
+		BUG();
+	}
+}
+
+/**
+ * spi_nand_do_read_ops - [INTERN] Read data with ECC
+ * @mtd: MTD device structure
+ * @from: offset to read from
+ * @ops: oob ops structure
+ *
+ * Internal function. Called with chip held.
+ */
+static int spi_nand_do_read_ops(struct mtd_info *mtd, loff_t from,
+				struct mtd_oob_ops *ops)
+{
+	struct spi_nand_chip *chip = mtd->priv;
+	int page_addr, page_offset, size;
+	int ret;
+	unsigned int corrected = 0;
+	struct mtd_ecc_stats stats;
+	unsigned int max_bitflips = 0;
+	int readlen = ops->len;
+	int oobreadlen = ops->ooblen;
+	int ooblen = ops->mode == MTD_OOB_AUTO ?
+		     mtd->oobavail : mtd->oobsize;
+
+	fh_dev_debug(&chip->spi->dev, "Enter %s\n", __func__);
+
+	/* Do not allow reads past end of device */
+	if (unlikely(from >= mtd->size)) {
+		pr_debug("%s: attempt to read beyond end of device\n",
+			 __func__);
+		return -EINVAL;
+	}
+	stats = mtd->ecc_stats;
+
+	page_addr = from >> chip->page_shift;
+
+	/* for main data */
+	page_offset = from & chip->page_mask;
+	ops->retlen = 0;
+
+	/* for oob */
+	if (oobreadlen > 0) {
+		if (unlikely(ops->ooboffs >= ooblen)) {
+			pr_debug("%s: attempt to start read outside oob\n",
+				 __func__);
+			return -EINVAL;
+		}
+
+		if (unlikely(ops->ooboffs + oobreadlen >
+			     ((mtd->size >> chip->page_shift) - (from >> chip->page_shift))
+			     * ooblen)) {
+			pr_debug("%s: attempt to read beyond end of device\n",
+				 __func__);
+			return -EINVAL;
+		}
+		ooblen -= ops->ooboffs;
+		ops->oobretlen = 0;
+	}
+
+	while (1) {
+		if (page_addr != chip->pagebuf || oobreadlen > 0) {
+			ret = spi_nand_do_read_page(mtd, page_addr,
+						    ops->mode == MTD_OOB_RAW, &corrected);
+			if (ret) {
+				pr_debug("error %d reading page 0x%x\n",
+					 ret, page_addr);
+				return ret;
+			}
+			chip->pagebuf_bitflips = corrected;
+			chip->pagebuf = page_addr;
+		}
+		max_bitflips = max(max_bitflips, chip->pagebuf_bitflips);
+		size = min(readlen, chip->page_size - page_offset);
+		memcpy(ops->datbuf + ops->retlen,
+		       chip->buf + page_offset, size);
+
+		ops->retlen += size;
+		readlen -= size;
+		page_offset = 0;
+
+		if (unlikely(ops->oobbuf)) {
+			size = min(oobreadlen, ooblen);
+			spi_nand_transfer_oob(chip,
+					      ops->oobbuf + ops->oobretlen, ops, size);
+
+			ops->oobretlen += size;
+			oobreadlen -= size;
+		}
+		if (!readlen)
+			break;
+
+		page_addr++;
+	}
+
+	if (mtd->ecc_stats.failed - stats.failed)
+		return -EBADMSG;
+
+	return max_bitflips;
+}
+
+/**
+ * spi_nand_do_write_ops - [INTERN] SPI-NAND write with ECC
+ * @mtd: MTD device structure
+ * @to: offset to write to
+ * @ops: oob operations description structure
+ *
+ */
+static int spi_nand_do_write_ops(struct mtd_info *mtd, loff_t to,
+				 struct mtd_oob_ops *ops)
+{
+	struct spi_nand_chip *chip = mtd->priv;
+	int page_addr, page_offset, size;
+	int writelen = ops->len;
+	int oobwritelen = ops->ooblen;
+	int ret;
+	int ooblen = ops->mode == MTD_OOB_AUTO ?
+		     mtd->oobavail : mtd->oobsize;
+
+	fh_dev_debug(&chip->spi->dev, "Enter %s\n", __func__);
+
+	/* Do not allow reads past end of device */
+	if (unlikely(to >= mtd->size)) {
+		pr_debug("%s: attempt to write beyond end of device\n",
+			 __func__);
+		return -EINVAL;
+	}
+
+	page_addr = to >> chip->page_shift;
+
+	/* for main data */
+	page_offset = to & chip->page_mask;
+	ops->retlen = 0;
+
+	/* for oob */
+	if (oobwritelen > 0) {
+		/* Do not allow write past end of page */
+		if ((ops->ooboffs + oobwritelen) > ooblen) {
+			pr_debug("%s: attempt to write past end of page\n",
+				 __func__);
+			return -EINVAL;
+		}
+
+		if (unlikely(ops->ooboffs >= ooblen)) {
+			pr_debug("%s: attempt to start write outside oob\n",
+				 __func__);
+			return -EINVAL;
+		}
+
+		if (unlikely(ops->ooboffs + oobwritelen >
+			     ((mtd->size >> chip->page_shift) - (to >> chip->page_shift))
+			     * ooblen)) {
+			pr_debug("%s: attempt to write beyond end of device\n",
+				 __func__);
+			return -EINVAL;
+		}
+		ooblen -= ops->ooboffs;
+		ops->oobretlen = 0;
+	}
+
+	chip->pagebuf = -1;
+
+	while (1) {
+		memset(chip->buf, 0xFF,
+		       chip->page_size + chip->page_spare_size);
+
+		size = min(writelen, chip->page_size - page_offset);
+		memcpy(chip->buf + page_offset,
+		       ops->datbuf + ops->retlen, size);
+
+		ops->retlen += size;
+		writelen -= size;
+		page_offset = 0;
+
+		if (unlikely(ops->oobbuf)) {
+			size = min(oobwritelen, ooblen);
+
+			spi_nand_fill_oob(chip, ops->oobbuf + ops->oobretlen,
+					  size, ops);
+
+			ops->oobretlen += size;
+			oobwritelen -= size;
+		}
+		ret = spi_nand_do_write_page(mtd, page_addr,
+					     ops->mode == MTD_OOB_RAW);
+		if (ret) {
+			pr_debug("error %d writing page 0x%x\n",
+				 ret, page_addr);
+			return ret;
+		}
+		if (!writelen)
+			break;
+		page_addr++;
+	}
+	return 0;
+}
+
+/**
+ * nand_read - [MTD Interface] SPI-NAND read
+ * @mtd: MTD device structure
+ * @from: offset to read from
+ * @len: number of bytes to read
+ * @retlen: pointer to variable to store the number of read bytes
+ * @buf: the databuffer to put data
+ *
+ */
+static int spi_nand_read(struct mtd_info *mtd, loff_t from, size_t len,
+			 size_t *retlen, u_char *buf)
+{
+	struct mtd_oob_ops ops = { 0 };
+	int ret;
+
+	spi_nand_get_device(mtd, FL_READING);
+
+	ops.len = len;
+	ops.datbuf = buf;
+
+	ret = spi_nand_do_read_ops(mtd, from, &ops);
+
+	*retlen = ops.retlen;
+
+	spi_nand_release_device(mtd);
+
+	return ret;
+}
+
+/**
+ * spi_nand_write - [MTD Interface] SPI-NAND write
+ * @mtd: MTD device structure
+ * @to: offset to write to
+ * @len: number of bytes to write
+ * @retlen: pointer to variable to store the number of written bytes
+ * @buf: the data to write
+ *
+ */
+static int spi_nand_write(struct mtd_info *mtd, loff_t to, size_t len,
+			  size_t *retlen, const u_char *buf)
+{
+	struct mtd_oob_ops ops = {0};
+	int ret;
+
+	spi_nand_get_device(mtd, FL_WRITING);
+
+	ops.len = len;
+	ops.datbuf = (uint8_t *)buf;
+
+
+	ret =  spi_nand_do_write_ops(mtd, to, &ops);
+
+	*retlen = ops.retlen;
+
+	spi_nand_release_device(mtd);
+
+	return ret;
+}
+
+/**
+ * spi_nand_do_read_oob - [INTERN] SPI-NAND read out-of-band
+ * @mtd: MTD device structure
+ * @from: offset to read from
+ * @ops: oob operations description structure
+ *
+ * SPI-NAND read out-of-band data from the spare area.
+ */
+static int spi_nand_do_read_oob(struct mtd_info *mtd, loff_t from,
+				struct mtd_oob_ops *ops)
+{
+	struct spi_nand_chip *chip = mtd->priv;
+	int page_addr;
+	int corrected = 0;
+	struct mtd_ecc_stats stats;
+	int readlen = ops->ooblen;
+	int len;
+	int ret = 0;
+
+	fh_dev_debug(&chip->spi->dev, "Enter %s\n", __func__);
+
+	pr_debug("%s: from = 0x%08Lx, len = %i\n",
+		 __func__, (unsigned long long)from, readlen);
+
+	stats = mtd->ecc_stats;
+
+	len = ops->mode == MTD_OOB_AUTO ? mtd->oobavail : mtd->oobsize;
+
+	if (unlikely(ops->ooboffs >= len)) {
+		pr_debug("%s: attempt to start read outside oob\n",
+			 __func__);
+		return -EINVAL;
+	}
+
+	/* Do not allow reads past end of device */
+	if (unlikely(from >= mtd->size ||
+		     ops->ooboffs + readlen > ((mtd->size >> chip->page_shift) -
+					       (from >> chip->page_shift)) * len)) {
+		pr_debug("%s: attempt to read beyond end of device\n",
+			 __func__);
+		return -EINVAL;
+	}
+
+	/* Shift to get page */
+	page_addr = (from >> chip->page_shift);
+	len -= ops->ooboffs;
+	ops->oobretlen = 0;
+
+	while (1) {
+		/*read data from chip*/
+		ret = spi_nand_do_read_page_oob(mtd, page_addr,
+						ops->mode == MTD_OOB_RAW, &corrected);
+		if (ret) {
+			pr_debug("error %d reading page 0x%x\n",
+				 ret, page_addr);
+			return ret;
+		}
+		if (page_addr == chip->pagebuf)
+			chip->pagebuf = -1;
+
+		len = min(len, readlen);
+		spi_nand_transfer_oob(chip, ops->oobbuf + ops->oobretlen,
+				      ops, len);
+
+		readlen -= len;
+		ops->oobretlen += len;
+		if (!readlen)
+			break;
+
+		page_addr++;
+	}
+
+	if (ret < 0)
+		return ret;
+
+	if (mtd->ecc_stats.failed - stats.failed)
+		return -EBADMSG;
+
+	return  mtd->ecc_stats.corrected - stats.corrected ? -EUCLEAN : 0;
+}
+
+/**
+ * spi_nand_do_write_oob - [MTD Interface] SPI-NAND write out-of-band
+ * @mtd: MTD device structure
+ * @to: offset to write to
+ * @ops: oob operation description structure
+ *
+ * SPI-NAND write out-of-band.
+ */
+static int spi_nand_do_write_oob(struct mtd_info *mtd, loff_t to,
+				 struct mtd_oob_ops *ops)
+{
+	int page_addr, len, ret;
+	struct spi_nand_chip *chip = mtd->priv;
+	int writelen = ops->ooblen;
+
+	fh_dev_debug(&chip->spi->dev, "Enter %s\n", __func__);
+
+	pr_debug("%s: to = 0x%08x, len = %i\n",
+		 __func__, (unsigned int)to, (int)writelen);
+
+	len = ops->mode == MTD_OOB_AUTO ? mtd->oobavail : mtd->oobsize;
+
+	/* Do not allow write past end of page */
+	if ((ops->ooboffs + writelen) > len) {
+		pr_debug("%s: attempt to write past end of page\n",
+			 __func__);
+		return -EINVAL;
+	}
+
+	if (unlikely(ops->ooboffs >= len)) {
+		pr_debug("%s: attempt to start write outside oob\n",
+			 __func__);
+		return -EINVAL;
+	}
+
+	/* Do not allow write past end of device */
+	if (unlikely(to >= mtd->size ||
+		     ops->ooboffs + writelen >
+		     ((mtd->size >> chip->page_shift) -
+		      (to >> chip->page_shift)) * len)) {
+		pr_debug("%s: attempt to write beyond end of device\n",
+			 __func__);
+		return -EINVAL;
+	}
+
+	/* Shift to get page */
+	page_addr = to >> chip->page_shift;
+	/* Invalidate the page cache, if we write to the cached page */
+	if (page_addr == chip->pagebuf)
+		chip->pagebuf = -1;
+
+	spi_nand_fill_oob(chip, ops->oobbuf, writelen, ops);
+
+	ret = spi_nand_do_write_page_oob(mtd, page_addr,
+					 ops->mode == MTD_OOB_RAW);
+	if (ret) {
+		pr_debug("error %d writing page 0x%x\n",
+			 ret, page_addr);
+		return ret;
+	}
+	ops->oobretlen = writelen;
+
+	return 0;
+}
+
+/**
+ * spi_nand_read_oob - [MTD Interface] SPI-NAND read data and/or out-of-band
+ * @mtd: MTD device structure
+ * @from: offset to read from
+ * @ops: oob operation description structure
+ *
+ * SPI-NAND read data and/or out-of-band data.
+ */
+static int spi_nand_read_oob(struct mtd_info *mtd, loff_t from,
+			     struct mtd_oob_ops *ops)
+{
+	int ret = -ENOTSUPP;
+
+	struct spi_nand_chip *this = mtd->priv;
+	fh_dev_debug(&this->spi->dev, "Enter %s, from 0x%08llx \n", __func__, from);
+	ops->retlen = 0;
+
+	/* Do not allow reads past end of device */
+	if (ops->datbuf && (from + ops->len) > mtd->size) {
+		pr_debug("%s: attempt to read beyond end of device\n",
+			 __func__);
+		return -EINVAL;
+	}
+
+	spi_nand_get_device(mtd, FL_READING);
+
+	switch (ops->mode) {
+	case MTD_OOB_PLACE:
+	case MTD_OOB_AUTO:
+	case MTD_OOB_RAW:
+		break;
+
+	default:
+		goto out;
+	}
+
+	if (!ops->datbuf)
+		ret = spi_nand_do_read_oob(mtd, from, ops);
+	else
+		ret = spi_nand_do_read_ops(mtd, from, ops);
+
+out:
+	spi_nand_release_device(mtd);
+
+	return ret;
+}
+
+/**
+ * spi_nand_write_oob - [MTD Interface] SPI-NAND write data and/or out-of-band
+ * @mtd: MTD device structure
+ * @to: offset to write to
+ * @ops: oob operation description structure
+ */
+static int spi_nand_write_oob(struct mtd_info *mtd, loff_t to,
+			      struct mtd_oob_ops *ops)
+{
+	int ret = -ENOTSUPP;
+	struct spi_nand_chip *this = mtd->priv;
+	fh_dev_debug(&this->spi->dev, "Enter %s\n", __func__);
+
+	ops->retlen = 0;
+
+	/* Do not allow writes past end of device */
+	if (ops->datbuf && (to + ops->len) > mtd->size) {
+		pr_debug("%s: attempt to write beyond end of device\n",
+			 __func__);
+		return -EINVAL;
+	}
+
+	spi_nand_get_device(mtd, FL_WRITING);
+
+	switch (ops->mode) {
+	case MTD_OOB_PLACE:
+	case MTD_OOB_AUTO:
+	case MTD_OOB_RAW:
+		break;
+
+	default:
+		goto out;
+	}
+
+	if (!ops->datbuf)
+		ret = spi_nand_do_write_oob(mtd, to, ops);
+	else
+		ret = spi_nand_do_write_ops(mtd, to, ops);
+
+out:
+	spi_nand_release_device(mtd);
+
+	return ret;
+}
+
+/**
+ * spi_nand_block_bad - [INTERN] Check if block at offset is bad
+ * @mtd: MTD device structure
+ * @offs: offset relative to mtd start
+ */
+static int spi_nand_block_bad(struct mtd_info *mtd, loff_t ofs)
+{
+	struct spi_nand_chip *chip = mtd->priv;
+	struct mtd_oob_ops ops = {0};
+	u32 block_addr;
+	u8 bad[2] = {0, 0};
+	u8 ret = 0;
+
+	block_addr = ofs >> chip->block_shift;
+	ops.mode = MTD_OOB_PLACE;
+	ops.ooblen = 2;
+	ops.oobbuf = bad;
+
+	ret = spi_nand_do_read_oob(mtd, block_addr << chip->block_shift, &ops);
+	if (bad[0] != 0xFF || bad[1] != 0xFF)
+		ret =  1;
+
+	return ret;
+
+}
+
+/**
+ * spi_nand_block_checkbad - [GENERIC] Check if a block is marked bad
+ * @mtd: MTD device structure
+ * @ofs: offset from device start
+ * @allowbbt: 1, if its allowed to access the bbt area
+ *
+ * Check, if the block is bad. Either by reading the bad block table or
+ * calling of the scan function.
+ */
+static int spi_nand_block_checkbad(struct mtd_info *mtd, loff_t ofs,
+				   int allowbbt)
+{
+	struct spi_nand_chip *chip = mtd->priv;
+
+	if (!chip->bbt)
+		return spi_nand_block_bad(mtd, ofs);
+
+	/* Return info from the table */
+	return spi_nand_isbad_bbt(mtd, ofs, allowbbt);
+}
+
+/**
+ * spi_nand_block_isbad - [MTD Interface] Check if block at offset is bad
+ * @mtd: MTD device structure
+ * @offs: offset relative to mtd start
+ */
+static int spi_nand_block_isbad(struct mtd_info *mtd, loff_t offs)
+{
+	struct spi_nand_chip *chip = mtd->priv;
+	return chip->block_bad(mtd, offs, 0);
+}
+
+/**
+ * spi_nand_block_markbad_lowlevel - mark a block bad
+ * @mtd: MTD device structure
+ * @ofs: offset from device start
+ *
+ * This function performs the generic bad block marking steps (i.e., bad
+ * block table(s) and/or marker(s)). We only allow the hardware driver to
+ * specify how to write bad block markers to OOB (chip->block_markbad).
+ *
+ * We try operations in the following order:
+ *  (1) erase the affected block, to allow OOB marker to be written cleanly
+ *  (2) write bad block marker to OOB area of affected block (unless flag
+ *      NAND_BBT_NO_OOB_BBM is present)
+ *  (3) update the BBT
+ * Note that we retain the first error encountered in (2) or (3), finish the
+ * procedures, and dump the error in the end.
+*/
+static int spi_nand_block_markbad_lowlevel(struct mtd_info *mtd, loff_t ofs)
+{
+	struct spi_nand_chip *chip = mtd->priv;
+	struct mtd_oob_ops ops = {0};
+	struct erase_info einfo = {0};
+	u32 block_addr;
+	u8 buf[2] = {0, 0};
+	int res, ret = 0;
+
+	if (!(chip->bbt_options & NAND_BBT_NO_OOB_BBM)) {
+		/*erase bad block before mark bad block*/
+		einfo.mtd = mtd;
+		einfo.addr = ofs;
+		einfo.len = 1UL << chip->block_shift;
+		spi_nand_erase(mtd, &einfo);
+
+		block_addr = ofs >> chip->block_shift;
+		ops.mode = MTD_OOB_PLACE;
+		ops.ooblen = 2;
+		ops.oobbuf = buf;
+
+		ret = spi_nand_do_write_oob(mtd,
+					    block_addr << chip->block_shift, &ops);
+	}
+
+	/* Mark block bad in BBT */
+	if (chip->bbt) {
+		res = spi_nand_markbad_bbt(mtd, ofs);
+		if (!ret)
+			ret = res;
+	}
+
+	if (!ret)
+		mtd->ecc_stats.badblocks++;
+
+	return ret;
+}
+
+/**
+ * spi_nand_block_markbad - [MTD Interface] Mark block at the given offset
+ * as bad
+ * @mtd: MTD device structure
+ * @ofs: offset relative to mtd start
+ */
+static int spi_nand_block_markbad(struct mtd_info *mtd, loff_t ofs)
+{
+	int ret;
+
+	ret = spi_nand_block_isbad(mtd, ofs);
+	if (ret) {
+		/* If it was bad already, return success and do nothing */
+		if (ret > 0)
+			return 0;
+		return ret;
+	}
+
+	return spi_nand_block_markbad_lowlevel(mtd, ofs);
+}
+
+/**
+ * __spi_nand_erase - [INTERN] erase block(s)
+ * @mtd: MTD device structure
+ * @einfo: erase instruction
+ * @allowbbt: allow to access bbt
+ *
+ * Erase one ore more blocks
+ */
+int __spi_nand_erase(struct mtd_info *mtd, struct erase_info *einfo,
+		     int allowbbt)
+{
+	struct spi_nand_chip *chip = mtd->priv;
+	int page_addr, pages_per_block;
+	loff_t len;
+	u8 status;
+	int ret = 0;
+
+
+	/* check address align on block boundary */
+	if (einfo->addr & (chip->block_size - 1)) {
+		pr_debug("%s: Unaligned address\n", __func__);
+		return -EINVAL;
+	}
+
+	if (einfo->len & (chip->block_size - 1)) {
+		pr_debug("%s: Length not block aligned\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Do not allow erase past end of device */
+	if ((einfo->len + einfo->addr) > chip->size) {
+		pr_debug("%s: Erase past end of device\n", __func__);
+		return -EINVAL;
+	}
+
+	einfo->fail_addr = MTD_FAIL_ADDR_UNKNOWN;
+
+	/* Grab the lock and see if the device is available */
+	spi_nand_get_device(mtd, FL_ERASING);
+
+	pages_per_block = 1 << (chip->block_shift - chip->page_shift);
+	page_addr = einfo->addr >> chip->page_shift;
+	len = einfo->len;
+
+	einfo->state = MTD_ERASING;
+
+	while (len) {
+		/* Check if we have a bad block, we do not erase bad blocks! */
+		if (chip->block_bad(mtd, ((loff_t) page_addr) <<
+					    chip->page_shift, allowbbt)) {
+			pr_warn("%s: attempt to erase a bad block at page 0x%08x\n",
+				__func__, page_addr);
+			einfo->state = MTD_ERASE_FAILED;
+			goto erase_exit;
+		}
+		/*
+		 * Invalidate the page cache, if we erase the block which
+		 * contains the current cached page.
+		 */
+		if (page_addr <= chip->pagebuf && chip->pagebuf <
+		    (page_addr + pages_per_block))
+			chip->pagebuf = -1;
+
+		ret = chip->write_enable(chip);
+		if (ret < 0) {
+			pr_debug("write enable command failed\n");
+			einfo->state = MTD_ERASE_FAILED;
+			goto erase_exit;
+		}
+
+		ret = chip->erase_block(chip, page_addr);
+		if (ret < 0) {
+			pr_debug("block erase command failed\n");
+			einfo->state = MTD_ERASE_FAILED;
+			einfo->fail_addr = (loff_t)page_addr
+					   << chip->page_shift;
+			goto erase_exit;
+		}
+		ret = chip->waitfunc(chip, &status);
+		if (ret < 0) {
+			pr_debug("block erase command wait failed\n");
+			einfo->state = MTD_ERASE_FAILED;
+			goto erase_exit;
+		}
+		if ((status & STATUS_E_FAIL_MASK) == STATUS_E_FAIL) {
+			pr_debug("erase block 0x%012llx failed\n",
+				 ((loff_t) page_addr) << chip->page_shift);
+			einfo->state = MTD_ERASE_FAILED;
+			einfo->fail_addr = (loff_t)page_addr
+					   << chip->page_shift;
+			goto erase_exit;
+		}
+
+		/* Increment page address and decrement length */
+		len -= (1ULL << chip->block_shift);
+		page_addr += pages_per_block;
+	}
+
+	einfo->state = MTD_ERASE_DONE;
+
+erase_exit:
+
+	ret = einfo->state == MTD_ERASE_DONE ? 0 : -EIO;
+
+	spi_nand_release_device(mtd);
+
+	/* Do call back function */
+	if (!ret)
+		mtd_erase_callback(einfo);
+
+	/* Return more or less happy */
+	return ret;
+}
+EXPORT_SYMBOL(__spi_nand_erase);
+
+/**
+ * spi_nand_erase - [MTD Interface] erase block(s)
+ * @mtd: MTD device structure
+ * @einfo: erase instruction
+ *
+ * Erase one ore more blocks
+ */
+static int spi_nand_erase(struct mtd_info *mtd, struct erase_info *einfo)
+{
+	return __spi_nand_erase(mtd, einfo, 0);
+}
+
+/**
+ * spi_nand_sync - [MTD Interface] sync
+ * @mtd: MTD device structure
+ *
+ * Sync is actually a wait for chip ready function
+ */
+static void spi_nand_sync(struct mtd_info *mtd)
+{
+	pr_debug("spi_nand_sync: called\n");
+
+	/* Grab the lock and see if the device is available */
+	spi_nand_get_device(mtd, FL_SYNCING);
+
+	/* Release it and go back */
+	spi_nand_release_device(mtd);
+}
+
+/**
+ * spi_nand_suspend - [MTD Interface] Suspend the SPI-NAND flash
+ * @mtd: MTD device structure
+ */
+static int spi_nand_suspend(struct mtd_info *mtd)
+{
+	return spi_nand_get_device(mtd, FL_PM_SUSPENDED);
+}
+
+/**
+ * spi_nand_resume - [MTD Interface] Resume the SPI-NAND flash
+ * @mtd: MTD device structure
+ */
+static void spi_nand_resume(struct mtd_info *mtd)
+{
+	struct spi_nand_chip *this = mtd->priv;
+
+	if (this->state == FL_PM_SUSPENDED)
+		spi_nand_release_device(mtd);
+	else
+		pr_err("%s is not called in suspended state\n:", __func__);
+}
+
+
+/*
+ * spi_nand_send_cmd - to process a command to send to the SPI-NAND
+ * @spi: spi device structure
+ * @cmd: command structure
+ *
+ *    Set up the command buffer to send to the SPI controller.
+ *    The command buffer has to initialized to 0.
+ */
+int spi_nand_send_cmd(struct spi_device *spi, struct spi_nand_cmd *cmd)
+{
+	struct spi_message message;
+	struct spi_transfer x[4];
+	u8 buf[8],  i;
+	u32 buflen = 0;
+
+	spi_message_init(&message);
+	memset(x, 0, sizeof(x));
+	x[0].len = 1;
+	x[0].tx_buf = &cmd->cmd;
+	spi_message_add_tail(&x[0], &message);
+
+	buf[buflen++] = cmd->cmd;
+
+	if (cmd->n_addr) {
+		x[1].len = cmd->n_addr;
+		x[1].tx_buf = cmd->addr;
+		spi_message_add_tail(&x[1], &message);
+	}
+	for (i = 0; i < cmd->n_addr && buflen < 7; i++)
+		buf[buflen++] = cmd->addr[i];
+
+	if (cmd->n_tx) {
+		x[2].len = cmd->n_tx;
+		/*x[2].tx_nbits = cmd->tx_nbits; always 0 for single future version*/
+		x[2].tx_buf = cmd->tx_buf;
+		spi_message_add_tail(&x[2], &message);
+	}
+	for (i = 0; i < cmd->n_tx && buflen < 7; i++)
+		buf[buflen++] = cmd->tx_buf[i];
+
+	if (cmd->n_rx) {
+		x[3].len = cmd->n_rx;
+		/*x[3].rx_nbits = cmd->rx_nbits;*/
+		x[3].rx_buf = cmd->rx_buf;
+		spi_message_add_tail(&x[3], &message);
+	}
+	for (i = 0; i < cmd->n_rx && buflen < 7; i++)
+		buf[buflen++] = cmd->rx_buf[i];
+
+	buflen = 1 + cmd->n_addr + cmd->n_tx + cmd->n_rx;
+	if (fh_start_debug || cmd->cmd == 0x1f)
+	fh_dev_debug(&spi->dev, " spi%d:%d: send cmd 0x: %02x %02x %02x %02x %02x %02x, size %d\n",
+			spi->master->bus_num, spi->chip_select,
+		     buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buflen);
+
+	return spi_sync(spi, &message);
+}
+EXPORT_SYMBOL(spi_nand_send_cmd);
+/*
+ * spi_nand_read_status- send command 0x0f to the SPI-NAND status register value
+ * @spi: spi device structure
+ * @status: buffer to store value
+ * Description:
+ *    After read, write, or erase, the Nand device is expected to set the
+ *    busy status.
+ *    This function is to allow reading the status of the command: read,
+ *    write, and erase.
+ *    Once the status turns to be ready, the other status bits also are
+ *    valid status bits.
+ */
+static int spi_nand_read_status(struct spi_device *spi, uint8_t *status)
+{
+	struct spi_nand_cmd cmd = {0};
+	int ret;
+
+	cmd.cmd = SPINAND_CMD_READ_REG;
+	cmd.n_addr = 1;
+	cmd.addr[0] = REG_STATUS;
+	cmd.n_rx = 1;
+	cmd.rx_buf = status;
+
+	ret = spi_nand_send_cmd(spi, &cmd);
+	if (ret < 0)
+		dev_err(&spi->dev, "err: %d read status register\n", ret);
+
+	return ret;
+}
+
+/**
+ * spi_nand_get_otp- send command 0x0f to read the SPI-NAND OTP register
+ * @spi: spi device structure
+ * @opt: buffer to store value
+ * Description:
+ *   There is one bit( bit 0x10 ) to set or to clear the internal ECC.
+ *   Enable chip internal ECC, set the bit to 1
+ *   Disable chip internal ECC, clear the bit to 0
+ */
+static int spi_nand_get_otp(struct spi_device *spi, u8 *otp)
+{
+	struct spi_nand_cmd cmd = {0};
+	int ret;
+
+	cmd.cmd = SPINAND_CMD_READ_REG;
+	cmd.n_addr = 1;
+	cmd.addr[0] = REG_OTP;
+	cmd.n_rx = 1;
+	cmd.rx_buf = otp;
+
+	ret = spi_nand_send_cmd(spi, &cmd);
+	if (ret < 0)
+		dev_err(&spi->dev, "error %d get otp\n", ret);
+	return ret;
+}
+
+/**
+ * spi_nand_set_otp- send command 0x1f to write the SPI-NAND OTP register
+ * @spi: spi device structure
+ * @status: buffer stored value
+ * Description:
+ *   There is one bit( bit 0x10 ) to set or to clear the internal ECC.
+ *   Enable chip internal ECC, set the bit to 1
+ *   Disable chip internal ECC, clear the bit to 0
+ */
+static int spi_nand_set_otp(struct spi_device *spi, u8 *otp)
+{
+	int ret;
+	struct spi_nand_cmd cmd = { 0 };
+
+	cmd.cmd = SPINAND_CMD_WRITE_REG;
+	cmd.n_addr = 1;
+	cmd.addr[0] = REG_OTP;
+	cmd.n_tx = 1;
+	cmd.tx_buf = otp;
+
+	ret = spi_nand_send_cmd(spi, &cmd);
+	if (ret < 0)
+		dev_err(&spi->dev, "error %d set otp\n", ret);
+
+	return ret;
+}
+
+/**
+ * spi_nand_enable_ecc- enable internal ECC
+ * @chip: SPI-NAND device structure
+ * Description:
+ *   There is one bit( bit 0x10 ) to set or to clear the internal ECC.
+ *   Enable chip internal ECC, set the bit to 1
+ *   Disable chip internal ECC, clear the bit to 0
+ */
+static int spi_nand_enable_ecc(struct spi_nand_chip *chip)
+{
+	struct spi_device *spi = chip->spi;
+	int ret;
+	u8 otp = 0;
+
+	fh_dev_debug(&spi->dev, "Enter %s\n", __func__);
+
+	ret = spi_nand_get_otp(spi, &otp);
+	if (ret < 0)
+		return ret;
+
+	fh_dev_debug(&spi->dev, "get opt: 0x%02x\n", otp);
+	if ((otp & OTP_ECC_MASK) == OTP_ECC_ENABLE)
+		return 0;
+
+	otp |= OTP_ECC_ENABLE;
+	ret = spi_nand_set_otp(spi, &otp);
+	if (ret < 0)
+		return ret;
+	fh_dev_debug(&spi->dev, "set opt: 0x%02x\n", otp);
+	return spi_nand_get_otp(spi, &otp);
+}
+
+/**
+ * spi_nand_disable_ecc- disable internal ECC
+ * @chip: SPI-NAND device structure
+ * Description:
+ *   There is one bit( bit 0x10 ) to set or to clear the internal ECC.
+ *   Enable chip internal ECC, set the bit to 1
+ *   Disable chip internal ECC, clear the bit to 0
+ */
+static int spi_nand_disable_ecc(struct spi_nand_chip *chip)
+{
+	struct spi_device *spi = chip->spi;
+	int ret;
+	u8 otp = 0;
+
+	fh_dev_debug(&spi->dev, "Enter %s\n", __func__);
+	ret = spi_nand_get_otp(spi, &otp);
+	if (ret < 0)
+		return ret;
+
+	if ((otp & OTP_ECC_MASK) == OTP_ECC_ENABLE) {
+		otp &= ~OTP_ECC_ENABLE;
+		ret = spi_nand_set_otp(spi, &otp);
+		if (ret < 0)
+			return ret;
+		return spi_nand_get_otp(spi, &otp);
+	} else
+		return 0;
+}
+
+/**
+ * spi_nand_write_enable- send command 0x06 to enable write or erase the
+ * Nand cells
+ * @chip: SPI-NAND device structure
+ * Description:
+ *   Before write and erase the Nand cells, the write enable has to be set.
+ *   After the write or erase, the write enable bit is automatically
+ *   cleared (status register bit 2)
+ *   Set the bit 2 of the status register has the same effect
+ */
+static int spi_nand_write_enable(struct spi_nand_chip *chip)
+{
+	struct spi_nand_cmd cmd = {0};
+	struct spi_device *spi = chip->spi;
+	fh_dev_debug(&spi->dev, "Enter %s\n", __func__);
+
+	cmd.cmd = SPINAND_CMD_WR_ENABLE;
+	return spi_nand_send_cmd(spi, &cmd);
+}
+
+/*
+ * spi_nand_read_from_cache- send command 0x13 to read data from Nand to cache
+ * @chip: SPI-NAND device structure
+ * @page_addr: page to read
+ */
+static int spi_nand_read_page_to_cache(struct spi_nand_chip *chip,
+				       u32 page_addr)
+{
+	struct spi_nand_cmd cmd = {0};
+	struct spi_device *spi = chip->spi;
+	fh_dev_debug(&spi->dev, "Enter %s\n", __func__);
+
+	cmd.cmd = SPINAND_CMD_READ;
+	cmd.n_addr = 3;
+	cmd.addr[0] = (u8)(page_addr >> 16);
+	cmd.addr[1] = (u8)(page_addr >> 8);
+	cmd.addr[2] = (u8)page_addr;
+
+	return spi_nand_send_cmd(spi, &cmd);
+}
+
+/*
+ * spi_nand_read_from_cache- send command 0x03 to read out the data from the
+ * cache register
+ * Description:
+ *   The read can specify 1 to (page size + spare size) bytes of data read at
+ *   the corresponding locations.
+ *   No tRd delay.
+ */
+int spi_nand_read_from_cache(struct spi_nand_chip *chip, u32 page_addr,
+			     u32 column, size_t len, u8 *rbuf)
+{
+	struct spi_nand_cmd cmd = {0};
+	struct spi_device *spi = chip->spi;
+	fh_dev_debug(&spi->dev, "Enter %s\n", __func__);
+
+	cmd.cmd = SPINAND_CMD_READ_RDM;
+	cmd.n_addr = 3;
+	if (chip->dev_id[0]==0xC8) {/*FIXME: early GD chips, test 1G*/
+		cmd.addr[0] = 0;
+		cmd.addr[1] = (u8)(column >> 8);
+		if (chip->options & SPINAND_NEED_PLANE_SELECT)
+			cmd.addr[0] |= (u8)(((page_addr >>
+					      (chip->block_shift - chip->page_shift)) & 0x1) << 4);
+		cmd.addr[2] = (u8)column;
+	}
+	else{
+		cmd.addr[0] = (u8)(column >> 8);
+		if (chip->options & SPINAND_NEED_PLANE_SELECT)
+			cmd.addr[0] |= (u8)(((page_addr >>
+					      (chip->block_shift - chip->page_shift)) & 0x1) << 4);
+		cmd.addr[1] = (u8)column;
+		cmd.addr[2] = 0;
+	}
+	cmd.n_rx = len;
+	cmd.rx_buf = rbuf;
+
+	return spi_nand_send_cmd(spi, &cmd);
+}
+
+/*
+ * spi_nand_read_from_cache_x2- send command 0x3b to read out the data from the
+ * cache register
+ * Description:
+ *   The read can specify 1 to (page size + spare size) bytes of data read at
+ *   the corresponding locations.
+ *   No tRd delay.
+ */
+/*int spi_nand_read_from_cache_x2(struct spi_nand_chip *chip, u32 page_addr,
+		u32 column, size_t len, u8 *rbuf)
+{
+	struct spi_nand_cmd cmd = {0};
+	struct spi_device *spi = chip->spi;
+
+	cmd.cmd = SPINAND_CMD_READ_CACHE_X2;
+	cmd.n_addr = 3;
+	cmd.addr[0] = (u8)(column >> 8);
+	if (chip->options & SPINAND_NEED_PLANE_SELECT)
+		cmd.addr[0] |= (u8)(((page_addr >>
+			(chip->block_shift - chip->page_shift)) & 0x1) << 4);
+	cmd.addr[1] = (u8)column;
+	cmd.addr[2] = 0;
+	cmd.n_rx = len;
+	cmd.rx_nbits = SPI_NBITS_DUAL;
+	cmd.rx_buf = rbuf;
+
+	return spi_nand_send_cmd(spi, &cmd);
+}*/
+
+/*
+ * spi_nand_read_from_cache_x4- send command 0x6b to read out the data from the
+ * cache register
+ * Description:
+ *   The read can specify 1 to (page size + spare size) bytes of data read at
+ *   the corresponding locations.
+ *   No tRd delay.
+ */
+/*int spi_nand_read_from_cache_x4(struct spi_nand_chip *chip, u32 page_addr,
+		u32 column, size_t len, u8 *rbuf)
+{
+	struct spi_nand_cmd cmd = {0};
+	struct spi_device *spi = chip->spi;
+
+	cmd.cmd = SPINAND_CMD_READ_CACHE_X4;
+	cmd.n_addr = 3;
+	cmd.addr[0] = (u8)(column >> 8);
+	if (chip->options & SPINAND_NEED_PLANE_SELECT)
+		cmd.addr[0] |= (u8)(((page_addr >>
+			(chip->block_shift - chip->page_shift)) & 0x1) << 4);
+	cmd.addr[1] = (u8)column;
+	cmd.addr[2] = 0;
+	cmd.n_rx = len;
+	cmd.rx_nbits = SPI_NBITS_QUAD;
+	cmd.rx_buf = rbuf;
+
+	return spi_nand_send_cmd(spi, &cmd);
+}*/
+
+/*
+ * spi_nand_read_from_cache_snor_protocol- send command 0x03 to read out the
+ * data from the cache register, 0x03 command protocol is same as SPI NOR
+ * read command
+ * Description:
+ *   The read can specify 1 to (page size + spare size) bytes of data read at
+ *   the corresponding locations.
+ *   No tRd delay.
+ */
+int spi_nand_read_from_cache_snor_protocol(struct spi_nand_chip *chip,
+		u32 page_addr, u32 column, size_t len, u8 *rbuf)
+{
+	struct spi_nand_cmd cmd = {0};
+	struct spi_device *spi = chip->spi;
+	fh_dev_debug(&spi->dev, "Enter %s\n", __func__);
+
+	cmd.cmd = SPINAND_CMD_READ_RDM;
+	cmd.n_addr = 3;
+	cmd.addr[0] = 0;
+	cmd.addr[1] = (u8)(column >> 8);
+	if (chip->options & SPINAND_NEED_PLANE_SELECT)
+		cmd.addr[1] |= (u8)(((page_addr >>
+				      (chip->block_shift - chip->page_shift)) & 0x1) << 4);
+	cmd.addr[2] = (u8)column;
+	cmd.n_rx = len;
+	cmd.rx_buf = rbuf;
+
+	return spi_nand_send_cmd(spi, &cmd);
+}
+EXPORT_SYMBOL(spi_nand_read_from_cache_snor_protocol);
+
+/*
+ * spi_nand_program_data_to_cache--to write a page to cache
+ * @chip: SPI-NAND device structure
+ * @page_addr: page to write
+ * @column: the location to write to the cache
+ * @len: number of bytes to write
+ * wrbuf: buffer held @len bytes
+ *
+ * Description:
+ *   The write command used here is 0x02--indicating that the cache is
+ *   cleared first.
+ *   Since it is writing the data to cache, there is no tPROG time.
+ */
+static int spi_nand_program_data_to_cache(struct spi_nand_chip *chip,
+		u32 page_addr, u32 column, size_t len, u8 *wbuf)
+{
+	struct spi_nand_cmd cmd = {0};
+	struct spi_device *spi = chip->spi;
+	fh_dev_debug(&spi->dev, "Enter %s\n", __func__);
+
+	cmd.cmd = SPINAND_CMD_PROG_LOAD;
+	cmd.n_addr = 2;
+	cmd.addr[0] = (u8)(column >> 8);
+	if (chip->options & SPINAND_NEED_PLANE_SELECT)
+		cmd.addr[0] |= (u8)(((page_addr >>
+				      (chip->block_shift - chip->page_shift)) & 0x1) << 4);
+	cmd.addr[1] = (u8)column;
+	cmd.n_tx = len;
+	cmd.tx_buf = wbuf;
+	fh_dev_debug(&spi->dev, "see n_tx %d,  oob[4] 0x%08x\n", len, *(uint32_t*)(wbuf+2048));
+
+	return spi_nand_send_cmd(spi, &cmd);
+}
+
+/**
+ * spi_nand_program_execute--to write a page from cache to the Nand array
+ * @chip: SPI-NAND device structure
+ * @page_addr: the physical page location to write the page.
+ *
+ * Description:
+ *   The write command used here is 0x10--indicating the cache is writing to
+ *   the Nand array.
+ *   Need to wait for tPROG time to finish the transaction.
+ */
+static int spi_nand_program_execute(struct spi_nand_chip *chip, u32 page_addr)
+{
+	struct spi_nand_cmd cmd = {0};
+	struct spi_device *spi = chip->spi;
+
+	fh_dev_debug(&spi->dev, "Enter %s\n", __func__);
+	cmd.cmd = SPINAND_CMD_PROG;
+	cmd.n_addr = 3;
+	cmd.addr[0] = (u8)(page_addr >> 16);
+	cmd.addr[1] = (u8)(page_addr >> 8);
+	cmd.addr[2] = (u8)page_addr;
+
+
+	return spi_nand_send_cmd(spi, &cmd);
+}
+
+
+/**
+ * spi_nand_erase_block_erase--to erase a block
+ * @chip: SPI-NAND device structure
+ * @page_addr: the page to erase.
+ *
+ * Description:
+ *   The command used here is 0xd8--indicating an erase command to erase
+ *   one block
+ *   Need to wait for tERS.
+ */
+static int spi_nand_erase_block(struct spi_nand_chip *chip,
+				u32 page_addr)
+{
+	struct spi_nand_cmd cmd = {0};
+	struct spi_device *spi = chip->spi;
+	fh_dev_debug(&spi->dev, "Enter %s\n", __func__);
+
+	cmd.cmd = SPINAND_CMD_ERASE_BLK;
+	cmd.n_addr = 3;
+	cmd.addr[0] = (u8)(page_addr >> 16);
+	cmd.addr[1] = (u8)(page_addr >> 8);
+	cmd.addr[2] = (u8)page_addr;
+
+	return spi_nand_send_cmd(spi, &cmd);
+}
+
+/**
+ * spi_nand_wait - [DEFAULT] wait until the command is done
+ * @chip: SPI-NAND device structure
+ * @s: buffer to store status register(can be NULL)
+ *
+ * Wait for command done. This applies to erase and program only. Erase can
+ * take up to 400ms and program up to 20ms.
+ */
+static int spi_nand_wait(struct spi_nand_chip *chip, u8 *s)
+{
+	unsigned long timeo = jiffies;
+	u8 status, state = chip->state;
+	int ret = -ETIMEDOUT;
+	fh_dev_debug(&chip->spi->dev, "Enter %s\n", __func__);
+
+	if (state == FL_ERASING)
+		timeo += msecs_to_jiffies(400);
+	else
+		timeo += msecs_to_jiffies(400); // 20 -> 40 for mx2g
+
+	while (time_before(jiffies, timeo)) {
+		spi_nand_read_status(chip->spi, &status);
+		if ((status & STATUS_OIP_MASK) == STATUS_READY) {
+			ret = 0;
+			goto out;
+		}
+		cond_resched();
+	}
+out:
+	if (s)
+		*s = status;
+
+	return 0;
+}
+
+
+/*
+ * spi_nand_reset- send RESET command "0xff" to the SPI-NAND.
+ * @chip: SPI-NAND device structure
+ */
+static int spi_nand_reset(struct spi_nand_chip *chip)
+{
+	struct spi_nand_cmd cmd = {0};
+	struct spi_device *spi = chip->spi;
+	fh_dev_debug(&spi->dev, "Enter %s\n", __func__);
+
+	cmd.cmd = SPINAND_CMD_RESET;
+
+	if (spi_nand_send_cmd(spi, &cmd) < 0)
+		pr_err("spi_nand reset failed!\n");
+
+	/* elapse 1ms before issuing any other command */
+	udelay(1000);
+
+	return 0;
+}
+
+
+/**
+ * spi_nand_lock_block- send write register 0x1f command to the lock/unlock device
+ * @spi: spi device structure
+ * @lock: value to set to block lock register
+ *
+ * Description:
+ *    After power up, all the Nand blocks are locked.  This function allows
+ *    one to unlock the blocks, and so it can be written or erased.
+ */
+static int spi_nand_lock_block(struct spi_device *spi, u8 lock)
+{
+	struct spi_nand_cmd cmd = {0};
+	int ret;
+
+	cmd.cmd = SPINAND_CMD_WRITE_REG;
+	cmd.n_addr = 1;
+	cmd.addr[0] = REG_BLOCK_LOCK;
+	cmd.n_tx = 1;
+	cmd.tx_buf = &lock;
+
+	ret = spi_nand_send_cmd(spi, &cmd);
+	if (ret < 0)
+		dev_err(&spi->dev, "error %d lock block\n", ret);
+
+	return ret;
+}
+
+static u16 onfi_crc16(u16 crc, u8 const *p, size_t len)
+{
+	int i;
+
+	while (len--) {
+		crc ^= *p++ << 8;
+		for (i = 0; i < 8; i++)
+			crc = (crc << 1) ^ ((crc & 0x8000) ? 0x8005 : 0);
+	}
+
+	return crc;
+}
+
+/* Sanitize ONFI strings so we can safely print them */
+static void sanitize_string(uint8_t *s, size_t len)
+{
+	ssize_t i;
+
+	/* Null terminate */
+	s[len - 1] = 0;
+
+	/* Remove non printable chars */
+	for (i = 0; i < len - 1; i++) {
+		if (s[i] < ' ' || s[i] > 127)
+			s[i] = '?';
+	}
+
+	/* Remove trailing spaces */
+	strim(s);
+}
+
+/*
+ * Check if the SPI-NAND chip is ONFI compliant,
+ * returns 1 if it is, 0 otherwise.
+ */
+static bool spi_nand_detect_onfi(struct spi_nand_chip *chip)
+{
+	struct spi_device *spi = chip->spi;
+	struct spi_nand_onfi_params *p;
+	char *buffer;
+	bool ret = true;
+	u8 otp;
+	int i;
+
+	/*FIXME buffer size*/
+	buffer = kmalloc(256 * 3, GFP_KERNEL);
+	otp = OTP_ENABLE;
+	spi_nand_set_otp(spi, &otp);
+	chip->load_page(chip, 0x01);
+	chip->waitfunc(chip, NULL);
+	spi_nand_read_from_cache(chip, 0x01, 0x00, 256 * 3, buffer);
+	otp = OTP_ECC_ENABLE;
+	spi_nand_set_otp(spi, &otp);
+
+	p = (struct spi_nand_onfi_params *)buffer;
+	for (i = 0; i < 3; i++, p++) {
+		if (p->sig[0] != 'O' || p->sig[1] != 'N' ||
+		    p->sig[2] != 'F' || p->sig[3] != 'I')
+			continue;
+		if (onfi_crc16(ONFI_CRC_BASE, (uint8_t *)p, 254) ==
+		    le16_to_cpu(p->crc))
+			break;
+	}
+	if (i == 3) {
+		pr_err("Could not find valid ONFI parameter page; aborting\n");
+		ret = false;
+		goto out;
+	}
+
+	memcpy(&chip->onfi_params, p, sizeof(*p));
+
+	p = &chip->onfi_params;
+
+	sanitize_string(p->manufacturer, sizeof(p->manufacturer));
+	sanitize_string(p->model, sizeof(p->model));
+
+	chip->name = p->model;
+	chip->size = le32_to_cpu(p->byte_per_page) *
+		     le32_to_cpu(p->pages_per_block) *
+		     le32_to_cpu(p->blocks_per_lun) * p->lun_count;
+	chip->block_size = le32_to_cpu(p->byte_per_page) *
+			   le32_to_cpu(p->pages_per_block);
+	chip->page_size = le32_to_cpu(p->byte_per_page);
+	chip->page_spare_size = le16_to_cpu(p->spare_bytes_per_page);
+	chip->block_shift = ilog2(chip->block_size);
+	chip->page_shift = ilog2(chip->page_size);
+	chip->page_mask = chip->page_size - 1;
+	chip->bits_per_cell = p->bits_per_cell;
+	/*FIXME need to find a way to read options from ONFI table*/
+	chip->options = SPINAND_NEED_PLANE_SELECT;
+	if (p->ecc_bits != 0xff) {
+		chip->ecc_strength_ds = p->ecc_bits;
+		chip->ecc_step_ds = 512;
+	}
+
+out:
+	kfree(buffer);
+	return ret;
+}
+
+static void spi_nand_set_defaults(struct spi_nand_chip *chip)
+{
+	/*struct spi_device *spi = chip->spi;*/
+
+	/*	if (spi->mode & SPI_RX_QUAD)
+			chip->read_cache = spi_nand_read_from_cache_x4;
+		else if (spi->mode & SPI_RX_DUAL)
+			chip->read_cache = spi_nand_read_from_cache_x2;
+		else*/
+	chip->read_cache = spi_nand_read_from_cache;
+
+	if (!chip->reset)
+		chip->reset = spi_nand_reset;
+	if (!chip->erase_block)
+		chip->erase_block = spi_nand_erase_block;
+	if (!chip->load_page)
+		chip->load_page = spi_nand_read_page_to_cache;
+	if (!chip->store_cache)
+		chip->store_cache = spi_nand_program_data_to_cache;
+	if (!chip->write_page)
+		chip->write_page = spi_nand_program_execute;
+	if (!chip->write_enable)
+		chip->write_enable = spi_nand_write_enable;
+	if (!chip->waitfunc)
+		chip->waitfunc = spi_nand_wait;
+	if (!chip->enable_ecc)
+		chip->enable_ecc = spi_nand_enable_ecc;
+	if (!chip->disable_ecc)
+		chip->disable_ecc = spi_nand_disable_ecc;
+	if (!chip->block_bad)
+		chip->block_bad = spi_nand_block_checkbad;
+}
+
+static int spi_nand_check(struct spi_nand_chip *chip)
+{
+	if (!chip->reset)
+		return -ENODEV;
+	if (!chip->read_id)
+		return -ENODEV;
+	if (!chip->load_page)
+		return -ENODEV;
+	if (!chip->read_cache)
+		return -ENODEV;
+	if (!chip->store_cache)
+		return -ENODEV;
+	if (!chip->write_page)
+		return -ENODEV;
+	if (!chip->erase_block)
+		return -ENODEV;
+	if (!chip->waitfunc)
+		return -ENODEV;
+	if (!chip->write_enable)
+		return -ENODEV;
+	if (!chip->get_ecc_status)
+		return -ENODEV;
+	if (!chip->enable_ecc)
+		return -ENODEV;
+	if (!chip->disable_ecc)
+		return -ENODEV;
+	if (!chip->ecclayout)
+		return -ENODEV;
+	return 0;
+}
+
+/**
+ * spi_nand_scan_ident - [SPI-NAND Interface] Scan for the SPI-NAND device
+ * @mtd: MTD device structure
+ *
+ * This is the first phase of the normal spi_nand_scan() function. It reads the
+ * flash ID and sets up MTD fields accordingly.
+ *
+ */
+int spi_nand_scan_ident(struct mtd_info *mtd)
+{
+	int ret;
+	u8 id[SPINAND_MAX_ID_LEN] = {0};
+	struct spi_nand_chip *chip = mtd->priv;
+
+	spi_nand_set_defaults(chip);
+	chip->reset(chip);
+
+	chip->read_id(chip, id);
+	if (id[0] == 0 && id[1] == 0) {
+		pr_err("SPINAND: read id error! 0x%02x, 0x%02x!\n",
+		       id[0], id[1]);
+		return -ENODEV;
+	}
+
+	pr_err("SPINAND: read id ! 0x%02x, 0x%02x 0x%02x, 0x%02x!\n",
+		id[0], id[1], id[2], id[3]);
+	if (spi_nand_scan_id_table(chip, id))
+		goto ident_done;
+	pr_info("SPI-NAND type mfr_id: %x, dev_id: %x is not in id table.\n",
+		id[0], id[1]);
+
+	if (spi_nand_detect_onfi(chip))
+		goto ident_done;
+
+	return -ENODEV;
+
+ident_done:
+	pr_info("SPI-NAND: %s is found.\n", chip->name);
+
+	/*chip->mfr_id = id[0];
+	chip->dev_id = id[1];*/
+
+	chip->buf = kzalloc(chip->page_size + chip->page_spare_size,
+			    GFP_KERNEL);
+	if (!chip->buf)
+		return -ENOMEM;
+
+	chip->oobbuf = chip->buf + chip->page_size;
+
+	ret = spi_nand_lock_block(chip->spi, BL_ALL_UNLOCKED);
+	ret = chip->enable_ecc(chip);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(spi_nand_scan_ident);
+
+/**
+ * spi_nand_scan_tail - [SPI-NAND Interface] Scan for the SPI-NAND device
+ * @mtd: MTD device structure
+ *
+ * This is the second phase of the normal spi_nand_scan() function. It fills out
+ * all the uninitialized function pointers with the defaults.
+ */
+int spi_nand_scan_tail(struct mtd_info *mtd)
+{
+	struct spi_nand_chip *chip = mtd->priv;
+	int ret;
+
+	ret = spi_nand_check(chip);
+	if (ret)
+		return ret;
+	/* Initialize state */
+	chip->state = FL_READY;
+	/* Invalidate the pagebuffer reference */
+	chip->pagebuf = -1;
+	chip->bbt_options |= NAND_BBT_USE_FLASH;
+	chip->badblockpos = NAND_LARGE_BADBLOCK_POS;
+
+	init_waitqueue_head(&chip->wq);
+	spin_lock_init(&chip->chip_lock);
+
+	mtd->name = chip->name;
+	mtd->size = chip->size;
+	mtd->erasesize = chip->block_size;
+	mtd->writesize = chip->page_size;
+	mtd->writebufsize = mtd->writesize;
+	mtd->oobsize = chip->page_spare_size;
+	mtd->owner = THIS_MODULE;
+	mtd->type = MTD_NANDFLASH;
+	mtd->flags = MTD_CAP_NANDFLASH;
+	/*xxx:porting down: if (!mtd->ecc_strength)
+			mtd->ecc_strength = chip->ecc_strength_ds ?
+						chip->ecc_strength_ds : 1;*/
+
+	mtd->ecclayout = chip->ecclayout;
+	mtd->oobsize = chip->page_spare_size;
+	mtd->oobavail = chip->ecclayout->oobavail;
+	/* remove _* */
+	mtd->erase = spi_nand_erase;
+	mtd->point = NULL;
+	mtd->unpoint = NULL;
+	mtd->read = spi_nand_read;
+	mtd->write = spi_nand_write;
+	mtd->read_oob = spi_nand_read_oob;
+	mtd->write_oob = spi_nand_write_oob;
+	mtd->sync = spi_nand_sync;
+	mtd->lock = NULL;
+	mtd->unlock = NULL;
+	mtd->suspend = spi_nand_suspend;
+	mtd->resume = spi_nand_resume;
+	mtd->block_isbad = spi_nand_block_isbad;
+	mtd->block_markbad = spi_nand_block_markbad;
+
+#ifndef CONFIG_SPI_NAND_BBT
+	/* Build bad block table */
+	return spi_nand_default_bbt(mtd);
+#else
+	return 0;
+#endif
+}
+EXPORT_SYMBOL_GPL(spi_nand_scan_tail);
+
+/**
+ * spi_nand_scan_ident_release - [SPI-NAND Interface] Free resources
+ * applied by spi_nand_scan_ident
+ * @mtd: MTD device structure
+ */
+int spi_nand_scan_ident_release(struct mtd_info *mtd)
+{
+	struct spi_nand_chip *chip = mtd->priv;
+
+	kfree(chip->buf);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(spi_nand_scan_ident_release);
+
+/**
+ * spi_nand_scan_tail_release - [SPI-NAND Interface] Free resources
+ * applied by spi_nand_scan_tail
+ * @mtd: MTD device structure
+ */
+int spi_nand_scan_tail_release(struct mtd_info *mtd)
+{
+	return 0;
+}
+EXPORT_SYMBOL_GPL(spi_nand_scan_tail_release);
+
+/**
+ * spi_nand_release - [SPI-NAND Interface] Free resources held by the SPI-NAND
+ * device
+ * @mtd: MTD device structure
+ */
+int spi_nand_release(struct mtd_info *mtd)
+{
+	struct spi_nand_chip *chip = mtd->priv;
+
+	mtd_device_unregister(mtd);
+	kfree(chip->buf);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(spi_nand_release);
+
+MODULE_DESCRIPTION("SPI NAND framework");
+MODULE_AUTHOR("Peter Pan<peterpandong at micron.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uraN linux-3.0.8/drivers/mtd/spi-nand/spi-nand-bbt.c linux-3.0.8-fh8632-V1.0_20180330/drivers/mtd/spi-nand/spi-nand-bbt.c
--- linux-3.0.8/drivers/mtd/spi-nand/spi-nand-bbt.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/mtd/spi-nand/spi-nand-bbt.c	2021-07-13 23:40:34.578361912 +0300
@@ -0,0 +1,1356 @@
+/*
+ *  drivers/mtd/spi_nand_bbt.c
+ *
+ *  Overview:
+ *   Bad block table support for the SPI-NAND driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This file is derived from nand_base.c
+ *
+ * TODO:
+ *   share BBT code with parallel nand
+ */
+
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/bbm.h>
+#include <linux/mtd/spi-nand.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/vmalloc.h>
+#include <linux/string.h>
+#include <linux/spi/spi.h>
+#include <asm/string.h>
+
+#define BBT_BLOCK_GOOD		0x00
+#define BBT_BLOCK_WORN		0x01
+#define BBT_BLOCK_RESERVED	0x02
+#define BBT_BLOCK_FACTORY_BAD	0x03
+
+#define BBT_ENTRY_MASK		0x03
+#define BBT_ENTRY_SHIFT		2
+
+#ifdef SPINAND_BBT_DEBUG
+#define fh_dev_debug		dev_err
+#define fh_debug_dump(buf,len)  do { \
+		unsigned int i; \
+		printk("\t %s:L%d", __func__,__LINE__); \
+		for (i=0;i<len/4;i++) { \
+			if (0 == i % 4 ) \
+				printk("\n\t\t 0x%08x:\t",(unsigned int) buf+i*4 ); \
+			printk("%08x ", *(unsigned int*) (buf + i*4));\
+		} \
+	} while(0)
+#else
+#define fh_dev_debug(...)
+#define fh_debug_dump(buf,len)
+#endif
+
+
+static int spi_nand_update_bbt(struct mtd_info *mtd, loff_t offs);
+
+static inline uint8_t bbt_get_entry(struct spi_nand_chip *chip, int block)
+{
+	uint8_t entry = chip->bbt[block >> BBT_ENTRY_SHIFT];
+
+	entry >>= (block & BBT_ENTRY_MASK) * 2;
+	return entry & BBT_ENTRY_MASK;
+}
+
+static inline void bbt_mark_entry(struct spi_nand_chip *chip, int block,
+				  uint8_t mark)
+{
+	uint8_t msk = (mark & BBT_ENTRY_MASK) << ((block & BBT_ENTRY_MASK) * 2);
+
+	chip->bbt[block >> BBT_ENTRY_SHIFT] |= msk;
+}
+
+static int check_pattern_no_oob(uint8_t *buf, struct nand_bbt_descr *td)
+{
+	if (memcmp(buf, td->pattern, td->len))
+		return -1;
+	return 0;
+}
+
+/**
+ * check_pattern - [GENERIC] check if a pattern is in the buffer
+ * @buf: the buffer to search
+ * @len: the length of buffer to search
+ * @paglen: the pagelength
+ * @td: search pattern descriptor
+ *
+ * Check for a pattern at the given place. Used to search bad block tables and
+ * good / bad block identifiers.
+ */
+static int check_pattern(uint8_t *buf, int len, int paglen,
+			 struct nand_bbt_descr *td)
+{
+	if (td->options & NAND_BBT_NO_OOB)
+		return check_pattern_no_oob(buf, td);
+
+	/* Compare the pattern */
+	fh_debug_dump(buf + paglen + td->offs, td->len);
+	if (memcmp(buf + paglen + td->offs, td->pattern, td->len))
+		return -1;
+
+	return 0;
+}
+
+/**
+ * check_short_pattern - [GENERIC] check if a pattern is in the buffer
+ * @buf: the buffer to search
+ * @td:	search pattern descriptor
+ *
+ * Check for a pattern at the given place. Used to search bad block tables and
+ * good / bad block identifiers. Same as check_pattern, but no optional empty
+ * check.
+ */
+static int check_short_pattern(uint8_t *buf, struct nand_bbt_descr *td)
+{
+	/* Compare the pattern */
+	if (memcmp(buf + td->offs, td->pattern, td->len))
+		return -1;
+	return 0;
+}
+
+/**
+ * add_marker_len - compute the length of the marker in data area
+ * @td: BBT descriptor used for computation
+ *
+ * The length will be 0 if the marker is located in OOB area.
+ */
+static u32 add_marker_len(struct nand_bbt_descr *td)
+{
+	u32 len;
+
+	if (!(td->options & NAND_BBT_NO_OOB))
+		return 0;
+
+	len = td->len;
+	if (td->options & NAND_BBT_VERSION)
+		len++;
+	return len;
+}
+
+static inline int mtd_is_eccerr(int err)
+{
+	return err == -EBADMSG;
+}
+
+static inline int mtd_is_bitflip(int err)
+{
+	return err == -EUCLEAN;
+}
+
+static inline int mtd_is_bitflip_or_eccerr(int err)
+{
+	return mtd_is_bitflip(err) || mtd_is_eccerr(err);
+}
+/**
+ * read_bbt - [GENERIC] Read the bad block table starting from page
+ * @mtd: MTD device structure
+ * @buf: temporary buffer
+ * @page: the starting page
+ * @num: the number of bbt descriptors to read
+ * @td: the bbt describtion table
+ * @offs: block number offset in the table
+ *
+ * Read the bad block table starting from page.
+ */
+static int read_bbt(struct mtd_info *mtd, uint8_t *buf, int page, int num,
+		    struct nand_bbt_descr *td, int offs)
+{
+	int res, ret = 0, i, j, act = 0;
+	struct spi_nand_chip *this = mtd->priv;
+	size_t retlen, len, totlen;
+	loff_t from;
+	int bits = td->options & NAND_BBT_NRBITS_MSK;
+	uint8_t msk = (uint8_t)((1 << bits) - 1);
+	u32 marker_len;
+	int reserved_block_code = td->reserved_block_code;
+
+	totlen = (num * bits) >> 3;
+	marker_len = add_marker_len(td);
+	from = ((loff_t)page) << this->page_shift;
+
+	while (totlen) {
+		len = min(totlen, (size_t)(1 << this->block_shift));
+		if (marker_len) {
+			/*
+			 * In case the BBT marker is not in the OOB area it
+			 * will be just in the first page.
+			 */
+			len -= marker_len;
+			from += marker_len;
+			marker_len = 0;
+		}
+		res = mtd->read(mtd, from, len, &retlen,
+				buf); /*/// mtd_read(mtd, from, len, &retlen, buf);*/
+		if (res < 0) {
+			if (mtd_is_eccerr(res)) {
+				pr_info("spi_nand_bbt: ECC error in BBT at 0x%012llx\n",
+					from & ~mtd->writesize);
+				return res;
+			} else if (mtd_is_bitflip(res)) {
+				pr_info("spi_nand_bbt: corrected error in BBT at 0x%012llx\n",
+					from & ~mtd->writesize);
+				ret = res;
+			} else {
+				pr_info("spi_nand_bbt: error reading BBT\n");
+				return res;
+			}
+		}
+
+		/* Analyse data */
+		for (i = 0; i < len; i++) {
+			uint8_t dat = buf[i];
+
+			for (j = 0; j < 8; j += bits, act++) {
+				uint8_t tmp = (dat >> j) & msk;
+
+				if (tmp == msk)
+					continue;
+				if (reserved_block_code &&
+				    (tmp == reserved_block_code)) {
+					pr_info("spi_nand_read_bbt: reserved block at 0x%012llx\n",
+						(loff_t)(offs + act) <<
+						this->block_shift);
+					bbt_mark_entry(this, offs + act,
+						       BBT_BLOCK_RESERVED);
+					mtd->ecc_stats.bbtblocks++;
+					continue;
+				}
+				/*
+				 * Leave it for now, if it's matured we can
+				 * move this message to pr_debug.
+				 */
+				pr_info("spi_nand_read_bbt: bad block at 0x%012llx\n",
+					(loff_t)(offs + act) <<
+					this->block_shift);
+				/* Factory marked bad or worn out? */
+				if (tmp == 0)
+					bbt_mark_entry(this, offs + act,
+						       BBT_BLOCK_FACTORY_BAD);
+				else
+					bbt_mark_entry(this, offs + act,
+						       BBT_BLOCK_WORN);
+				mtd->ecc_stats.badblocks++;
+			}
+		}
+		totlen -= len;
+		from += len;
+	}
+	return ret;
+}
+
+/**
+ * read_abs_bbt - [GENERIC] Read the bad block table starting at a given page
+ * @mtd: MTD device structure
+ * @buf: temporary buffer
+ * @td: descriptor for the bad block table
+ * @chip: read the table for a specific chip, -1 read all chips; applies only if
+ *        NAND_BBT_PERCHIP option is set
+ *
+ * Read the bad block table for all chips starting at a given page. We assume
+ * that the bbt bits are in consecutive order.
+ */
+static int read_abs_bbt(struct mtd_info *mtd, uint8_t *buf,
+			struct nand_bbt_descr *td, int chip)
+{
+	struct spi_nand_chip *this = mtd->priv;
+	int res = 0;
+
+	res = read_bbt(mtd, buf, td->pages[0],
+		       mtd->size >> this->block_shift, td, 0);
+	if (res)
+		return res;
+
+	return 0;
+}
+
+/* BBT marker is in the first page, no OOB */
+static int scan_read_data(struct mtd_info *mtd, uint8_t *buf, loff_t offs,
+			  struct nand_bbt_descr *td)
+{
+	size_t retlen;
+	size_t len;
+
+	len = td->len;
+	if (td->options & NAND_BBT_VERSION)
+		len++;
+
+	/*return mtd_read(mtd, offs, len, &retlen, buf);*/
+	return mtd->read(mtd, offs, len, &retlen, buf);
+}
+
+/**
+ * scan_read_oob - [GENERIC] Scan data+OOB region to buffer
+ * @mtd: MTD device structure
+ * @buf: temporary buffer
+ * @offs: offset at which to scan
+ * @len: length of data region to read
+ *
+ * Scan read data from data+OOB. May traverse multiple pages, interleaving
+ * page,OOB,page,OOB,... in buf. Completes transfer and returns the "strongest"
+ * ECC condition (error or bitflip). May quit on the first (non-ECC) error.
+ */
+static int scan_read_oob(struct mtd_info *mtd, uint8_t *buf, loff_t offs,
+			 size_t len)
+{
+	struct mtd_oob_ops ops;
+	int res, ret = 0;
+	struct spi_nand_chip *chip = mtd->priv;
+	fh_dev_debug(&chip->spi->dev, "Enter %s\n", __func__);
+
+	ops.mode = MTD_OOB_PLACE;
+	ops.ooboffs = 0;
+	ops.ooblen = mtd->oobsize;
+
+	while (len > 0) {
+		ops.datbuf = buf;
+		ops.len = min_t(size_t, len, mtd->writesize);
+		ops.oobbuf = buf + ops.len;
+
+		/*res = mtd_read_oob(mtd, offs, &ops);*/
+		res = mtd->read_oob(mtd, offs, &ops);
+		if (res) {
+			if (!mtd_is_bitflip_or_eccerr(res))
+				return res;
+			else if (mtd_is_eccerr(res) || !ret)
+				ret = res;
+		}
+
+		buf += mtd->oobsize + mtd->writesize;
+		len -= mtd->writesize;
+		offs += mtd->writesize;
+	}
+	return ret;
+}
+
+static int scan_read(struct mtd_info *mtd, uint8_t *buf, loff_t offs,
+		     size_t len, struct nand_bbt_descr *td)
+{
+	if (td->options & NAND_BBT_NO_OOB)
+		return scan_read_data(mtd, buf, offs, td);
+	else
+		return scan_read_oob(mtd, buf, offs, len);
+}
+
+/* Scan write data with oob to flash */
+static int scan_write_bbt(struct mtd_info *mtd, loff_t offs, size_t len,
+			  uint8_t *buf, uint8_t *oob)
+{
+	struct mtd_oob_ops ops;
+
+	ops.mode = MTD_OOB_PLACE;
+	ops.ooboffs = 0;
+	ops.ooblen = mtd->oobsize;
+	ops.datbuf = buf;
+	ops.oobbuf = oob;
+	ops.len = len;
+
+	/*return mtd_write_oob(mtd, offs, &ops);*/
+	return mtd->write_oob(mtd, offs, &ops);
+}
+
+static u32 bbt_get_ver_offs(struct mtd_info *mtd, struct nand_bbt_descr *td)
+{
+	u32 ver_offs = td->veroffs;
+
+	if (!(td->options & NAND_BBT_NO_OOB))
+		ver_offs += mtd->writesize;
+	return ver_offs;
+}
+
+/**
+ * read_abs_bbts - [GENERIC] Read the bad block table(s) for all chips starting at a given page
+ * @mtd: MTD device structure
+ * @buf: temporary buffer
+ * @td: descriptor for the bad block table
+ * @md:	descriptor for the bad block table mirror
+ *
+ * Read the bad block table(s) for all chips starting at a given page. We
+ * assume that the bbt bits are in consecutive order.
+ */
+static void read_abs_bbts(struct mtd_info *mtd, uint8_t *buf,
+			  struct nand_bbt_descr *td, struct nand_bbt_descr *md)
+{
+	struct spi_nand_chip *this = mtd->priv;
+
+	/* Read the primary version, if available */
+	if (td->options & NAND_BBT_VERSION) {
+		scan_read(mtd, buf, (loff_t)td->pages[0] << this->page_shift,
+			  mtd->writesize, td);
+		td->version[0] = buf[bbt_get_ver_offs(mtd, td)];
+		pr_info("Bad block table at page %d, version 0x%02X\n",
+			td->pages[0], td->version[0]);
+	}
+
+	/* Read the mirror version, if available */
+	if (md && (md->options & NAND_BBT_VERSION)) {
+		scan_read(mtd, buf, (loff_t)md->pages[0] << this->page_shift,
+			  mtd->writesize, md);
+		md->version[0] = buf[bbt_get_ver_offs(mtd, md)];
+		pr_info("Bad block table at page %d, version 0x%02X\n",
+			md->pages[0], md->version[0]);
+	}
+}
+
+/* Scan a given block partially */
+static int scan_block_fast(struct mtd_info *mtd, struct nand_bbt_descr *bd,
+			   loff_t offs, uint8_t *buf, int numpages)
+{
+	struct mtd_oob_ops ops;
+	int j, ret;
+
+	ops.ooblen = mtd->oobsize;
+	ops.oobbuf = buf;
+	ops.ooboffs = 0;
+	ops.datbuf = NULL;
+	ops.mode = MTD_OOB_PLACE;
+
+	for (j = 0; j < numpages; j++) {
+		/*
+		 * Read the full oob until read_oob is fixed to handle single
+		 * byte reads for 16 bit buswidth.
+		 */
+		ret = mtd->read_oob(mtd, offs, &ops);/*mtd_read_oob(mtd, offs, &ops);*/
+		/* Ignore ECC errors when checking for BBM */
+		if (ret && !mtd_is_bitflip_or_eccerr(ret))
+			return ret;
+
+		if (check_short_pattern(buf, bd))
+			return 1;
+
+		offs += mtd->writesize;
+	}
+	return 0;
+}
+
+/**
+ * create_bbt - [GENERIC] Create a bad block table by scanning the device
+ * @mtd: MTD device structure
+ * @buf: temporary buffer
+ * @bd: descriptor for the good/bad block search pattern
+ * @chip: create the table for a specific chip, -1 read all chips; applies only
+ *        if NAND_BBT_PERCHIP option is set
+ *
+ * Create a bad block table by scanning the device for the given good/bad block
+ * identify pattern.
+ */
+static int create_bbt(struct mtd_info *mtd, uint8_t *buf,
+		      struct nand_bbt_descr *bd, int chip)
+{
+	struct spi_nand_chip *this = mtd->priv;
+	int i, numblocks, numpages;
+	int startblock;
+	loff_t from;
+	fh_dev_debug(&this->spi->dev, "Enter %s\n", __func__);
+
+	pr_info("Scanning device for bad blocks\n");
+
+	if (bd->options & NAND_BBT_SCAN2NDPAGE)
+		numpages = 2;
+	else
+		numpages = 1;
+
+	if (chip == -1) {
+		numblocks = mtd->size >> this->block_shift;
+		startblock = 0;
+		from = 0;
+	} else {
+		numblocks = this->size >> this->block_shift;
+		startblock = chip * numblocks;
+		numblocks += startblock;
+		from = (loff_t)startblock << this->block_shift;
+	}
+
+	if (this->bbt_options & NAND_BBT_SCANLASTPAGE)
+		from += mtd->erasesize - (mtd->writesize * numpages);
+
+	for (i = startblock; i < numblocks; i++) {
+		int ret;
+
+		BUG_ON(bd->options & NAND_BBT_NO_OOB);
+
+		ret = scan_block_fast(mtd, bd, from, buf, numpages);
+		if (ret < 0)
+			return ret;
+
+		if (ret) {
+			bbt_mark_entry(this, i, BBT_BLOCK_FACTORY_BAD);
+			pr_warn("Bad eraseblock %d at 0x%012llx\n",
+				i, (unsigned long long)from);
+			mtd->ecc_stats.badblocks++;
+		}
+
+		from += (1 << this->block_shift);
+	}
+	return 0;
+}
+
+/**
+ * search_bbt - [GENERIC] scan the device for a specific bad block table
+ * @mtd: MTD device structure
+ * @buf: temporary buffer
+ * @td: descriptor for the bad block table
+ *
+ * Read the bad block table by searching for a given ident pattern. Search is
+ * preformed either from the beginning up or from the end of the device
+ * downwards. The search starts always at the start of a block. If the option
+ * NAND_BBT_PERCHIP is given, each chip is searched for a bbt, which contains
+ * the bad block information of this chip. This is necessary to provide support
+ * for certain DOC devices.
+ *
+ * The bbt ident pattern resides in the oob area of the first page in a block.
+ */
+static int search_bbt(struct mtd_info *mtd, uint8_t *buf,
+		      struct nand_bbt_descr *td)
+{
+	struct spi_nand_chip *this = mtd->priv;
+	int i, chips;
+	int startblock, block, dir;
+	int scanlen = mtd->writesize + mtd->oobsize;
+	int bbtblocks;
+	int blocktopage = this->block_shift - this->page_shift;
+
+	fh_dev_debug(&this->spi->dev, "Enter %s\n", __func__);
+	/* Search direction top -> down? */
+	if (td->options & NAND_BBT_LASTBLOCK) {
+		startblock = (mtd->size >> this->block_shift) - 1;
+		dir = -1;
+	} else {
+		startblock = 0;
+		dir = 1;
+	}
+
+	chips = 1;
+	bbtblocks = mtd->size >> this->block_shift;
+
+	for (i = 0; i < chips; i++) {
+		/* Reset version information */
+		td->version[i] = 0;
+		td->pages[i] = -1;
+		/* Scan the maximum number of blocks */
+		for (block = 0; block < td->maxblocks; block++) {
+
+			int actblock = startblock + dir * block;
+			loff_t offs = (loff_t)actblock << this->block_shift;
+
+			/* Read first page */
+			scan_read(mtd, buf, offs, mtd->writesize, td);
+			fh_dev_debug(&this->spi->dev, "read block %d, first v 0x%08x\n ",
+				     actblock, *(int *)buf);
+			fh_dev_debug(&this->spi->dev, "td pattern:%s, offset %d, len %d\n ",
+				     td->pattern, td->offs,td->len);
+			if (!check_pattern(buf, scanlen, mtd->writesize, td)) {
+				td->pages[i] = actblock << blocktopage;
+				if (td->options & NAND_BBT_VERSION) {
+					offs = bbt_get_ver_offs(mtd, td);
+					td->version[i] = buf[offs];
+				}
+				break;
+			}
+		}
+		startblock += this->size >> this->block_shift;
+	}
+	/* Check, if we found a bbt for each requested chip */
+	for (i = 0; i < chips; i++) {
+		if (td->pages[i] == -1)
+			pr_warn("Bad block table not found for chip %d\n", i);
+		else
+			pr_info("Bad block table found at page %d, version 0x%02X\n",
+				td->pages[i], td->version[i]);
+	}
+	return 0;
+}
+
+/**
+ * search_read_bbts - [GENERIC] scan the device for bad block table(s)
+ * @mtd: MTD device structure
+ * @buf: temporary buffer
+ * @td: descriptor for the bad block table
+ * @md: descriptor for the bad block table mirror
+ *
+ * Search and read the bad block table(s).
+ */
+static void search_read_bbts(struct mtd_info *mtd, uint8_t *buf,
+			     struct nand_bbt_descr *td,
+			     struct nand_bbt_descr *md)
+{
+	/* Search the primary table */
+	search_bbt(mtd, buf, td);
+
+	/* Search the mirror table */
+	if (md)
+		search_bbt(mtd, buf, md);
+}
+
+/**
+ * write_bbt - [GENERIC] (Re)write the bad block table
+ * @mtd: MTD device structure
+ * @buf: temporary buffer
+ * @td: descriptor for the bad block table
+ * @md: descriptor for the bad block table mirror
+ * @chipsel: selector for a specific chip, -1 for all
+ *
+ * (Re)write the bad block table.
+ */
+static int write_bbt(struct mtd_info *mtd, uint8_t *buf,
+		     struct nand_bbt_descr *td, struct nand_bbt_descr *md,
+		     int chipsel)
+{
+	struct spi_nand_chip *this = mtd->priv;
+	struct erase_info einfo;
+	int i, res, chip = 0;
+	int bits, startblock, dir, page, offs, numblocks, sft, sftmsk;
+	int nrchips, pageoffs, ooboffs;
+	uint8_t msk[4];
+	uint8_t rcode = td->reserved_block_code;
+	size_t retlen, len = 0;
+	loff_t to;
+	struct mtd_oob_ops ops;
+	extern int fh_start_debug;
+	fh_start_debug = 1;
+	fh_dev_debug(&this->spi->dev, "Enter %s\n", __func__);
+
+	ops.ooblen = mtd->oobsize;
+	ops.ooboffs = 0;
+	ops.datbuf = NULL;
+	ops.mode = MTD_OOB_PLACE;
+
+	if (!rcode)
+		rcode = 0xff;
+	numblocks = (int)(mtd->size >> this->block_shift);
+	nrchips = 1;
+
+	/* Loop through the chips */
+	for (; chip < nrchips; chip++) {
+		/*
+		 * There was already a version of the table, reuse the page
+		 * This applies for absolute placement too, as we have the
+		 * page nr. in td->pages.
+		 */
+		if (td->pages[chip] != -1) {
+			page = td->pages[chip];
+			goto write;
+		}
+
+		/*
+		 * Automatic placement of the bad block table. Search direction
+		 * top -> down?
+		 */
+		if (td->options & NAND_BBT_LASTBLOCK) {
+			startblock = numblocks * (chip + 1) - 1;
+			dir = -1;
+		} else {
+			startblock = chip * numblocks;
+			dir = 1;
+		}
+
+		for (i = 0; i < td->maxblocks; i++) {
+			int block = startblock + dir * i;
+			/* Check, if the block is bad */
+			switch (bbt_get_entry(this, block)) {
+			case BBT_BLOCK_WORN:
+			case BBT_BLOCK_FACTORY_BAD:
+				continue;
+			}
+			page = block <<
+			       (this->block_shift - this->page_shift);
+			/* Check, if the block is used by the mirror table */
+			if (!md || md->pages[chip] != page)
+				goto write;
+		}
+		pr_err("No space left to write bad block table\n");
+		return -ENOSPC;
+write:
+
+		/* Set up shift count and masks for the flash table */
+		bits = td->options & NAND_BBT_NRBITS_MSK;
+		msk[2] = ~rcode;
+		switch (bits) {
+		case 1:
+			sft = 3;
+			sftmsk = 0x07;
+			msk[0] = 0x00;
+			msk[1] = 0x01;
+			msk[3] = 0x01;
+			break;
+		case 2:
+			sft = 2;
+			sftmsk = 0x06;
+			msk[0] = 0x00;
+			msk[1] = 0x01;
+			msk[3] = 0x03;
+			break;
+		case 4:
+			sft = 1;
+			sftmsk = 0x04;
+			msk[0] = 0x00;
+			msk[1] = 0x0C;
+			msk[3] = 0x0f;
+			break;
+		case 8:
+			sft = 0;
+			sftmsk = 0x00;
+			msk[0] = 0x00;
+			msk[1] = 0x0F;
+			msk[3] = 0xff;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		to = ((loff_t)page) << this->page_shift;
+
+		fh_dev_debug(&this->spi->dev, " td.options 0x08%x\n", td->options);
+
+		/* Must we save the block contents? */
+		if (td->options & NAND_BBT_SAVECONTENT) {
+			/* Make it block aligned */
+			to &= ~((loff_t)((1 << this->block_shift) - 1));
+			len = 1 << this->block_shift;
+			res = mtd->read(mtd, to, len, &retlen,
+					buf); // mtd_read(mtd, to, len, &retlen, buf);
+			if (res < 0) {
+				if (retlen != len) {
+					pr_info("spi_nand_bbt: error reading block ");
+					pr_info("for writing the bad block table\n");
+					return res;
+				}
+				pr_warn("spi_nand_bbt: ECC error while reading ");
+				pr_warn("block for writing bad block table\n");
+			}
+			/* Read oob data */
+			ops.ooblen = (len >> this->page_shift) * mtd->oobsize;
+			ops.oobbuf = &buf[len];
+			res = mtd->read_oob(mtd, to + mtd->writesize,
+					    &ops); /*mtd_read_oob(mtd, to + mtd->writesize, &ops);*/
+			if (res < 0 || ops.oobretlen != ops.ooblen)
+				goto outerr;
+
+			/* Calc the byte offset in the buffer */
+			pageoffs = page - (int)(to >> this->page_shift);
+			offs = pageoffs << this->page_shift;
+			/* Preset the bbt area with 0xff */
+			memset(&buf[offs], 0xff, (size_t)(numblocks >> sft));
+			ooboffs = len + (pageoffs * mtd->oobsize);
+
+		} else if (td->options & NAND_BBT_NO_OOB) {
+			ooboffs = 0;
+			offs = td->len;
+			/* The version byte */
+			if (td->options & NAND_BBT_VERSION)
+				offs++;
+			/* Calc length */
+			len = (size_t)(numblocks >> sft);
+			len += offs;
+			/* Make it page aligned! */
+			len = ALIGN(len, mtd->writesize);
+			/* Preset the buffer with 0xff */
+			memset(buf, 0xff, len);
+			/* Pattern is located at the begin of first page */
+			memcpy(buf, td->pattern, td->len);
+		} else {
+			/* Calc length */
+			len = (size_t)(numblocks >> sft);
+			/* Make it page aligned! */
+			len = ALIGN(len, mtd->writesize);
+			/* Preset the buffer with 0xff */
+			memset(buf, 0xff, len +
+			       (len >> this->page_shift) * mtd->oobsize);
+			offs = 0;
+			ooboffs = len;
+			/* Pattern is located in oob area of first page */
+			memcpy(&buf[ooboffs + td->offs], td->pattern, td->len);
+
+			/*fh_debug_dump(td->pattern, td->len);*/
+		}
+
+		if (td->options & NAND_BBT_VERSION)
+			buf[ooboffs + td->veroffs] = td->version[chip];
+
+		/* Walk through the memory table */
+		for (i = 0; i < numblocks; i++) {
+			uint8_t dat;
+			int sftcnt = (i << (3 - sft)) & sftmsk;
+
+			dat = bbt_get_entry(this, chip * numblocks + i);
+			/* Do not store the reserved bbt blocks! */
+			buf[offs + (i >> sft)] &= ~(msk[dat] << sftcnt);
+		}
+
+		memset(&einfo, 0, sizeof(einfo));
+		einfo.mtd = mtd;
+		einfo.addr = to;
+		einfo.len = 1 << this->block_shift;
+		res = __spi_nand_erase(mtd, &einfo, 1);
+		if (res < 0)
+			goto outerr;
+
+		/*fh_debug_dump(&buf[ooboffs],20);*/
+		res = scan_write_bbt(mtd, to, len, buf,
+				     td->options & NAND_BBT_NO_OOB ? NULL :
+				     &buf[len]);
+
+		if (res < 0)
+			goto outerr;
+
+		pr_info("Bad block table written to 0x%012llx, version 0x%02X\n",
+			(unsigned long long)to, td->version[chip]);
+
+		/* Mark it as used */
+		td->pages[chip] = page;
+	}
+	return 0;
+
+outerr:
+	pr_warn("spi_nand_bbt: error while writing bad block table %d\n", res);
+	return res;
+}
+
+/**
+ * spi_nand_memory_bbt - [GENERIC] create a memory based bad block table
+ * @mtd: MTD device structure
+ * @bd: descriptor for the good/bad block search pattern
+ *
+ * The function creates a memory based bbt by scanning the device for
+ * manufacturer / software marked good / bad blocks.
+ */
+static inline int spi_nand_memory_bbt(struct mtd_info *mtd,
+				      struct nand_bbt_descr *bd)
+{
+	struct spi_nand_chip *this = mtd->priv;
+	fh_dev_debug(&this->spi->dev, "Enter %s\n", __func__);
+
+	return create_bbt(mtd, this->buf, bd, -1);
+}
+
+/**
+ * check_create - [GENERIC] create and write bbt(s) if necessary
+ * @mtd: MTD device structure
+ * @buf: temporary buffer
+ * @bd: descriptor for the good/bad block search pattern
+ *
+ * The function checks the results of the previous call to read_bbt and creates
+ * / updates the bbt(s) if necessary. Creation is necessary if no bbt was found
+ * for the chip/device. Update is necessary if one of the tables is missing or
+ * the version nr. of one table is less than the other.
+ */
+static int check_create(struct mtd_info *mtd, uint8_t *buf,
+			struct nand_bbt_descr *bd)
+{
+	int i, chips, writeops, create, chipsel, res, res2;
+	struct spi_nand_chip *this = mtd->priv;
+	struct nand_bbt_descr *td = this->bbt_td;
+	struct nand_bbt_descr *md = this->bbt_md;
+	struct nand_bbt_descr *rd, *rd2;
+
+	chips = 1;
+
+	for (i = 0; i < chips; i++) {
+		writeops = 0;
+		create = 0;
+		rd = NULL;
+		rd2 = NULL;
+		res = res2 = 0;
+		/* Per chip or per device? */
+		chipsel = -1;
+		/* Mirrored table available? */
+		if (md) {
+			if (td->pages[i] == -1 && md->pages[i] == -1) {
+				create = 1;
+				writeops = 0x03;
+			} else if (td->pages[i] == -1) {
+				rd = md;
+				writeops = 0x01;
+			} else if (md->pages[i] == -1) {
+				rd = td;
+				writeops = 0x02;
+			} else if (td->version[i] == md->version[i]) {
+				rd = td;
+				if (!(td->options & NAND_BBT_VERSION))
+					rd2 = md;
+			} else if (((int8_t)(td->version[i] - md->version[i]))
+				   > 0) {
+				rd = td;
+				writeops = 0x02;
+			} else {
+				rd = md;
+				writeops = 0x01;
+			}
+		} else {
+			if (td->pages[i] == -1) {
+				create = 1;
+				writeops = 0x01;
+			} else
+				rd = td;
+		}
+
+		if (create) {
+			/* Create the bad block table by scanning the device? */
+			if (!(td->options & NAND_BBT_CREATE))
+				continue;
+
+			/* Create the table in memory by scanning the chip(s) */
+			/*xxx: create it; if (!(this->bbt_options & NAND_BBT_CREATE_EMPTY))*/
+				create_bbt(mtd, buf, bd, chipsel);
+
+			td->version[i] = 1;
+			if (md)
+				md->version[i] = 1;
+		}
+
+		/* Read back first? */
+		if (rd) {
+			res = read_abs_bbt(mtd, buf, rd, chipsel);
+			if (mtd_is_eccerr(res)) {
+				/* Mark table as invalid */
+				rd->pages[i] = -1;
+				rd->version[i] = 0;
+				i--;
+				continue;
+			}
+		}
+		/* If they weren't versioned, read both */
+		if (rd2) {
+			res2 = read_abs_bbt(mtd, buf, rd2, chipsel);
+			if (mtd_is_eccerr(res2)) {
+				/* Mark table as invalid */
+				rd2->pages[i] = -1;
+				rd2->version[i] = 0;
+				i--;
+				continue;
+			}
+		}
+
+		/* Scrub the flash table(s)? */
+		if (mtd_is_bitflip(res) || mtd_is_bitflip(res2))
+			writeops = 0x03;
+
+		/* Update version numbers before writing */
+		if (md) {
+			td->version[i] = max(td->version[i], md->version[i]);
+			md->version[i] = td->version[i];
+		}
+
+		/* Write the bad block table to the device? */
+		if ((writeops & 0x01) && (td->options & NAND_BBT_WRITE)) {
+			res = write_bbt(mtd, buf, td, md, chipsel);
+			if (res < 0)
+				return res;
+		}
+
+		/* Write the mirror bad block table to the device? */
+		if ((writeops & 0x02) && md && (md->options & NAND_BBT_WRITE)) {
+			res = write_bbt(mtd, buf, md, td, chipsel);
+			if (res < 0)
+				return res;
+		}
+	}
+	return 0;
+}
+
+/**
+ * mark_bbt_regions - [GENERIC] mark the bad block table regions
+ * @mtd: MTD device structure
+ * @td: bad block table descriptor
+ *
+ * The bad block table regions are marked as "bad" to prevent accidental
+ * erasures / writes. The regions are identified by the mark 0x02.
+ */
+static void mark_bbt_region(struct mtd_info *mtd, struct nand_bbt_descr *td)
+{
+	struct spi_nand_chip *this = mtd->priv;
+	int i, j, chips, block, nrblocks, update;
+	uint8_t oldval;
+
+	chips = 1;
+	nrblocks = (int)(mtd->size >> this->block_shift);
+
+	for (i = 0; i < chips; i++) {
+		if ((td->options & NAND_BBT_ABSPAGE) ||
+		    !(td->options & NAND_BBT_WRITE)) {
+			if (td->pages[i] == -1)
+				continue;
+			block = td->pages[i] >>
+				(this->block_shift - this->page_shift);
+			oldval = bbt_get_entry(this, block);
+			bbt_mark_entry(this, block, BBT_BLOCK_RESERVED);
+			if ((oldval != BBT_BLOCK_RESERVED) &&
+			    td->reserved_block_code)
+				spi_nand_update_bbt(mtd, (loff_t)block <<
+						    this->block_shift);
+			continue;
+		}
+		update = 0;
+		if (td->options & NAND_BBT_LASTBLOCK)
+			block = ((i + 1) * nrblocks) - td->maxblocks;
+		else
+			block = i * nrblocks;
+		for (j = 0; j < td->maxblocks; j++) {
+			oldval = bbt_get_entry(this, block);
+			bbt_mark_entry(this, block, BBT_BLOCK_RESERVED);
+			if (oldval != BBT_BLOCK_RESERVED)
+				update = 1;
+			block++;
+		}
+		/*
+		 * If we want reserved blocks to be recorded to flash, and some
+		 * new ones have been marked, then we need to update the stored
+		 * bbts.  This should only happen once.
+		 */
+		if (update && td->reserved_block_code)
+			spi_nand_update_bbt(mtd, (loff_t)(block - 1) <<
+					    this->block_shift);
+	}
+	fh_dev_debug(&this->spi->dev, "Leave %s\n", __func__);
+}
+
+/**
+ * verify_bbt_descr - verify the bad block description
+ * @mtd: MTD device structure
+ * @bd: the table to verify
+ *
+ * This functions performs a few sanity checks on the bad block description
+ * table.
+ */
+static void verify_bbt_descr(struct mtd_info *mtd, struct nand_bbt_descr *bd)
+{
+	struct spi_nand_chip *this = mtd->priv;
+	u32 pattern_len;
+	u32 bits;
+	u32 table_size;
+
+	if (!bd)
+		return;
+
+	pattern_len = bd->len;
+	bits = bd->options & NAND_BBT_NRBITS_MSK;
+
+	BUG_ON((this->bbt_options & NAND_BBT_NO_OOB) &&
+	       !(this->bbt_options & NAND_BBT_USE_FLASH));
+	BUG_ON(!bits);
+
+	if (bd->options & NAND_BBT_VERSION)
+		pattern_len++;
+
+	if (bd->options & NAND_BBT_NO_OOB) {
+		BUG_ON(!(this->bbt_options & NAND_BBT_USE_FLASH));
+		BUG_ON(!(this->bbt_options & NAND_BBT_NO_OOB));
+		BUG_ON(bd->offs);
+		if (bd->options & NAND_BBT_VERSION)
+			BUG_ON(bd->veroffs != bd->len);
+		BUG_ON(bd->options & NAND_BBT_SAVECONTENT);
+	}
+
+	table_size = mtd->size >> this->block_shift;
+	table_size >>= 3;
+	table_size *= bits;
+	if (bd->options & NAND_BBT_NO_OOB)
+		table_size += pattern_len;
+	BUG_ON(table_size > (1 << this->block_shift));
+}
+
+/**
+ * spi_nand_scan_bbt - [SPI-NAND Interface] scan, find, read and maybe create
+ * bad block table(s)
+ * @mtd: MTD device structure
+ * @bd: descriptor for the good/bad block search pattern
+ *
+ * The function checks, if a bad block table(s) is/are already available. If
+ * not it scans the device for manufacturer marked good / bad blocks and writes
+ * the bad block table(s) to the selected place.
+ *
+ * The bad block table memory is allocated here. It must be freed by calling
+ * the spi_nand_free_bbt function.
+ */
+int spi_nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
+{
+	struct spi_nand_chip *this = mtd->priv;
+	int len, res = 0;
+	uint8_t *buf;
+	struct nand_bbt_descr *td = this->bbt_td;
+	struct nand_bbt_descr *md = this->bbt_md;
+
+	fh_dev_debug(&this->spi->dev, "Enter %s\n", __func__);
+	len = mtd->size >> (this->block_shift + 2);
+	/*
+	 * Allocate memory (2bit per block) and clear the memory bad block
+	 * table.
+	 */
+	this->bbt = kzalloc(len, GFP_KERNEL);
+	if (!this->bbt)
+		return -ENOMEM;
+
+	/*
+	 * If no primary table decriptor is given, scan the device to build a
+	 * memory based bad block table.
+	 */
+	if (!td) {
+		res = spi_nand_memory_bbt(mtd, bd);
+		if (res) {
+			pr_err("spi_nand_bbt: can't scan flash and build the RAM-based BBT\n");
+			kfree(this->bbt);
+			this->bbt = NULL;
+		}
+		return res;
+	}
+	verify_bbt_descr(mtd, td);
+	verify_bbt_descr(mtd, md);
+
+	/* Allocate a temporary buffer for one eraseblock incl. oob */
+	len = (1 << this->block_shift);
+	len += (len >> this->page_shift) * mtd->oobsize;
+	buf = vmalloc(len);
+	if (!buf) {
+		kfree(this->bbt);
+		this->bbt = NULL;
+		return -ENOMEM;
+	}
+
+	/* Is the bbt at a given page? */
+	if (td->options & NAND_BBT_ABSPAGE)
+		read_abs_bbts(mtd, buf, td, md);
+	else {
+		/* Search the bad block table using a pattern in oob */
+		search_read_bbts(mtd, buf, td, md);
+	}
+
+	res = check_create(mtd, buf, bd);
+
+	/* Prevent the bbt regions from erasing / writing */
+	mark_bbt_region(mtd, td);
+	if (md)
+		mark_bbt_region(mtd, md);
+
+	vfree(buf);
+	return res;
+}
+EXPORT_SYMBOL(spi_nand_scan_bbt);
+
+/**
+ * spi_nand_update_bbt - update bad block table(s)
+ * @mtd: MTD device structure
+ * @offs: the offset of the newly marked block
+ *
+ * The function updates the bad block table(s).
+ */
+static int spi_nand_update_bbt(struct mtd_info *mtd, loff_t offs)
+{
+	struct spi_nand_chip *this = mtd->priv;
+	int len, res = 0;
+	int chip, chipsel;
+	uint8_t *buf;
+	struct nand_bbt_descr *td = this->bbt_td;
+	struct nand_bbt_descr *md = this->bbt_md;
+
+	if (!this->bbt || !td)
+		return -EINVAL;
+
+	/* Allocate a temporary buffer for one eraseblock incl. oob */
+	len = (1 << this->block_shift);
+	len += (len >> this->page_shift) * mtd->oobsize;
+	buf = kmalloc(len, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	chip = 0;
+	chipsel = -1;
+
+	td->version[chip]++;
+	if (md)
+		md->version[chip]++;
+
+	/* Write the bad block table to the device? */
+	if (td->options & NAND_BBT_WRITE) {
+		res = write_bbt(mtd, buf, td, md, chipsel);
+		if (res < 0)
+			goto out;
+	}
+	/* Write the mirror bad block table to the device? */
+	if (md && (md->options & NAND_BBT_WRITE))
+		res = write_bbt(mtd, buf, md, td, chipsel);
+
+out:
+	kfree(buf);
+	return res;
+}
+
+/*
+ * Define some generic bad / good block scan pattern which are used
+ * while scanning a device for factory marked good / bad blocks.
+ */
+static uint8_t scan_ff_pattern[] = { 0xff, 0xff };
+
+/* Generic flash bbt descriptors */
+static uint8_t bbt_pattern[] = {'B', 'b', 't', '0' };
+static uint8_t mirror_pattern[] = {'1', 't', 'b', 'B' };
+
+static struct nand_bbt_descr bbt_main_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+	| NAND_BBT_2BIT | NAND_BBT_VERSION,
+	.offs = 4, //.offs = 8,
+	.len = 4,
+	.veroffs = 2, //.veroffs = 12,
+	.maxblocks = NAND_BBT_SCAN_MAXBLOCKS,
+	.pattern = bbt_pattern
+};
+
+static struct nand_bbt_descr bbt_mirror_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+	| NAND_BBT_2BIT | NAND_BBT_VERSION,
+	.offs = 4, //.offs = 8,
+	.len = 4,
+	.veroffs = 2, //.veroffs = 12,
+	.maxblocks = NAND_BBT_SCAN_MAXBLOCKS,
+	.pattern = mirror_pattern
+};
+
+static struct nand_bbt_descr bbt_main_no_oob_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+	| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_NO_OOB,
+	.len = 4,
+	.veroffs = 4,
+	.maxblocks = NAND_BBT_SCAN_MAXBLOCKS,
+	.pattern = bbt_pattern
+};
+
+static struct nand_bbt_descr bbt_mirror_no_oob_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+	| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_NO_OOB,
+	.len = 4,
+	.veroffs = 4,
+	.maxblocks = NAND_BBT_SCAN_MAXBLOCKS,
+	.pattern = mirror_pattern
+};
+
+#define BADBLOCK_SCAN_MASK (~NAND_BBT_NO_OOB)
+/**
+ * spi_nand_create_badblock_pattern - [INTERN] Creates a BBT descriptor structure
+ * @this: SPI-NAND chip to create descriptor for
+ *
+ * This function allocates and initializes a nand_bbt_descr for BBM detection
+ * based on the properties of @this. The new descriptor is stored in
+ * this->badblock_pattern. Thus, this->badblock_pattern should be NULL when
+ * passed to this function.
+ */
+static int spi_nand_create_badblock_pattern(struct spi_nand_chip *this)
+{
+	struct nand_bbt_descr *bd;
+
+	if (this->badblock_pattern) {
+		pr_warn("Bad block pattern already allocated; not replacing\n");
+		return -EINVAL;
+	}
+	bd = kzalloc(sizeof(*bd), GFP_KERNEL);
+	if (!bd)
+		return -ENOMEM;
+	bd->options = this->bbt_options & BADBLOCK_SCAN_MASK;
+	bd->offs = this->badblockpos;
+	bd->len = 1;
+	bd->pattern = scan_ff_pattern;
+	bd->options |= NAND_BBT_DYNAMICSTRUCT;
+	this->badblock_pattern = bd;
+	return 0;
+}
+
+/**
+ * spi_nand_default_bbt - [SPI-NAND Interface] Select a default bad block table for the device
+ * @mtd: MTD device structure
+ *
+ * This function selects the default bad block table support for the device and
+ * calls the spi_nand_scan_bbt function.
+ */
+int spi_nand_default_bbt(struct mtd_info *mtd)
+{
+	struct spi_nand_chip *this = mtd->priv;
+	int ret;
+
+	fh_dev_debug(&this->spi->dev, "Enter %s\n", __func__);
+
+	fh_dev_debug(&this->spi->dev, "\tbbt option %x\n", this->bbt_options);
+	/* Is a flash based bad block table requested? */
+	if (this->bbt_options & NAND_BBT_USE_FLASH) {
+		/* Use the default pattern descriptors */
+		if (!this->bbt_td) {
+			if (this->bbt_options & NAND_BBT_NO_OOB) {
+				this->bbt_td = &bbt_main_no_oob_descr;
+				this->bbt_md = &bbt_mirror_no_oob_descr;
+			} else {
+				this->bbt_td = &bbt_main_descr;
+				this->bbt_md = &bbt_mirror_descr;
+			}
+		}
+	} else {
+		this->bbt_td = NULL;
+		this->bbt_md = NULL;
+	}
+
+	if (!this->badblock_pattern) {
+		ret = spi_nand_create_badblock_pattern(this);
+		if (ret)
+			return ret;
+	}
+
+	fh_dev_debug(&this->spi->dev, "badblock pattern 0x%02x\n",
+		     * this->badblock_pattern->pattern);
+	return spi_nand_scan_bbt(mtd, this->badblock_pattern);
+}
+EXPORT_SYMBOL(spi_nand_default_bbt);
+
+/**
+ * spi_nand_isbad_bbt - [SPI-NAND Interface] Check if a block is bad
+ * @mtd: MTD device structure
+ * @offs: offset in the device
+ * @allowbbt: allow access to bad block table region
+ */
+int spi_nand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt)
+{
+	struct spi_nand_chip *this = mtd->priv;
+	int block, res;
+
+	block = (int)(offs >> this->block_shift);
+	res = bbt_get_entry(this, block);
+
+	pr_debug("%s: bbt info for offs 0x%08x: (block %d) 0x%02x\n",
+		 __func__, (unsigned int)offs, block, res);
+
+	switch (res) {
+	case BBT_BLOCK_GOOD:
+		return 0;
+	case BBT_BLOCK_WORN:
+		return 1;
+	case BBT_BLOCK_RESERVED:
+		return allowbbt ? 0 : 1;
+	}
+	return 1;
+}
+EXPORT_SYMBOL(spi_nand_isbad_bbt);
+/**
+ * spi_nand_markbad_bbt - [SPI-NAND Interface] Mark a block bad in the BBT
+ * @mtd: MTD device structure
+ * @offs: offset of the bad block
+ */
+int spi_nand_markbad_bbt(struct mtd_info *mtd, loff_t offs)
+{
+	struct spi_nand_chip *this = mtd->priv;
+	int block, ret = 0;
+
+	block = (int)(offs >> this->block_shift);
+
+	/* Mark bad block in memory */
+	bbt_mark_entry(this, block, BBT_BLOCK_WORN);
+
+	/* Update flash-based bad block table */
+	if (this->bbt_options & NAND_BBT_USE_FLASH)
+		ret = spi_nand_update_bbt(mtd, offs);
+
+	return ret;
+}
+EXPORT_SYMBOL(spi_nand_markbad_bbt);
diff -uraN linux-3.0.8/drivers/mtd/spi-nand/spi-nand-device.c linux-3.0.8-fh8632-V1.0_20180330/drivers/mtd/spi-nand/spi-nand-device.c
--- linux-3.0.8/drivers/mtd/spi-nand/spi-nand-device.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/mtd/spi-nand/spi-nand-device.c	2021-07-13 23:40:34.582361938 +0300
@@ -0,0 +1,276 @@
+/*
+ * Copyright (c) 2009-2014 Micron Technology, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/nand.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/mtd/spi-nand.h>
+#include "spi-nand-ids.h"
+
+#ifdef SPINAND_BBT_DEBUG
+#define fh_dev_debug	dev_err
+#else
+#define fh_dev_debug(...)
+#endif
+
+static int spi_nand_read_id(struct spi_nand_chip *chip, u8 *buf)
+{
+	struct spi_device *spi = chip->spi;
+	struct spi_nand_cmd cmd = { 0 };
+
+	cmd.cmd = SPINAND_CMD_READ_ID;
+	cmd.n_rx = SPINAND_MAX_ID_LEN;
+	cmd.rx_buf = buf;
+
+	return spi_nand_send_cmd(spi, &cmd);
+}
+
+static void spi_nand_ecc_status(struct spi_nand_chip *chip, unsigned int status,
+				      unsigned int *corrected, unsigned int *ecc_error)
+{
+	unsigned int ecc_status = (status >> SPI_NAND_ECC_SHIFT) &
+				  chip->ecc_mask;
+
+	*ecc_error = (ecc_status >= chip->ecc_uncorr);
+	if (*ecc_error == 0)
+		*corrected = ecc_status;
+}
+
+static void spi_nand_mt29f_ecc_status(unsigned int status,
+				      unsigned int *corrected, unsigned int *ecc_error)
+{
+	unsigned int ecc_status = (status >> SPI_NAND_MT29F_ECC_SHIFT) &
+				  SPI_NAND_MT29F_ECC_MASK;
+
+	*ecc_error = (ecc_status == SPI_NAND_MT29F_ECC_UNCORR);
+	if (*ecc_error == 0)
+		*corrected = ecc_status;
+}
+
+static void spi_nand_gd5f_ecc_status(unsigned int status,
+				     unsigned int *corrected, unsigned int *ecc_error)
+{
+	unsigned int ecc_status = (status >> SPI_NAND_GD5F_ECC_SHIFT) &
+				  SPI_NAND_GD5F_ECC_MASK;
+
+	*ecc_error = (ecc_status == SPI_NAND_GD5F_ECC_UNCORR);
+	/*TODO fix corrected bits*/
+	if (*ecc_error == 0)
+		*corrected = ecc_status;
+}
+
+/*static int spi_nand_manufacture_init(struct spi_nand_chip *chip)
+{
+	switch (chip->mfr_id) {
+	case SPINAND_MFR_MICRON:
+		chip->get_ecc_status = spi_nand_mt29f_ecc_status;
+
+		if (chip->page_spare_size == 64)
+			chip->ecclayout = &micron_ecc_layout_64;
+
+		chip->bbt_options |= NAND_BBT_NO_OOB;
+		break;
+	case SPINAND_MFR_GIGADEVICE:
+		chip->get_ecc_status = spi_nand_gd5f_ecc_status;
+		chip->read_cache = spi_nand_read_from_cache_snor_protocol;
+		chip->ecc_strength_ds = 8;
+		chip->ecc_step_ds = chip->page_size >> 2;
+		if (chip->page_spare_size == 128)
+			chip->ecclayout = &gd5f_ecc_layout_128;
+		else if (chip->page_spare_size == 256)
+			chip->ecclayout = &gd5f_ecc_layout_256;
+
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}*/
+
+static int spi_nand_device_probe(struct spi_device *spi)
+{
+	struct spi_nand_chip *chip;
+	enum spi_nand_device_variant variant;
+	struct mtd_info *mtd;
+	/*	struct mtd_part_parser_data ppdata;*/
+	struct mtd_partition *parts = NULL;
+	int nr_parts = 0;
+	int ret, i;
+	struct flash_platform_data	*data;
+
+	fh_dev_debug(&spi->dev, "%s with spi%d:%d \n", __func__, spi->master->bus_num, spi->chip_select);
+
+	data = spi->dev.platform_data;
+	chip = kzalloc(sizeof(struct spi_nand_chip), GFP_KERNEL);
+	if (!chip) {
+		ret = -ENOMEM;
+		goto err1;
+	}
+	chip->spi = spi;
+
+	mtd = kzalloc(sizeof(struct mtd_info), GFP_KERNEL);
+	if (!mtd) {
+		ret = -ENOMEM;
+		goto err2;
+	}
+	mtd->priv = chip;
+	chip->mtd = mtd;
+	spi_set_drvdata(spi, chip);
+	/*
+	 * read ID command format might be different for different manufactory
+	 * such as, Micron SPI NAND need extra one dummy byte after perform
+	 * read ID command but Giga device don't need.
+	 *
+	 * So, specify manufactory of device in device tree is obligatory
+	 */
+/*	variant = spi_get_device_id(spi)->driver_data;
+	switch (variant) {
+	case SPI_NAND_MT29F:
+		chip->read_id = spi_nand_mt29f_read_id;
+		break;
+	case SPI_NAND_GD5F:
+		chip->read_id = spi_nand_gd5f_read_id;
+		break;
+	default:
+		dev_err(&spi->dev, "unknown device, id %d\n", variant);
+		ret = -ENODEV;
+		goto err3;
+	}*/
+
+	chip->read_id = spi_nand_read_id;
+	ret = spi_nand_scan_ident(mtd);
+	if (ret){
+		ret = -ENODEV;
+		goto err3;
+	}
+
+/*	spi_nand_manufacture_init(chip);*/
+	chip->get_ecc_status = spi_nand_ecc_status;
+
+	ret = spi_nand_scan_tail(mtd);
+	if (ret) {
+		fh_dev_debug(&spi->dev, "goto err4 %s\n", __func__);
+		goto err4;
+	}
+
+	/* partitions should match sector boundaries; and it may be good to
+	 * use readonly partitions for writeprotected sectors (BP2..BP0).
+	 */
+	mtd->name = "spi0.0";
+	if (mtd_has_cmdlinepart()) {
+		static const char *part_probes[] = { "cmdlinepart", NULL, };
+
+		nr_parts = parse_mtd_partitions(mtd, part_probes, &parts, 0);
+	}
+
+	if (nr_parts <= 0 && data && data->parts) {
+		parts = data->parts;
+		nr_parts = data->nr_parts;
+	}
+
+	if (nr_parts > 0) {
+		for (i = 0; i < nr_parts; i++) {
+			DEBUG(MTD_DEBUG_LEVEL2,
+			      "partitions[%d] = " "{.name = %s, .offset = 0x%llx, "
+			      ".size = 0x%llx (%lldKiB) }\n",
+			      i, parts[i].name, (long long)parts[i].offset,
+			      (long long)parts[i].size,
+			      (long long)(parts[i].size >> 10));
+		}
+	}
+
+	fh_dev_debug(&spi->dev, " mtd_device_register %s\n", __func__);
+	ret = mtd_device_register(mtd, parts, nr_parts);
+	if (!ret)
+		return 0;
+
+	fh_dev_debug(&spi->dev, " spi_nand_scan_tail_release %s\n", __func__);
+	spi_nand_scan_tail_release(mtd);
+	fh_dev_debug(&spi->dev, "Leave %s\n", __func__);
+err4:
+	spi_nand_scan_ident_release(mtd);
+err3:
+	kfree(mtd);
+err2:
+	kfree(chip);
+err1:
+	return ret;
+}
+
+int spi_nand_device_remove(struct spi_device *spi)
+{
+	struct spi_nand_chip *chip = spi_get_drvdata(spi);
+	struct mtd_info *mtd = chip->mtd;
+
+	spi_nand_release(mtd);
+	kfree(mtd);
+	kfree(chip);
+
+	return 0;
+}
+
+const struct spi_device_id spi_nand_id_table[] = {
+	{ "spi-nand", SPI_NAND_GENERIC},
+	{ "mt29f", SPI_NAND_MT29F },
+	{ "gd5f", SPI_NAND_GD5F },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, spi_nand_id_table);
+
+/**
+ * module_spi_driver() - Helper macro for registering a SPI driver
+ * @__spi_driver: spi_driver struct
+ *
+ * Helper macro for SPI drivers which do not do anything special in module
+ * init/exit. This eliminates a lot of boilerplate. Each module may only
+ * use this macro once, and calling it replaces module_init() and module_exit()
+ */
+#define module_spi_driver(__spi_driver) \
+	module_driver(__spi_driver, spi_register_driver, \
+			spi_unregister_driver)
+
+static struct spi_driver spi_nand_device_driver = {
+	.driver = {
+		.name	= "spi-nand",
+		.bus	= &spi_bus_type,
+		.owner	= THIS_MODULE,
+	},
+	.id_table = spi_nand_id_table,
+	.probe	= spi_nand_device_probe,
+	.remove	= spi_nand_device_remove,
+};
+
+static int __init spi_nand_init(void)
+{
+	return spi_register_driver(&spi_nand_device_driver);
+}
+
+static void __exit spi_nand_exit(void)
+{
+	spi_unregister_driver(&spi_nand_device_driver);
+}
+
+module_init(spi_nand_init);
+module_exit(spi_nand_exit);
+
+MODULE_DESCRIPTION("SPI NAND device");
+MODULE_AUTHOR("Peter Pan<peterpandong at micron.com>");
+MODULE_AUTHOR("Ezequiel Garcia <ezequiel.garcia at imgtec.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uraN linux-3.0.8/drivers/mtd/spi-nand/spi-nand-ids.c linux-3.0.8-fh8632-V1.0_20180330/drivers/mtd/spi-nand/spi-nand-ids.c
--- linux-3.0.8/drivers/mtd/spi-nand/spi-nand-ids.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/mtd/spi-nand/spi-nand-ids.c	2021-07-13 23:40:34.578361912 +0300
@@ -0,0 +1,287 @@
+/*
+ * Copyright (c) 2016 Fullhan, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/mtd/spi-nand.h>
+
+/*static struct spi_nand_flash spi_nand_table[] = {
+	SPI_NAND_INFO("MT29F2G01AAAED", 0x2C, 0X22, 2048, 64, 64, 2048,
+	SPINAND_NEED_PLANE_SELECT),
+	SPI_NAND_INFO("MT29F4G01AAADD", 0x2C, 0X32, 2048, 64, 64, 4096,
+	SPINAND_NEED_PLANE_SELECT),
+	SPI_NAND_INFO("GD5F 512MiB 1.8V", 0xC8, 0XA4, 4096, 256, 64, 2048,
+	0),
+	SPI_NAND_INFO("GD5F 512MiB 3.3V", 0xC8, 0XB4, 4096, 256, 64, 2048,
+	0),
+	SPI_NAND_INFO("GD5F 256MiB 3.3V", 0xC8, 0XB2, 2048, 128, 64, 2048,
+	0),
+	SPI_NAND_INFO("GD5F 128MiB 3.3V", 0xC8, 0XB1, 2048, 128, 64, 1024,
+	0),
+	SPI_NAND_INFO("W25N01GV", 0xEF, 0XAA21, 2048, 64, 64, 1024,
+	0),
+	{.name = NULL},
+};*/
+
+/**
+*  Default OOB area specification layout
+*/
+static struct nand_ecclayout ecc_layout_64 = {
+	.eccbytes = 32,
+	.eccpos = {
+		8, 9, 10, 11, 12, 13, 14, 15,
+		24, 25, 26, 27, 28, 29, 30, 21,
+		40, 41, 42, 43, 44, 45, 46, 47,
+		56, 57, 58, 59, 60, 61, 62, 63
+	},
+	.oobavail = 30,
+	.oobfree = {
+		{
+			.offset = 2,
+			.length = 6
+		}, {
+			.offset = 16,
+			.length = 8
+		}, {
+			.offset = 32,
+			.length = 8
+		}, {
+			.offset = 48,
+			.length = 8
+		},
+	}
+};
+
+static struct nand_ecclayout gd5f_ecc_layout_256 = {
+	.eccbytes = 128,
+	.eccpos = {
+		128, 129, 130, 131, 132, 133, 134, 135,
+		136, 137, 138, 139, 140, 141, 142, 143,
+		144, 145, 146, 147, 148, 149, 150, 151,
+		152, 153, 154, 155, 156, 157, 158, 159,
+		160, 161, 162, 163, 164, 165, 166, 167,
+		168, 169, 170, 171, 172, 173, 174, 175,
+		176, 177, 178, 179, 180, 181, 182, 183,
+		184, 185, 186, 187, 188, 189, 190, 191,
+		192, 193, 194, 195, 196, 197, 198, 199,
+		200, 201, 202, 203, 204, 205, 206, 207,
+		208, 209, 210, 211, 212, 213, 214, 215,
+		216, 217, 218, 219, 220, 221, 222, 223,
+		224, 225, 226, 227, 228, 229, 230, 231,
+		232, 233, 234, 235, 236, 237, 238, 239,
+		240, 241, 242, 243, 244, 245, 246, 247,
+		248, 249, 250, 251, 252, 253, 254, 255
+	},
+	.oobavail = 127,
+	.oobfree = { {1, 127} }
+};
+
+static struct nand_ecclayout gd5f_ecc_layout_128 = {
+	.eccbytes = 64,
+	.eccpos = {
+		64, 65, 66, 67, 68, 69, 70, 72,
+		72, 73, 74, 75, 76, 77, 78, 79,
+		80, 81, 82, 83, 84, 85, 86, 87,
+		88, 89, 90, 91, 92, 93, 94, 95,
+		96, 97, 98, 99, 100, 101, 102, 103,
+		104, 105, 106, 107, 108, 109, 110, 111,
+		112, 113, 114, 115, 116, 117, 118, 119,
+		120, 121, 122, 123, 124, 125, 126, 127,
+	},
+	.oobavail = 62,
+	.oobfree = { {2, 63} }
+};
+
+static struct nand_ecclayout pn26_ecc_layout_128 = {
+	.eccbytes = 52,
+	.eccpos = {
+		6, 7, 8, 9, 10,11,12,13,14,15,16,17,18,
+		21,22,23,24,25,26,27,28,29,30,31,32,33,
+		36,37,38,39,40,41,42,43,44,45,46,47,48,
+		51,52,53,54,55,56,57,58,59,60,61,62,63
+	},
+	.oobavail = 72,
+	.oobfree = {
+			{
+				.offset = 4,
+				.length = 2
+			}, {
+				.offset = 19,
+				.length = 2
+			}, {
+				.offset = 34,
+				.length = 2
+			}, {
+				.offset = 49,
+				.length = 2
+			},
+			{
+				.offset = 64,
+				.length = 64
+			},
+		}
+};
+
+static struct nand_ecclayout default_ecc_layout = {
+	.eccbytes = 64,
+	.oobavail = 28,
+	.oobfree = { { 2, 30 } }
+};
+
+static struct nand_ecclayout mx35_ecc_layout_64 = {
+	.eccbytes = 0,
+	.oobavail = 62,
+	.oobfree = { {2, 62} }
+};
+
+
+static struct spi_nand_flash spi_nand_table[] = {
+	{
+		.name = "W25N01GV",
+		.id_info = {
+			.id_addr = 0,
+			.id_len = 3,
+		},
+		.dev_id = {0xEF, 0xAA, 0x21},
+		.page_size = 2048,
+		.page_spare_size = 64,
+		.pages_per_blk = 64,
+		.blks_per_chip = 1024,
+		.options = 0,
+		.ecc_mask = 3,
+		.ecc_uncorr = 2,
+		.ecc_layout = &ecc_layout_64,
+	},
+	{
+		.name = "MX35LF1GE4AB",
+		.id_info = {
+			.id_addr = 0,
+			.id_len = 2,
+		},
+		.dev_id = {0xC2, 0x12},
+		.page_size = 2048,
+		.page_spare_size = 64,
+		.pages_per_blk = 64,
+		.blks_per_chip = 1024,
+		.options = 0,
+		.ecc_mask = 3,
+		.ecc_uncorr = 2,
+	},
+	{
+		.name = "MX35LF2GE4AB",
+		.id_info = {
+			.id_addr = 0,
+			.id_len = 2,
+		},
+		.dev_id = {0xC2, 0x22},
+		.page_size = 2048,
+		.page_spare_size = 64,
+		.pages_per_blk = 64,
+		.blks_per_chip = 2048,
+		.options = SPINAND_NEED_PLANE_SELECT,
+		.ecc_mask = 3,
+		.ecc_uncorr = 2,
+		.ecc_layout =&mx35_ecc_layout_64,
+	},
+	{
+		.name = "GD5F1GQ4U",
+		.id_info = {
+			.id_addr = SPI_NAND_ID_NO_DUMMY,
+			.id_len = 3,
+		},
+		.dev_id = {0xC8, 0xB1, 0x48},
+		.page_size = 2048,
+		.page_spare_size = 128,
+		.pages_per_blk = 64,
+		.blks_per_chip = 1024,
+		.options = 0,
+		.ecc_mask = 7,
+		.ecc_uncorr = 7,
+		.ecc_layout = &gd5f_ecc_layout_128,
+	},
+	{
+		.name = "GD5F2GQ4U",
+		.id_info = {
+			.id_addr = SPI_NAND_ID_NO_DUMMY,
+			.id_len = 3,
+		},
+		.dev_id = {0xC8, 0xB2, 0x48},
+		.page_size = 2048,
+		.page_spare_size = 128,
+		.pages_per_blk = 64,
+		.blks_per_chip = 1024,
+		.options = 0,
+		.ecc_mask = 7,
+		.ecc_uncorr = 7,
+	},
+	{
+			.name = "PN26G01A",
+			.id_info = {
+				.id_addr = 0x0,
+				.id_len = 2,
+			},
+			.dev_id = {0xA1, 0xE1},
+			.page_size = 2048,
+			.page_spare_size = 128,
+			.pages_per_blk = 64,
+			.blks_per_chip = 1024,
+			.options = 0,
+			.ecc_mask = 3,
+			.ecc_uncorr = 2,
+			.ecc_layout = &pn26_ecc_layout_128,
+		}
+
+};
+
+/**
+ * spi_nand_scan_id_table - [INTERN] scan chip info in id table
+ * @chip: SPI-NAND device structure
+ * @id: point to manufacture id and device id
+ */
+bool spi_nand_scan_id_table(struct spi_nand_chip *chip, u8 *id)
+{
+	int i, j = 0;
+	struct spi_nand_flash *type = spi_nand_table;
+	int m=0;
+
+	for (m=0; m<ARRAY_SIZE(spi_nand_table); m++,type++) {
+//		if (id[0] == type->mfr_id && id[1] == type->dev_id) {
+		for (j=0, i = (SPI_NAND_ID_NO_DUMMY == type->id_info.id_addr) ? 0 : 1;
+		                j < type->id_info.id_len;j++,i++ ) {
+			if (id[i] != type->dev_id[j])
+				break;
+		}
+		if (j == type->id_info.id_len) {
+			chip->name = type->name;
+			chip->size = type->page_size * type->pages_per_blk
+				     * type->blks_per_chip;
+			chip->block_size = type->page_size
+					   * type->pages_per_blk;
+			chip->page_size = type->page_size;
+			chip->page_spare_size = type->page_spare_size;
+			chip->block_shift = ilog2(chip->block_size);
+			chip->page_shift = ilog2(chip->page_size);
+			chip->page_mask = chip->page_size - 1;
+			chip->options = type->options;
+			if (!type->ecc_layout)
+				chip->ecclayout = &default_ecc_layout;
+			else
+				chip->ecclayout = type->ecc_layout;
+			chip->dev_id_len = type->id_info.id_len;
+			chip->ecc_uncorr = type->ecc_uncorr;
+			chip->ecc_mask = type->ecc_mask;
+			memcpy(chip->dev_id, type->dev_id, chip->dev_id_len);
+			return true;
+		}
+	}
+	return false;
+}
diff -uraN linux-3.0.8/drivers/mtd/spi-nand/spi-nand-ids.h linux-3.0.8-fh8632-V1.0_20180330/drivers/mtd/spi-nand/spi-nand-ids.h
--- linux-3.0.8/drivers/mtd/spi-nand/spi-nand-ids.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/mtd/spi-nand/spi-nand-ids.h	2021-07-13 23:40:34.582361938 +0300
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2016 Fullhan, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+#ifndef DRIVERS_MTD_SPI_NAND_SPI_NAND_IDS_H_
+#define DRIVERS_MTD_SPI_NAND_SPI_NAND_IDS_H_
+
+enum spi_nand_device_variant {
+	SPI_NAND_GENERIC,
+	SPI_NAND_MT29F,
+	SPI_NAND_GD5F,
+};
+
+
+bool spi_nand_scan_id_table(struct spi_nand_chip *chip, u8 *id);
+
+#endif /* DRIVERS_MTD_SPI_NAND_SPI_NAND_IDS_H_ */
diff -uraN linux-3.0.8/drivers/net/fh_gmac/fh_gmac_dma.c linux-3.0.8-fh8632-V1.0_20180330/drivers/net/fh_gmac/fh_gmac_dma.c
--- linux-3.0.8/drivers/net/fh_gmac/fh_gmac_dma.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/net/fh_gmac/fh_gmac_dma.c	2021-07-13 23:40:36.058370882 +0300
@@ -0,0 +1,519 @@
+#include <linux/io.h>
+#include <linux/dma-mapping.h>
+#include <asm/dma-mapping.h>
+#include <mach/fh_gmac.h>
+#include "fh_gmac.h"
+#include "fh_gmac_dma.h"
+
+void GMAC_DMA_ReleaseTxDesc(Gmac_Tx_DMA_Descriptors * desc)
+{
+	int ter = desc->desc1.bit.end_of_ring;
+	desc->desc0.dw = 0;
+	desc->desc1.dw = 0;
+	/* set termination field */
+	desc->desc1.bit.end_of_ring = ter;
+}
+
+void GMAC_DMA_DisplayRxDesc(Gmac_Rx_DMA_Descriptors * desc, int size)
+{
+	int i;
+	for (i = 0; i < size; i++) {
+		pr_info("\t%d [0x%x]: DES0=0x%x DES1=0x%x DES2=0x%x DES3=0x%x",
+			i, (__u32) (&desc[i]), desc[i].desc0.dw,
+			desc[i].desc1.dw, desc[i].desc2.dw, desc[i].desc3.dw);
+		pr_info("\n");
+	}
+}
+
+void GMAC_DMA_DisplayTxDesc(Gmac_Tx_DMA_Descriptors * desc, int size)
+{
+	int i;
+	pr_info("Tx desc:\n");
+	for (i = 0; i < size; i++) {
+		pr_info("\t%d [0x%x]: DES0=0x%x DES1=0x%x BUF1=0x%x BUF2=0x%x",
+			i, (__u32) & desc[i], desc[i].desc0.dw,
+			desc[i].desc1.dw, desc[i].desc2.dw, desc[i].desc3.dw);
+		pr_info("\n");
+	}
+}
+
+void GMAC_DMA_InitRxDesc(Gmac_Rx_DMA_Descriptors * desc, __u32 size)
+{
+	int i;
+	for (i = 0; i < size; i++) {
+		desc->desc0.bit.own = 1;
+		desc->desc1.bit.buffer1_size = BUFFER_SIZE_2K - 1;
+		if (i == size - 1) {
+			desc->desc1.bit.end_of_ring = 1;
+		}
+		desc++;
+	}
+}
+
+void GMAC_DMA_InitTxDesc(Gmac_Tx_DMA_Descriptors * desc, __u32 size)
+{
+	int i;
+	for (i = 0; i < size; i++) {
+		desc->desc0.bit.own = 0;
+		if (i == size - 1) {
+			desc->desc1.bit.end_of_ring = 1;
+		}
+		desc++;
+	}
+}
+
+void GMAC_DMA_OpMode(Gmac_Object * pGmac)
+{
+
+	//op mode, reg 6
+	//transmit_store_forward
+	//receive_store_forward
+	writel(0 << 25 | 1 << 21 | 0 << 2 | 0 << 14,
+	       pGmac->remap_addr + REG_GMAC_OP_MODE);
+}
+
+void GMAC_DMA_InitDescRings(struct net_device *ndev)
+{
+	int i;
+	Gmac_Object *pGmac = netdev_priv(ndev);
+	struct sk_buff *skb;
+	__u32 txsize = pGmac->dma_tx_size;
+	__u32 rxsize = pGmac->dma_rx_size;
+	__u32 bfsize = pGmac->dma_buf_sz;
+
+	pGmac->rx_skbuff_dma = kmalloc(rxsize * sizeof(dma_addr_t), GFP_KERNEL);
+	pGmac->rx_skbuff =
+	    kmalloc(sizeof(struct sk_buff *) * rxsize, GFP_KERNEL);
+	pGmac->rx_dma_descriptors =
+	    (Gmac_Rx_DMA_Descriptors *) dma_alloc_coherent(pGmac->dev,
+							   rxsize *
+							   sizeof
+							   (Gmac_Rx_DMA_Descriptors),
+							   &pGmac->rx_bus_addr,
+							   GFP_KERNEL);
+	pGmac->tx_skbuff =
+	    kmalloc(sizeof(struct sk_buff *) * txsize, GFP_KERNEL);
+	pGmac->tx_dma_descriptors =
+	    (Gmac_Tx_DMA_Descriptors *) dma_alloc_coherent(pGmac->dev,
+							   txsize *
+							   sizeof
+							   (Gmac_Tx_DMA_Descriptors),
+							   &pGmac->tx_bus_addr,
+							   GFP_KERNEL);
+
+	if ((pGmac->rx_dma_descriptors == NULL)
+	    || (pGmac->tx_dma_descriptors == NULL)) {
+		pr_err("%s:ERROR allocating the DMA Tx/Rx desc\n", __func__);
+		return;
+	}
+
+	pr_debug("fh gmac (%s) DMA desc rings: virt addr (Rx %p, "
+		 "Tx %p)\n\tDMA phy addr (Rx 0x%08x, Tx 0x%08x)\n",
+		 ndev->name, pGmac->rx_dma_descriptors,
+		 pGmac->tx_dma_descriptors, (__u32) pGmac->rx_bus_addr,
+		 (__u32) pGmac->tx_bus_addr);
+
+	for (i = 0; i < rxsize; i++) {
+		Gmac_Rx_DMA_Descriptors *desc = pGmac->rx_dma_descriptors + i;
+
+		skb = netdev_alloc_skb_ip_align(ndev, bfsize);
+		if (unlikely(skb == NULL)) {
+			pr_err("%s: Rx init fails; skb is NULL\n", __func__);
+			break;
+		}
+		pGmac->rx_skbuff[i] = skb;
+		pGmac->rx_skbuff_dma[i] =
+		    dma_map_single(pGmac->dev, skb->data, bfsize,
+				   DMA_FROM_DEVICE);
+
+		desc->desc2.dw = pGmac->rx_skbuff_dma[i];
+	}
+	pGmac->cur_rx = 0;
+	pGmac->dirty_rx = (__u32) (i - rxsize);
+
+	pGmac->dma_buf_sz = bfsize;
+
+	/* TX INITIALIZATION */
+	for (i = 0; i < txsize; i++) {
+		pGmac->tx_skbuff[i] = NULL;
+		pGmac->tx_dma_descriptors[i].desc2.dw = 0;
+	}
+	pGmac->dirty_tx = 0;
+	pGmac->cur_tx = 0;
+
+	/* Clear the Rx/Tx descriptors */
+	GMAC_DMA_InitRxDesc(pGmac->rx_dma_descriptors, rxsize);
+	GMAC_DMA_InitTxDesc(pGmac->tx_dma_descriptors, txsize);
+#ifdef FH_GMAC_DMA_DEBUG
+	if (netif_msg_hw(pGmac)) {
+		pr_info("RX descriptor ring:\n");
+		GMAC_DMA_DisplayRxDesc(pGmac->rx_dma_descriptors, rxsize);
+		pr_info("TX descriptor ring:\n");
+		GMAC_DMA_DisplayTxDesc(pGmac->tx_dma_descriptors, txsize);
+	}
+#endif
+}
+
+void GMAC_DMA_FreeRxSkbufs(Gmac_Object * pGmac)
+{
+	int i;
+
+	for (i = 0; i < pGmac->dma_rx_size; i++) {
+		if (pGmac->rx_skbuff[i]) {
+			dma_unmap_single(pGmac->dev, pGmac->rx_skbuff_dma[i],
+					 pGmac->dma_buf_sz, DMA_FROM_DEVICE);
+			dev_kfree_skb_any(pGmac->rx_skbuff[i]);
+		}
+		pGmac->rx_skbuff[i] = NULL;
+	}
+}
+
+void GMAC_DMA_FreeTxSkbufs(Gmac_Object * pGmac)
+{
+	int i;
+
+	for (i = 0; i < pGmac->dma_tx_size; i++) {
+		if (pGmac->tx_skbuff[i] != NULL) {
+			Gmac_Tx_DMA_Descriptors *desc =
+			    pGmac->tx_dma_descriptors + i;
+			if (desc->desc2.dw) {
+				__u32 size;
+				size = desc->desc1.bit.buffer1_size;
+				dma_unmap_single(pGmac->dev, desc->desc2.dw,
+						 size, DMA_TO_DEVICE);
+			}
+			dev_kfree_skb_any(pGmac->tx_skbuff[i]);
+			pGmac->tx_skbuff[i] = NULL;
+		}
+	}
+}
+
+void GMAC_DMA_FreeDesc(Gmac_Object * pGmac)
+{
+	/* Release the DMA TX/RX socket buffers */
+	GMAC_DMA_FreeRxSkbufs(pGmac);
+	GMAC_DMA_FreeTxSkbufs(pGmac);
+
+	/* Free the region of consistent memory previously allocated for
+	 * the DMA */
+	dma_free_coherent(pGmac->dev,
+			  pGmac->dma_tx_size * sizeof(Gmac_Tx_DMA_Descriptors),
+			  pGmac->tx_dma_descriptors, pGmac->tx_bus_addr);
+	dma_free_coherent(pGmac->dev,
+			  pGmac->dma_rx_size * sizeof(Gmac_Tx_DMA_Descriptors),
+			  pGmac->rx_dma_descriptors, pGmac->rx_bus_addr);
+	kfree(pGmac->rx_skbuff_dma);
+	kfree(pGmac->rx_skbuff);
+	kfree(pGmac->tx_skbuff);
+}
+
+int GMAC_DMA_Init(struct net_device *ndev, __u32 dma_tx, __u32 dma_rx)
+{
+	Gmac_Object *pGmac = netdev_priv(ndev);
+#ifdef GMAC_RESET
+	int limit;
+
+	__u32 reg = readl(pGmac->remap_addr + REG_GMAC_BUS_MODE);
+	reg |= 0x1;
+	writel(reg, pGmac->remap_addr + REG_GMAC_BUS_MODE);
+
+	limit = 10;
+	while (limit--) {
+		if (!(readl(pGmac->remap_addr + REG_GMAC_BUS_MODE) & 0x1)) {
+			break;
+		}
+		mdelay(10);
+	}
+	if (limit < 0)
+		return -EBUSY;
+#endif
+	//initialize dma bus mode reg0
+	//8xpbl
+	//no address_aligned_beats
+	//no fixed_burst
+	writel(0 << 25 | 0 << 24 | 0 << 16 | 32 << 8,
+	       pGmac->remap_addr + REG_GMAC_BUS_MODE);
+	writel(0x1a061, pGmac->remap_addr + REG_GMAC_INTR_EN);
+	/* The base address of the RX/TX descriptor lists must be written into
+	 * DMA CSR3 and CSR4, respectively. */
+	writel(dma_rx, pGmac->remap_addr + REG_GMAC_RX_DESC_ADDR);
+	writel(dma_tx, pGmac->remap_addr + REG_GMAC_TX_DESC_ADDR);
+
+	return 0;
+}
+
+void GMAC_DMA_StartTx(Gmac_Object * pGmac)
+{
+	__u32 reg = readl(pGmac->remap_addr + REG_GMAC_OP_MODE);
+	reg |= 1 << 13;
+	writel(reg, pGmac->remap_addr + REG_GMAC_OP_MODE);
+}
+
+void GMAC_DMA_StopTx(Gmac_Object * pGmac)
+{
+	__u32 reg = readl(pGmac->remap_addr + REG_GMAC_OP_MODE);
+	reg &= ~(1 << 13);
+	writel(reg, pGmac->remap_addr + REG_GMAC_OP_MODE);
+}
+
+void GMAC_DMA_StartRx(Gmac_Object * pGmac)
+{
+	__u32 reg = readl(pGmac->remap_addr + REG_GMAC_OP_MODE);
+	reg |= 1 << 1;
+	writel(reg, pGmac->remap_addr + REG_GMAC_OP_MODE);
+}
+
+void GMAC_DMA_StopRx(Gmac_Object * pGmac)
+{
+	__u32 reg = readl(pGmac->remap_addr + REG_GMAC_OP_MODE);
+	reg &= ~(1 << 1);
+	writel(reg, pGmac->remap_addr + REG_GMAC_OP_MODE);
+}
+
+#ifdef FH_GMAC_DMA_DEBUG
+static void GMAC_DMA_ShowTxState(__u32 status)
+{
+	__u32 state;
+	state = (status & DMA_STATUS_TS_MASK) >> DMA_STATUS_TS_SHIFT;
+
+	switch (state) {
+	case 0:
+		pr_info("- TX (Stopped): Reset or Stop command\n");
+		break;
+	case 1:
+		pr_info("- TX (Running):Fetching the Tx desc\n");
+		break;
+	case 2:
+		pr_info("- TX (Running): Waiting for end of tx\n");
+		break;
+	case 3:
+		pr_info("- TX (Running): Reading the data "
+			"and queuing the data into the Tx buf\n");
+		break;
+	case 6:
+		pr_info("- TX (Suspended): Tx Buff Underflow "
+			"or an unavailable Transmit descriptor\n");
+		break;
+	case 7:
+		pr_info("- TX (Running): Closing Tx descriptor\n");
+		break;
+	default:
+		break;
+	}
+}
+
+static void GMAC_DMA_ShowRxState(__u32 status)
+{
+	__u32 state;
+	state = (status & DMA_STATUS_RS_MASK) >> DMA_STATUS_RS_SHIFT;
+
+	switch (state) {
+	case 0:
+		pr_info("- RX (Stopped): Reset or Stop command\n");
+		break;
+	case 1:
+		pr_info("- RX (Running): Fetching the Rx desc\n");
+		break;
+	case 2:
+		pr_info("- RX (Running):Checking for end of pkt\n");
+		break;
+	case 3:
+		pr_info("- RX (Running): Waiting for Rx pkt\n");
+		break;
+	case 4:
+		pr_info("- RX (Suspended): Unavailable Rx buf\n");
+		break;
+	case 5:
+		pr_info("- RX (Running): Closing Rx descriptor\n");
+		break;
+	case 6:
+		pr_info("- RX(Running): Flushing the current frame"
+			" from the Rx buf\n");
+		break;
+	case 7:
+		pr_info("- RX (Running): Queuing the Rx frame"
+			" from the Rx buf into memory\n");
+		break;
+	default:
+		break;
+	}
+}
+#endif
+
+int GMAC_DMA_Interrupt(Gmac_Object * pGmac)
+{
+	int ret = 0;
+	Gmac_Stats *gmac_stats = &pGmac->stats;
+	/* read the status register (CSR5) */
+	__u32 intr_status;
+	intr_status = readl(pGmac->remap_addr + REG_GMAC_STATUS);
+
+	GMAC_DMA_DBG("%s: [GMAC_STATUS: 0x%08x]\n", __func__, intr_status);
+#ifdef FH_GMAC_DMA_DEBUG
+	/* It displays the DMA process states (CSR5 register) */
+	GMAC_DMA_ShowTxState(intr_status);
+	GMAC_DMA_ShowRxState(intr_status);
+#endif
+	/* ABNORMAL interrupts */
+	if (unlikely(intr_status & DMA_STATUS_AIS)) {
+		GMAC_DMA_DBG(KERN_INFO "CSR5[15] DMA ABNORMAL IRQ: ");
+		if (unlikely(intr_status & DMA_STATUS_UNF)) {
+			GMAC_DMA_DBG(KERN_INFO "transmit underflow\n");
+			ret = tx_hard_error_bump_tc;
+			gmac_stats->tx_undeflow_irq++;
+		}
+		if (unlikely(intr_status & DMA_STATUS_TJT)) {
+			GMAC_DMA_DBG(KERN_INFO "transmit jabber\n");
+			gmac_stats->tx_jabber_irq++;
+		}
+		if (unlikely(intr_status & DMA_STATUS_OVF)) {
+			GMAC_DMA_DBG(KERN_INFO "recv overflow\n");
+			gmac_stats->rx_overflow_irq++;
+		}
+		if (unlikely(intr_status & DMA_STATUS_RU)) {
+			GMAC_DMA_DBG(KERN_INFO "receive buffer unavailable\n");
+			gmac_stats->rx_buf_unav_irq++;
+		}
+		if (unlikely(intr_status & DMA_STATUS_RPS)) {
+			GMAC_DMA_DBG(KERN_INFO "receive process stopped\n");
+			gmac_stats->rx_process_stopped_irq++;
+		}
+		if (unlikely(intr_status & DMA_STATUS_RWT)) {
+			GMAC_DMA_DBG(KERN_INFO "receive watchdog\n");
+			gmac_stats->rx_watchdog_irq++;
+		}
+		if (unlikely(intr_status & DMA_STATUS_ETI)) {
+			GMAC_DMA_DBG(KERN_INFO "transmit early interrupt\n");
+			gmac_stats->tx_early_irq++;
+		}
+		if (unlikely(intr_status & DMA_STATUS_TPS)) {
+			GMAC_DMA_DBG(KERN_INFO "transmit process stopped\n");
+			gmac_stats->tx_process_stopped_irq++;
+			ret = tx_hard_error;
+		}
+		if (unlikely(intr_status & DMA_STATUS_FBI)) {
+			GMAC_DMA_DBG(KERN_INFO "fatal bus error\n");
+			gmac_stats->fatal_bus_error_irq++;
+			ret = tx_hard_error;
+		}
+	}
+	/* TX/RX NORMAL interrupts */
+	if (intr_status & DMA_STATUS_NIS) {
+		gmac_stats->normal_irq_n++;
+		if (likely((intr_status & DMA_STATUS_RI) ||
+			   (intr_status & (DMA_STATUS_TI))))
+			ret = handle_tx_rx;
+	}
+	/* Optional hardware blocks, interrupts should be disabled */
+	if (unlikely(intr_status &
+		     (DMA_STATUS_GPI | DMA_STATUS_GMI | DMA_STATUS_GLI)))
+		pr_info("%s: unexpected status %08x\n", __func__, intr_status);
+
+	/* Clear the interrupt by writing a logic 1 to the CSR5[15-0] */
+	writel(intr_status & 0x1ffff, pGmac->remap_addr + REG_GMAC_STATUS);
+	GMAC_DMA_DBG(KERN_INFO "\n\n");
+
+	return ret;
+}
+
+int GMAC_DMA_TxStatus(Gmac_Object * pGmac, Gmac_Tx_DMA_Descriptors * desc)
+{
+	int ret = 0;
+	struct net_device_stats *stats = &pGmac->ndev->stats;
+	Gmac_Stats *gmac_stats = &pGmac->stats;
+
+	if (unlikely(desc->desc0.bit.error_summary)) {
+		if (unlikely(desc->desc0.bit.underflow_error)) {
+			gmac_stats->tx_underflow++;
+			stats->tx_fifo_errors++;
+		}
+		if (unlikely(desc->desc0.bit.no_carrier)) {
+			gmac_stats->tx_carrier++;
+			stats->tx_carrier_errors++;
+		}
+		if (unlikely(desc->desc0.bit.loss_of_carrier)) {
+			gmac_stats->tx_losscarrier++;
+			stats->tx_carrier_errors++;
+		}
+		if (unlikely((desc->desc0.bit.excessive_deferral) ||
+			     (desc->desc0.bit.excessive_collision) ||
+			     (desc->desc0.bit.late_collision)))
+			stats->collisions += desc->desc0.bit.collision_count;
+		ret = -1;
+	}
+	if (unlikely(desc->desc0.bit.deferred))
+		gmac_stats->tx_deferred++;
+
+	return ret;
+}
+
+int GMAC_DMA_RxStatus(Gmac_Object * pGmac, Gmac_Rx_DMA_Descriptors * desc)
+{
+	int ret = csum_none;
+	struct net_device_stats *stats = &pGmac->ndev->stats;
+	Gmac_Stats *gmac_stats = &pGmac->stats;
+
+	if (unlikely(desc->desc0.bit.last_descriptor == 0)) {
+		pr_warning("ndesc Error: Oversized Ethernet "
+			   "frame spanned multiple buffers\n");
+		stats->rx_length_errors++;
+		return discard_frame;
+	}
+
+	if (unlikely(desc->desc0.bit.error_summary)) {
+		if (unlikely(desc->desc0.bit.descriptor_error))
+			gmac_stats->rx_desc++;
+		if (unlikely(desc->desc0.bit.ipc_chksum_error_giant_frame))
+			gmac_stats->rx_toolong++;
+		if (unlikely(desc->desc0.bit.late_collision)) {
+			gmac_stats->rx_collision++;
+			stats->collisions++;
+		}
+		if (unlikely(desc->desc0.bit.crc_error)) {
+			gmac_stats->rx_crc++;
+			stats->rx_crc_errors++;
+		}
+		ret = discard_frame;
+	}
+	if (unlikely(desc->desc0.bit.dribble_error))
+		ret = discard_frame;
+
+	if (unlikely(desc->desc0.bit.length_error)) {
+		gmac_stats->rx_length++;
+		ret = discard_frame;
+	}
+
+	return ret;
+}
+
+void GMAC_DMA_DiagnosticFrame(void *data, Gmac_Object * pGmac)
+{
+	struct net_device_stats *stats = (struct net_device_stats *)data;
+	Gmac_Stats *gmac_stats = &pGmac->stats;
+	__u32 csr8 = readl(pGmac->remap_addr + REG_GMAC_ERROR_COUNT);
+
+	if (unlikely(csr8)) {
+		//Overflow bit for FIFO Overflow Counter
+		if (csr8 & 0x10000000) {
+			stats->rx_over_errors += 0x800;
+			gmac_stats->rx_overflow_cntr += 0x800;
+		} else {
+			unsigned int ove_cntr;
+			//indicates the number of frames missed by the application
+			ove_cntr = ((csr8 & 0x0ffe0000) >> 17);
+			stats->rx_over_errors += ove_cntr;
+			gmac_stats->rx_overflow_cntr += ove_cntr;
+		}
+
+		//Overflow bit for Missed Frame Counter
+		if (csr8 & 0x10000) {
+			stats->rx_missed_errors += 0xffff;
+			gmac_stats->rx_missed_cntr += 0xffff;
+		} else {
+			//indicates the number of frames missed by the controller
+			unsigned int miss_f = (csr8 & 0xffff);
+			stats->rx_missed_errors += miss_f;
+			gmac_stats->rx_missed_cntr += miss_f;
+		}
+	}
+}
diff -uraN linux-3.0.8/drivers/net/fh_gmac/fh_gmac_dma.h linux-3.0.8-fh8632-V1.0_20180330/drivers/net/fh_gmac/fh_gmac_dma.h
--- linux-3.0.8/drivers/net/fh_gmac/fh_gmac_dma.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/net/fh_gmac/fh_gmac_dma.h	2021-07-13 23:40:36.058370882 +0300
@@ -0,0 +1,183 @@
+/*
+ * fh_gmac_dma.h
+ *
+ *  Created on: May 22, 2014
+ *      Author: duobao
+ */
+
+#ifndef FH_GMAC_DMA_H_
+#define FH_GMAC_DMA_H_
+
+
+
+/* DMA Status register defines */
+#define DMA_STATUS_GPI		0x10000000	/* PMT interrupt */
+#define DMA_STATUS_GMI		0x08000000	/* MMC interrupt */
+#define DMA_STATUS_GLI		0x04000000	/* GMAC Line interface int */
+#define DMA_STATUS_GMI		0x08000000
+#define DMA_STATUS_GLI		0x04000000
+#define DMA_STATUS_EB_MASK	0x00380000	/* Error Bits Mask */
+#define DMA_STATUS_EB_TX_ABORT	0x00080000	/* Error Bits - TX Abort */
+#define DMA_STATUS_EB_RX_ABORT	0x00100000	/* Error Bits - RX Abort */
+#define DMA_STATUS_TS_MASK	0x00700000	/* Transmit Process State */
+#define DMA_STATUS_TS_SHIFT	20
+#define DMA_STATUS_RS_MASK	0x000e0000	/* Receive Process State */
+#define DMA_STATUS_RS_SHIFT	17
+#define DMA_STATUS_NIS	0x00010000	/* Normal Interrupt Summary */
+#define DMA_STATUS_AIS	0x00008000	/* Abnormal Interrupt Summary */
+#define DMA_STATUS_ERI	0x00004000	/* Early Receive Interrupt */
+#define DMA_STATUS_FBI	0x00002000	/* Fatal Bus Error Interrupt */
+#define DMA_STATUS_ETI	0x00000400	/* Early Transmit Interrupt */
+#define DMA_STATUS_RWT	0x00000200	/* Receive Watchdog Timeout */
+#define DMA_STATUS_RPS	0x00000100	/* Receive Process Stopped */
+#define DMA_STATUS_RU	0x00000080	/* Receive Buffer Unavailable */
+#define DMA_STATUS_RI	0x00000040	/* Receive Interrupt */
+#define DMA_STATUS_UNF	0x00000020	/* Transmit Underflow */
+#define DMA_STATUS_OVF	0x00000010	/* Receive Overflow */
+#define DMA_STATUS_TJT	0x00000008	/* Transmit Jabber Timeout */
+#define DMA_STATUS_TU	0x00000004	/* Transmit Buffer Unavailable */
+#define DMA_STATUS_TPS	0x00000002	/* Transmit Process Stopped */
+#define DMA_STATUS_TI	0x00000001	/* Transmit Interrupt */
+#define DMA_CONTROL_FTF		0x00100000 /* Flush transmit FIFO */
+
+typedef union
+{
+	struct
+	{
+		__u32	deferred						:1; //0~31
+		__u32	underflow_error					:1;
+		__u32	excessive_deferral				:1;
+		__u32	collision_count					:4;
+		__u32	vlan_frame						:1;
+		__u32	excessive_collision				:1;
+		__u32	late_collision					:1;
+		__u32	no_carrier						:1;
+		__u32	loss_of_carrier					:1;
+		__u32	payload_checksum_error			:1;
+		__u32	frame_flushed					:1;
+		__u32	jabber_timeout					:1;
+		__u32	error_summary					:1;
+		__u32	ip_header_error					:1;
+		__u32	tx_timestamp_status				:1;
+		__u32	reserved_30_18					:13;
+		__u32	own								:1;
+	}bit;
+	__u32 dw;
+}Gmac_Tx_Descriptor0;
+
+typedef union
+{
+	struct
+	{
+		__u32	buffer1_size					:11; //0~31
+		__u32	buffer2_size					:11;
+		__u32	timestamp_enable				:1;
+		__u32	disable_padding					:1;
+		__u32	second_address_chained			:1;
+		__u32	end_of_ring						:1;
+		__u32	disable_crc						:1;
+		__u32	checksum_insertion_ctrl			:2;
+		__u32	first_segment					:1;
+		__u32	last_segment					:1;
+		__u32	intr_on_completion				:1;
+	}bit;
+	__u32 dw;
+}Gmac_Tx_Descriptor1;
+
+typedef union
+{
+	struct
+	{
+		__u32	buffer_address_pointer					:32; //0~31
+	}bit;
+	__u32 dw;
+}Gmac_Tx_Descriptor2;
+
+typedef union
+{
+	struct
+	{
+		__u32	buffer_address_pointer					:32; //0~31
+	}bit;
+	__u32 dw;
+}Gmac_Tx_Descriptor3;
+
+typedef union
+{
+	struct
+	{
+		__u32	mac_addr_payload_chksum_error	:1; //0
+		__u32	crc_error						:1;	//1
+		__u32	dribble_error					:1;	//2
+		__u32	receive_error					:1;	//3
+		__u32	watchdog_timeout				:1;	//4
+		__u32	frame_type						:1;	//5
+		__u32	late_collision					:1;	//6
+		__u32	ipc_chksum_error_giant_frame	:1;	//7
+		__u32	last_descriptor					:1;	//8
+		__u32	first_descriptor				:1;	//9
+		__u32	vlan_tag						:1; //10
+		__u32	overflow_error					:1; //11
+		__u32	length_error					:1; //12
+		__u32	sa_filter_fail					:1; //13
+		__u32	descriptor_error				:1; //14
+		__u32	error_summary					:1;	//15
+		__u32	frame_length					:14;//16~29
+		__u32	da_filter_fail					:1;	//30
+		__u32	own								:1; //31
+	}bit;
+	__u32 dw;
+}Gmac_Rx_Descriptor0;
+
+typedef union
+{
+	struct
+	{
+		__u32	buffer1_size					:11; //0~10
+		__u32	buffer2_size					:11; //11~21
+		__u32	reserved_23_22					:2;  //22~23
+		__u32	second_address_chained			:1;	 //24
+		__u32	end_of_ring						:1;	 //25
+		__u32	reserved_30_26					:5;	 //26~30
+		__u32	disable_intr_on_completion		:1;  //31
+	}bit;
+	__u32 dw;
+}Gmac_Rx_Descriptor1;
+
+typedef union
+{
+	struct
+	{
+		__u32	buffer_address_pointer					:32; //0~31
+	}bit;
+	__u32 dw;
+}Gmac_Rx_Descriptor2;
+
+typedef union
+{
+	struct
+	{
+		__u32	buffer_address_pointer					:32; //0~31
+	}bit;
+	__u32 dw;
+}Gmac_Rx_Descriptor3;
+
+typedef struct
+{
+	Gmac_Tx_Descriptor0 desc0;   	 /* control and status information of descriptor */
+	Gmac_Tx_Descriptor1 desc1;   	 /* buffer sizes                                 */
+	Gmac_Tx_Descriptor2 desc2;   	 /* physical address of the buffer 1             */
+	Gmac_Tx_Descriptor3 desc3;    	 /* physical address of the buffer 2             */
+}Gmac_Tx_DMA_Descriptors;
+
+typedef struct
+{
+	Gmac_Rx_Descriptor0 desc0;   	 /* control and status information of descriptor */
+	Gmac_Rx_Descriptor1 desc1;   	 /* buffer sizes                                 */
+	Gmac_Rx_Descriptor2 desc2;   	 /* physical address of the buffer 1             */
+	Gmac_Rx_Descriptor3 desc3;    	 /* physical address of the buffer 2             */
+}Gmac_Rx_DMA_Descriptors;
+
+
+
+#endif /* FH_GMAC_DMA_H_ */
diff -uraN linux-3.0.8/drivers/net/fh_gmac/fh_gmac_ethtool.c linux-3.0.8-fh8632-V1.0_20180330/drivers/net/fh_gmac/fh_gmac_ethtool.c
--- linux-3.0.8/drivers/net/fh_gmac/fh_gmac_ethtool.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/net/fh_gmac/fh_gmac_ethtool.c	2021-07-13 23:40:36.058370882 +0300
@@ -0,0 +1,316 @@
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <mach/fh_gmac.h>
+#include "fh_gmac.h"
+
+#define REG_SPACE_SIZE	0x1054
+#define GMAC_ETHTOOL_NAME	"fh_gmac"
+
+struct gmac_stats
+{
+	char stat_string[ETH_GSTRING_LEN];
+	int sizeof_stat;
+	int stat_offset;
+};
+
+#define FH_GMAC_STAT(m)	\
+	{ #m, FIELD_SIZEOF(Gmac_Stats, m),	\
+	offsetof(Gmac_Object, stats.m)}
+
+static const struct gmac_stats gmac_gstrings_stats[] =
+{
+	FH_GMAC_STAT(tx_underflow),
+	FH_GMAC_STAT(tx_carrier),
+	FH_GMAC_STAT(tx_losscarrier),
+	FH_GMAC_STAT(tx_heartbeat),
+	FH_GMAC_STAT(tx_deferred),
+	FH_GMAC_STAT(tx_vlan),
+	FH_GMAC_STAT(tx_jabber),
+	FH_GMAC_STAT(tx_frame_flushed),
+	FH_GMAC_STAT(tx_payload_error),
+	FH_GMAC_STAT(tx_ip_header_error),
+	FH_GMAC_STAT(rx_desc),
+	FH_GMAC_STAT(rx_partial),
+	FH_GMAC_STAT(rx_runt),
+	FH_GMAC_STAT(rx_toolong),
+	FH_GMAC_STAT(rx_collision),
+	FH_GMAC_STAT(rx_crc),
+	FH_GMAC_STAT(rx_length),
+	FH_GMAC_STAT(rx_mii),
+	FH_GMAC_STAT(rx_multicast),
+	FH_GMAC_STAT(rx_gmac_overflow),
+	FH_GMAC_STAT(rx_watchdog),
+	FH_GMAC_STAT(da_rx_filter_fail),
+	FH_GMAC_STAT(sa_rx_filter_fail),
+	FH_GMAC_STAT(rx_missed_cntr),
+	FH_GMAC_STAT(rx_overflow_cntr),
+	FH_GMAC_STAT(tx_undeflow_irq),
+	FH_GMAC_STAT(tx_process_stopped_irq),
+	FH_GMAC_STAT(tx_jabber_irq),
+	FH_GMAC_STAT(rx_overflow_irq),
+	FH_GMAC_STAT(rx_buf_unav_irq),
+	FH_GMAC_STAT(rx_process_stopped_irq),
+	FH_GMAC_STAT(rx_watchdog_irq),
+	FH_GMAC_STAT(tx_early_irq),
+	FH_GMAC_STAT(fatal_bus_error_irq),
+	FH_GMAC_STAT(threshold),
+	FH_GMAC_STAT(tx_pkt_n),
+	FH_GMAC_STAT(rx_pkt_n),
+	FH_GMAC_STAT(poll_n),
+	FH_GMAC_STAT(sched_timer_n),
+	FH_GMAC_STAT(normal_irq_n),
+};
+#define FH_GMAC_STATS_LEN ARRAY_SIZE(gmac_gstrings_stats)
+
+static void gmac_ethtool_getdrvinfo(struct net_device *ndev, struct ethtool_drvinfo *info)
+{
+	strcpy(info->driver, GMAC_ETHTOOL_NAME);
+
+	strcpy(info->version, "0.0.1");
+	info->fw_version[0] = '\0';
+	info->n_stats = FH_GMAC_STATS_LEN;
+}
+
+static int gmac_ethtool_getsettings(struct net_device *ndev, struct ethtool_cmd *cmd)
+{
+	Gmac_Object* pGmac = netdev_priv(ndev);
+	struct phy_device *phy = pGmac->phydev;
+	int rc;
+	if (phy == NULL)
+	{
+		pr_err("%s: %s: PHY is not registered\n",
+		       __func__, ndev->name);
+		return -ENODEV;
+	}
+	if (!netif_running(ndev))
+	{
+		pr_err("%s: interface is disabled: we cannot track "
+		"link speed / duplex setting\n", ndev->name);
+		return -EBUSY;
+	}
+	cmd->transceiver = XCVR_INTERNAL;
+	spin_lock_irq(&pGmac->lock);
+	rc = phy_ethtool_gset(phy, cmd);
+	spin_unlock_irq(&pGmac->lock);
+	return rc;
+}
+
+static int gmac_ethtool_setsettings(struct net_device *ndev, struct ethtool_cmd *cmd)
+{
+	Gmac_Object* pGmac = netdev_priv(ndev);
+	struct phy_device *phy = pGmac->phydev;
+	int rc;
+
+	spin_lock(&pGmac->lock);
+	rc = phy_ethtool_sset(phy, cmd);
+	spin_unlock(&pGmac->lock);
+
+	return rc;
+}
+
+static __u32 gmac_ethtool_getmsglevel(struct net_device *ndev)
+{
+	Gmac_Object* pGmac = netdev_priv(ndev);
+	return pGmac->msg_enable;
+}
+
+static void gmac_ethtool_setmsglevel(struct net_device *ndev, __u32 level)
+{
+	Gmac_Object* pGmac = netdev_priv(ndev);
+	pGmac->msg_enable = level;
+
+}
+
+static int gmac_check_if_running(struct net_device *ndev)
+{
+	if (!netif_running(ndev))
+		return -EBUSY;
+	return 0;
+}
+
+static int gmac_ethtool_get_regs_len(struct net_device *ndev)
+{
+	return REG_SPACE_SIZE;
+}
+
+static void gmac_ethtool_gregs(struct net_device *ndev, struct ethtool_regs *regs, void *space)
+{
+	int i;
+	__u32 *reg_space = (__u32 *) space;
+
+	Gmac_Object* pGmac = netdev_priv(ndev);
+
+	memset(reg_space, 0x0, REG_SPACE_SIZE);
+
+	/* MAC registers */
+	for (i = 0; i < 55; i++)
+		reg_space[i] = readl(pGmac->remap_addr + (i * 4));
+	/* DMA registers */
+	for (i = 0; i < 22; i++)
+		reg_space[i + 55] = readl(pGmac->remap_addr + (REG_GMAC_BUS_MODE + (i * 4)));
+}
+
+static void gmac_get_pauseparam(struct net_device *ndev, struct ethtool_pauseparam *pause)
+{
+	Gmac_Object* pGmac = netdev_priv(ndev);
+
+	spin_lock(&pGmac->lock);
+
+	pause->rx_pause = 0;
+	pause->tx_pause = 0;
+	pause->autoneg = pGmac->phydev->autoneg;
+
+	if (pGmac->flow_ctrl & FLOW_RX)
+		pause->rx_pause = 1;
+	if (pGmac->flow_ctrl & FLOW_TX)
+		pause->tx_pause = 1;
+
+	spin_unlock(&pGmac->lock);
+}
+
+static int gmac_set_pauseparam(struct net_device *ndev, struct ethtool_pauseparam *pause)
+{
+	Gmac_Object* pGmac = netdev_priv(ndev);
+	struct phy_device *phy = pGmac->phydev;
+	int new_pause = FLOW_OFF;
+	int ret = 0;
+
+	spin_lock(&pGmac->lock);
+
+	if (pause->rx_pause)
+		new_pause |= FLOW_RX;
+	if (pause->tx_pause)
+		new_pause |= FLOW_TX;
+
+	pGmac->flow_ctrl = new_pause;
+	phy->autoneg = pause->autoneg;
+
+	if (phy->autoneg)
+	{
+		if (netif_running(ndev))
+			ret = phy_start_aneg(phy);
+	}
+	else
+	{
+		GMAC_FlowCtrl(pGmac, phy->duplex, pGmac->flow_ctrl, pGmac->pause);
+	}
+	spin_unlock(&pGmac->lock);
+	return ret;
+}
+
+static void gmac_get_ethtool_stats(struct net_device *ndev, struct ethtool_stats *dummy, __u64 *data)
+{
+	Gmac_Object* pGmac = netdev_priv(ndev);
+	int i;
+
+	/* Update HW stats if supported */
+	GMAC_DMA_DiagnosticFrame(&ndev->stats, pGmac);
+
+	for (i = 0; i < FH_GMAC_STATS_LEN; i++)
+	{
+		char *p = (char *)pGmac + gmac_gstrings_stats[i].stat_offset;
+		data[i] = (gmac_gstrings_stats[i].sizeof_stat ==
+		sizeof(__u64)) ? (*(__u64 *)p) : (*(__u32 *)p);
+	}
+}
+
+static int gmac_get_sset_count(struct net_device *netdev, int sset)
+{
+	switch (sset)
+	{
+	case ETH_SS_STATS:
+		return FH_GMAC_STATS_LEN;
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+static void gmac_get_strings(struct net_device *ndev, __u32 stringset, __u8 *data)
+{
+	int i;
+	__u8 *p = data;
+
+	switch (stringset)
+	{
+	case ETH_SS_STATS:
+		for (i = 0; i < FH_GMAC_STATS_LEN; i++)
+		{
+			memcpy(p, gmac_gstrings_stats[i].stat_string, ETH_GSTRING_LEN);
+			p += ETH_GSTRING_LEN;
+		}
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+}
+
+/* Currently only support WOL through Magic packet. */
+static void gmac_get_wol(struct net_device *ndev, struct ethtool_wolinfo *wol)
+{
+	Gmac_Object* pGmac = netdev_priv(ndev);
+
+	spin_lock_irq(&pGmac->lock);
+	if (device_can_wakeup(pGmac->dev))
+	{
+		wol->supported = WAKE_MAGIC | WAKE_UCAST;
+		wol->wolopts = pGmac->wolopts;
+	}
+	spin_unlock_irq(&pGmac->lock);
+}
+
+static int gmac_set_wol(struct net_device *ndev, struct ethtool_wolinfo *wol)
+{
+	Gmac_Object* pGmac = netdev_priv(ndev);
+	__u32 support = WAKE_MAGIC | WAKE_UCAST;
+
+	if (!device_can_wakeup(pGmac->dev))
+		return -EINVAL;
+
+	if (wol->wolopts & ~support)
+		return -EINVAL;
+
+	if (wol->wolopts)
+	{
+		pr_info("fh_gmac: wakeup enable\n");
+		device_set_wakeup_enable(pGmac->dev, 1);
+		enable_irq_wake(ndev->irq);
+	}
+	else
+	{
+		device_set_wakeup_enable(pGmac->dev, 0);
+		disable_irq_wake(ndev->irq);
+	}
+
+	spin_lock_irq(&pGmac->lock);
+	pGmac->wolopts = wol->wolopts;
+	spin_unlock_irq(&pGmac->lock);
+
+	return 0;
+}
+
+static struct ethtool_ops fh_gmac_ethtool_ops = {
+	.begin = gmac_check_if_running,
+	.get_drvinfo = gmac_ethtool_getdrvinfo,
+	.get_settings = gmac_ethtool_getsettings,
+	.set_settings = gmac_ethtool_setsettings,
+	.get_msglevel = gmac_ethtool_getmsglevel,
+	.set_msglevel = gmac_ethtool_setmsglevel,
+	.get_regs = gmac_ethtool_gregs,
+	.get_regs_len = gmac_ethtool_get_regs_len,
+	.get_link = ethtool_op_get_link,
+	.get_pauseparam = gmac_get_pauseparam,
+	.set_pauseparam = gmac_set_pauseparam,
+	.get_ethtool_stats = gmac_get_ethtool_stats,
+	.get_strings = gmac_get_strings,
+	.get_wol = gmac_get_wol,
+	.set_wol = gmac_set_wol,
+	.get_sset_count	= gmac_get_sset_count,
+};
+
+void fh_gmac_set_ethtool_ops(struct net_device *netdev)
+{
+	SET_ETHTOOL_OPS(netdev, &fh_gmac_ethtool_ops);
+}
diff -uraN linux-3.0.8/drivers/net/fh_gmac/fh_gmac.h linux-3.0.8-fh8632-V1.0_20180330/drivers/net/fh_gmac/fh_gmac.h
--- linux-3.0.8/drivers/net/fh_gmac/fh_gmac.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/net/fh_gmac/fh_gmac.h	2021-07-13 23:40:36.058370882 +0300
@@ -0,0 +1,245 @@
+/*
+ * fh_gmac.h
+ *
+ *  Created on: May 22, 2014
+ *      Author: duobao
+ */
+
+#ifndef FH_GMAC_H_
+#define FH_GMAC_H_
+
+#include <linux/phy.h>
+#include <linux/etherdevice.h>
+
+#include "fh_gmac_phyt.h"
+#include "fh_gmac_dma.h"
+
+//GMAC-MAC
+#define		REG_GMAC_CONFIG				(0x0000)
+#define		REG_GMAC_FRAME_FILTER		(0x0004)
+#define		REG_GMAC_HASH_HIGH			(0x0008)
+#define		REG_GMAC_HASH_LOW			(0x000C)
+#define		REG_GMAC_GMII_ADDRESS		(0x0010)
+#define		REG_GMAC_GMII_DATA			(0x0014)
+#define		REG_GMAC_FLOW_CTRL			(0x0018)
+#define		REG_GMAC_DEBUG				(0x0024)
+#define		REG_GMAC_MAC_HIGH 			(0x0040)
+#define		REG_GMAC_MAC_LOW 			(0x0044)
+//GMAC-DMA
+#define		REG_GMAC_BUS_MODE			(0x1000)
+#define		REG_GMAC_TX_POLL_DEMAND		(0x1004)
+#define		REG_GMAC_RX_POLL_DEMAND		(0x1008)
+#define		REG_GMAC_RX_DESC_ADDR		(0x100C)
+#define		REG_GMAC_TX_DESC_ADDR		(0x1010)
+#define		REG_GMAC_STATUS				(0x1014)
+#define		REG_GMAC_OP_MODE			(0x1018)
+#define		REG_GMAC_INTR_EN			(0x101C)
+#define		REG_GMAC_ERROR_COUNT		(0x1020)
+#define		REG_GMAC_AXI_BUS_MODE		(0x1028)
+#define		REG_GMAC_AXI_STATUS			(0x102C)
+#define 	REG_GMAC_CURR_TX_DESC		(0x1048)
+#define 	REG_GMAC_CURR_RX_DESC		(0x104C)
+
+enum tx_dma_irq_status {
+	tx_hard_error = 1,
+	tx_hard_error_bump_tc = 2,
+	handle_tx_rx = 3,
+};
+
+enum rx_frame_status {
+	good_frame = 0,
+	discard_frame = 1,
+	csum_none = 2,
+	llc_snap = 4,
+};
+
+#define GMAC_MIN_ETHPKTSIZE		(60) /* Minimum ethernet pkt size */
+#define GMAC_MAX_FRAME_SIZE		(1500 + 14 + 4 + 4)
+
+#define BUFFER_SIZE_2K	2048
+#define BUFFER_SIZE_4K	4096
+#define BUFFER_SIZE_8K	8192
+#define BUFFER_SIZE_16K	16384
+
+#ifdef FH_GMAC_DMA_DEBUG
+#define GMAC_DMA_DBG(fmt, args...)  printk(fmt, ## args)
+#else
+#define GMAC_DMA_DBG(fmt, args...)  do { } while (0)
+#endif
+
+#ifdef FH_GMAC_XMIT_DEBUG
+#define TX_DBG(fmt, args...)  printk(fmt, ## args)
+#else
+#define TX_DBG(fmt, args...)  do { } while (0)
+#endif
+
+#ifdef FH_GMAC_RX_DEBUG
+#define RX_DBG(fmt, args...)  printk(fmt, ## args)
+#else
+#define RX_DBG(fmt, args...)  do { } while (0)
+#endif
+
+#define FH_GMAC_DEBUG	(	NETIF_MSG_DRV | \
+								NETIF_MSG_PROBE | \
+								NETIF_MSG_LINK | \
+								NETIF_MSG_TIMER | \
+								NETIF_MSG_IFDOWN | \
+								NETIF_MSG_IFUP | \
+								NETIF_MSG_RX_ERR | \
+								NETIF_MSG_TX_ERR | \
+								NETIF_MSG_TX_QUEUED | \
+								NETIF_MSG_INTR | \
+								NETIF_MSG_TX_DONE | \
+								NETIF_MSG_RX_STATUS | \
+								NETIF_MSG_PKTDATA | \
+								NETIF_MSG_HW | \
+								NETIF_MSG_WOL			)
+
+enum {
+	gmac_gmii_clock_60_100,
+	gmac_gmii_clock_100_150,
+	gmac_gmii_clock_20_35,
+	gmac_gmii_clock_35_60,
+	gmac_gmii_clock_150_250,
+	gmac_gmii_clock_250_300
+};
+
+enum {
+	gmac_interrupt_all = 0x0001ffff,
+	gmac_interrupt_none = 0x0
+};
+
+typedef struct Gmac_Stats {
+	/* Transmit errors */
+	unsigned long tx_underflow ____cacheline_aligned;
+	unsigned long tx_carrier;
+	unsigned long tx_losscarrier;
+	unsigned long tx_heartbeat;
+	unsigned long tx_deferred;
+	unsigned long tx_vlan;
+	unsigned long tx_jabber;
+	unsigned long tx_frame_flushed;
+	unsigned long tx_payload_error;
+	unsigned long tx_ip_header_error;
+	/* Receive errors */
+	unsigned long rx_desc;
+	unsigned long rx_partial;
+	unsigned long rx_runt;
+	unsigned long rx_toolong;
+	unsigned long rx_collision;
+	unsigned long rx_crc;
+	unsigned long rx_length;
+	unsigned long rx_mii;
+	unsigned long rx_multicast;
+	unsigned long rx_gmac_overflow;
+	unsigned long rx_watchdog;
+	unsigned long da_rx_filter_fail;
+	unsigned long sa_rx_filter_fail;
+	unsigned long rx_missed_cntr;
+	unsigned long rx_overflow_cntr;
+	/* Tx/Rx IRQ errors */
+	unsigned long tx_undeflow_irq;
+	unsigned long tx_process_stopped_irq;
+	unsigned long tx_jabber_irq;
+	unsigned long rx_overflow_irq;
+	unsigned long rx_buf_unav_irq;
+	unsigned long rx_process_stopped_irq;
+	unsigned long rx_watchdog_irq;
+	unsigned long tx_early_irq;
+	unsigned long fatal_bus_error_irq;
+	/* Extra info */
+	unsigned long threshold;
+	unsigned long tx_pkt_n;
+	unsigned long rx_pkt_n;
+	unsigned long poll_n;
+	unsigned long sched_timer_n;
+	unsigned long normal_irq_n;
+}Gmac_Stats;
+
+typedef struct Gmac_Object {
+	Gmac_Tx_DMA_Descriptors* tx_dma_descriptors	____cacheline_aligned;
+	Gmac_Rx_DMA_Descriptors* rx_dma_descriptors;
+	int full_duplex;			//read only
+	int speed_100m;				//read only
+
+	struct sk_buff_head rx_recycle;
+	struct sk_buff** rx_skbuff;
+	struct sk_buff** tx_skbuff;
+	dma_addr_t* rx_skbuff_dma;
+	__u32 cur_rx;
+	__u32 dirty_rx;
+	__u32 cur_tx;
+	__u32 dirty_tx;
+	dma_addr_t tx_bus_addr;
+	dma_addr_t rx_bus_addr;
+	__u32 dma_tx_size;
+	__u32 dma_rx_size;
+	__u32 dma_buf_sz;
+
+	spinlock_t lock;
+
+	void __iomem *remap_addr;
+	__u8 local_mac_address[6];
+	__u32 msg_enable;
+	struct device* dev;
+	struct net_device* ndev;
+	struct platform_device* pdev;
+	struct napi_struct napi;
+	struct mii_bus *mii;
+	struct phy_device *phydev;
+	Gmac_Stats stats;
+
+	int oldlink;
+	int speed;
+	int oldduplex;
+	__u32 flow_ctrl;
+	__u32 pause;
+
+	int wolopts;
+	int wolenabled;
+
+	int phy_interface;
+	struct fh_gmac_platform_data* priv_data;
+
+	struct clk* clk;
+
+}Gmac_Object;
+
+#define TX_TIMEO 5000 /* default 5 seconds */
+#define DMA_RX_SIZE 256
+#define DMA_TX_SIZE 256
+#define FLOW_OFF 0
+#define FLOW_RX		4
+#define FLOW_TX		2
+#define FLOW_AUTO	(FLOW_TX | FLOW_RX)
+#define PAUSE_TIME 0x200
+
+int fh_mdio_register(struct net_device *ndev);
+int fh_mdio_unregister(struct net_device *ndev);
+
+void GMAC_DMA_StartTx(Gmac_Object* pGmac);
+void GMAC_DMA_StopTx(Gmac_Object* pGmac);
+void GMAC_DMA_StartRx(Gmac_Object* pGmac);
+void GMAC_DMA_StopRx(Gmac_Object* pGmac);
+
+void fh_gmac_set_ethtool_ops(struct net_device *netdev);
+
+void GMAC_DMA_InitDescRings(struct net_device *ndev);
+int GMAC_DMA_Init(struct net_device *ndev, __u32 dma_tx, __u32 dma_rx);
+void GMAC_DMA_InitRxDesc(Gmac_Rx_DMA_Descriptors* desc, unsigned int size);
+void GMAC_DMA_InitTxDesc(Gmac_Tx_DMA_Descriptors* desc, unsigned int size);
+void GMAC_DMA_OpMode(Gmac_Object* pGmac);
+void GMAC_DMA_FreeDesc(Gmac_Object* pGmac);
+void GMAC_DMA_FreeRxSkbufs(Gmac_Object* pGmac);
+void GMAC_DMA_FreeTxSkbufs(Gmac_Object* pGmac);
+void GMAC_DMA_DisplayRxDesc(Gmac_Rx_DMA_Descriptors* desc, int size);
+void GMAC_DMA_DisplayTxDesc(Gmac_Tx_DMA_Descriptors* desc, int size);
+int GMAC_DMA_Interrupt(Gmac_Object* pGmac);
+int GMAC_DMA_TxStatus(Gmac_Object* pGmac, Gmac_Tx_DMA_Descriptors* desc);
+int GMAC_DMA_RxStatus(Gmac_Object* pGmac, Gmac_Rx_DMA_Descriptors* desc);
+void GMAC_DMA_ReleaseTxDesc(Gmac_Tx_DMA_Descriptors* desc);
+void GMAC_DMA_DiagnosticFrame(void *data, Gmac_Object* pGmac);
+void GMAC_FlowCtrl(Gmac_Object * pGmac, unsigned int duplex, unsigned int fc,
+		   unsigned int pause_time);
+
+#endif /* FH_GMAC_H_ */
diff -uraN linux-3.0.8/drivers/net/fh_gmac/fh_gmac_main.c linux-3.0.8-fh8632-V1.0_20180330/drivers/net/fh_gmac/fh_gmac_main.c
--- linux-3.0.8/drivers/net/fh_gmac/fh_gmac_main.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/net/fh_gmac/fh_gmac_main.c	2021-07-13 23:40:36.058370882 +0300
@@ -0,0 +1,1364 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/errno.h>
+#include <linux/in.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/ethtool.h>
+#include <linux/highmem.h>
+#include <linux/proc_fs.h>
+#include <linux/ctype.h>
+#include <linux/version.h>
+#include <linux/spinlock.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/semaphore.h>
+#include <linux/phy.h>
+#include <linux/bitops.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <linux/irqreturn.h>
+
+#include <asm/irq.h>
+#include <asm/page.h>
+#include <asm/setup.h>
+#include <linux/crc32.h>
+#include <mach/fh_gmac.h>
+#include "fh_gmac.h"
+
+/* Module parameters */
+static int watchdog = TX_TIMEO;
+static int debug = 16;      /* -1: default, 0: no output, 16:  all */
+static int dma_txsize = DMA_TX_SIZE;
+static int dma_rxsize = DMA_RX_SIZE;
+static int flow_ctrl = FLOW_AUTO;
+static int pause = PAUSE_TIME;
+
+static unsigned int phymode = PHY_INTERFACE_MODE_MII;
+
+#if defined(FH_GMAC_XMIT_DEBUG) || defined(FH_GMAC_RX_DEBUG)
+static void print_pkt(unsigned char *buf, int len)
+{
+	int j;
+	printk("len = %d byte, buf addr: 0x%p", len, buf);
+	for (j = 0; j < len; j++)
+	{
+		if ((j % 16) == 0)
+			printk("\n %03x:", j);
+		printk(" %02x", buf[j]);
+	}
+	printk("\n");
+}
+#endif
+
+static __u32 GMAC_BitReverse(register __u32 x)
+{
+        register __u32 y = 0x55555555;
+        x = (((x >> 1) & y) | ((x & y) << 1));
+        y = 0x33333333;
+        x = (((x >> 2) & y) | ((x & y) << 2));
+        y = 0x0f0f0f0f;
+        x = (((x >> 4) & y) | ((x & y) << 4));
+        y = 0x00ff00ff;
+        x = (((x >> 8) & y) | ((x & y) << 8));
+        return((x >> 16) | (x << 16));
+}
+
+
+static void GMAC_SetMacAddress(Gmac_Object* pGmac)
+{
+
+	__u32 macHigh = pGmac->local_mac_address[5]<<8 | pGmac->local_mac_address[4];
+	__u32 macLow = pGmac->local_mac_address[3]<<24 | pGmac->local_mac_address[2]<<16 | pGmac->local_mac_address[1]<<8 | pGmac->local_mac_address[0];
+
+	writel(macHigh, pGmac->remap_addr + REG_GMAC_MAC_HIGH);
+	writel(macLow, pGmac->remap_addr + REG_GMAC_MAC_LOW);
+}
+
+int gmac_dev_set_mac_addr(struct net_device *dev, void *p)
+{
+    Gmac_Object *pGmac = netdev_priv(dev);
+    struct sockaddr *addr = p;
+    memcpy(pGmac->local_mac_address, addr->sa_data, ETH_ALEN);
+    GMAC_SetMacAddress(pGmac);
+    return eth_mac_addr(dev, p);
+}
+
+static inline void GMAC_EnableMac(Gmac_Object* pGmac)
+{
+		//transmitter enable
+		//receive enable
+		__u32 reg = readl(pGmac->remap_addr + REG_GMAC_CONFIG);
+		reg |= 0xc;
+		writel(reg, pGmac->remap_addr + REG_GMAC_CONFIG);
+
+}
+
+
+
+static inline void GMAC_DisableMac(Gmac_Object* pGmac)
+{
+		//transmitter disable
+		//receive disable
+		__u32 reg = readl(pGmac->remap_addr + REG_GMAC_CONFIG);
+		reg &= ~0xc;
+		writel(reg | 0xc, pGmac->remap_addr + REG_GMAC_CONFIG);
+}
+
+static inline void GMAC_CoreInit(Gmac_Object* pGmac)
+{
+	//FIXME: heartbeat disable
+	//auto pad or crc stripping
+	__u32 reg = readl(pGmac->remap_addr + REG_GMAC_CONFIG);
+	reg |= 0x80;
+	writel(reg | 0xc, pGmac->remap_addr + REG_GMAC_CONFIG);
+}
+
+void GMAC_FlowCtrl(Gmac_Object* pGmac, unsigned int duplex,
+			       unsigned int fc, unsigned int pause_time)
+{
+	__u32 flow = fc;
+
+	if (duplex)
+		flow |= (pause_time << 16);
+	writel(flow, pGmac->remap_addr + REG_GMAC_FLOW_CTRL);
+}
+
+static void gmac_tx_err(Gmac_Object* pGmac)
+{
+
+	netif_stop_queue(pGmac->ndev);
+	GMAC_DMA_StopTx(pGmac);
+	GMAC_DMA_FreeTxSkbufs(pGmac);
+	GMAC_DMA_InitTxDesc(pGmac->tx_dma_descriptors, pGmac->dma_tx_size);
+	pGmac->dirty_tx = 0;
+	pGmac->cur_tx = 0;
+	GMAC_DMA_StartTx(pGmac);
+	pGmac->ndev->stats.tx_errors++;
+	netif_wake_queue(pGmac->ndev);
+}
+
+
+static irqreturn_t fh_gmac_interrupt(int irq, void *dev_id)
+{
+
+	struct net_device *ndev = (struct net_device *)dev_id;
+	Gmac_Object *pGmac = netdev_priv(ndev);
+	int status;
+
+	if (unlikely(!ndev))
+	{
+		pr_err("%s: invalid ndev pointer\n", __func__);
+		return IRQ_NONE;
+	}
+
+
+	status = GMAC_DMA_Interrupt(pGmac);
+	if (likely(status == handle_tx_rx))
+	{
+		if (likely(napi_schedule_prep(&pGmac->napi)))
+		{
+			writel(0x0, pGmac->remap_addr + REG_GMAC_INTR_EN);
+			__napi_schedule(&pGmac->napi);
+		}
+	}
+	else if (unlikely(status & tx_hard_error_bump_tc))
+	{
+		//FIXME: tx underflow
+	}
+	else if (unlikely(status == tx_hard_error))
+	{
+		gmac_tx_err(pGmac);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void fh_gmac_verify_args(void)
+{
+	if (unlikely(watchdog < 0))
+		watchdog = TX_TIMEO;
+	if (unlikely(dma_rxsize < 0))
+		dma_rxsize = DMA_RX_SIZE;
+	if (unlikely(dma_txsize < 0))
+		dma_txsize = DMA_TX_SIZE;
+	if (unlikely(flow_ctrl > 1))
+		flow_ctrl = FLOW_AUTO;
+	else if (likely(flow_ctrl < 0))
+		flow_ctrl = FLOW_OFF;
+	if (unlikely((pause < 0) || (pause > 0xffff)))
+		pause = PAUSE_TIME;
+
+}
+
+static void fh_gmac_adjust_link(struct net_device *ndev)
+{
+	Gmac_Object *pGmac = netdev_priv(ndev);
+	struct phy_device *phydev = pGmac->phydev;
+	unsigned long flags;
+	int new_state = 0;
+
+	if (phydev == NULL)
+		return;
+
+	spin_lock_irqsave(&pGmac->lock, flags);
+	if (phydev->link)
+	{
+		__u32 ctrl = readl(pGmac->remap_addr + REG_GMAC_CONFIG);
+
+		/* Now we make sure that we can be in full duplex mode.
+		 * If not, we operate in half-duplex mode. */
+		if (phydev->duplex != pGmac->oldduplex)
+		{
+			new_state = 1;
+			if (!(phydev->duplex))
+				ctrl &= ~0x800;
+			else
+				ctrl |= 0x800;
+			pGmac->oldduplex = phydev->duplex;
+		}
+		/* Flow Control operation */
+		if (phydev->pause)
+		{
+			__u32 fc = pGmac->flow_ctrl, pause_time = pGmac->pause;
+			GMAC_FlowCtrl(pGmac, phydev->duplex, fc, pause_time);
+		}
+
+		if (phydev->speed != pGmac->speed)
+		{
+			new_state = 1;
+			switch (phydev->speed)
+			{
+			case 100:
+				ctrl |= 0x4000;
+				if(pGmac->priv_data->set_rmii_speed)
+					pGmac->priv_data->set_rmii_speed(gmac_speed_100m);
+				break;
+			case 10:
+				ctrl &= ~0x4000;
+				if(pGmac->priv_data->set_rmii_speed)
+					pGmac->priv_data->set_rmii_speed(gmac_speed_10m);
+				break;
+			default:
+				if (netif_msg_link(pGmac))
+					pr_warning("%s: Speed (%d) is not 10"
+				       " or 100!\n", ndev->name, phydev->speed);
+				break;
+			}
+
+			pGmac->speed = phydev->speed;
+		}
+		writel(ctrl, pGmac->remap_addr + REG_GMAC_CONFIG);
+		if (!pGmac->oldlink)
+		{
+			new_state = 1;
+			pGmac->oldlink = 1;
+		}
+	}
+	else if (pGmac->oldlink)
+	{
+		new_state = 1;
+		pGmac->oldlink = 0;
+		pGmac->speed = 0;
+		pGmac->oldduplex = -1;
+	}
+
+	if (new_state && netif_msg_link(pGmac))
+		phy_print_status(phydev);
+
+	spin_unlock_irqrestore(&pGmac->lock, flags);
+}
+
+
+static inline void fh_gmac_rx_refill(Gmac_Object* pGmac)
+{
+	__u32 rxsize = pGmac->dma_rx_size;
+	int bfsize = pGmac->dma_buf_sz;
+	Gmac_Rx_DMA_Descriptors *desc = pGmac->rx_dma_descriptors;
+
+	for (; pGmac->cur_rx - pGmac->dirty_rx > 0; pGmac->dirty_rx++)
+	{
+		__u32 entry = pGmac->dirty_rx % rxsize;
+		if (likely(pGmac->rx_skbuff[entry] == NULL))
+		{
+			struct sk_buff *skb;
+
+			skb = __skb_dequeue(&pGmac->rx_recycle);
+			if (skb == NULL)
+				skb = netdev_alloc_skb_ip_align(pGmac->ndev, bfsize);
+
+			if (unlikely(skb == NULL))
+				break;
+
+			pGmac->rx_skbuff[entry] = skb;
+			pGmac->rx_skbuff_dma[entry] =
+			    dma_map_single(pGmac->dev, skb->data, bfsize,
+					   DMA_FROM_DEVICE);
+
+			(desc + entry)->desc2.dw = pGmac->rx_skbuff_dma[entry];
+			RX_DBG(KERN_INFO "\trefill entry #%d\n", entry);
+		}
+		wmb();
+		(desc+entry)->desc0.bit.own = 1;
+		wmb();
+	}
+}
+
+static int fh_gmac_rx(Gmac_Object* pGmac, int limit)
+{
+	__u32 rxsize = pGmac->dma_rx_size;
+	__u32 entry = pGmac->cur_rx % rxsize;
+	__u32 next_entry;
+	__u32 count = 0;
+	Gmac_Rx_DMA_Descriptors *desc = pGmac->rx_dma_descriptors + entry;
+	Gmac_Rx_DMA_Descriptors *desc_next;
+
+#ifdef FH_GMAC_RX_DEBUG
+	if (netif_msg_hw(pGmac))
+	{
+		printk(">>> fh_gmac_rx: descriptor ring:\n");
+		GMAC_DMA_DisplayRxDesc(pGmac->rx_dma_descriptors, rxsize);
+	}
+#endif
+	count = 0;
+	while (!desc->desc0.bit.own)
+	{
+		int status;
+
+		if (count >= limit)
+			break;
+
+		count++;
+
+		next_entry = (++pGmac->cur_rx) % rxsize;
+		desc_next = pGmac->rx_dma_descriptors + next_entry;
+		prefetch(desc_next);
+
+		/* read the status of the incoming frame */
+		status = (GMAC_DMA_RxStatus(pGmac, desc));
+		if (unlikely(status == discard_frame))
+		{
+			pGmac->ndev->stats.rx_errors++;
+		}
+		else
+		{
+			struct sk_buff *skb;
+			int frame_len;
+			frame_len = desc->desc0.bit.frame_length;
+			/* ACS is set; GMAC core strips PAD/FCS for IEEE 802.3
+			 * Type frames (LLC/LLC-SNAP) */
+			if (unlikely(status != llc_snap))
+				frame_len -= ETH_FCS_LEN;
+#ifdef FH_GMAC_RX_DEBUG
+			if (frame_len > ETH_FRAME_LEN)
+				pr_debug("\tRX frame size %d, COE status: %d\n",
+					frame_len, status);
+
+			if (netif_msg_hw(pGmac))
+				pr_debug("\tdesc: %p [entry %d] buff=0x%x\n",
+					desc, entry, desc->desc2.dw);
+#endif
+			skb = pGmac->rx_skbuff[entry];
+			if (unlikely(!skb))
+			{
+				pr_err("%s: Inconsistent Rx descriptor chain\n",
+						pGmac->ndev->name);
+				pGmac->ndev->stats.rx_dropped++;
+				break;
+			}
+			prefetch(skb->data - NET_IP_ALIGN);
+			pGmac->rx_skbuff[entry] = NULL;
+
+			skb_put(skb, frame_len);
+			dma_unmap_single(pGmac->dev,
+					pGmac->rx_skbuff_dma[entry],
+					pGmac->dma_buf_sz, DMA_FROM_DEVICE);
+#ifdef FH_GMAC_RX_DEBUG
+			if (netif_msg_pktdata(pGmac))
+			{
+				pr_info(" frame received (%dbytes)", frame_len);
+				print_pkt(skb->data, frame_len);
+			}
+#endif
+			skb->protocol = eth_type_trans(skb, pGmac->ndev);
+
+			if (unlikely(status == csum_none))
+			{
+				/* always for the old mac 10/100 */
+				skb_checksum_none_assert(skb);
+				netif_receive_skb(skb);
+			}
+			else
+			{
+				skb->ip_summed = CHECKSUM_UNNECESSARY;
+				napi_gro_receive(&pGmac->napi, skb);
+			}
+
+			pGmac->ndev->stats.rx_packets++;
+			pGmac->ndev->stats.rx_bytes += frame_len;
+		}
+		entry = next_entry;
+		desc = desc_next;	/* use prefetched values */
+	}
+
+	fh_gmac_rx_refill(pGmac);
+
+	pGmac->stats.rx_pkt_n += count;
+
+	return count;
+}
+
+/* minimum number of free TX descriptors required to wake up TX process */
+#define FH_GMAC_TX_THRESH(x)	(x->dma_tx_size/4)
+
+static inline __u32 gmac_tx_avail(Gmac_Object* pGmac)
+{
+	return pGmac->dirty_tx + pGmac->dma_tx_size - pGmac->cur_tx - 1;
+}
+
+
+
+static void fh_gmac_tx(Gmac_Object* pGmac)
+{
+	__u32 txsize = pGmac->dma_tx_size;
+	while (pGmac->dirty_tx != pGmac->cur_tx)
+	{
+		int last;
+		__u32 entry = pGmac->dirty_tx % txsize;
+		struct sk_buff *skb = pGmac->tx_skbuff[entry];
+		Gmac_Tx_DMA_Descriptors *desc = pGmac->tx_dma_descriptors + entry;
+
+		/* Check if the descriptor is owned by the DMA. */
+		if (desc->desc0.bit.own)
+			break;
+
+		/* Verify tx error by looking at the last segment */
+		last = desc->desc1.bit.last_segment;
+		if (likely(last))
+		{
+			int tx_error = GMAC_DMA_TxStatus(pGmac, desc);
+			if (likely(tx_error == 0))
+			{
+				pGmac->ndev->stats.tx_packets++;
+				pGmac->stats.tx_pkt_n++;
+			}
+			else
+			{
+				pGmac->ndev->stats.tx_errors++;
+			}
+		}
+		TX_DBG("%s: curr %d, dirty %d\n", __func__,
+				pGmac->cur_tx, pGmac->dirty_tx);
+
+		if (likely(desc->desc2.dw))
+		{
+			dma_unmap_single(pGmac->dev, desc->desc2.dw, desc->desc1.bit.buffer1_size,
+					 DMA_TO_DEVICE);
+		}
+		if (unlikely(desc->desc3.dw))
+		{
+			desc->desc3.dw = 0;
+		}
+
+		if (likely(skb != NULL))
+		{
+			/*
+			 * If there's room in the queue (limit it to size)
+			 * we add this skb back into the pool,
+			 * if it's the right size.
+			 */
+			if ((skb_queue_len(&pGmac->rx_recycle) < pGmac->dma_rx_size)
+					&&
+				skb_recycle_check(skb, pGmac->dma_buf_sz))
+			{
+				__skb_queue_head(&pGmac->rx_recycle, skb);
+			}
+			else
+			{
+				dev_kfree_skb(skb);
+			}
+
+			pGmac->tx_skbuff[entry] = NULL;
+		}
+		GMAC_DMA_ReleaseTxDesc(desc);
+
+		entry = (++pGmac->dirty_tx) % txsize;
+	}
+	if (unlikely(netif_queue_stopped(pGmac->ndev) &&
+		     gmac_tx_avail(pGmac) > FH_GMAC_TX_THRESH(pGmac)))
+	{
+		netif_tx_lock(pGmac->ndev);
+		if (netif_queue_stopped(pGmac->ndev) &&
+				gmac_tx_avail(pGmac) > FH_GMAC_TX_THRESH(pGmac))
+		{
+			TX_DBG("%s: restart transmit\n", __func__);
+			netif_wake_queue(pGmac->ndev);
+		}
+		netif_tx_unlock(pGmac->ndev);
+	}
+}
+
+
+static int fh_gmac_poll(struct napi_struct *napi, int budget)
+{
+	Gmac_Object* pGmac = container_of(napi, Gmac_Object, napi);
+	int work_done = 0;
+
+	pGmac->stats.poll_n++;
+	fh_gmac_tx(pGmac);
+	work_done = fh_gmac_rx(pGmac, budget);
+
+	if (work_done < budget)
+	{
+		napi_complete(napi);
+		writel(0x1a061, pGmac->remap_addr + REG_GMAC_INTR_EN);
+	}
+	return work_done;
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/* Polling receive - used by NETCONSOLE and other diagnostic tools
+ * to allow network I/O with interrupts disabled. */
+static void gmac_poll_controller(struct net_device *ndev)
+{
+	disable_irq(ndev->irq);
+	fh_gmac_interrupt(ndev->irq, ndev);
+	enable_irq(ndev->irq);
+}
+#endif
+
+
+static __u32 gmac_handle_jumbo_frames(struct sk_buff *skb, struct net_device *dev, int checksum_insertion)
+{
+	//FIXME: 8K jumbo frame
+	Gmac_Object* pGmac = netdev_priv(dev);
+	__u32 nopaged_len = skb_headlen(skb);
+	__u32 txsize = pGmac->dma_tx_size;
+	__u32 entry = pGmac->cur_tx % txsize;
+	Gmac_Tx_DMA_Descriptors *desc = pGmac->tx_dma_descriptors + entry;
+
+	if (nopaged_len > BUFFER_SIZE_2K)
+	{
+
+		int buf2_size = nopaged_len - BUFFER_SIZE_2K + 1;
+
+		desc->desc2.dw = dma_map_single(pGmac->dev, skb->data,
+					BUFFER_SIZE_2K, DMA_TO_DEVICE);
+		desc->desc3.dw = desc->desc2.dw + BUFFER_SIZE_2K;
+		desc->desc1.bit.first_segment = 1;
+		desc->desc1.bit.buffer1_size = BUFFER_SIZE_2K - 1;
+		desc->desc1.bit.checksum_insertion_ctrl = 3;
+		entry = (++pGmac->cur_tx) % txsize;
+		desc = pGmac->tx_dma_descriptors + entry;
+		desc->desc2.dw = dma_map_single(pGmac->dev,
+					skb->data + BUFFER_SIZE_2K,
+					buf2_size, DMA_TO_DEVICE);
+		desc->desc3.dw = desc->desc2.dw + BUFFER_SIZE_2K;
+		desc->desc1.bit.first_segment = 0;
+		desc->desc1.bit.buffer1_size = buf2_size;
+		desc->desc1.bit.checksum_insertion_ctrl = checksum_insertion;
+		desc->desc0.bit.own = 1;
+		pGmac->tx_skbuff[entry] = NULL;
+	}
+	else
+	{
+		desc->desc2.dw = dma_map_single(pGmac->dev, skb->data,
+					nopaged_len, DMA_TO_DEVICE);
+		desc->desc3.dw = desc->desc2.dw + BUFFER_SIZE_2K;
+		desc->desc1.bit.first_segment = 1;
+		desc->desc1.bit.buffer1_size = nopaged_len;
+		desc->desc1.bit.checksum_insertion_ctrl = checksum_insertion;
+	}
+	return entry;
+}
+
+/* Configuration changes (passed on by ifconfig) */
+static int gmac_dev_set_config(struct net_device *ndev, struct ifmap *map)
+{
+	if (ndev->flags & IFF_UP)	/* can't act on a running interface */
+		return -EBUSY;
+
+	/* Don't allow changing the I/O address */
+	if (map->base_addr != ndev->base_addr) {
+		pr_warning("%s: can't change I/O address\n", ndev->name);
+		return -EOPNOTSUPP;
+	}
+
+	/* Don't allow changing the IRQ */
+	if (map->irq != ndev->irq) {
+		pr_warning("%s: can't change IRQ number %d\n",
+				ndev->name, ndev->irq);
+		return -EOPNOTSUPP;
+	}
+
+	/* ignore other fields */
+	return 0;
+}
+
+
+static int gmac_dev_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	Gmac_Object* pGmac = netdev_priv(ndev);
+	__u32 txsize = pGmac->dma_tx_size;
+	__u32 entry;
+	int i, csum_insertion = 0;
+	int nfrags = skb_shinfo(skb)->nr_frags;
+	Gmac_Tx_DMA_Descriptors *desc, *first;
+
+	if (unlikely(gmac_tx_avail(pGmac) < nfrags + 1))
+	{
+		if (!netif_queue_stopped(ndev))
+		{
+			netif_stop_queue(ndev);
+			/* This is a hard error, log it. */
+			pr_err("%s: BUG! Tx Ring full when queue awake\n",
+				__func__);
+		}
+		return NETDEV_TX_BUSY;
+	}
+
+	entry = pGmac->cur_tx % txsize;
+	//fixme: debug
+
+#ifdef FH_GMAC_XMIT_DEBUG
+	if ((skb->len > ETH_FRAME_LEN) || nfrags)
+		pr_info("fh gmac xmit:\n"
+			   "\tskb addr %p - len: %d - nopaged_len: %d\n"
+			   "\tn_frags: %d - ip_summed: %d - %s gso\n",
+			   skb, skb->len, skb_headlen(skb), nfrags, skb->ip_summed,
+			   !skb_is_gso(skb) ? "isn't" : "is");
+#endif
+
+	csum_insertion = (skb->ip_summed == CHECKSUM_PARTIAL)? 3 : 0;
+
+	desc = pGmac->tx_dma_descriptors + entry;
+	first = desc;
+
+#ifdef FH_GMAC_XMIT_DEBUG
+	if ((nfrags > 0) || (skb->len > ETH_FRAME_LEN))
+		pr_debug("stmmac xmit: skb len: %d, nopaged_len: %d,\n"
+			   "\t\tn_frags: %d, ip_summed: %d\n",
+			   skb->len, skb_headlen(skb), nfrags, skb->ip_summed);
+#endif
+	pGmac->tx_skbuff[entry] = skb;
+	if (unlikely(skb->len >= BUFFER_SIZE_2K))
+	{
+		printk("jumbo_frames detected\n");
+		entry = gmac_handle_jumbo_frames(skb, ndev, csum_insertion);
+		desc = pGmac->tx_dma_descriptors + entry;
+	}
+	else
+	{
+		__u32 nopaged_len = skb_headlen(skb);
+		desc->desc2.dw = dma_map_single(pGmac->dev, skb->data,
+					nopaged_len, DMA_TO_DEVICE);
+		desc->desc1.bit.first_segment = 1;
+		desc->desc1.bit.buffer1_size = nopaged_len;
+		desc->desc1.bit.checksum_insertion_ctrl = csum_insertion;
+	}
+
+	for (i = 0; i < nfrags; i++)
+	{
+		const skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
+		int len = frag->size;
+
+		entry = (++pGmac->cur_tx) % txsize;
+		desc = pGmac->tx_dma_descriptors + entry;
+
+		TX_DBG("\t[entry %d] segment len: %d\n", entry, len);
+		desc->desc2.dw = dma_map_page(pGmac->dev, frag->page,
+					  frag->page_offset,
+					  len, DMA_TO_DEVICE);
+		pGmac->tx_skbuff[entry] = NULL;
+		desc->desc1.bit.first_segment = 0;
+		desc->desc1.bit.buffer1_size = len;
+		wmb();
+		desc->desc1.bit.checksum_insertion_ctrl = csum_insertion;
+		desc->desc0.bit.own = 1;
+		wmb();
+	}
+
+	/* Interrupt on completition only for the latest segment */
+	desc->desc1.bit.last_segment = 1;
+	desc->desc1.bit.intr_on_completion = 1;
+	wmb();
+#ifdef CONFIG_STMMAC_TIMER
+	/* Clean IC while using timer */
+	if (likely(priv->tm->enable))
+		priv->hw->desc->clear_tx_ic(desc);
+#endif
+	/* To avoid raise condition */
+	first->desc0.bit.own = 1;
+	wmb();
+	pGmac->cur_tx++;
+
+#ifdef FH_GMAC_XMIT_DEBUG
+	if (netif_msg_pktdata(pGmac))
+	{
+		pr_info("fh gmac xmit: current=%d, dirty=%d, entry=%d, "
+			   "first=%p, nfrags=%d\n",
+			   (pGmac->cur_tx % txsize), (pGmac->dirty_tx % txsize),
+			   entry, first, nfrags);
+		GMAC_DMA_DisplayTxDesc(pGmac->tx_dma_descriptors, 3);
+		pr_info(">>> frame to be transmitted: ");
+		print_pkt(skb->data, skb->len);
+	}
+#endif
+	if (unlikely(gmac_tx_avail(pGmac) <= (MAX_SKB_FRAGS + 1)))
+	{
+		TX_DBG("%s: stop transmitted packets\n", __func__);
+		netif_stop_queue(ndev);
+	}
+
+	ndev->stats.tx_bytes += skb->len;
+	writel(0x1, pGmac->remap_addr + REG_GMAC_TX_POLL_DEMAND);
+
+	return NETDEV_TX_OK;
+}
+
+static void gmac_dev_tx_timeout(struct net_device *ndev)
+{
+	Gmac_Object *pGmac = netdev_priv(ndev);
+	gmac_tx_err(pGmac);
+}
+
+static int gmac_dev_change_mtu(struct net_device *ndev, int new_mtu)
+{
+	int max_mtu;
+
+	if (netif_running(ndev))
+	{
+		pr_err("%s: must be stopped to change its MTU\n", ndev->name);
+		return -EBUSY;
+	}
+
+	max_mtu = ETH_DATA_LEN;
+
+	if ((new_mtu < 46) || (new_mtu > max_mtu))
+	{
+		pr_err("%s: invalid MTU, max MTU is: %d\n", ndev->name, max_mtu);
+		return -EINVAL;
+	}
+
+	ndev->mtu = new_mtu;
+	netdev_update_features(ndev);
+
+	return 0;
+}
+
+
+static void gmac_set_filter(struct net_device *ndev)
+{
+	Gmac_Object* pGmac = netdev_priv(ndev);
+	__u32 value = readl(pGmac->remap_addr + REG_GMAC_FRAME_FILTER);
+
+	if (ndev->flags & IFF_PROMISC)
+	{
+		//enable Promiscuous Mode
+		value = 0x1;
+	}
+	else if ((netdev_mc_count(ndev) > 64)	//HASH_TABLE_SIZE = 64
+		   || (ndev->flags & IFF_ALLMULTI))
+	{
+		//enable Pass All Multicast
+		value = 0x10;
+
+		writel(0xffffffff, pGmac->remap_addr + REG_GMAC_HASH_HIGH);
+		writel(0xffffffff, pGmac->remap_addr + REG_GMAC_HASH_LOW);
+	}
+	else if (netdev_mc_empty(ndev))
+	{	/* no multicast */
+		value = 0;
+	}
+	else
+	{
+		__u32 mc_filter[2];
+		struct netdev_hw_addr *ha;
+
+		/* Perfect filter mode for physical address and Hash
+		   filter for multicast */
+		value = 0x404;
+
+		memset(mc_filter, 0, sizeof(mc_filter));
+		netdev_for_each_mc_addr(ha, ndev)
+		{
+			/* The upper 6 bits of the calculated CRC are used to
+			 * index the contens of the hash table */
+			int bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;
+
+			/* The most significant bit determines the register to
+			 * use (H/L) while the other 5 bits determine the bit
+			 * within the register. */
+			mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
+		}
+		writel(GMAC_BitReverse(mc_filter[0]), pGmac->remap_addr + REG_GMAC_HASH_HIGH);
+		writel(GMAC_BitReverse(mc_filter[1]), pGmac->remap_addr + REG_GMAC_HASH_LOW);
+	}
+	writel(value, pGmac->remap_addr + REG_GMAC_FRAME_FILTER);
+}
+
+static void gmac_dev_mcast_set(struct net_device *ndev)
+{
+	Gmac_Object* pGmac = netdev_priv(ndev);
+
+	spin_lock(&pGmac->lock);
+	gmac_set_filter(ndev);
+	spin_unlock(&pGmac->lock);
+}
+
+static int gmac_dev_ioctl(struct net_device *ndev, struct ifreq *ifrq, int cmd)
+{
+	Gmac_Object* pGmac = netdev_priv(ndev);
+	int ret;
+
+	if (!netif_running(ndev))
+		return -EINVAL;
+
+	if (!pGmac->phydev)
+		return -EINVAL;
+
+	ret = phy_mii_ioctl(pGmac->phydev, ifrq, cmd);
+
+	return ret;
+
+}
+
+
+
+static int fh_gmac_init_phy(struct net_device *ndev)
+{
+	Gmac_Object *pGmac = netdev_priv(ndev);
+	struct phy_device *phydev;
+	char phy_id[MII_BUS_ID_SIZE + 3];
+	char bus_id[MII_BUS_ID_SIZE];
+
+	if (pGmac->phydev == NULL)
+		return -ENODEV;
+
+	snprintf(bus_id, MII_BUS_ID_SIZE, "%x", 0);
+	snprintf(phy_id, MII_BUS_ID_SIZE + 3, PHY_ID_FMT, bus_id, pGmac->priv_data->phyid);
+	pr_debug("fh_gmac_init_phy:  trying to attach to %s\n", phy_id);
+
+	phydev = phy_connect(ndev, phy_id, &fh_gmac_adjust_link, 0,
+			pGmac->phy_interface);
+
+	if (IS_ERR(phydev))
+	{
+		pr_err("%s: Could not attach to PHY\n", ndev->name);
+		return PTR_ERR(phydev);
+	}
+
+	phydev->advertising &= ~(SUPPORTED_1000baseT_Half | SUPPORTED_1000baseT_Full);
+
+
+	//FIXME: phy_id == 0
+	/*
+	 * Broken HW is sometimes missing the pull-up resistor on the
+	 * MDIO line, which results in reads to non-existent devices returning
+	 * 0 rather than 0xffff. Catch this here and treat 0 as a non-existent
+	 * device as well.
+	 * Note: phydev->phy_id is the result of reading the UID PHY registers.
+	 */
+	if (phydev->phy_id == 0)
+	{
+		phy_disconnect(phydev);
+		return -ENODEV;
+	}
+	pr_debug("fh_gmac_init_phy:  %s: attached to PHY (UID 0x%x)"
+	       " Link = %d\n", ndev->name, phydev->phy_id, phydev->link);
+
+	return 0;
+}
+
+
+static int gmac_dev_open(struct net_device *ndev)
+{
+	Gmac_Object* pGmac = netdev_priv(ndev);
+	int ret;
+
+	fh_gmac_verify_args();
+
+	/* MDIO bus Registration */
+	ret = fh_mdio_register(ndev);
+	if (ret < 0)
+	{
+		goto open_error;
+	}
+
+	ret = fh_gmac_init_phy(ndev);
+	if (unlikely(ret))
+	{
+		pr_err("%s: Cannot attach to PHY (error: %d)\n", __func__, ret);
+		goto open_error;
+	}
+	/* Create and initialize the TX/RX descriptors chains. */
+	//FIXME: STMMAC_ALIGN(buf_sz);
+	pGmac->dma_tx_size = dma_txsize;
+	pGmac->dma_rx_size = dma_rxsize;
+	pGmac->dma_buf_sz = BUFFER_SIZE_2K;
+
+	GMAC_DMA_InitDescRings(ndev);
+	/* DMA initialization and SW reset */
+	ret = GMAC_DMA_Init(ndev, pGmac->tx_bus_addr, pGmac->rx_bus_addr);
+	if (ret < 0)
+	{
+		pr_err("%s: DMA initialization failed\n", __func__);
+		goto open_error;
+	}
+
+	/* Copy the MAC addr into the HW  */
+	GMAC_SetMacAddress(pGmac);
+
+	/* Initialize the MAC Core */
+	GMAC_CoreInit(pGmac);
+
+	netdev_update_features(ndev);
+
+	/* Request the IRQ lines */
+	ret = request_irq(ndev->irq, fh_gmac_interrupt, IRQF_SHARED, ndev->name, ndev);
+	if (unlikely(ret < 0))
+	{
+		pr_err("%s: ERROR: allocating the IRQ %d (error: %d)\n",
+			   __func__, ndev->irq, ret);
+		goto open_error;
+	}
+
+	/* Enable the MAC Rx/Tx */
+	GMAC_EnableMac(pGmac);
+
+	/* Set the HW DMA mode and the COE */
+	//FIXME:TTC or SF
+	GMAC_DMA_OpMode(pGmac);
+
+	/* Extra statistics */
+	memset(&pGmac->stats, 0, sizeof(struct Gmac_Stats));
+	//FIXME: threshold?
+	pGmac->stats.threshold = 64;
+
+	/* Start the ball rolling... */
+	pr_debug("%s: DMA RX/TX processes started...\n", ndev->name);
+	GMAC_DMA_StartTx(pGmac);
+	GMAC_DMA_StartRx(pGmac);
+	//FIXME: dump register
+
+	if (pGmac->phydev)
+		phy_start(pGmac->phydev);
+
+	napi_enable(&pGmac->napi);
+	skb_queue_head_init(&pGmac->rx_recycle);
+	netif_start_queue(ndev);
+
+	return 0;
+
+open_error:
+	if (pGmac->phydev)
+		phy_disconnect(pGmac->phydev);
+
+	return ret;
+
+}
+
+static int gmac_dev_stop(struct net_device *ndev)
+{
+
+	Gmac_Object* pGmac = netdev_priv(ndev);
+
+	/* Stop and disconnect the PHY */
+	if (pGmac->phydev)
+	{
+		phy_stop(pGmac->phydev);
+		phy_disconnect(pGmac->phydev);
+		pGmac->phydev = NULL;
+
+		pGmac->oldduplex = 0;
+		pGmac->speed = 0;
+	}
+
+	netif_stop_queue(ndev);
+
+	napi_disable(&pGmac->napi);
+	skb_queue_purge(&pGmac->rx_recycle);
+
+	/* Free the IRQ lines */
+	free_irq(ndev->irq, ndev);
+
+	/* Stop TX/RX DMA and clear the descriptors */
+	GMAC_DMA_StopTx(pGmac);
+	GMAC_DMA_StopRx(pGmac);
+
+	/* Release and free the Rx/Tx resources */
+	GMAC_DMA_FreeDesc(pGmac);
+
+	/* Disable the MAC Rx/Tx */
+	GMAC_DisableMac(pGmac);
+
+	netif_carrier_off(ndev);
+
+	fh_mdio_unregister(ndev);
+
+	return 0;
+}
+
+
+static const struct net_device_ops fh_gmac_netdev_ops =
+{
+	.ndo_open			= gmac_dev_open,
+	.ndo_stop			= gmac_dev_stop,
+	.ndo_start_xmit			= gmac_dev_xmit,
+	.ndo_set_multicast_list		= gmac_dev_mcast_set,
+	.ndo_set_mac_address		= gmac_dev_set_mac_addr,
+	.ndo_do_ioctl			= gmac_dev_ioctl,
+	.ndo_tx_timeout			= gmac_dev_tx_timeout,
+	.ndo_change_mtu 		= gmac_dev_change_mtu,
+	.ndo_fix_features 		= NULL,
+	.ndo_set_config 		= gmac_dev_set_config,
+#ifdef STMMAC_VLAN_TAG_USED
+	.ndo_vlan_rx_register		= stmmac_vlan_rx_register,
+#endif
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller		= gmac_poll_controller,
+#endif
+};
+
+
+static int __devinit fh_gmac_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	Gmac_Object *pGmac;
+	struct net_device *ndev;
+	struct resource *mem_res, *irq_res;
+	struct fh_gmac_platform_data *plat_data;
+
+	pr_info("GMAC driver:\n\tplatform registration... ");
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem_res)
+	{
+		pr_err("%s: ERROR: getting resource failed"
+		       "cannot get IORESOURCE_MEM\n",
+		       __func__);
+		return -ENODEV;
+	}
+
+	if (!request_mem_region(mem_res->start, resource_size(mem_res), pdev->name))
+	{
+		pr_err("%s: ERROR: memory allocation failed"
+		       "cannot get the I/O addr 0x%x\n",
+		       __func__, (__u32)mem_res->start);
+		return -EBUSY;
+	}
+
+	ndev = alloc_etherdev(sizeof(Gmac_Object));
+
+	if (!ndev)
+	{
+		pr_err("%s: ERROR: allocating the device\n", __func__);
+		ret = -ENOMEM;
+		goto out_release_region;
+	}
+
+	irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!irq_res)
+	{
+		pr_err("%s: ERROR: getting resource failed"
+		       "cannot get IORESOURCE_IRQ\n", __func__);
+		ret = -ENXIO;
+		goto out_free_ndev;
+	}
+	ndev->irq = irq_res->start;
+
+	pGmac = netdev_priv(ndev);
+
+	pGmac->remap_addr = ioremap(mem_res->start, resource_size(mem_res));
+
+	if (!pGmac->remap_addr)
+	{
+		pr_err("%s: ERROR: memory mapping failed\n", __func__);
+		ret = -ENOMEM;
+		goto out_free_ndev;
+	}
+
+	pGmac->clk = clk_get(&pdev->dev, "eth_clk");
+	if (IS_ERR(pGmac->clk))
+	{
+		ret = PTR_ERR(pGmac->clk);
+		goto out_unmap;
+	}
+
+	clk_enable(pGmac->clk);
+	/* add net_device to platform_device */
+	SET_NETDEV_DEV(ndev, &pdev->dev);
+
+	pGmac->dev = &(pdev->dev);
+	pGmac->pdev = pdev;
+	pGmac->ndev = ndev;
+	plat_data = pdev->dev.platform_data;
+	pGmac->priv_data = plat_data;
+
+	platform_set_drvdata(pdev, ndev);
+	ndev->base_addr = (unsigned long)pGmac->remap_addr;
+
+	ether_setup(ndev);
+	ndev->netdev_ops = &fh_gmac_netdev_ops;
+	fh_gmac_set_ethtool_ops(ndev);
+
+	ndev->hw_features = NETIF_F_SG | NETIF_F_ALL_CSUM | NETIF_F_RXCSUM;
+	ndev->features |= ndev->hw_features | NETIF_F_HIGHDMA;
+	ndev->watchdog_timeo = msecs_to_jiffies(watchdog);
+	pGmac->msg_enable = netif_msg_init(debug, FH_GMAC_DEBUG);
+
+
+	if (flow_ctrl)
+	{
+		pGmac->flow_ctrl = FLOW_AUTO;	/* RX/TX pause on */
+	}
+
+	pGmac->pause = pause;
+
+
+	netif_napi_add(ndev, &(pGmac->napi), fh_gmac_poll, 64);
+
+
+	if (!is_valid_ether_addr(pGmac->local_mac_address))
+	{
+		/* Use random MAC if none passed */
+		random_ether_addr(pGmac->local_mac_address);
+		pr_warning("\tusing random MAC address: %pM\n", pGmac->local_mac_address);
+	}
+	ndev->dev_addr = pGmac->local_mac_address;
+
+	spin_lock_init(&pGmac->lock);
+
+	ret = register_netdev(ndev);
+	if (ret)
+	{
+		pr_err("%s: ERROR %i registering the netdevice\n", __func__, ret);
+		ret = -ENODEV;
+		goto out_plat_exit;
+	}
+
+	pr_info("\t%s - (dev. name: %s - id: %d, IRQ #%d\n"
+		   "\t\tIO base addr: 0x%p)\n", ndev->name, pdev->name,
+		   pdev->id, ndev->irq, pGmac->remap_addr);
+
+	plat_data->interface = pGmac->phy_interface = phymode;
+
+	/* Custom initialisation */
+	if (pGmac->priv_data->early_init)
+	{
+		pGmac->priv_data->early_init(plat_data);
+	}
+
+	if (pGmac->priv_data->plat_init)
+	{
+		pGmac->priv_data->plat_init(plat_data);
+	}
+
+
+	return 0;
+
+out_plat_exit:
+	clk_disable(pGmac->clk);
+out_unmap:
+	iounmap(pGmac->remap_addr);
+out_free_ndev:
+	free_netdev(ndev);
+	platform_set_drvdata(pdev, NULL);
+out_release_region:
+	release_mem_region(mem_res->start, resource_size(mem_res));
+
+	return ret;
+}
+
+static int __init parse_tag_phymode(const struct tag *tag)
+{
+    phymode = tag->u.phymode.phymode;
+    return 0;
+}
+
+__tagtable(ATAG_PHYMODE, parse_tag_phymode);
+
+static int __devexit fh_gmac_remove(struct platform_device *pdev)
+{
+
+	struct net_device* ndev = platform_get_drvdata(pdev);
+	Gmac_Object* pGmac = netdev_priv(ndev);
+	struct resource* res;
+
+	pr_info("%s:\n\tremoving driver", __func__);
+
+	GMAC_DMA_StopTx(pGmac);
+	GMAC_DMA_StopRx(pGmac);
+
+	GMAC_DisableMac(pGmac);
+
+	netif_carrier_off(ndev);
+
+	platform_set_drvdata(pdev, NULL);
+	unregister_netdev(ndev);
+
+	clk_disable(pGmac->clk);
+
+	iounmap((void *)pGmac->remap_addr);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, resource_size(res));
+	free_netdev(ndev);
+
+	return 0;
+}
+
+
+#ifdef CONFIG_PM
+static int fh_gmac_suspend(struct device *dev)
+{
+	struct net_device *ndev = dev_get_drvdata(dev);
+	Gmac_Object* pGmac = netdev_priv(ndev);
+
+	if (!ndev || !netif_running(ndev))
+		return 0;
+
+	spin_lock(&pGmac->lock);
+
+	netif_device_detach(ndev);
+	netif_stop_queue(ndev);
+	if (pGmac->phydev)
+		phy_stop(pGmac->phydev);
+
+	napi_disable(&pGmac->napi);
+
+	/* Stop TX/RX DMA */
+	GMAC_DMA_StopTx(pGmac);
+	GMAC_DMA_StopRx(pGmac);
+	/* Clear the Rx/Tx descriptors */
+	GMAC_DMA_InitRxDesc(pGmac->rx_dma_descriptors, pGmac->dma_rx_size);
+	GMAC_DMA_InitTxDesc(pGmac->tx_dma_descriptors, pGmac->dma_tx_size);
+
+	/* Enable Power down mode by programming the PMT regs */
+	if (device_may_wakeup(pGmac->dev))
+	{
+		//priv->hw->mac->pmt(priv->ioaddr, priv->wolopts);
+	}
+	else
+	{
+		GMAC_DisableMac(pGmac);
+	}
+
+	spin_unlock(&pGmac->lock);
+	return 0;
+}
+
+static int fh_gmac_resume(struct device *dev)
+{
+	struct net_device *ndev = dev_get_drvdata(dev);
+	Gmac_Object* pGmac = netdev_priv(ndev);
+	u32 reg;
+
+	reg = pGmac->mii->read(pGmac->mii, 0, 0);
+	reg |= 1 << 15;
+	pGmac->mii->write(pGmac->mii, 0, 0, reg);
+
+	pGmac->mii->reset(pGmac->mii);
+
+	if (!netif_running(ndev))
+		return 0;
+
+	spin_lock(&pGmac->lock);
+
+	/* Power Down bit, into the PM register, is cleared
+	 * automatically as soon as a magic packet or a Wake-up frame
+	 * is received. Anyway, it's better to manually clear
+	 * this bit because it can generate problems while resuming
+	 * from another devices (e.g. serial console). */
+	if (device_may_wakeup(pGmac->dev))
+	{
+		//priv->hw->mac->pmt(priv->ioaddr, 0);
+	}
+
+	netif_device_attach(ndev);
+
+	/* Enable the MAC and DMA */
+	GMAC_EnableMac(pGmac);
+	GMAC_DMA_StartTx(pGmac);
+	GMAC_DMA_StartRx(pGmac);
+
+	napi_enable(&pGmac->napi);
+
+	if (pGmac->phydev)
+		phy_start(pGmac->phydev);
+
+	netif_start_queue(ndev);
+
+	spin_unlock(&pGmac->lock);
+	return 0;
+}
+
+static int fh_gmac_freeze(struct device *dev)
+{
+	struct net_device *ndev = dev_get_drvdata(dev);
+
+	if (!ndev || !netif_running(ndev))
+		return 0;
+
+	return gmac_dev_stop(ndev);
+}
+
+static int fh_gmac_restore(struct device *dev)
+{
+	struct net_device *ndev = dev_get_drvdata(dev);
+
+	if (!ndev || !netif_running(ndev))
+		return 0;
+
+	return gmac_dev_open(ndev);
+}
+
+static const struct dev_pm_ops fh_gmac_pm_ops =
+{
+	.suspend = fh_gmac_suspend,
+	.resume = fh_gmac_resume,
+	.freeze = fh_gmac_freeze,
+	.thaw = fh_gmac_restore,
+	.restore = fh_gmac_restore,
+};
+#else
+static const struct dev_pm_ops fh_gmac_pm_ops;
+#endif /* CONFIG_PM */
+
+
+static struct platform_driver fh_gmac_driver =
+{
+	.driver =
+	{
+		.name	 = "fh_gmac",
+		.owner	 = THIS_MODULE,
+		.pm	 = &fh_gmac_pm_ops,
+	},
+	.probe = fh_gmac_probe,
+	.remove = __devexit_p(fh_gmac_remove),
+};
+
+static int __init fh_gmac_init(void)
+{
+	return platform_driver_register(&fh_gmac_driver);
+}
+late_initcall(fh_gmac_init);
+
+
+static void __exit fh_gmac_exit(void)
+{
+	platform_driver_unregister(&fh_gmac_driver);
+}
+module_exit(fh_gmac_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("QIN");
+MODULE_DESCRIPTION("Fullhan Ethernet driver");
diff -uraN linux-3.0.8/drivers/net/fh_gmac/fh_gmac_phyt.c linux-3.0.8-fh8632-V1.0_20180330/drivers/net/fh_gmac/fh_gmac_phyt.c
--- linux-3.0.8/drivers/net/fh_gmac/fh_gmac_phyt.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/net/fh_gmac/fh_gmac_phyt.c	2021-07-13 23:40:36.058370882 +0300
@@ -0,0 +1,222 @@
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <mach/fh_gmac.h>
+#include "fh_gmac_phyt.h"
+#include "fh_gmac.h"
+
+static int fh_mdio_read(struct mii_bus *bus, int phyaddr, int phyreg)
+{
+	struct net_device *ndev = bus->priv;
+	Gmac_Object *pGmac = netdev_priv(ndev);
+	int timeout = 1000;
+
+	if (phyaddr < 0)
+		return -ENODEV;
+
+	writel(phyaddr << 11 | gmac_gmii_clock_100_150 << 2 | phyreg << 6 | 0x1,
+	       pGmac->remap_addr + REG_GMAC_GMII_ADDRESS);
+
+	while (readl(pGmac->remap_addr + REG_GMAC_GMII_ADDRESS) & 0x1) {
+		udelay(100);
+		timeout--;
+		if (timeout < 0) {
+			printk(KERN_ERR "ERROR: %s, timeout\n", __func__);
+			break;
+		}
+	}
+
+	return readl(pGmac->remap_addr + REG_GMAC_GMII_DATA);
+}
+
+static int fh_mdio_write(struct mii_bus *bus, int phyaddr, int phyreg,
+			 u16 phydata)
+{
+	struct net_device *ndev = bus->priv;
+	Gmac_Object *pGmac = netdev_priv(ndev);
+	int timeout = 1000;
+
+	if (phyaddr < 0)
+		return -ENODEV;
+
+	writel(phydata, pGmac->remap_addr + REG_GMAC_GMII_DATA);
+	writel(0x1 << 1 | phyaddr << 11 | gmac_gmii_clock_100_150 << 2 | phyreg
+	       << 6 | 0x1, pGmac->remap_addr + REG_GMAC_GMII_ADDRESS);
+
+	while (readl(pGmac->remap_addr + REG_GMAC_GMII_ADDRESS) & 0x1) {
+		udelay(100);
+		timeout--;
+		if (timeout < 0) {
+			printk(KERN_ERR "ERROR: %s, timeout\n", __func__);
+			break;
+		}
+	}
+	return 0;
+}
+
+int fh_mdio_reset(struct mii_bus *bus)
+{
+	struct net_device *ndev = bus->priv;
+	Gmac_Object *pGmac = netdev_priv(ndev);
+	struct fh_gmac_platform_data *plat_data;
+
+	plat_data = pGmac->priv_data;
+
+	if (plat_data && plat_data->phy_reset)
+		plat_data->phy_reset();
+
+	return 0;
+}
+
+int fh_mdio_set_mii(struct mii_bus *bus)
+{
+	struct net_device *ndev = bus->priv;
+	Gmac_Object *pGmac = netdev_priv(ndev);
+	__u32 rmii_mode;
+	int phyid = pGmac->priv_data->phyid;
+
+	if (pGmac->phydev == NULL)
+		return -ENODEV;
+
+	if (pGmac->phy_interface == PHY_INTERFACE_MODE_RMII) {
+		switch (pGmac->phydev->phy_id) {
+		case FH_GMAC_PHY_RTL8201:
+			fh_mdio_write(bus, phyid,
+					gmac_phyt_rtl8201_page_select, 7);
+			fh_mdio_write(bus, phyid,
+					gmac_phyt_rtl8201_rmii_mode, 0x1ffa);
+			fh_mdio_write(bus, phyid,
+					gmac_phyt_rtl8201_page_select, 0);
+			break;
+		case FH_GMAC_PHY_IP101G:
+			fh_mdio_write(bus, phyid,
+					gmac_phyt_ip101g_page_select, 16);
+			fh_mdio_write(bus, phyid,
+					gmac_phyt_rtl8201_rmii_mode, 0x1006);
+			fh_mdio_write(bus, phyid,
+					gmac_phyt_ip101g_page_select, 0x10);
+			break;
+		case FH_GMAC_PHY_TI83848:
+			rmii_mode = fh_mdio_read(bus, phyid,
+					gmac_phyt_ti83848_rmii_mode);
+			rmii_mode |= 0x20;
+			fh_mdio_write(bus, phyid,
+					gmac_phyt_ti83848_rmii_mode, rmii_mode);
+			break;
+		default:
+			return -ENODEV;
+		}
+	} else if (pGmac->phy_interface == PHY_INTERFACE_MODE_MII) {
+		switch (pGmac->phydev->phy_id) {
+		case FH_GMAC_PHY_RTL8201:
+			fh_mdio_write(bus, phyid,
+					gmac_phyt_rtl8201_page_select, 7);
+			fh_mdio_write(bus, phyid,
+					gmac_phyt_rtl8201_rmii_mode, 0x6ff3);
+			fh_mdio_write(bus, phyid,
+					gmac_phyt_rtl8201_page_select, 0);
+			break;
+		case FH_GMAC_PHY_IP101G:
+			fh_mdio_write(bus, phyid,
+					gmac_phyt_ip101g_page_select, 16);
+			fh_mdio_write(bus, phyid,
+					gmac_phyt_rtl8201_rmii_mode, 0x2);
+			fh_mdio_write(bus, phyid,
+					gmac_phyt_ip101g_page_select, 0x10);
+			break;
+		case FH_GMAC_PHY_TI83848:
+			rmii_mode = fh_mdio_read(bus, phyid,
+					gmac_phyt_ti83848_rmii_mode);
+			rmii_mode &= ~(0x20);
+			fh_mdio_write(bus, phyid,
+					gmac_phyt_ti83848_rmii_mode, rmii_mode);
+			break;
+		default:
+			return -ENODEV;
+		}
+	}
+
+	return 0;
+}
+
+int fh_mdio_register(struct net_device *ndev)
+{
+	int err = 0, found, addr;
+	struct mii_bus *new_bus;
+	Gmac_Object *pGmac = netdev_priv(ndev);
+	struct phy_device *phydev = NULL;
+
+	new_bus = mdiobus_alloc();
+	if (new_bus == NULL)
+		return -ENOMEM;
+	new_bus->name =
+	    pGmac->phy_interface ==
+	    PHY_INTERFACE_MODE_MII ? "gmac_mii" : "gmac_rmii";
+	new_bus->read = &fh_mdio_read;
+	new_bus->write = &fh_mdio_write;
+	new_bus->reset = &fh_mdio_reset;
+	snprintf(new_bus->id, MII_BUS_ID_SIZE, "%x", 0);
+	new_bus->priv = ndev;
+	new_bus->parent = pGmac->dev;
+	err = mdiobus_register(new_bus);
+	if (err != 0) {
+		pr_err("%s: Cannot register as MDIO bus, error: %d\n",
+		       new_bus->name, err);
+		goto bus_register_fail;
+	}
+
+	pGmac->mii = new_bus;
+
+	found = 0;
+	for (addr = 0; addr < 32; addr++) {
+		phydev = new_bus->phy_map[addr];
+		if (phydev) {
+			if (pGmac->priv_data->phyid == -1)
+				pGmac->priv_data->phyid = addr;
+
+			found = 1;
+			pGmac->phydev = phydev;
+			break;
+		}
+	}
+
+	if (pGmac->mii == NULL || phydev == NULL) {
+		pr_warning("%s: MII BUS or phydev is NULL\n", ndev->name);
+		err = -ENXIO;
+		goto bus_register_fail;
+	}
+
+	err = fh_mdio_set_mii(pGmac->mii);
+
+	if (!found || err) {
+		pr_warning("%s: No PHY found\n", ndev->name);
+		err = -ENXIO;
+		goto bus_register_fail;
+	}
+
+	pr_info("%s: PHY ID %08x at %d IRQ %d (%s)%s\n",
+		ndev->name, pGmac->phydev->phy_id, addr,
+		pGmac->phydev->irq, dev_name(&pGmac->phydev->dev),
+		(addr ==
+		 pGmac->priv_data->phyid) ? " active" : "");
+
+	return 0;
+
+bus_register_fail:
+	pGmac->phydev = NULL;
+	mdiobus_unregister(new_bus);
+	kfree(new_bus);
+	return err;
+}
+
+int fh_mdio_unregister(struct net_device *ndev)
+{
+	Gmac_Object *pGmac = netdev_priv(ndev);
+
+	mdiobus_unregister(pGmac->mii);
+	pGmac->mii->priv = NULL;
+	kfree(pGmac->mii);
+	return 0;
+}
diff -uraN linux-3.0.8/drivers/net/fh_gmac/fh_gmac_phyt.h linux-3.0.8-fh8632-V1.0_20180330/drivers/net/fh_gmac/fh_gmac_phyt.h
--- linux-3.0.8/drivers/net/fh_gmac/fh_gmac_phyt.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/net/fh_gmac/fh_gmac_phyt.h	2021-07-13 23:40:36.058370882 +0300
@@ -0,0 +1,83 @@
+/*
+ * fh_gmac_phyt.h
+ *
+ *  Created on: May 22, 2014
+ *      Author: duobao
+ */
+
+#ifndef FH_GMAC_PHYT_H_
+#define FH_GMAC_PHYT_H_
+
+#define FH_GMAC_PHY_IP101G	0x02430C54
+#define FH_GMAC_PHY_RTL8201	0x001CC816
+#define FH_GMAC_PHY_TI83848	0xFFFFFFFF
+
+enum
+{
+	gmac_phyt_speed_10M_half_duplex = 1,
+	gmac_phyt_speed_100M_half_duplex = 2,
+	gmac_phyt_speed_10M_full_duplex = 5,
+	gmac_phyt_speed_100M_full_duplex = 6
+};
+
+
+typedef union
+{
+	struct
+	{
+		__u32	reserved_6_0					:7;
+		__u32	collision_test					:1;
+		__u32	duplex_mode						:1;
+		__u32	restart_auto_negotiate			:1;
+		__u32	isolate							:1;
+		__u32	power_down						:1;
+		__u32	auto_negotiate_enable			:1;
+		__u32	speed_select					:1;
+		__u32	loopback						:1;
+		__u32	reset							:1;
+		__u32	reserved_31_16					:16;
+	}bit;
+	__u32 dw;
+}Reg_Phyt_Basic_Ctrl;
+
+
+typedef union
+{
+	struct
+	{
+		__u32	extended_capabilities			:1;
+		__u32	jabber_detect					:1;
+		__u32	link_status						:1;
+		__u32	auto_negotiate_ability			:1;
+		__u32	remote_fault					:1;
+		__u32	auto_negotiate_complete			:1;
+		__u32	reserved_10_6					:5;
+		__u32	base_t_half_duplex_10			:1;
+		__u32	base_t_full_duplex_10			:1;
+		__u32	base_tx_half_duplex_100			:1;
+		__u32	base_tx_full_duplex_100			:1;
+		__u32	base_t_4						:1;
+		__u32	reserved_31_16					:16;
+	}bit;
+	__u32 dw;
+}Reg_Phyt_Basic_Status;
+
+typedef union
+{
+	struct
+	{
+		__u32	scramble_disable			:1;
+		__u32	reserved_1					:1;
+		__u32	speed_indication			:3;
+		__u32	reserved_5					:1;
+		__u32	enable_4b5b					:1;
+		__u32	gpo							:3;
+		__u32	reserved_11_10				:2;
+		__u32	auto_done					:1;
+		__u32	reserved_31_13				:19;
+	}bit;
+	__u32 dw;
+}Reg_Phyt_Special_Status;
+
+
+#endif /* FH_GMAC_PHYT_H_ */
diff -uraN linux-3.0.8/drivers/net/fh_gmac/Kconfig linux-3.0.8-fh8632-V1.0_20180330/drivers/net/fh_gmac/Kconfig
--- linux-3.0.8/drivers/net/fh_gmac/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/net/fh_gmac/Kconfig	2021-07-13 23:40:36.058370882 +0300
@@ -0,0 +1,21 @@
+config FH_GMAC
+	tristate "FH 10/100 Ethernet driver"
+	select MII
+	select PHYLIB
+	select CRC32
+	depends on NETDEVICES && HAS_IOMEM
+	help
+	  This is the driver for the Ethernet IPs are built around a
+	  Synopsys IP Core.
+
+if FH_GMAC
+
+config FH_GMAC_DA
+	bool "FH GMAC DMA arbitration scheme"
+	default n
+	help
+	  Selecting this option, rx has priority over Tx (only for Giga
+	  Ethernet device).
+	  By default, the DMA arbitration scheme is based on Round-robin
+	  (rx:tx priority is 1:1).	  
+endif
diff -uraN linux-3.0.8/drivers/net/fh_gmac/Makefile linux-3.0.8-fh8632-V1.0_20180330/drivers/net/fh_gmac/Makefile
--- linux-3.0.8/drivers/net/fh_gmac/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/net/fh_gmac/Makefile	2021-07-13 23:40:36.058370882 +0300
@@ -0,0 +1,5 @@
+
+
+obj-$(CONFIG_FH_GMAC) += fh_gmac.o
+
+fh_gmac-objs := fh_gmac_dma.o fh_gmac_main.o fh_gmac_ethtool.o fh_gmac_phyt.o
diff -uraN linux-3.0.8/drivers/net/Kconfig linux-3.0.8-fh8632-V1.0_20180330/drivers/net/Kconfig
--- linux-3.0.8/drivers/net/Kconfig	2021-07-14 21:52:02.987133925 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/net/Kconfig	2021-07-13 23:40:36.426373057 +0300
@@ -984,6 +984,8 @@
 
 	  To compile this driver as a module, choose M here.  The module
 	  will be called dm9000.
+	  
+source "drivers/net/fh_gmac/Kconfig"
 
 config DM9000_DEBUGLEVEL
 	int "DM9000 maximum debug level"
@@ -2542,6 +2544,7 @@
 
 source "drivers/net/stmmac/Kconfig"
 
+
 config PCH_GBE
 	tristate "Intel EG20T PCH / OKI SEMICONDUCTOR ML7223 IOH GbE"
 	depends on PCI
@@ -3450,4 +3453,6 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called vmxnet3.
 
+
+
 endif # NETDEVICES
diff -uraN linux-3.0.8/drivers/net/Makefile linux-3.0.8-fh8632-V1.0_20180330/drivers/net/Makefile
--- linux-3.0.8/drivers/net/Makefile	2021-07-14 21:52:02.987133925 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/net/Makefile	2021-07-13 23:40:36.010370598 +0300
@@ -254,6 +254,7 @@
 obj-$(CONFIG_PXA168_ETH) += pxa168_eth.o
 obj-$(CONFIG_BFIN_MAC) += bfin_mac.o
 obj-$(CONFIG_DM9000) += dm9000.o
+obj-$(CONFIG_FH_GMAC) += fh_gmac/
 obj-$(CONFIG_PASEMI_MAC) += pasemi_mac_driver.o
 pasemi_mac_driver-objs := pasemi_mac.o pasemi_mac_ethtool.o
 obj-$(CONFIG_MLX4_CORE) += mlx4/
diff -uraN linux-3.0.8/drivers/net/phy/phy_device.c linux-3.0.8-fh8632-V1.0_20180330/drivers/net/phy/phy_device.c
--- linux-3.0.8/drivers/net/phy/phy_device.c	2021-07-14 21:52:03.171134458 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/net/phy/phy_device.c	2021-07-13 23:40:36.062370905 +0300
@@ -845,7 +845,7 @@
 	 * all possible port types */
 	features = (SUPPORTED_TP | SUPPORTED_MII
 			| SUPPORTED_AUI | SUPPORTED_FIBRE |
-			SUPPORTED_BNC);
+			SUPPORTED_BNC | SUPPORTED_Pause);
 
 	/* Do we support autonegotiation? */
 	val = phy_read(phydev, MII_BMSR);
diff -uraN linux-3.0.8/drivers/net/usb/asix.c linux-3.0.8-fh8632-V1.0_20180330/drivers/net/usb/asix.c
--- linux-3.0.8/drivers/net/usb/asix.c	2021-07-14 21:52:03.235134643 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/net/usb/asix.c	2021-07-13 23:40:35.902369947 +0300
@@ -20,8 +20,8 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-// #define	DEBUG			// error path messages, extra info
-// #define	VERBOSE			// more; success messages
+#define	DEBUG			// error path messages, extra info
+#define	VERBOSE			// more; success messages
 
 #include <linux/module.h>
 #include <linux/kmod.h>
@@ -312,14 +312,25 @@
 	packet = head + sizeof(header);
 
 	skb_pull(skb, 4);
-
+	static unsigned int cnt = 0;
+	//printk("%d\t",cnt++);
+	//printk("header :0x%x\n",header);
 	while (skb->len > 0) {
-		if ((short)(header & 0x0000ffff) !=
-		    ~((short)((header & 0xffff0000) >> 16))) {
+
+		if ((header & 0x07ff) != ((~header >> 16) & 0x07ff)){
 			netdev_err(dev->net, "asix_rx_fixup() Bad Header Length\n");
+			return 0;
 		}
+
+
 		/* get the packet length */
-		size = (u16) (header & 0x0000ffff);
+		size = (u16) (header & 0x000007ff);
+		if (size > dev->net->mtu + ETH_HLEN) {
+				netdev_err(dev->net, "asix_rx_fixup() Bad RX Length %d\n",
+					   size);
+				return 0;
+		}
+
 
 		if ((skb->len) - ((size + 1) & 0xfffe) == 0) {
 			u8 alignment = (unsigned long)skb->data & 0x3;
@@ -344,11 +355,7 @@
 			return 2;
 		}
 
-		if (size > dev->net->mtu + ETH_HLEN) {
-			netdev_err(dev->net, "asix_rx_fixup() Bad RX Length %d\n",
-				   size);
-			return 0;
-		}
+
 		ax_skb = skb_clone(skb, GFP_ATOMIC);
 		if (ax_skb) {
 			u8 alignment = (unsigned long)packet & 0x3;
@@ -514,7 +521,7 @@
 static int asix_write_rx_ctl(struct usbnet *dev, u16 mode)
 {
 	int ret;
-
+	//mode = 0x81;
 	netdev_dbg(dev->net, "asix_write_rx_ctl() - mode = 0x%04x\n", mode);
 	ret = asix_write_cmd(dev, AX_CMD_WRITE_RX_CTL, mode, 0, 0, NULL);
 	if (ret < 0)
@@ -562,9 +569,6 @@
 		netdev_err(dev->net, "Failed to write GPIO value 0x%04x: %02x\n",
 			   value, ret);
 
-	if (sleep)
-		msleep(sleep);
-
 	return ret;
 }
 
@@ -894,7 +898,6 @@
 					(gpio_bits >> (i * 8)) & 0xff, 0, 0,
 					NULL)) < 0)
 			goto out;
-		msleep(5);
 	}
 
 	if ((ret = asix_write_rx_ctl(dev, 0x80)) < 0)
@@ -1006,11 +1009,9 @@
 	if ((ret = asix_sw_reset(dev, AX_SWRESET_IPPD | AX_SWRESET_PRL)) < 0)
 		goto out;
 
-	msleep(150);
 	if ((ret = asix_sw_reset(dev, AX_SWRESET_CLEAR)) < 0)
 		goto out;
 
-	msleep(150);
 	if (embd_phy) {
 		if ((ret = asix_sw_reset(dev, AX_SWRESET_IPRL)) < 0)
 			goto out;
@@ -1020,7 +1021,6 @@
 			goto out;
 	}
 
-	msleep(150);
 	rx_ctl = asix_read_rx_ctl(dev);
 	dbg("RX_CTL is 0x%04x after software reset", rx_ctl);
 	if ((ret = asix_write_rx_ctl(dev, 0x0000)) < 0)
@@ -1051,13 +1051,9 @@
 	if ((ret = asix_sw_reset(dev, AX_SWRESET_PRL)) < 0)
 		goto out;
 
-	msleep(150);
-
 	if ((ret = asix_sw_reset(dev, AX_SWRESET_IPRL | AX_SWRESET_PRL)) < 0)
 		goto out;
 
-	msleep(150);
-
 	dev->net->netdev_ops = &ax88772_netdev_ops;
 	dev->net->ethtool_ops = &ax88772_ethtool_ops;
 
@@ -1320,10 +1316,8 @@
 	}
 
 	asix_sw_reset(dev, 0);
-	msleep(150);
 
 	asix_sw_reset(dev, AX_SWRESET_PRL | AX_SWRESET_IPPD);
-	msleep(150);
 
 	asix_write_rx_ctl(dev, 0);
 
@@ -1352,7 +1346,6 @@
 
 	if (data->phymode == PHY_MODE_MARVELL) {
 		marvell_phy_init(dev);
-		msleep(60);
 	}
 
 	asix_mdio_write(dev->net, dev->mii.phy_id, MII_BMCR,
@@ -1428,7 +1421,7 @@
 	.status = asix_status,
 	.link_reset = ax88772_link_reset,
 	.reset = ax88772_link_reset,
-	.flags = FLAG_ETHER | FLAG_FRAMING_AX | FLAG_LINK_INTR,
+	.flags = FLAG_ETHER | FLAG_FRAMING_AX | FLAG_LINK_INTR ,
 	.rx_fixup = asix_rx_fixup,
 	.tx_fixup = asix_tx_fixup,
 };
@@ -1446,123 +1439,144 @@
 
 static const struct usb_device_id	products [] = {
 {
-	// Linksys USB200M
 	USB_DEVICE (0x077b, 0x2226),
 	.driver_info =	(unsigned long) &ax8817x_info,
-}, {
-	// Netgear FA120
+},
+{
 	USB_DEVICE (0x0846, 0x1040),
 	.driver_info =  (unsigned long) &netgear_fa120_info,
-}, {
-	// DLink DUB-E100
+},
+{
 	USB_DEVICE (0x2001, 0x1a00),
 	.driver_info =  (unsigned long) &dlink_dub_e100_info,
-}, {
-	// Intellinet, ST Lab USB Ethernet
+},
+{
 	USB_DEVICE (0x0b95, 0x1720),
 	.driver_info =  (unsigned long) &ax8817x_info,
-}, {
-	// Hawking UF200, TrendNet TU2-ET100
+},
+{
 	USB_DEVICE (0x07b8, 0x420a),
 	.driver_info =  (unsigned long) &hawking_uf200_info,
-}, {
-	// Billionton Systems, USB2AR
+},
+{
 	USB_DEVICE (0x08dd, 0x90ff),
 	.driver_info =  (unsigned long) &ax8817x_info,
-}, {
-	// ATEN UC210T
+},
+{
 	USB_DEVICE (0x0557, 0x2009),
 	.driver_info =  (unsigned long) &ax8817x_info,
-}, {
-	// Buffalo LUA-U2-KTX
+},
+{
+
 	USB_DEVICE (0x0411, 0x003d),
 	.driver_info =  (unsigned long) &ax8817x_info,
-}, {
-	// Buffalo LUA-U2-GT 10/100/1000
+},
+{
+
 	USB_DEVICE (0x0411, 0x006e),
 	.driver_info =  (unsigned long) &ax88178_info,
-}, {
-	// Sitecom LN-029 "USB 2.0 10/100 Ethernet adapter"
+},
+{
+
 	USB_DEVICE (0x6189, 0x182d),
 	.driver_info =  (unsigned long) &ax8817x_info,
-}, {
-	// corega FEther USB2-TX
+},
+{
+
 	USB_DEVICE (0x07aa, 0x0017),
 	.driver_info =  (unsigned long) &ax8817x_info,
-}, {
-	// Surecom EP-1427X-2
+},
+{
+
 	USB_DEVICE (0x1189, 0x0893),
 	.driver_info = (unsigned long) &ax8817x_info,
-}, {
-	// goodway corp usb gwusb2e
+},
+{
+
 	USB_DEVICE (0x1631, 0x6200),
 	.driver_info = (unsigned long) &ax8817x_info,
-}, {
-	// JVC MP-PRX1 Port Replicator
+},
+{
+
 	USB_DEVICE (0x04f1, 0x3008),
 	.driver_info = (unsigned long) &ax8817x_info,
-}, {
-	// ASIX AX88772B 10/100
+},
+{
+
 	USB_DEVICE (0x0b95, 0x772b),
 	.driver_info = (unsigned long) &ax88772_info,
-}, {
-	// ASIX AX88772 10/100
+},
+{
+
 	USB_DEVICE (0x0b95, 0x7720),
 	.driver_info = (unsigned long) &ax88772_info,
-}, {
-	// ASIX AX88178 10/100/1000
+},
+{
+
 	USB_DEVICE (0x0b95, 0x1780),
 	.driver_info = (unsigned long) &ax88178_info,
-}, {
-	// Logitec LAN-GTJ/U2A
+},
+{
+
 	USB_DEVICE (0x0789, 0x0160),
 	.driver_info = (unsigned long) &ax88178_info,
-}, {
-	// Linksys USB200M Rev 2
+},
+{
+
 	USB_DEVICE (0x13b1, 0x0018),
 	.driver_info = (unsigned long) &ax88772_info,
-}, {
-	// 0Q0 cable ethernet
+},
+{
+
 	USB_DEVICE (0x1557, 0x7720),
 	.driver_info = (unsigned long) &ax88772_info,
-}, {
-	// DLink DUB-E100 H/W Ver B1
+},
+{
+
 	USB_DEVICE (0x07d1, 0x3c05),
 	.driver_info = (unsigned long) &ax88772_info,
-}, {
-	// DLink DUB-E100 H/W Ver B1 Alternate
+},
+{
+
 	USB_DEVICE (0x2001, 0x3c05),
 	.driver_info = (unsigned long) &ax88772_info,
-}, {
-	// Linksys USB1000
+},
+{
+
 	USB_DEVICE (0x1737, 0x0039),
 	.driver_info = (unsigned long) &ax88178_info,
-}, {
-	// IO-DATA ETG-US2
+},
+{
+
 	USB_DEVICE (0x04bb, 0x0930),
 	.driver_info = (unsigned long) &ax88178_info,
-}, {
-	// Belkin F5D5055
+},
+{
+
 	USB_DEVICE(0x050d, 0x5055),
 	.driver_info = (unsigned long) &ax88178_info,
-}, {
-	// Apple USB Ethernet Adapter
+},
+{
+
 	USB_DEVICE(0x05ac, 0x1402),
 	.driver_info = (unsigned long) &ax88772_info,
-}, {
-	// Cables-to-Go USB Ethernet Adapter
+},
+{
+
 	USB_DEVICE(0x0b95, 0x772a),
 	.driver_info = (unsigned long) &ax88772_info,
-}, {
-	// ABOCOM for pci
+},
+{
+
 	USB_DEVICE(0x14ea, 0xab11),
 	.driver_info = (unsigned long) &ax88178_info,
-}, {
-	// ASIX 88772a
+},
+{
+
 	USB_DEVICE(0x0db0, 0xa877),
 	.driver_info = (unsigned long) &ax88772_info,
 },
-	{ },		// END
+	{ },
 };
 MODULE_DEVICE_TABLE(usb, products);
 
diff -uraN linux-3.0.8/drivers/net/usb/usbnet.c linux-3.0.8-fh8632-V1.0_20180330/drivers/net/usb/usbnet.c
--- linux-3.0.8/drivers/net/usb/usbnet.c	2021-07-14 21:52:03.243134666 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/net/usb/usbnet.c	2021-07-13 23:40:35.898369924 +0300
@@ -64,19 +64,21 @@
  * is required, under load.  Jumbograms change the equation.
  */
 #define RX_MAX_QUEUE_MEMORY (60 * 1518)
-#define	RX_QLEN(dev) (((dev)->udev->speed == USB_SPEED_HIGH) ? \
-			(RX_MAX_QUEUE_MEMORY/(dev)->rx_urb_size) : 4)
+#if(0)
+//#define	RX_QLEN(dev) (((dev)->udev->speed == USB_SPEED_HIGH) ? \
+//			(RX_MAX_QUEUE_MEMORY/(dev)->rx_urb_size) : 4)
+//#define	RX_QLEN(dev)
+#endif
+#define	RX_QLEN(dev)	5
 #define	TX_QLEN(dev) (((dev)->udev->speed == USB_SPEED_HIGH) ? \
 			(RX_MAX_QUEUE_MEMORY/(dev)->hard_mtu) : 4)
 
-// reawaken network queue this soon after stopping; else watchdog barks
+
 #define TX_TIMEOUT_JIFFIES	(5*HZ)
 
-// throttle rx/tx briefly after some faults, so khubd might disconnect()
-// us (it polls at HZ/4 usually) before we report too many false errors.
+
 #define THROTTLE_JIFFIES	(HZ/8)
 
-// between wakeups
 #define UNLINK_TIMEOUT_MS	3
 
 /*-------------------------------------------------------------------------*/
@@ -92,7 +94,7 @@
 MODULE_PARM_DESC (msg_level, "Override default message level");
 
 /*-------------------------------------------------------------------------*/
-
+static void usbnet_bh (unsigned long param);
 /* handles CDC Ethernet and many other network "bulk data" interfaces */
 int usbnet_get_endpoints(struct usbnet *dev, struct usb_interface *intf)
 {
@@ -239,9 +241,12 @@
 		  skb->len + sizeof (struct ethhdr), skb->protocol);
 	memset (skb->cb, 0, sizeof (struct skb_data));
 	status = netif_rx (skb);
-	if (status != NET_RX_SUCCESS)
+	if (status != NET_RX_SUCCESS){
 		netif_dbg(dev, rx_err, dev->net,
 			  "netif_rx status %d\n", status);
+		printk("send to netif bug.....\n");
+	}
+
 }
 EXPORT_SYMBOL_GPL(usbnet_skb_return);
 
@@ -287,13 +292,16 @@
 {
 	unsigned long		flags;
 
+
 	spin_lock_irqsave(&list->lock, flags);
 	__skb_unlink(skb, list);
 	spin_unlock(&list->lock);
 	spin_lock(&dev->done.lock);
 	__skb_queue_tail(&dev->done, skb);
-	if (dev->done.qlen == 1)
-		tasklet_schedule(&dev->bh);
+	if (dev->done.qlen >= 1){
+		usbnet_bh(dev);
+	}
+
 	spin_unlock_irqrestore(&dev->done.lock, flags);
 }
 
@@ -337,10 +345,8 @@
 	entry->dev = dev;
 	entry->state = rx_start;
 	entry->length = 0;
-
 	usb_fill_bulk_urb (urb, dev->udev, dev->in,
 		skb->data, size, rx_complete, skb);
-
 	spin_lock_irqsave (&dev->rxq.lock, lockflags);
 
 	if (netif_running (dev->net) &&
@@ -394,13 +400,14 @@
 		goto done;
 	}
 	// else network stack removes extra byte if we forced a short packet
-
 	if (skb->len) {
 		/* all data was already cloned from skb inside the driver */
 		if (dev->driver_info->flags & FLAG_MULTI_PACKET)
 			dev_kfree_skb_any(skb);
-		else
+		else{
 			usbnet_skb_return(dev, skb);
+		}
+
 		return;
 	}
 
@@ -710,7 +717,6 @@
 		goto done_nopm;
 	}
 
-	// put into "known safe" state
 	if (info->reset && (retval = info->reset (dev)) < 0) {
 		netif_info(dev, ifup, dev->net,
 			   "open reset fail (%d) usbnet usb-%s-%s, %s\n",
@@ -884,7 +890,6 @@
 		container_of(work, struct usbnet, kevent);
 	int			status;
 
-	/* usb_clear_halt() needs a thread context */
 	if (test_bit (EVENT_TX_HALT, &dev->flags)) {
 		unlink_urbs (dev, &dev->txq);
 		status = usb_autopm_get_interface(dev->intf);
@@ -1082,7 +1087,7 @@
 
 	usb_fill_bulk_urb (urb, dev->udev, dev->out,
 			skb->data, skb->len, tx_complete, skb);
-
+	//printk("\n [tx]  user complete add is %x\n",(unsigned int)tx_complete);
 	/* don't assume the hardware handles USB_ZERO_PACKET
 	 * NOTE:  strictly conforming cdc-ether devices should expect
 	 * the ZLP here, but ignore the one-byte packet.
@@ -1162,7 +1167,7 @@
 
 /*-------------------------------------------------------------------------*/
 
-// tasklet (work deferred from completions, in_irq) or timer
+
 
 static void usbnet_bh (unsigned long param)
 {
@@ -1174,11 +1179,13 @@
 		entry = (struct skb_data *) skb->cb;
 		switch (entry->state) {
 		case rx_done:
+
 			entry->state = rx_cleanup;
 			rx_process (dev, skb);
 			continue;
 		case tx_done:
 		case rx_cleanup:
+
 			usb_free_urb (entry->urb);
 			dev_kfree_skb (skb);
 			continue;
@@ -1187,7 +1194,7 @@
 		}
 	}
 
-	// waiting for all pending urbs to complete?
+
 	if (dev->wait) {
 		if ((dev->txq.qlen + dev->rxq.qlen + dev->done.qlen) == 0) {
 			wake_up (dev->wait);
@@ -1205,7 +1212,6 @@
 			struct urb	*urb;
 			int		i;
 
-			// don't refill the queue all at once
 			for (i = 0; i < 10 && dev->rxq.qlen < qlen; i++) {
 				urb = usb_alloc_urb (0, GFP_ATOMIC);
 				if (urb != NULL) {
@@ -1218,12 +1224,17 @@
 				netif_dbg(dev, link, dev->net,
 					  "rxqlen %d --> %d\n",
 					  temp, dev->rxq.qlen);
-			if (dev->rxq.qlen < qlen)
+			if (dev->rxq.qlen < qlen){
 				tasklet_schedule (&dev->bh);
+			}
+
 		}
-		if (dev->txq.qlen < TX_QLEN (dev))
+		if (dev->txq.qlen < TX_QLEN (dev)){
 			netif_wake_queue (dev->net);
+		}
+
 	}
+
 }
 
 
@@ -1237,35 +1248,34 @@
 
 void usbnet_disconnect (struct usb_interface *intf)
 {
-	struct usbnet		*dev;
-	struct usb_device	*xdev;
-	struct net_device	*net;
+	struct usbnet *dev;
+	struct usb_device *xdev;
+	struct net_device *net;
 
 	dev = usb_get_intfdata(intf);
 	usb_set_intfdata(intf, NULL);
 	if (!dev)
 		return;
 
-	xdev = interface_to_usbdev (intf);
+	xdev = interface_to_usbdev(intf);
 
 	netif_info(dev, probe, dev->net, "unregister '%s' usb-%s-%s, %s\n",
-		   intf->dev.driver->name,
-		   xdev->bus->bus_name, xdev->devpath,
-		   dev->driver_info->description);
+	                intf->dev.driver->name, xdev->bus->bus_name,
+	                xdev->devpath, dev->driver_info->description);
 
 	net = dev->net;
-	unregister_netdev (net);
+	unregister_netdev(net);
 
 	cancel_work_sync(&dev->kevent);
 
 	if (dev->driver_info->unbind)
-		dev->driver_info->unbind (dev, intf);
+		dev->driver_info->unbind(dev, intf);
 
 	usb_kill_urb(dev->interrupt);
 	usb_free_urb(dev->interrupt);
 
 	free_netdev(net);
-	usb_put_dev (xdev);
+	usb_put_dev(xdev);
 }
 EXPORT_SYMBOL_GPL(usbnet_disconnect);
 
@@ -1325,7 +1335,7 @@
 
 	status = -ENOMEM;
 
-	// set up our own records
+
 	net = alloc_etherdev(sizeof(*dev));
 	if (!net) {
 		dbg ("can't kmalloc dev");
@@ -1374,16 +1384,12 @@
 	net->watchdog_timeo = TX_TIMEOUT_JIFFIES;
 	net->ethtool_ops = &usbnet_ethtool_ops;
 
-	// allow device-specific bind/init procedures
-	// NOTE net->name still not usable ...
+
 	if (info->bind) {
 		status = info->bind (dev, udev);
 		if (status < 0)
 			goto out1;
 
-		// heuristic:  "usb%d" for links we know are two-host,
-		// else "eth%d" when there's reasonable doubt.  userspace
-		// can rename the link if it knows better.
 		if ((dev->driver_info->flags & FLAG_ETHER) != 0 &&
 		    ((dev->driver_info->flags & FLAG_POINTTOPOINT) == 0 ||
 		     (net->dev_addr [0] & 0x02) == 0))
@@ -1411,11 +1417,12 @@
 			status = 0;
 
 	}
+#if(0)
 	if (status >= 0 && dev->status)
 		status = init_status (dev, udev);
 	if (status < 0)
 		goto out3;
-
+#endif
 	if (!dev->rx_urb_size)
 		dev->rx_urb_size = dev->hard_mtu;
 	dev->maxpacket = usb_maxpacket (dev->udev, dev->out, 1);
@@ -1435,7 +1442,7 @@
 		   dev->driver_info->description,
 		   net->dev_addr);
 
-	// ok, it's ready to go.
+
 	usb_set_intfdata (udev, dev);
 
 	netif_device_attach (net);
@@ -1447,7 +1454,7 @@
 
 out3:
 	if (info->unbind)
-		info->unbind (dev, udev);
+		info->unbind(dev, udev);
 out1:
 	free_netdev(net);
 out:
@@ -1465,7 +1472,7 @@
 
 int usbnet_suspend (struct usb_interface *intf, pm_message_t message)
 {
-	struct usbnet		*dev = usb_get_intfdata(intf);
+	struct usbnet *dev = usb_get_intfdata(intf);
 
 	if (!dev->suspend_count++) {
 		spin_lock_irq(&dev->txq.lock);
@@ -1481,7 +1488,7 @@
 		 * accelerate emptying of the rx and queues, to avoid
 		 * having everything error out.
 		 */
-		netif_device_detach (dev->net);
+		netif_device_detach(dev->net);
 		usbnet_terminate_urbs(dev);
 		usb_kill_urb(dev->interrupt);
 
@@ -1489,7 +1496,7 @@
 		 * reattach so runtime management can use and
 		 * wake the device
 		 */
-		netif_device_attach (dev->net);
+		netif_device_attach(dev->net);
 	}
 	return 0;
 }
@@ -1497,10 +1504,10 @@
 
 int usbnet_resume (struct usb_interface *intf)
 {
-	struct usbnet		*dev = usb_get_intfdata(intf);
-	struct sk_buff          *skb;
-	struct urb              *res;
-	int                     retval;
+	struct usbnet *dev = usb_get_intfdata(intf);
+	struct sk_buff *skb;
+	struct urb *res;
+	int retval;
 
 	if (!--dev->suspend_count) {
 		/* resume interrupt URBs */
@@ -1510,7 +1517,7 @@
 		spin_lock_irq(&dev->txq.lock);
 		while ((res = usb_get_from_anchor(&dev->deferred))) {
 
-			skb = (struct sk_buff *)res->context;
+			skb = (struct sk_buff *) res->context;
 			retval = usb_submit_urb(res, GFP_ATOMIC);
 			if (retval < 0) {
 				dev_kfree_skb_any(skb);
@@ -1529,7 +1536,7 @@
 		if (test_bit(EVENT_DEV_OPEN, &dev->flags)) {
 			if (!(dev->txq.qlen >= TX_QLEN(dev)))
 				netif_start_queue(dev->net);
-			tasklet_schedule (&dev->bh);
+			tasklet_schedule(&dev->bh);
 		}
 	}
 	return 0;
diff -uraN linux-3.0.8/drivers/pwm/core.c linux-3.0.8-fh8632-V1.0_20180330/drivers/pwm/core.c
--- linux-3.0.8/drivers/pwm/core.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/pwm/core.c	2021-07-13 23:40:35.586368043 +0300
@@ -0,0 +1,642 @@
+/*
+ * Generic pwmlib implementation
+ *
+ * Copyright (C) 2011 Sascha Hauer <s.hauer@pengutronix.de>
+ * Copyright (C) 2011-2012 Avionic Design GmbH
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/pwm.h>
+#include <linux/radix-tree.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+#define MAX_PWMS 1024
+
+/* flags in the third cell of the DT PWM specifier */
+#define PWM_SPEC_POLARITY	(1 << 0)
+
+static DEFINE_MUTEX(pwm_lookup_lock);
+static LIST_HEAD(pwm_lookup_list);
+static DEFINE_MUTEX(pwm_lock);
+static LIST_HEAD(pwm_chips);
+static DECLARE_BITMAP(allocated_pwms, MAX_PWMS);
+static RADIX_TREE(pwm_tree, GFP_KERNEL);
+
+static struct pwm_device *pwm_to_device(unsigned int pwm)
+{
+	return radix_tree_lookup(&pwm_tree, pwm);
+}
+
+static int alloc_pwms(int pwm, unsigned int count)
+{
+	unsigned int from = 0;
+	unsigned int start;
+
+	if (pwm >= MAX_PWMS)
+		return -EINVAL;
+
+	if (pwm >= 0)
+		from = pwm;
+
+	start = bitmap_find_next_zero_area(allocated_pwms, MAX_PWMS, from,
+					   count, 0);
+
+	if (pwm >= 0 && start != pwm)
+		return -EEXIST;
+
+	if (start + count > MAX_PWMS)
+		return -ENOSPC;
+
+	return start;
+}
+
+static void free_pwms(struct pwm_chip *chip)
+{
+	unsigned int i;
+
+	for (i = 0; i < chip->npwm; i++) {
+		struct pwm_device *pwm = &chip->pwms[i];
+		radix_tree_delete(&pwm_tree, pwm->pwm);
+	}
+
+	bitmap_clear(allocated_pwms, chip->base, chip->npwm);
+
+	kfree(chip->pwms);
+	chip->pwms = NULL;
+}
+
+static struct pwm_chip *pwmchip_find_by_name(const char *name)
+{
+	struct pwm_chip *chip;
+
+	if (!name)
+		return NULL;
+
+	mutex_lock(&pwm_lock);
+
+	list_for_each_entry(chip, &pwm_chips, list) {
+		const char *chip_name = dev_name(chip->dev);
+
+		if (chip_name && strcmp(chip_name, name) == 0) {
+			mutex_unlock(&pwm_lock);
+			return chip;
+		}
+	}
+
+	mutex_unlock(&pwm_lock);
+
+	return NULL;
+}
+
+static int pwm_device_request(struct pwm_device *pwm, const char *label)
+{
+	int err;
+
+	if (test_bit(PWMF_REQUESTED, &pwm->flags))
+		return -EBUSY;
+
+	if (!try_module_get(pwm->chip->ops->owner))
+		return -ENODEV;
+
+	if (pwm->chip->ops->request) {
+		err = pwm->chip->ops->request(pwm->chip, pwm);
+		if (err) {
+			module_put(pwm->chip->ops->owner);
+			return err;
+		}
+	}
+
+	set_bit(PWMF_REQUESTED, &pwm->flags);
+	pwm->label = label;
+
+	return 0;
+}
+
+/**
+ * pwm_set_chip_data() - set private chip data for a PWM
+ * @pwm: PWM device
+ * @data: pointer to chip-specific data
+ */
+int pwm_set_chip_data(struct pwm_device *pwm, void *data)
+{
+	if (!pwm)
+		return -EINVAL;
+
+	pwm->chip_data = data;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pwm_set_chip_data);
+
+/**
+ * pwm_get_chip_data() - get private chip data for a PWM
+ * @pwm: PWM device
+ */
+void *pwm_get_chip_data(struct pwm_device *pwm)
+{
+	return pwm ? pwm->chip_data : NULL;
+}
+EXPORT_SYMBOL_GPL(pwm_get_chip_data);
+
+/**
+ * pwmchip_add() - register a new PWM chip
+ * @chip: the PWM chip to add
+ *
+ * Register a new PWM chip. If chip->base < 0 then a dynamically assigned base
+ * will be used.
+ */
+int pwmchip_add(struct pwm_chip *chip)
+{
+	struct pwm_device *pwm;
+	unsigned int i;
+	int ret;
+
+	if (!chip || !chip->dev || !chip->ops || !chip->ops->config ||
+	    !chip->ops->enable || !chip->ops->disable)
+		return -EINVAL;
+
+	mutex_lock(&pwm_lock);
+
+	ret = alloc_pwms(chip->base, chip->npwm);
+	if (ret < 0)
+		goto out;
+
+	chip->pwms = kzalloc(chip->npwm * sizeof(*pwm), GFP_KERNEL);
+	if (!chip->pwms) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	chip->base = ret;
+
+	for (i = 0; i < chip->npwm; i++) {
+		pwm = &chip->pwms[i];
+
+		pwm->chip = chip;
+		pwm->pwm = chip->base + i;
+		pwm->hwpwm = i;
+
+		radix_tree_insert(&pwm_tree, pwm->pwm, pwm);
+	}
+
+	bitmap_set(allocated_pwms, chip->base, chip->npwm);
+
+	INIT_LIST_HEAD(&chip->list);
+	list_add(&chip->list, &pwm_chips);
+
+	ret = 0;
+out:
+	mutex_unlock(&pwm_lock);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pwmchip_add);
+
+/**
+ * pwmchip_remove() - remove a PWM chip
+ * @chip: the PWM chip to remove
+ *
+ * Removes a PWM chip. This function may return busy if the PWM chip provides
+ * a PWM device that is still requested.
+ */
+int pwmchip_remove(struct pwm_chip *chip)
+{
+	unsigned int i;
+	int ret = 0;
+
+	mutex_lock(&pwm_lock);
+
+	for (i = 0; i < chip->npwm; i++) {
+		struct pwm_device *pwm = &chip->pwms[i];
+
+		if (test_bit(PWMF_REQUESTED, &pwm->flags)) {
+			ret = -EBUSY;
+			goto out;
+		}
+	}
+
+	list_del_init(&chip->list);
+
+	free_pwms(chip);
+
+out:
+	mutex_unlock(&pwm_lock);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pwmchip_remove);
+
+/**
+ * pwm_request() - request a PWM device
+ * @pwm_id: global PWM device index
+ * @label: PWM device label
+ *
+ * This function is deprecated, use pwm_get() instead.
+ */
+struct pwm_device *pwm_request(int pwm, const char *label)
+{
+	struct pwm_device *dev;
+	int err;
+
+	if (pwm < 0 || pwm >= MAX_PWMS)
+		return ERR_PTR(-EINVAL);
+
+	mutex_lock(&pwm_lock);
+
+	dev = pwm_to_device(pwm);
+	if (!dev) {
+		dev = ERR_PTR(-ENODEV);
+		goto out;
+	}
+
+	err = pwm_device_request(dev, label);
+	if (err < 0)
+		dev = ERR_PTR(err);
+
+out:
+	mutex_unlock(&pwm_lock);
+
+	return dev;
+}
+EXPORT_SYMBOL_GPL(pwm_request);
+
+/**
+ * pwm_request_from_chip() - request a PWM device relative to a PWM chip
+ * @chip: PWM chip
+ * @index: per-chip index of the PWM to request
+ * @label: a literal description string of this PWM
+ *
+ * Returns the PWM at the given index of the given PWM chip. A negative error
+ * code is returned if the index is not valid for the specified PWM chip or
+ * if the PWM device cannot be requested.
+ */
+struct pwm_device *pwm_request_from_chip(struct pwm_chip *chip,
+					 unsigned int index,
+					 const char *label)
+{
+	struct pwm_device *pwm;
+	int err;
+
+	if (!chip || index >= chip->npwm)
+		return ERR_PTR(-EINVAL);
+
+	mutex_lock(&pwm_lock);
+	pwm = &chip->pwms[index];
+
+	err = pwm_device_request(pwm, label);
+	if (err < 0)
+		pwm = ERR_PTR(err);
+
+	mutex_unlock(&pwm_lock);
+	return pwm;
+}
+EXPORT_SYMBOL_GPL(pwm_request_from_chip);
+
+/**
+ * pwm_free() - free a PWM device
+ * @pwm: PWM device
+ *
+ * This function is deprecated, use pwm_put() instead.
+ */
+void pwm_free(struct pwm_device *pwm)
+{
+	pwm_put(pwm);
+}
+EXPORT_SYMBOL_GPL(pwm_free);
+
+/**
+ * pwm_config() - change a PWM device configuration
+ * @pwm: PWM device
+ * @duty_ns: "on" time (in nanoseconds)
+ * @period_ns: duration (in nanoseconds) of one cycle
+ */
+int pwm_config(struct pwm_device *pwm, int duty_ns, int period_ns)
+{
+	if (!pwm || duty_ns < 0 || period_ns <= 0 || duty_ns > period_ns)
+		return -EINVAL;
+
+	return pwm->chip->ops->config(pwm->chip, pwm, duty_ns, period_ns);
+}
+EXPORT_SYMBOL_GPL(pwm_config);
+
+/**
+ * pwm_set_polarity() - configure the polarity of a PWM signal
+ * @pwm: PWM device
+ * @polarity: new polarity of the PWM signal
+ *
+ * Note that the polarity cannot be configured while the PWM device is enabled
+ */
+int pwm_set_polarity(struct pwm_device *pwm, enum pwm_polarity polarity)
+{
+	if (!pwm || !pwm->chip->ops)
+		return -EINVAL;
+
+	if (!pwm->chip->ops->set_polarity)
+		return -ENOSYS;
+
+	if (test_bit(PWMF_ENABLED, &pwm->flags))
+		return -EBUSY;
+
+	return pwm->chip->ops->set_polarity(pwm->chip, pwm, polarity);
+}
+EXPORT_SYMBOL_GPL(pwm_set_polarity);
+
+/**
+ * pwm_enable() - start a PWM output toggling
+ * @pwm: PWM device
+ */
+int pwm_enable(struct pwm_device *pwm)
+{
+	if (pwm && !test_and_set_bit(PWMF_ENABLED, &pwm->flags))
+		return pwm->chip->ops->enable(pwm->chip, pwm);
+
+	return pwm ? 0 : -EINVAL;
+}
+EXPORT_SYMBOL_GPL(pwm_enable);
+
+/**
+ * pwm_disable() - stop a PWM output toggling
+ * @pwm: PWM device
+ */
+void pwm_disable(struct pwm_device *pwm)
+{
+	if (pwm && test_and_clear_bit(PWMF_ENABLED, &pwm->flags))
+		pwm->chip->ops->disable(pwm->chip, pwm);
+}
+EXPORT_SYMBOL_GPL(pwm_disable);
+
+/**
+ * pwm_add_table() - register PWM device consumers
+ * @table: array of consumers to register
+ * @num: number of consumers in table
+ */
+void __init pwm_add_table(struct pwm_lookup *table, size_t num)
+{
+	mutex_lock(&pwm_lookup_lock);
+
+	while (num--) {
+		list_add_tail(&table->list, &pwm_lookup_list);
+		table++;
+	}
+
+	mutex_unlock(&pwm_lookup_lock);
+}
+
+/**
+ * pwm_get() - look up and request a PWM device
+ * @dev: device for PWM consumer
+ * @con_id: consumer name
+ *
+ * Lookup is first attempted using DT. If the device was not instantiated from
+ * a device tree, a PWM chip and a relative index is looked up via a table
+ * supplied by board setup code (see pwm_add_table()).
+ *
+ * Once a PWM chip has been found the specified PWM device will be requested
+ * and is ready to be used.
+ */
+struct pwm_device *pwm_get(struct device *dev, const char *con_id)
+{
+	struct pwm_device *pwm = ERR_PTR(-ENODEV);
+	const char *dev_id = dev ? dev_name(dev) : NULL;
+	struct pwm_chip *chip = NULL;
+	unsigned int index = 0;
+	unsigned int best = 0;
+	struct pwm_lookup *p;
+	unsigned int match;
+
+	/*
+	 * We look up the provider in the static table typically provided by
+	 * board setup code. We first try to lookup the consumer device by
+	 * name. If the consumer device was passed in as NULL or if no match
+	 * was found, we try to find the consumer by directly looking it up
+	 * by name.
+	 *
+	 * If a match is found, the provider PWM chip is looked up by name
+	 * and a PWM device is requested using the PWM device per-chip index.
+	 *
+	 * The lookup algorithm was shamelessly taken from the clock
+	 * framework:
+	 *
+	 * We do slightly fuzzy matching here:
+	 *  An entry with a NULL ID is assumed to be a wildcard.
+	 *  If an entry has a device ID, it must match
+	 *  If an entry has a connection ID, it must match
+	 * Then we take the most specific entry - with the following order
+	 * of precedence: dev+con > dev only > con only.
+	 */
+	mutex_lock(&pwm_lookup_lock);
+
+	list_for_each_entry(p, &pwm_lookup_list, list) {
+		match = 0;
+
+		if (p->dev_id) {
+			if (!dev_id || strcmp(p->dev_id, dev_id))
+				continue;
+
+			match += 2;
+		}
+
+		if (p->con_id) {
+			if (!con_id || strcmp(p->con_id, con_id))
+				continue;
+
+			match += 1;
+		}
+
+		if (match > best) {
+			chip = pwmchip_find_by_name(p->provider);
+			index = p->index;
+
+			if (match != 3)
+				best = match;
+			else
+				break;
+		}
+	}
+
+	if (chip)
+		pwm = pwm_request_from_chip(chip, index, con_id ?: dev_id);
+
+	mutex_unlock(&pwm_lookup_lock);
+
+	return pwm;
+}
+EXPORT_SYMBOL_GPL(pwm_get);
+
+/**
+ * pwm_put() - release a PWM device
+ * @pwm: PWM device
+ */
+void pwm_put(struct pwm_device *pwm)
+{
+	if (!pwm)
+		return;
+
+	mutex_lock(&pwm_lock);
+
+	if (!test_and_clear_bit(PWMF_REQUESTED, &pwm->flags)) {
+		pr_warn("PWM device already freed\n");
+		goto out;
+	}
+
+	if (pwm->chip->ops->free)
+		pwm->chip->ops->free(pwm->chip, pwm);
+
+	pwm->label = NULL;
+
+	module_put(pwm->chip->ops->owner);
+out:
+	mutex_unlock(&pwm_lock);
+}
+EXPORT_SYMBOL_GPL(pwm_put);
+
+static void devm_pwm_release(struct device *dev, void *res)
+{
+	pwm_put(*(struct pwm_device **)res);
+}
+
+/**
+ * devm_pwm_get() - resource managed pwm_get()
+ * @dev: device for PWM consumer
+ * @con_id: consumer name
+ *
+ * This function performs like pwm_get() but the acquired PWM device will
+ * automatically be released on driver detach.
+ */
+struct pwm_device *devm_pwm_get(struct device *dev, const char *con_id)
+{
+	struct pwm_device **ptr, *pwm;
+
+	ptr = devres_alloc(devm_pwm_release, sizeof(**ptr), GFP_KERNEL);
+	if (!ptr)
+		return ERR_PTR(-ENOMEM);
+
+	pwm = pwm_get(dev, con_id);
+	if (!IS_ERR(pwm)) {
+		*ptr = pwm;
+		devres_add(dev, ptr);
+	} else {
+		devres_free(ptr);
+	}
+
+	return pwm;
+}
+EXPORT_SYMBOL_GPL(devm_pwm_get);
+
+/**
+  * pwm_can_sleep() - report whether PWM access will sleep
+  * @pwm: PWM device
+  *
+  * It returns true if accessing the PWM can sleep, false otherwise.
+  */
+bool pwm_can_sleep(struct pwm_device *pwm)
+{
+	return pwm->chip->can_sleep;
+}
+EXPORT_SYMBOL_GPL(pwm_can_sleep);
+
+#ifdef CONFIG_DEBUG_FS
+static void pwm_dbg_show(struct pwm_chip *chip, struct seq_file *s)
+{
+	unsigned int i;
+
+	for (i = 0; i < chip->npwm; i++) {
+		struct pwm_device *pwm = &chip->pwms[i];
+
+		seq_printf(s, " pwm-%-3d (%-20.20s):", i, pwm->label);
+
+		if (test_bit(PWMF_REQUESTED, &pwm->flags))
+			seq_printf(s, " requested");
+
+		if (test_bit(PWMF_ENABLED, &pwm->flags))
+			seq_printf(s, " enabled");
+
+		seq_printf(s, "\n");
+	}
+}
+
+static void *pwm_seq_start(struct seq_file *s, loff_t *pos)
+{
+	mutex_lock(&pwm_lock);
+	s->private = "";
+
+	return seq_list_start(&pwm_chips, *pos);
+}
+
+static void *pwm_seq_next(struct seq_file *s, void *v, loff_t *pos)
+{
+	s->private = "\n";
+
+	return seq_list_next(v, &pwm_chips, pos);
+}
+
+static void pwm_seq_stop(struct seq_file *s, void *v)
+{
+	mutex_unlock(&pwm_lock);
+}
+
+static int pwm_seq_show(struct seq_file *s, void *v)
+{
+	struct pwm_chip *chip = list_entry(v, struct pwm_chip, list);
+
+	seq_printf(s, "%s%s/%s, %d PWM device%s\n", (char *)s->private,
+		   chip->dev->bus ? chip->dev->bus->name : "no-bus",
+		   dev_name(chip->dev), chip->npwm,
+		   (chip->npwm != 1) ? "s" : "");
+
+	if (chip->ops->dbg_show)
+		chip->ops->dbg_show(chip, s);
+	else
+		pwm_dbg_show(chip, s);
+
+	return 0;
+}
+
+static const struct seq_operations pwm_seq_ops = {
+	.start = pwm_seq_start,
+	.next = pwm_seq_next,
+	.stop = pwm_seq_stop,
+	.show = pwm_seq_show,
+};
+
+static int pwm_seq_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &pwm_seq_ops);
+}
+
+static const struct file_operations pwm_debugfs_ops = {
+	.owner = THIS_MODULE,
+	.open = pwm_seq_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release,
+};
+
+static int __init pwm_debugfs_init(void)
+{
+	debugfs_create_file("pwm", S_IFREG | S_IRUGO, NULL, NULL,
+			    &pwm_debugfs_ops);
+
+	return 0;
+}
+
+subsys_initcall(pwm_debugfs_init);
+#endif /* CONFIG_DEBUG_FS */
diff -uraN linux-3.0.8/drivers/pwm/Kconfig linux-3.0.8-fh8632-V1.0_20180330/drivers/pwm/Kconfig
--- linux-3.0.8/drivers/pwm/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/pwm/Kconfig	2021-07-13 23:40:35.586368043 +0300
@@ -0,0 +1,47 @@
+menuconfig PWM
+	bool "Pulse-Width Modulation (PWM) Support"
+	help
+	  Generic Pulse-Width Modulation (PWM) support.
+
+	  In Pulse-Width Modulation, a variation of the width of pulses
+	  in a rectangular pulse signal is used as a means to alter the
+	  average power of the signal. Applications include efficient
+	  power delivery and voltage regulation. In computer systems,
+	  PWMs are commonly used to control fans or the brightness of
+	  display backlights.
+
+	  This framework provides a generic interface to PWM devices
+	  within the Linux kernel. On the driver side it provides an API
+	  to register and unregister a PWM chip, an abstraction of a PWM
+	  controller, that supports one or more PWM devices. Client
+	  drivers can request PWM devices and use the generic framework
+	  to configure as well as enable and disable them.
+
+	  This generic framework replaces the legacy PWM framework which
+	  allows only a single driver implementing the required API. Not
+	  all legacy implementations have been ported to the framework
+	  yet. The framework provides an API that is backward compatible
+	  with the legacy framework so that existing client drivers
+	  continue to work as expected.
+
+	  If unsure, say no.
+
+if PWM
+
+config PWM_FULLHAN
+	tristate "FH PWM support"
+	help
+	  To compile this driver as a module, choose M here: the module will
+	  be called fh_pwm.
+	  
+if PWM_FULLHAN
+config FH_PWM_NUM
+	int
+	prompt "Number of PWMs, range: 1~8"
+	default 2
+	range 1 8
+	help
+	  Number of PWMs
+endif
+
+endif
diff -uraN linux-3.0.8/drivers/pwm/Makefile linux-3.0.8-fh8632-V1.0_20180330/drivers/pwm/Makefile
--- linux-3.0.8/drivers/pwm/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/pwm/Makefile	2021-07-13 23:40:35.586368043 +0300
@@ -0,0 +1,20 @@
+obj-$(CONFIG_PWM)		+= core.o
+obj-$(CONFIG_PWM_AB8500)	+= pwm-ab8500.o
+obj-$(CONFIG_PWM_ATMEL_TCB)	+= pwm-atmel-tcb.o
+obj-$(CONFIG_PWM_BFIN)		+= pwm-bfin.o
+obj-$(CONFIG_PWM_IMX)		+= pwm-imx.o
+obj-$(CONFIG_PWM_JZ4740)	+= pwm-jz4740.o
+obj-$(CONFIG_PWM_LPC32XX)	+= pwm-lpc32xx.o
+obj-$(CONFIG_PWM_MXS)		+= pwm-mxs.o
+obj-$(CONFIG_PWM_PUV3)		+= pwm-puv3.o
+obj-$(CONFIG_PWM_PXA)		+= pwm-pxa.o
+obj-$(CONFIG_PWM_SAMSUNG)	+= pwm-samsung.o
+obj-$(CONFIG_PWM_SPEAR)		+= pwm-spear.o
+obj-$(CONFIG_PWM_TEGRA)		+= pwm-tegra.o
+obj-$(CONFIG_PWM_TIECAP)	+= pwm-tiecap.o
+obj-$(CONFIG_PWM_TIEHRPWM)	+= pwm-tiehrpwm.o
+obj-$(CONFIG_PWM_TIPWMSS)	+= pwm-tipwmss.o
+obj-$(CONFIG_PWM_TWL)		+= pwm-twl.o
+obj-$(CONFIG_PWM_TWL_LED)	+= pwm-twl-led.o
+obj-$(CONFIG_PWM_VT8500)	+= pwm-vt8500.o
+obj-$(CONFIG_PWM_FULLHAN)	+= pwmv2-fullhan.o
diff -uraN linux-3.0.8/drivers/pwm/pwm-fullhan.c linux-3.0.8-fh8632-V1.0_20180330/drivers/pwm/pwm-fullhan.c
--- linux-3.0.8/drivers/pwm/pwm-fullhan.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/pwm/pwm-fullhan.c	2021-07-13 23:40:35.586368043 +0300
@@ -0,0 +1,607 @@
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/pwm.h>
+#include <linux/printk.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/decompress/mm.h>
+#include <linux/of_address.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+#include <asm/uaccess.h>
+#include "pwm-fullhan.h"
+
+#undef  FH_PWM_DEBUG
+#ifdef FH_PWM_DEBUG
+#define PRINT_DBG(fmt,args...)  printk(fmt,##args)
+#else
+#define PRINT_DBG(fmt,args...)  do{} while(0)
+#endif
+
+struct fh_pwm_chip {
+	struct pwm_chip chip;
+	void __iomem *base;
+	struct clk *clk;
+	struct proc_dir_entry *proc_file;
+};
+
+struct fh_pwm_chip fh_pwm = {
+
+};
+
+
+static int pwm_get_duty_cycle_ns(struct fh_pwm_chip_data *chip_data)
+{
+	u32 reg, period, duty;
+	u32 clk_rate = clk_get_rate(fh_pwm.clk);
+
+	reg = readl(fh_pwm.base + REG_PWM_CMD(chip_data->id));
+	period = reg & 0x0fff;
+	duty = (reg >> 16) & 0xfff;
+	duty = period - duty;       //reverse duty cycle
+
+	if (period == 0)
+		period = duty;
+
+	chip_data->counter_ns = duty * 1000000000 / clk_rate;
+	chip_data->period_ns = period * 1000000000 / clk_rate;
+
+	PRINT_DBG("get duty: %d, period: %d, reg: 0x%x\n", duty, period, reg);
+
+	return 0;
+}
+
+static int pwm_set_duty_cycle_ns(struct fh_pwm_chip_data *chip_data)
+{
+	u32 period, duty, reg, clk_rate, duty_revert;
+	clk_rate = clk_get_rate(fh_pwm.clk);
+	if (!clk_rate) {
+		pr_err("PWM: clock rate is 0\n");
+		return -EINVAL;
+	}
+	period = chip_data->period_ns / (1000000000 / clk_rate);
+
+	if (period < 8) {
+		pr_err("PWM: min period is 8\n");
+		return -EINVAL;
+	}
+
+	duty = chip_data->counter_ns / (1000000000 / clk_rate);
+
+	if (period < duty) {
+		pr_err("PWM: period < duty\n");
+		return -EINVAL;
+	}
+
+	duty_revert = period - duty;
+
+	if (duty == period)
+		reg = (duty & 0xfff) << 16 | (0 & 0xfff);
+	else
+		reg = (duty_revert & 0xfff) << 16 | (period & 0xfff);
+
+	PRINT_DBG("set duty_revert: %d, period: %d, reg: 0x%x\n", duty_revert, period, reg);
+
+	writel(reg, fh_pwm.base + REG_PWM_CMD(chip_data->id));
+	return 0;
+}
+
+
+static int pwm_set_duty_cycle_percent(struct fh_pwm_chip_data *chip_data)
+{
+	u32 period, duty, reg, clk_rate, duty_revert;
+	clk_rate = clk_get_rate(fh_pwm.clk);
+	if (!clk_rate) {
+		pr_err("PWM: clock rate is 0\n");
+		return -EINVAL;
+	}
+
+	if (chip_data->percent > 100 || chip_data->percent < 0) {
+		pr_err("PWM: pwm->percent is out of range\n");
+		return -EINVAL;
+	}
+
+	period = chip_data->period_ns / (1000000000 / clk_rate);
+
+	if (period < 8) {
+		pr_err("PWM: min period is 8\n");
+		return -EINVAL;
+	}
+
+	duty = period * 100 / chip_data->percent;
+
+	if (period < duty) {
+		pr_err("PWM: period < duty\n");
+		return -EINVAL;
+	}
+
+	duty_revert = period - duty;
+
+	if (duty == period)
+		reg = (duty & 0xfff) << 16 | (0 & 0xfff);
+	else
+		reg = (duty_revert & 0xfff) << 16 | (period & 0xfff);
+
+	PRINT_DBG("set duty_revert: %d, period: %d, reg: 0x%x\n", duty_revert, period, reg);
+
+	writel(reg, fh_pwm.base + REG_PWM_CMD(chip_data->id));
+	return 0;
+}
+
+
+int fh_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
+		  int duty_ns, int period_ns)
+{
+	struct fh_pwm_chip_data *chip_data;
+
+	chip_data = pwm_get_chip_data(pwm);
+	if (!chip_data) {
+		pr_err("%s: ERROR: PWM %d does NOT exist\n",
+		       __func__, pwm->hwpwm);
+		return -ENXIO;
+	}
+	chip_data->counter_ns = duty_ns;
+	chip_data->period_ns = period_ns;
+	pwm_set_duty_cycle_ns(chip_data);
+	return 0;
+}
+
+static int _fh_pwm_enable(struct fh_pwm_chip_data *chip_data)
+{
+	int i;
+	unsigned int reg = 0;
+	chip_data->working = 1;
+
+	for (i = 0; i < fh_pwm.chip.npwm; i++) {
+		chip_data = pwm_get_chip_data(&fh_pwm.chip.pwms[i]);
+		reg |= chip_data->working << i;
+	}
+
+	writel(reg, fh_pwm.base + REG_PWM_CTRL);
+	return 0;
+}
+
+int fh_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct fh_pwm_chip_data *chip_data;
+
+	chip_data = pwm_get_chip_data(pwm);
+	if (!chip_data) {
+		pr_err("%s: ERROR: PWM %d does NOT exist\n",
+		       __func__, pwm->hwpwm);
+		return -ENXIO;
+	}
+
+	_fh_pwm_enable(chip_data);
+
+	return 0;
+}
+
+static int _fh_pwm_disable(struct fh_pwm_chip_data *chip_data)
+{
+	int i;
+	unsigned int reg = 0;
+	chip_data->working = 0;
+
+	for (i = 0; i < fh_pwm.chip.npwm; i++) {
+		chip_data = pwm_get_chip_data(&fh_pwm.chip.pwms[i]);
+		reg |= chip_data->working << i;
+	}
+
+	writel(reg, fh_pwm.base + REG_PWM_CTRL);
+	return 0;
+}
+
+void fh_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct fh_pwm_chip_data *chip_data;
+
+	chip_data = pwm_get_chip_data(pwm);
+	if (!chip_data) {
+		pr_err("%s: ERROR: PWM %d does NOT exist\n",
+		       __func__, pwm->hwpwm);
+		return;
+	}
+
+	_fh_pwm_disable(chip_data);
+}
+
+static int fh_pwm_open(struct inode *inode, struct file *file)
+{
+	int i;
+	struct fh_pwm_chip_data *chip_data;
+	struct pwm_device *pwm;
+
+	for (i = 0; i < fh_pwm.chip.npwm; i++) {
+		pwm = &fh_pwm.chip.pwms[i];
+
+		if (!pwm) {
+			pr_err("%s: ERROR: PWM %d does NOT exist\n",
+			       __func__, i);
+			return -ENXIO;
+		}
+		chip_data = pwm_get_chip_data(pwm);
+		if (!chip_data)
+			chip_data = kzalloc(sizeof(*chip_data), GFP_KERNEL);
+
+		chip_data->id = pwm->hwpwm;
+		chip_data->working = 0;
+		pwm->chip_data = chip_data;
+	}
+	return 0;
+}
+
+static int fh_pwm_release(struct inode *inode, struct file *filp)
+{
+	int i;
+	struct fh_pwm_chip_data *chip_data;
+	struct pwm_device *pwm;
+
+	for (i = 0; i < fh_pwm.chip.npwm; i++) {
+		pwm = &fh_pwm.chip.pwms[i];
+
+		if (!pwm) {
+			pr_err("%s: ERROR: PWM %d does NOT exist\n",
+			       __func__, i);
+			return -ENOTTY;
+		}
+		chip_data = pwm_get_chip_data(pwm);
+		free(chip_data);
+		pwm_set_chip_data(pwm, NULL);
+	}
+	return 0;
+}
+
+
+static long fh_pwm_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+	struct fh_pwm_chip_data *pwm;
+
+	if (unlikely(_IOC_TYPE(cmd) != PWM_IOCTL_MAGIC)) {
+		pr_err("%s: ERROR: incorrect magic num %d (error: %d)\n",
+		       __func__, _IOC_TYPE(cmd), -ENOTTY);
+		return -ENOTTY;
+	}
+
+	if (unlikely(_IOC_NR(cmd) > PWM_IOCTL_MAXNR)) {
+		pr_err("%s: ERROR: incorrect cmd num %d (error: %d)\n",
+		       __func__, _IOC_NR(cmd), -ENOTTY);
+		return -ENOTTY;
+	}
+
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		ret = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		ret = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
+
+	if (ret) {
+		pr_err("%s: ERROR: user space access is not permitted %d (error: %d)\n",
+		       __func__, _IOC_NR(cmd), -EACCES);
+		return -EACCES;
+	}
+
+	switch (cmd) {
+	case ENABLE_PWM:
+		pwm = (struct fh_pwm_chip_data __user *)arg;
+		_fh_pwm_enable(pwm);
+		break;
+	case DISABLE_PWM:
+		pwm = (struct fh_pwm_chip_data __user *)arg;
+		_fh_pwm_disable(pwm);
+		break;
+	case SET_PWM_DUTY_CYCLE:
+		pwm = (struct fh_pwm_chip_data __user *)arg;
+		printk("ioctl: pwm addr: %p, pwm->period: %d ns\n", pwm, pwm->period_ns);
+		pwm_set_duty_cycle_ns(pwm);
+		break;
+	case GET_PWM_DUTY_CYCLE:
+		pwm = (struct fh_pwm_chip_data __user *)arg;
+		printk("ioctl: pwm->id: %d, pwm->counter: %d, pwm->period: %d\n", pwm->id, pwm->counter_ns,
+		       pwm->period_ns);
+		pwm_get_duty_cycle_ns(pwm);
+		break;
+	case SET_PWM_DUTY_CYCLE_PERCENT:
+		pwm = (struct fh_pwm_chip_data __user *)arg;
+		printk("ioctl: pwm->id: %d, pwm->counter: %d, pwm->period: %d\n", pwm->id, pwm->counter_ns,
+		       pwm->period_ns);
+		pwm_set_duty_cycle_percent(pwm);
+		break;
+	}
+
+
+	return ret;
+}
+
+static const struct file_operations fh_pwm_fops = {
+	.owner 			= THIS_MODULE,
+	.open 			= fh_pwm_open,
+	.release 		= fh_pwm_release,
+	.unlocked_ioctl = fh_pwm_ioctl,
+};
+
+static struct miscdevice fh_pwm_misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = DEVICE_NAME,
+	.fops = &fh_pwm_fops,
+};
+
+static const struct pwm_ops fh_pwm_ops = {
+	.config = fh_pwm_config,
+	.enable = fh_pwm_enable,
+	.disable = fh_pwm_disable,
+	.owner = THIS_MODULE,
+};
+
+
+static void del_char(char *str, char ch)
+{
+	char *p = str;
+	char *q = str;
+	while (*q) {
+		if (*q != ch)
+			*p++ = *q;
+		q++;
+	}
+	*p = '\0';
+}
+
+static ssize_t fh_pwm_proc_write(struct file *filp, const char *buf, size_t len, loff_t *off)
+{
+	int i;
+	char message[32] = {0};
+	char *const delim = ",";
+	char *cur = message;
+	char *param_str[4];
+	unsigned int param[4];
+	struct fh_pwm_chip_data *chip_data;
+
+	len = (len > 32) ? 32 : len;
+
+	if (copy_from_user(message, buf, len))
+		return -EFAULT;
+
+	for (i = 0; i < 4; i++) {
+		param_str[i] = strsep(&cur, delim);
+		if (!param_str[i]) {
+			pr_err("%s: ERROR: parameter[%d] is empty\n", __func__, i);
+			return -EINVAL;
+		} else {
+			del_char(param_str[i], ' ');
+			del_char(param_str[i], '\n');
+			param[i] = (u32)simple_strtoul(param_str[i], NULL, 10);
+			if (param[i] < 0) {
+				pr_err("%s: ERROR: parameter[%d] is incorrect\n", __func__, i);
+				return -EINVAL;
+			}
+		}
+	}
+
+	printk("set pwm %d to %s, duty cycle: %u ns, period cycle: %u\n", param[0],
+	       param[1] ? "enable" : "disable", param[2], param[3]);
+	chip_data = pwm_get_chip_data(&fh_pwm.chip.pwms[param[0]]);
+	chip_data->counter_ns = param[2];
+	chip_data->period_ns = param[3];
+
+	param[1] ? fh_pwm_enable(&fh_pwm.chip, &fh_pwm.chip.pwms[param[0]]) : fh_pwm_disable(&fh_pwm.chip,
+			&fh_pwm.chip.pwms[param[0]]);
+	pwm_set_duty_cycle_ns(chip_data);
+
+	return len;
+}
+
+static void *v_seq_start(struct seq_file *s, loff_t *pos)
+{
+	static unsigned long counter = 0;
+	if (*pos == 0)
+		return &counter;
+	else {
+		*pos = 0;
+		return NULL;
+	}
+}
+
+static void *v_seq_next(struct seq_file *s, void *v, loff_t *pos)
+{
+	(*pos)++;
+	return NULL;
+}
+
+static void v_seq_stop(struct seq_file *s, void *v)
+{
+
+}
+
+static int v_seq_show(struct seq_file *sfile, void *v)
+{
+	int i;
+	seq_printf(sfile, "\nPWM Status:\n");
+
+	for (i = 0; i < fh_pwm.chip.npwm; i++) {
+		struct fh_pwm_chip_data *chip_data;
+
+		chip_data = pwm_get_chip_data(&fh_pwm.chip.pwms[i]);
+		seq_printf(sfile, "id: %d \t%s, duty_ns: %u, period_ns: %u\n",
+			   chip_data->id,
+			   (chip_data->working) ? "ENABLE" : "DISABLE",
+			   chip_data->counter_ns,
+			   chip_data->period_ns);
+	}
+	return 0;
+}
+
+static const struct seq_operations isp_seq_ops = {
+	.start = v_seq_start,
+	.next = v_seq_next,
+	.stop = v_seq_stop,
+	.show = v_seq_show
+};
+
+static int fh_pwm_proc_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &isp_seq_ops);
+}
+
+
+static struct file_operations fh_pwm_proc_ops = {
+	.owner = THIS_MODULE,
+	.open = fh_pwm_proc_open,
+	.read = seq_read,
+	.write = fh_pwm_proc_write,
+	.release = seq_release,
+};
+
+static int __devinit fh_pwm_probe(struct platform_device *pdev)
+{
+	int err, i;
+	struct resource *res;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		err = -ENXIO;
+		goto fail_no_mem_resource;
+	}
+
+	res = request_mem_region(res->start, resource_size(res), pdev->name);
+	if (res == NULL) {
+		err = -EBUSY;
+		goto fail_no_mem_resource;
+	}
+
+	fh_pwm.base = ioremap(res->start, resource_size(res));
+	if (fh_pwm.base == NULL) {
+		err = -ENXIO;
+		goto fail_no_ioremap;
+	}
+
+	fh_pwm.clk = clk_get(&pdev->dev, "pwm_clk");
+
+	if (IS_ERR(fh_pwm.clk)) {
+		err = PTR_ERR(fh_pwm.clk);
+		goto fail_no_clk;
+	}
+
+	clk_enable(fh_pwm.clk);
+
+	err = misc_register(&fh_pwm_misc);
+	if (err < 0) {
+		pr_err("%s: ERROR: %s registration failed",
+		       __func__, DEVICE_NAME);
+		return -ENXIO;
+	}
+
+	fh_pwm.chip.dev = &pdev->dev;
+	fh_pwm.chip.ops = &fh_pwm_ops;
+	fh_pwm.chip.base = pdev->id;
+	fh_pwm.chip.npwm = CONFIG_FH_PWM_NUM;
+
+	err = pwmchip_add(&fh_pwm.chip);
+	if (err < 0) {
+		pr_err("%s: ERROR: %s pwmchip_add failed",
+		       __func__, DEVICE_NAME);
+		return err;
+	}
+
+	for (i = 0; i < fh_pwm.chip.npwm; i++) {
+		struct fh_pwm_chip_data *chip_data;
+
+		chip_data = kzalloc(sizeof(struct fh_pwm_chip_data), GFP_KERNEL);
+		if (chip_data == NULL) {
+			pr_err("pwm[%d], chip data malloced failed\n", i);
+			continue;
+		}
+
+		chip_data->id = i;
+		chip_data->working = 0;
+
+		pwm_set_chip_data(&fh_pwm.chip.pwms[i], chip_data);
+	}
+
+	platform_set_drvdata(pdev, &fh_pwm);
+
+	/* disable pwm at startup. Avoids zero value. */
+	writel(0x0, fh_pwm.base + REG_PWM_CTRL);
+
+	pr_info("PWM driver, Number: %d, IO base addr: 0x%p\n",
+		fh_pwm.chip.npwm, fh_pwm.base);
+
+	fh_pwm.proc_file = create_proc_entry(FH_PWM_PROC_FILE, 0644, NULL);
+
+	if (fh_pwm.proc_file)
+		fh_pwm.proc_file->proc_fops = &fh_pwm_proc_ops;
+	else
+		pr_err("%s: ERROR: %s proc file create failed",
+		       __func__, DEVICE_NAME);
+
+	dev_dbg(&pdev->dev, "PWM probe successful, IO base addr: %p\n",
+		fh_pwm.base);
+	return 0;
+
+fail_no_clk:
+	iounmap(fh_pwm.base);
+fail_no_ioremap:
+	release_mem_region(res->start, resource_size(res));
+fail_no_mem_resource:
+	return err;
+}
+
+static int __exit fh_pwm_remove(struct platform_device *pdev)
+{
+	int err, i;
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	for (i = 0; i < fh_pwm.chip.npwm; i++)
+		kfree(fh_pwm.chip.pwms[i].chip_data);
+
+	err = pwmchip_remove(&fh_pwm.chip);
+	if (err < 0)
+		return err;
+
+	dev_dbg(&pdev->dev, "pwm driver removed\n");
+
+	writel(0x0, fh_pwm.base + REG_PWM_CTRL);
+	clk_disable(fh_pwm.clk);
+
+	iounmap(fh_pwm.base);
+	release_mem_region(res->start, resource_size(res));
+	platform_set_drvdata(pdev, NULL);
+	misc_deregister(&fh_pwm_misc);
+	return 0;
+}
+
+static struct platform_driver fh_pwm_driver = {
+	.driver	=
+	{
+		.name	= DEVICE_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe 		= fh_pwm_probe,
+	.remove		= __exit_p(fh_pwm_remove),
+};
+
+static int __init fh_pwm_init(void)
+{
+	return platform_driver_register(&fh_pwm_driver);
+}
+
+static void __exit fh_pwm_exit(void)
+{
+
+	platform_driver_unregister(&fh_pwm_driver);
+
+}
+
+module_init(fh_pwm_init);
+module_exit(fh_pwm_exit);
+
+
+MODULE_AUTHOR("fullhan");
+
+MODULE_DESCRIPTION("FH PWM driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(MISC_DYNAMIC_MINOR);
diff -uraN linux-3.0.8/drivers/pwm/pwm-fullhan.h linux-3.0.8-fh8632-V1.0_20180330/drivers/pwm/pwm-fullhan.h
--- linux-3.0.8/drivers/pwm/pwm-fullhan.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/pwm/pwm-fullhan.h	2021-07-13 23:40:35.586368043 +0300
@@ -0,0 +1,31 @@
+#ifndef FH_PMU_H_
+#define FH_PMU_H_
+
+#include <linux/slab.h>
+#include <linux/ioctl.h>
+
+#define DEVICE_NAME					"fh_pwm"
+#define FH_PWM_PROC_FILE            "driver/pwm"
+
+#define REG_PWM_CTRL				(0x00)
+#define REG_PWM_CMD(n)          	(((n) * 4) + REG_PWM_CTRL + 4)
+
+#define PWM_IOCTL_MAGIC 			'p'
+#define ENABLE_PWM	 				_IOWR(PWM_IOCTL_MAGIC, 0, __u32)
+#define DISABLE_PWM		 			_IOWR(PWM_IOCTL_MAGIC, 1, __u32)
+
+#define SET_PWM_DUTY_CYCLE			_IOWR(PWM_IOCTL_MAGIC, 2, __u32)
+#define GET_PWM_DUTY_CYCLE 		    _IOWR(PWM_IOCTL_MAGIC, 3, __u32)
+#define SET_PWM_DUTY_CYCLE_PERCENT  _IOWR(PWM_IOCTL_MAGIC, 4, __u32)
+#define PWM_IOCTL_MAXNR 			8
+
+struct fh_pwm_chip_data
+{
+	int id;
+	int working;
+	u32 period_ns;
+	u32 counter_ns;
+	int percent;
+};
+
+#endif /* FH_PMU_H_ */
diff -uraN linux-3.0.8/drivers/pwm/pwmv2-fullhan.c linux-3.0.8-fh8632-V1.0_20180330/drivers/pwm/pwmv2-fullhan.c
--- linux-3.0.8/drivers/pwm/pwmv2-fullhan.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/pwm/pwmv2-fullhan.c	2021-07-13 23:40:35.586368043 +0300
@@ -0,0 +1,864 @@
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/pwm.h>
+#include <linux/printk.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/decompress/mm.h>
+#include <linux/of_address.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/time.h>
+#include <linux/interrupt.h>
+
+#include <linux/uaccess.h>
+#include "pwmv2-fullhan.h"
+
+#define FH_PWM_DEBUG
+#ifdef FH_PWM_DEBUG
+#define PRINT_DBG(fmt,args...)  printk(fmt,##args)
+#else
+#define PRINT_DBG(fmt,args...)  do{} while(0)
+#endif
+
+#define STATUS_INT			(1<<31)
+#define STATUS_FINALL0			(1<<0)
+#define STATUS_FINALL1			(1<<1)
+#define STATUS_FINALL2			(1<<2)
+#define STATUS_FINALL3			(1<<3)
+#define STATUS_FINALL4			(1<<4)
+#define STATUS_FINALL5			(1<<5)
+#define STATUS_FINALL6			(1<<6)
+#define STATUS_FINALL7			(1<<7)
+#define STATUS_FINONCE0			(1<<8)
+#define STATUS_FINONCE1			(1<<9)
+#define STATUS_FINONCE2			(1<<10)
+#define STATUS_FINONCE3			(1<<11)
+#define STATUS_FINONCE4			(1<<12)
+#define STATUS_FINONCE5			(1<<13)
+#define STATUS_FINONCE6			(1<<14)
+#define STATUS_FINONCE7			(1<<15)
+
+#define OFFSET_PWM_BASE(n)		(0x100 + 0x100 * n)
+
+#define OFFSET_PWM_GLOBAL_CTRL0		(0x000)
+#define OFFSET_PWM_GLOBAL_CTRL1		(0x004)
+#define OFFSET_PWM_GLOBAL_CTRL2		(0x008)
+#define OFFSET_PWM_INT_ENABLE		(0x010)
+#define OFFSET_PWM_INT_STATUS		(0x014)
+
+#define OFFSET_PWM_CTRL(n)		(0x000 + OFFSET_PWM_BASE(n))
+#define OFFSET_PWM_CFG0(n)		(0x004 + OFFSET_PWM_BASE(n))
+#define OFFSET_PWM_CFG1(n)		(0x008 + OFFSET_PWM_BASE(n))
+#define OFFSET_PWM_CFG2(n)		(0x00c + OFFSET_PWM_BASE(n))
+#define OFFSET_PWM_CFG3(n)		(0x010 + OFFSET_PWM_BASE(n))
+#define OFFSET_PWM_CFG4(n)		(0x014 + OFFSET_PWM_BASE(n))
+#define OFFSET_PWM_STATUS0(n)		(0x020 + OFFSET_PWM_BASE(n))
+#define OFFSET_PWM_STATUS1(n)		(0x024 + OFFSET_PWM_BASE(n))
+#define OFFSET_PWM_STATUS2(n)		(0x028 + OFFSET_PWM_BASE(n))
+
+struct fh_pwm_driver
+{
+	unsigned int irq;
+	struct pwm_chip chip;
+	void __iomem *base;
+	struct clk *clk;
+	struct proc_dir_entry *proc_file;
+};
+
+struct fh_pwm_driver *fh_pwm_drv;
+
+static void fh_pwm_output_mask(unsigned int mask)
+{
+	writel(mask, fh_pwm_drv->base + OFFSET_PWM_GLOBAL_CTRL2);
+}
+
+static void fh_pwm_output_enable(unsigned int n)
+{
+	unsigned int reg;
+
+	reg = readl(fh_pwm_drv->base + OFFSET_PWM_GLOBAL_CTRL2);
+	reg |= (1 << n);
+	writel(reg, fh_pwm_drv->base + OFFSET_PWM_GLOBAL_CTRL2);
+}
+
+static void fh_pwm_output_disable(unsigned int n)
+{
+	unsigned int reg;
+
+	reg = readl(fh_pwm_drv->base + OFFSET_PWM_GLOBAL_CTRL1);
+	reg |= 1 << (8 + n);
+	writel(reg, fh_pwm_drv->base + OFFSET_PWM_GLOBAL_CTRL1);
+
+	reg = readl(fh_pwm_drv->base + OFFSET_PWM_GLOBAL_CTRL2);
+	reg &= ~(1 << n);
+	writel(reg, fh_pwm_drv->base + OFFSET_PWM_GLOBAL_CTRL2);
+}
+
+static void fh_pwm_config_enable(unsigned int n)
+{
+	unsigned int reg;
+
+	reg = readl(fh_pwm_drv->base + OFFSET_PWM_GLOBAL_CTRL0);
+	reg |= (1 << n);
+	writel(reg, fh_pwm_drv->base + OFFSET_PWM_GLOBAL_CTRL0);
+}
+
+static void fh_pwm_config_disable(unsigned int n)
+{
+	unsigned int reg;
+
+	reg = readl(fh_pwm_drv->base + OFFSET_PWM_GLOBAL_CTRL0);
+	reg &= ~(1 << n);
+	writel(reg, fh_pwm_drv->base + OFFSET_PWM_GLOBAL_CTRL0);
+}
+
+static void fh_pwm_shadow_enable(unsigned int n)
+{
+	unsigned int reg;
+
+	reg = readl(fh_pwm_drv->base + OFFSET_PWM_GLOBAL_CTRL1);
+	reg |= (1 << n);
+	writel(reg, fh_pwm_drv->base + OFFSET_PWM_GLOBAL_CTRL1);
+}
+
+static void fh_pwm_shadow_disable(unsigned int n)
+{
+	unsigned int reg;
+
+	reg = readl(fh_pwm_drv->base + OFFSET_PWM_GLOBAL_CTRL1);
+	reg &= ~(1 << n);
+	writel(reg, fh_pwm_drv->base + OFFSET_PWM_GLOBAL_CTRL1);
+}
+
+static void fh_pwm_interrupt_finishall_enable(unsigned int n)
+{
+	unsigned int reg;
+
+	reg = readl(fh_pwm_drv->base + OFFSET_PWM_INT_ENABLE);
+	reg |= (1 << n);
+	writel(reg, fh_pwm_drv->base + OFFSET_PWM_INT_ENABLE);
+}
+
+static void fh_pwm_interrupt_finishall_disable(unsigned int n)
+{
+	unsigned int reg;
+
+	reg = readl(fh_pwm_drv->base + OFFSET_PWM_INT_ENABLE);
+	reg &= ~(1 << n);
+	writel(reg, fh_pwm_drv->base + OFFSET_PWM_INT_ENABLE);
+}
+
+static void fh_pwm_interrupt_finishonce_enable(unsigned int n)
+{
+	unsigned int reg;
+
+	reg = readl(fh_pwm_drv->base + OFFSET_PWM_INT_ENABLE);
+	reg |= (1 << (n + 8));
+	writel(reg, fh_pwm_drv->base + OFFSET_PWM_INT_ENABLE);
+}
+
+static void fh_pwm_interrupt_finishonce_disable(unsigned int n)
+{
+	unsigned int reg;
+
+	reg = readl(fh_pwm_drv->base + OFFSET_PWM_INT_ENABLE);
+	reg &= ~(1 << (n + 8));
+	writel(reg, fh_pwm_drv->base + OFFSET_PWM_INT_ENABLE);
+}
+
+static unsigned int fh_pwm_interrupt_get_status(void)
+{
+	unsigned int reg;
+
+	reg = readl(fh_pwm_drv->base + OFFSET_PWM_INT_STATUS);
+	reg &= readl(fh_pwm_drv->base + OFFSET_PWM_INT_ENABLE);
+
+	return reg;
+}
+
+static void fh_pwm_interrupt_finishonce_clear(unsigned int n)
+{
+	unsigned int reg;
+
+	reg = readl(fh_pwm_drv->base + OFFSET_PWM_INT_STATUS);
+
+	reg &= ~(1 << (n + 8));
+
+	return writel(reg, fh_pwm_drv->base + OFFSET_PWM_INT_STATUS);
+}
+
+static void fh_pwm_interrupt_finishall_clear(unsigned int n)
+{
+	unsigned int reg;
+
+	reg = readl(fh_pwm_drv->base + OFFSET_PWM_INT_STATUS);
+
+	reg &= ~(1 << n);
+
+	return writel(reg, fh_pwm_drv->base + OFFSET_PWM_INT_STATUS);
+}
+
+static void fh_pwm_set_config(struct fh_pwm_chip_data *chip_data)
+{
+	unsigned int clk_rate = clk_get_rate(fh_pwm_drv->clk);
+	unsigned int ctrl = 0, period, duty, delay, phase;
+
+	fh_pwm_config_disable(chip_data->id);
+
+	period = chip_data->config.period_ns / (NSEC_PER_SEC / clk_rate);
+	duty = chip_data->config.duty_ns / (NSEC_PER_SEC / clk_rate);
+	delay = chip_data->config.delay_ns / (NSEC_PER_SEC / clk_rate);
+	phase = chip_data->config.phase_ns / (NSEC_PER_SEC / clk_rate);
+
+	if (period > 0x1ffffff) {
+		pr_err("PWM: period exceed 24-bit\n");
+		period = 0x1ffffff;
+	}
+
+	if (duty > 0x1ffffff) {
+		pr_err("PWM: duty exceed 24-bit\n");
+		duty = 0x1ffffff;
+	}
+
+	PRINT_DBG("set period: 0x%x\n", period);
+	PRINT_DBG("set duty: 0x%x\n", duty);
+	PRINT_DBG("set phase: 0x%x\n", phase);
+	PRINT_DBG("set delay: 0x%x\n", delay);
+
+	writel(period, fh_pwm_drv->base + OFFSET_PWM_CFG0(chip_data->id));
+	writel(duty, fh_pwm_drv->base + OFFSET_PWM_CFG1(chip_data->id));
+	writel(phase, fh_pwm_drv->base + OFFSET_PWM_CFG2(chip_data->id));
+	writel(delay, fh_pwm_drv->base + OFFSET_PWM_CFG3(chip_data->id));
+	writel(chip_data->config.pulses,
+			fh_pwm_drv->base + OFFSET_PWM_CFG4(chip_data->id));
+
+	if (chip_data->config.delay_ns)
+		ctrl |= 1 << 3;
+
+	if(!chip_data->config.pulses)
+		ctrl |= 1 << 0;
+
+	ctrl |= (chip_data->config.stop & 0x3) << 1;
+
+	writel(ctrl, fh_pwm_drv->base + OFFSET_PWM_CTRL(chip_data->id));
+
+	PRINT_DBG("set ctrl: 0x%x\n", ctrl);
+
+	ctrl = readl(fh_pwm_drv->base + OFFSET_PWM_GLOBAL_CTRL1);
+
+	ctrl |= (chip_data->config.stop >> 4) << (8 + chip_data->id);
+
+	writel(ctrl, fh_pwm_drv->base + OFFSET_PWM_GLOBAL_CTRL1);
+
+	writel(chip_data->config.pulses,
+		fh_pwm_drv->base + OFFSET_PWM_CFG4(chip_data->id));
+	PRINT_DBG("set pulses: 0x%x\n", chip_data->config.pulses);
+
+	if (chip_data->config.finish_once)
+		fh_pwm_interrupt_finishonce_enable(chip_data->id);
+	else
+		fh_pwm_interrupt_finishonce_disable(chip_data->id);
+
+	if (chip_data->config.finish_all)
+		fh_pwm_interrupt_finishall_enable(chip_data->id);
+	else
+		fh_pwm_interrupt_finishall_disable(chip_data->id);
+
+	if (chip_data->config.shadow_enable)
+		fh_pwm_shadow_enable(chip_data->id);
+	else
+		fh_pwm_shadow_disable(chip_data->id);
+
+	fh_pwm_config_enable(chip_data->id);
+
+}
+
+static void fh_pwm_get_config(struct fh_pwm_chip_data *chip_data)
+{
+	unsigned int clk_rate = clk_get_rate(fh_pwm_drv->clk);
+	unsigned int ctrl = 0, period, duty, delay, phase, pulses,
+			status0, status1, status2;
+
+	period = readl(fh_pwm_drv->base + OFFSET_PWM_CFG0(chip_data->id));
+	duty = readl(fh_pwm_drv->base + OFFSET_PWM_CFG1(chip_data->id));
+	phase = readl(fh_pwm_drv->base + OFFSET_PWM_CFG2(chip_data->id));
+	delay = readl(fh_pwm_drv->base + OFFSET_PWM_CFG3(chip_data->id));
+	pulses = readl(fh_pwm_drv->base + OFFSET_PWM_CFG4(chip_data->id));
+	ctrl = readl(fh_pwm_drv->base + OFFSET_PWM_CTRL(chip_data->id));
+	status0 = readl(fh_pwm_drv->base + OFFSET_PWM_STATUS0(chip_data->id));
+	status1 = readl(fh_pwm_drv->base + OFFSET_PWM_STATUS1(chip_data->id));
+	status2 = readl(fh_pwm_drv->base + OFFSET_PWM_STATUS2(chip_data->id));
+
+
+	PRINT_DBG("==============================\n");
+	PRINT_DBG("pwm%d register config:\n", chip_data->id);
+	PRINT_DBG("\t\tperiod: 0x%x\n", period);
+	PRINT_DBG("\t\tduty: 0x%x\n", duty);
+	PRINT_DBG("\t\tphase: 0x%x\n", phase);
+	PRINT_DBG("\t\tdelay: 0x%x\n", delay);
+	PRINT_DBG("\t\tpulses: 0x%x\n", pulses);
+	PRINT_DBG("\t\tctrl: 0x%x\n", ctrl);
+	PRINT_DBG("\t\tstatus0: 0x%x\n", status0);
+	PRINT_DBG("\t\tstatus1: 0x%x\n", status1);
+	PRINT_DBG("\t\tstatus2: 0x%x\n", status2);
+
+	chip_data->config.period_ns = period * (NSEC_PER_SEC / clk_rate);
+	chip_data->config.duty_ns = duty * (NSEC_PER_SEC / clk_rate);
+
+	PRINT_DBG("\t\tclk_rate: %d\n", clk_rate);
+	PRINT_DBG("\t\tconfig.period_ns: %d\n", chip_data->config.period_ns);
+	PRINT_DBG("\t\tconfig.duty_ns: %d\n", chip_data->config.duty_ns);
+	PRINT_DBG("==============================\n\n");
+
+	chip_data->config.phase_ns = phase * (NSEC_PER_SEC / clk_rate);
+	chip_data->config.delay_ns = delay * (NSEC_PER_SEC / clk_rate);
+	chip_data->config.pulses = pulses;
+	chip_data->config.stop = (ctrl >> 1) & 0x3;
+	chip_data->config.percent = chip_data->config.duty_ns /
+			(chip_data->config.period_ns / 100);
+
+	chip_data->status.busy = (status2 >> 4) & 0x1;
+	chip_data->status.error = (status2 >> 3) & 0x1;
+	chip_data->status.total_cnt = status1;
+	chip_data->status.done_cnt = status0;
+}
+
+int fh_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
+		  int duty_ns, int period_ns)
+{
+	struct fh_pwm_chip_data *chip_data;
+
+	chip_data = kzalloc(sizeof(struct fh_pwm_chip_data), GFP_KERNEL);
+	if (chip_data == NULL) {
+		pr_err("pwm[%d], chip data malloc failed\n", pwm->hwpwm);
+		return -ENOMEM;
+	}
+
+	chip_data->id = pwm->hwpwm;
+	chip_data->config.duty_ns = duty_ns;
+	chip_data->config.period_ns = period_ns;
+
+	fh_pwm_set_config(chip_data);
+
+	kfree(chip_data);
+
+	return 0;
+}
+
+int fh_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	fh_pwm_output_enable(pwm->hwpwm);
+	return 0;
+}
+
+void fh_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	fh_pwm_output_disable(pwm->hwpwm);
+}
+
+static int fh_pwm_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int fh_pwm_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+
+static long fh_pwm_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+	struct fh_pwm_chip_data *chip_data;
+	unsigned int val;
+
+	if (unlikely(_IOC_TYPE(cmd) != PWM_IOCTL_MAGIC)) {
+		pr_err("%s: ERROR: incorrect magic num %d (error: %d)\n",
+			__func__, _IOC_TYPE(cmd), -ENOTTY);
+		return -ENOTTY;
+	}
+
+	if (unlikely(_IOC_NR(cmd) > PWM_IOCTL_MAXNR)) {
+		pr_err("%s: ERROR: incorrect cmd num %d (error: %d)\n",
+			__func__, _IOC_NR(cmd), -ENOTTY);
+		return -ENOTTY;
+	}
+
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		ret = !access_ok(VERIFY_WRITE,
+			(void __user *)arg, _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		ret = !access_ok(VERIFY_READ,
+			(void __user *)arg, _IOC_SIZE(cmd));
+
+	if (ret) {
+		pr_err("%s: ERROR: user space access is not permitted %d (error: %d)\n",
+		       __func__, _IOC_NR(cmd), -EACCES);
+		return -EACCES;
+	}
+
+	switch (cmd) {
+	case SET_PWM_ENABLE:
+		get_user(val, (unsigned int __user *)&arg);
+		fh_pwm_output_enable(val);
+		break;
+	case ENABLE_PWM:
+		chip_data = (struct fh_pwm_chip_data __user *)arg;
+		ret = copy_from_user(
+			fh_pwm_drv->chip.pwms[chip_data->id].chip_data,
+			(struct fh_pwm_chip_data __user *)arg,
+			sizeof(struct fh_pwm_chip_data));
+		fh_pwm_output_enable(chip_data->id);
+		break;
+	case DISABLE_PWM:
+		chip_data = (struct fh_pwm_chip_data __user *)arg;
+		ret = copy_from_user(
+			fh_pwm_drv->chip.pwms[chip_data->id].chip_data,
+			(struct fh_pwm_chip_data __user *)arg,
+			sizeof(struct fh_pwm_chip_data));
+		fh_pwm_output_disable(chip_data->id);
+		break;
+	case SET_PWM_DUTY_CYCLE:
+		chip_data = (struct fh_pwm_chip_data __user *)arg;
+		ret = copy_from_user(
+			fh_pwm_drv->chip.pwms[chip_data->id].chip_data,
+			(struct fh_pwm_chip_data __user *)arg,
+			sizeof(struct fh_pwm_chip_data));
+		printk("ioctl: SET_PWM_DUTY_CYCLE, "
+			"pwm->id: %d, pwm->counter: %d, pwm->period: %d ns\n",
+			chip_data->id, chip_data->config.duty_ns,
+			chip_data->config.period_ns);
+		fh_pwm_set_config(chip_data);
+		break;
+	case GET_PWM_DUTY_CYCLE:
+		chip_data = (struct fh_pwm_chip_data __user *)arg;
+		ret = copy_from_user(
+			fh_pwm_drv->chip.pwms[chip_data->id].chip_data,
+			(struct fh_pwm_chip_data __user *)arg,
+			sizeof(struct fh_pwm_chip_data));
+		printk("ioctl: GET_PWM_DUTY_CYCLE, "
+			"pwm->id: %d, pwm->counter: %d, pwm->period: %d ns\n",
+			chip_data->id, chip_data->config.duty_ns,
+			chip_data->config.period_ns);
+		fh_pwm_get_config(chip_data);
+		break;
+	case SET_PWM_DUTY_CYCLE_PERCENT:
+		chip_data = (struct fh_pwm_chip_data __user *)arg;
+		ret = copy_from_user(
+			fh_pwm_drv->chip.pwms[chip_data->id].chip_data,
+			(struct fh_pwm_chip_data __user *)arg,
+			sizeof(struct fh_pwm_chip_data));
+		if(chip_data->config.percent > 100)
+		{
+			pr_err("ERROR: percentage is over 100\n");
+			return -EIO;
+		}
+		chip_data->config.duty_ns = chip_data->config.period_ns *
+				chip_data->config.percent / 100;
+		printk("ioctl: SET_PWM_DUTY_CYCLE_PERCENT, "
+			"pwm->id: %d, pwm->counter: %d, pwm->period: %d ns\n",
+			chip_data->id, chip_data->config.duty_ns,
+			chip_data->config.period_ns);
+		fh_pwm_set_config(chip_data);
+		break;
+	}
+
+
+	return ret;
+}
+
+static const struct file_operations fh_pwm_fops =
+{
+	.owner			= THIS_MODULE,
+	.open			= fh_pwm_open,
+	.release		= fh_pwm_release,
+	.unlocked_ioctl		= fh_pwm_ioctl,
+};
+
+static struct miscdevice fh_pwm_misc =
+{
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = DEVICE_NAME,
+	.fops = &fh_pwm_fops,
+};
+
+static const struct pwm_ops fh_pwm_ops =
+{
+	.config = fh_pwm_config,
+	.enable = fh_pwm_enable,
+	.disable = fh_pwm_disable,
+	.owner = THIS_MODULE,
+};
+
+
+static void del_char(char *str, char ch)
+{
+	char *p = str;
+	char *q = str;
+	while (*q) {
+		if (*q != ch)
+			*p++ = *q;
+		q++;
+	}
+	*p = '\0';
+}
+
+static ssize_t fh_pwm_proc_write(struct file *filp,
+                                 const char *buf, size_t len, loff_t *off)
+{
+	int i;
+	char message[64] = {0};
+	char *const delim = ",";
+	char *cur = message;
+	char *param_str[8];
+	unsigned int param[8];
+	struct fh_pwm_chip_data *chip_data;
+
+	len = (len > 64) ? 64 : len;
+
+	if (copy_from_user(message, buf, len))
+		return -EFAULT;
+
+	for (i = 0; i < 8; i++) {
+		param_str[i] = strsep(&cur, delim);
+		if (!param_str[i]) {
+			pr_err("%s: ERROR: parameter[%d] is empty\n",
+                               __func__, i);
+			pr_err("id, switch_mask, duty_ns, period_ns, "
+                               "numofpules, delay_ns, phase_ns, stop_status\n");
+			pr_err("eg. echo '0,1,5000,10000,0,0,1000,0' > /proc/driver/pwm\n");
+			return -EINVAL;
+		} else {
+			del_char(param_str[i], ' ');
+			del_char(param_str[i], '\n');
+			param[i] = (unsigned int)simple_strtoul(param_str[i], NULL, 10);
+			if (param[i] < 0)
+			{
+				pr_err("%s: ERROR: parameter[%d] is incorrect\n", __func__, i);
+				pr_err("id, switch_mask, duty_ns, period_ns, numofpules, "
+                                       "delay_ns, phase_ns, stop_status\n");
+				pr_err("eg. echo '0,1,5000,10000,0,0,1000,0' > /proc/driver/pwm\n");
+				return -EINVAL;
+			}
+		}
+	}
+
+	chip_data = kzalloc(sizeof(struct fh_pwm_chip_data), GFP_KERNEL);
+	if (chip_data == NULL) {
+		pr_err("pwm[%d], chip data malloc failed\n", i);
+		return 0;
+	}
+
+	chip_data->id = param[0];
+	chip_data->config.duty_ns = param[2];
+	chip_data->config.period_ns = param[3];
+	chip_data->config.pulses = param[4];
+	chip_data->config.delay_ns = param[5];
+	chip_data->config.phase_ns = param[6];
+	chip_data->config.stop = param[7];
+
+	fh_pwm_set_config(chip_data);
+
+	printk("set pwm %d, enable: 0x%x, duty cycle: %u ns, period cycle: %u,"
+			"numofpulse: %d, delay: %d ns, phase: %d ns, stop: %d\n",
+			param[0], param[1], param[2], param[3],
+					param[4], param[5], param[6], param[7]);
+
+	fh_pwm_output_mask(param[1]);
+
+	kfree(chip_data);
+
+	return len;
+}
+
+static void *v_seq_start(struct seq_file *s, loff_t *pos)
+{
+	static unsigned long counter = 0;
+	if (*pos == 0)
+		return &counter;
+	else {
+		*pos = 0;
+		return NULL;
+	}
+}
+
+static void *v_seq_next(struct seq_file *s, void *v, loff_t *pos)
+{
+	(*pos)++;
+	return NULL;
+}
+
+static void v_seq_stop(struct seq_file *s, void *v)
+{
+
+}
+
+static int v_seq_show(struct seq_file *sfile, void *v)
+{
+	int i;
+	seq_printf(sfile, "\nPWM Status:\n");
+
+	seq_printf(sfile, "global_ctrl0: 0x%x\n",
+                   readl(fh_pwm_drv->base + OFFSET_PWM_GLOBAL_CTRL0));
+	seq_printf(sfile, "global_ctrl1: 0x%x\n",
+                   readl(fh_pwm_drv->base + OFFSET_PWM_GLOBAL_CTRL1));
+	seq_printf(sfile, "global_ctrl2: 0x%x\n",
+                   readl(fh_pwm_drv->base + OFFSET_PWM_GLOBAL_CTRL2));
+
+	for (i = 0; i < fh_pwm_drv->chip.npwm; i++) {
+		struct fh_pwm_chip_data *chip_data;
+
+		chip_data = pwm_get_chip_data(&fh_pwm_drv->chip.pwms[i]);
+		fh_pwm_get_config(chip_data);
+
+		seq_printf(sfile, "id: %d \t%s, duty_ns: %u, period_ns: %u\n",
+			   chip_data->id,
+			   (chip_data->status.busy) ? "ENABLE" : "DISABLE",
+			   chip_data->config.duty_ns,
+			   chip_data->config.period_ns);
+	}
+	return 0;
+}
+
+static const struct seq_operations pwm_seq_ops =
+{
+	.start = v_seq_start,
+	.next = v_seq_next,
+	.stop = v_seq_stop,
+	.show = v_seq_show
+};
+
+static int fh_pwm_proc_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &pwm_seq_ops);
+}
+
+
+static struct file_operations fh_pwm_proc_ops =
+{
+	.owner	= THIS_MODULE,
+	.open	= fh_pwm_proc_open,
+	.read	= seq_read,
+	.write	= fh_pwm_proc_write,
+	.release = seq_release,
+};
+
+static irqreturn_t fh_pwm_interrupt(int this_irq, void *param)
+{
+	unsigned int status, stat_once, stat_all;
+	struct fh_pwm_chip_data *chip_data;
+	unsigned int irq;
+
+	status = fh_pwm_interrupt_get_status();
+
+	status &= 0xffff;
+
+	stat_once = (status >> 8) & 0xff;
+	stat_all = status & 0xff;
+
+	if(stat_once) {
+		irq = fls(stat_once);
+		chip_data = pwm_get_chip_data(&fh_pwm_drv->chip.pwms[irq - 1]);
+		if(chip_data && chip_data->finishonce_callback) {
+			/* chip_data->finishonce_callback(chip_data); */
+		} else {
+			pr_err("callback is empty, status: 0x%x\n", status);
+		}
+		fh_pwm_interrupt_finishonce_clear(irq - 1);
+		fh_pwm_interrupt_finishonce_disable(irq - 1);
+		fh_pwm_interrupt_finishonce_enable(irq - 1);
+	}
+
+	if(stat_all) {
+		irq = fls(stat_all);
+		chip_data = pwm_get_chip_data(&fh_pwm_drv->chip.pwms[irq - 1]);
+		if(chip_data && chip_data->finishonce_callback) {
+			/* chip_data->finishall_callback(chip_data); */
+		} else {
+			pr_err("callback is empty, status: 0x%x\n", status);
+		}
+		fh_pwm_interrupt_finishall_clear(irq - 1);
+		fh_pwm_interrupt_finishall_disable(irq - 1);
+		fh_pwm_interrupt_finishall_enable(irq - 1);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int __devinit fh_pwm_probe(struct platform_device *pdev)
+{
+	int err, i;
+	struct resource *res;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		err = -ENXIO;
+		goto fail_no_mem_resource;
+	}
+
+	res = request_mem_region(res->start, resource_size(res), pdev->name);
+	if (res == NULL) {
+		err = -EBUSY;
+		goto fail_no_mem_resource;
+	}
+
+	fh_pwm_drv = kzalloc(sizeof(struct fh_pwm_driver), GFP_KERNEL);
+
+	fh_pwm_drv->base = ioremap(res->start, resource_size(res));
+	if (fh_pwm_drv->base == NULL) {
+		err = -ENXIO;
+		goto fail_no_ioremap;
+	}
+
+	fh_pwm_drv->clk = clk_get(&pdev->dev, "pwm_clk");
+
+	if (IS_ERR(fh_pwm_drv->clk)) {
+		err = PTR_ERR(fh_pwm_drv->clk);
+		goto fail_no_clk;
+	}
+
+	clk_enable(fh_pwm_drv->clk);
+
+	PRINT_DBG("%s: clk_rate: %lu\n", __func__, clk_get_rate(fh_pwm_drv->clk));
+
+	err = platform_get_irq(pdev, 0);
+	if (err < 0) {
+		dev_err(&pdev->dev, "no irq resource?\n");
+		goto fail_no_clk;
+	}
+
+	fh_pwm_drv->irq = err;
+
+	err = request_irq(fh_pwm_drv->irq,
+                          fh_pwm_interrupt, IRQF_DISABLED, pdev->name, fh_pwm_drv);
+	if (err) {
+		dev_err(&pdev->dev, "failure requesting irq %i\n", fh_pwm_drv->irq);
+		goto fail_no_clk;
+	}
+
+	err = misc_register(&fh_pwm_misc);
+	if (err < 0) {
+		pr_err("%s: ERROR: %s registration failed",
+		       __func__, DEVICE_NAME);
+		return -ENXIO;
+	}
+
+	fh_pwm_drv->chip.dev = &pdev->dev;
+	fh_pwm_drv->chip.ops = &fh_pwm_ops;
+	fh_pwm_drv->chip.base = pdev->id;
+	fh_pwm_drv->chip.npwm = CONFIG_FH_PWM_NUM;
+
+	err = pwmchip_add(&fh_pwm_drv->chip);
+	if (err < 0) {
+		pr_err("%s: ERROR: %s pwmchip_add failed",
+		       __func__, DEVICE_NAME);
+		return err;
+	}
+
+	for (i = 0; i < fh_pwm_drv->chip.npwm; i++) {
+		struct fh_pwm_chip_data *chip_data;
+
+		chip_data = kzalloc(sizeof(struct fh_pwm_chip_data), GFP_KERNEL);
+		if (chip_data == NULL) {
+			pr_err("pwm[%d], chip data malloc failed\n", i);
+			continue;
+		}
+
+		chip_data->id = i;
+
+		pwm_set_chip_data(&fh_pwm_drv->chip.pwms[i], chip_data);
+	}
+
+	fh_pwm_output_mask(0);
+
+	platform_set_drvdata(pdev, fh_pwm_drv);
+
+	pr_info("PWM driver, Number: %d, IO base addr: 0x%p\n",
+			fh_pwm_drv->chip.npwm, fh_pwm_drv->base);
+
+	fh_pwm_drv->proc_file = create_proc_entry(FH_PWM_PROC_FILE, 0644, NULL);
+
+	if (fh_pwm_drv->proc_file)
+		fh_pwm_drv->proc_file->proc_fops = &fh_pwm_proc_ops;
+	else
+		pr_err("%s: ERROR: %s proc file create failed",
+		       __func__, DEVICE_NAME);
+
+	dev_dbg(&pdev->dev, "PWM probe successful, IO base addr: %p\n",
+		fh_pwm_drv->base);
+	return 0;
+
+fail_no_clk:
+	iounmap(fh_pwm_drv->base);
+fail_no_ioremap:
+	release_mem_region(res->start, resource_size(res));
+fail_no_mem_resource:
+	return err;
+}
+
+static int __exit fh_pwm_remove(struct platform_device *pdev)
+{
+	int err, i;
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	for (i = 0; i < fh_pwm_drv->chip.npwm; i++)
+		kfree(fh_pwm_drv->chip.pwms[i].chip_data);
+
+	err = pwmchip_remove(&fh_pwm_drv->chip);
+	if (err < 0)
+		return err;
+
+	dev_dbg(&pdev->dev, "pwm driver removed\n");
+
+	fh_pwm_output_mask(0);
+	clk_disable(fh_pwm_drv->clk);
+	free_irq(fh_pwm_drv->irq, NULL);
+	iounmap(fh_pwm_drv->base);
+	release_mem_region(res->start, resource_size(res));
+	platform_set_drvdata(pdev, NULL);
+	misc_deregister(&fh_pwm_misc);
+
+	free(fh_pwm_drv);
+	fh_pwm_drv = NULL;
+
+	return 0;
+}
+
+static struct platform_driver fh_pwm_driver =
+{
+	.driver	=
+	{
+		.name = DEVICE_NAME,
+		.owner = THIS_MODULE,
+	},
+	.probe		= fh_pwm_probe,
+	.remove		= __exit_p(fh_pwm_remove),
+};
+
+static int __init fh_pwm_init(void)
+{
+	return platform_driver_register(&fh_pwm_driver);
+}
+
+static void __exit fh_pwm_exit(void)
+{
+
+	platform_driver_unregister(&fh_pwm_driver);
+
+}
+
+module_init(fh_pwm_init);
+module_exit(fh_pwm_exit);
+
+
+MODULE_AUTHOR("fullhan");
+
+MODULE_DESCRIPTION("FH PWM driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(MISC_DYNAMIC_MINOR);
diff -uraN linux-3.0.8/drivers/pwm/pwmv2-fullhan.h linux-3.0.8-fh8632-V1.0_20180330/drivers/pwm/pwmv2-fullhan.h
--- linux-3.0.8/drivers/pwm/pwmv2-fullhan.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/pwm/pwmv2-fullhan.h	2021-07-13 23:40:35.586368043 +0300
@@ -0,0 +1,63 @@
+#ifndef FH_PMU_H_
+#define FH_PMU_H_
+
+#include <linux/slab.h>
+#include <linux/ioctl.h>
+
+#define DEVICE_NAME				"fh_pwm"
+#define FH_PWM_PROC_FILE			"driver/pwm"
+
+#define REG_PWM_CTRL				(0x00)
+#define REG_PWM_CMD(n)				(((n) * 4) + REG_PWM_CTRL + 4)
+
+#define PWM_IOCTL_MAGIC 			'p'
+#define ENABLE_PWM	 			_IOWR(PWM_IOCTL_MAGIC, 0, __u32)
+#define DISABLE_PWM		 		_IOWR(PWM_IOCTL_MAGIC, 1, __u32)
+
+#define SET_PWM_DUTY_CYCLE			_IOWR(PWM_IOCTL_MAGIC, 2, __u32)
+#define GET_PWM_DUTY_CYCLE 		    	_IOWR(PWM_IOCTL_MAGIC, 3, __u32)
+#define SET_PWM_DUTY_CYCLE_PERCENT  		_IOWR(PWM_IOCTL_MAGIC, 4, __u32)
+#define SET_PWM_ENABLE		 		_IOWR(PWM_IOCTL_MAGIC, 5, __u32)
+
+#define PWM_IOCTL_MAXNR 			8
+
+struct fh_pwm_config
+{
+	unsigned int period_ns;
+	unsigned int duty_ns;
+	unsigned int pulses;
+#define FH_PWM_STOPLVL_LOW		(0x0)
+#define FH_PWM_STOPLVL_HIGH		(0x3)
+#define FH_PWM_STOPLVL_KEEP		(0x1)
+
+#define FH_PWM_STOPCTRL_ATONCE		(0x00)
+#define FH_PWM_STOPCTRL_AFTERFINISH	(0x10)
+	unsigned int stop;
+	unsigned int delay_ns;
+	unsigned int phase_ns;
+	unsigned int percent;
+	unsigned int finish_once;
+	unsigned int finish_all;
+	unsigned int shadow_enable;
+};
+
+struct fh_pwm_status
+{
+	unsigned int done_cnt;
+	unsigned int total_cnt;
+	unsigned int busy;
+	unsigned int error;
+};
+
+struct fh_pwm_chip_data
+{
+	int id;
+	struct fh_pwm_config config;
+	struct fh_pwm_status status;
+	void (*finishall_callback)(struct fh_pwm_chip_data *data);
+	void (*finishonce_callback)(struct fh_pwm_chip_data *data);
+};
+
+
+
+#endif /* FH_PMU_H_ */
diff -uraN linux-3.0.8/drivers/rtc/Kconfig linux-3.0.8-fh8632-V1.0_20180330/drivers/rtc/Kconfig
--- linux-3.0.8/drivers/rtc/Kconfig	2021-07-14 21:52:03.599135696 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/rtc/Kconfig	2021-07-13 23:40:36.482373387 +0300
@@ -1060,4 +1060,15 @@
 	  This drive can also be built as a module. If so, the module
 	  will be called rtc-puv3.
 
+
+config RTC_DRV_FH
+	tristate "FH On-Chip RTC"
+	depends on RTC_CLASS 
+	help
+	  Say Y here to enable support for the on-chip RTC found in
+	  FH processors.
+
+ 	  To compile this driver as a module, choose M here: the
+	  module will be called rtc-fh.
+
 endif # RTC_CLASS
diff -uraN linux-3.0.8/drivers/rtc/Makefile linux-3.0.8-fh8632-V1.0_20180330/drivers/rtc/Makefile
--- linux-3.0.8/drivers/rtc/Makefile	2021-07-14 21:52:03.599135696 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/rtc/Makefile	2021-07-13 23:40:36.474373340 +0300
@@ -108,3 +108,5 @@
 obj-$(CONFIG_RTC_DRV_WM831X)	+= rtc-wm831x.o
 obj-$(CONFIG_RTC_DRV_WM8350)	+= rtc-wm8350.o
 obj-$(CONFIG_RTC_DRV_X1205)	+= rtc-x1205.o
+
+obj-$(CONFIG_RTC_DRV_FH)	+= rtc-fh.o
\ No newline at end of file
diff -uraN linux-3.0.8/drivers/rtc/rtc-fh.c linux-3.0.8-fh8632-V1.0_20180330/drivers/rtc/rtc-fh.c
--- linux-3.0.8/drivers/rtc/rtc-fh.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/rtc/rtc-fh.c	2021-07-13 23:40:36.478373364 +0300
@@ -0,0 +1,902 @@
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/rtc.h>
+#include <linux/bcd.h>
+#include <linux/clk.h>
+#include <linux/log2.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <mach/rtc.h>
+#include <mach/fh_sadc.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+
+/* #define FH_RTC_DEBUG_PRINT */
+
+#ifdef FH_RTC_DEBUG_PRINT
+#define RTC_PRINT_DBG(fmt, args...) \
+	printk(KERN_INFO "[FH_RTC_DEBUG]: "); \
+	printk(fmt, ## args)
+#else
+#define RTC_PRINT_DBG(fmt, args...)  do { } while (0)
+#endif
+
+#define RTC_MAGIC	0x55555555
+#define RTC_PHASE	0x03840384
+
+#define SYNC_LOOP_COUNT 100
+
+struct fh_rtc_controller {
+	void * __iomem regs;
+	unsigned int irq;
+	unsigned int paddr;
+	unsigned int base_year;
+	unsigned int base_month;
+	unsigned int base_day;
+	struct rtc_device *rtc;
+	struct clk *clk;
+	struct proc_dir_entry *proc_rtc_entry;
+	int sadc_channel;
+
+	struct workqueue_struct *wq;
+	struct delayed_work self_adjust;
+};
+
+struct fh_rtc_controller *fh_rtc;
+
+enum {
+
+	TIME_FUNC = 0,
+	ALARM_FUNC,
+
+};
+
+/* value of SADC channel for reference to get current temperature */
+long SadcValue[28] = {
+	260, 293, 332, 375, 426,
+	483, 548, 621, 706, 800,
+	906, 1022, 1149, 1287, 1435,
+	1590, 1750, 1913, 2075, 2233,
+	2385, 2527, 2656, 2772, 2873,
+	2960, 3034, 3094
+};
+
+/* value of temperature for reference */
+int Temperature1[28] = {
+	95000, 90000, 85000, 80000, 75000,
+	70000, 65000, 60000, 55000, 50000,
+	45000, 40000, 35000, 30000, 25000,
+	20000, 15000, 10000, 4000, 0,
+	-5000, -10000, -15000, -20000, -25000,
+	-30000, -35000, -40000
+};
+
+/* value of temperature for reference to get current deviation */
+int Temperature2[136] = {
+	-40000, -39000, -38000, -37000, -36000, -35000,
+	-34000, -33000, -32000, -31000, -30000, -29000,
+	-28000, -27000, -26000, -25000, -24000, -23000,
+	-22000, -21000, -20000, -19000, -18000, -17000,
+	-16000, -15000, -14000, -13000, -12000, -11000,
+	-10000, -9000, -8000, -7000, -6000, -5000, -4000,
+	-3000, -2000, -1000, 0, 1000, 2000, 3000, 4000,
+	5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000,
+	13000, 14000, 15000, 16000, 17000, 18000, 19000,
+	20000, 21000, 22000, 23000, 24000, 25000, 26000,
+	27000, 28000, 29000, 30000, 31000, 32000, 33000,
+	34000, 35000, 36000, 37000, 38000, 39000, 40000,
+	41000, 42000, 43000, 44000, 45000, 46000, 47000,
+	48000, 49000, 50000, 51000, 52000, 53000, 54000,
+	55000, 56000, 57000, 58000, 59000, 60000, 61000,
+	62000, 63000, 64000, 65000, 66000, 67000, 68000,
+	69000, 70000, 71000, 72000, 73000, 74000, 75000,
+	76000, 77000, 78000, 79000, 80000, 81000, 82000,
+	83000, 84000, 85000, 86000, 87000, 88000, 89000,
+	90000, 91000, 92000, 93000, 94000, 95000
+};
+
+/* the value of deviation to adjust rtc clock */
+long Deviation[136] = {
+	1690000, 1638400, 1587600, 1537600, 1488400, 1440000,
+	1392400, 1345600, 1299600, 1254400, 1210000, 1166400,
+	1123600, 1081600, 1040400, 1000000, 960400, 921600,
+	883600, 846400, 810000, 774400, 739600, 705600, 672400,
+	640000, 608400, 577600, 547600, 518400, 490000, 462400,
+	435600, 409600, 384400, 360000, 336400, 313600, 291600,
+	270400, 250000, 230400, 211600, 193600, 176400, 160000,
+	144400, 129600, 115600, 102400, 90000, 78400, 67600, 57600,
+	48400, 40000, 32400, 25600, 19600, 14400, 10000, 6400,
+	3600, 1600, 400, 0, 400, 1600, 3600, 6400, 10000, 14400,
+	19600, 25600, 32400, 40000, 48400, 57600, 67600, 78400,
+	90000, 102400, 115600, 129600, 144400, 160000, 176400,
+	193600, 211600, 230400, 250000, 270400, 291600, 313600,
+	336400, 360000, 384400, 409600, 435600, 462400, 490000,
+	518400, 547600, 577600, 608400, 640000, 672400, 705600,
+	739600, 774400, 810000, 846400, 883600, 921600, 960400,
+	1000000, 1040400, 1081600, 1123600, 1166400, 1210000,
+	1254400, 1299600, 1345600, 1392400, 1440000, 1488400,
+	1537600, 1587600, 1638400, 1690000, 1742400, 1795600,
+	1849600, 1904400, 1960000
+};
+
+static int accelerate_second_rtc(int n)
+{
+	unsigned int reg;
+
+	reg = readl(fh_rtc->regs + FH_RTC_OFFSET);
+	reg &= ~(0x7000000);
+	reg |= 0x30000000 | ((n & 0x7) << 24);
+	writel(reg, fh_rtc->regs + FH_RTC_OFFSET);
+	return 0;
+}
+
+static int accelerate_minute_rtc(int m)
+{
+	unsigned int reg;
+
+	reg = readl(fh_rtc->regs + FH_RTC_OFFSET);
+	reg &= ~(0x3F0000);
+	reg |= 0x30000000 | ((m & 0x3f) << 16);
+	writel(reg, fh_rtc->regs + FH_RTC_OFFSET);
+	return 0;
+}
+
+static int __maybe_unused slow_down_second_rtc(int n)
+{
+	unsigned int reg;
+
+	reg = readl(fh_rtc->regs + FH_RTC_OFFSET);
+	reg &= ~(0x7000000);
+	reg |= 0x10000000 | ((n & 0x7) << 24);
+	writel(reg, fh_rtc->regs + FH_RTC_OFFSET);
+	return 0;
+}
+
+static int __maybe_unused slow_down_minute_rtc(int m)
+{
+	unsigned int reg;
+
+	reg = readl(fh_rtc->regs + FH_RTC_OFFSET);
+	reg &= ~(0x3F0000);
+	reg |= 0x10000000 | ((m & 0x3f) << 16);
+	writel(reg, fh_rtc->regs + FH_RTC_OFFSET);
+	return 0;
+}
+
+static unsigned int fh_rtc_get_hw_sec_data(unsigned int func_switch)
+{
+
+	unsigned int ret_sec, raw_value, sec_value;
+	unsigned int min_value, hour_value, day_value;
+
+	if (func_switch == TIME_FUNC)
+		raw_value = fh_rtc_get_time(fh_rtc->regs);
+	else
+		raw_value = fh_rtc_get_alarm_time(fh_rtc->regs);
+
+	sec_value = FH_GET_RTC_SEC(raw_value);
+	min_value = FH_GET_RTC_MIN(raw_value);
+	hour_value = FH_GET_RTC_HOUR(raw_value);
+	day_value = FH_GET_RTC_DAY(raw_value);
+	ret_sec = (day_value * 86400) + (hour_value * 3600)
+			+ (min_value * 60) + sec_value;
+
+	return ret_sec;
+
+}
+
+static void fh_rtc_set_hw_sec_data(struct rtc_time *rtc_tm,
+		unsigned int func_switch) {
+
+	unsigned int raw_value, sec_value, min_value;
+	unsigned int hour_value, day_value;
+
+	day_value = rtc_year_days(rtc_tm->tm_mday, rtc_tm->tm_mon,
+			rtc_tm->tm_year+1900);
+	day_value += (rtc_tm->tm_year-70)*365
+			+ ELAPSED_LEAP_YEARS(rtc_tm->tm_year);
+
+	hour_value = rtc_tm->tm_hour;
+	min_value = rtc_tm->tm_min;
+	sec_value = rtc_tm->tm_sec;
+
+	raw_value = (day_value << DAY_BIT_START)
+			| (hour_value << HOUR_BIT_START)
+			| (min_value << MIN_BIT_START)
+			| (sec_value << SEC_BIT_START);
+
+	if (func_switch == TIME_FUNC)
+		fh_rtc_set_time(fh_rtc->regs, raw_value);
+	else
+		fh_rtc_set_alarm_time(fh_rtc->regs, raw_value);
+
+}
+
+static int fh_rtc_exam_magic(void)
+{
+	unsigned int magic, status;
+	int i;
+
+	for (i = 0; i < 10; i++) {
+		magic = GET_REG(fh_rtc->regs + FH_RTC_USER_REG);
+
+		if (magic != RTC_MAGIC) {
+			status = GET_REG(fh_rtc->regs+FH_RTC_SYNC);
+			status &= 0x2;
+			SET_REG(fh_rtc->regs+FH_RTC_SYNC, status);
+
+			msleep(30);
+		} else {
+			return 0;
+		}
+	}
+
+	printk(KERN_INFO "ERROR: read rtc failed: 0x%x\n", magic);
+
+	return -EAGAIN;
+
+}
+
+static int fh_rtc_open(struct device *dev)
+{
+	return 0;
+}
+
+static void fh_rtc_release(struct device *dev)
+{
+	return;
+}
+
+static int fh_rtc_tm_compare(struct rtc_time *tm0, struct rtc_time *tm1)
+{
+	unsigned long read = 0, write = 0;
+
+	rtc_tm_to_time(tm0, &read);
+	rtc_tm_to_time(tm1, &write);
+
+	if (write > read || write < read - 2) {
+		RTC_PRINT_DBG("ERROR: read(%d-%d-%d %d:%d:%d) vs "
+				"write(%d-%d-%d %d:%d:%d)\n",
+			   tm0->tm_year + 1900,
+			   tm0->tm_mon + 1,
+			   tm0->tm_mday,
+			   tm0->tm_hour,
+			   tm0->tm_min,
+			   tm0->tm_sec,
+			   tm1->tm_year + 1900,
+			   tm1->tm_mon + 1,
+			   tm1->tm_mday,
+			   tm1->tm_hour,
+			   tm1->tm_min,
+			   tm1->tm_sec);
+		return -1;
+	}
+	return 0;
+}
+
+static int fh_rtc_gettime_nosync(struct device *dev, struct rtc_time *rtc_tm)
+{
+	unsigned int temp;
+
+	temp = fh_rtc_get_hw_sec_data(TIME_FUNC);
+	rtc_time_to_tm(temp, rtc_tm);
+	RTC_PRINT_DBG("rtc read date:0x%x\n", temp);
+	return 0;
+}
+
+
+static int fh_rtc_gettime_sync(struct device *dev, struct rtc_time *rtc_tm)
+{
+	unsigned int status;
+	unsigned int loop_count;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct fh_rtc_controller *fh_rtc = platform_get_drvdata(pdev);
+
+	status = GET_REG(fh_rtc->regs+FH_RTC_SYNC);
+	status &= 0x2;
+
+	SET_REG(fh_rtc->regs+FH_RTC_SYNC, status);
+	msleep(30);
+
+	for (loop_count = 0;
+			loop_count <= SYNC_LOOP_COUNT;
+			loop_count++) {
+		udelay(100);
+		status = GET_REG(fh_rtc->regs+FH_RTC_SYNC);
+		status &= 0x1;
+		if(status == 1) {
+			unsigned int temp;
+			temp = fh_rtc_get_hw_sec_data(TIME_FUNC);
+			rtc_time_to_tm(temp, rtc_tm);
+			RTC_PRINT_DBG("rtc read date:0x%x\n", temp);
+			return 0;
+		}
+
+	}
+
+	printk(KERN_INFO "rtc read sync fail!\n");
+	return -EAGAIN;
+}
+
+static int fh_rtc_settime(struct device *dev, struct rtc_time *tm)
+{
+	struct rtc_time rtc_tm_read0;
+	unsigned int status;
+	unsigned int loop_count;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct fh_rtc_controller *fh_rtc = platform_get_drvdata(pdev);
+	int cnt, ret, read_count = 0;
+
+	RTC_PRINT_DBG("rtc write %d-%d-%d %d:%d:%d\n",
+		 tm->tm_year + 1900,
+		 tm->tm_mon + 1,
+		 tm->tm_mday,
+		 tm->tm_hour,
+		 tm->tm_min,
+		 tm->tm_sec);
+
+	SET_REG(fh_rtc->regs + FH_RTC_USER_REG, RTC_MAGIC);
+	msleep(3);
+
+	for (cnt = 0; cnt < 5; cnt++) {
+		int rewrite_count = 0;
+REWRITE:
+		ret = 0;
+
+		fh_rtc_set_hw_sec_data(tm, TIME_FUNC);
+
+		/*spin_lock_irqsave(&rtc_lock, flag);*/
+
+		for (loop_count = 0;
+				loop_count <= SYNC_LOOP_COUNT;
+				loop_count++) {
+			udelay(100);
+
+			status = GET_REG(fh_rtc->regs+FH_RTC_SYNC);
+			status &= 0x2;
+			if (status == 0x2) {
+				printk(KERN_INFO "rtc write loop_count :%d\n",
+						loop_count);
+				if(loop_count > 20) {
+					RTC_PRINT_DBG("error: rewrite: %d, "
+							"rtc write loop_count :%d\n",
+							rewrite_count,
+							loop_count);
+					msleep(3);
+					rewrite_count++;
+					if (rewrite_count < 5) {
+						goto REWRITE;
+					} else {
+						RTC_PRINT_DBG("rtc write retry exceed\n");
+						msleep(3);
+						break;
+					}
+				}
+				/*spin_unlock_irqrestore(&rtc_lock, flag);*/
+				msleep(3);
+				break;
+			}
+		}
+
+		if (loop_count >= SYNC_LOOP_COUNT) {
+			printk(KERN_INFO "rtc write sync fail!\n");
+			return -EAGAIN;
+		}
+
+		for (read_count = 0; read_count < 5; read_count++) {
+			fh_rtc_gettime_sync(dev, &rtc_tm_read0);
+			ret += fh_rtc_tm_compare(&rtc_tm_read0, tm);
+		}
+
+		if (!ret) {
+			return 0;
+		}
+
+	}
+
+	return -1;
+}
+
+static int fh_rtc_getalarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct rtc_time *rtc_tm = &alrm->time;
+
+	rtc_time_to_tm(fh_rtc_get_hw_sec_data(ALARM_FUNC), rtc_tm);
+
+	return 0;
+}
+
+static int fh_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct rtc_time *rtc_tm = &alrm->time;
+
+	fh_rtc_set_hw_sec_data(rtc_tm, ALARM_FUNC);
+
+	return 0;
+}
+
+
+
+static int fh_rtc_irq_enable(struct device *dev, unsigned int enabled)
+{
+
+	struct platform_device *pdev = to_platform_device(dev);
+	struct fh_rtc_controller *fh_rtc = platform_get_drvdata(pdev);
+
+	if (enabled) {
+		fh_rtc_enable_interrupt(fh_rtc->regs,
+				FH_RTC_ISR_SEC_POS | FH_RTC_ISR_ALARM_POS);
+	}
+	else{
+
+		fh_rtc_disenable_interrupt(fh_rtc->regs,
+				FH_RTC_ISR_SEC_POS | FH_RTC_ISR_ALARM_POS);
+	}
+
+	return 0;
+}
+
+
+
+
+static irqreturn_t fh_rtc_irq(int irq, void *dev_id)
+{
+
+	struct fh_rtc_controller *fh_rtc = (struct fh_rtc_controller *)dev_id;
+	unsigned long events = 0;
+	unsigned int isr_status;
+	struct rtc_device *rtc = fh_rtc->rtc;
+
+	isr_status = fh_rtc_get_enabled_interrupt(fh_rtc->regs);
+
+	fh_rtc_clear_interrupt_status(fh_rtc->regs, isr_status);
+
+	if (isr_status & FH_RTC_ISR_SEC_POS) {
+
+		events |= RTC_IRQF | RTC_UF;
+	}
+	else if(isr_status & FH_RTC_ISR_ALARM_POS){
+		events |= RTC_IRQF | RTC_AF;
+	}
+	else{
+		pr_info("rtc unknown isr...\n");
+		return IRQ_HANDLED;
+	}
+	rtc_update_irq(rtc, 1, events);
+
+	return IRQ_HANDLED;
+
+}
+
+static const struct rtc_class_ops fh_rtcops = {
+	.open		= fh_rtc_open,
+	.release	= fh_rtc_release,
+	.read_time	= fh_rtc_gettime_nosync,
+	.set_time	= fh_rtc_settime,
+	.read_alarm	= fh_rtc_getalarm,
+	.set_alarm	= fh_rtc_setalarm,
+	.alarm_irq_enable = fh_rtc_irq_enable,
+};
+
+/*get the read of SADC and adjust RTC clock*/
+int fh_adjust_rtc(void)
+{
+	int m, n;	/*m:MinuteOffset, n:SecondOffset*/
+	long T = 25000;
+	int i, j, temp;
+	long Ppm = 0;
+	long value[7];
+	int flag = 0;
+	long sum = 0;
+	long v;
+	int num;
+
+	for (i = 0; i < 7; i++) {
+		value[i] = fh_sadc_get_value(fh_rtc->sadc_channel);
+		if(!value[i])
+		{
+			printk("ERROR: %s, sadc value %lu is incorrect\n",
+					__func__, value[i]);
+			return -EIO;
+		}
+		mdelay(100);
+	}
+	for (i = 0; i < 7; i++) {
+		for (j = i + 1; j < 7; j++) {
+			if (value[j] < value[i]) {
+				temp = value[i];
+				value[i] = value[j];
+				value[j] = temp;
+			}
+		}
+	}
+	sum = value[2] + value[3] + value[4];
+	v = sum / 3;
+	printk("the average value of SADC is:%ld\n", v);
+	if(v >= 3094) {	/*if temperature is lower than -40,adjust by -40*/
+		Ppm = 1690000;
+		n = Ppm / 305176;
+		Ppm -= 305176 * n;
+		m = Ppm / 5086;
+		printk("SecondOffset is: %d\n", n);
+		printk("MinuteOffset is: %d\n", m);
+		if ((n <= 7) && (m <= 63)) {
+			accelerate_second_rtc(n);
+			accelerate_minute_rtc(m);
+			printk("rtc clock has been adjusted!\n");
+		} else {
+			printk("beyond range of adjust\n");
+		}
+		return 0;
+	}
+	if(v < 260) {	/*if temperature is higher than 95,adjust by 95*/
+		Ppm = 1960000;
+		n = Ppm / 305176;
+		Ppm -= 305176 * n;
+		m = Ppm / 5086;
+		printk("SecondOffset is: %d\n", n);
+		printk("MinuteOffset is: %d\n", m);
+		if ((n <= 7) && (m <= 63)) {
+			accelerate_second_rtc(n);
+			accelerate_minute_rtc(m);
+			printk("rtc clock has been adjusted!\n");
+		} else {
+			printk("beyond range of adjust\n");
+		}
+
+		return 0;
+	}
+	for (i = 0; i < 27; i++) {	/*calculate temperature by voltage*/
+		if ((v >= SadcValue[i]) && (v < SadcValue[i+1])) {
+			T = Temperature1[i] - ((Temperature1[i] - Temperature1[i+1]) *
+					(SadcValue[i] - v) / (SadcValue[i] - SadcValue[i+1]));
+		} else {
+			//printk("the reading of SADC is beyond of voltage range\n");
+			continue;
+		}
+	}
+	for (i = 0; i < 135; i++) {	/*get deviation by temperature*/
+		if ((T >= Temperature2[i]) && (T < Temperature2[i+1])) {
+			num = i;
+			flag = 1;
+			if ((Temperature2[num+1] - T) <= 500) {
+				T = Temperature2[num + 1];
+				Ppm = Deviation[num + 1];
+			} else if ((Temperature2[num+1] - T) > 500) {
+				T = Temperature2[num];
+				Ppm = Deviation[num];
+			}
+			printk("current temperature is: %ld\n", T);
+			printk("current deviation of RTC crystal oscillator is: %ld\n", Ppm);
+		}
+	}
+	if (flag == 1) {
+		n = Ppm / 305176;
+		Ppm -= 305176 * n;
+		m = Ppm / 5086;
+		printk("SecondOffset is: %d\n", n);
+		printk("MinuteOffset is: %d\n", m);
+		if ((n <= 7) && (m <= 63)) {
+			accelerate_second_rtc(n);
+			accelerate_minute_rtc(m);
+			printk("rtc clock has been adjusted!\n");
+		} else {
+			printk("beyond range of adjust\n");
+		}
+	}
+	return 0;
+}
+
+long get_rtc_temperature(void)
+{
+	long T = 0;
+	int i, j, temp;
+	long value[7];
+	long sum = 0;
+	long v;
+	for (i = 0; i < 7; i++) {
+		value[i] = fh_sadc_get_value(fh_rtc->sadc_channel);
+		if(!value[i])
+		{
+			printk("ERROR: %s, sadc value %lu is incorrect\n",
+					__func__, value[i]);
+			return -EIO;
+		}
+		mdelay(100);
+	}
+	for (i = 0; i < 7; i++) {
+		for (j = i + 1; j < 7; j++) {
+			if (value[j] < value[i]) {
+				temp = value[i];
+				value[i] = value[j];
+				value[j] = temp;
+			}
+		}
+	}
+	sum = value[2] + value[3] + value[4];
+	v = sum / 3;
+	printk("the average value of SADC is:%ld\n", v);
+	for (i = 0; i < 27; i++) {
+		if ((v >= SadcValue[i]) && (v < SadcValue[i+1])) {
+			T = Temperature1[i] - ((Temperature1[i] - Temperature1[i+1]) *
+					(SadcValue[i] - v) / (SadcValue[i] - SadcValue[i+1]));
+		} else {
+			//printk("the reading of SADC is beyond of voltage range\n");
+			continue;
+		}
+	}
+	printk("current temperature is: %ld\n", T);
+	return 0;
+}
+
+void fh_rtc_self_adjustment(struct work_struct *work)
+{
+	fh_adjust_rtc();
+
+	queue_delayed_work(fh_rtc->wq, &fh_rtc->self_adjust, 5000);
+}
+
+
+static void create_proc_rtc(struct fh_rtc_controller *rtc);
+static void remove_proc(void);
+static int __devinit fh_rtc_probe(struct platform_device *pdev)
+{
+	int err = 0;
+	struct resource *ioarea;
+	struct fh_rtc_platform_data * rtc_platform_info;
+	struct rtc_device *rtc;
+	struct resource *res;
+
+	fh_rtc = kzalloc(sizeof(struct fh_rtc_controller), GFP_KERNEL);
+	if (!fh_rtc)
+		return -ENOMEM;
+
+	memset(fh_rtc, 0, sizeof(struct fh_rtc_controller));
+
+	/* board info below */
+	rtc_platform_info = (struct fh_rtc_platform_data *)pdev->dev.platform_data;
+	if(rtc_platform_info == NULL){
+		dev_err(&pdev->dev, "%s, rtc platform error.\n",
+			__func__);
+		err = -ENODEV;
+		goto err_nores;
+	}
+	fh_rtc->base_year = rtc_platform_info->base_year;
+	fh_rtc->base_month = rtc_platform_info->base_month;
+	fh_rtc->base_day = rtc_platform_info->base_day;
+	fh_rtc->sadc_channel = rtc_platform_info->sadc_channel;
+
+	/* find the IRQs */
+	fh_rtc->irq = platform_get_irq(pdev, 0);
+	if (fh_rtc->irq < 0) {
+		dev_err(&pdev->dev, "%s, rtc irq error.\n",
+			__func__);
+		err = fh_rtc->irq;
+		goto err_nores;
+	}
+
+	/* get the memory region */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "failed to get memory region resource\n");
+		err = -ENOENT;
+		goto err_nores;
+	}
+
+	fh_rtc->paddr = res->start;
+	ioarea = request_mem_region(res->start, resource_size(res),
+			pdev->name);
+	if(!ioarea) {
+		dev_err(&pdev->dev, "rtc region already claimed\n");
+		err = -EBUSY;
+		goto err_nores;
+	}
+
+	fh_rtc->regs = ioremap(res->start, resource_size(res));
+	if (!fh_rtc->regs) {
+		dev_err(&pdev->dev, "rtc already mapped\n");
+		err = -EINVAL;
+		goto err_nores;
+	}
+
+	/* register RTC and exit */
+	platform_set_drvdata(pdev, fh_rtc);
+	rtc = rtc_device_register(rtc_platform_info->dev_name, &pdev->dev, &fh_rtcops,
+				  THIS_MODULE);
+
+	if (IS_ERR(rtc)) {
+		dev_err(&pdev->dev, "cannot attach rtc\n");
+		err = PTR_ERR(rtc);
+		goto err_nores;
+	}
+	fh_rtc->rtc = rtc;
+
+	err = request_irq(fh_rtc->irq , fh_rtc_irq, 0,
+			  dev_name(&pdev->dev), fh_rtc);
+	if (err) {
+		dev_dbg(&pdev->dev, "request_irq failed, %d\n", err);
+		goto err_nores;
+	}
+
+	create_proc_rtc(fh_rtc);
+
+	SET_REG(fh_rtc->regs + FH_RTC_DEBUG, RTC_PHASE);
+
+	if(fh_rtc->sadc_channel >= 0)
+	{
+		pr_info("RTC: start self adjustment\n");
+		fh_rtc->wq = create_workqueue("rtc_wq");
+		if(!fh_rtc->wq)
+		{
+			dev_err(&pdev->dev, "no memory to create rtc workqueue\n");
+			return -ENOMEM;
+		}
+		INIT_DELAYED_WORK(&fh_rtc->self_adjust, fh_rtc_self_adjustment);
+
+		queue_delayed_work(fh_rtc->wq, &fh_rtc->self_adjust, 5000);
+	}
+
+	err = fh_rtc_exam_magic();
+
+	if(err)
+		return -1;
+
+
+err_nores:
+	return err;
+
+	return 0;
+}
+
+static int __devexit fh_rtc_remove(struct platform_device *dev)
+{
+	struct fh_rtc_controller *fh_rtc = platform_get_drvdata(dev);
+
+	remove_proc();
+	free_irq(fh_rtc->irq, fh_rtc);
+	rtc_device_unregister(fh_rtc->rtc);
+
+	iounmap(fh_rtc->regs);
+	platform_set_drvdata(dev, NULL);
+	kfree(fh_rtc);
+	return 0;
+}
+
+
+
+#ifdef CONFIG_PM
+
+/* RTC Power management control */
+
+static int fh_rtc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int fh_rtc_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+#else
+#define fh_rtc_suspend NULL
+#define fh_rtc_resume  NULL
+#endif
+
+
+
+static struct platform_driver fh_rtc_driver = {
+	.probe		= fh_rtc_probe,
+	.remove		= __devexit_p(fh_rtc_remove),
+	.suspend	= fh_rtc_suspend,
+	.resume		= fh_rtc_resume,
+	.driver		= {
+		.name	= "fh_rtc",
+		.owner	= THIS_MODULE,
+	},
+};
+
+
+static int __init fh_rtc_init(void) {
+
+	return platform_driver_register(&fh_rtc_driver);
+}
+
+static void __exit fh_rtc_exit(void) {
+	platform_driver_unregister(&fh_rtc_driver);
+}
+
+static void del_char(char *str, char ch)
+{
+	char *p = str;
+	char *q = str;
+	while (*q) {
+		if (*q != ch) {
+			*p++ = *q;
+		}
+		q++;
+	}
+	*p = '\0';
+}
+
+ssize_t proc_read(char *page, char **start, off_t off, int count,
+		int *eof, struct fh_rtc_controller *data) {
+	ssize_t len = 0;
+
+	printk(KERN_INFO "------------- dump register -------------\n");
+	printk(KERN_INFO "cnt:0x%x\n",fh_rtc_get_time(data->regs)  );
+	printk(KERN_INFO "offset:0x%x\n",fh_rtc_get_offset(data->regs));
+	printk(KERN_INFO "fail:0x%x\n",fh_rtc_get_power_fail(data->regs));
+	printk(KERN_INFO "alarm_cnt:0x%x\n",fh_rtc_get_alarm_time(data->regs));
+	printk(KERN_INFO "int stat:0x%x\n",fh_rtc_get_int_status(data->regs));
+	printk(KERN_INFO "int en:0x%x\n",fh_rtc_get_enabled_interrupt(data->regs));
+	printk(KERN_INFO "sync:0x%x\n",fh_rtc_get_sync(data->regs));
+	printk(KERN_INFO "debug:0x%x\n",fh_rtc_get_debug(data->regs));
+	printk(KERN_INFO "-------------------------------------------\n");
+
+	return len;
+}
+
+
+static ssize_t fh_rtc_proc_write(struct file *filp, const char *buf, size_t len, loff_t *off)
+{
+	char message[32] = {0};
+	char * const delim = ",";
+	char *cur = message, *power_str;
+	int power;
+	len = (len > 32) ? 32 : len;
+	if (copy_from_user(message, buf, len))
+		return -EFAULT;
+	power_str = strsep(&cur, delim);
+	if (!power_str) {
+		pr_err("%s: ERROR: parameter is empty\n", __func__);
+		return -EINVAL;
+	} else {
+		del_char(power_str, ' ');
+		del_char(power_str, '\n');
+		power = (unsigned int)simple_strtoul(power_str, NULL, 10);
+		if (power < 0) {
+			pr_err("%s: ERROR: parameter is incorrect\n", __func__);
+			return -EINVAL;
+		}
+		printk(KERN_INFO "the diff between rtc and sys is %d\n",
+				power);
+		if (power == 0)
+			fh_adjust_rtc();
+		else if (power == 1)
+			get_rtc_temperature();
+	}
+	return len;
+}
+
+static void create_proc_rtc(struct fh_rtc_controller *rtc)
+{
+	fh_rtc->proc_rtc_entry =
+			create_proc_entry(FH_RTC_PROC_FILE,
+					S_IRUGO, NULL);
+
+	if (!fh_rtc->proc_rtc_entry) {
+		printk(KERN_ERR"create proc failed\n");
+	} else {
+		fh_rtc->proc_rtc_entry->read_proc =
+				(read_proc_t *)proc_read;
+		fh_rtc->proc_rtc_entry->write_proc =
+				(write_proc_t *)fh_rtc_proc_write;
+		fh_rtc->proc_rtc_entry->data = rtc;
+	}
+}
+
+static void remove_proc(void) {
+    remove_proc_entry(FH_RTC_PROC_FILE, NULL);
+}
+
+module_init(fh_rtc_init);
+module_exit(fh_rtc_exit);
+
+MODULE_DESCRIPTION("FH SOC RTC Driver");
+MODULE_AUTHOR("yu.zhang <zhangy@fullhan.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:fh-rtc");
diff -uraN linux-3.0.8/drivers/spi/dw_spi.h linux-3.0.8-fh8632-V1.0_20180330/drivers/spi/dw_spi.h
--- linux-3.0.8/drivers/spi/dw_spi.h	2021-07-14 21:52:03.843136403 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/spi/dw_spi.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,232 +0,0 @@
-#ifndef DW_SPI_HEADER_H
-#define DW_SPI_HEADER_H
-
-#include <linux/io.h>
-#include <linux/scatterlist.h>
-
-/* Bit fields in CTRLR0 */
-#define SPI_DFS_OFFSET			0
-
-#define SPI_FRF_OFFSET			4
-#define SPI_FRF_SPI			0x0
-#define SPI_FRF_SSP			0x1
-#define SPI_FRF_MICROWIRE		0x2
-#define SPI_FRF_RESV			0x3
-
-#define SPI_MODE_OFFSET			6
-#define SPI_SCPH_OFFSET			6
-#define SPI_SCOL_OFFSET			7
-
-#define SPI_TMOD_OFFSET			8
-#define SPI_TMOD_MASK			(0x3 << SPI_TMOD_OFFSET)
-#define	SPI_TMOD_TR			0x0		/* xmit & recv */
-#define SPI_TMOD_TO			0x1		/* xmit only */
-#define SPI_TMOD_RO			0x2		/* recv only */
-#define SPI_TMOD_EPROMREAD		0x3		/* eeprom read mode */
-
-#define SPI_SLVOE_OFFSET		10
-#define SPI_SRL_OFFSET			11
-#define SPI_CFS_OFFSET			12
-
-/* Bit fields in SR, 7 bits */
-#define SR_MASK				0x7f		/* cover 7 bits */
-#define SR_BUSY				(1 << 0)
-#define SR_TF_NOT_FULL			(1 << 1)
-#define SR_TF_EMPT			(1 << 2)
-#define SR_RF_NOT_EMPT			(1 << 3)
-#define SR_RF_FULL			(1 << 4)
-#define SR_TX_ERR			(1 << 5)
-#define SR_DCOL				(1 << 6)
-
-/* Bit fields in ISR, IMR, RISR, 7 bits */
-#define SPI_INT_TXEI			(1 << 0)
-#define SPI_INT_TXOI			(1 << 1)
-#define SPI_INT_RXUI			(1 << 2)
-#define SPI_INT_RXOI			(1 << 3)
-#define SPI_INT_RXFI			(1 << 4)
-#define SPI_INT_MSTI			(1 << 5)
-
-/* TX RX interrupt level threshold, max can be 256 */
-#define SPI_INT_THRESHOLD		32
-
-enum dw_ssi_type {
-	SSI_MOTO_SPI = 0,
-	SSI_TI_SSP,
-	SSI_NS_MICROWIRE,
-};
-
-struct dw_spi_reg {
-	u32	ctrl0;
-	u32	ctrl1;
-	u32	ssienr;
-	u32	mwcr;
-	u32	ser;
-	u32	baudr;
-	u32	txfltr;
-	u32	rxfltr;
-	u32	txflr;
-	u32	rxflr;
-	u32	sr;
-	u32	imr;
-	u32	isr;
-	u32	risr;
-	u32	txoicr;
-	u32	rxoicr;
-	u32	rxuicr;
-	u32	msticr;
-	u32	icr;
-	u32	dmacr;
-	u32	dmatdlr;
-	u32	dmardlr;
-	u32	idr;
-	u32	version;
-	u32	dr;		/* Currently oper as 32 bits,
-				though only low 16 bits matters */
-} __packed;
-
-struct dw_spi;
-struct dw_spi_dma_ops {
-	int (*dma_init)(struct dw_spi *dws);
-	void (*dma_exit)(struct dw_spi *dws);
-	int (*dma_transfer)(struct dw_spi *dws, int cs_change);
-};
-
-struct dw_spi {
-	struct spi_master	*master;
-	struct spi_device	*cur_dev;
-	struct device		*parent_dev;
-	enum dw_ssi_type	type;
-
-	void __iomem		*regs;
-	unsigned long		paddr;
-	u32			iolen;
-	int			irq;
-	u32			fifo_len;	/* depth of the FIFO buffer */
-	u32			max_freq;	/* max bus freq supported */
-
-	u16			bus_num;
-	u16			num_cs;		/* supported slave numbers */
-
-	/* Driver message queue */
-	struct workqueue_struct	*workqueue;
-	struct work_struct	pump_messages;
-	spinlock_t		lock;
-	struct list_head	queue;
-	int			busy;
-	int			run;
-
-	/* Message Transfer pump */
-	struct tasklet_struct	pump_transfers;
-
-	/* Current message transfer state info */
-	struct spi_message	*cur_msg;
-	struct spi_transfer	*cur_transfer;
-	struct chip_data	*cur_chip;
-	struct chip_data	*prev_chip;
-	size_t			len;
-	void			*tx;
-	void			*tx_end;
-	void			*rx;
-	void			*rx_end;
-	int			dma_mapped;
-	dma_addr_t		rx_dma;
-	dma_addr_t		tx_dma;
-	size_t			rx_map_len;
-	size_t			tx_map_len;
-	u8			n_bytes;	/* current is a 1/2 bytes op */
-	u8			max_bits_per_word;	/* maxim is 16b */
-	u32			dma_width;
-	int			cs_change;
-	irqreturn_t		(*transfer_handler)(struct dw_spi *dws);
-	void			(*cs_control)(u32 command);
-
-	/* Dma info */
-	int			dma_inited;
-	struct dma_chan		*txchan;
-	struct scatterlist	tx_sgl;
-	struct dma_chan		*rxchan;
-	struct scatterlist	rx_sgl;
-	int			dma_chan_done;
-	struct device		*dma_dev;
-	dma_addr_t		dma_addr; /* phy address of the Data register */
-	struct dw_spi_dma_ops	*dma_ops;
-	void			*dma_priv; /* platform relate info */
-	struct pci_dev		*dmac;
-
-	/* Bus interface info */
-	void			*priv;
-#ifdef CONFIG_DEBUG_FS
-	struct dentry *debugfs;
-#endif
-};
-
-#define dw_readl(dw, name) \
-	__raw_readl(&(((struct dw_spi_reg *)dw->regs)->name))
-#define dw_writel(dw, name, val) \
-	__raw_writel((val), &(((struct dw_spi_reg *)dw->regs)->name))
-#define dw_readw(dw, name) \
-	__raw_readw(&(((struct dw_spi_reg *)dw->regs)->name))
-#define dw_writew(dw, name, val) \
-	__raw_writew((val), &(((struct dw_spi_reg *)dw->regs)->name))
-
-static inline void spi_enable_chip(struct dw_spi *dws, int enable)
-{
-	dw_writel(dws, ssienr, (enable ? 1 : 0));
-}
-
-static inline void spi_set_clk(struct dw_spi *dws, u16 div)
-{
-	dw_writel(dws, baudr, div);
-}
-
-static inline void spi_chip_sel(struct dw_spi *dws, u16 cs)
-{
-	if (cs > dws->num_cs)
-		return;
-
-	if (dws->cs_control)
-		dws->cs_control(1);
-
-	dw_writel(dws, ser, 1 << cs);
-}
-
-/* Disable IRQ bits */
-static inline void spi_mask_intr(struct dw_spi *dws, u32 mask)
-{
-	u32 new_mask;
-
-	new_mask = dw_readl(dws, imr) & ~mask;
-	dw_writel(dws, imr, new_mask);
-}
-
-/* Enable IRQ bits */
-static inline void spi_umask_intr(struct dw_spi *dws, u32 mask)
-{
-	u32 new_mask;
-
-	new_mask = dw_readl(dws, imr) | mask;
-	dw_writel(dws, imr, new_mask);
-}
-
-/*
- * Each SPI slave device to work with dw_api controller should
- * has such a structure claiming its working mode (PIO/DMA etc),
- * which can be save in the "controller_data" member of the
- * struct spi_device
- */
-struct dw_spi_chip {
-	u8 poll_mode;	/* 0 for contoller polling mode */
-	u8 type;	/* SPI/SSP/Micrwire */
-	u8 enable_dma;
-	void (*cs_control)(u32 command);
-};
-
-extern int dw_spi_add_host(struct dw_spi *dws);
-extern void dw_spi_remove_host(struct dw_spi *dws);
-extern int dw_spi_suspend_host(struct dw_spi *dws);
-extern int dw_spi_resume_host(struct dw_spi *dws);
-extern void dw_spi_xfer_done(struct dw_spi *dws);
-
-/* platform related setup */
-extern int dw_spi_mid_init(struct dw_spi *dws); /* Intel MID platforms */
-#endif /* DW_SPI_HEADER_H */
diff -uraN linux-3.0.8/drivers/spi/fh_spi.c linux-3.0.8-fh8632-V1.0_20180330/drivers/spi/fh_spi.c
--- linux-3.0.8/drivers/spi/fh_spi.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/spi/fh_spi.c	2021-07-13 23:40:34.222359723 +0300
@@ -0,0 +1,1460 @@
+/** @file fh_spi.c
+ *  @note ShangHai FullHan Co., Ltd. All Right Reserved.
+ *  @brief fh driver
+ *  @author     yu.zhang
+ *  @date       2015/1/11
+ *  @note history
+ *  @note 2014-1-11 V1.0.0 create the file.
+ */
+/*****************************************************************************
+ *  Include Section
+ *  add all #include here
+ *****************************************************************************/
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/scatterlist.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include <linux/bug.h>
+#include <linux/completion.h>
+#include <linux/gpio.h>
+#include <linux/dmaengine.h>
+#include <mach/spi.h>
+#include <mach/fh_dmac.h>
+#include <linux/dma-mapping.h>
+#include <mach/fh_dmac_regs.h>
+/*****************************************************************************
+ * Define section
+ * add all #define here
+ *****************************************************************************/
+#define lift_shift_bit_num(bit_num)     (1<<bit_num)
+/* read spi irq, only useful if you set which is masked */
+#define SPI_IRQ_TXEIS           (lift_shift_bit_num(0))
+#define SPI_IRQ_TXOIS           (lift_shift_bit_num(1))
+#define SPI_IRQ_RXUIS           (lift_shift_bit_num(2))
+#define SPI_IRQ_RXOIS           (lift_shift_bit_num(3))
+#define SPI_IRQ_RXFIS           (lift_shift_bit_num(4))
+#define SPI_IRQ_MSTIS           (lift_shift_bit_num(5))
+/* spi status */
+#define SPI_STATUS_BUSY         (lift_shift_bit_num(0))
+#define SPI_STATUS_TFNF         (lift_shift_bit_num(1))
+#define SPI_STATUS_TFE          (lift_shift_bit_num(2))
+#define SPI_STATUS_RFNE         (lift_shift_bit_num(3))
+#define SPI_STATUS_RFF          (lift_shift_bit_num(4))
+#define SPI_STATUS_TXE          (lift_shift_bit_num(5))
+#define SPI_STATUS_DCOL         (lift_shift_bit_num(6))
+#define CACHE_LINE_SIZE         (32)
+#define PUMP_DATA_NONE_MODE     (0x00)
+#define PUMP_DATA_DMA_MODE      (0x11)
+#define PUMP_DATA_ISR_MODE      (0x22)
+#define PUMP_DATA_POLL_MODE     (0x33)
+#define DMA_TRANS_GATE_LEVEL    1024
+#define SPI_DATA_REG_OFFSET     (0x60)
+/****************************************************************************
+ * ADT section
+ *  add definition of user defined Data Type that only be used in this file  here
+ ***************************************************************************/
+enum {
+	CONFIG_OK = 0, CONFIG_PARA_ERROR = lift_shift_bit_num(0),
+	/* only for the set slave en/disable */
+	CONFIG_BUSY = lift_shift_bit_num(1),
+	/* only for write_read mode */
+	WRITE_READ_OK = 0,
+	WRITE_READ_ERROR = lift_shift_bit_num(2),
+	WRITE_READ_TIME_OUT = lift_shift_bit_num(3),
+	/* only for write only mode */
+	WRITE_ONLY_OK = 0,
+	WRITE_ONLY_ERROR = lift_shift_bit_num(4),
+	WRITE_ONLY_TIME_OUT = lift_shift_bit_num(5),
+	/* only for read only mode */
+	READ_ONLY_OK = 0,
+	READ_ONLY_ERROR = lift_shift_bit_num(6),
+	READ_ONLY_TIME_OUT = lift_shift_bit_num(7),
+	/* eeprom mode */
+	EEPROM_OK = 0,
+	EEPROM_ERROR = lift_shift_bit_num(8),
+	EEPROM_TIME_OUT = lift_shift_bit_num(9),
+	MULTI_MASTER_ERROR = lift_shift_bit_num(10),
+	TX_OVERFLOW_ERROR = lift_shift_bit_num(11),
+	RX_OVERFLOW_ERROR = lift_shift_bit_num(12),
+};
+
+/* enable spi */
+typedef enum enum_spi_enable {
+	SPI_DISABLE = 0,
+	SPI_ENABLE = (lift_shift_bit_num(0)),
+} spi_enable_e;
+
+/* polarity */
+typedef enum enum_spi_polarity {
+	SPI_POLARITY_LOW = 0,
+	SPI_POLARITY_HIGH = (lift_shift_bit_num(7)),
+	SPI_POLARITY_RANGE = (lift_shift_bit_num(7)),
+} spi_polarity_e;
+
+typedef enum enum_spi_phase {
+	SPI_PHASE_RX_FIRST = 0,
+	SPI_PHASE_TX_FIRST = (lift_shift_bit_num(6)),
+	SPI_PHASE_RANGE = (lift_shift_bit_num(6)),
+} spi_phase_e;
+
+typedef enum enum_spi_format {
+	SPI_MOTOROLA_MODE = 0x00,
+	SPI_TI_MODE = 0x10,
+	SPI_MICROWIRE_MODE = 0x20,
+	SPI_FRAME_FORMAT_RANGE = 0x30,
+} spi_format_e;
+
+typedef enum enum_spi_data_size {
+	SPI_DATA_SIZE_4BIT = 0x03,
+	SPI_DATA_SIZE_5BIT = 0x04,
+	SPI_DATA_SIZE_6BIT = 0x05,
+	SPI_DATA_SIZE_7BIT = 0x06,
+	SPI_DATA_SIZE_8BIT = 0x07,
+	SPI_DATA_SIZE_9BIT = 0x08,
+	SPI_DATA_SIZE_10BIT = 0x09,
+	SPI_DATA_SIZE_16BIT = 0x0f,
+	SPI_DATA_SIZE_RANGE = 0x0f,
+} spi_data_size_e;
+
+typedef enum enum_spi_transfer_mode {
+	SPI_TX_RX_MODE = 0x000,
+	SPI_ONLY_TX_MODE = 0x100,
+	SPI_ONLY_RX_MODE = 0x200,
+	SPI_EEPROM_MODE = 0x300,
+	SPI_TRANSFER_MODE_RANGE = 0x300,
+} spi_transfer_mode_e;
+
+typedef enum enum_spi_baudrate {
+	SPI_SCLKIN = 50000000, 
+	SPI_SCLKOUT_27000000 = (SPI_SCLKIN / 27000000), //27M
+	SPI_SCLKOUT_13500000 = (SPI_SCLKIN / 13500000),  //13.5M
+	SPI_SCLKOUT_6750000 = (SPI_SCLKIN / 6750000),  //6.75M
+	SPI_SCLKOUT_4500000 = (SPI_SCLKIN / 4500000),    //4.5M
+	SPI_SCLKOUT_3375000 = (SPI_SCLKIN / 3375000),  //3.375M
+	SPI_SCLKOUT_2700000 = (SPI_SCLKIN / 2700000),    //2.7M
+	SPI_SCLKOUT_1500000 = (SPI_SCLKIN / 1500000),  //1.5M
+	SPI_SCLKOUT_500000 = (SPI_SCLKIN / 500000),  //0.1M
+	SPI_SCLKOUT_100000 = (SPI_SCLKIN / 100000),  //0.1M
+} spi_baudrate_e;
+
+typedef enum enum_spi_irq {
+	SPI_IRQ_TXEIM = (lift_shift_bit_num(0)),
+	SPI_IRQ_TXOIM = (lift_shift_bit_num(1)),
+	SPI_IRQ_RXUIM = (lift_shift_bit_num(2)),
+	SPI_IRQ_RXOIM = (lift_shift_bit_num(3)),
+	SPI_IRQ_RXFIM = (lift_shift_bit_num(4)),
+	SPI_IRQ_MSTIM = (lift_shift_bit_num(5)),
+	SPI_IRQ_ALL = 0x3f,
+} spi_irq_e;
+
+typedef enum enum_spi_slave {
+	SPI_SLAVE_PORT0 = (lift_shift_bit_num(0)),
+	SPI_SLAVE_PORT1 = (lift_shift_bit_num(1)),
+} spi_slave_e;
+
+typedef enum enum_spi_dma_control_mode {
+	SPI_DMA_RX_POS = (lift_shift_bit_num(0)),
+	SPI_DMA_TX_POS = (lift_shift_bit_num(1)),
+	SPI_DMA_CONTROL_RANGE = 0x03,
+} spi_dma_control_mode_e;
+
+struct fh_spi_reg {
+	u32 ctrl0;
+	u32 ctrl1;
+	u32 ssienr;
+	u32 mwcr;
+	u32 ser;
+	u32 baudr;
+	u32 txfltr;
+	u32 rxfltr;
+	u32 txflr;
+	u32 rxflr;
+	u32 sr;
+	u32 imr;
+	u32 isr;
+	u32 risr;
+	u32 txoicr;
+	u32 rxoicr;
+	u32 rxuicr;
+	u32 msticr;
+	u32 icr;
+	u32 dmacr;
+	u32 dmatdlr;
+	u32 dmardlr;
+	u32 idr;
+	u32 version;
+	u32 dr; /* Currently oper as 32 bits,
+	 though only low 16 bits matters */
+	u32 rev[35];
+	u32 rx_sample_dly;
+};
+
+#define dw_readl(dw, name) \
+__raw_readl(&(((struct fh_spi_reg *)dw->regs)->name))
+#define dw_writel(dw, name, val) \
+__raw_writel((val), &(((struct fh_spi_reg *)dw->regs)->name))
+#define dw_readw(dw, name) \
+ __raw_readw(&(((struct fh_spi_reg *)dw->regs)->name))
+#define dw_writew(dw, name, val) \
+__raw_writew((val), &(((struct fh_spi_reg *)dw->regs)->name))
+#define MAX_SG_LEN		32
+#define SG_ONE_TIME_MAX_SIZE (4096)
+struct _fh_spi_dma_transfer {
+	struct dma_chan *chan;
+	struct dma_slave_config cfg;
+	struct scatterlist sgl[MAX_SG_LEN];
+	u32 sgl_data_size[MAX_SG_LEN];
+	u32 actual_sgl_size;
+	struct dma_async_tx_descriptor *desc;
+};
+
+struct fh_spi {
+	void * __iomem regs; /* vaddr of the control registers */
+	u32 id;
+	u32 paddr;
+	u32 slave_port;
+	u32 irq; /* irq no */
+	u32 fifo_len; /* depth of the FIFO buffer */
+	u32 cpol;
+	u32 cpha;
+	u32 isr_flag;
+	u32 apb_clock_in;
+	u32 max_freq; /* max bus freq supported */
+	u32 div;
+	/*use id u32 bus_num;*//*which bus*/
+	u32 num_cs; /* supported slave numbers */
+	u32 data_width;
+	u32 frame_mode;
+	u32 transfer_mode;
+	u32 active_cs_pin;
+	u32 tx_len;
+	u32 rx_len;
+	void *rx_buff;
+	void *tx_buff;
+	u32 tx_dma_add;
+	u32 rx_dma_add;
+	u32 tx_hs_no;
+	u32 rx_hs_no;
+	u32 tx_dumy_buff[4];
+	u32 rx_dumy_buff[4];
+	u32 tx_dumy_dma_add;
+	u32 rx_dumy_dma_add;
+	struct fh_spi_cs cs_data[SPI_MASTER_CONTROLLER_MAX_SLAVE];
+	u32 pump_data_mode;
+	struct _fh_spi_dma_transfer dma_rx;
+	struct _fh_spi_dma_transfer dma_tx;
+	u32 complete_times;
+	struct fh_spi_platform_data *board_info;
+};
+
+struct fh_spi_controller {
+	struct device *master_dev;
+	struct clk *clk;
+	spinlock_t lock;
+	struct list_head queue;
+	struct platform_device *p_dev;
+	struct work_struct work;
+	struct workqueue_struct *workqueue;
+	struct spi_message *active_message;
+	struct spi_transfer *active_transfer;
+	struct fh_spi dwc;
+	struct completion done;
+};
+
+/******************************************************************************
+ * Function prototype section
+ * add prototypes for all functions called by this file,execepting those
+ * declared in header file
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Global variables section - Exported
+ * add declaration of global variables that will be exported here
+ * e.g.
+ *  int8_t foo;
+ ****************************************************************************/
+
+/*****************************************************************************
+
+ *  static fun;
+ *****************************************************************************/
+
+static u32 Spi_Enable(struct fh_spi *dw, spi_enable_e enable);
+static u32 Spi_SetPolarity(struct fh_spi *dw, spi_polarity_e polarity);
+static u32 Spi_SetPhase(struct fh_spi *dw, spi_phase_e phase);
+static u32 Spi_SetFrameFormat(struct fh_spi *dw, spi_format_e format);
+static u32 Spi_SetBaudrate(struct fh_spi *dw, spi_baudrate_e baudrate);
+static u32 Spi_DisableIrq(struct fh_spi *dw, u32 irq);
+static u32 Spi_ReadStatus(struct fh_spi *dw);
+static u32 Spi_EnableSlaveen(struct fh_spi *dw, spi_slave_e port);
+static u32 Spi_DisableSlaveen(struct fh_spi *dw, spi_slave_e port);
+static u32 Spi_EnableIrq(struct fh_spi *dw, u32 irq);
+static u32 Spi_SetTxlevlel(struct fh_spi *dw, u32 level);
+static u32 Spi_ReadTxfifolevel(struct fh_spi *dw);
+static u32 Spi_ReadRxfifolevel(struct fh_spi *dw);
+static u32 Spi_WriteData(struct fh_spi *dw, u16 data);
+static u16 Spi_ReadData(struct fh_spi *dw);
+static u32 Spi_Isrstatus(struct fh_spi *dw);
+static void Spi_SetDmaTxDataLevel(struct fh_spi *dw, u32 level);
+static void Spi_SetDmaRxDataLevel(struct fh_spi *dw, u32 level);
+static void Spi_SetDmaControlEnable(struct fh_spi *dw,
+spi_dma_control_mode_e enable_pos);
+static bool fh_spi_dma_chan_filter(struct dma_chan *chan, void *param);
+static int fh_spi_setup(struct spi_device *spi);
+static u32 Spi_SetRxdelay(struct fh_spi *dw, u8 data);
+/*****************************************************************************
+ * Global variables section - Local
+ * define global variables(will be refered only in this file) here,
+ * static keyword should be used to limit scope of local variable to this file
+ * e.g.
+ *  static uint8_t ufoo;
+ *****************************************************************************/
+
+/* function body */
+
+static u32 Spi_Enable(struct fh_spi *dw, spi_enable_e enable)
+{
+	dw_writel(dw, ssienr, enable);
+	return CONFIG_OK;
+}
+
+static u32 Spi_SetPolarity(struct fh_spi *dw, spi_polarity_e polarity)
+{
+	u32 data;
+
+	data = dw_readl(dw, ctrl0);
+	data &= ~(u32) SPI_POLARITY_RANGE;
+	data |= polarity;
+	dw_writel(dw, ctrl0, data);
+	return CONFIG_OK;
+}
+
+static u32 Spi_SetPhase(struct fh_spi *dw, spi_phase_e phase)
+{
+	u32 data;
+
+	data = dw_readl(dw, ctrl0);
+	data &= ~(u32) SPI_PHASE_RANGE;
+	data |= phase;
+	dw_writel(dw, ctrl0, data);
+	return CONFIG_OK;
+}
+
+static u32 Spi_SetFrameFormat(struct fh_spi *dw, spi_format_e format)
+{
+	u32 data = 0;
+
+	data = dw_readl(dw, ctrl0);
+	data &= ~(u32) SPI_FRAME_FORMAT_RANGE;
+	data |= format;
+	dw_writel(dw, ctrl0, data);
+	return CONFIG_OK;
+}
+
+static u32 Spi_SetTransferMode(struct fh_spi *dw, spi_transfer_mode_e mode)
+{
+	u32 data = 0;
+
+	data = dw_readl(dw, ctrl0);
+	data &= ~(u32) SPI_TRANSFER_MODE_RANGE;
+	data |= mode;
+	dw_writel(dw, ctrl0, data);
+	return CONFIG_OK;
+}
+
+static u32 Spi_SetBaudrate(struct fh_spi *dw, spi_baudrate_e baudrate)
+{
+	dw_writel(dw, baudr, baudrate);
+	return CONFIG_OK;
+}
+
+static u32 Spi_DisableIrq(struct fh_spi *dw, u32 irq)
+{
+	u32 data = 0;
+
+	data = dw_readl(dw, imr);
+	data &= ~irq;
+	dw_writel(dw, imr, data);
+	return CONFIG_OK;
+}
+
+static u32 Spi_EnableIrq(struct fh_spi *dw, u32 irq)
+{
+	u32 data = 0;
+
+	data = dw_readl(dw, imr);
+	data |= irq;
+	dw_writel(dw, imr, data);
+	return CONFIG_OK;
+
+}
+
+static u32 Spi_SetTxlevlel(struct fh_spi *dw, u32 level)
+{
+	dw_writel(dw, txfltr, level);
+	return CONFIG_OK;
+}
+
+static u32 Spi_ReadTxfifolevel(struct fh_spi *dw)
+{
+	return dw_readl(dw, txflr);
+}
+
+static u32 Spi_ReadRxfifolevel(struct fh_spi *dw)
+{
+	return (u32) dw_readl(dw, rxflr);
+}
+
+static u32 Spi_ReadStatus(struct fh_spi *dw)
+{
+	return (uint8_t) dw_readl(dw, sr);
+}
+
+static u32 Spi_EnableSlaveen(struct fh_spi *dw, spi_slave_e port)
+{
+	u32 data = 0;
+
+	gpio_direction_output(dw->active_cs_pin, 0);
+	data = dw_readl(dw, ser);
+	data |= port;
+	dw_writel(dw, ser, data);
+	return CONFIG_OK;
+}
+
+static u32 Spi_DisableSlaveen(struct fh_spi *dw, spi_slave_e port)
+{
+	u32 data = 0;
+	gpio_direction_output(dw->active_cs_pin, 1);
+	data = dw_readl(dw, ser);
+	data &= ~port;
+	dw_writel(dw, ser, data);
+	return CONFIG_OK;
+}
+
+static u32 Spi_WriteData(struct fh_spi *dw, u16 data)
+{
+	dw_writew(dw, dr, data);
+	return WRITE_ONLY_OK;
+}
+
+static u16 Spi_ReadData(struct fh_spi *dw)
+{
+	return dw_readw(dw, dr);
+}
+
+static void Spi_Clearallerror(struct fh_spi *dw)
+{
+	u32 data = dw_readl(dw, icr);
+	data = 0;
+}
+
+static u32 Spi_Isrstatus(struct fh_spi *dw)
+{
+	u32 data = dw_readl(dw, isr);
+	return data;
+}
+
+static void Spi_SetDmaTxDataLevel(struct fh_spi *dw, u32 level)
+{
+	dw_writel(dw, dmatdlr, level);
+}
+
+static void Spi_SetDmaRxDataLevel(struct fh_spi *dw, u32 level)
+{
+	dw_writel(dw, dmardlr, level);
+}
+
+static void Spi_SetDmaControlEnable(struct fh_spi *dw,
+spi_dma_control_mode_e enable_pos)
+{
+	u32 data;
+	data = dw_readl(dw, dmacr);
+	data |= enable_pos;
+	dw_writel(dw, dmacr, data);
+}
+
+static void Spi_SetDmaControlDisable(struct fh_spi *dw,
+spi_dma_control_mode_e enable_pos)
+{
+	u32 data;
+	data = dw_readl(dw, dmacr);
+	data &= ~enable_pos;
+	dw_writel(dw, dmacr, data);
+}
+
+static u32 Spi_SetRxdelay(struct fh_spi *dw, u8 data)
+{
+	dw_writel(dw, rx_sample_dly, data);
+	return CONFIG_OK;
+}
+
+static inline u32 tx_max_tx_only(struct fh_spi_controller *fh_spi)
+{
+	u32 hw_tx_level;
+	hw_tx_level = Spi_ReadTxfifolevel(&fh_spi->dwc);
+	hw_tx_level = fh_spi->dwc.fifo_len - hw_tx_level;
+
+	return min(hw_tx_level, fh_spi->dwc.tx_len);
+}
+
+static inline u32 tx_max(struct fh_spi_controller *fh_spi)
+{
+
+	u32 hw_tx_level, hw_rx_level;
+	u32 temp_tx_lev;
+	temp_tx_lev = Spi_ReadTxfifolevel(&fh_spi->dwc);
+	hw_rx_level = temp_tx_lev + Spi_ReadRxfifolevel(&fh_spi->dwc);
+	/* add shift data... maybe should add apb bus delay */
+	hw_rx_level++;
+
+	hw_tx_level = temp_tx_lev;
+	hw_tx_level = fh_spi->dwc.fifo_len - hw_tx_level;
+	hw_rx_level = fh_spi->dwc.fifo_len - hw_rx_level;
+	/* min(hw_tx_level, fh_spi->dwc.tx_len); */
+	return min(min(hw_tx_level, fh_spi->dwc.tx_len), hw_rx_level); 
+}
+
+/* Return the max entries we should read out of rx fifo */
+static inline u32 rx_max(struct fh_spi_controller *fh_spi)
+{
+	u32 hw_rx_level;
+
+	hw_rx_level = Spi_ReadRxfifolevel(&fh_spi->dwc);
+	return hw_rx_level;
+}
+
+static int fh_spi_init_hw(struct fh_spi_controller *fh_spi,
+struct fh_spi_platform_data *board_info)
+{
+	int status, i;
+
+	fh_spi->dwc.id = board_info->bus_no;
+
+	fh_spi->dwc.fifo_len = board_info->fifo_len;
+	fh_spi->dwc.num_cs = board_info->slave_max_num;
+	for (i = 0; i < fh_spi->dwc.num_cs; i++) {
+		fh_spi->dwc.cs_data[i].GPIO_Pin =
+		                board_info->cs_data[i].GPIO_Pin;
+		fh_spi->dwc.cs_data[i].name = board_info->cs_data[i].name;
+	}
+
+	fh_spi->dwc.rx_hs_no = board_info->rx_handshake_num;
+	fh_spi->dwc.tx_hs_no = board_info->tx_handshake_num;
+	memset(&fh_spi->dwc.dma_rx, 0, sizeof(struct _fh_spi_dma_transfer));
+	memset(&fh_spi->dwc.dma_tx, 0, sizeof(struct _fh_spi_dma_transfer));
+	fh_spi->dwc.complete_times = 0;
+	fh_spi->dwc.pump_data_mode = PUMP_DATA_POLL_MODE;
+	/* bind the platform data here.... */
+	fh_spi->dwc.board_info = board_info;
+
+	fh_spi->dwc.isr_flag = SPI_IRQ_TXEIM | SPI_IRQ_TXOIM | SPI_IRQ_RXUIM
+	                | SPI_IRQ_RXOIM;
+	fh_spi->dwc.frame_mode = SPI_MOTOROLA_MODE;
+	fh_spi->dwc.transfer_mode = SPI_TX_RX_MODE;
+
+	do {
+		status = Spi_ReadStatus(&fh_spi->dwc);
+	} while (status & 0x01);
+	/* add spi disable */
+	Spi_Enable(&fh_spi->dwc, SPI_DISABLE);
+	/* add spi frame mode & transfer mode */
+	Spi_SetFrameFormat(&fh_spi->dwc, fh_spi->dwc.frame_mode);
+	Spi_SetTransferMode(&fh_spi->dwc, fh_spi->dwc.transfer_mode);
+	/* add spi disable all isr */
+	Spi_DisableIrq(&fh_spi->dwc, SPI_IRQ_ALL);
+	/* add spi enable */
+	Spi_Enable(&fh_spi->dwc, SPI_ENABLE);
+	return 0;
+}
+
+static irqreturn_t fh_spi_irq(int irq, void *dev_id)
+{
+	u8* txbuf;
+	struct fh_spi_controller *fh_spi;
+	u32 isr_status;
+	u32 rx_fifo_capability, tx_fifo_capability;
+	u16 data;
+	unsigned size;
+	fh_spi = (struct fh_spi_controller *) dev_id;
+	data = 0x00;
+	txbuf = (u8*) fh_spi->dwc.tx_buff;
+	isr_status = Spi_Isrstatus(&fh_spi->dwc);
+	/* this transfer total size. */
+	size = fh_spi->active_transfer->len;
+	if (isr_status & (SPI_IRQ_TXOIM | SPI_IRQ_RXUIM | SPI_IRQ_RXOIM)) {
+		Spi_Clearallerror(&fh_spi->dwc);
+		/* error handle */
+		dev_err(&fh_spi->p_dev->dev, "spi isr status:%x\n", isr_status);
+		WARN_ON(1);
+	}
+
+	Spi_DisableIrq(&fh_spi->dwc, fh_spi->dwc.isr_flag);
+
+	if (fh_spi->dwc.transfer_mode == SPI_TX_RX_MODE) {
+
+		tx_fifo_capability = tx_max(fh_spi);
+		rx_fifo_capability = rx_max(fh_spi);
+		fh_spi->dwc.rx_len += rx_fifo_capability;
+		while (rx_fifo_capability) {
+			data = Spi_ReadData(&fh_spi->dwc);
+			if (fh_spi->dwc.rx_buff != NULL) {
+				*(u8 *) fh_spi->dwc.rx_buff++ = (u8) data;
+			}
+			rx_fifo_capability--;
+		}
+
+		if (fh_spi->dwc.rx_len == size) {
+			complete(&(fh_spi->done));
+			return IRQ_HANDLED;
+		}
+
+		fh_spi->dwc.tx_len -= tx_fifo_capability;
+		while (tx_fifo_capability) {
+			data = 0x0;
+
+			if (fh_spi->dwc.tx_buff != NULL) {
+				data = *(u8*) fh_spi->dwc.tx_buff++;
+			}
+			Spi_WriteData(&fh_spi->dwc, data);
+			tx_fifo_capability--;
+		}
+		Spi_EnableIrq(&fh_spi->dwc, fh_spi->dwc.isr_flag);
+
+	} else if (fh_spi->dwc.transfer_mode == SPI_ONLY_TX_MODE) {
+		tx_fifo_capability = tx_max(fh_spi);
+
+		fh_spi->dwc.tx_len -= tx_fifo_capability;
+		while (tx_fifo_capability) {
+			/* data = 0x0; */
+			Spi_WriteData(&fh_spi->dwc, *txbuf++);
+			fh_spi->dwc.tx_buff++;
+			tx_fifo_capability--;
+		}
+		if (fh_spi->dwc.tx_len == 0) {
+			complete(&(fh_spi->done));
+			return IRQ_HANDLED;
+		}
+		/* reopen tx isr... */
+		Spi_EnableIrq(&fh_spi->dwc, fh_spi->dwc.isr_flag);
+	}
+	return IRQ_HANDLED;
+}
+
+static int fh_spi_setup_transfer(struct spi_device *spi, struct spi_transfer *t)
+{
+	u8 bits_per_word;
+	u32 hz;
+	u32 div;
+	struct fh_spi_controller *fh_spi = spi_master_get_devdata(spi->master);
+
+	bits_per_word = spi->bits_per_word;
+	if (t && t->bits_per_word)
+		bits_per_word = t->bits_per_word;
+
+	/*
+	 * Calculate speed:
+	 *  - by default, use maximum speed from ssp clk
+	 *  - if device overrides it, use it
+	 *  - if transfer specifies other speed, use transfer's one
+	 */
+	hz = fh_spi->dwc.max_freq;
+	if (spi->max_speed_hz)
+		hz = min(hz, spi->max_speed_hz);
+	if (t && t->speed_hz)
+		hz = min(hz, t->speed_hz);
+
+	div = fh_spi->dwc.apb_clock_in / hz;
+	fh_spi->dwc.div = div;
+
+	if (hz == 0) {
+		dev_err(&spi->dev, "Cannot continue with zero clock\n");
+		WARN_ON(1);
+		return -EINVAL;
+	}
+
+	if (bits_per_word != 8) {
+		dev_err(&spi->dev, "%s, unsupported bits_per_word=%d\n",
+		                __func__, bits_per_word);
+		return -EINVAL;
+	}
+
+	if (spi->mode & SPI_CPOL)
+		fh_spi->dwc.cpol = SPI_POLARITY_HIGH;
+	else
+		fh_spi->dwc.cpol = SPI_POLARITY_LOW;
+
+	if (spi->mode & SPI_CPHA)
+		fh_spi->dwc.cpha = SPI_PHASE_TX_FIRST;
+	else
+		fh_spi->dwc.cpha = SPI_PHASE_RX_FIRST;
+
+	Spi_Enable(&fh_spi->dwc, SPI_DISABLE);
+	Spi_SetPolarity(&fh_spi->dwc, fh_spi->dwc.cpol);
+	Spi_SetPhase(&fh_spi->dwc, fh_spi->dwc.cpha);
+	Spi_SetBaudrate(&fh_spi->dwc, fh_spi->dwc.div);
+	Spi_SetRxdelay(&fh_spi->dwc, 1);
+	Spi_DisableIrq(&fh_spi->dwc, SPI_IRQ_ALL);
+	Spi_Enable(&fh_spi->dwc, SPI_ENABLE);
+	fh_spi_setup(spi);
+	return 0;
+}
+
+static int isr_pump_data(struct fh_spi_controller *fh_spi)
+{
+	u32 status;
+	/* first clear isr... */
+	fh_spi->dwc.isr_flag &= ~(SPI_IRQ_TXEIM | SPI_IRQ_RXFIM);
+	Spi_Enable(&fh_spi->dwc, SPI_DISABLE);
+
+	if ((fh_spi->dwc.rx_buff == NULL) && (fh_spi->dwc.tx_buff != NULL)) {
+
+		fh_spi->dwc.isr_flag |= SPI_IRQ_TXEIM;
+		Spi_SetTxlevlel(&fh_spi->dwc, fh_spi->dwc.fifo_len - 1);
+		Spi_EnableIrq(&fh_spi->dwc, fh_spi->dwc.isr_flag);
+		fh_spi->dwc.transfer_mode = SPI_ONLY_TX_MODE;
+
+	} else {
+		/* tx & rx.. */
+		fh_spi->dwc.isr_flag |= SPI_IRQ_TXEIM;
+		Spi_SetTxlevlel(&fh_spi->dwc, fh_spi->dwc.fifo_len - 1);
+		Spi_EnableIrq(&fh_spi->dwc, fh_spi->dwc.isr_flag);
+		fh_spi->dwc.transfer_mode = SPI_TX_RX_MODE;
+	}
+
+	Spi_SetTransferMode(&fh_spi->dwc, fh_spi->dwc.transfer_mode);
+	Spi_Enable(&fh_spi->dwc, SPI_ENABLE);
+	wait_for_completion(&fh_spi->done);
+	/* add wait spi idle.. */
+	do {
+		status = Spi_ReadStatus(&fh_spi->dwc);
+	} while (status & 0x01);
+
+	return 0;
+}
+
+static bool fh_spi_dma_chan_filter(struct dma_chan *chan, void *param)
+{
+	int dma_channel = *(int *) param;
+	bool ret = false;
+
+	if (chan->chan_id == dma_channel) {
+		ret = true;
+	}
+	return ret;
+}
+
+static void fh_spi_rx_dma_done(void *arg)
+{
+	struct fh_spi_controller *fh_spi = (struct fh_spi_controller *) arg;
+	fh_spi->dwc.complete_times++;
+	if (fh_spi->dwc.complete_times == 2) {
+		fh_spi->dwc.complete_times = 0;
+		complete(&(fh_spi->done));
+	}
+}
+
+
+
+static int dma_set_tx_para(struct fh_spi_controller *fh_spi)
+{
+	struct fh_dma_pri fh_pri;
+	struct dma_slave_config *tx_config;
+	struct spi_transfer *t;
+	struct dma_chan *txchan;
+	struct scatterlist *p_sca_list;
+	unsigned int sg_size = 0;
+	int i, xfer_len, one_sg_data_len;
+	unsigned char *temp_buf;
+	t = fh_spi->active_transfer;
+	memset(&fh_spi->dwc.dma_tx.cfg, 0, sizeof(struct dma_slave_config));
+	txchan = fh_spi->dwc.dma_tx.chan;
+	tx_config = &fh_spi->dwc.dma_tx.cfg;
+	tx_config->dst_addr = fh_spi->dwc.paddr + SPI_DATA_REG_OFFSET;
+	/* set the spi data tx reg */
+	tx_config->dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
+	tx_config->src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
+	tx_config->slave_id = fh_spi->dwc.tx_hs_no;
+	tx_config->src_maxburst = 4;
+	tx_config->dst_maxburst = 4;
+	tx_config->direction = DMA_MEM_TO_DEV;
+	tx_config->device_fc = FALSE;
+	xfer_len = t->len;
+	temp_buf = (unsigned char*)t->tx_buf;
+	sg_size =  t->len /SG_ONE_TIME_MAX_SIZE; 
+	if(t->len % SG_ONE_TIME_MAX_SIZE){
+		sg_size++;
+	}
+	if(sg_size > MAX_SG_LEN) {
+		printk("%s_%d :: too large sg size:0x%x\n",__func__,__LINE__,sg_size);
+		return -1;
+	}
+	p_sca_list = &fh_spi->dwc.dma_tx.sgl[0];
+	for(i=0;i<sg_size;i++,p_sca_list++){
+		one_sg_data_len = min(xfer_len,SG_ONE_TIME_MAX_SIZE);
+		xfer_len -=one_sg_data_len;
+
+		if (t->tx_buf == NULL){
+			fh_pri.sinc = FH_DMA_SLAVE_FIX;
+			p_sca_list->dma_address =  fh_spi->dwc.tx_dumy_dma_add;
+		}
+		else{
+			fh_pri.sinc = FH_DMA_SLAVE_INC;
+			p_sca_list->dma_address = dma_map_single(
+		                txchan->dev->device.parent,
+		                (void*) temp_buf, one_sg_data_len,
+		                DMA_TO_DEVICE);
+			fh_spi->dwc.dma_tx.sgl_data_size[i] = one_sg_data_len;
+			temp_buf += one_sg_data_len;
+
+		}
+		p_sca_list->length = one_sg_data_len;
+	}
+	fh_pri.dinc = FH_DMA_SLAVE_FIX;
+	dmaengine_slave_config(txchan, tx_config);
+
+	fh_spi->dwc.dma_tx.desc = txchan->device->device_prep_slave_sg(txchan,
+				&fh_spi->dwc.dma_tx.sgl[0], sg_size, DMA_MEM_TO_DEV,
+				DMA_PREP_INTERRUPT | DMA_COMPL_SKIP_DEST_UNMAP,
+				&fh_pri);
+	fh_spi->dwc.dma_tx.actual_sgl_size = sg_size;
+	fh_spi->dwc.dma_tx.desc->callback = fh_spi_rx_dma_done;
+	fh_spi->dwc.dma_tx.desc->callback_param = fh_spi;
+	return 0;
+
+}
+
+static int dma_set_rx_para(struct fh_spi_controller *fh_spi)
+{
+
+	struct fh_dma_pri fh_pri;
+	struct dma_slave_config *rx_config;
+	struct spi_transfer *t;
+	struct dma_chan *rxchan;
+	struct scatterlist *p_sca_list;
+	unsigned int sg_size = 0;
+	int i, xfer_len, one_sg_data_len;
+	unsigned char *temp_buf;
+
+	t = fh_spi->active_transfer;
+	rxchan = fh_spi->dwc.dma_rx.chan;
+	memset(&fh_spi->dwc.dma_rx.cfg, 0, sizeof(struct dma_slave_config));
+	rx_config = &fh_spi->dwc.dma_rx.cfg;
+	rx_config->src_addr = fh_spi->dwc.paddr + SPI_DATA_REG_OFFSET;
+	rx_config->src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
+	rx_config->dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
+	rx_config->slave_id = fh_spi->dwc.rx_hs_no;
+	rx_config->src_maxburst = 4;
+	rx_config->dst_maxburst = 4;
+	rx_config->device_fc = FALSE;
+	rx_config->direction = DMA_DEV_TO_MEM;
+	xfer_len = t->len;
+	temp_buf = (unsigned char*)t->rx_buf;
+	sg_size =  t->len /SG_ONE_TIME_MAX_SIZE; 
+	if(t->len % SG_ONE_TIME_MAX_SIZE){
+		sg_size++;
+	}
+	if(sg_size > MAX_SG_LEN) {
+		printk("%s_%d :: too large sg size:0x%x\n",__func__,__LINE__,sg_size);
+		return -1;
+	}
+	p_sca_list = &fh_spi->dwc.dma_rx.sgl[0];
+	for(i=0;i<sg_size;i++,p_sca_list++){
+		one_sg_data_len = min(xfer_len,SG_ONE_TIME_MAX_SIZE);
+		xfer_len -=one_sg_data_len;
+		if (t->rx_buf == NULL){
+			fh_pri.dinc = FH_DMA_SLAVE_FIX;
+			p_sca_list->dma_address =  fh_spi->dwc.rx_dumy_dma_add;
+		}
+		else{
+			fh_pri.dinc = FH_DMA_SLAVE_INC;
+			p_sca_list->dma_address = dma_map_single(
+		                rxchan->dev->device.parent,
+		                (void*) temp_buf, one_sg_data_len,
+		                DMA_FROM_DEVICE);
+			fh_spi->dwc.dma_rx.sgl_data_size[i] = one_sg_data_len;
+			temp_buf += one_sg_data_len;
+		}
+		p_sca_list->length = one_sg_data_len;
+	}
+
+	fh_pri.sinc = FH_DMA_SLAVE_FIX;
+	dmaengine_slave_config(rxchan, rx_config);
+	fh_spi->dwc.dma_rx.desc = rxchan->device->device_prep_slave_sg(rxchan,
+	                &fh_spi->dwc.dma_rx.sgl[0], sg_size, DMA_DEV_TO_MEM,
+	                DMA_PREP_INTERRUPT | DMA_COMPL_SKIP_DEST_UNMAP,
+	                &fh_pri);
+	fh_spi->dwc.dma_rx.actual_sgl_size = sg_size;
+	fh_spi->dwc.dma_rx.desc->callback = fh_spi_rx_dma_done;
+	fh_spi->dwc.dma_rx.desc->callback_param = fh_spi;
+
+	return 0;
+
+}
+
+void unmap_dma_tx_sg(struct fh_spi_controller *fh_spi){
+	struct dma_chan *txchan;
+	struct scatterlist *p_sca_list;
+	int i;
+	txchan = fh_spi->dwc.dma_tx.chan;
+	p_sca_list = &fh_spi->dwc.dma_tx.sgl[0];
+	for(i=0;i<fh_spi->dwc.dma_tx.actual_sgl_size;i++,p_sca_list++){
+		dma_unmap_single(txchan->dev->device.parent,
+				p_sca_list->dma_address,
+				fh_spi->dwc.dma_tx.sgl_data_size[i], DMA_MEM_TO_DEV);
+	}
+}
+
+void unmap_dma_rx_sg(struct fh_spi_controller *fh_spi){
+	struct dma_chan *rxchan;
+	struct scatterlist *p_sca_list;
+	int i;
+	
+	rxchan = fh_spi->dwc.dma_rx.chan;
+	p_sca_list = &fh_spi->dwc.dma_rx.sgl[0];
+	for(i=0;i<fh_spi->dwc.dma_rx.actual_sgl_size;i++,p_sca_list++){
+		dma_unmap_single(rxchan->dev->device.parent,
+				p_sca_list->dma_address,
+				fh_spi->dwc.dma_rx.sgl_data_size[i], DMA_FROM_DEVICE);
+	}
+}
+
+
+static int dma_pump_data(struct fh_spi_controller *fh_spi)
+{
+	struct spi_transfer *t;
+	struct dma_chan *rxchan;
+	struct dma_chan *txchan;
+	int ret;
+	t = fh_spi->active_transfer;
+	txchan = fh_spi->dwc.dma_tx.chan;
+	rxchan = fh_spi->dwc.dma_rx.chan;
+	init_completion(&fh_spi->done);
+	ret = dma_set_tx_para(fh_spi);
+	if (ret != 0) {
+		return ret;
+	}
+	ret = dma_set_rx_para(fh_spi);
+	if (ret != 0) {
+		unmap_dma_tx_sg(fh_spi);
+		return ret;
+	}
+	Spi_Enable(&fh_spi->dwc, SPI_DISABLE);
+	Spi_SetDmaRxDataLevel(&fh_spi->dwc, 3);
+	Spi_SetDmaControlEnable(&fh_spi->dwc, SPI_DMA_RX_POS);
+	Spi_SetDmaTxDataLevel(&fh_spi->dwc, 4);
+	Spi_SetDmaControlEnable(&fh_spi->dwc, SPI_DMA_TX_POS);
+	Spi_Enable(&fh_spi->dwc, SPI_ENABLE);
+	fh_spi->dwc.dma_rx.desc->tx_submit(fh_spi->dwc.dma_rx.desc);
+	fh_spi->dwc.dma_tx.desc->tx_submit(fh_spi->dwc.dma_tx.desc);
+	wait_for_completion(&fh_spi->done);
+	if (t->tx_buf != NULL) {
+		unmap_dma_tx_sg(fh_spi);
+	}
+	if (t->rx_buf != NULL) {
+		unmap_dma_rx_sg(fh_spi);
+	}
+	Spi_SetDmaControlDisable(&fh_spi->dwc, SPI_DMA_RX_POS);
+	Spi_SetDmaControlDisable(&fh_spi->dwc, SPI_DMA_TX_POS);
+	return 0;
+
+}
+
+static int poll_pump_data(struct fh_spi_controller *fh_spi)
+{
+	register u32 rx_fifo_capability, tx_fifo_capability;
+	u8* txbuf;
+	u8* rxbuf;
+	u16 data;
+	u32 size;
+	rxbuf = (u8*) fh_spi->dwc.rx_buff;
+	txbuf = (u8*) fh_spi->dwc.tx_buff;
+	size = fh_spi->active_transfer->len;
+
+	Spi_Enable(&fh_spi->dwc, SPI_DISABLE);
+	fh_spi->dwc.transfer_mode = SPI_TX_RX_MODE;
+	Spi_SetTransferMode(&fh_spi->dwc, fh_spi->dwc.transfer_mode);
+	Spi_Enable(&fh_spi->dwc, SPI_ENABLE);
+
+	goto first;
+	start: rx_fifo_capability = rx_max(fh_spi);
+	fh_spi->dwc.rx_len += rx_fifo_capability;
+
+	if (rxbuf != NULL) {
+		fh_spi->dwc.rx_buff += rx_fifo_capability;
+		while (rx_fifo_capability) {
+			*rxbuf++ = Spi_ReadData(&fh_spi->dwc);
+			rx_fifo_capability--;
+		}
+
+	} else {
+		while (rx_fifo_capability) {
+			data = Spi_ReadData(&fh_spi->dwc);
+			rx_fifo_capability--;
+		}
+	}
+
+	if (fh_spi->dwc.rx_len == size) {
+		return 0;
+	}
+
+	first: tx_fifo_capability = tx_max(fh_spi);
+	fh_spi->dwc.tx_len -= tx_fifo_capability;
+	if (txbuf != NULL) {
+		fh_spi->dwc.tx_buff += tx_fifo_capability;
+		while (tx_fifo_capability) {
+			Spi_WriteData(&fh_spi->dwc, *txbuf++);
+			tx_fifo_capability--;
+		}
+
+	} else {
+		while (tx_fifo_capability) {
+			Spi_WriteData(&fh_spi->dwc, 0xff);
+			tx_fifo_capability--;
+		}
+	}
+
+	goto start;
+
+	return 0;
+}
+
+static int fh_spi_handle_message(struct fh_spi_controller *fh_spi,
+                struct spi_message *m)
+{
+	bool first, last;
+	struct spi_transfer *t, *tmp_t;
+	int status = 0;
+	int cs_change;
+	cs_change = 1;
+	m->actual_length = 0;
+	fh_spi->active_message = m;
+
+	list_for_each_entry_safe(t, tmp_t, &m->transfers, transfer_list)
+	{
+		first = (&t->transfer_list == m->transfers.next);
+		last = (&t->transfer_list == m->transfers.prev);
+
+		if (first || t->speed_hz || t->bits_per_word)
+		fh_spi_setup_transfer(m->spi, t);
+
+		if (cs_change) {
+			Spi_EnableSlaveen(&fh_spi->dwc, fh_spi->dwc.slave_port);
+		}
+		cs_change = t->cs_change;
+
+		fh_spi->active_transfer = t;
+		fh_spi->dwc.tx_len = t->len;
+		fh_spi->dwc.rx_len = 0;
+		fh_spi->dwc.tx_buff = (void *) t->tx_buf;
+		fh_spi->dwc.rx_buff = t->rx_buf;
+
+		if (fh_spi->dwc.board_info->dma_transfer_enable
+				== SPI_TRANSFER_USE_DMA) {
+
+			if(fh_spi->dwc.tx_len < DMA_TRANS_GATE_LEVEL) {
+				fh_spi->dwc.pump_data_mode = PUMP_DATA_POLL_MODE;
+				goto pump_data;
+			}
+			fh_spi->dwc.pump_data_mode = PUMP_DATA_DMA_MODE;
+		}
+		else {
+			fh_spi->dwc.pump_data_mode = PUMP_DATA_POLL_MODE;
+		}
+
+		pump_data:
+
+		switch (fh_spi->dwc.pump_data_mode) {
+			case PUMP_DATA_DMA_MODE:
+			status = dma_pump_data(fh_spi);
+			if (status == 0) {
+				break;
+			} else {
+				WARN_ON(1);
+				dev_err(&fh_spi->p_dev->dev,
+						"spi dma pump data error\n");
+				fh_spi->dwc.pump_data_mode =
+				PUMP_DATA_POLL_MODE;
+			}
+
+			case PUMP_DATA_ISR_MODE:
+			status = isr_pump_data(fh_spi);
+			break;
+
+			case PUMP_DATA_POLL_MODE:
+			status = poll_pump_data(fh_spi);
+			break;
+			default:
+			status = -1;
+			WARN_ON(1);
+			dev_err(&fh_spi->p_dev->dev,
+					"spi pump data mode error..\n");
+		}
+
+		if (!cs_change && last) {
+			Spi_DisableSlaveen(&fh_spi->dwc,
+					fh_spi->dwc.slave_port);
+		}
+/* 
+*      if (t->delay_usecs)
+*		udelay(t->delay_usecs);
+*/
+		m->actual_length += t->len;
+		if (status)
+			break;
+
+	}
+
+	return status;
+
+}
+
+static void fh_spi_handle(struct work_struct *w)
+{
+	struct fh_spi_controller
+	*fh_spi = container_of(w, struct fh_spi_controller, work);
+	unsigned long flags;
+	struct spi_message *m;
+	spin_lock_irqsave(&fh_spi->lock, flags);
+	while (!list_empty(&fh_spi->queue)) {
+		m = list_entry(fh_spi->queue.next, struct spi_message, queue);
+		list_del_init(&m->queue);
+		spin_unlock_irqrestore(&fh_spi->lock, flags);
+		m->status = fh_spi_handle_message(fh_spi, m);
+		if (m->complete)
+			m->complete(m->context);
+
+		spin_lock_irqsave(&fh_spi->lock, flags);
+	}
+	spin_unlock_irqrestore(&fh_spi->lock, flags);
+
+}
+
+static int fh_spi_transfer(struct spi_device *spi, struct spi_message *m)
+{
+	struct fh_spi_controller *fh_spi = spi_master_get_devdata(spi->master);
+	unsigned long flags;
+	m->status = -EINPROGRESS;
+	spin_lock_irqsave(&fh_spi->lock, flags);
+	list_add_tail(&m->queue, &fh_spi->queue);
+	spin_unlock_irqrestore(&fh_spi->lock, flags);
+	queue_work(fh_spi->workqueue, &fh_spi->work);
+	return 0;
+}
+
+static int fh_spi_setup(struct spi_device *spi)
+{
+	/* spi_setup() does basic checks,
+	 * stmp_spi_setup_transfer() does more later
+	 */
+	struct fh_spi_controller *fh_spi = spi_master_get_devdata(spi->master);
+
+	fh_spi->dwc.active_cs_pin =
+	                fh_spi->dwc.cs_data[spi->chip_select].GPIO_Pin;
+
+	if (spi->chip_select >= fh_spi->dwc.num_cs) {
+		dev_err(&spi->dev, "%s, unsupported chip select no=%d\n",
+		                __func__, spi->chip_select);
+		return -EINVAL;
+	}
+	fh_spi->dwc.slave_port = 1 << spi->chip_select;
+
+	if (spi->bits_per_word != 8) {
+		dev_err(&spi->dev, "%s, unsupported bits_per_word=%d\n",
+		                __func__, spi->bits_per_word);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void fh_spi_cleanup(struct spi_device *spi)
+{
+
+}
+
+static int __devinit fh_spi_probe(struct platform_device *dev)
+{
+	int err = 0;
+	struct spi_master *master;
+	struct fh_spi_controller *fh_spi;
+	struct resource *r, *ioarea;
+	int ret, i, j;
+	dma_cap_mask_t mask;
+	int filter_no;
+	struct fh_spi_platform_data * spi_platform_info;
+
+	spi_platform_info =
+	                (struct fh_spi_platform_data *) dev->dev.platform_data;
+	if (spi_platform_info == NULL) {
+
+		err = -ENODEV;
+		goto out0;
+	}
+
+	master = spi_alloc_master(&dev->dev, sizeof(struct fh_spi_controller));
+	if (master == NULL) {
+		err = -ENOMEM;
+		dev_err(&dev->dev, "%s, master malloc failed.\n", __func__);
+		goto out0;
+	}
+
+	fh_spi = spi_master_get_devdata(master);
+	if (!fh_spi) {
+		dev_err(&dev->dev, "%s, master dev data is null.\n", __func__);
+		err = -ENOMEM;
+		goto out_put_master;
+	}
+	fh_spi->master_dev = &dev->dev;
+	fh_spi->p_dev = dev;
+	platform_set_drvdata(dev, master);
+
+	fh_spi->dwc.irq = platform_get_irq(dev, 0);
+	if (fh_spi->dwc.irq < 0) {
+		dev_err(&dev->dev, "%s, spi irq no error.\n", __func__);
+		err = fh_spi->dwc.irq;
+		goto out_set_plat_drvdata_null;
+	}
+
+	err = request_irq(fh_spi->dwc.irq, fh_spi_irq, 0, dev_name(&dev->dev),
+	                fh_spi);
+	if (err) {
+		dev_dbg(&dev->dev, "request_irq failed, %d\n", err);
+		goto out_set_plat_drvdata_null;
+	}
+
+	/* Get resources(memory, IRQ) associated with the device */
+	r = platform_get_resource(dev, IORESOURCE_MEM, 0);
+	if (r == NULL) {
+		dev_err(&dev->dev, "%s, spi ioresource error. \n", __func__);
+		err = -ENODEV;
+		goto out_free_irq;
+	}
+
+	fh_spi->dwc.paddr = r->start;
+	ioarea = request_mem_region(r->start, resource_size(r), dev->name);
+	if (!ioarea) {
+		dev_err(&dev->dev, "spi region already claimed\n");
+		err = -EBUSY;
+		goto out_free_irq;
+	}
+
+	fh_spi->dwc.regs = ioremap(r->start, resource_size(r));
+	if (!fh_spi->dwc.regs) {
+		dev_err(&dev->dev, "spi region already mapped\n");
+		err = -EINVAL;
+		goto out_relase_mem_region;
+	}
+
+	INIT_WORK(&fh_spi->work, fh_spi_handle);
+	init_completion(&fh_spi->done);
+	INIT_LIST_HEAD(&fh_spi->queue);
+	spin_lock_init(&fh_spi->lock);
+
+	fh_spi->workqueue = create_singlethread_workqueue(dev_name(&dev->dev));
+	if (!fh_spi->workqueue) {
+		err = -ENXIO;
+		goto out_iounmap;
+	}
+	master->transfer = fh_spi_transfer;
+	master->setup = fh_spi_setup;
+	master->cleanup = fh_spi_cleanup;
+
+	/* the spi->mode bits understood by this driver: */
+	master->mode_bits = SPI_CPOL | SPI_CPHA;
+	master->bus_num = dev->id;
+	spi_platform_info->bus_no = dev->id;
+
+	master->num_chipselect = spi_platform_info->slave_max_num;
+	/* parse the controller board info~~~ */
+	/* clk enable in the func */
+	ret = fh_spi_init_hw(fh_spi, spi_platform_info);
+	if (ret) {
+		err = ret;
+		goto out_destroy_queue;
+	}
+	fh_spi->clk = clk_get(&fh_spi->p_dev->dev, spi_platform_info->clk_name);
+
+	if (IS_ERR(fh_spi->clk)) {
+		dev_err(&fh_spi->p_dev->dev, "cannot find the spi%d clk.\n",
+		                fh_spi->dwc.id);
+		err = PTR_ERR(fh_spi->clk);
+		goto out_destroy_queue;
+	}
+
+	clk_enable(fh_spi->clk);
+	fh_spi->dwc.apb_clock_in = clk_get_rate(fh_spi->clk);
+	if (spi_platform_info->apb_clock_in > fh_spi->dwc.apb_clock_in) {
+		clk_set_rate(fh_spi->clk, spi_platform_info->apb_clock_in);
+		fh_spi->dwc.apb_clock_in = spi_platform_info->apb_clock_in;
+	}
+	fh_spi->dwc.max_freq = fh_spi->dwc.apb_clock_in / 2;
+
+	/* request the cs gpio */
+	for (i = 0; i < fh_spi->dwc.num_cs; i++) {
+		ret = gpio_request(fh_spi->dwc.cs_data[i].GPIO_Pin,
+		                fh_spi->dwc.cs_data[i].name);
+		if (ret) {
+			dev_err(&dev->dev,
+			                "spi failed to request the gpio:%d\n",
+			                fh_spi->dwc.cs_data[i].GPIO_Pin);
+			/* release the gpio already request.. */
+			if (i != 0) {
+				for (j = 0; j < i; j++) {
+					gpio_free(
+					                fh_spi->dwc.cs_data[j].GPIO_Pin);
+				}
+			}
+			err = ret;
+			/* clk disable */
+			goto out_clk_disable;
+		}
+		/* set the dir */
+		gpio_direction_output(fh_spi->dwc.cs_data[i].GPIO_Pin,
+		                GPIOF_OUT_INIT_HIGH);
+	}
+	/* fix:need use the platform dma channel.. not 0 and 1.... */
+	if (fh_spi->dwc.board_info->dma_transfer_enable == SPI_TRANSFER_USE_DMA) {
+		filter_no = fh_spi->dwc.board_info->tx_dma_channel;
+		dma_cap_zero(mask);
+		dma_cap_set(DMA_SLAVE, mask);
+		fh_spi->dwc.dma_tx.chan = dma_request_channel(mask,
+		                fh_spi_dma_chan_filter, &filter_no);
+
+		if (!fh_spi->dwc.dma_tx.chan) {
+			dev_err(&fh_spi->p_dev->dev,
+			                "spi%d request dma channel error....\n",
+			                fh_spi->dwc.id);
+			fh_spi->dwc.board_info->dma_transfer_enable = 0;
+			goto step_register_master;
+		}
+		filter_no = fh_spi->dwc.board_info->rx_dma_channel;
+		fh_spi->dwc.dma_rx.chan = dma_request_channel(mask,
+		                fh_spi_dma_chan_filter, &filter_no);
+
+		if (!fh_spi->dwc.dma_rx.chan) {
+			dev_err(&fh_spi->p_dev->dev,
+			                "spi%d request dma channel error....\n",
+			                fh_spi->dwc.id);
+			dma_release_channel(fh_spi->dwc.dma_tx.chan);
+			fh_spi->dwc.board_info->dma_transfer_enable = 0;
+			goto step_register_master;
+		}
+
+		fh_spi->dwc.tx_dumy_dma_add = dma_map_single(
+		                fh_spi->dwc.dma_tx.chan->dev->device.parent,
+		                (void*) fh_spi->dwc.tx_dumy_buff,
+		                sizeof(fh_spi->dwc.tx_dumy_buff),
+		                DMA_TO_DEVICE);
+
+		fh_spi->dwc.rx_dumy_dma_add = dma_map_single(
+		                fh_spi->dwc.dma_rx.chan->dev->device.parent,
+		                (void*) fh_spi->dwc.rx_dumy_buff,
+		                sizeof(fh_spi->dwc.rx_dumy_buff),
+		                DMA_TO_DEVICE);
+
+	}
+
+step_register_master:
+	err = spi_register_master(master);
+	if (err) {
+		dev_dbg(&dev->dev, "cannot register spi master, %d\n", err);
+		goto out_gpio_tree;
+	}
+
+	return 0;
+
+out_gpio_tree:
+	for (i = 0; i < fh_spi->dwc.num_cs; i++) {
+		gpio_free(fh_spi->dwc.cs_data[i].GPIO_Pin);
+	}
+out_clk_disable:
+	clk_disable(fh_spi->clk);
+out_destroy_queue:
+	destroy_workqueue(fh_spi->workqueue);
+out_iounmap:
+	iounmap(fh_spi->dwc.regs);
+out_relase_mem_region:
+	release_mem_region(r->start, resource_size(r));
+out_free_irq:
+	free_irq(fh_spi->dwc.irq, fh_spi);
+out_set_plat_drvdata_null:
+	memset(fh_spi, 0,sizeof(struct fh_spi_controller));
+	platform_set_drvdata(dev, NULL);
+out_put_master:
+	spi_master_put(master);
+out0:
+	return err;
+
+}
+
+static int __devexit fh_spi_remove(struct platform_device *dev)
+{
+	struct resource *r;
+	struct spi_master *master;
+	struct fh_spi_controller *fh_spi;
+	int i;
+	master = platform_get_drvdata(dev);
+	if (master == NULL)
+		goto out0;
+
+	fh_spi = spi_master_get_devdata(master);
+	spi_unregister_master(master);
+	for(i = 0;i<fh_spi->dwc.num_cs;i++) {
+		gpio_free(fh_spi->dwc.cs_data[i].GPIO_Pin);
+	}
+	clk_disable(fh_spi->clk);
+	if(fh_spi->dwc.pump_data_mode == PUMP_DATA_DMA_MODE) {
+		if(fh_spi->dwc.dma_rx.chan) {
+			dma_release_channel(fh_spi->dwc.dma_rx.chan);
+			fh_spi->dwc.dma_rx.chan->private = NULL;
+		}
+		if(fh_spi->dwc.dma_tx.chan) {
+			dma_release_channel(fh_spi->dwc.dma_tx.chan);
+			fh_spi->dwc.dma_tx.chan->private = NULL;
+		}
+	}
+	destroy_workqueue(fh_spi->workqueue);
+	r = platform_get_resource(dev, IORESOURCE_MEM, 0);
+	iounmap(fh_spi->dwc.regs);
+	release_mem_region(r->start, resource_size(r));
+	free_irq(fh_spi->dwc.irq, fh_spi);
+	memset(fh_spi,0,sizeof(struct fh_spi_controller));
+	platform_set_drvdata(dev, NULL);
+	spi_master_put(master);
+
+out0:
+	return 0;
+
+}
+
+static struct platform_driver fh_spi_driver = {
+		.probe = fh_spi_probe,
+		.remove = __devexit_p(fh_spi_remove),
+		.driver = {
+				.name = "fh_spi",
+				.owner = THIS_MODULE,
+		},
+		.suspend = NULL,
+		.resume = NULL,
+};
+
+static int __init fh_spi_init(void)
+{
+	return platform_driver_register(&fh_spi_driver);
+}
+
+static void __exit fh_spi_exit(void)
+{
+	platform_driver_unregister(&fh_spi_driver);
+}
+
+module_init(fh_spi_init);
+module_exit(fh_spi_exit);
+MODULE_AUTHOR("yu.zhang <zhangy@fullhan.com>");
+MODULE_DESCRIPTION("DUOBAO SPI driver");
+MODULE_LICENSE("GPL");
diff -uraN linux-3.0.8/drivers/spi/fh_spi_slave.c linux-3.0.8-fh8632-V1.0_20180330/drivers/spi/fh_spi_slave.c
--- linux-3.0.8/drivers/spi/fh_spi_slave.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/spi/fh_spi_slave.c	2021-07-13 23:40:34.222359723 +0300
@@ -0,0 +1,979 @@
+/*
+ * fh_slave_spi.c
+ *
+ *  Created on: Sep 19, 2016
+ *      Author: duobao
+ */
+
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/scatterlist.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/bug.h>
+#include <linux/completion.h>
+#include <linux/gpio.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <mach/fh_dmac.h>
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <mach/io.h>
+#include <linux/kfifo.h>
+#include <mach/spi.h>
+
+#define lift_shift_bit_num(bit_num)	(1<<bit_num)
+//read spi irq, only useful if you set which is masked
+#define SPI_IRQ_TXEIS	(lift_shift_bit_num(0))
+#define SPI_IRQ_TXOIS	(lift_shift_bit_num(1))
+#define SPI_IRQ_RXUIS	(lift_shift_bit_num(2))
+#define SPI_IRQ_RXOIS	(lift_shift_bit_num(3))
+#define SPI_IRQ_RXFIS	(lift_shift_bit_num(4))
+#define SPI_IRQ_MSTIS	(lift_shift_bit_num(5))
+//spi status
+#define SPI_STATUS_BUSY         (lift_shift_bit_num(0))
+#define SPI_STATUS_TFNF         (lift_shift_bit_num(1))
+#define SPI_STATUS_TFE          (lift_shift_bit_num(2))
+#define SPI_STATUS_RFNE         (lift_shift_bit_num(3))
+#define SPI_STATUS_RFF          (lift_shift_bit_num(4))
+#define SPI_STATUS_TXE          (lift_shift_bit_num(5))
+#define SPI_STATUS_DCOL         (lift_shift_bit_num(6))
+#define CACHE_LINE_SIZE		(32)
+#define PUMP_DATA_NONE_MODE	(0x00)
+#define PUMP_DATA_DMA_MODE	(0x11)
+#define PUMP_DATA_ISR_MODE	(0x22)
+#define PUMP_DATA_POLL_MODE	(0x33)
+#define SPI_DIV_TRANSFER_SIZE	(256)
+#define SPI_DATA_REG_OFFSET	(0x60)
+#define KFIFO_SIZE		2048
+#define DUMY_DATA		0xff
+#define SPI_SLAVE_MAX_FIFO_SIZE	256
+#define SLAVE_SET_PHASE		1
+#define SLAVE_SET_POLARITY	SLAVE_SET_PHASE + 1
+#define SLAVE_INIT_RX_FIFO 	SLAVE_SET_POLARITY + 1
+#define SLAVE_INIT_TX_FIFO 	SLAVE_INIT_RX_FIFO + 1
+#define SLAVE_GET_ERROR_STATUS	SLAVE_INIT_TX_FIFO + 1
+
+//#define FH_SPI_SLAVE_DEBUG
+#define MAX_SPI_SLAVES			8
+/****************************************************************************
+ * ADT section
+ *  add definition of user defined Data Type that only be used in this file  here
+ ***************************************************************************/
+enum {
+	CONFIG_OK = 0, CONFIG_PARA_ERROR = lift_shift_bit_num(0),
+	//only for the set slave en/disable
+	CONFIG_BUSY = lift_shift_bit_num(1),
+	//only for write_read mode
+	WRITE_READ_OK = 0,
+	WRITE_READ_ERROR = lift_shift_bit_num(2),
+	WRITE_READ_TIME_OUT = lift_shift_bit_num(3),
+	//only for write only mode
+	WRITE_ONLY_OK = 0,
+	WRITE_ONLY_ERROR = lift_shift_bit_num(4),
+	WRITE_ONLY_TIME_OUT = lift_shift_bit_num(5),
+	//only for read only mode
+	READ_ONLY_OK = 0,
+	READ_ONLY_ERROR = lift_shift_bit_num(6),
+	READ_ONLY_TIME_OUT = lift_shift_bit_num(7),
+	//eeprom mode
+	EEPROM_OK = 0,
+	EEPROM_ERROR = lift_shift_bit_num(8),
+	EEPROM_TIME_OUT = lift_shift_bit_num(9),
+	//if read/write/eeprom error,the error below could give you more info by reading the 'Spi_ReadTransferError' function
+	MULTI_MASTER_ERROR = lift_shift_bit_num(10),
+	TX_OVERFLOW_ERROR = lift_shift_bit_num(11),
+	RX_OVERFLOW_ERROR = lift_shift_bit_num(12),
+};
+
+//enable spi
+typedef enum enum_spi_enable {
+	SPI_DISABLE = 0,
+	SPI_ENABLE = (lift_shift_bit_num(0)),
+} spi_enable_e;
+
+//polarity
+typedef enum enum_spi_polarity {
+	SPI_POLARITY_LOW = 0,
+	SPI_POLARITY_HIGH = (lift_shift_bit_num(7)),
+	//bit pos
+	SPI_POLARITY_RANGE = (lift_shift_bit_num(7)),
+} spi_polarity_e;
+
+//phase
+typedef enum enum_spi_phase {
+	SPI_PHASE_RX_FIRST = 0,
+	SPI_PHASE_TX_FIRST = (lift_shift_bit_num(6)),
+	//bit pos
+	SPI_PHASE_RANGE = (lift_shift_bit_num(6)),
+} spi_phase_e;
+
+//frame format
+typedef enum enum_spi_format {
+	SPI_MOTOROLA_MODE = 0x00,
+	SPI_TI_MODE = 0x10,
+	SPI_MICROWIRE_MODE = 0x20,
+	//bit pos
+	SPI_FRAME_FORMAT_RANGE = 0x30,
+} spi_format_e;
+
+//data size
+typedef enum enum_spi_data_size {
+	SPI_DATA_SIZE_4BIT = 0x03,
+	SPI_DATA_SIZE_5BIT = 0x04,
+	SPI_DATA_SIZE_6BIT = 0x05,
+	SPI_DATA_SIZE_7BIT = 0x06,
+	SPI_DATA_SIZE_8BIT = 0x07,
+	SPI_DATA_SIZE_9BIT = 0x08,
+	SPI_DATA_SIZE_10BIT = 0x09,
+	SPI_DATA_SIZE_16BIT = 0x0f,
+	//bit pos
+	SPI_DATA_SIZE_RANGE = 0x0f,
+} spi_data_size_e;
+
+//transfer mode
+typedef enum enum_spi_transfer_mode {
+	SPI_TX_RX_MODE = 0x000,
+	SPI_ONLY_TX_MODE = 0x100,
+	SPI_ONLY_RX_MODE = 0x200,
+	SPI_EEPROM_MODE = 0x300,
+	//bit pos
+	SPI_TRANSFER_MODE_RANGE = 0x300,
+} spi_transfer_mode_e;
+
+//spi baudrate
+typedef enum enum_spi_baudrate {
+	SPI_SCLKIN = 50000000,
+	SPI_SCLKOUT_27000000 = (SPI_SCLKIN / 27000000), //27M
+	SPI_SCLKOUT_13500000 = (SPI_SCLKIN / 13500000),  //13.5M
+	SPI_SCLKOUT_6750000 = (SPI_SCLKIN / 6750000),  //6.75M
+	SPI_SCLKOUT_4500000 = (SPI_SCLKIN / 4500000),	 //4.5M
+	SPI_SCLKOUT_3375000 = (SPI_SCLKIN / 3375000),  //3.375M
+	SPI_SCLKOUT_2700000 = (SPI_SCLKIN / 2700000),	 //2.7M
+	SPI_SCLKOUT_1500000 = (SPI_SCLKIN / 1500000),  //1.5M
+	SPI_SCLKOUT_500000 = (SPI_SCLKIN / 500000),  //0.1M
+	SPI_SCLKOUT_100000 = (SPI_SCLKIN / 100000),  //0.1M
+} spi_baudrate_e;
+
+//spi_irq
+typedef enum enum_spi_irq {
+	SPI_IRQ_TXEIM = (lift_shift_bit_num(0)),
+	SPI_IRQ_TXOIM = (lift_shift_bit_num(1)),
+	SPI_IRQ_RXUIM = (lift_shift_bit_num(2)),
+	SPI_IRQ_RXOIM = (lift_shift_bit_num(3)),
+	SPI_IRQ_RXFIM = (lift_shift_bit_num(4)),
+	SPI_IRQ_MSTIM = (lift_shift_bit_num(5)),
+	SPI_IRQ_ALL = 0x3f,
+} spi_irq_e;
+
+//spi_slave_port
+typedef enum enum_spi_slave {
+	SPI_SLAVE_PORT0 = (lift_shift_bit_num(0)),
+	SPI_SLAVE_PORT1 = (lift_shift_bit_num(1)),
+} spi_slave_e;
+
+//dma control
+typedef enum enum_spi_dma_control_mode {
+	SPI_DMA_RX_POS = (lift_shift_bit_num(0)),
+	SPI_DMA_TX_POS = (lift_shift_bit_num(1)),
+	//bit pos
+	SPI_DMA_CONTROL_RANGE = 0x03,
+} spi_dma_control_mode_e;
+
+//frame format
+typedef enum enum_spi_slave_mode {
+	SPI_SLAVE_EN = 0x00,
+	SPI_SLAVE_DIS = 1 << 10,
+	//bit pos
+	SPI_SLAVE_MODE_RANGE = 1 << 10,
+} spi_slave_mode_e;
+
+#ifdef FH_SPI_SLAVE_DEBUG
+#define SPI_SLAVE_PRINT_DBG(fmt, args...) \
+	printk("[FH_SPI_S_DEBUG]: "); \
+	printk(fmt, ## args)
+#else
+#define SPI_SLAVE_PRINT_DBG(fmt, args...)  do { } while (0)
+#endif
+
+struct fh_spi_reg {
+	u32 ctrl0;
+	u32 ctrl1;
+	u32 ssienr;
+	u32 mwcr;
+	u32 ser;
+	u32 baudr;
+	u32 txfltr;
+	u32 rxfltr;
+	u32 txflr;
+	u32 rxflr;
+	u32 sr;
+	u32 imr;
+	u32 isr;
+	u32 risr;
+	u32 txoicr;
+	u32 rxoicr;
+	u32 rxuicr;
+	u32 msticr;
+	u32 icr;
+	u32 dmacr;
+	u32 dmatdlr;
+	u32 dmardlr;
+	u32 idr;
+	u32 version;
+	u32 dr; /* Currently oper as 32 bits,
+	 though only low 16 bits matters */
+};
+
+#define dw_readl(dw, name) \
+	__raw_readl(&(((struct fh_spi_reg *)dw->regs)->name))
+#define dw_writel(dw, name, val) \
+	__raw_writel((val), &(((struct fh_spi_reg *)dw->regs)->name))
+#define dw_readw(dw, name) \
+	__raw_readw(&(((struct fh_spi_reg *)dw->regs)->name))
+#define dw_writew(dw, name, val) \
+	__raw_writew((val), &(((struct fh_spi_reg *)dw->regs)->name))
+
+struct _fh_spi_dma_transfer {
+	//bind to dma channel
+	struct dma_chan *chan;
+	struct dma_slave_config *cfg;
+	struct scatterlist sgl;
+	struct dma_async_tx_descriptor *desc;
+};
+
+struct fh_spi {
+	void * __iomem regs; /* vaddr of the control registers */
+	u32 id;
+	u32 paddr;
+	u32 slave_port;
+	u32 irq; /* irq no */
+	u32 fifo_len; /* depth of the FIFO buffer */
+	u32 cpol;
+	u32 cpha;
+	u32 isr_flag;
+	//clk
+	u32 apb_clock_in;
+	u32 max_freq; /* max bus freq supported */
+	u32 div;
+	/*use id u32 bus_num;*//*which bus*/
+	u32 num_cs; /* supported slave numbers */
+	u32 data_width;
+	u32 frame_mode;
+	u32 transfer_mode;
+	u32 active_cs_pin;
+	//copy from the user...
+	u32 tx_len;
+	u32 rx_len;
+	void *rx_buff;
+	void *tx_buff;
+	u32 tx_dma_add;
+	u32 rx_dma_add;
+	u32 tx_hs_no;			//tx handshaking number
+	u32 rx_hs_no;			//rx handshaking number
+	u32 *tx_dumy_buff;
+	u32 *rx_dumy_buff;
+	struct fh_spi_cs cs_data[SPI_MASTER_CONTROLLER_MAX_SLAVE];
+	u32 pump_data_mode;
+	struct _fh_spi_dma_transfer dma_rx;
+	struct _fh_spi_dma_transfer dma_tx;
+	u32 complete_times;
+	struct fh_spi_platform_data *board_info;
+};
+
+//this file private
+struct fh_spi_slave_controller {
+	struct clk *clk;
+	spinlock_t lock;
+	//message queue
+	struct platform_device *p_dev;
+	struct fh_spi dwc;
+	struct completion tx_done;
+
+	u32 cur_rx_len;
+	u32 cur_tx_len;
+
+	//dev interface
+	int major;
+	struct class *psClass;
+	struct device *psDev;
+
+	//kfifo interface
+	struct kfifo kfifo_in;
+	struct kfifo kfifo_out;
+};
+
+/******************************************************************************
+ * Function prototype section
+ * add prototypes for all functions called by this file,execepting those
+ * declared in header file
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Global variables section - Exported
+ * add declaration of global variables that will be exported here
+ * e.g.
+ *  int8_t foo;
+ ****************************************************************************/
+
+/*****************************************************************************
+
+ *  static fun;
+ *****************************************************************************/
+
+static int fh_spi_slave_init_hw(struct fh_spi_slave_controller *fh_spi_slave,
+                struct fh_spi_platform_data *board_info);
+static u32 Spi_RawIsrstatus(struct fh_spi *dw);
+
+/*****************************************************************************
+ * Global variables section - Local
+ * define global variables(will be refered only in this file) here,
+ * static keyword should be used to limit scope of local variable to this file
+ * e.g.
+ *  static uint8_t ufoo;
+ *****************************************************************************/
+static struct fh_spi_slave_controller *priv_array[MAX_SPI_SLAVES] = { NULL,
+NULL, NULL, NULL, NULL, NULL, NULL, NULL };
+
+/* function body */
+
+static u32 Spi_Enable(struct fh_spi *dw, spi_enable_e enable)
+{
+	dw_writel(dw, ssienr, enable);
+	return CONFIG_OK;
+}
+
+static u32 Spi_SetPolarity(struct fh_spi *dw, spi_polarity_e polarity)
+{
+	u32 data;
+
+	data = dw_readl(dw, ctrl0);
+	data &= ~(u32) SPI_POLARITY_RANGE;
+	data |= polarity;
+	dw_writel(dw, ctrl0, data);
+	return CONFIG_OK;
+}
+
+static u32 Spi_SetPhase(struct fh_spi *dw, spi_phase_e phase)
+{
+	u32 data;
+
+	data = dw_readl(dw, ctrl0);
+	data &= ~(u32) SPI_PHASE_RANGE;
+	data |= phase;
+	dw_writel(dw, ctrl0, data);
+	return CONFIG_OK;
+}
+
+static u32 Spi_SetFrameFormat(struct fh_spi *dw, spi_format_e format)
+{
+	u32 data = 0;
+
+	data = dw_readl(dw, ctrl0);
+	data &= ~(u32) SPI_FRAME_FORMAT_RANGE;
+	data |= format;
+	dw_writel(dw, ctrl0, data);
+	return CONFIG_OK;
+}
+
+static u32 Spi_SetTransferMode(struct fh_spi *dw, spi_transfer_mode_e mode)
+{
+	u32 data = 0;
+
+	data = dw_readl(dw, ctrl0);
+	data &= ~(u32) SPI_TRANSFER_MODE_RANGE;
+	data |= mode;
+	dw_writel(dw, ctrl0, data);
+	return CONFIG_OK;
+}
+
+static u32 Spi_DisableIrq(struct fh_spi *dw, u32 irq)
+{
+	u32 data = 0;
+
+	data = dw_readl(dw, imr);
+	data &= ~irq;
+	dw_writel(dw, imr, data);
+	return CONFIG_OK;
+}
+
+static u32 Spi_EnableIrq(struct fh_spi *dw, u32 irq)
+{
+	u32 data = 0;
+
+	data = dw_readl(dw, imr);
+	data |= irq;
+	dw_writel(dw, imr, data);
+	return CONFIG_OK;
+
+}
+
+static u32 Spi_SetTxlevlel(struct fh_spi *dw, u32 level)
+{
+	dw_writel(dw, txfltr, level);
+	return CONFIG_OK;
+}
+
+static u32 Spi_SetRxlevlel(struct fh_spi *dw, u32 level)
+{
+	dw_writel(dw, rxfltr, level);
+	return CONFIG_OK;
+}
+
+static u32 Spi_ReadTxfifolevel(struct fh_spi *dw)
+{
+	return dw_readl(dw, txflr);
+}
+
+static u32 Spi_ReadRxfifolevel(struct fh_spi *dw)
+{
+	return (u32) dw_readl(dw, rxflr);
+}
+
+static u32 Spi_ReadStatus(struct fh_spi *dw)
+{
+	return (uint8_t) dw_readl(dw, sr);
+}
+
+static u32 Spi_SetSlaveMode(struct fh_spi *dw, spi_slave_mode_e format)
+{
+
+	u32 data = 0;
+	data = dw_readl(dw, ctrl0);
+	data &= ~(u32) SPI_SLAVE_MODE_RANGE;
+	data |= format;
+	dw_writel(dw, ctrl0, data);
+	return CONFIG_OK;
+
+}
+
+static u32 Spi_WriteData(struct fh_spi *dw, u16 data)
+{
+	dw_writew(dw, dr, data);
+	return WRITE_ONLY_OK;
+}
+
+static u16 Spi_ReadData(struct fh_spi *dw)
+{
+	return dw_readw(dw, dr);
+}
+
+#if(0)
+static void Spi_Clearallerror(struct fh_spi *dw)
+{
+	u32 data = dw_readl(dw, icr);
+	data = 0;
+}
+#endif
+
+static u32 Spi_Isrstatus(struct fh_spi *dw)
+{
+	u32 data = dw_readl(dw, isr);
+	return data;
+}
+
+static u32 Spi_RawIsrstatus(struct fh_spi *dw)
+{
+	u32 data = dw_readl(dw, risr);
+	return data;
+}
+
+#if(0)
+static void Spi_SetDmaTxDataLevel(struct fh_spi *dw, u32 level)
+{
+	dw_writel(dw, dmatdlr, level);
+}
+
+static void Spi_SetDmaRxDataLevel(struct fh_spi *dw, u32 level)
+{
+	dw_writel(dw, dmardlr, level);
+}
+
+static void Spi_SetDmaControlEnable(struct fh_spi *dw,
+		spi_dma_control_mode_e enable_pos)
+{
+
+	u32 data;
+
+	data = dw_readl(dw, dmacr);
+	data |= enable_pos;
+	dw_writel(dw, dmacr, data);
+}
+#endif
+
+static int spi_slave_open(struct inode *inode, struct file *filp)
+{
+	int i, ret = 0;
+	struct fh_spi_slave_controller *fh_spi_slave;
+	SPI_SLAVE_PRINT_DBG("%s\n", __func__);
+	//bind the pri to the spi slave control...
+	SPI_SLAVE_PRINT_DBG("inode id is %x..\n", inode->i_rdev);
+	for (i = 0; i < MAX_SPI_SLAVES; i++) {
+		SPI_SLAVE_PRINT_DBG("register id is %x..\n",
+		                MKDEV(priv_array[i]->major, 0));
+		if (priv_array[i]
+		                && MKDEV(priv_array[i]->major, 0)
+		                                == inode->i_rdev) {
+			//SPI_SLAVE_PRINT_DBG();
+			filp->private_data = priv_array[i];
+			break;
+		}
+	}
+	if (i == MAX_SPI_SLAVES)
+		return -ENXIO;
+	//reset kfifo...
+	fh_spi_slave = priv_array[i];
+	kfifo_reset(&fh_spi_slave->kfifo_in);
+	kfifo_reset(&fh_spi_slave->kfifo_out);
+	return ret;
+}
+
+static ssize_t spi_slave_read(struct file *filp, char __user *buf, size_t count,
+                loff_t *f_pos)
+{
+	int ret;
+	unsigned int copied;
+	struct fh_spi_slave_controller *fh_spi_slave;
+	fh_spi_slave = (struct fh_spi_slave_controller *) filp->private_data;
+	//write data to fifo_out
+	if (kfifo_is_empty(&fh_spi_slave->kfifo_out)) {
+		return -EFAULT;
+	}
+	ret = kfifo_to_user(&fh_spi_slave->kfifo_out, buf, count, &copied);
+	//start spi hw work...
+	if (ret == 0) {
+		fh_spi_slave->cur_rx_len = copied;
+		return copied;
+	}
+	//error..
+	else {
+
+		return ret;
+	}
+
+	//hw isr pump fifo_out data..
+
+}
+
+#if(0)
+static void wait_spi_idle(struct fh_spi_slave_controller *fh_spi_slave) {
+	int status;
+	do {
+		status = Spi_ReadStatus(&fh_spi_slave->dwc);
+		SPI_SLAVE_PRINT_DBG("status is %x\n",status);
+	}while (status & 0x01);
+}
+#endif
+
+static void spi_slave_isr_tx_data(struct fh_spi_slave_controller *fh_spi_slave)
+{
+	//fh_spi_slave->dwc.isr_flag = SPI_IRQ_TXEIM;
+	//Spi_SetTxlevlel(&fh_spi_slave->dwc, fh_spi_slave->dwc.fifo_len / 2);
+	Spi_SetTxlevlel(&fh_spi_slave->dwc, fh_spi_slave->dwc.fifo_len - 5);
+	SPI_SLAVE_PRINT_DBG("open spi slave isr tx..\n");
+	Spi_EnableIrq(&fh_spi_slave->dwc, SPI_IRQ_TXEIM);
+	//wait_for_completion(&fh_spi_slave->tx_done);
+}
+
+static ssize_t spi_slave_write(struct file *filp, const char __user *buf,
+                size_t count, loff_t *f_pos)
+{
+	int ret;
+	unsigned int copied;
+	struct fh_spi_slave_controller *fh_spi_slave;
+	fh_spi_slave = (struct fh_spi_slave_controller *) filp->private_data;
+	if (kfifo_is_full(&fh_spi_slave->kfifo_in)) {
+		//spin_unlock_irqrestore(&fh_spi_slave->lock, flags);
+		return -EFAULT;
+	}
+	ret = kfifo_from_user(&fh_spi_slave->kfifo_in, buf, count, &copied);
+	//start spi hw work...
+	if (ret == 0) {
+		//start spi hw work...
+		//here we could start a back work to process the hw write data....
+		fh_spi_slave->cur_tx_len = copied;
+		spi_slave_isr_tx_data(fh_spi_slave);
+		return copied;
+	}
+	//error..
+	else {
+		return ret;
+	}
+
+
+
+}
+
+long spi_slave_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int err = -ENOIOCTLCMD;
+
+	switch (cmd) {
+	case SLAVE_SET_PHASE:
+		break;
+	case SLAVE_SET_POLARITY:
+		break;
+	case SLAVE_INIT_RX_FIFO:
+		break;
+
+	case SLAVE_INIT_TX_FIFO:
+		break;
+
+	case SLAVE_GET_ERROR_STATUS:
+		break;
+
+	default:
+		break;
+	}
+
+	return err;
+}
+
+static int spi_slave_release(struct inode *inode, struct file *filp)
+{
+
+	int ret = 0;
+	return ret;
+}
+
+static struct file_operations spi_slave_fops = {
+		.open = spi_slave_open,
+		.read = spi_slave_read,
+		.write = spi_slave_write,
+		.unlocked_ioctl = spi_slave_ioctl,
+		.release = spi_slave_release,
+};
+
+static inline u32 tx_max(struct fh_spi_slave_controller *fh_spi_slave)
+{
+	u32 hw_tx_level;
+	hw_tx_level = Spi_ReadTxfifolevel(&fh_spi_slave->dwc);
+	hw_tx_level = fh_spi_slave->dwc.fifo_len - hw_tx_level;
+	hw_tx_level /= 2;
+	return hw_tx_level;	//min(hw_tx_level, fh_spi_slave->dwc.tx_len);
+}
+
+/* Return the max entries we should read out of rx fifo */
+static inline u32 rx_max(struct fh_spi_slave_controller *fh_spi_slave)
+{
+	u32 hw_rx_level;
+
+	hw_rx_level = Spi_ReadRxfifolevel(&fh_spi_slave->dwc);
+	return hw_rx_level;
+}
+
+static void spi_slave_process_tx_isr(
+                struct fh_spi_slave_controller *fh_spi_slave)
+{
+
+	u8 tx_buff[SPI_SLAVE_MAX_FIFO_SIZE] = { 0 };
+	int kfifo_tx_size, hw_tx_size, trans_size;
+	u16 data;
+	int i;
+	int temp;
+	//Spi_DisableIrq(&fh_spi_slave->dwc, SPI_IRQ_TXEIM);
+	//Spi_DisableIrq(&fh_spi_slave->dwc, SPI_IRQ_RXFIM);
+
+	kfifo_tx_size = kfifo_len(&fh_spi_slave->kfifo_in);
+	//kfifo_tx_size = fh_spi_slave->cur_tx_len;
+	hw_tx_size = tx_max(fh_spi_slave);
+	//read MIN(hw tx fifo avail size , tx kfifo size)
+	trans_size = min(kfifo_tx_size, hw_tx_size);
+	temp = kfifo_out(&fh_spi_slave->kfifo_in, tx_buff, trans_size);
+	//transfer data to hw.. and reduce the actual trans data size..
+	SPI_SLAVE_PRINT_DBG("kfifo size :%d,  hw size:%d..\n",kfifo_tx_size,hw_tx_size);
+	SPI_SLAVE_PRINT_DBG("tx isr size is %d..\n",trans_size);
+	//printk("**0d%d\n",trans_size);
+	for (i = 0; i < trans_size; i++) {
+		data = tx_buff[i];
+		//SPI_SLAVE_PRINT_DBG("tx data is %x\n",data);
+		Spi_WriteData(&fh_spi_slave->dwc, data);
+	}
+	//SPI_SLAVE_PRINT_DBG("\n");
+	fh_spi_slave->cur_tx_len -= trans_size;
+	if (fh_spi_slave->cur_tx_len == 0) {
+		Spi_DisableIrq(&fh_spi_slave->dwc, SPI_IRQ_TXEIM);
+		//complete(&(fh_spi_slave->tx_done));
+	} else {
+		//Spi_EnableIrq(&fh_spi_slave->dwc, SPI_IRQ_TXEIM);
+	}
+
+}
+
+static void spi_slave_process_rx_isr(
+                struct fh_spi_slave_controller *fh_spi_slave)
+{
+
+	int hw_rx_size;
+	int i;
+	u16 data;
+	int status;
+	//here we try to get more data when the the clk is too high...
+	//do {
+	hw_rx_size = rx_max(fh_spi_slave);
+	SPI_SLAVE_PRINT_DBG("rx get size is 0x%d\n",hw_rx_size);
+	for (i = 0; i < hw_rx_size; i++) {
+		data = Spi_ReadData(&fh_spi_slave->dwc);
+		//rx_buff[i] = (u8) data;
+		kfifo_in(&fh_spi_slave->kfifo_out, &data, 1);
+	}
+	status = Spi_ReadStatus(&fh_spi_slave->dwc);
+	//} while (status & (1 << 3));
+
+}
+
+static irqreturn_t fh_spi_slave_irq(int irq, void *dev_id)
+{
+	struct fh_spi_slave_controller *fh_spi_slave;
+	u32 isr_status;
+	u32 raw_status;
+
+	fh_spi_slave = (struct fh_spi_slave_controller *) dev_id;
+	isr_status = Spi_Isrstatus(&fh_spi_slave->dwc);
+	raw_status = Spi_RawIsrstatus(&fh_spi_slave->dwc);
+	//printk("raw irq status is 0x%x..\n",raw_status);
+	SPI_SLAVE_PRINT_DBG("irq status is 0x%x..\n",isr_status);
+	if(raw_status & (1<<3)){
+		printk("[FH_SPI_S_ERROR]: rx overflow....\n");
+	}
+	if (isr_status & SPI_IRQ_TXEIM) {
+		spi_slave_process_tx_isr(fh_spi_slave);
+	}
+	if (isr_status & SPI_IRQ_RXFIM) {
+		spi_slave_process_rx_isr(fh_spi_slave);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int __devinit fh_spi_slave_probe(struct platform_device *dev)
+{
+	int err = 0;
+	struct resource *r,*ioarea;
+	int ret;
+	char spi_slave_name[32] = {0};
+	char spi_slave_class_name[32] = {0};
+	int major_id;
+	struct fh_spi_slave_controller *fh_spi_slave;
+	struct fh_spi_platform_data * spi_platform_info;
+	spi_platform_info = (struct fh_spi_platform_data *)dev->dev.platform_data;
+	if(spi_platform_info == NULL){
+		err = -ENODEV;
+		dev_err(&dev->dev, "%s, spi slave platform data null.\n",
+			__func__);
+		BUG();
+
+	}
+	fh_spi_slave =kzalloc(sizeof(struct fh_spi_slave_controller), GFP_KERNEL);
+	if (!fh_spi_slave) {
+		dev_err(&dev->dev, "malloc spi slave control mem not enough\n");
+		BUG();
+	}
+	fh_spi_slave->dwc.irq = platform_get_irq(dev, 0);
+	if (fh_spi_slave->dwc.irq < 0) {
+		dev_err(&dev->dev, "%s, spi slave irq no error.\n",
+			__func__);
+		err = fh_spi_slave->dwc.irq;
+		BUG();
+	}
+	err = request_irq(fh_spi_slave->dwc.irq , fh_spi_slave_irq, 0,
+			  dev_name(&dev->dev), fh_spi_slave);
+	if (err) {
+		dev_dbg(&dev->dev, "request_irq failed, %d\n", err);BUG();
+	}
+	r = platform_get_resource(dev, IORESOURCE_MEM, 0);
+	if (r == NULL) {
+		dev_err(&dev->dev, "%s, spi slave ioresource error. \n",
+			__func__);
+		err = -ENODEV;
+		BUG();
+	}
+	fh_spi_slave->dwc.paddr = r->start;
+	ioarea = request_mem_region(r->start,
+                resource_size(r), dev->name);if(!ioarea) {
+		dev_err(&dev->dev, "spi slave region already claimed\n");
+		err = -EBUSY;
+		BUG();
+
+	}
+	fh_spi_slave->dwc.regs = ioremap(r->start, resource_size(r));
+	if (!fh_spi_slave->dwc.regs) {
+		dev_err(&dev->dev, "spi slave region already mapped\n");
+		err = -EINVAL;
+		BUG();
+	}
+	spi_platform_info->bus_no = dev->id;
+	priv_array[dev->id] = fh_spi_slave;
+	init_completion(&fh_spi_slave->tx_done);
+	spin_lock_init(
+                &fh_spi_slave->lock);
+
+	fh_spi_slave->clk = clk_get(NULL, spi_platform_info->clk_name);
+	if (IS_ERR(fh_spi_slave->clk)) {
+		dev_err(&fh_spi_slave->p_dev->dev, "cannot find the spi%d clk.\n",
+				fh_spi_slave->dwc.id);
+		err = PTR_ERR(fh_spi_slave->clk);
+		BUG();
+	}
+	clk_enable(fh_spi_slave->clk);
+	clk_set_rate(fh_spi_slave->clk,spi_platform_info->apb_clock_in);
+
+	ret = fh_spi_slave_init_hw(fh_spi_slave,spi_platform_info);
+	if(ret) {
+		err = ret;
+		BUG();
+	}
+	init_completion(&fh_spi_slave->tx_done);
+	sprintf(spi_slave_name, "fh_spi_slave_%d", dev->id);
+	sprintf(spi_slave_class_name, "fh_spi_slave_class_%d", dev->id);
+	major_id = register_chrdev(0, spi_slave_name, &spi_slave_fops);
+	if (major_id <= 0) {
+		err = -EIO;
+		dev_err(&fh_spi_slave->p_dev->dev, "cannot register spi slave_%d char dev..\n",
+				fh_spi_slave->dwc.id);
+		BUG();
+	} else {
+		fh_spi_slave->major = major_id;
+	}
+
+	fh_spi_slave->psClass = class_create(THIS_MODULE, spi_slave_class_name);if (IS_ERR(fh_spi_slave->psClass)) {
+		err = -EIO;
+		dev_err(&fh_spi_slave->p_dev->dev, "%s: Unable to create class\n", __FILE__);
+		BUG();
+	}
+
+	fh_spi_slave->psDev = device_create(fh_spi_slave->psClass, NULL, MKDEV(major_id, 0),
+			fh_spi_slave, spi_slave_name);
+	if (IS_ERR(fh_spi_slave->psDev)) {
+		err = -EIO;
+		dev_err(&fh_spi_slave->p_dev->dev,"Error: %s: Unable to create device\n", __FILE__);
+		BUG();
+	}
+
+	if(kfifo_alloc(
+                &fh_spi_slave->kfifo_in, KFIFO_SIZE, GFP_KERNEL)){
+		dev_err(&fh_spi_slave->p_dev->dev,"Error: %s: Unable to alloc kfifo..\n", __FILE__);
+		BUG();
+	}
+
+	if(kfifo_alloc(&fh_spi_slave->kfifo_out, KFIFO_SIZE, GFP_KERNEL)) {
+		dev_err(&fh_spi_slave->p_dev->dev,"Error: %s: Unable to alloc kfifo..\n", __FILE__);
+		BUG();
+	}
+
+	#if(0)
+
+	//1 :empty 		0:not empty
+	//1 :full		0:not full
+	int empty,full,avail;
+	char test_buf_out[20] = {0};
+
+	empty = kfifo_is_empty(&fh_spi_slave->kfifo_in);
+	full = kfifo_is_full(&fh_spi_slave->kfifo_in);
+	avail = kfifo_avail(&fh_spi_slave->kfifo_in);
+	printk("empty:  %x,  full:  %x,  avail:  %x\n",empty,full,avail);
+	printk(KERN_INFO "queue len: %u\n", kfifo_len(&fh_spi_slave->kfifo_in));
+	kfifo_in(&fh_spi_slave->kfifo_in, "hello", 5);
+	printk(KERN_INFO "queue len: %u\n", kfifo_len(&fh_spi_slave->kfifo_in));
+
+	empty = kfifo_is_empty(&fh_spi_slave->kfifo_in);
+	full = kfifo_is_full(&fh_spi_slave->kfifo_in);
+	avail = kfifo_avail(&fh_spi_slave->kfifo_in);
+	printk("empty:  %x,  full:  %x,  avail:  %x\n",empty,full,avail);
+
+	/* put values into the fifo */
+	for (i = 0; i !=5; i++)
+	kfifo_put(&fh_spi_slave->kfifo_in, &i);
+
+	i = kfifo_out(&fh_spi_slave->kfifo_in, test_buf_out, 5);
+	printk("data len is %d\n",i);
+	printk(KERN_INFO "buf: %.*s\n", i, test_buf_out);
+
+	printk(KERN_INFO "queue len: %u\n", kfifo_len(&fh_spi_slave->kfifo_in));
+	i = kfifo_out(&fh_spi_slave->kfifo_in, test_buf_out, 10);
+	printk("data len is %d\n",i);
+	printk(KERN_INFO "buf: %.*s\n", i, test_buf_out);
+	#endif
+
+	return err;
+}
+
+static int __devexit fh_spi_slave_remove(struct platform_device *dev)
+{
+	return 0;
+}
+
+static int fh_spi_slave_init_hw(struct fh_spi_slave_controller *fh_spi_slave,
+        struct fh_spi_platform_data *board_info)
+{
+	int status;
+	fh_spi_slave->dwc.id = board_info->bus_no;
+	fh_spi_slave->dwc.fifo_len = board_info->fifo_len;
+	fh_spi_slave->dwc.rx_hs_no = board_info->rx_handshake_num;
+	fh_spi_slave->dwc.tx_hs_no = board_info->tx_handshake_num;
+	memset(&fh_spi_slave->dwc.dma_rx, 0, sizeof(struct _fh_spi_dma_transfer));
+	memset(&fh_spi_slave->dwc.dma_tx, 0, sizeof(struct _fh_spi_dma_transfer));
+	fh_spi_slave->dwc.pump_data_mode = PUMP_DATA_ISR_MODE;
+	//bind the platform data here....
+	fh_spi_slave->dwc.board_info = board_info;
+
+	fh_spi_slave->dwc.isr_flag = SPI_IRQ_RXFIM;
+	fh_spi_slave->dwc.frame_mode = SPI_MOTOROLA_MODE;
+	fh_spi_slave->dwc.transfer_mode = SPI_TX_RX_MODE;
+	fh_spi_slave->dwc.cpol = SPI_POLARITY_HIGH;
+	fh_spi_slave->dwc.cpha = SPI_PHASE_RX_FIRST;
+	do {
+		status = Spi_ReadStatus(&fh_spi_slave->dwc);
+	} while (status & 0x01);
+	//add spi disable
+	Spi_Enable(&fh_spi_slave->dwc, SPI_DISABLE);
+	//add spi frame mode & transfer mode
+	Spi_SetFrameFormat(&fh_spi_slave->dwc, fh_spi_slave->dwc.frame_mode);
+	Spi_SetTransferMode(&fh_spi_slave->dwc, fh_spi_slave->dwc.transfer_mode);
+	Spi_SetPolarity(&fh_spi_slave->dwc, fh_spi_slave->dwc.cpol);
+	Spi_SetPhase(&fh_spi_slave->dwc, fh_spi_slave->dwc.cpha);
+	//Spi_SetRxlevlel(&fh_spi_slave->dwc, fh_spi_slave->dwc.fifo_len / 2);
+	Spi_SetRxlevlel(&fh_spi_slave->dwc, 0);
+	Spi_SetSlaveMode(&fh_spi_slave->dwc, SPI_SLAVE_EN);
+	//add spi disable all isr
+	Spi_DisableIrq(&fh_spi_slave->dwc, SPI_IRQ_ALL);
+	Spi_EnableIrq(&fh_spi_slave->dwc, fh_spi_slave->dwc.isr_flag);
+	//add spi enable
+	Spi_Enable(&fh_spi_slave->dwc, SPI_ENABLE);
+
+	return 0;
+
+}
+
+static struct platform_driver fh_spi_slave_driver = {
+	.probe = fh_spi_slave_probe,
+        .remove = __devexit_p(fh_spi_slave_remove),
+        .driver = {
+        		.name = "fh_spi_slave",
+        		.owner = THIS_MODULE,
+	},
+        .suspend =NULL,
+        .resume = NULL,
+};
+
+static int __init fh_spi_slave_init(void)
+{
+	return platform_driver_register(&fh_spi_slave_driver);
+}
+
+static void __exit fh_spi_slave_exit(void)
+{
+	platform_driver_unregister(&fh_spi_slave_driver);
+}
+
+module_init(fh_spi_slave_init);
+module_exit(fh_spi_slave_exit);
+MODULE_AUTHOR("yu.zhang <zhangy@fullhan.com>");
+MODULE_DESCRIPTION("DUOBAO SPI SLAVE driver");
+MODULE_LICENSE("GPL");
diff -uraN linux-3.0.8/drivers/spi/Kconfig linux-3.0.8-fh8632-V1.0_20180330/drivers/spi/Kconfig
--- linux-3.0.8/drivers/spi/Kconfig	2021-07-14 21:52:03.843136403 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/spi/Kconfig	2021-07-13 23:40:34.234359797 +0300
@@ -442,6 +442,15 @@
 	tristate "Memory-mapped io interface driver for DW SPI core"
 	depends on SPI_DESIGNWARE && HAVE_CLK
 
+
+config SPI_FH
+	tristate "fh spi driver for DW SPI core"
+	depends on SPI_MASTER
+	
+config SPI_FH_SLAVE
+	tristate "fh spi slave driver for DW SPI core"
+
+	
 #
 # There are lots of SPI device types, with sensors and memory
 # being probably the most widely used ones.
diff -uraN linux-3.0.8/drivers/spi/Makefile linux-3.0.8-fh8632-V1.0_20180330/drivers/spi/Makefile
--- linux-3.0.8/drivers/spi/Makefile	2021-07-14 21:52:03.843136403 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/spi/Makefile	2021-07-13 23:40:34.226359747 +0300
@@ -22,7 +22,13 @@
 obj-$(CONFIG_SPI_DESIGNWARE)		+= dw_spi.o
 obj-$(CONFIG_SPI_DW_PCI)		+= dw_spi_midpci.o
 dw_spi_midpci-objs			:= dw_spi_pci.o dw_spi_mid.o
+
 obj-$(CONFIG_SPI_DW_MMIO)		+= dw_spi_mmio.o
+
+obj-$(CONFIG_SPI_FH)		+= fh_spi.o
+obj-$(CONFIG_SPI_FH_SLAVE)		+= fh_spi_slave.o
+
+
 obj-$(CONFIG_SPI_EP93XX)		+= ep93xx_spi.o
 obj-$(CONFIG_SPI_GPIO)			+= spi_gpio.o
 obj-$(CONFIG_SPI_IMX)			+= spi_imx.o
diff -uraN linux-3.0.8/drivers/spi/spi.c linux-3.0.8-fh8632-V1.0_20180330/drivers/spi/spi.c
--- linux-3.0.8/drivers/spi/spi.c	2021-07-14 21:52:03.847136415 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/spi/spi.c	2021-07-13 23:40:34.230359772 +0300
@@ -318,7 +318,7 @@
 	}
 
 	spi->master = master;
-	spi->dev.parent = dev;
+	spi->dev.parent = &master->dev;
 	spi->dev.bus = &spi_bus_type;
 	spi->dev.release = spidev_release;
 	device_initialize(&spi->dev);
diff -uraN linux-3.0.8/drivers/tty/serial/fh_serial.c linux-3.0.8-fh8632-V1.0_20180330/drivers/tty/serial/fh_serial.c
--- linux-3.0.8/drivers/tty/serial/fh_serial.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/tty/serial/fh_serial.c	2021-07-13 23:40:35.794369296 +0300
@@ -0,0 +1,1041 @@
+#if defined(CONFIG_SERIAL_FH_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/sysrq.h>
+#include <linux/console.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/cpufreq.h>
+#include <linux/moduleparam.h>
+#include <linux/ratelimit.h>
+#include <linux/serial_reg.h>
+#include <linux/nmi.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/err.h>
+#include <linux/sched.h>
+#include <linux/timex.h>
+#include <asm/irq.h>
+#include <asm/mach/irq.h>
+#include "fh_serial.h"
+
+/*********************************
+ *
+ * fh  private
+ *
+ *********************************/
+#define     REG_UART_RBR		(0x0000)
+#define     REG_UART_THR		(0x0000)
+#define     REG_UART_DLL		(0x0000)
+#define     REG_UART_DLH		(0x0004)
+#define     REG_UART_IER		(0x0004)
+#define     REG_UART_IIR		(0x0008)
+#define     REG_UART_FCR		(0x0008)
+#define     REG_UART_LCR		(0x000c)
+#define     REG_UART_MCR		(0x0010)
+#define     REG_UART_LSR		(0x0014)
+#define     REG_UART_MSR		(0x0018)
+#define     REG_UART_SCR		(0x001c)
+#define     REG_UART_FAR		(0x0070)
+#define     REG_UART_TFR		(0x0074)
+#define     REG_UART_RFW		(0x0078)
+#define     REG_UART_USR		(0x007c)
+#define     REG_UART_TFL		(0x0080)
+#define     REG_UART_RFL		(0x0084)
+#define     REG_UART_SRR		(0x0088)
+#define     REG_UART_SFE		(0x0098)
+#define     REG_UART_SRT		(0x009c)
+#define     REG_UART_STET		(0x00a0)
+#define     REG_UART_HTX		(0x00a4)
+#define     REG_UART_DMASA		(0x00a8)
+#define     REG_UART_CPR		(0x00f4)
+#define     REG_UART_UCV		(0x00f8)
+#define     REG_UART_CTR		(0x00fc)
+
+#define	DBGLINE()		printk(KERN_DEBUG \
+				"file: %s\tfunc:%s\tline:%d\n",\
+				__FILE__, __FUNCTION__, __LINE__)
+#define FH_SERIAL_NAME					"ttyS"
+#define FH_DRIVE_NAME					"ttyS"
+#define FH_DEV_NAME						"ttyS"
+
+
+#define UART_READ_RX_DW_FIFO_OK			0
+#define UART_READ_RX_DW_FIFO_TIME_OUT	0xcc
+#define MAP_SIZE						0x80000
+
+#ifdef CONFIG_SERIAL_FH_CONSOLE
+static struct console fh_serial_console;
+#define FH_SERIAL_CONSOLE		 (&fh_serial_console)
+#else
+#define FH_SERIAL_CONSOLE NULL
+#endif
+
+#define tx_enabled(port)		((port)->unused[0])
+#define rx_enabled(port)		((port)->unused[1])
+#define FH_TYPE					(99)
+#define BOTH_EMPTY				(UART_LSR_TEMT | UART_LSR_THRE)
+#define fh_dev_to_port(__dev)	(struct uart_port *)dev_get_drvdata(__dev)
+
+
+#define fh_uart_readl(addr) \
+	__raw_readl(addr)
+#define fh_uart_writel(addr, val) \
+	__raw_writel((val), addr)
+
+#define fh_uart_readw(addr) \
+	__raw_readw(addr)
+#define fh_uart_writew(addr, val) \
+	__raw_writew((val), addr)
+
+/******************************************************************************
+ * Function prototype section
+ * add prototypes for all functions called by this file,execepting those
+ * declared in header file
+ *****************************************************************************/
+static void fh_uart_pm(struct uart_port *port, unsigned int level,
+			      unsigned int old);
+static void fh_uart_stop_tx(struct uart_port *port);
+static void fh_uart_start_tx(struct uart_port *port);
+static void fh_uart_stop_rx(struct uart_port *port);
+static void fh_uart_start_rx(struct uart_port *port);
+static void fh_uart_enable_ms(struct uart_port *port);
+static unsigned int fh_uart_tx_empty(struct uart_port *port);
+static unsigned int fh_uart_get_mctrl(struct uart_port *port);
+static void fh_uart_set_mctrl(struct uart_port *port, unsigned int mctrl);
+static void fh_uart_break_ctl(struct uart_port *port, int break_state);
+static irqreturn_t fh_uart_rx_chars(int irq, void *dev_id);
+static irqreturn_t fh_uart_tx_chars(int irq, void *dev_id);
+static irqreturn_t fh_uart_isr(int irq, void *dev_id);
+static void fh_serial_shutdown(struct uart_port *port);
+static int fh_serial_startup(struct uart_port *port);
+static void fh_serial_set_termios(struct uart_port *port,
+				       struct ktermios *termios,
+				       struct ktermios *old);
+static const char *fh_serial_type(struct uart_port *port);
+static void fh_serial_release_port(struct uart_port *port);
+static int fh_serial_request_port(struct uart_port *port);
+static void fh_serial_config_port(struct uart_port *port, int flags);
+static int fh_uart_set_wake(struct uart_port *, unsigned int state);
+
+struct fh_uart_port *to_fh_uart_port(struct uart_port *port);
+struct fh_uart_port *info_to_fh_uart_port(fh_uart_info *info);
+/*****************************************************************************
+ * Global variables section - Local
+ * define global variables(will be refered only in this file) here,
+ * static keyword should be used to limit scope of local variable to this file
+ * e.g.
+ *	static uint8_t ufoo;
+ *****************************************************************************/
+static struct uart_ops fh_serial_ops = {
+	.pm		= fh_uart_pm,
+	.tx_empty	= fh_uart_tx_empty,
+	.get_mctrl	= fh_uart_get_mctrl,
+	.set_mctrl	= fh_uart_set_mctrl,
+	.stop_tx	= fh_uart_stop_tx,
+	.start_tx	= fh_uart_start_tx,
+	.stop_rx	= fh_uart_stop_rx,
+	.enable_ms	= fh_uart_enable_ms,
+	.break_ctl	= fh_uart_break_ctl,
+	.startup	= fh_serial_startup,
+	.shutdown	= fh_serial_shutdown,
+	.set_termios	= fh_serial_set_termios,
+	.type		= fh_serial_type,
+	.release_port	= fh_serial_release_port,
+	.request_port	= fh_serial_request_port,
+	.config_port	= fh_serial_config_port,
+	.set_wake	= fh_uart_set_wake,
+	.verify_port	= NULL,
+};
+
+static struct uart_driver fh_uart_drv = {
+	.owner			= THIS_MODULE,
+	.driver_name	= FH_DRIVE_NAME,
+	.nr				= FH_UART_NUMBER,
+	.cons			= FH_SERIAL_CONSOLE,
+	.dev_name		= FH_DEV_NAME,
+	.major			= 4,
+	.minor			= 64,
+};
+
+#if (defined(CONFIG_ARCH_FH8810) || defined(CONFIG_ARCH_WUDANG))
+#define UART_PORT0_ISR      ISR_NUMBER1
+#define UART_PORT1_ISR      ISR_NUMBER0
+#define UART_PORT0_BASE     UART1_REG_BASE
+#define UART_PORT1_BASE     UART0_REG_BASE
+#define UART_PORT0(x)       VUART1(x)
+#define UART_PORT1(x)       VUART0(x)
+#else
+#define UART_PORT0_ISR      ISR_NUMBER0
+#define UART_PORT1_ISR      ISR_NUMBER1
+#define UART_PORT2_ISR      ISR_NUMBER2
+#define UART_PORT0_BASE     UART0_REG_BASE
+#define UART_PORT1_BASE     UART1_REG_BASE
+#define UART_PORT2_BASE     UART2_REG_BASE
+#define UART_PORT0(x)       VUART0(x)
+#define UART_PORT1(x)       VUART1(x)
+#define UART_PORT2(x)       VUART2(x)
+#endif
+
+static  struct fh_uart_port  fh_own_ports[FH_UART_NUMBER] = {
+	[0] = {
+		.port = {
+			.lock		= __SPIN_LOCK_UNLOCKED(fh_own_ports[0].port.lock),
+			.iotype		= UPIO_MEM,
+			.irq		= UART_PORT0_ISR,
+			.uartclk	= 30000000,
+			.fifosize	= UART0_FIFO_SIZE,
+			.ops		= &fh_serial_ops,
+			.flags		= UPF_BOOT_AUTOCONF,
+			.line		= 0,
+			.mapbase = UART_PORT0_BASE,
+			.membase = (unsigned char __iomem *)UART_PORT0(UART_PORT0_BASE),
+		},
+		.fh_info = {
+			.name = "FH UART0",
+			.irq_num = UART_PORT0_ISR,
+			.base_add = (unsigned char __iomem *)UART_PORT0(UART_PORT0_BASE),
+			.baudrate = BAUDRATE_115200,
+			.line_ctrl = Uart_line_8n2,
+			.fifo_ctrl = UART_INT_RXFIFO_DEPTH_QUARTER,
+		}
+	},
+	[1] = {
+		.port = {
+			.lock		= __SPIN_LOCK_UNLOCKED(fh_own_ports[1].port.lock),
+			.iotype		= UPIO_MEM,
+			.irq		= UART_PORT1_ISR,
+			.uartclk	= 30000000,
+			.fifosize	= UART1_FIFO_SIZE,
+			.ops		= &fh_serial_ops,
+			.flags		= UPF_BOOT_AUTOCONF,
+			.line		= 1,
+			.mapbase = UART_PORT1_BASE,
+			.membase = (unsigned char __iomem *)UART_PORT1(UART_PORT1_BASE),
+
+		},
+		.fh_info = {
+			.name = "FH UART1",
+			.irq_num = UART_PORT1_ISR,
+			.base_add = (unsigned char __iomem *)UART_PORT1(UART_PORT1_BASE),
+			.baudrate = BAUDRATE_115200,
+			.line_ctrl = Uart_line_8n2,
+			.fifo_ctrl = UART_INT_RXFIFO_DEPTH_QUARTER,
+		}
+	},
+#ifdef CONFIG_ARCH_FH8830
+	[2] = {
+		.port = {
+			.lock		= __SPIN_LOCK_UNLOCKED(fh_own_ports[2].port.lock),
+			.iotype		= UPIO_MEM,
+			.irq		= UART_PORT2_ISR,
+			.uartclk	= 30000000,
+			.fifosize	= UART2_FIFO_SIZE,
+			.ops		= &fh_serial_ops,
+			.flags		= UPF_BOOT_AUTOCONF,
+			.line		= 2,
+			.mapbase = UART_PORT2_BASE,
+			.membase = (unsigned char __iomem *)UART_PORT2(UART_PORT2_BASE),
+
+		},
+		.fh_info = {
+			.name = "FH UART2",
+			.irq_num = UART_PORT2_ISR,
+			.base_add = (unsigned char __iomem *)UART_PORT2(UART_PORT2_BASE),
+			.baudrate = BAUDRATE_115200,
+			.line_ctrl = Uart_line_8n2,
+			.fifo_ctrl = UART_INT_RXFIFO_DEPTH_QUARTER,
+		}
+	},
+#endif
+};
+
+struct fh_uart_port *to_fh_uart_port(struct uart_port *port)
+{
+	return container_of(port, struct fh_uart_port, port);
+
+}
+
+struct fh_uart_port *info_to_fh_uart_port(fh_uart_info *info)
+{
+	return container_of(info, struct fh_uart_port, fh_info);
+
+}
+
+s32 Uart_Disable_Irq(fh_uart_info *desc, uart_irq_e interrupts)
+{
+	u32 ret;
+	u32 base = (u32)desc->base_add;
+
+	ret = fh_uart_readl(base + REG_UART_IER);
+	ret &= ~interrupts;
+	fh_uart_writel(base+REG_UART_IER, ret);
+
+	return UART_CONFIG_OK;
+}
+
+s32 Uart_Enable_Irq(fh_uart_info *desc, uart_irq_e interrupts)
+{
+	u32 ret;
+	u32 base = (u32)desc->base_add;
+
+	ret = fh_uart_readl(base);
+	ret |= interrupts;
+	fh_uart_writel(base + REG_UART_IER, ret);
+
+	return UART_CONFIG_OK;
+
+}
+
+s32 Uart_Fifo_Config(fh_uart_info *desc)
+{
+	u32 ret;
+	u32 base = (u32)desc->base_add;
+
+	fh_uart_writel(base + REG_UART_FCR, desc->fifo_ctrl);
+	ret = fh_uart_readl(base + REG_UART_IIR);
+
+	if (ret & UART_FIFO_IS_ENABLE)
+		return UART_CONFIG_FIFO_OK;
+	else
+		return UART_CONFIG_FIFO_ERROR;
+}
+
+s32 Uart_Read_Control_Status(fh_uart_info *desc)
+{
+	u32 base = (u32)desc->base_add;
+	return fh_uart_readl(base + REG_UART_USR);
+}
+
+s32 Uart_Set_Line_Control(fh_uart_info *desc)
+{
+	u32 ret;
+	u32 base = (u32)desc->base_add;
+
+	ret = Uart_Read_Control_Status(desc);
+	if (ret & UART_STATUS_BUSY)
+		return UART_IS_BUSY;
+
+	fh_uart_writel(base + REG_UART_LCR, desc->line_ctrl);
+	return UART_CONFIG_LINE_OK;
+}
+
+s32 Uart_Read_Line_Status(fh_uart_info *desc)
+{
+	u32 base = (u32)desc->base_add;
+	return fh_uart_readl(base + REG_UART_LSR);
+}
+
+s32 Uart_Set_Clock_Divisor(fh_uart_info *desc)
+{
+	u32 low, high, ret;
+	u32 base = (u32)desc->base_add;
+
+	low = desc->baudrate & 0x00ff;
+	high = (desc->baudrate & 0xff00) >> 8;
+
+	ret = Uart_Read_Control_Status(desc);
+	if (ret & UART_STATUS_BUSY)
+		return UART_IS_BUSY;
+
+	ret = fh_uart_readl(base + REG_UART_LCR);
+	/* if DLAB not set */
+	if (!(ret & UART_LCR_DLAB_POS)) {
+		ret |= UART_LCR_DLAB_POS;
+		fh_uart_writel(base + REG_UART_LCR, ret);
+	}
+	fh_uart_writel(base + REG_UART_DLL, low);
+	fh_uart_writel(base + REG_UART_DLH, high);
+
+	/* clear DLAB */
+	ret = ret & 0x7f;
+	fh_uart_writel(base + REG_UART_LCR, ret);
+
+	return UART_CONFIG_DIVISOR_OK;
+}
+
+s32 Uart_Read_iir(fh_uart_info *desc)
+{
+	u32 base = (u32)desc->base_add;
+	return fh_uart_readl(base + REG_UART_IIR);
+}
+
+s32 Uart_Init(fh_uart_info *desc)
+{
+
+	u32 base = (u32)desc->base_add;
+	struct fh_uart_port *port = info_to_fh_uart_port(desc);
+	u8 test_init_status = 0;
+
+	/* reset fifo */
+	fh_uart_writel(base + REG_UART_FCR, 6);
+	test_init_status |= Uart_Set_Clock_Divisor(desc);
+	test_init_status |= Uart_Set_Line_Control(desc);
+	test_init_status |= Uart_Fifo_Config(desc);
+	if (test_init_status != 0) {
+		return test_init_status;
+	}
+	Uart_Disable_Irq(desc, UART_INT_ALL);
+	fh_uart_start_rx(&port->port);
+	return 0;
+}
+
+
+
+/*********************************
+ *
+ *
+ * FH  CONSOLE
+ *
+ *
+ *********************************/
+#ifdef CONFIG_SERIAL_FH_CONSOLE
+static struct uart_port *cons_uart;
+
+static void
+fh_serial_console_putchar(struct uart_port *port, int ch)
+{
+	u32 ret;
+	struct fh_uart_port *myown_port = to_fh_uart_port(port);
+
+	do {
+		ret = (u8)Uart_Read_Control_Status(&myown_port->fh_info);
+	}
+	/* wait txfifo is full
+	 * 0 means full.
+	 * 1 means not full
+	 */
+	while(!(ret & UART_STATUS_TFNF));
+
+	fh_uart_writel(myown_port->fh_info.base_add + REG_UART_THR,ch);
+}
+
+static void
+fh_serial_console_write(struct console *co, const char *s,
+			     unsigned int count)
+{
+	struct fh_uart_port* myown_port  = &fh_own_ports[co->index];
+	uart_console_write(&myown_port->port, s, count, fh_serial_console_putchar);
+}
+
+
+static int __init
+fh_serial_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = 115200;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+	/* is this a valid port */
+	if (co->index == -1 || co->index >= FH_UART_NUMBER)
+	    printk("ERROR: co->index invaild: %d\n", co->index);
+
+	port = &fh_own_ports[co->index].port;
+
+	/* is the port configured? */
+	if (port->mapbase == 0x0)
+	    printk("ERROR: port->mapbase == 0x0\n");
+
+	cons_uart = port;
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	uart_set_options(port, co, baud, parity, bits, flow);
+
+	/* must true for setup ok, see printk.c line:1463 */
+	return 1;
+}
+
+
+int fh_serial_initconsole(void)
+{
+	fh_serial_console.data = &fh_uart_drv;
+	register_console(&fh_serial_console);
+	return 0;
+}
+console_initcall(fh_serial_initconsole);
+
+static struct console fh_serial_console = {
+	.name		= FH_SERIAL_NAME,
+	.device		= uart_console_device,
+	.flags		= CON_PRINTBUFFER | CON_ANYTIME | CON_ENABLED,
+	.index		= -1,
+	.write		= fh_serial_console_write,
+	.setup		= fh_serial_console_setup,
+	.data		= &fh_uart_drv,
+};
+
+#endif /* CONFIG_SERIAL_FH_CONSOLE */
+
+static void fh_uart_stop_tx(struct uart_port *port)
+{
+	/* close tx isr */
+	struct fh_uart_port* myown_port = to_fh_uart_port(port);
+	u32 base = (u32)myown_port->fh_info.base_add;
+	tx_enabled(port) = 0;
+	fh_uart_writel(base + REG_UART_IER, 0x01);
+}
+
+static void fh_uart_start_tx(struct uart_port *port)
+{
+	/* open tx isr */
+	struct fh_uart_port* myown_port = to_fh_uart_port(port);
+	u32 base = (u32)myown_port->fh_info.base_add;
+	fh_uart_writel(base + REG_UART_IER, 0x03);
+	tx_enabled(port) = 1;
+}
+
+static void fh_uart_stop_rx(struct uart_port *port)
+{
+	struct fh_uart_port* myown_port = to_fh_uart_port(port);
+	rx_enabled(port) = 0;
+	Uart_Disable_Irq(&myown_port->fh_info,UART_INT_ERBFI_POS);
+}
+
+static void fh_uart_start_rx(struct uart_port *port)
+{
+	struct fh_uart_port* myown_port = to_fh_uart_port(port);
+	rx_enabled(port) = 1;
+	Uart_Enable_Irq(&myown_port->fh_info,UART_INT_ERBFI_POS);
+}
+
+static void fh_uart_pm(struct uart_port *port, unsigned int level,
+			      unsigned int old)
+{
+
+}
+
+static int fh_uart_set_wake(struct uart_port *port, unsigned int state)
+{
+	return 0;
+}
+
+
+static void fh_uart_enable_ms(struct uart_port *port)
+{
+
+}
+
+
+static unsigned int fh_uart_tx_empty(struct uart_port *port)
+{
+	struct fh_uart_port* myown_port = to_fh_uart_port(port);
+	/*
+	 * 1 means empty
+	 * 0:means no empty
+	 */
+	int ret = 1;
+	int ret_status;
+
+	ret_status = (u8)Uart_Read_Control_Status(&myown_port->fh_info);
+	if(ret_status & UART_STATUS_TFE)
+		ret = 1;
+	else
+		ret = 0;
+	return ret;
+}
+
+
+static unsigned int fh_uart_get_mctrl(struct uart_port *port)
+{
+	return 0;
+}
+
+
+static void fh_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+
+}
+
+static void fh_uart_break_ctl(struct uart_port *port, int break_state)
+{
+
+}
+
+static irqreturn_t
+fh_uart_rx_chars(int irq, void *dev_id)
+{
+	struct fh_uart_port* myown_port  = dev_id;
+	struct uart_port *port = &myown_port->port;
+	struct tty_struct *tty = port->state->port.tty;
+	unsigned int ch;
+	unsigned int flag;
+	unsigned int uerstat;
+	int max_count = 64;
+	int ret_status;
+
+	while (max_count-- > 0) {
+		/* check if rx fifo is empty */
+		ret_status = (u8)Uart_Read_Control_Status(&myown_port->fh_info);
+		if(!(ret_status & UART_STATUS_RFNE))
+			break;
+		/* read error in the rx process */
+		uerstat = Uart_Read_Line_Status(&myown_port->fh_info);
+		/* read  data in the rxfifo */
+		if(uerstat & UART_LINE_STATUS_DR)
+			ch = fh_uart_readl(myown_port->fh_info.base_add + REG_UART_RBR);
+		/* insert the character into the buffer */
+		flag = TTY_NORMAL;
+		port->icount.rx++;
+		/* if at least one error in rx process */
+		if (unlikely(uerstat & UART_LINE_STATUS_RFE)) {
+			printk("rxerr: port ch=0x%02x, rxs=0x%08x\n",
+			    ch, uerstat);
+			/* check for break */
+			if (uerstat & UART_LINE_STATUS_BI) {
+				port->icount.brk++;
+				if (uart_handle_break(port))
+				    goto ignore_char;
+			}
+
+			if (uerstat & UART_LINE_STATUS_BI)
+				port->icount.frame++;
+			if (uerstat & UART_LINE_STATUS_OE)
+				port->icount.overrun++;
+
+			uerstat &= port->read_status_mask;
+
+			if (uerstat & UART_LINE_STATUS_BI)
+				flag = TTY_BREAK;
+			else if (uerstat & UART_LINE_STATUS_PE)
+				flag = TTY_PARITY;
+			else if (uerstat & (UART_LINE_STATUS_FE |
+					UART_LINE_STATUS_OE))
+				flag = TTY_FRAME;
+		}
+
+		if (uart_handle_sysrq_char(port, ch))
+			goto ignore_char;
+
+		uart_insert_char(port, uerstat, UART_LINE_STATUS_OE,
+				 ch, flag);
+
+ ignore_char:
+		continue;
+	}
+	tty_flip_buffer_push(tty);
+	return IRQ_HANDLED;
+}
+
+
+
+static irqreturn_t
+fh_uart_tx_chars(int irq, void *dev_id)
+{
+	struct fh_uart_port* myown_port  = dev_id;
+	struct uart_port *port = &myown_port->port;
+	struct circ_buf *xmit = &port->state->xmit;
+	int count = 256;
+	int ret_status;
+
+	/* if there isn't anything more to transmit, or the uart is now
+	 * stopped, disable the uart and exit
+	*/
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
+		fh_uart_stop_tx(port);
+		goto out;
+	}
+	/* try and drain the buffer... */
+	while (!uart_circ_empty(xmit) && count-- > 0) {
+
+		/*
+		 *  check the tx fifo full?
+		 * full then break
+		 */
+		ret_status = (u8)Uart_Read_Control_Status(&myown_port->fh_info);
+		if(!(ret_status & UART_STATUS_TFNF))
+			break;
+		/* write data to the hw fifo */
+		fh_uart_writel(myown_port->fh_info.base_add + REG_UART_THR,xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+	}
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+	if (uart_circ_empty(xmit))
+		fh_uart_stop_tx(port);
+out:
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t
+fh_uart_isr(int irq, void *dev_id){
+	irqreturn_t ret_isr;
+	struct fh_uart_port* myown_port  = dev_id;
+	int ret_iir;
+
+	/* check if the tx empty isr */
+	ret_iir = Uart_Read_iir(&myown_port->fh_info);
+	if (ret_iir == 0x06){
+		printk("uart overrun\n");
+	}
+
+	if((ret_iir & 0x04)||(ret_iir & 0x0c)){
+		ret_isr = fh_uart_rx_chars(irq,dev_id);
+	}
+
+	if(ret_iir & 0x02){
+		ret_isr = fh_uart_tx_chars(irq,dev_id);
+	}
+	else
+		ret_isr = IRQ_HANDLED;
+
+	return ret_isr;
+}
+
+static void fh_serial_shutdown(struct uart_port *port)
+{
+	struct fh_uart_port* myown_port = to_fh_uart_port(port);
+
+	Uart_Disable_Irq(&myown_port->fh_info,UART_INT_ALL);
+	fh_uart_writel( myown_port->fh_info.base_add + REG_UART_FCR, 6);
+	free_irq(myown_port->fh_info.irq_num, myown_port);
+	tx_enabled(port) = 0;
+	rx_enabled(port) = 0;
+}
+
+static int fh_serial_startup(struct uart_port *port)
+{
+	struct fh_uart_port* myown_port = to_fh_uart_port(port);
+	int ret;
+	int status;
+
+	do {
+		status = Uart_Read_Line_Status(&myown_port->fh_info);
+
+	} while ((status & BOTH_EMPTY) != BOTH_EMPTY);
+
+	Uart_Init(&myown_port->fh_info);
+	if ((ret = request_irq(myown_port->fh_info.irq_num, fh_uart_isr, 0, FH_DEV_NAME, (void*)myown_port)))
+	{
+		printk("cannot get irq %d\n", myown_port->fh_info.irq_num);
+		return ret;
+	}
+
+	enable_irq_wake(myown_port->fh_info.irq_num);
+
+	return 0;
+}
+
+static void fh_serial_set_termios(struct uart_port *port,
+				       struct ktermios *termios,
+				       struct ktermios *old)
+{
+	struct fh_uart_port* myown_port = to_fh_uart_port(port);
+
+	unsigned long flags;
+	unsigned int baud, quot;
+	unsigned int line_data = 0,status;
+
+	do {
+		status = Uart_Read_Line_Status(&myown_port->fh_info);
+
+	} while ((status & BOTH_EMPTY) != BOTH_EMPTY);
+
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		line_data |= UART_LCR_WLEN5;
+		break;
+	case CS6:
+		line_data |= UART_LCR_WLEN6;
+		break;
+	case CS7:
+		line_data |= UART_LCR_WLEN7;
+		break;
+	case CS8:
+		line_data |= UART_LCR_WLEN8;
+		break;
+	default:
+		line_data |= UART_LCR_WLEN8;
+		break;
+	}
+	/* stop bits */
+	if (termios->c_cflag & CSTOPB)
+		line_data |= UART_LCR_STOP;
+
+	if (termios->c_cflag & PARENB){
+		line_data |= UART_LCR_PARITY;
+
+		if (!(termios->c_cflag & PARODD))
+			line_data |= UART_LCR_EPAR;
+	}
+	/*
+	 * baud cal.
+	 * baud is the uart will be out.
+	 * the quot is the div
+	 */
+	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);
+	quot = uart_get_divisor(port, baud);
+
+	do{
+		status = Uart_Read_Line_Status(&myown_port->fh_info);
+	} while ((status & BOTH_EMPTY) != BOTH_EMPTY);
+
+	uart_update_timeout(port, termios->c_cflag, baud);
+	spin_lock_irqsave(&myown_port->port.lock, flags);
+
+	myown_port->port.read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;
+	if (termios->c_iflag & INPCK)
+		myown_port->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;
+	if (termios->c_iflag & (BRKINT | PARMRK))
+		myown_port->port.read_status_mask |= UART_LSR_BI;
+
+	/*
+	 * Characters to ignore
+	 */
+	myown_port->port.ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		myown_port->port.ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;
+	if (termios->c_iflag & IGNBRK) {
+		myown_port->port.ignore_status_mask |= UART_LSR_BI;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			myown_port->port.ignore_status_mask |= UART_LSR_OE;
+	}
+
+	/*
+	 * ignore all characters if CREAD is not set
+	 */
+	if ((termios->c_cflag & CREAD) == 0)
+		myown_port->port.ignore_status_mask |= UART_LSR_DR;
+
+
+	myown_port->fh_info.line_ctrl = (uart_line_e)line_data;
+	myown_port->fh_info.baudrate = quot;
+	myown_port->fh_info.fifo_ctrl = UART_INT_RXFIFO_DEPTH_QUARTER;
+	Uart_Init(&myown_port->fh_info);
+	spin_unlock_irqrestore(&myown_port->port.lock, flags);
+}
+
+
+
+static const char *fh_serial_type(struct uart_port *port)
+{
+	return FH_SERIAL_NAME;
+}
+
+static void fh_serial_release_port(struct uart_port *port)
+{
+	release_mem_region(port->mapbase, MAP_SIZE);
+}
+
+static int fh_serial_request_port(struct uart_port *port)
+{
+	struct fh_uart_port* myown_port = to_fh_uart_port(port);
+	const char* name = myown_port->fh_info.name;
+	return request_mem_region(port->mapbase, MAP_SIZE, name) ? 0 : -EBUSY;
+}
+
+
+static void fh_serial_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE) {
+		fh_serial_request_port(port);
+		port->type = FH_TYPE;
+	}
+}
+
+static int fh_serial_init_port(struct fh_uart_port* myown_port,
+
+				    struct platform_device *platdev)
+{
+	struct uart_port *port = &myown_port->port;
+	struct resource *res;
+
+	if(platdev == NULL)
+		return -ENODEV;
+
+
+	myown_port->fh_info.dev = platdev;
+	/* setup info for port */
+	port->dev	= &platdev->dev;
+
+	/* sort our the physical and virtual addresses for each UART */
+	res = platform_get_resource(platdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		printk(KERN_ERR "failed to find memory resource for uart\n");
+		return -EINVAL;
+	}
+
+	myown_port->fh_info.baudrate = BAUDRATE_115200;
+	myown_port->fh_info.fifo_ctrl = UART_INT_RXFIFO_DEPTH_QUARTER;
+	myown_port->fh_info.line_ctrl = Uart_line_8n2;
+
+	Uart_Init(&myown_port->fh_info);
+	return 0;
+}
+
+static inline int fh_serial_cpufreq_register(struct fh_uart_port* myown_port)
+{
+	return 0;
+}
+
+static ssize_t fh_serial_show_clksrc(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "* %s\n", FH_SERIAL_NAME);
+}
+
+static DEVICE_ATTR(clock_source, S_IRUGO, fh_serial_show_clksrc, NULL);
+
+#ifdef CONFIG_PM
+static int fh_serial_suspend(struct platform_device *pdev,
+				pm_message_t state)
+{
+	struct uart_port *port = platform_get_drvdata(pdev);
+
+	uart_suspend_port(&fh_uart_drv, port);
+
+	return 0;
+}
+
+static int fh_serial_resume(struct platform_device *pdev)
+{
+	struct uart_port *port = platform_get_drvdata(pdev);
+	int may_wakeup;
+
+	may_wakeup = device_may_wakeup(&pdev->dev);
+
+	uart_resume_port(&fh_uart_drv, port);
+	device_set_wakeup_enable(&pdev->dev, may_wakeup);
+
+	return 0;
+}
+#endif
+
+int fh_serial_probe(struct platform_device *dev)
+{
+	int ret = 0;
+	struct fh_uart_port* myown_port;
+	if(dev->id > (sizeof(fh_own_ports)/sizeof(struct fh_uart_port)))
+		goto probe_err;
+
+	myown_port = &fh_own_ports[dev->id];
+	ret = fh_serial_init_port(myown_port,dev);
+	if (ret < 0)
+		goto probe_err;
+
+	ret = uart_add_one_port(&fh_uart_drv, &myown_port->port);
+	if(ret != 0)
+		printk(KERN_ERR "%s: failed to add one port.\n", __func__);
+
+	platform_set_drvdata(dev, &myown_port->port);
+	ret = device_create_file(&dev->dev, &dev_attr_clock_source);
+
+	if (ret < 0)
+		printk(KERN_ERR "%s: failed to add clksrc attr.\n", __func__);
+
+	ret = fh_serial_cpufreq_register(myown_port);
+	if (ret < 0)
+		dev_err(&dev->dev, "failed to add cpufreq notifier\n");
+
+	printk(KERN_DEBUG "fh serial probe done\n");
+	return 0;
+
+ probe_err:
+	printk(KERN_ERR "%s: fh serial probe error.\n",__func__);
+	return ret;
+}
+
+EXPORT_SYMBOL_GPL(fh_serial_probe);
+
+static inline void fh_serial_cpufreq_deregister(struct fh_uart_port* myown_port)
+{
+
+}
+
+
+int __devexit fh_serial_remove(struct platform_device *dev)
+{
+	struct uart_port *port = fh_dev_to_port(&dev->dev);
+	struct fh_uart_port* myown_port = to_fh_uart_port(port);
+
+	if (port) {
+		fh_serial_cpufreq_deregister(myown_port);
+		device_remove_file(&dev->dev, &dev_attr_clock_source);
+		uart_remove_one_port(&fh_uart_drv, port);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(fh_serial_remove);
+
+int fh_serial_init(struct platform_driver *drv)
+{
+	return platform_driver_register(drv);
+}
+EXPORT_SYMBOL_GPL(fh_serial_init);
+
+static int __init fh_serial_modinit(void)
+{
+	int ret;
+	ret = uart_register_driver(&fh_uart_drv);
+	if (ret < 0) {
+		printk(KERN_ERR "failed to register UART driver\n");
+		return -1;
+	}
+	return 0;
+}
+
+static void __exit fh_serial_modexit(void)
+{
+	uart_unregister_driver(&fh_uart_drv);
+}
+
+
+static int _fh_serial_probe(struct platform_device *dev)
+{
+	return fh_serial_probe(dev);
+}
+
+static struct platform_driver fh_serial_driver = {
+	.probe		= _fh_serial_probe,
+	.remove		= __devexit_p(fh_serial_remove),
+#ifdef CONFIG_PM
+	.suspend	= fh_serial_suspend,
+	.resume		= fh_serial_resume,
+#endif
+	.driver		= {
+		.name	= FH_SERIAL_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init _fh_serial_init(void)
+{
+	return fh_serial_init(&fh_serial_driver);
+}
+
+static void __exit _fh_serial_exit(void)
+{
+	platform_driver_unregister(&fh_serial_driver);
+}
+
+module_init(_fh_serial_init);
+module_exit(_fh_serial_exit);
+
+module_init(fh_serial_modinit);
+module_exit(fh_serial_modexit);
diff -uraN linux-3.0.8/drivers/tty/serial/fh_serial.h linux-3.0.8-fh8632-V1.0_20180330/drivers/tty/serial/fh_serial.h
--- linux-3.0.8/drivers/tty/serial/fh_serial.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/tty/serial/fh_serial.h	2021-07-13 23:40:35.782369224 +0300
@@ -0,0 +1,166 @@
+/*
+ * fh_serial.h
+ *
+ *  Created on: Jul 29, 2014
+ *      Author: duobao
+ */
+#ifndef FH_SERIAL_H_
+#define FH_SERIAL_H_
+/****************************************************************************
+ * #include section
+ *	add #include here if any
+ ***************************************************************************/
+
+/****************************************************************************
+ * #define section
+ *	add constant #define here if any
+ ***************************************************************************/
+
+#define lift_shift_bit_num(bit_num)			(1<<bit_num)
+#define ISR_NUMBER0							(30)
+#define ISR_NUMBER1							(31)
+#define ISR_NUMBER2							(35)
+#define UART0_PORT							0
+#define UART1_PORT							1
+#define UART2_PORT							2
+#define	UART_MAX_NUM						3
+#define UART_DATA_ARRIVED					1
+#define UART_LCR_DLAB_POS        			(lift_shift_bit_num(7))
+
+#define UART0_FIFO_SIZE							32
+#define UART1_FIFO_SIZE							16
+#define UART2_FIFO_SIZE							16
+
+/****************************************************************************
+* ADT section
+*	add Abstract Data Type definition here
+***************************************************************************/
+//error status
+enum {
+	UART_CONFIG_OK = 0,
+	UART_CONFIG_FIFO_OK = 0,
+	UART_CONFIG_LINE_OK = 0,
+	UART_CONFIG_DIVISOR_OK = 0,
+	UART_WRITE_DATA_OK = 0,
+	UART_READ_DATA_OK = 0,
+	UART_CLEAR_ERROR_OK = 0,
+	UART_RESET_RX_POOL_OK = 0,
+	UART_CLEAR_RX_DATA_READY_OK = 0,
+	UART_INIT_OK = 0,
+	UART_CONFIG_PARA_ERROR = lift_shift_bit_num(0),
+	UART_CONFIG_FIFO_ERROR = lift_shift_bit_num(1),
+	UART_IS_BUSY = lift_shift_bit_num(2),
+	UART_DW_FIFO_OVERFLOW = lift_shift_bit_num(3),  //dw rxfifo overflow ,maybe rxisr is closed or main clock is too low
+	UART_SW_FIFO_OVERFLOW = lift_shift_bit_num(4),	//soft rxfifo overflow , maybe main clk is too low
+	UART_PARITY_ERROR = lift_shift_bit_num(5),
+	UART_FRAME_ERROR = lift_shift_bit_num(6),
+	UART_BREAK_ERROR = lift_shift_bit_num(7),
+	UART_FIFO_EMPTY = lift_shift_bit_num(8),
+};
+
+//interrupt enable
+typedef enum enum_uart_irq {
+	UART_INT_PTIME_POS = (lift_shift_bit_num(7)),
+	UART_INT_EDSSI_POS = (lift_shift_bit_num(3)),
+	UART_INT_ELSI_POS  = (lift_shift_bit_num(2)),
+	UART_INT_ETBEI_POS = (lift_shift_bit_num(1)),
+	UART_INT_ERBFI_POS = (lift_shift_bit_num(0)),
+	UART_INT_ALL          = 0x0f,
+}uart_irq_e;
+
+//interrupt id
+enum {
+	UART_INT_ID_MODEM = 		0,
+	UART_INT_ID_NO_INT = 		1,
+	UART_INT_ID_THR_EMPTY =  	2,
+	UART_INT_ID_RECEIVE_DATA =	4,
+	UART_INT_ID_RECEIVE_LINE =	6,
+	UART_INT_ID_BUSY = 			7,
+	UART_INT_ID_TIME_OUT =	    12,
+	UART_FIFO_IS_ENABLE =	    0xc0,
+};
+
+typedef enum enum_uart_line {
+    Uart_line_5n1 = 0x00,   // 5 data bits, no parity, 1 stop bit
+    Uart_line_5n1_5 = 0x04, // 5 data bits, no parity, 1.5 stop bits
+    Uart_line_5e1 = 0x18,   // 5 data bits, even parity, 1 stop bit
+    Uart_line_5e1_5 = 0x1c, // 5 data bits, even parity, 1.5 stop bits
+    Uart_line_5o1 = 0x08,   // 5 data bits, odd parity, 1 stop bit
+    Uart_line_5o1_5 = 0x0c, // 5 data bits, odd parity, 1.5 stop bits
+    Uart_line_6n1 = 0x01,   // 6 data bits, no parity, 1 stop bit
+    Uart_line_6n2 = 0x05,   // 6 data bits, no parity, 2 stop bits
+    Uart_line_6e1 = 0x19,   // 6 data bits, even parity, 1 stop bit
+    Uart_line_6e2 = 0x1d,   // 6 data bits, even parity, 2 stop bits
+    Uart_line_6o1 = 0x09,   // 6 data bits, odd parity, 1 stop bit
+    Uart_line_6o2 = 0x0d,   // 6 data bits, odd parity, 2 stop bits
+    Uart_line_7n1 = 0x02,   // 7 data bits, no parity, 1 stop bit
+    Uart_line_7n2 = 0x06,   // 7 data bits, no parity, 2 stop bits
+    Uart_line_7e1 = 0x1a,   // 7 data bits, even parity, 1 stop bit
+    Uart_line_7e2 = 0x1e,   // 7 data bits, even parity, 2 stop bits
+    Uart_line_7o1 = 0x0a,   // 7 data bits, odd parity, 1 stop bit
+    Uart_line_7o2 = 0x0e,   // 7 data bits, odd parity, 2 stop bits
+    Uart_line_8n1 = 0x03,   // 8 data bits, no parity, 1 stop bit
+    Uart_line_8n2 = 0x07,   // 8 data bits, no parity, 2 stop bits
+    Uart_line_8e1 = 0x1b,   // 8 data bits, even parity, 1 stop bit
+    Uart_line_8e2 = 0x1f,   // 8 data bits, even parity, 2 stop bits
+    Uart_line_8o1 = 0x0b,   // 8 data bits, odd parity, 1 stop bit
+    Uart_line_8o2 = 0x0f    // 8 data bits, odd parity, 2 stop bits
+}uart_line_e;
+
+//rx & tx fifo config
+typedef enum enum_uart_fifo {
+	UART_INT_RXFIFO_DEPTH_1 = 0x01,        			//fifo enable, rx 1 byte, set rx int
+	UART_INT_RXFIFO_DEPTH_QUARTER = 0x41,			//fifo enable, rx 1/4 fifo, set rx int
+	UART_INT_RXFIFO_DEPTH_HALF =0x81,				//fifo enable, rx 1/2 fifo, set rx int
+	UART_INT_RXFIFO_2LESS_THAN_FULL =0xc1,			//fifo enable, rx 2 less than full,  set rx int
+}uart_fifo_e;
+
+//line status
+enum {
+	UART_LINE_STATUS_RFE	 = (lift_shift_bit_num(7)),
+	UART_LINE_STATUS_TEMT 	 = (lift_shift_bit_num(6)),
+	UART_LINE_STATUS_THRE 	 = (lift_shift_bit_num(5)),
+	UART_LINE_STATUS_BI	 	 = (lift_shift_bit_num(4)),
+	UART_LINE_STATUS_FE 	 = (lift_shift_bit_num(3)),
+	UART_LINE_STATUS_PE   	 = (lift_shift_bit_num(2)),
+	UART_LINE_STATUS_OE 	 = (lift_shift_bit_num(1)),
+	UART_LINE_STATUS_DR 	 = (lift_shift_bit_num(0)),
+};
+
+//uart status
+enum {
+	UART_STATUS_RFF	 = (lift_shift_bit_num(4)),
+	UART_STATUS_RFNE = (lift_shift_bit_num(3)),
+	UART_STATUS_TFE	 = (lift_shift_bit_num(2)),
+	UART_STATUS_TFNF = (lift_shift_bit_num(1)),
+	UART_STATUS_BUSY = (lift_shift_bit_num(0)),
+
+};
+
+#define 	UART_CLOCK_FREQ   	(30000000)   //15MHZ
+typedef enum enum_uart_baudrate{
+	BAUDRATE_9600 	= (((UART_CLOCK_FREQ/9600)+8)/16),
+	BAUDRATE_19200 	= (((UART_CLOCK_FREQ/19200)+8)/16),
+	BAUDRATE_38400  = (((UART_CLOCK_FREQ/38400)+8)/16),
+	BAUDRATE_57600  = (((UART_CLOCK_FREQ/57600)+8)/16),
+	BAUDRATE_115200 = (((UART_CLOCK_FREQ/115200)+8)/16),
+	BAUDRATE_194000 = (((UART_CLOCK_FREQ/194000)+8)/16),
+}uart_baudrate_e;
+
+typedef struct _fh_uart_info {
+	const char * name;
+	unsigned int irq_num;
+	unsigned char __iomem	*base_add;
+	uart_baudrate_e	baudrate;
+	uart_line_e		line_ctrl;
+	uart_fifo_e		fifo_ctrl;
+	struct platform_device *dev;
+
+}fh_uart_info;
+
+struct fh_uart_port {
+	fh_uart_info	fh_info;
+	struct uart_port port;
+};
+
+#endif /* FH_SERIAL_H_ */
diff -uraN linux-3.0.8/drivers/tty/serial/Kconfig linux-3.0.8-fh8632-V1.0_20180330/drivers/tty/serial/Kconfig
--- linux-3.0.8/drivers/tty/serial/Kconfig	2021-07-14 21:52:04.471138221 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/tty/serial/Kconfig	2021-07-13 23:40:35.806369369 +0300
@@ -1635,4 +1635,32 @@
 	help
 	  Enable a Xilinx PS UART port to be the system console.
 
+config SERIAL_FH
+	tristate "FH UART support"
+	select SERIAL_CORE
+	help
+	  This driver supports the FH UART port.
+	  
+config SERIAL_FH_CONSOLE
+	bool "FH UART console support"
+	depends on SERIAL_FH=y
+	select SERIAL_CORE_CONSOLE
+	help
+	   Enable a FH UART port to be the system console.
+	   
+	   
+	   
+	   
+	
+
+
+	   
+	   
+	   
+	   
+	   
+	   
+	   
+	   
+	   
 endmenu
diff -uraN linux-3.0.8/drivers/tty/serial/Makefile linux-3.0.8-fh8632-V1.0_20180330/drivers/tty/serial/Makefile
--- linux-3.0.8/drivers/tty/serial/Makefile	2021-07-14 21:52:04.471138221 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/tty/serial/Makefile	2021-07-13 23:40:35.790369273 +0300
@@ -96,3 +96,7 @@
 obj-$(CONFIG_SERIAL_MXS_AUART) += mxs-auart.o
 obj-$(CONFIG_SERIAL_LANTIQ)	+= lantiq.o
 obj-$(CONFIG_SERIAL_XILINX_PS_UART) += xilinx_uartps.o
+obj-$(CONFIG_SERIAL_FH) += fh_serial.o
+
+
+
diff -uraN linux-3.0.8/drivers/usb/core/hcd.c linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/core/hcd.c
--- linux-3.0.8/drivers/usb/core/hcd.c	2021-07-14 21:52:04.511138336 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/core/hcd.c	2021-07-13 23:40:34.154359304 +0300
@@ -393,7 +393,6 @@
 	char const *s;
 	static char const langids[4] = {4, USB_DT_STRING, 0x09, 0x04};
 
-	// language ids
 	switch (id) {
 	case 0:
 		/* Array of LANGID codes (0x0409 is MSFT-speak for "en-us") */
@@ -562,7 +561,6 @@
 	case DeviceOutRequest | USB_REQ_SET_INTERFACE:
 		break;
 	case DeviceOutRequest | USB_REQ_SET_ADDRESS:
-		// wValue == urb->dev->devaddr
 		dev_dbg (hcd->self.controller, "root hub device address %d\n",
 			wValue);
 		break;
@@ -572,7 +570,7 @@
 	/* ENDPOINT REQUESTS */
 
 	case EndpointRequest | USB_REQ_GET_STATUS:
-		// ENDPOINT_HALT flag
+
 		tbuf [0] = 0;
 		tbuf [1] = 0;
 		len = 2;
@@ -1582,8 +1580,10 @@
 	usb_unanchor_urb(urb);
 
 	/* pass ownership to the completion handler */
+	//printk("god...hand add is %x\n",(unsigned int)urb->complete);
 	urb->status = status;
 	urb->complete (urb);
+
 	atomic_dec (&urb->use_count);
 	if (unlikely(atomic_read(&urb->reject)))
 		wake_up (&usb_kill_urb_queue);
diff -uraN linux-3.0.8/drivers/usb/core/hub.c linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/core/hub.c
--- linux-3.0.8/drivers/usb/core/hub.c	2021-07-14 21:52:04.511138336 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/core/hub.c	2021-07-13 23:40:34.150359280 +0300
@@ -2939,6 +2939,7 @@
 					/* FALL THROUGH */
 				default:
 					if (r == 0)
+						printk("error is r = eproto\n");
 						r = -EPROTO;
 					break;
 				}
diff -uraN linux-3.0.8/drivers/usb/gadget/gadget_chips.h linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/gadget/gadget_chips.h
--- linux-3.0.8/drivers/usb/gadget/gadget_chips.h	2021-07-14 21:52:04.527138383 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/gadget/gadget_chips.h	2021-07-13 23:40:34.202359600 +0300
@@ -136,6 +136,7 @@
 #define gadget_is_s3c_hsotg(g)    0
 #endif
 
+
 #ifdef CONFIG_USB_S3C_HSUDC
 #define gadget_is_s3c_hsudc(g) (!strcmp("s3c-hsudc", (g)->name))
 #else
@@ -223,6 +224,7 @@
 		return 0x29;
 	else if (gadget_is_s3c_hsudc(gadget))
 		return 0x30;
+		return 0x31;
 
 	return -ENOENT;
 }
diff -uraN linux-3.0.8/drivers/usb/gadget/Makefile linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/gadget/Makefile
--- linux-3.0.8/drivers/usb/gadget/Makefile	2021-07-14 21:52:04.515138348 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/gadget/Makefile	2021-07-13 23:40:34.198359575 +0300
@@ -3,7 +3,7 @@
 #
 ccflags-$(CONFIG_USB_GADGET_DEBUG) := -DDEBUG
 
-obj-$(CONFIG_USB_DUMMY_HCD)	+= dummy_hcd.o
+#obj-$(CONFIG_USB_DUMMY_HCD)	+= dummy_hcd.o
 obj-$(CONFIG_USB_NET2280)	+= net2280.o
 obj-$(CONFIG_USB_AMD5536UDC)	+= amd5536udc.o
 obj-$(CONFIG_USB_PXA25X)	+= pxa25x_udc.o
@@ -22,6 +22,7 @@
 obj-$(CONFIG_USB_FSL_QE)	+= fsl_qe_udc.o
 obj-$(CONFIG_USB_CI13XXX_PCI)	+= ci13xxx_pci.o
 obj-$(CONFIG_USB_S3C_HSOTG)	+= s3c-hsotg.o
+obj-$(CONFIG_USB_S3C_OTGD)	+= s3c_udc_otg.o
 obj-$(CONFIG_USB_S3C_HSUDC)	+= s3c-hsudc.o
 obj-$(CONFIG_USB_LANGWELL)	+= langwell_udc.o
 obj-$(CONFIG_USB_EG20T)		+= pch_udc.o
diff -uraN linux-3.0.8/drivers/usb/gadget/s3c2410_udc.c linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/gadget/s3c2410_udc.c
--- linux-3.0.8/drivers/usb/gadget/s3c2410_udc.c	2021-07-14 21:52:04.539138417 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/gadget/s3c2410_udc.c	2021-07-13 23:40:34.202359600 +0300
@@ -28,6 +28,7 @@
 #include <linux/ioport.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
+#include <linux/smp_lock.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/timer.h>
@@ -35,8 +36,6 @@
 #include <linux/interrupt.h>
 #include <linux/platform_device.h>
 #include <linux/clk.h>
-#include <linux/gpio.h>
-#include <linux/prefetch.h>
 
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
@@ -52,6 +51,7 @@
 #include <mach/irqs.h>
 
 #include <mach/hardware.h>
+#include <mach/regs-gpio.h>
 
 #include <plat/regs-udc.h>
 #include <plat/udc.h>
@@ -736,10 +736,6 @@
 	else
 		dev->ep0state = EP0_OUT_DATA_PHASE;
 
-	if (!dev->driver)
-		return;
-
-	/* deliver the request to the gadget driver */
 	ret = dev->driver->setup(&dev->gadget, crq);
 	if (ret < 0) {
 		if (dev->req_config) {
@@ -903,7 +899,7 @@
 	int pwr_reg;
 	int ep0csr;
 	int i;
-	u32 idx, idx2;
+	u32 idx;
 	unsigned long flags;
 
 	spin_lock_irqsave(&dev->lock, flags);
@@ -1018,20 +1014,6 @@
 		}
 	}
 
-	/* what else causes this interrupt? a receive! who is it? */
-	if (!usb_status && !usbd_status && !pwr_reg && !ep0csr) {
-		for (i = 1; i < S3C2410_ENDPOINTS; i++) {
-			idx2 = udc_read(S3C2410_UDC_INDEX_REG);
-			udc_write(i, S3C2410_UDC_INDEX_REG);
-
-			if (udc_read(S3C2410_UDC_OUT_CSR1_REG) & 0x1)
-				s3c2410_udc_handle_ep(&dev->ep[i]);
-
-			/* restore index */
-			udc_write(idx2, S3C2410_UDC_INDEX_REG);
-		}
-	}
-
 	dprintk(DEBUG_VERBOSE, "irq: %d s3c2410_udc_done.\n", IRQ_USBD);
 
 	/* Restore old index */
@@ -1482,9 +1464,7 @@
 {
 	dprintk(DEBUG_NORMAL, "%s()\n", __func__);
 
-	if (udc_info && (udc_info->udc_command ||
-		gpio_is_valid(udc_info->pullup_pin))) {
-
+	if (udc_info && udc_info->udc_command) {
 		if (is_on)
 			s3c2410_udc_enable(udc);
 		else {
@@ -1530,7 +1510,11 @@
 
 	dprintk(DEBUG_NORMAL, "%s()\n", __func__);
 
-	value = gpio_get_value(udc_info->vbus_pin) ? 1 : 0;
+	/* some cpus cannot read from an line configured to IRQ! */
+	s3c2410_gpio_cfgpin(udc_info->vbus_pin, S3C2410_GPIO_INPUT);
+	value = s3c2410_gpio_getpin(udc_info->vbus_pin);
+	s3c2410_gpio_cfgpin(udc_info->vbus_pin, S3C2410_GPIO_SFN2);
+
 	if (udc_info->vbus_pin_inverted)
 		value = !value;
 
@@ -1561,32 +1545,6 @@
 	.vbus_draw		= s3c2410_vbus_draw,
 };
 
-static void s3c2410_udc_command(enum s3c2410_udc_cmd_e cmd)
-{
-	if (!udc_info)
-		return;
-
-	if (udc_info->udc_command) {
-		udc_info->udc_command(S3C2410_UDC_P_DISABLE);
-	} else if (gpio_is_valid(udc_info->pullup_pin)) {
-		int value;
-
-		switch (cmd) {
-		case S3C2410_UDC_P_ENABLE:
-			value = 1;
-			break;
-		case S3C2410_UDC_P_DISABLE:
-			value = 0;
-			break;
-		default:
-			return;
-		}
-		value ^= udc_info->pullup_pin_inverted;
-
-		gpio_set_value(udc_info->pullup_pin, value);
-	}
-}
-
 /*------------------------- gadget driver handling---------------------------*/
 /*
  * s3c2410_udc_disable
@@ -1608,7 +1566,8 @@
 	udc_write(0x1F, S3C2410_UDC_EP_INT_REG);
 
 	/* Good bye, cruel world */
-	s3c2410_udc_command(S3C2410_UDC_P_DISABLE);
+	if (udc_info && udc_info->udc_command)
+		udc_info->udc_command(S3C2410_UDC_P_DISABLE);
 
 	/* Set speed to unknown */
 	dev->gadget.speed = USB_SPEED_UNKNOWN;
@@ -1669,19 +1628,20 @@
 	udc_write(S3C2410_UDC_INT_EP0, S3C2410_UDC_EP_INT_EN_REG);
 
 	/* time to say "hello, world" */
-	s3c2410_udc_command(S3C2410_UDC_P_ENABLE);
+	if (udc_info && udc_info->udc_command)
+		udc_info->udc_command(S3C2410_UDC_P_ENABLE);
 }
 
 /*
- *	usb_gadget_probe_driver
+ *	usb_gadget_register_driver
  */
-int usb_gadget_probe_driver(struct usb_gadget_driver *driver,
-		int (*bind)(struct usb_gadget *))
+int usb_gadget_register_driver(struct usb_gadget_driver *driver)
 {
 	struct s3c2410_udc *udc = the_controller;
 	int		retval;
 
-	dprintk(DEBUG_NORMAL, "%s() '%s'\n", __func__, driver->driver.name);
+	dprintk(DEBUG_NORMAL, "usb_gadget_register_driver() '%s'\n",
+		driver->driver.name);
 
 	/* Sanity checks */
 	if (!udc)
@@ -1690,9 +1650,10 @@
 	if (udc->driver)
 		return -EBUSY;
 
-	if (!bind || !driver->setup || driver->speed < USB_SPEED_FULL) {
+	if (!driver->bind || !driver->setup
+			|| driver->speed < USB_SPEED_FULL) {
 		printk(KERN_ERR "Invalid driver: bind %p setup %p speed %d\n",
-			bind, driver->setup, driver->speed);
+			driver->bind, driver->setup, driver->speed);
 		return -EINVAL;
 	}
 #if defined(MODULE)
@@ -1715,7 +1676,7 @@
 	dprintk(DEBUG_NORMAL, "binding gadget driver '%s'\n",
 		driver->driver.name);
 
-	if ((retval = bind(&udc->gadget)) != 0) {
+	if ((retval = driver->bind (&udc->gadget)) != 0) {
 		device_del(&udc->gadget.dev);
 		goto register_error;
 	}
@@ -1730,7 +1691,6 @@
 	udc->gadget.dev.driver = NULL;
 	return retval;
 }
-EXPORT_SYMBOL(usb_gadget_probe_driver);
 
 /*
  *	usb_gadget_unregister_driver
@@ -1745,15 +1705,12 @@
 	if (!driver || driver != udc->driver || !driver->unbind)
 		return -EINVAL;
 
-	dprintk(DEBUG_NORMAL, "usb_gadget_unregister_driver() '%s'\n",
+	dprintk(DEBUG_NORMAL,"usb_gadget_register_driver() '%s'\n",
 		driver->driver.name);
 
-	/* report disconnect */
 	if (driver->disconnect)
 		driver->disconnect(&udc->gadget);
 
-	driver->unbind(&udc->gadget);
-
 	device_del(&udc->gadget.dev);
 	udc->driver = NULL;
 
@@ -1770,7 +1727,7 @@
 		.ep0		= &memory.ep[0].ep,
 		.name		= gadget_name,
 		.dev = {
-			.init_name	= "gadget",
+			.bus_id		= "gadget",
 		},
 	},
 
@@ -1845,7 +1802,7 @@
 	struct s3c2410_udc *udc = &memory;
 	struct device *dev = &pdev->dev;
 	int retval;
-	int irq;
+	unsigned int irq;
 
 	dev_dbg(dev, "%s()\n", __func__);
 
@@ -1904,7 +1861,7 @@
 
 	/* irq setup after old hardware state is cleaned up */
 	retval = request_irq(IRQ_USBD, s3c2410_udc_irq,
-			     IRQF_DISABLED, gadget_name, udc);
+			IRQF_DISABLED, gadget_name, udc);
 
 	if (retval != 0) {
 		dev_err(dev, "cannot get irq %i, err %d\n", IRQ_USBD, retval);
@@ -1915,28 +1872,17 @@
 	dev_dbg(dev, "got irq %i\n", IRQ_USBD);
 
 	if (udc_info && udc_info->vbus_pin > 0) {
-		retval = gpio_request(udc_info->vbus_pin, "udc vbus");
-		if (retval < 0) {
-			dev_err(dev, "cannot claim vbus pin\n");
-			goto err_int;
-		}
-
-		irq = gpio_to_irq(udc_info->vbus_pin);
-		if (irq < 0) {
-			dev_err(dev, "no irq for gpio vbus pin\n");
-			goto err_gpio_claim;
-		}
-
+		irq = s3c2410_gpio_getirq(udc_info->vbus_pin);
 		retval = request_irq(irq, s3c2410_udc_vbus_irq,
 				     IRQF_DISABLED | IRQF_TRIGGER_RISING
 				     | IRQF_TRIGGER_FALLING | IRQF_SHARED,
 				     gadget_name, udc);
 
 		if (retval != 0) {
-			dev_err(dev, "can't get vbus irq %d, err %d\n",
+			dev_err(dev, "can't get vbus irq %i, err %d\n",
 				irq, retval);
 			retval = -EBUSY;
-			goto err_gpio_claim;
+			goto err_int;
 		}
 
 		dev_dbg(dev, "got irq %i\n", irq);
@@ -1944,17 +1890,6 @@
 		udc->vbus = 1;
 	}
 
-	if (udc_info && !udc_info->udc_command &&
-		gpio_is_valid(udc_info->pullup_pin)) {
-
-		retval = gpio_request_one(udc_info->pullup_pin,
-				udc_info->vbus_pin_inverted ?
-				GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW,
-				"udc pullup");
-		if (retval)
-			goto err_vbus_irq;
-	}
-
 	if (s3c2410_udc_debugfs_root) {
 		udc->regs_info = debugfs_create_file("registers", S_IRUGO,
 				s3c2410_udc_debugfs_root,
@@ -1967,12 +1902,6 @@
 
 	return 0;
 
-err_vbus_irq:
-	if (udc_info && udc_info->vbus_pin > 0)
-		free_irq(gpio_to_irq(udc_info->vbus_pin), udc);
-err_gpio_claim:
-	if (udc_info && udc_info->vbus_pin > 0)
-		gpio_free(udc_info->vbus_pin);
 err_int:
 	free_irq(IRQ_USBD, udc);
 err_map:
@@ -1997,12 +1926,8 @@
 
 	debugfs_remove(udc->regs_info);
 
-	if (udc_info && !udc_info->udc_command &&
-		gpio_is_valid(udc_info->pullup_pin))
-		gpio_free(udc_info->pullup_pin);
-
 	if (udc_info && udc_info->vbus_pin > 0) {
-		irq = gpio_to_irq(udc_info->vbus_pin);
+		irq = s3c2410_gpio_getirq(udc_info->vbus_pin);
 		free_irq(irq, udc);
 	}
 
@@ -2032,14 +1957,16 @@
 #ifdef CONFIG_PM
 static int s3c2410_udc_suspend(struct platform_device *pdev, pm_message_t message)
 {
-	s3c2410_udc_command(S3C2410_UDC_P_DISABLE);
+	if (udc_info && udc_info->udc_command)
+		udc_info->udc_command(S3C2410_UDC_P_DISABLE);
 
 	return 0;
 }
 
 static int s3c2410_udc_resume(struct platform_device *pdev)
 {
-	s3c2410_udc_command(S3C2410_UDC_P_ENABLE);
+	if (udc_info && udc_info->udc_command)
+		udc_info->udc_command(S3C2410_UDC_P_ENABLE);
 
 	return 0;
 }
@@ -2106,6 +2033,7 @@
 }
 
 EXPORT_SYMBOL(usb_gadget_unregister_driver);
+EXPORT_SYMBOL(usb_gadget_register_driver);
 
 module_init(udc_init);
 module_exit(udc_exit);
diff -uraN linux-3.0.8/drivers/usb/gadget/s3c_udc.h linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/gadget/s3c_udc.h
--- linux-3.0.8/drivers/usb/gadget/s3c_udc.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/gadget/s3c_udc.h	2021-07-13 23:40:34.194359551 +0300
@@ -0,0 +1,134 @@
+/*
+ * drivers/usb/gadget/s3c_udc.h
+ * Samsung S3C on-chip full/high speed USB device controllers
+ * Copyright (C) 2005 for Samsung Electronics 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+ 
+#ifndef __S3C_USB_GADGET
+#define __S3C_USB_GADGET
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/byteorder.h>
+#include <asm/dma.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+//#include <asm/hardware.h>
+
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+
+// Max packet size
+#if defined(CONFIG_USB_GADGET_S3C_FS)
+#define EP0_FIFO_SIZE		8
+#define EP_FIFO_SIZE		64
+#define S3C_MAX_ENDPOINTS	5
+#elif defined(CONFIG_USB_GADGET_S3C_HS) || defined(CONFIG_PLAT_S5P64XX)
+#define EP0_FIFO_SIZE		64
+#define EP_FIFO_SIZE		512
+#define EP_FIFO_SIZE2		1024
+#define S3C_MAX_ENDPOINTS	9
+#define DED_TX_FIFO		1	/* Dedicated NPTx fifo for s5p6440 */
+#else
+#define EP0_FIFO_SIZE		64
+#define EP_FIFO_SIZE		512
+#define EP_FIFO_SIZE2		1024
+#define S3C_MAX_ENDPOINTS	16
+#endif
+
+#define WAIT_FOR_SETUP          0
+#define DATA_STATE_XMIT         1
+#define DATA_STATE_NEED_ZLP     2
+#define WAIT_FOR_OUT_STATUS     3
+#define DATA_STATE_RECV         4
+#define RegReadErr		5
+#define FAIL_TO_SETUP		6
+
+/* ********************************************************************************************* */
+/* IO
+ */
+
+typedef enum ep_type {
+	ep_control, ep_bulk_in, ep_bulk_out, ep_interrupt
+} ep_type_t;
+
+struct s3c_ep {
+	struct usb_ep ep;
+	struct s3c_udc *dev;
+
+	const struct usb_endpoint_descriptor *desc;
+	struct list_head queue;
+	unsigned long pio_irqs;
+
+	u8 stopped;
+	u8 bEndpointAddress;
+	u8 bmAttributes;
+
+	ep_type_t ep_type;
+	u32 fifo;
+#ifdef CONFIG_USB_GADGET_S3C_FS
+	u32 csr1;
+	u32 csr2;
+#endif
+};
+
+struct s3c_request {
+	struct usb_request req;
+	struct list_head queue;
+};
+
+struct s3c_udc {
+	struct usb_gadget gadget;
+	struct usb_gadget_driver *driver;
+	//struct device *dev;
+	struct platform_device *dev;
+	spinlock_t lock;
+
+	int ep0state;
+	struct s3c_ep ep[S3C_MAX_ENDPOINTS];
+
+	unsigned char usb_address;
+
+	unsigned req_pending:1, req_std:1, req_config:1;
+};
+
+extern struct s3c_udc *the_controller;
+
+#define ep_is_in(EP) 		(((EP)->bEndpointAddress&USB_DIR_IN)==USB_DIR_IN)
+#define ep_index(EP) 		((EP)->bEndpointAddress&0xF)
+#define ep_maxpacket(EP) 	((EP)->ep.maxpacket)
+
+#endif
diff -uraN linux-3.0.8/drivers/usb/gadget/s3c_udc_otg.c linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/gadget/s3c_udc_otg.c
--- linux-3.0.8/drivers/usb/gadget/s3c_udc_otg.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/gadget/s3c_udc_otg.c	2021-07-13 23:40:34.194359551 +0300
@@ -0,0 +1,1093 @@
+/*
+ * drivers/usb/gadget/s3c_udc_otg.c
+ * Samsung S3C on-chip full/high speed USB OTG 2.0 device controllers
+ *
+ * Copyright (C) 2008 for Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include "s3c_udc.h"
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <mach/map.h>
+#include <plat/regs-otg.h>
+
+#if	defined(CONFIG_USB_GADGET_S3C_OTGD_DMA_MODE) /* DMA mode */
+#define OTG_DMA_MODE		1
+
+#elif	defined(CONFIG_USB_GADGET_S3C_OTGD_SLAVE_MODE) /* Slave mode */
+#define OTG_DMA_MODE		0
+#error " Slave Mode is not implemented to do later"
+#else
+#error " Unknown S3C OTG operation mode, Select a correct operation mode"
+#endif
+
+#undef DEBUG_S3C_UDC_SETUP
+#undef DEBUG_S3C_UDC_EP0
+#undef DEBUG_S3C_UDC_ISR
+#undef DEBUG_S3C_UDC_OUT_EP
+#undef DEBUG_S3C_UDC_IN_EP
+#undef DEBUG_S3C_UDC
+
+//#define DEBUG_S3C_UDC_SETUP
+//#define DEBUG_S3C_UDC_EP0
+//#define DEBUG_S3C_UDC_ISR
+//#define DEBUG_S3C_UDC_OUT_EP
+//#define DEBUG_S3C_UDC_IN_EP
+//#define DEBUG_S3C_UDC
+
+#define EP0_CON		0
+#define EP1_OUT		1
+#define EP2_IN		2
+#define EP3_IN		3
+#define EP_MASK		0xF
+
+#if defined(DEBUG_S3C_UDC_SETUP) || defined(DEBUG_S3C_UDC_ISR)\
+	|| defined(DEBUG_S3C_UDC_OUT_EP)
+
+static char *state_names[] = {
+	"WAIT_FOR_SETUP",
+	"DATA_STATE_XMIT",
+	"DATA_STATE_NEED_ZLP",
+	"WAIT_FOR_OUT_STATUS",
+	"DATA_STATE_RECV",
+	};
+#endif
+
+#ifdef DEBUG_S3C_UDC_SETUP
+#define DEBUG_SETUP(fmt,args...) printk(fmt, ##args)
+#else
+#define DEBUG_SETUP(fmt,args...) do {} while(0)
+#endif
+
+#ifdef DEBUG_S3C_UDC_EP0
+#define DEBUG_EP0(fmt,args...) printk(fmt, ##args)
+#else
+#define DEBUG_EP0(fmt,args...) do {} while(0)
+#endif
+
+#ifdef DEBUG_S3C_UDC
+#define DEBUG(fmt,args...) printk(fmt, ##args)
+#else
+#define DEBUG(fmt,args...) do {} while(0)
+#endif
+
+#ifdef DEBUG_S3C_UDC_ISR
+#define DEBUG_ISR(fmt,args...) printk(fmt, ##args)
+#else
+#define DEBUG_ISR(fmt,args...) do {} while(0)
+#endif
+
+#ifdef DEBUG_S3C_UDC_OUT_EP
+#define DEBUG_OUT_EP(fmt,args...) printk(fmt, ##args)
+#else
+#define DEBUG_OUT_EP(fmt,args...) do {} while(0)
+#endif
+
+#ifdef DEBUG_S3C_UDC_IN_EP
+#define DEBUG_IN_EP(fmt,args...) printk(fmt, ##args)
+#else
+#define DEBUG_IN_EP(fmt,args...) do {} while(0)
+#endif
+
+
+#define	DRIVER_DESC		"S3C HS USB OTG Device Driver, (c) 2008-2009 Samsung Electronics"
+#define	DRIVER_VERSION		"15 March 2009"
+
+struct s3c_udc	*the_controller;
+
+static const char driver_name[] = "s3c-udc";
+static const char driver_desc[] = DRIVER_DESC;
+static const char ep0name[] = "ep0-control";
+
+/* Max packet size*/
+static unsigned int ep0_fifo_size = 64;
+static unsigned int ep_fifo_size =  512;
+static unsigned int ep_fifo_size2 = 1024;
+static int reset_available = 1;
+
+extern void otg_phy_init(void);
+extern void otg_phy_off(void);
+extern struct usb_ctrlrequest usb_ctrl;
+
+/*
+  Local declarations.
+*/
+static int s3c_ep_enable(struct usb_ep *ep, const struct usb_endpoint_descriptor *);
+static int s3c_ep_disable(struct usb_ep *ep);
+static struct usb_request *s3c_alloc_request(struct usb_ep *ep, gfp_t gfp_flags);
+static void s3c_free_request(struct usb_ep *ep, struct usb_request *);
+
+static int s3c_queue(struct usb_ep *ep, struct usb_request *, gfp_t gfp_flags);
+static int s3c_dequeue(struct usb_ep *ep, struct usb_request *);
+static int s3c_fifo_status(struct usb_ep *ep);
+static void s3c_fifo_flush(struct usb_ep *ep);
+static void s3c_ep0_read(struct s3c_udc *dev);
+static void s3c_ep0_kick(struct s3c_udc *dev, struct s3c_ep *ep);
+static void s3c_handle_ep0(struct s3c_udc *dev);
+static int s3c_ep0_write(struct s3c_udc *dev);
+static int write_fifo_ep0(struct s3c_ep *ep, struct s3c_request *req);
+static void done(struct s3c_ep *ep, struct s3c_request *req, int status);
+static void stop_activity(struct s3c_udc *dev, struct usb_gadget_driver *driver);
+static int udc_enable(struct s3c_udc *dev);
+static void udc_set_address(struct s3c_udc *dev, unsigned char address);
+static void reconfig_usbd(void);
+static void set_max_pktsize(struct s3c_udc *dev, enum usb_device_speed speed);
+static void nuke(struct s3c_ep *ep, int status);
+static int s3c_udc_set_halt(struct usb_ep *_ep, int value);
+
+static struct usb_ep_ops s3c_ep_ops = {
+	.enable = s3c_ep_enable,
+	.disable = s3c_ep_disable,
+
+	.alloc_request = s3c_alloc_request,
+	.free_request = s3c_free_request,
+
+	.queue = s3c_queue,
+	.dequeue = s3c_dequeue,
+
+	.set_halt = s3c_udc_set_halt,
+	.fifo_status = s3c_fifo_status,
+	.fifo_flush = s3c_fifo_flush,
+};
+
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
+
+static const char proc_node_name[] = "driver/udc";
+
+static int
+udc_proc_read(char *page, char **start, off_t off, int count,
+	      int *eof, void *_dev)
+{
+	char *buf = page;
+	struct s3c_udc *dev = _dev;
+	char *next = buf;
+	unsigned size = count;
+	unsigned long flags;
+	int t;
+
+	if (off != 0)
+		return 0;
+
+	local_irq_save(flags);
+
+	/* basic device status */
+	t = scnprintf(next, size,
+		      DRIVER_DESC "\n"
+		      "%s version: %s\n"
+		      "Gadget driver: %s\n"
+		      "\n",
+		      driver_name, DRIVER_VERSION,
+		      dev->driver ? dev->driver->driver.name : "(none)");
+	size -= t;
+	next += t;
+
+	local_irq_restore(flags);
+	*eof = 1;
+	return count - size;
+}
+
+#define create_proc_files() \
+	create_proc_read_entry(proc_node_name, 0, NULL, udc_proc_read, dev)
+#define remove_proc_files() \
+	remove_proc_entry(proc_node_name, NULL)
+
+#else	/* !CONFIG_USB_GADGET_DEBUG_FILES */
+
+#define create_proc_files() do {} while (0)
+#define remove_proc_files() do {} while (0)
+
+#endif	/* CONFIG_USB_GADGET_DEBUG_FILES */
+
+#if	OTG_DMA_MODE /* DMA Mode */
+#include "s3c_udc_otg_xfer_dma.c"
+
+#else	/* Slave Mode */
+#include "s3c_udc_otg_xfer_slave.c"
+#endif
+
+/*
+ * 	udc_disable - disable USB device controller
+ */
+static void udc_disable(struct s3c_udc *dev)
+{
+	DEBUG_SETUP("%s: %p\n", __FUNCTION__, dev);
+
+	udc_set_address(dev, 0);
+
+	dev->ep0state = WAIT_FOR_SETUP;
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+	dev->usb_address = 0;
+
+	otg_phy_off();
+}
+
+/*
+ * 	udc_reinit - initialize software state
+ */
+static void udc_reinit(struct s3c_udc *dev)
+{
+	unsigned int i;
+
+	DEBUG_SETUP("%s: %p\n", __FUNCTION__, dev);
+
+	/* device/ep0 records init */
+	INIT_LIST_HEAD(&dev->gadget.ep_list);
+	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
+	dev->ep0state = WAIT_FOR_SETUP;
+
+	/* basic endpoint records init */
+	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
+		struct s3c_ep *ep = &dev->ep[i];
+
+		if (i != 0)
+			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);
+
+		ep->desc = 0;
+		ep->stopped = 0;
+		INIT_LIST_HEAD(&ep->queue);
+		ep->pio_irqs = 0;
+	}
+
+	/* the rest was statically initialized, and is read-only */
+}
+
+#define BYTES2MAXP(x)	(x / 8)
+#define MAXP2BYTES(x)	(x * 8)
+
+/* until it's enabled, this UDC should be completely invisible
+ * to any USB host.
+ */
+static int udc_enable(struct s3c_udc *dev)
+{
+	DEBUG_SETUP("%s: %p\n", __FUNCTION__, dev);
+
+	otg_phy_init();
+	reconfig_usbd();
+
+	DEBUG_SETUP("S3C USB 2.0 OTG Controller Core Initialized : 0x%x\n",
+			readl(S3C_UDC_OTG_GINTMSK));
+
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+
+	return 0;
+}
+
+/*
+  Register entry point for the peripheral controller driver.
+*/
+int usb_gadget_register_driver(struct usb_gadget_driver *driver)
+{
+	struct s3c_udc *dev = the_controller;
+	int retval;
+
+	DEBUG_SETUP("%s: %s\n", __FUNCTION__, driver->driver.name);
+
+	if (!driver
+	    || (driver->speed != USB_SPEED_FULL && driver->speed != USB_SPEED_HIGH)
+	    || !driver->bind
+	    || !driver->unbind || !driver->disconnect || !driver->setup)
+		return -EINVAL;
+	if (!dev)
+		return -ENODEV;
+	if (dev->driver)
+		return -EBUSY;
+
+	/* first hook up the driver ... */
+	dev->driver = driver;
+	dev->gadget.dev.driver = &driver->driver;
+	retval = device_add(&dev->gadget.dev);
+
+	if(retval) { /* TODO */
+		printk("target device_add failed, error %d\n", retval);
+		return retval;
+	}
+
+	retval = driver->bind(&dev->gadget);
+	if (retval) {
+		printk("%s: bind to driver %s --> error %d\n", dev->gadget.name,
+		       driver->driver.name, retval);
+		device_del(&dev->gadget.dev);
+
+		dev->driver = 0;
+		dev->gadget.dev.driver = 0;
+		return retval;
+	}
+
+	enable_irq(IRQ_OTG);
+
+	printk("Registered gadget driver '%s'\n", driver->driver.name);
+	udc_enable(dev);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(usb_gadget_register_driver);
+
+/*
+  Unregister entry point for the peripheral controller driver.
+*/
+int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
+{
+	struct s3c_udc *dev = the_controller;
+	unsigned long flags;
+
+	if (!dev)
+		return -ENODEV;
+	if (!driver || driver != dev->driver)
+		return -EINVAL;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	dev->driver = 0;
+	stop_activity(dev, driver);
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	driver->unbind(&dev->gadget);
+	device_del(&dev->gadget.dev);
+
+	disable_irq(IRQ_OTG);
+
+	printk("Unregistered gadget driver '%s'\n", driver->driver.name);
+
+	udc_disable(dev);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(usb_gadget_unregister_driver);
+
+/*
+ *	done - retire a request; caller blocked irqs
+ */
+static void done(struct s3c_ep *ep, struct s3c_request *req, int status)
+{
+	unsigned int stopped = ep->stopped;
+
+	DEBUG("%s: %s %p, req = %p, stopped = %d\n",
+		__FUNCTION__, ep->ep.name, ep, &req->req, stopped);
+
+	list_del_init(&req->queue);
+
+	if (likely(req->req.status == -EINPROGRESS)) {
+		req->req.status = status;
+	} else {
+		status = req->req.status;
+	}
+
+	if (status && status != -ESHUTDOWN) {
+		DEBUG("complete %s req %p stat %d len %u/%u\n",
+			ep->ep.name, &req->req, status,
+			req->req.actual, req->req.length);
+	}
+
+	/* don't modify queue heads during completion callback */
+	ep->stopped = 1;
+
+	spin_unlock(&ep->dev->lock);
+	req->req.complete(&ep->ep, &req->req);
+	spin_lock(&ep->dev->lock);
+
+	ep->stopped = stopped;
+}
+
+/*
+ * 	nuke - dequeue ALL requests
+ */
+static void nuke(struct s3c_ep *ep, int status)
+{
+	struct s3c_request *req;
+
+	DEBUG("%s: %s %p\n", __FUNCTION__, ep->ep.name, ep);
+
+	/* called with irqs blocked */
+	while (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next, struct s3c_request, queue);
+		done(ep, req, status);
+	}
+}
+
+static void stop_activity(struct s3c_udc *dev,
+			  struct usb_gadget_driver *driver)
+{
+	int i;
+
+	/* don't disconnect drivers more than once */
+	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
+		driver = 0;
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+
+	/* prevent new request submissions, kill any outstanding requests  */
+	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
+		struct s3c_ep *ep = &dev->ep[i];
+		ep->stopped = 1;
+		nuke(ep, -ESHUTDOWN);
+	}
+
+	/* report disconnect; the driver is already quiesced */
+	if (driver) {
+		spin_unlock(&dev->lock);
+		driver->disconnect(&dev->gadget);
+		spin_lock(&dev->lock);
+	}
+
+	/* re-init driver-visible data structures */
+	udc_reinit(dev);
+}
+
+static void reconfig_usbd(void)
+{
+	/* 2. Soft-reset OTG Core and then unreset again. */
+#ifdef DED_TX_FIFO
+	int i;
+#endif
+	unsigned int uTemp = writel(CORE_SOFT_RESET, S3C_UDC_OTG_GRSTCTL);
+
+	writel(	0<<15		/* PHY Low Power Clock sel*/
+		|1<<14		/* Non-Periodic TxFIFO Rewind Enable*/
+		|0x5<<10	/* Turnaround time*/
+		|0<<9|0<<8	/* [0:HNP disable, 1:HNP enable][ 0:SRP disable, 1:SRP enable] H1= 1,1*/
+		|0<<7		/* Ulpi DDR sel*/
+		|0<<6		/* 0: high speed utmi+, 1: full speed serial*/
+		|0<<4		/* 0: utmi+, 1:ulpi*/
+		|1<<3		/* phy i/f  0:8bit, 1:16bit*/
+		|0x7<<0,	/* HS/FS Timeout**/
+		S3C_UDC_OTG_GUSBCFG);
+
+	/* 3. Put the OTG device core in the disconnected state.*/
+	uTemp = readl(S3C_UDC_OTG_DCTL);
+	uTemp |= SOFT_DISCONNECT;
+	writel(uTemp, S3C_UDC_OTG_DCTL);
+
+	udelay(20);
+
+	/* 4. Make the OTG device core exit from the disconnected state.*/
+	uTemp = readl(S3C_UDC_OTG_DCTL);
+	uTemp = uTemp & ~SOFT_DISCONNECT;
+	writel(uTemp, S3C_UDC_OTG_DCTL);
+
+	/* 5. Configure OTG Core to initial settings of device mode.*/
+	writel(1<<18|0x0<<0, S3C_UDC_OTG_DCFG);		/* [][1: full speed(30Mhz) 0:high speed]*/
+
+	mdelay(1);
+
+	/* 6. Unmask the core interrupts*/
+	writel(GINTMSK_INIT, S3C_UDC_OTG_GINTMSK);
+
+	/* 7. Set NAK bit of EP0, EP1, EP2*/
+	writel(DEPCTL_EPDIS|DEPCTL_SNAK|(0<<0), S3C_UDC_OTG_DOEPCTL(EP0_CON));
+	writel(DEPCTL_EPDIS|DEPCTL_SNAK|(0<<0), S3C_UDC_OTG_DIEPCTL(EP0_CON));
+
+	/* 8. Unmask EPO interrupts*/
+	writel( ((1<<EP0_CON)<<DAINT_OUT_BIT)|(1<<EP0_CON), S3C_UDC_OTG_DAINTMSK);
+
+	/* 9. Unmask device OUT EP common interrupts*/
+	writel(DOEPMSK_INIT, S3C_UDC_OTG_DOEPMSK);
+
+	/* 10. Unmask device IN EP common interrupts*/
+	writel(DIEPMSK_INIT, S3C_UDC_OTG_DIEPMSK);
+
+	/* 11. Set Rx FIFO Size*/
+	writel(RX_FIFO_SIZE, S3C_UDC_OTG_GRXFSIZ);
+
+	/* 12. Set Non Periodic Tx FIFO Size*/
+	writel(NPTX_FIFO_SIZE<<16| NPTX_FIFO_START_ADDR<<0, S3C_UDC_OTG_GNPTXFSIZ);
+
+#ifdef DED_TX_FIFO
+	for (i = 1; i < S3C_MAX_ENDPOINTS; i++)
+		writel(NPTX_FIFO_SIZE << 16 |
+			(NPTX_FIFO_START_ADDR + NPTX_FIFO_SIZE + PTX_FIFO_SIZE*(i-1)) << 0,
+			S3C_UDC_OTG_DIEPTXF(i));
+#endif
+
+	/* 13. Clear NAK bit of EP0, EP1, EP2*/
+	/* For Slave mode*/
+	writel(DEPCTL_EPDIS|DEPCTL_CNAK|(0<<0), S3C_UDC_OTG_DOEPCTL(EP0_CON)); /* EP0: Control OUT */
+
+	/* 14. Initialize OTG Link Core.*/
+	writel(GAHBCFG_INIT, S3C_UDC_OTG_GAHBCFG);
+
+}
+
+static void set_max_pktsize(struct s3c_udc *dev, enum usb_device_speed speed)
+{
+	unsigned int ep_ctrl;
+
+	if (speed == USB_SPEED_HIGH) {
+		ep0_fifo_size = 64;
+		ep_fifo_size = 512;
+		ep_fifo_size2 = 1024;
+		dev->gadget.speed = USB_SPEED_HIGH;
+	} else {
+		ep0_fifo_size = 64;
+		ep_fifo_size = 64;
+		ep_fifo_size2 = 64;
+		dev->gadget.speed = USB_SPEED_FULL;
+	}
+
+	dev->ep[0].ep.maxpacket = ep0_fifo_size;
+	dev->ep[1].ep.maxpacket = ep_fifo_size;
+	dev->ep[2].ep.maxpacket = ep_fifo_size;
+	dev->ep[3].ep.maxpacket = ep_fifo_size;
+	dev->ep[4].ep.maxpacket = ep_fifo_size;
+	dev->ep[5].ep.maxpacket = ep_fifo_size2;
+	dev->ep[6].ep.maxpacket = ep_fifo_size2;
+	dev->ep[7].ep.maxpacket = ep_fifo_size2;
+	dev->ep[8].ep.maxpacket = ep_fifo_size2;
+
+
+	/* EP0 - Control IN (64 bytes)*/
+	ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL(EP0_CON));
+	writel(ep_ctrl|(0<<0), S3C_UDC_OTG_DIEPCTL(EP0_CON));
+
+	/* EP0 - Control OUT (64 bytes)*/
+	ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL(EP0_CON));
+	writel(ep_ctrl|(0<<0), S3C_UDC_OTG_DOEPCTL(EP0_CON));
+}
+
+static int s3c_ep_enable(struct usb_ep *_ep,
+			     const struct usb_endpoint_descriptor *desc)
+{
+	struct s3c_ep *ep;
+	struct s3c_udc *dev;
+	unsigned long flags;
+
+	DEBUG("%s: %p\n", __FUNCTION__, _ep);
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+	if (!_ep || !desc || ep->desc || _ep->name == ep0name
+	    || desc->bDescriptorType != USB_DT_ENDPOINT
+	    || ep->bEndpointAddress != desc->bEndpointAddress
+	    || ep_maxpacket(ep) < le16_to_cpu(desc->wMaxPacketSize)) {
+
+		DEBUG("%s: bad ep or descriptor\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	/* xfer types must match, except that interrupt ~= bulk */
+	if (ep->bmAttributes != desc->bmAttributes
+	    && ep->bmAttributes != USB_ENDPOINT_XFER_BULK
+	    && desc->bmAttributes != USB_ENDPOINT_XFER_INT) {
+
+		DEBUG("%s: %s type mismatch\n", __FUNCTION__, _ep->name);
+		return -EINVAL;
+	}
+
+	/* hardware _could_ do smaller, but driver doesn't */
+	if ((desc->bmAttributes == USB_ENDPOINT_XFER_BULK
+	     && le16_to_cpu(desc->wMaxPacketSize) != ep_maxpacket(ep))
+	    || !desc->wMaxPacketSize) {
+
+		DEBUG("%s: bad %s maxpacket\n", __FUNCTION__, _ep->name);
+		return -ERANGE;
+	}
+
+	dev = ep->dev;
+	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
+
+		DEBUG("%s: bogus device state\n", __FUNCTION__);
+		return -ESHUTDOWN;
+	}
+
+	ep->stopped = 0;
+	ep->desc = desc;
+	ep->pio_irqs = 0;
+	ep->ep.maxpacket = le16_to_cpu(desc->wMaxPacketSize);
+
+	/* Reset halt state */
+	s3c_udc_set_halt(_ep, 0);
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+	s3c_udc_ep_activate(ep);
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+
+	DEBUG("%s: enabled %s, stopped = %d, maxpacket = %d\n",
+		__FUNCTION__, _ep->name, ep->stopped, ep->ep.maxpacket);
+	return 0;
+}
+
+/** Disable EP
+ */
+static int s3c_ep_disable(struct usb_ep *_ep)
+{
+	struct s3c_ep *ep;
+	unsigned long flags;
+
+	DEBUG("%s: %p\n", __FUNCTION__, _ep);
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+	if (!_ep || !ep->desc) {
+		DEBUG("%s: %s not enabled\n", __FUNCTION__,
+		      _ep ? ep->ep.name : NULL);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	/* Nuke all pending requests */
+	nuke(ep, -ESHUTDOWN);
+
+	ep->desc = 0;
+	ep->stopped = 1;
+
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+
+	DEBUG("%s: disabled %s\n", __FUNCTION__, _ep->name);
+	return 0;
+}
+
+static struct usb_request *s3c_alloc_request(struct usb_ep *ep,
+						 gfp_t gfp_flags)
+{
+	struct s3c_request *req;
+
+	DEBUG("%s: %s %p\n", __FUNCTION__, ep->name, ep);
+
+	req = kmalloc(sizeof *req, gfp_flags);
+	if (!req)
+		return 0;
+
+	memset(req, 0, sizeof *req);
+	INIT_LIST_HEAD(&req->queue);
+
+	return &req->req;
+}
+
+static void s3c_free_request(struct usb_ep *ep, struct usb_request *_req)
+{
+	struct s3c_request *req;
+
+	DEBUG("%s: %p\n", __FUNCTION__, ep);
+
+	req = container_of(_req, struct s3c_request, req);
+	WARN_ON(!list_empty(&req->queue));
+	kfree(req);
+}
+
+/* dequeue JUST ONE request */
+static int s3c_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct s3c_ep *ep;
+	struct s3c_request *req;
+	unsigned long flags;
+
+	DEBUG("%s: %p\n", __FUNCTION__, _ep);
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+	if (!_ep || ep->ep.name == ep0name)
+		return -EINVAL;
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	/* make sure it's actually queued on this endpoint */
+	list_for_each_entry(req, &ep->queue, queue) {
+		if (&req->req == _req)
+			break;
+	}
+	if (&req->req != _req) {
+		spin_unlock_irqrestore(&ep->dev->lock, flags);
+		return -EINVAL;
+	}
+
+	done(ep, req, -ECONNRESET);
+
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+	return 0;
+}
+
+/** Return bytes in EP FIFO
+ */
+static int s3c_fifo_status(struct usb_ep *_ep)
+{
+	int count = 0;
+	struct s3c_ep *ep;
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+	if (!_ep) {
+		DEBUG("%s: bad ep\n", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	DEBUG("%s: %d\n", __FUNCTION__, ep_index(ep));
+
+	/* LPD can't report unclaimed bytes from IN fifos */
+	if (ep_is_in(ep))
+		return -EOPNOTSUPP;
+
+	return count;
+}
+
+/** Flush EP FIFO
+ */
+static void s3c_fifo_flush(struct usb_ep *_ep)
+{
+	struct s3c_ep *ep;
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) {
+		DEBUG("%s: bad ep\n", __FUNCTION__);
+		return;
+	}
+
+	DEBUG("%s: %d\n", __FUNCTION__, ep_index(ep));
+}
+
+/* ---------------------------------------------------------------------------
+ * 	device-scoped parts of the api to the usb controller hardware
+ * ---------------------------------------------------------------------------
+ */
+
+static int s3c_udc_get_frame(struct usb_gadget *_gadget)
+{
+	/*fram count number [21:8]*/
+	unsigned int frame = readl(S3C_UDC_OTG_DSTS);
+
+	DEBUG("%s: %p\n", __FUNCTION__, _gadget);
+	return (frame & 0x3ff00);
+}
+
+static int s3c_udc_wakeup(struct usb_gadget *_gadget)
+{
+	DEBUG("%s: %p\n", __FUNCTION__, _gadget);
+	return -ENOTSUPP;
+}
+
+static const struct usb_gadget_ops s3c_udc_ops = {
+	.get_frame = s3c_udc_get_frame,
+	.wakeup = s3c_udc_wakeup,
+	/* current versions must always be self-powered */
+};
+
+static void nop_release(struct device *dev)
+{
+	DEBUG("%s %s\n", __FUNCTION__, dev->bus_id);
+}
+
+static struct s3c_udc memory = {
+	.usb_address = 0,
+
+	.gadget = {
+		   .ops = &s3c_udc_ops,
+		   .ep0 = &memory.ep[0].ep,
+		   .name = driver_name,
+		   .dev = {
+			   .bus_id = "gadget",
+			   .release = nop_release,
+			   },
+		   },
+
+	/* control endpoint */
+	.ep[0] = {
+		  .ep = {
+			 .name = ep0name,
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = EP0_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = 0,
+		  .bmAttributes = 0,
+
+		  .ep_type = ep_control,
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP0_FIFO,
+		  },
+
+	/* first group of endpoints */
+	.ep[1] = {
+		  .ep = {
+			 .name = "ep1-bulk",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = EP_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = 1,
+		  .bmAttributes = USB_ENDPOINT_XFER_BULK,
+
+		  .ep_type = ep_bulk_out,
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP1_FIFO,
+		  },
+
+	.ep[2] = {
+		  .ep = {
+			 .name = "ep2-bulk",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = EP_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 2,
+		  .bmAttributes = USB_ENDPOINT_XFER_BULK,
+
+		  .ep_type = ep_bulk_in,
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP2_FIFO,
+		  },
+
+	.ep[3] = {				/* Though NOT USED XXX*/
+		  .ep = {
+			 .name = "ep3-int",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = EP_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 3,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+
+		  .ep_type = ep_interrupt,
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP3_FIFO,
+		  },
+	.ep[4] = {				/* Though NOT USED XXX*/
+		  .ep = {
+			 .name = "ep4-int",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = EP_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 4,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+
+		  .ep_type = ep_interrupt,
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP4_FIFO,
+		  },
+	.ep[5] = {				/* Though NOT USED XXX*/
+		  .ep = {
+			 .name = "ep5-int",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = EP_FIFO_SIZE2,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 5,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+
+		  .ep_type = ep_interrupt,
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP5_FIFO,
+		  },
+	.ep[6] = {				/* Though NOT USED XXX*/
+		  .ep = {
+			 .name = "ep6-int",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = EP_FIFO_SIZE2,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 6,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+
+		  .ep_type = ep_interrupt,
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP6_FIFO,
+		  },
+	.ep[7] = {				/* Though NOT USED XXX*/
+		  .ep = {
+			 .name = "ep7-int",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = EP_FIFO_SIZE2,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 7,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+
+		  .ep_type = ep_interrupt,
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP7_FIFO,
+		  },
+	.ep[8] = {				/* Though NOT USED XXX*/
+		  .ep = {
+			 .name = "ep8-int",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = EP_FIFO_SIZE2,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 8,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+
+		  .ep_type = ep_interrupt,
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP8_FIFO,
+		  },
+};
+
+/*
+ * 	probe - binds to the platform device
+ */
+static struct clk	*otg_clock = NULL;
+
+static int s3c_udc_probe(struct platform_device *pdev)
+{
+	struct s3c_udc *dev = &memory;
+	int retval;
+
+	DEBUG("%s: %p\n", __FUNCTION__, pdev);
+
+	spin_lock_init(&dev->lock);
+	dev->dev = pdev;
+
+	device_initialize(&dev->gadget.dev);
+	dev->gadget.dev.parent = &pdev->dev;
+
+	dev->gadget.is_dualspeed = 1;	/* Hack only*/
+	dev->gadget.is_otg = 0;
+	dev->gadget.is_a_peripheral = 0;
+	dev->gadget.b_hnp_enable = 0;
+	dev->gadget.a_hnp_support = 0;
+	dev->gadget.a_alt_hnp_support = 0;
+
+	the_controller = dev;
+	platform_set_drvdata(pdev, dev);
+
+	otg_clock = clk_get(&pdev->dev, "otg");
+	if (otg_clock == NULL) {
+		printk(KERN_INFO "failed to find otg clock source\n");
+		return -ENOENT;
+	}
+	clk_enable(otg_clock);
+
+	udc_reinit(dev);
+
+	local_irq_disable();
+
+	/* irq setup after old hardware state is cleaned up */
+	retval =
+	    request_irq(IRQ_OTG, s3c_udc_irq, 0, driver_name, dev);
+
+	if (retval != 0) {
+		DEBUG(KERN_ERR "%s: can't get irq %i, err %d\n", driver_name,
+		      IRQ_OTG, retval);
+		return -EBUSY;
+	}
+
+	disable_irq(IRQ_OTG);
+	local_irq_enable();
+	create_proc_files();
+
+	return retval;
+}
+
+static int s3c_udc_remove(struct platform_device *pdev)
+{
+	struct s3c_udc *dev = platform_get_drvdata(pdev);
+
+	DEBUG("%s: %p\n", __FUNCTION__, pdev);
+
+	if (otg_clock != NULL) {
+		clk_disable(otg_clock);
+		clk_put(otg_clock);
+		otg_clock = NULL;
+	}
+
+	remove_proc_files();
+	usb_gadget_unregister_driver(dev->driver);
+
+	free_irq(IRQ_OTG, dev);
+
+	platform_set_drvdata(pdev, 0);
+
+	the_controller = 0;
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int s3c_udc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+        struct s3c_udc *dev = the_controller;
+        int i;
+
+        if (dev->driver) {
+                if (dev->driver->suspend)
+                        dev->driver->suspend(&dev->gadget);
+
+                /* Terminate any outstanding requests  */
+                for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
+                        struct s3c_ep *ep = &dev->ep[i];
+                        if ( ep->dev != NULL )
+                                spin_lock(&ep->dev->lock);
+                        ep->stopped = 1;
+                        nuke(ep, -ESHUTDOWN);
+                        if ( ep->dev != NULL )
+                                spin_unlock(&ep->dev->lock);
+                }
+
+                disable_irq(IRQ_OTG);
+                udc_disable(dev);
+                clk_disable(otg_clock);
+        }
+
+        return 0;
+}
+
+static int s3c_udc_resume(struct platform_device *pdev)
+{
+        struct s3c_udc *dev = the_controller;
+
+        if (dev->driver) {
+                clk_enable(otg_clock);
+                udc_reinit(dev);
+                enable_irq(IRQ_OTG);
+                udc_enable(dev);
+
+                if (dev->driver->resume)
+                        dev->driver->resume(&dev->gadget);
+        }
+
+        return 0;
+}
+#else
+#define s3c_udc_suspend NULL
+#define s3c_udc_resume  NULL
+#endif /* CONFIG_PM */
+
+/*-------------------------------------------------------------------------*/
+static struct platform_driver s3c_udc_driver = {
+	.probe		= s3c_udc_probe,
+	.remove		= s3c_udc_remove,
+	.suspend	= s3c_udc_suspend,
+	.resume		= s3c_udc_resume,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "s3c-usbgadget",
+	},
+};
+
+static int __init udc_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&s3c_udc_driver);
+	if(!ret)
+	   printk("%s : %s\n"
+	   	  "%s : version %s %s \n",
+	   	  driver_name, DRIVER_DESC,
+	   	  driver_name, DRIVER_VERSION, OTG_DMA_MODE? "(DMA Mode)" : "(Slave Mode)");
+
+	return ret;
+}
+
+static void __exit udc_exit(void)
+{
+	platform_driver_unregister(&s3c_udc_driver);
+	printk("Unloaded %s version %s\n", driver_name, DRIVER_VERSION);
+}
+
+module_init(udc_init);
+module_exit(udc_exit);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("Samsung");
+MODULE_LICENSE("GPL");
diff -uraN linux-3.0.8/drivers/usb/gadget/s3c_udc_otg_xfer_dma.c linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/gadget/s3c_udc_otg_xfer_dma.c
--- linux-3.0.8/drivers/usb/gadget/s3c_udc_otg_xfer_dma.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/gadget/s3c_udc_otg_xfer_dma.c	2021-07-13 23:40:34.210359649 +0300
@@ -0,0 +1,1269 @@
+/*
+ * drivers/usb/gadget/s3c_udc_otg_xfer_dma.c
+ * Samsung S3C on-chip full/high speed USB OTG 2.0 device controllers
+ *
+ * Copyright (C) 2009 for Samsung Electronics
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#define GINTMSK_INIT	(INT_OUT_EP|INT_IN_EP|INT_RESUME|INT_ENUMDONE|INT_RESET|INT_SUSPEND)
+#define DOEPMSK_INIT	(CTRL_OUT_EP_SETUP_PHASE_DONE|AHB_ERROR|TRANSFER_DONE)
+#define DIEPMSK_INIT	(NON_ISO_IN_EP_TIMEOUT|AHB_ERROR|TRANSFER_DONE)
+#define GAHBCFG_INIT	(PTXFE_HALF|NPTXFE_HALF|MODE_DMA|BURST_INCR4|GBL_INT_UNMASK)
+
+static u8 clear_feature_num;
+static int clear_feature_flag = 0;
+static int set_conf_done = 0;
+
+/* Bulk-Only Mass Storage Reset (class-specific request) */
+#define GET_MAX_LUN_REQUEST	0xFE
+#define BOT_RESET_REQUEST	0xFF
+
+void s3c_udc_ep_set_stall(struct s3c_ep *ep);
+
+static inline void s3c_udc_ep0_zlp(void)
+{
+	u32 ep_ctrl;
+	
+	writel(virt_to_phys(&usb_ctrl), S3C_UDC_OTG_DIEPDMA(EP0_CON));
+	writel((1<<19| 0<<0), S3C_UDC_OTG_DIEPTSIZ(EP0_CON));
+
+	ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL(EP0_CON));
+	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK, S3C_UDC_OTG_DIEPCTL(EP0_CON));
+
+	DEBUG_EP0("%s:EP0 ZLP DIEPCTL0 = 0x%x\n",
+		__func__, readl(S3C_UDC_OTG_DIEPCTL(EP0_CON)));
+}
+
+static inline void s3c_udc_pre_setup(void)
+{
+	u32 ep_ctrl;
+
+	DEBUG_IN_EP("%s : Prepare Setup packets.\n", __func__);
+
+	writel((1 << 19)|sizeof(struct usb_ctrlrequest), S3C_UDC_OTG_DOEPTSIZ(EP0_CON));
+	writel(virt_to_phys(&usb_ctrl), S3C_UDC_OTG_DOEPDMA(EP0_CON));
+
+	ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL(EP0_CON));
+	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL(EP0_CON));
+}
+
+static int setdma_rx(struct s3c_ep *ep, struct s3c_request *req)
+{
+	u32 *buf, ctrl;
+	u32 length, pktcnt;
+	u32 ep_num = ep_index(ep);
+
+	buf = req->req.buf + req->req.actual;
+	prefetchw(buf);
+
+	length = req->req.length - req->req.actual;
+	dma_cache_maint(buf, length, DMA_FROM_DEVICE);
+
+	if(length == 0)
+		pktcnt = 1;
+	else
+		pktcnt = (length - 1)/(ep->ep.maxpacket) + 1;
+
+	ctrl =  readl(S3C_UDC_OTG_DOEPCTL(ep_num));
+
+	writel(virt_to_phys(buf), S3C_UDC_OTG_DOEPDMA(ep_num));
+	writel((pktcnt<<19)|(length<<0), S3C_UDC_OTG_DOEPTSIZ(ep_num));
+	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, S3C_UDC_OTG_DOEPCTL(ep_num));
+
+	DEBUG_OUT_EP("%s: EP%d RX DMA start : DOEPDMA = 0x%x, DOEPTSIZ = 0x%x, DOEPCTL = 0x%x\n"
+			"\tbuf = 0x%p, pktcnt = %d, xfersize = %d\n",
+			__func__, ep_num,
+			readl(S3C_UDC_OTG_DOEPDMA(ep_num)),
+			readl(S3C_UDC_OTG_DOEPTSIZ(ep_num)),
+			readl(S3C_UDC_OTG_DOEPCTL(ep_num)),
+			buf, pktcnt, length);
+	return 0;
+
+}
+
+static int setdma_tx(struct s3c_ep *ep, struct s3c_request *req)
+{
+	u32 *buf, ctrl = 0;
+	u32 length, pktcnt;
+	u32 ep_num = ep_index(ep);
+
+	buf = req->req.buf + req->req.actual;
+	prefetch(buf);
+	length = req->req.length - req->req.actual;
+
+	if(ep_num == EP0_CON) {
+		length = min(length, (u32)ep_maxpacket(ep));
+	}
+
+	req->req.actual += length;
+	dma_cache_maint(buf, length, DMA_TO_DEVICE);
+
+	if(length == 0) {
+		pktcnt = 1;
+	} else {
+		pktcnt = (length - 1)/(ep->ep.maxpacket) + 1;
+	}
+
+	ctrl = readl(S3C_UDC_OTG_DIEPCTL(ep_num));
+
+	writel(virt_to_phys(buf), S3C_UDC_OTG_DIEPDMA(ep_num));
+	writel((pktcnt<<19)|(length<<0), S3C_UDC_OTG_DIEPTSIZ(ep_num));
+	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, S3C_UDC_OTG_DIEPCTL(ep_num));
+
+	ctrl = readl(S3C_UDC_OTG_DIEPCTL(EP0_CON));
+	ctrl = (ctrl&~(EP_MASK<<DEPCTL_NEXT_EP_BIT))|(ep_num<<DEPCTL_NEXT_EP_BIT);
+	writel(ctrl, S3C_UDC_OTG_DIEPCTL(EP0_CON));
+
+	DEBUG_IN_EP("%s:EP%d TX DMA start : DIEPDMA0 = 0x%x, DIEPTSIZ0 = 0x%x, DIEPCTL0 = 0x%x\n"
+			"\tbuf = 0x%p, pktcnt = %d, xfersize = %d\n",
+			__func__, ep_num,
+			readl(S3C_UDC_OTG_DIEPDMA(ep_num)),
+			readl(S3C_UDC_OTG_DIEPTSIZ(ep_num)),
+			readl(S3C_UDC_OTG_DIEPCTL(ep_num)),
+			buf, pktcnt, length);
+
+	return length;
+}
+
+static void complete_rx(struct s3c_udc *dev, u8 ep_num)
+{
+	struct s3c_ep *ep = &dev->ep[ep_num];
+	struct s3c_request *req = NULL;
+	u32 ep_tsr = 0, xfer_size = 0, xfer_length, is_short = 0;
+
+	if (list_empty(&ep->queue)) {
+		DEBUG_OUT_EP("%s: RX DMA done : NULL REQ on OUT EP-%d\n",
+					__func__, ep_num);
+		return;
+
+	}
+
+	req = list_entry(ep->queue.next, struct s3c_request, queue);
+
+	ep_tsr = readl(S3C_UDC_OTG_DOEPTSIZ(ep_num));
+
+	if(ep_num == EP0_CON) {
+		xfer_size = (ep_tsr & 0x7f);
+
+	} else {
+		xfer_size = (ep_tsr & 0x7fff);
+	}
+
+	dma_cache_maint(req->req.buf, req->req.length, DMA_FROM_DEVICE);
+	xfer_length = req->req.length - xfer_size;
+	req->req.actual += min(xfer_length, req->req.length - req->req.actual);
+	is_short = (xfer_length < ep->ep.maxpacket);
+
+	DEBUG_OUT_EP("%s: RX DMA done : ep = %d, rx bytes = %d/%d, "
+		     "is_short = %d, DOEPTSIZ = 0x%x, remained bytes = %d\n",
+			__func__, ep_num, req->req.actual, req->req.length,
+			is_short, ep_tsr, xfer_size);
+
+	if (is_short || req->req.actual == xfer_length) {
+		if(ep_num == EP0_CON && dev->ep0state == DATA_STATE_RECV) {
+			DEBUG_OUT_EP("	=> Send ZLP\n");
+			dev->ep0state = WAIT_FOR_SETUP;
+			s3c_udc_ep0_zlp();
+
+		} else {
+			done(ep, req, 0);
+
+			if(!list_empty(&ep->queue)) {
+				req = list_entry(ep->queue.next, struct s3c_request, queue);
+				DEBUG_OUT_EP("%s: Next Rx request start...\n", __func__);
+				setdma_rx(ep, req);
+			}
+		}
+	}
+}
+
+static void complete_tx(struct s3c_udc *dev, u8 ep_num)
+{
+	struct s3c_ep *ep = &dev->ep[ep_num];
+	struct s3c_request *req;
+	u32 ep_tsr = 0, xfer_size = 0, xfer_length, is_short = 0;
+	u32 last;
+
+	if (list_empty(&ep->queue)) {
+		DEBUG_IN_EP("%s: TX DMA done : NULL REQ on IN EP-%d\n",
+					__func__, ep_num);
+		return;
+
+	}
+
+	req = list_entry(ep->queue.next, struct s3c_request, queue);
+
+	if(dev->ep0state == DATA_STATE_XMIT) {
+		DEBUG_IN_EP("%s: ep_num = %d, ep0stat == DATA_STATE_XMIT\n",
+					__func__, ep_num);
+
+		last = write_fifo_ep0(ep, req);
+
+		if(last) {
+			dev->ep0state = WAIT_FOR_SETUP;
+		}
+
+		return;
+	}
+
+	ep_tsr = readl(S3C_UDC_OTG_DIEPTSIZ(ep_num));
+
+	if(ep_num == EP0_CON) {
+		xfer_size = (ep_tsr & 0x7f);
+
+	} else {
+		xfer_size = (ep_tsr & 0x7fff);
+	}
+
+	req->req.actual = req->req.length - xfer_size;
+	xfer_length = req->req.length - xfer_size;
+	req->req.actual += min(xfer_length, req->req.length - req->req.actual);
+	is_short = (xfer_length < ep->ep.maxpacket);
+
+	DEBUG_IN_EP("%s: TX DMA done : ep = %d, tx bytes = %d/%d, "
+		     "is_short = %d, DIEPTSIZ = 0x%x, remained bytes = %d\n",
+			__func__, ep_num, req->req.actual, req->req.length,
+			is_short, ep_tsr, xfer_size);
+
+	if (req->req.actual == req->req.length) {
+		done(ep, req, 0);
+
+		if(!list_empty(&ep->queue)) {
+			req = list_entry(ep->queue.next, struct s3c_request, queue);
+			DEBUG_IN_EP("%s: Next Tx request start...\n", __func__);
+			setdma_tx(ep, req);
+		}
+	}
+}
+static inline void s3c_udc_check_tx_queue(struct s3c_udc *dev, u8 ep_num)
+{
+	struct s3c_ep *ep = &dev->ep[ep_num];
+	struct s3c_request *req;
+
+	DEBUG_IN_EP("%s: Check queue, ep_num = %d\n", __func__, ep_num);
+
+	if (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next, struct s3c_request, queue);
+		DEBUG_IN_EP("%s: Next Tx request(0x%p) start...\n", __func__, req);
+
+		if (ep_is_in(ep))
+			setdma_tx(ep, req);
+		else
+			setdma_rx(ep, req);
+	} else {
+		DEBUG_IN_EP("%s: NULL REQ on IN EP-%d\n", __func__, ep_num);
+
+		return;
+	}
+
+}
+
+static void process_ep_in_intr(struct s3c_udc *dev)
+{
+	u32 ep_intr, ep_intr_status;
+	u8 ep_num = 0;
+
+	ep_intr = readl(S3C_UDC_OTG_DAINT);
+	DEBUG_IN_EP("*** %s: EP In interrupt : DAINT = 0x%x\n",
+				__func__, ep_intr);
+
+	ep_intr &= DAINT_MASK;
+
+	while(ep_intr) {
+		if (ep_intr & 0x1) {
+			ep_intr_status = readl(S3C_UDC_OTG_DIEPINT(ep_num));
+			DEBUG_IN_EP("\tEP%d-IN : DIEPINT = 0x%x\n",
+						ep_num, ep_intr_status);
+
+			/* Interrupt Clear */
+			writel(ep_intr_status, S3C_UDC_OTG_DIEPINT(ep_num));
+
+			if (ep_intr_status & TRANSFER_DONE) {
+				complete_tx(dev, ep_num);
+
+				if (ep_num == 0) {
+					if(dev->ep0state == WAIT_FOR_SETUP) {
+						s3c_udc_pre_setup();
+					}
+
+					/* continue transfer after set_clear_halt for DMA mode */
+					if (clear_feature_flag == 1) {
+						s3c_udc_check_tx_queue(dev, clear_feature_num);
+						clear_feature_flag = 0;
+					}
+				}
+			}
+		}
+		ep_num++;
+		ep_intr >>= 1;
+	}
+
+}
+
+static void process_ep_out_intr(struct s3c_udc * dev)
+{
+	u32 ep_intr, ep_intr_status;
+	u8 ep_num = 0;
+
+	ep_intr = readl(S3C_UDC_OTG_DAINT);
+	DEBUG_OUT_EP("*** %s: EP OUT interrupt : DAINT = 0x%x\n",
+				__func__, ep_intr);
+
+	ep_intr = (ep_intr >> DAINT_OUT_BIT) & DAINT_MASK;
+
+	while(ep_intr) {
+		if (ep_intr & 0x1) {
+			ep_intr_status = readl(S3C_UDC_OTG_DOEPINT(ep_num));
+			DEBUG_OUT_EP("\tEP%d-OUT : DOEPINT = 0x%x\n",
+						ep_num, ep_intr_status);
+
+			/* Interrupt Clear */
+			writel(ep_intr_status, S3C_UDC_OTG_DOEPINT(ep_num));
+
+			if (ep_num == 0 ) {
+				if (ep_intr_status & CTRL_OUT_EP_SETUP_PHASE_DONE) {
+					DEBUG_OUT_EP("\tSETUP packet(transaction) arrived\n");
+					s3c_handle_ep0(dev);
+				}
+
+				if (ep_intr_status & TRANSFER_DONE) {
+					complete_rx(dev, ep_num);
+					s3c_udc_pre_setup();
+				}
+
+			} else {
+				if (ep_intr_status & TRANSFER_DONE) {
+					complete_rx(dev, ep_num);
+				}
+			}
+		}
+		ep_num++;
+		ep_intr >>= 1;
+	}
+}
+
+/*
+ *	usb client interrupt handler.
+ */
+static irqreturn_t s3c_udc_irq(int irq, void *_dev)
+{
+	struct s3c_udc *dev = _dev;
+	u32 intr_status;
+	u32 usb_status, gintmsk;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	intr_status = readl(S3C_UDC_OTG_GINTSTS);
+	gintmsk = readl(S3C_UDC_OTG_GINTMSK);
+
+	DEBUG_ISR("\n*** %s : GINTSTS=0x%x(on state %s), GINTMSK : 0x%x, DAINT : 0x%x, DAINTMSK : 0x%x\n",
+			__func__, intr_status, state_names[dev->ep0state], gintmsk,
+			readl(S3C_UDC_OTG_DAINT), readl(S3C_UDC_OTG_DAINTMSK));
+
+	if (!intr_status) {
+		spin_unlock_irqrestore(&dev->lock, flags);
+		return IRQ_HANDLED;
+	}
+
+	if (intr_status & INT_ENUMDONE) {
+		DEBUG_ISR("\tSpeed Detection interrupt\n");
+
+		writel(INT_ENUMDONE, S3C_UDC_OTG_GINTSTS);
+		usb_status = (readl(S3C_UDC_OTG_DSTS) & 0x6);
+
+		if (usb_status & (USB_FULL_30_60MHZ | USB_FULL_48MHZ)) {
+			DEBUG_ISR("\t\tFull Speed Detection\n");
+			set_max_pktsize(dev, USB_SPEED_FULL);
+
+		} else {
+			DEBUG_ISR("\t\tHigh Speed Detection : 0x%x\n", usb_status);
+			set_max_pktsize(dev, USB_SPEED_HIGH);
+		}
+	}
+
+	if (intr_status & INT_EARLY_SUSPEND) {
+		DEBUG_ISR("\tEarly suspend interrupt\n");
+		writel(INT_EARLY_SUSPEND, S3C_UDC_OTG_GINTSTS);
+	}
+
+	if (intr_status & INT_SUSPEND) {
+		usb_status = readl(S3C_UDC_OTG_DSTS);
+		DEBUG_ISR("\tSuspend interrupt :(DSTS):0x%x\n", usb_status);
+		writel(INT_SUSPEND, S3C_UDC_OTG_GINTSTS);
+
+		if (dev->gadget.speed != USB_SPEED_UNKNOWN
+		    && dev->driver
+		    && dev->driver->suspend) {
+
+			dev->driver->suspend(&dev->gadget);
+		}
+	}
+
+	if (intr_status & INT_RESUME) {
+		DEBUG_ISR("\tResume interrupt\n");
+		writel(INT_RESUME, S3C_UDC_OTG_GINTSTS);
+
+		if (dev->gadget.speed != USB_SPEED_UNKNOWN
+		    && dev->driver
+		    && dev->driver->resume) {
+
+			dev->driver->resume(&dev->gadget);
+		}
+	}
+
+	if (intr_status & INT_RESET) {
+		usb_status = readl(S3C_UDC_OTG_GOTGCTL);
+		DEBUG_ISR("\tReset interrupt - (GOTGCTL):0x%x\n", usb_status);
+		writel(INT_RESET, S3C_UDC_OTG_GINTSTS);
+
+		set_conf_done = 0;
+		
+		if((usb_status & 0xc0000) == (0x3 << 18)) {
+			if(reset_available) {
+				DEBUG_ISR("\t\tOTG core got reset (%d)!! \n", reset_available);
+				reconfig_usbd();
+				dev->ep0state = WAIT_FOR_SETUP;
+				reset_available = 0;
+				s3c_udc_pre_setup();
+			}
+
+		} else {
+			reset_available = 1;
+			DEBUG_ISR("\t\tRESET handling skipped\n");
+		}
+	}
+
+	if (intr_status & INT_IN_EP) {
+		process_ep_in_intr(dev);
+	}
+
+	if(intr_status & INT_OUT_EP) {
+		process_ep_out_intr(dev);
+	}
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+/** Queue one request
+ *  Kickstart transfer if needed
+ */
+static int s3c_queue(struct usb_ep *_ep, struct usb_request *_req,
+			 gfp_t gfp_flags)
+{
+	struct s3c_request *req;
+	struct s3c_ep *ep;
+	struct s3c_udc *dev;
+	unsigned long flags;
+	u32 ep_num, gintsts;
+
+	req = container_of(_req, struct s3c_request, req);
+	if (unlikely(!_req || !_req->complete || !_req->buf || !list_empty(&req->queue))) {
+
+		DEBUG("%s: bad params\n", __func__);
+		return -EINVAL;
+	}
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+
+	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) {
+
+		DEBUG("%s: bad ep\n", __func__);
+		return -EINVAL;
+	}
+
+	ep_num = ep_index(ep);
+	dev = ep->dev;
+	if (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {
+
+		DEBUG("%s: bogus device state %p\n", __func__, dev->driver);
+		return -ESHUTDOWN;
+	}
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+
+	/* kickstart this i/o queue? */
+	DEBUG("\n*** %s: %s-%s req = %p, len = %d, buf = %p"
+		"Q empty = %d, stopped = %d\n",
+		__func__,_ep->name, ep_is_in(ep)? "in" : "out",
+		_req, _req->length,_req->buf,
+		list_empty(&ep->queue), ep->stopped);
+
+	if (list_empty(&ep->queue) && !ep->stopped) {
+
+		if (ep_num == 0) {
+			/* EP0 */
+			list_add_tail(&req->queue, &ep->queue);
+			s3c_ep0_kick(dev, ep);
+			req = 0;
+
+		} else if (ep_is_in(ep)) {
+			gintsts = readl(S3C_UDC_OTG_GINTSTS);
+			DEBUG_IN_EP("%s: ep_is_in, S3C_UDC_OTG_GINTSTS=0x%x\n",
+						__func__, gintsts);
+
+			if (set_conf_done == 1) {
+				setdma_tx(ep, req);
+			} else {
+				done(ep, req, 0);
+				DEBUG("%s: Not yet Set_configureation, ep_num = %d, req = %p\n",
+						__func__, ep_num, req);
+				req = 0;
+			}
+
+		} else {
+			gintsts = readl(S3C_UDC_OTG_GINTSTS);
+			DEBUG_OUT_EP("%s: ep_is_out, S3C_UDC_OTG_GINTSTS=0x%x\n",
+				__func__, gintsts);
+
+			setdma_rx(ep, req);
+		}
+	}
+
+	/* pio or dma irq handler advances the queue. */
+	if (likely(req != 0)) {
+		list_add_tail(&req->queue, &ep->queue);
+	}
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return 0;
+}
+
+/****************************************************************/
+/* End Point 0 related functions                                */
+/****************************************************************/
+
+/* return:  0 = still running, 1 = completed, negative = errno */
+static int write_fifo_ep0(struct s3c_ep *ep, struct s3c_request *req)
+{
+	u32 max;
+	unsigned count;
+	int is_last;
+
+	max = ep_maxpacket(ep);
+
+	DEBUG_EP0("%s: max = %d\n", __func__, max);
+
+	count = setdma_tx(ep, req);
+
+	/* last packet is usually short (or a zlp) */
+	if (likely(count != max))
+		is_last = 1;
+	else {
+		if (likely(req->req.length != req->req.actual) || req->req.zero)
+			is_last = 0;
+		else
+			is_last = 1;
+	}
+
+	DEBUG_EP0("%s: wrote %s %d bytes%s %d left %p\n", __func__,
+		  ep->ep.name, count,
+		  is_last ? "/L" : "", req->req.length - req->req.actual, req);
+
+	/* requests complete when all IN data is in the FIFO */
+	if (is_last) {
+		ep->dev->ep0state = WAIT_FOR_SETUP;
+		return 1;
+	}
+
+	return 0;
+}
+
+static __inline__ int s3c_fifo_read(struct s3c_ep *ep, u32 *cp, int max)
+{
+	u32 bytes;
+
+	bytes = sizeof(struct usb_ctrlrequest);
+	dma_cache_maint(&usb_ctrl, bytes, DMA_FROM_DEVICE);
+	DEBUG_EP0("%s: bytes=%d, ep_index=%d \n", __func__, bytes, ep_index(ep));
+
+	return bytes;
+}
+
+/**
+ * udc_set_address - set the USB address for this device
+ * @address:
+ *
+ * Called from control endpoint function
+ * after it decodes a set address setup packet.
+ */
+static void udc_set_address(struct s3c_udc *dev, unsigned char address)
+{
+	u32 ctrl = readl(S3C_UDC_OTG_DCFG);
+	writel(address << 4 | ctrl, S3C_UDC_OTG_DCFG);
+
+	s3c_udc_ep0_zlp();
+
+	DEBUG_EP0("%s: USB OTG 2.0 Device address=%d, DCFG=0x%x\n",
+		__func__, address, readl(S3C_UDC_OTG_DCFG));
+
+	dev->usb_address = address;
+}
+
+static inline void s3c_udc_ep0_set_stall(struct s3c_ep *ep) 
+{
+	struct s3c_udc *dev;
+	u32		ep_ctrl = 0;
+
+	dev = ep->dev;
+	ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL(EP0_CON));
+
+	/* set the disable and stall bits */
+	if (ep_ctrl & DEPCTL_EPENA) {
+		ep_ctrl |= DEPCTL_EPDIS;
+	}
+	ep_ctrl |= DEPCTL_STALL;
+
+	writel(ep_ctrl, S3C_UDC_OTG_DIEPCTL(EP0_CON));
+
+	DEBUG_EP0("%s: set ep%d stall, DIEPCTL0 = 0x%x\n",
+		__func__, ep_index(ep), readl(S3C_UDC_OTG_DIEPCTL(EP0_CON)));
+	/* 
+	 * The application can only set this bit, and the core clears it,
+	 * when a SETUP token is received for this endpoint
+	 */
+	dev->ep0state = WAIT_FOR_SETUP;
+
+	s3c_udc_pre_setup();
+}
+
+static void s3c_ep0_read(struct s3c_udc *dev)
+{
+	struct s3c_request *req;
+	struct s3c_ep *ep = &dev->ep[0];
+	int ret;
+
+	if (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next, struct s3c_request, queue);
+
+	} else {
+		DEBUG("%s: ---> BUG\n", __func__);
+		BUG();
+		return;
+	}
+
+	DEBUG_EP0("%s: req = %p, req.length = 0x%x, req.actual = 0x%x\n",
+		__func__, req, req->req.length, req->req.actual);
+
+	if(req->req.length == 0) {
+		/* zlp for Set_configuration, Set_interface,
+		 * or Bulk-Only mass storge reset */
+
+		dev->ep0state = WAIT_FOR_SETUP;
+		set_conf_done = 1;
+		s3c_udc_ep0_zlp();
+		done(ep, req, 0);
+
+		DEBUG_EP0("%s: req.length = 0, bRequest = %d\n", __func__, usb_ctrl.bRequest);
+		return;
+	}
+
+	ret = setdma_rx(ep, req);
+}
+
+/*
+ * DATA_STATE_XMIT
+ */
+static int s3c_ep0_write(struct s3c_udc *dev)
+{
+	struct s3c_request *req;
+	struct s3c_ep *ep = &dev->ep[0];
+	int ret, need_zlp = 0;
+
+	if (list_empty(&ep->queue)) {
+		req = 0;
+
+	} else {
+		req = list_entry(ep->queue.next, struct s3c_request, queue);
+	}
+
+	if (!req) {
+		DEBUG_EP0("%s: NULL REQ\n", __func__);
+		return 0;
+	}
+
+	DEBUG_EP0("%s: req = %p, req.length = 0x%x, req.actual = 0x%x\n",
+		__func__, req, req->req.length, req->req.actual);
+
+	if (req->req.length - req->req.actual == ep0_fifo_size) {
+		/* Next write will end with the packet size, */
+		/* so we need Zero-length-packet */
+		need_zlp = 1;
+	}
+
+	ret = write_fifo_ep0(ep, req);
+
+	if ((ret == 1) && !need_zlp) {
+		/* Last packet */
+		dev->ep0state = WAIT_FOR_SETUP;
+		DEBUG_EP0("%s: finished, waiting for status\n", __func__);
+
+	} else {
+		dev->ep0state = DATA_STATE_XMIT;
+		DEBUG_EP0("%s: not finished\n", __func__);
+	}
+
+	if (need_zlp) {
+		dev->ep0state = DATA_STATE_NEED_ZLP;
+		DEBUG_EP0("%s: Need ZLP!\n", __func__);
+	}
+
+	return 1;
+}
+
+u16	g_status;
+
+static int s3c_udc_get_status(struct s3c_udc *dev,
+		struct usb_ctrlrequest *crq)
+{
+	u8 ep_num = crq->wIndex & 0x7F;
+	u32 ep_ctrl;
+
+	DEBUG_SETUP("%s: *** USB_REQ_GET_STATUS  \n",__func__);
+
+	switch (crq->bRequestType & USB_RECIP_MASK) {
+	case USB_RECIP_INTERFACE:
+		g_status = 0;
+		DEBUG_SETUP("\tGET_STATUS: USB_RECIP_INTERFACE, g_stauts = %d\n", g_status);
+		break;
+
+	case USB_RECIP_DEVICE:
+		g_status = 0x1; /* Self powered */
+		DEBUG_SETUP("\tGET_STATUS: USB_RECIP_DEVICE, g_stauts = %d\n", g_status);
+		break;
+
+	case USB_RECIP_ENDPOINT:
+		if (ep_num > 4 || crq->wLength > 2) {
+			DEBUG_SETUP("\tGET_STATUS: Not support EP or wLength\n");
+			return 1;
+		}
+
+		g_status = dev->ep[ep_num].stopped;
+		DEBUG_SETUP("\tGET_STATUS: USB_RECIP_ENDPOINT, g_stauts = %d\n", g_status);
+
+		break;
+
+	default:
+		return 1;
+	}
+
+	dma_cache_maint(&g_status, 2, DMA_TO_DEVICE);
+
+	writel(virt_to_phys(&g_status), S3C_UDC_OTG_DIEPDMA(EP0_CON));
+	writel((1<<19)|(2<<0), S3C_UDC_OTG_DIEPTSIZ(EP0_CON));
+
+	ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL(EP0_CON));
+	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK, S3C_UDC_OTG_DIEPCTL(EP0_CON));
+	dev->ep0state = WAIT_FOR_SETUP;
+
+	return 0;
+}
+
+void s3c_udc_ep_set_stall(struct s3c_ep *ep)
+{
+	u8		ep_num;
+	u32		ep_ctrl = 0;
+
+	ep_num = ep_index(ep);
+	DEBUG("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);
+		
+	if (ep_is_in(ep)) {
+		ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL(ep_num));
+	
+		/* set the disable and stall bits */
+		if (ep_ctrl & DEPCTL_EPENA) {
+			ep_ctrl |= DEPCTL_EPDIS;
+		}
+		ep_ctrl |= DEPCTL_STALL;
+
+		writel(ep_ctrl, S3C_UDC_OTG_DIEPCTL(ep_num));
+		DEBUG("%s: set stall, DIEPCTL%d = 0x%x\n",
+			__func__, ep_num, readl(S3C_UDC_OTG_DIEPCTL(ep_num)));
+
+	} else {
+		ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL(ep_num));
+
+		/* set the stall bit */
+		ep_ctrl |= DEPCTL_STALL;
+		ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL(ep_num));
+
+		writel(ep_ctrl, S3C_UDC_OTG_DOEPCTL(ep_num));
+		DEBUG("%s: set stall, DOEPCTL%d = 0x%x\n",
+			__func__, ep_num, readl(S3C_UDC_OTG_DOEPCTL(ep_num)));
+	}
+		
+	return;
+}
+
+void s3c_udc_ep_clear_stall(struct s3c_ep *ep)
+{
+	u8		ep_num;
+	u32		ep_ctrl = 0;
+
+	ep_num = ep_index(ep);	
+	DEBUG("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);
+
+	if (ep_is_in(ep)) {
+		ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL(ep_num));
+
+		/* clear stall bit */
+		ep_ctrl &= ~DEPCTL_STALL;
+
+		/* 
+		 * USB Spec 9.4.5: For endpoints using data toggle, regardless
+		 * of whether an endpoint has the Halt feature set, a
+		 * ClearFeature(ENDPOINT_HALT) request always results in the
+		 * data toggle being reinitialized to DATA0.
+		 */
+		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
+		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
+			ep_ctrl |= DEPCTL_SETD0PID; /* DATA0 */
+		}
+
+		writel(ep_ctrl, S3C_UDC_OTG_DIEPCTL(ep_num));
+		DEBUG("%s: cleared stall, DIEPCTL%d = 0x%x\n",
+			__func__, ep_num, readl(S3C_UDC_OTG_DIEPCTL(ep_num)));
+
+	} else {
+		ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL(ep_num));
+
+		/* clear stall bit */
+		ep_ctrl &= ~DEPCTL_STALL;
+
+		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
+		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
+			ep_ctrl |= DEPCTL_SETD0PID; /* DATA0 */
+		}
+
+		writel(ep_ctrl, S3C_UDC_OTG_DOEPCTL(ep_num));
+		DEBUG("%s: cleared stall, DOEPCTL%d = 0x%x\n",
+			__func__, ep_num, readl(S3C_UDC_OTG_DOEPCTL(ep_num)));
+	}
+
+	return;
+}
+
+static int s3c_udc_set_halt(struct usb_ep *_ep, int value)
+{
+	struct s3c_ep	*ep;
+	struct s3c_udc	*dev;
+	unsigned long	flags;
+	u8		ep_num;
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+
+	if (unlikely (!_ep || (!ep->desc && ep->ep.name != ep0name) ||
+			ep->desc->bmAttributes == USB_ENDPOINT_XFER_ISOC)) {
+		DEBUG("%s: %s bad ep or descriptor\n", __func__, ep->ep.name);
+		return -EINVAL;
+	}
+
+	/* Attempt to halt IN ep will fail if any transfer requests
+	 * are still queue */
+	if (value && ep_is_in(ep) && !list_empty(&ep->queue)) {
+		DEBUG("%s: %s queue not empty, req = %p\n",
+			__func__, ep->ep.name,
+			list_entry(ep->queue.next, struct s3c_request, queue));
+
+		return -EAGAIN;
+	}
+
+	dev = ep->dev;
+	ep_num = ep_index(ep);
+	DEBUG("%s: ep_num = %d, value = %d\n", __func__, ep_num, value);
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	if (value == 0) {
+		ep->stopped = 0;
+		s3c_udc_ep_clear_stall(ep);
+	} else {
+		if (ep_num == 0) {
+			dev->ep0state = WAIT_FOR_SETUP;
+		}
+		
+		ep->stopped = 1;
+		s3c_udc_ep_set_stall(ep);
+	}
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return 0;
+}
+
+void s3c_udc_ep_activate(struct s3c_ep *ep)
+{
+	u8 ep_num;
+	u32 ep_ctrl = 0, daintmsk = 0;
+	
+	ep_num = ep_index(ep);
+
+	/* Read DEPCTLn register */
+	if (ep_is_in(ep)) {
+		ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL(ep_num));
+		daintmsk = 1 << ep_num;
+	} else {
+		ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL(ep_num));
+		daintmsk = (1 << ep_num) << DAINT_OUT_BIT;
+	}
+
+	DEBUG("%s: EPCTRL%d = 0x%x, ep_is_in = %d\n",
+		__func__, ep_num, ep_ctrl, ep_is_in(ep));
+		
+	/* If the EP is already active don't change the EP Control
+	 * register. */
+	if (!(ep_ctrl & DEPCTL_USBACTEP)) {
+		ep_ctrl = (ep_ctrl & ~DEPCTL_TYPE_MASK)| (ep->bmAttributes << DEPCTL_TYPE_BIT);
+		ep_ctrl = (ep_ctrl & ~DEPCTL_MPS_MASK) | (ep->ep.maxpacket << DEPCTL_MPS_BIT);
+		ep_ctrl |= (DEPCTL_SETD0PID | DEPCTL_USBACTEP);
+
+		if (ep_is_in(ep)) {
+			writel(ep_ctrl, S3C_UDC_OTG_DIEPCTL(ep_num));
+			DEBUG("%s: USB Ative EP%d, DIEPCTRL%d = 0x%x\n",
+				__func__, ep_num, ep_num, readl(S3C_UDC_OTG_DIEPCTL(ep_num)));
+		} else {
+			writel(ep_ctrl, S3C_UDC_OTG_DOEPCTL(ep_num));
+			DEBUG("%s: USB Ative EP%d, DOEPCTRL%d = 0x%x\n",
+				__func__, ep_num, ep_num, readl(S3C_UDC_OTG_DOEPCTL(ep_num)));
+		}
+	}
+
+	/* Unmask EP Interrtupt */
+	writel(readl(S3C_UDC_OTG_DAINTMSK)|daintmsk, S3C_UDC_OTG_DAINTMSK);
+	DEBUG("%s: DAINTMSK = 0x%x\n", __func__, readl(S3C_UDC_OTG_DAINTMSK));
+
+}
+
+static int s3c_udc_clear_feature(struct usb_ep *_ep)
+{
+	struct s3c_ep	*ep;
+	u8		ep_num;
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+	ep_num = ep_index(ep);
+
+	DEBUG_SETUP("%s: ep_num = %d, is_in = %d, clear_feature_flag = %d\n",
+		__func__, ep_num, ep_is_in(ep), clear_feature_flag);
+
+	if (usb_ctrl.wLength != 0) {
+		DEBUG_SETUP("\tCLEAR_FEATURE: wLength is not zero.....\n");
+		return 1;
+	}
+
+	switch (usb_ctrl.bRequestType & USB_RECIP_MASK) {
+	case USB_RECIP_DEVICE:
+		switch (usb_ctrl.wValue) {
+		case USB_DEVICE_REMOTE_WAKEUP:
+			DEBUG_SETUP("\tCLEAR_FEATURE: USB_DEVICE_REMOTE_WAKEUP\n");
+			break;
+
+		case USB_DEVICE_TEST_MODE:
+			DEBUG_SETUP("\tCLEAR_FEATURE: USB_DEVICE_TEST_MODE\n");
+			/** @todo Add CLEAR_FEATURE for TEST modes. */
+			break;
+		}
+
+		s3c_udc_ep0_zlp();
+		break;
+
+	case USB_RECIP_ENDPOINT:
+		DEBUG_SETUP("\tCLEAR_FEATURE: USB_RECIP_ENDPOINT, wValue = %d\n",
+				usb_ctrl.wValue);
+
+		if (usb_ctrl.wValue == USB_ENDPOINT_HALT) {
+			if (ep == 0) {
+				s3c_udc_ep0_set_stall(ep);
+				return 0;
+			} 
+
+			s3c_udc_ep0_zlp();
+
+			s3c_udc_ep_clear_stall(ep);
+			s3c_udc_ep_activate(ep);
+			ep->stopped = 0;
+
+			clear_feature_num = ep_num;
+			clear_feature_flag = 1;
+		}
+		break;
+	}
+
+	return 0;
+}
+
+static int s3c_udc_set_feature(struct usb_ep *_ep)
+{
+	struct s3c_ep	*ep;
+	u8		ep_num;
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+	ep_num = ep_index(ep);
+
+	DEBUG_SETUP("%s: *** USB_REQ_SET_FEATURE , ep_num = %d\n",__func__, ep_num);
+
+	if (usb_ctrl.wLength != 0) {
+		DEBUG_SETUP("\tSET_FEATURE: wLength is not zero.....\n");
+		return 1;
+	}
+
+	switch (usb_ctrl.bRequestType & USB_RECIP_MASK) {
+	case USB_RECIP_DEVICE:
+		switch (usb_ctrl.wValue) {
+		case USB_DEVICE_REMOTE_WAKEUP:
+			DEBUG_SETUP("\tSET_FEATURE: USB_DEVICE_REMOTE_WAKEUP\n");
+			break;
+
+		case USB_DEVICE_TEST_MODE:
+			DEBUG_SETUP("\tSET_FEATURE: USB_DEVICE_TEST_MODE\n");
+			break;
+
+		case USB_DEVICE_B_HNP_ENABLE:
+			DEBUG_SETUP("\tSET_FEATURE: USB_DEVICE_B_HNP_ENABLE\n");
+			break;
+
+		case USB_DEVICE_A_HNP_SUPPORT:
+			/* RH port supports HNP */
+			DEBUG_SETUP("\tSET_FEATURE: USB_DEVICE_A_HNP_SUPPORT\n");
+			break;
+
+		case USB_DEVICE_A_ALT_HNP_SUPPORT:
+			/* other RH port does */
+			DEBUG_SETUP("\tSET_FEATURE: USB_DEVICE_A_ALT_HNP_SUPPORT\n");
+			break;
+		}
+
+		s3c_udc_ep0_zlp();
+		return 0;
+
+	case USB_RECIP_INTERFACE:
+		DEBUG_SETUP("\tSET_FEATURE: USB_RECIP_INTERFACE\n");
+		break;
+
+	case USB_RECIP_ENDPOINT:
+		DEBUG_SETUP("\tSET_FEATURE: USB_RECIP_ENDPOINT\n");
+		if (usb_ctrl.wValue == USB_ENDPOINT_HALT) {
+			if (ep_num == 0) {
+				s3c_udc_ep0_set_stall(ep);
+				return 0;
+			} 
+			ep->stopped = 1;
+			s3c_udc_ep_set_stall(ep);
+		}
+
+		s3c_udc_ep0_zlp();
+		return 0;
+	}
+
+	return 1;
+}
+
+/*
+ * WAIT_FOR_SETUP (OUT_PKT_RDY)
+ */
+static void s3c_ep0_setup(struct s3c_udc *dev)
+{
+	struct s3c_ep *ep = &dev->ep[0];
+	int i, bytes, is_in;
+	u8 ep_num;
+
+	/* Nuke all previous transfers */
+	nuke(ep, -EPROTO);
+
+	/* read control req from fifo (8 bytes) */
+	bytes = s3c_fifo_read(ep, (u32 *)&usb_ctrl, 8);
+
+	DEBUG_SETUP("%s: bRequestType = 0x%x(%s), bRequest = 0x%x"
+			"\twLength = 0x%x, wValue = 0x%x, wIndex= 0x%x\n",
+			__func__, usb_ctrl.bRequestType,
+			(usb_ctrl.bRequestType & USB_DIR_IN) ? "IN" : "OUT", usb_ctrl.bRequest,
+			usb_ctrl.wLength, usb_ctrl.wValue, usb_ctrl.wIndex);
+
+	if (usb_ctrl.bRequest == GET_MAX_LUN_REQUEST && usb_ctrl.wLength != 1) {
+		DEBUG_SETUP("\t%s:GET_MAX_LUN_REQUEST:invalid wLength = %d, setup returned\n",
+			__func__, usb_ctrl.wLength);
+
+		s3c_udc_ep0_set_stall(ep);
+		dev->ep0state = WAIT_FOR_SETUP;
+
+		return;
+	}
+	else if (usb_ctrl.bRequest == BOT_RESET_REQUEST && usb_ctrl.wLength != 0) {
+		/* Bulk-Only *mass storge reset of class-specific request */ 
+		DEBUG_SETUP("\t%s:BOT Rest:invalid wLength = %d, setup returned\n",
+			__func__, usb_ctrl.wLength);
+
+		s3c_udc_ep0_set_stall(ep);
+		dev->ep0state = WAIT_FOR_SETUP;
+
+		return;
+	}
+
+	/* Set direction of EP0 */
+	if (likely(usb_ctrl.bRequestType & USB_DIR_IN)) {
+		ep->bEndpointAddress |= USB_DIR_IN;
+		is_in = 1;
+
+	} else {
+		ep->bEndpointAddress &= ~USB_DIR_IN;
+		is_in = 0;
+	}
+	/* cope with automagic for some standard requests. */
+	dev->req_std = (usb_ctrl.bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD;
+	dev->req_config = 0;
+	dev->req_pending = 1;
+
+	/* Handle some SETUP packets ourselves */
+	switch (usb_ctrl.bRequest) {
+	case USB_REQ_SET_ADDRESS:
+	DEBUG_SETUP("%s: *** USB_REQ_SET_ADDRESS (%d)\n",
+			__func__, usb_ctrl.wValue);
+
+		if (usb_ctrl.bRequestType
+			!= (USB_TYPE_STANDARD | USB_RECIP_DEVICE))
+			break;
+
+		udc_set_address(dev, usb_ctrl.wValue);
+		return;
+
+	case USB_REQ_SET_CONFIGURATION :
+		DEBUG_SETUP("============================================\n");
+		DEBUG_SETUP("%s: USB_REQ_SET_CONFIGURATION (%d)\n",
+				__func__, usb_ctrl.wValue);
+
+		if (usb_ctrl.bRequestType == USB_RECIP_DEVICE) {
+			reset_available = 1;
+			dev->req_config = 1;
+		}
+		break;
+
+	case USB_REQ_GET_DESCRIPTOR:
+		DEBUG_SETUP("%s: *** USB_REQ_GET_DESCRIPTOR  \n",__func__);
+		break;
+
+	case USB_REQ_SET_INTERFACE:
+		DEBUG_SETUP("%s: *** USB_REQ_SET_INTERFACE (%d)\n",
+				__func__, usb_ctrl.wValue);
+
+		if (usb_ctrl.bRequestType == USB_RECIP_INTERFACE) {
+			reset_available = 1;
+			dev->req_config = 1;
+		}
+		break;
+
+	case USB_REQ_GET_CONFIGURATION:
+		DEBUG_SETUP("%s: *** USB_REQ_GET_CONFIGURATION  \n",__func__);
+		break;
+
+	case USB_REQ_GET_STATUS:
+		if (dev->req_std) {
+			if (!s3c_udc_get_status(dev, &usb_ctrl)) {
+				return;
+			}
+		}
+		break;
+
+	case USB_REQ_CLEAR_FEATURE:
+		ep_num = usb_ctrl.wIndex & 0x7f;
+
+		if (!s3c_udc_clear_feature(&dev->ep[ep_num].ep)) {
+			return;
+		}
+		break;
+
+	case USB_REQ_SET_FEATURE:
+		ep_num = usb_ctrl.wIndex & 0x7f;
+
+		if (!s3c_udc_set_feature(&dev->ep[ep_num].ep)) {
+			return;
+		}
+		break;
+
+	default:
+		DEBUG_SETUP("%s: *** Default of usb_ctrl.bRequest=0x%x happened.\n",
+				__func__, usb_ctrl.bRequest);
+		break;
+	}
+
+	if (likely(dev->driver)) {
+		/* device-2-host (IN) or no data setup command,
+		 * process immediately */
+		DEBUG_SETUP("%s: usb_ctrlrequest will be passed to fsg_setup()\n", __func__);
+
+		spin_unlock(&dev->lock);
+		i = dev->driver->setup(&dev->gadget, &usb_ctrl);
+		spin_lock(&dev->lock);
+
+		if (i < 0) {
+			if (dev->req_config) {
+				DEBUG_SETUP("\tconfig change 0x%02x fail %d?\n",
+					(u32)&usb_ctrl.bRequest, i);
+				return;
+			}
+
+			/* setup processing failed, force stall */
+			s3c_udc_ep0_set_stall(ep);
+			dev->ep0state = WAIT_FOR_SETUP;
+
+			DEBUG_SETUP("\tdev->driver->setup failed (%d), bRequest = %d\n",
+				i, usb_ctrl.bRequest);
+
+
+		} else if (dev->req_pending) {
+			dev->req_pending = 0;
+			DEBUG_SETUP("\tdev->req_pending... \n");
+		}
+
+		DEBUG_SETUP("\tep0state = %s\n", state_names[dev->ep0state]);
+
+	}
+}
+
+/*
+ * handle ep0 interrupt
+ */
+static void s3c_handle_ep0(struct s3c_udc *dev)
+{
+	if (dev->ep0state == WAIT_FOR_SETUP) {
+		DEBUG_OUT_EP("%s: WAIT_FOR_SETUP\n", __func__);
+		s3c_ep0_setup(dev);
+
+	} else {
+		DEBUG_OUT_EP("%s: strange state!!(state = %s)\n",
+			__func__, state_names[dev->ep0state]);
+	}
+}
+
+static void s3c_ep0_kick(struct s3c_udc *dev, struct s3c_ep *ep)
+{
+	DEBUG_EP0("%s: ep_is_in = %d\n", __func__, ep_is_in(ep));
+	if (ep_is_in(ep)) {
+		dev->ep0state = DATA_STATE_XMIT;
+		s3c_ep0_write(dev);
+
+	} else {
+		dev->ep0state = DATA_STATE_RECV;
+		s3c_ep0_read(dev);
+	}
+}
diff -uraN linux-3.0.8/drivers/usb/gadget/s3c_udc_otg_xfer_slave.c linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/gadget/s3c_udc_otg_xfer_slave.c
--- linux-3.0.8/drivers/usb/gadget/s3c_udc_otg_xfer_slave.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/gadget/s3c_udc_otg_xfer_slave.c	2021-07-13 23:40:34.194359551 +0300
@@ -0,0 +1,971 @@
+/*
+ * drivers/usb/gadget/s3c_udc_otg_xfer_slave.c
+ * Samsung S3C on-chip full/high speed USB OTG 2.0 device controllers
+ *
+ * Copyright (C) 2009 for Samsung Electronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#define GINTMSK_INIT	(INT_RESUME|INT_ENUMDONE|INT_RESET|INT_SUSPEND|INT_RX_FIFO_NOT_EMPTY)
+#define DOEPMSK_INIT	(AHB_ERROR)
+#define DIEPMSK_INIT	(NON_ISO_IN_EP_TIMEOUT|AHB_ERROR)
+#define GAHBCFG_INIT	(PTXFE_HALF|NPTXFE_HALF|MODE_SLAVE|BURST_SINGLE|GBL_INT_UNMASK)
+
+u32 tx_ep_num = 2;
+
+static int set_interface_first = 0;
+
+/*-------------------------------------------------------------------------*/
+
+/** Read to request from FIFO (max read == bytes in fifo)
+ *  Return:  0 = still running, 1 = completed, negative = errno
+ */
+static int read_fifo(struct s3c_ep *ep, struct s3c_request *req)
+{
+	u32 csr, gintmsk;
+	u32 *buf;
+	u32 bufferspace, count, count_bytes, is_short = 0;
+	u32 fifo = ep->fifo;
+
+	csr = readl(S3C_UDC_OTG_GRXSTSP);
+	count_bytes = (csr & 0x7ff0)>>4;
+
+	gintmsk = readl(S3C_UDC_OTG_GINTMSK);
+
+	if(!count_bytes) {
+		DEBUG_OUT_EP("%s: count_bytes %d bytes\n", __FUNCTION__, count_bytes);
+
+		// Unmask USB OTG 2.0 interrupt source : INT_RX_FIFO_NOT_EMPTY
+		writel(gintmsk | INT_RX_FIFO_NOT_EMPTY, S3C_UDC_OTG_GINTMSK);
+		return 0;
+	}
+
+	buf = req->req.buf + req->req.actual;
+	prefetchw(buf);
+	bufferspace = req->req.length - req->req.actual;
+
+	count = count_bytes / 4;
+	if(count_bytes%4) count = count + 1;
+
+	req->req.actual += min(count_bytes, bufferspace);
+
+	is_short = (count_bytes < ep->ep.maxpacket);
+	DEBUG_OUT_EP("%s: read %s, %d bytes%s req %p %d/%d GRXSTSP:0x%x\n",
+		__FUNCTION__,
+		ep->ep.name, count_bytes,
+		is_short ? "/S" : "", req, req->req.actual, req->req.length, csr);
+
+	while (likely(count-- != 0)) {
+		u32 byte = (u32) readl(fifo);
+
+		if (unlikely(bufferspace == 0)) {
+			/* this happens when the driver's buffer
+		 	* is smaller than what the host sent.
+		 	* discard the extra data.
+		 	*/
+			if (req->req.status != -EOVERFLOW)
+				printk("%s overflow %d\n", ep->ep.name, count);
+			req->req.status = -EOVERFLOW;
+		} else {
+			*buf++ = byte;
+			bufferspace-=4;
+		}
+ 	 }
+
+	// Unmask USB OTG 2.0 interrupt source : INT_RX_FIFO_NOT_EMPTY
+	writel(gintmsk | INT_RX_FIFO_NOT_EMPTY, S3C_UDC_OTG_GINTMSK);
+
+	/* completion */
+	if (is_short || req->req.actual == req->req.length) {
+		done(ep, req, 0);
+		return 1;
+	}
+
+	/* finished that packet.  the next one may be waiting... */
+	return 0;
+}
+
+/* Inline code */
+static __inline__ int write_packet(struct s3c_ep *ep,
+				   struct s3c_request *req, int max)
+{
+	u32 *buf;
+	int length, count;
+	u32 fifo = ep->fifo, in_ctrl;
+
+	buf = req->req.buf + req->req.actual;
+	prefetch(buf);
+
+	length = req->req.length - req->req.actual;
+	length = min(length, max);
+	req->req.actual += length;
+
+	DEBUG("%s: Write %d (max %d), fifo=0x%x\n",
+		__FUNCTION__, length, max, fifo);
+
+	if(ep_index(ep) == EP0_CON) {
+		writel((1<<19)|(length<<0), (u32) S3C_UDC_OTG_DIEPTSIZ0);
+
+		in_ctrl =  readl(S3C_UDC_OTG_DIEPCTL0);
+		writel(DEPCTL_EPENA|DEPCTL_CNAK|(EP2_IN<<11)| in_ctrl, (u32) S3C_UDC_OTG_DIEPCTL0);
+
+		DEBUG_EP0("%s:(DIEPTSIZ0):0x%x, (DIEPCTL0):0x%x, (GNPTXSTS):0x%x\n", __FUNCTION__,
+			readl(S3C_UDC_OTG_DIEPTSIZ0),readl(S3C_UDC_OTG_DIEPCTL0),
+			readl(S3C_UDC_OTG_GNPTXSTS));
+
+		udelay(30);
+
+	} else if ((ep_index(ep) == EP2_IN)) {
+		writel((1<<19)|(length<<0), S3C_UDC_OTG_DIEPTSIZ2);
+
+		in_ctrl =  readl(S3C_UDC_OTG_DIEPCTL2);
+		writel(DEPCTL_EPENA|DEPCTL_CNAK|(EP2_IN<<11)| in_ctrl, (u32) S3C_UDC_OTG_DIEPCTL2);
+
+		DEBUG_IN_EP("%s:(DIEPTSIZ2):0x%x, (DIEPCTL2):0x%x, (GNPTXSTS):0x%x\n", __FUNCTION__,
+			readl(S3C_UDC_OTG_DIEPTSIZ2),readl(S3C_UDC_OTG_DIEPCTL2),
+			readl(S3C_UDC_OTG_GNPTXSTS));
+
+		udelay(30);
+
+	} else if ((ep_index(ep) == EP3_IN)) {
+
+		if (set_interface_first == 1) {
+			DEBUG_IN_EP("%s: first packet write skipped after set_interface\n", __FUNCTION__);
+			set_interface_first = 0;
+			return length;
+		}
+
+		writel((1<<19)|(length<<0), S3C_UDC_OTG_DIEPTSIZ3);
+
+		in_ctrl =  readl(S3C_UDC_OTG_DIEPCTL3);
+		writel(DEPCTL_EPENA|DEPCTL_CNAK|(EP2_IN<<11)| in_ctrl, (u32) S3C_UDC_OTG_DIEPCTL3);
+
+		DEBUG_IN_EP("%s:(DIEPTSIZ3):0x%x, (DIEPCTL3):0x%x, (GNPTXSTS):0x%x\n", __FUNCTION__,
+			readl(S3C_UDC_OTG_DIEPTSIZ3),readl(S3C_UDC_OTG_DIEPCTL3),
+			readl(S3C_UDC_OTG_GNPTXSTS));
+
+		udelay(30);
+
+	} else {
+		printk("%s: --> Error Unused Endpoint!!\n",
+			__FUNCTION__);
+		BUG();
+	}
+
+	for (count=0;count<length;count+=4) {
+	  	writel(*buf++, fifo);
+	}
+	return length;
+}
+
+/** Write request to FIFO (max write == maxp size)
+ *  Return:  0 = still running, 1 = completed, negative = errno
+ */
+static int write_fifo(struct s3c_ep *ep, struct s3c_request *req)
+{
+	u32 max, gintmsk;
+	unsigned count;
+	int is_last = 0, is_short = 0;
+
+	gintmsk = readl(S3C_UDC_OTG_GINTMSK);
+
+	max = le16_to_cpu(ep->desc->wMaxPacketSize);
+	count = write_packet(ep, req, max);
+
+	/* last packet is usually short (or a zlp) */
+	if (unlikely(count != max))
+		is_last = is_short = 1;
+	else {
+		if (likely(req->req.length != req->req.actual)
+		    || req->req.zero)
+			is_last = 0;
+		else
+			is_last = 1;
+		/* interrupt/iso maxpacket may not fill the fifo */
+		is_short = unlikely(max < ep_maxpacket(ep));
+	}
+
+	DEBUG_IN_EP("%s: wrote %s %d bytes%s%s req %p %d/%d\n",
+			__FUNCTION__,
+      			ep->ep.name, count,
+     	 		is_last ? "/L" : "", is_short ? "/S" : "",
+      			req, req->req.actual, req->req.length);
+
+	/* requests complete when all IN data is in the FIFO */
+	if (is_last) {
+		if(!ep_index(ep)){
+			printk("%s: --> Error EP0 must not come here!\n",
+				__FUNCTION__);
+			BUG();
+		}
+		writel(gintmsk&(~INT_NP_TX_FIFO_EMPTY), S3C_UDC_OTG_GINTMSK);
+		done(ep, req, 0);
+		return 1;
+	}
+
+	// Unmask USB OTG 2.0 interrupt source : INT_NP_TX_FIFO_EMPTY
+	writel(gintmsk | INT_NP_TX_FIFO_EMPTY, S3C_UDC_OTG_GINTMSK);
+	return 0;
+}
+
+/* ********************************************************************************************* */
+/* Bulk OUT (recv)
+ */
+
+static void s3c_out_epn(struct s3c_udc *dev, u32 ep_idx)
+{
+	struct s3c_ep *ep = &dev->ep[ep_idx];
+	struct s3c_request *req;
+
+	if (unlikely(!(ep->desc))) {
+		/* Throw packet away.. */
+		printk("%s: No descriptor?!?\n", __FUNCTION__);
+		return;
+	}
+
+	if (list_empty(&ep->queue))
+		req = 0;
+	else
+		req = list_entry(ep->queue.next,
+				struct s3c_request, queue);
+
+	if (unlikely(!req)) {
+		DEBUG_OUT_EP("%s: NULL REQ on OUT EP-%d\n", __FUNCTION__, ep_idx);
+		return;
+
+	} else {
+		read_fifo(ep, req);
+	}
+
+}
+
+/**
+ * s3c_in_epn - handle IN interrupt
+ */
+static void s3c_in_epn(struct s3c_udc *dev, u32 ep_idx)
+{
+	struct s3c_ep *ep = &dev->ep[ep_idx];
+	struct s3c_request *req;
+
+	if (list_empty(&ep->queue))
+		req = 0;
+	else
+		req = list_entry(ep->queue.next, struct s3c_request, queue);
+
+	if (unlikely(!req)) {
+		DEBUG_IN_EP("%s: NULL REQ on IN EP-%d\n", __FUNCTION__, ep_idx);
+		return;
+	}
+	else {
+		write_fifo(ep, req);
+	}
+
+}
+
+/*
+ *	elfin usb client interrupt handler.
+ */
+static irqreturn_t s3c_udc_irq(int irq, void *_dev)
+{
+	struct s3c_udc *dev = _dev;
+	u32 intr_status;
+	u32 usb_status, ep_ctrl, gintmsk;
+
+	spin_lock(&dev->lock);
+
+	intr_status = readl(S3C_UDC_OTG_GINTSTS);
+	gintmsk = readl(S3C_UDC_OTG_GINTMSK);
+
+	DEBUG_ISR("\n**** %s : GINTSTS=0x%x(on state %s), GINTMSK : 0x%x\n",
+			__FUNCTION__, intr_status, state_names[dev->ep0state], gintmsk);
+
+	if (!intr_status) {
+		spin_unlock(&dev->lock);
+		return IRQ_HANDLED;
+	}
+
+	if (intr_status & INT_ENUMDONE) {
+		DEBUG_SETUP("####################################\n");
+		DEBUG_SETUP("    %s: Speed Detection interrupt\n",
+				__FUNCTION__);
+		writel(INT_ENUMDONE, S3C_UDC_OTG_GINTSTS);
+
+		usb_status = (readl(S3C_UDC_OTG_DSTS) & 0x6);
+
+		if (usb_status & (USB_FULL_30_60MHZ | USB_FULL_48MHZ)) {
+			DEBUG_SETUP("    %s: Full Speed Detection\n",__FUNCTION__);
+			set_max_pktsize(dev, USB_SPEED_FULL);
+
+		} else {
+			DEBUG_SETUP("    %s: High Speed Detection : 0x%x\n", __FUNCTION__, usb_status);
+			set_max_pktsize(dev, USB_SPEED_HIGH);
+		}
+	}
+
+	if (intr_status & INT_EARLY_SUSPEND) {
+		DEBUG_SETUP("####################################\n");
+		DEBUG_SETUP("    %s:Early suspend interrupt\n", __FUNCTION__);
+		writel(INT_EARLY_SUSPEND, S3C_UDC_OTG_GINTSTS);
+	}
+
+	if (intr_status & INT_SUSPEND) {
+		usb_status = readl(S3C_UDC_OTG_DSTS);
+		DEBUG_SETUP("####################################\n");
+		DEBUG_SETUP("    %s:Suspend interrupt :(DSTS):0x%x\n", __FUNCTION__, usb_status);
+		writel(INT_SUSPEND, S3C_UDC_OTG_GINTSTS);
+
+		if (dev->gadget.speed != USB_SPEED_UNKNOWN
+		    && dev->driver
+		    && dev->driver->suspend) {
+
+			dev->driver->suspend(&dev->gadget);
+		}
+	}
+
+	if (intr_status & INT_RESUME) {
+		DEBUG_SETUP("####################################\n");
+		DEBUG_SETUP("    %s: Resume interrupt\n", __FUNCTION__);
+		writel(INT_RESUME, S3C_UDC_OTG_GINTSTS);
+
+		if (dev->gadget.speed != USB_SPEED_UNKNOWN
+		    && dev->driver
+		    && dev->driver->resume) {
+
+			dev->driver->resume(&dev->gadget);
+		}
+	}
+
+	if (intr_status & INT_RESET) {
+		usb_status = readl(S3C_UDC_OTG_GOTGCTL);
+		DEBUG_SETUP("####################################\n");
+		DEBUG_SETUP("    %s: Reset interrupt - (GOTGCTL):0x%x\n", __FUNCTION__, usb_status);
+		writel(INT_RESET, S3C_UDC_OTG_GINTSTS);
+
+		if((usb_status & 0xc0000) == (0x3 << 18)) {
+			if(reset_available) {
+				DEBUG_SETUP("     ===> OTG core got reset (%d)!! \n", reset_available);
+				reconfig_usbd();
+				dev->ep0state = WAIT_FOR_SETUP;
+				reset_available = 0;
+			}
+		} else {
+			reset_available = 1;
+			DEBUG_SETUP("      RESET handling skipped : reset_available : %d\n", reset_available);
+		}
+	}
+
+	if (intr_status & INT_RX_FIFO_NOT_EMPTY) {
+		u32 grx_status, packet_status, ep_num, fifoCntByte = 0;
+
+		// Mask USB OTG 2.0 interrupt source : INT_RX_FIFO_NOT_EMPTY
+		gintmsk &= ~INT_RX_FIFO_NOT_EMPTY;
+		writel(gintmsk, S3C_UDC_OTG_GINTMSK);
+
+		grx_status = readl(S3C_UDC_OTG_GRXSTSR);
+		DEBUG_ISR("    INT_RX_FIFO_NOT_EMPTY(GRXSTSR):0x%x, GINTMSK:0x%x\n", grx_status, gintmsk);
+
+		packet_status = grx_status & 0x1E0000;
+		fifoCntByte = (grx_status & 0x7ff0)>>4;
+		ep_num = grx_status & EP_MASK;
+
+		if (fifoCntByte) {
+
+			if (packet_status == SETUP_PKT_RECEIVED)  {
+				DEBUG_EP0("      => A SETUP data packet received : %d bytes\n", fifoCntByte);
+				s3c_handle_ep0(dev);
+
+				// Unmask USB OTG 2.0 interrupt source : INT_RX_FIFO_NOT_EMPTY
+				gintmsk |= INT_RX_FIFO_NOT_EMPTY;
+
+			} else if (packet_status == OUT_PKT_RECEIVED) {
+
+				if(ep_num == EP1_OUT) {
+					ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL1);
+					DEBUG_ISR("      => A Bulk OUT data packet received : %d bytes, (DOEPCTL1):0x%x\n",
+						fifoCntByte, ep_ctrl);
+					s3c_out_epn(dev, 1);
+					gintmsk = readl(S3C_UDC_OTG_GINTMSK);
+					writel(ep_ctrl | DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL1);
+				} else if (ep_num == EP0_CON) {
+					ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL0);
+					DEBUG_EP0("      => A CONTROL OUT data packet received : %d bytes, (DOEPCTL0):0x%x\n",
+						fifoCntByte, ep_ctrl);
+					dev->ep0state = DATA_STATE_RECV;
+					s3c_ep0_read(dev);
+					gintmsk |= INT_RX_FIFO_NOT_EMPTY;
+				} else {
+					DEBUG_ISR("      => Unused EP: %d bytes, (GRXSTSR):0x%x\n", fifoCntByte, grx_status);
+				}
+			} else {
+				grx_status = readl(S3C_UDC_OTG_GRXSTSP);
+
+				// Unmask USB OTG 2.0 interrupt source : INT_RX_FIFO_NOT_EMPTY
+				gintmsk |= INT_RX_FIFO_NOT_EMPTY;
+
+				DEBUG_ISR("      => A reserved packet received : %d bytes\n", fifoCntByte);
+			}
+		} else {
+			if (dev->ep0state == DATA_STATE_XMIT) {
+				ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL0);
+				DEBUG_EP0("      => Write ep0 continue... (DOEPCTL0):0x%x\n", ep_ctrl);
+				s3c_ep0_write(dev);
+			}
+
+			if (packet_status == SETUP_TRANSACTION_COMPLETED) {
+				ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL0);
+				DEBUG_EP0("      => A SETUP transaction completed (DOEPCTL0):0x%x\n", ep_ctrl);
+				writel(ep_ctrl | DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL0);
+
+			} else if (packet_status == OUT_TRANSFER_COMPLELTED) {
+				if (ep_num == EP1_OUT) {
+					ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL1);
+					DEBUG_ISR("      => An OUT transaction completed (DOEPCTL1):0x%x\n", ep_ctrl);
+					writel(ep_ctrl | DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL1);
+				} else if (ep_num == EP0_CON) {
+					ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL0);
+					DEBUG_ISR("      => An OUT transaction completed (DOEPCTL0):0x%x\n", ep_ctrl);
+					writel(ep_ctrl | DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL0);
+				} else {
+					DEBUG_ISR("      => Unused EP: %d bytes, (GRXSTSR):0x%x\n", fifoCntByte, grx_status);
+				}
+			} else if (packet_status == OUT_PKT_RECEIVED) {
+				DEBUG_ISR("      => A  OUT PACKET RECEIVED (NO FIFO CNT BYTE)...(GRXSTSR):0x%x\n", grx_status);
+			} else {
+				DEBUG_ISR("      => A RESERVED PACKET RECEIVED (NO FIFO CNT BYTE)...(GRXSTSR):0x%x\n", grx_status);
+			}
+
+			grx_status = readl(S3C_UDC_OTG_GRXSTSP);
+
+			// Unmask USB OTG 2.0 interrupt source : INT_RX_FIFO_NOT_EMPTY
+			gintmsk |= INT_RX_FIFO_NOT_EMPTY;
+
+		}
+
+		// Un/Mask USB OTG 2.0 interrupt sources
+		writel(gintmsk, S3C_UDC_OTG_GINTMSK);
+
+		spin_unlock(&dev->lock);
+		return IRQ_HANDLED;
+	}
+
+
+	if (intr_status & INT_NP_TX_FIFO_EMPTY) {
+		DEBUG_ISR("    INT_NP_TX_FIFO_EMPTY (GNPTXSTS):0x%x, (GINTMSK):0x%x, ep_num=%d\n",
+				readl(S3C_UDC_OTG_GNPTXSTS),
+				readl(S3C_UDC_OTG_GINTMSK),
+				tx_ep_num);
+
+		s3c_in_epn(dev, tx_ep_num);
+	}
+
+	spin_unlock(&dev->lock);
+
+	return IRQ_HANDLED;
+}
+
+/** Queue one request
+ *  Kickstart transfer if needed
+ */
+static int s3c_queue(struct usb_ep *_ep, struct usb_request *_req,
+			 gfp_t gfp_flags)
+{
+	struct s3c_request *req;
+	struct s3c_ep *ep;
+	struct s3c_udc *dev;
+	unsigned long flags;
+
+	req = container_of(_req, struct s3c_request, req);
+	if (unlikely(!_req || !_req->complete || !_req->buf
+			|| !list_empty(&req->queue)))
+	{
+		DEBUG("%s: bad params\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) {
+		DEBUG("%s: bad ep\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	dev = ep->dev;
+	if (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {
+		DEBUG("%s: bogus device state %p\n", __FUNCTION__, dev->driver);
+		return -ESHUTDOWN;
+	}
+
+	DEBUG("\n%s: %s queue req %p, len %d buf %p\n",
+		__FUNCTION__, _ep->name, _req, _req->length, _req->buf);
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+
+	/* kickstart this i/o queue? */
+	DEBUG("%s: Add to ep=%d, Q empty=%d, stopped=%d\n",
+		__FUNCTION__, ep_index(ep), list_empty(&ep->queue), ep->stopped);
+
+	if (list_empty(&ep->queue) && likely(!ep->stopped)) {
+		u32 csr;
+
+		if (unlikely(ep_index(ep) == 0)) {
+			/* EP0 */
+			list_add_tail(&req->queue, &ep->queue);
+			s3c_ep0_kick(dev, ep);
+			req = 0;
+
+		} else if (ep_is_in(ep)) {
+			csr = readl((u32) S3C_UDC_OTG_GINTSTS);
+			DEBUG_IN_EP("%s: ep_is_in, S3C_UDC_OTG_GINTSTS=0x%x\n",
+				__FUNCTION__, csr);
+
+			if((csr & INT_NP_TX_FIFO_EMPTY) &&
+			   (write_fifo(ep, req) == 1)) {
+				req = 0;
+			} else {
+				DEBUG("++++ IN-list_add_taill::req=%p, ep=%d\n",
+					req, ep_index(ep));
+				tx_ep_num = ep_index(ep);
+			}
+		} else {
+			csr = readl((u32) S3C_UDC_OTG_GINTSTS);
+			DEBUG_OUT_EP("%s: ep_is_out, S3C_UDC_OTG_GINTSTS=0x%x\n",
+				__FUNCTION__, csr);
+
+			if((csr & INT_RX_FIFO_NOT_EMPTY) &&
+			   (read_fifo(ep, req) == 1))
+				req = 0;
+			else
+				DEBUG("++++ OUT-list_add_taill::req=%p, DOEPCTL1:0x%x\n",
+					req, readl(S3C_UDC_OTG_DOEPCTL1));
+		}
+	}
+
+	/* pio or dma irq handler advances the queue. */
+	if (likely(req != 0))
+		list_add_tail(&req->queue, &ep->queue);
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return 0;
+}
+
+/****************************************************************/
+/* End Point 0 related functions                                */
+/****************************************************************/
+
+/* return:  0 = still running, 1 = completed, negative = errno */
+static int write_fifo_ep0(struct s3c_ep *ep, struct s3c_request *req)
+{
+	u32 max;
+	unsigned count;
+	int is_last;
+
+	max = ep_maxpacket(ep);
+
+	DEBUG_EP0("%s: max = %d\n", __FUNCTION__, max);
+
+	count = write_packet(ep, req, max);
+
+	/* last packet is usually short (or a zlp) */
+	if (likely(count != max))
+		is_last = 1;
+	else {
+		if (likely(req->req.length != req->req.actual) || req->req.zero)
+			is_last = 0;
+		else
+			is_last = 1;
+	}
+
+	DEBUG_EP0("%s: wrote %s %d bytes%s %d left %p\n", __FUNCTION__,
+		  ep->ep.name, count,
+		  is_last ? "/L" : "", req->req.length - req->req.actual, req);
+
+	/* requests complete when all IN data is in the FIFO */
+	if (is_last) {
+		return 1;
+	}
+
+	return 0;
+}
+
+static __inline__ int s3c_fifo_read(struct s3c_ep *ep, u32 *cp, int max)
+{
+	int bytes;
+	int count;
+	u32 grx_status = readl(S3C_UDC_OTG_GRXSTSP);
+	bytes = (grx_status & 0x7ff0)>>4;
+
+	DEBUG_EP0("%s: GRXSTSP=0x%x, bytes=%d, ep_index=%d, fifo=0x%x\n",
+			__FUNCTION__, grx_status, bytes, ep_index(ep), ep->fifo);
+
+	// 32 bits interface
+	count = bytes / 4;
+
+	while (count--) {
+		*cp++ = (u32) readl(S3C_UDC_OTG_EP0_FIFO);
+	}
+
+	return bytes;
+}
+
+static int read_fifo_ep0(struct s3c_ep *ep, struct s3c_request *req)
+{
+	u32 csr;
+	u32 *buf;
+	unsigned bufferspace, count, is_short, bytes;
+	u32 fifo = ep->fifo;
+
+	DEBUG_EP0("%s\n", __FUNCTION__);
+
+	csr = readl(S3C_UDC_OTG_GRXSTSP);
+	bytes = (csr & 0x7ff0)>>4;
+
+	buf = req->req.buf + req->req.actual;
+	prefetchw(buf);
+	bufferspace = req->req.length - req->req.actual;
+
+	/* read all bytes from this packet */
+	if (likely((csr & EP_MASK) == EP0_CON)) {
+		count = bytes / 4;
+		req->req.actual += min(bytes, bufferspace);
+
+	} else	{		// zlp
+		count = 0;
+		bytes = 0;
+	}
+
+	is_short = (bytes < ep->ep.maxpacket);
+	DEBUG_EP0("%s: read %s %02x, %d bytes%s req %p %d/%d\n",
+		  __FUNCTION__,
+		  ep->ep.name, csr, bytes,
+		  is_short ? "/S" : "", req, req->req.actual, req->req.length);
+
+	while (likely(count-- != 0)) {
+		u32 byte = (u32) readl(fifo);
+
+		if (unlikely(bufferspace == 0)) {
+			/* this happens when the driver's buffer
+			 * is smaller than what the host sent.
+			 * discard the extra data.
+			 */
+			if (req->req.status != -EOVERFLOW)
+				DEBUG_EP0("%s overflow %d\n", ep->ep.name,
+					  count);
+			req->req.status = -EOVERFLOW;
+		} else {
+			*buf++ = byte;
+			bufferspace = bufferspace - 4;
+		}
+	}
+
+	/* completion */
+	if (is_short || req->req.actual == req->req.length) {
+		return 1;
+	}
+
+	return 0;
+}
+
+/**
+ * udc_set_address - set the USB address for this device
+ * @address:
+ *
+ * Called from control endpoint function
+ * after it decodes a set address setup packet.
+ */
+static void udc_set_address(struct s3c_udc *dev, unsigned char address)
+{
+	u32 ctrl = readl(S3C_UDC_OTG_DCFG);
+	writel(address << 4 | ctrl, S3C_UDC_OTG_DCFG);
+
+	ctrl = readl(S3C_UDC_OTG_DIEPCTL0);
+	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, S3C_UDC_OTG_DIEPCTL0); /* EP0: Control IN */
+
+	DEBUG_EP0("%s: USB OTG 2.0 Device address=%d, DCFG=0x%x\n",
+		__FUNCTION__, address, readl(S3C_UDC_OTG_DCFG));
+
+	dev->usb_address = address;
+}
+
+
+
+static int first_time = 1;
+
+static void s3c_ep0_read(struct s3c_udc *dev)
+{
+	struct s3c_request *req;
+	struct s3c_ep *ep = &dev->ep[0];
+	int ret;
+
+	if (!list_empty(&ep->queue))
+		req = list_entry(ep->queue.next, struct s3c_request, queue);
+	else {
+		printk("%s: ---> BUG\n", __FUNCTION__);
+		BUG();	//logic ensures		-jassi
+		return;
+	}
+
+	DEBUG_EP0("%s: req.length = 0x%x, req.actual = 0x%x\n",
+		__FUNCTION__, req->req.length, req->req.actual);
+
+	if(req->req.length == 0) {
+		dev->ep0state = WAIT_FOR_SETUP;
+		first_time = 1;
+		done(ep, req, 0);
+		return;
+	}
+
+	if(!req->req.actual && first_time){	//for SetUp packet
+		first_time = 0;
+		return;
+	}
+
+	ret = read_fifo_ep0(ep, req);
+	if (ret) {
+		dev->ep0state = WAIT_FOR_SETUP;
+		first_time = 1;
+		done(ep, req, 0);
+		return;
+	}
+
+}
+
+/*
+ * DATA_STATE_XMIT
+ */
+static int s3c_ep0_write(struct s3c_udc *dev)
+{
+	struct s3c_request *req;
+	struct s3c_ep *ep = &dev->ep[0];
+	int ret, need_zlp = 0;
+
+	DEBUG_EP0("%s: ep0 write\n", __FUNCTION__);
+
+	if (list_empty(&ep->queue))
+		req = 0;
+	else
+		req = list_entry(ep->queue.next, struct s3c_request, queue);
+
+	if (!req) {
+		DEBUG_EP0("%s: NULL REQ\n", __FUNCTION__);
+		return 0;
+	}
+
+	DEBUG_EP0("%s: req.length = 0x%x, req.actual = 0x%x\n",
+		__FUNCTION__, req->req.length, req->req.actual);
+
+	if (req->req.length == 0) {
+		dev->ep0state = WAIT_FOR_SETUP;
+	   	done(ep, req, 0);
+		return 1;
+	}
+
+	if (req->req.length - req->req.actual == ep0_fifo_size) {
+		/* Next write will end with the packet size, */
+		/* so we need Zero-length-packet */
+		need_zlp = 1;
+	}
+
+	ret = write_fifo_ep0(ep, req);
+
+	if ((ret == 1) && !need_zlp) {
+		/* Last packet */
+		DEBUG_EP0("%s: finished, waiting for status\n", __FUNCTION__);
+		dev->ep0state = WAIT_FOR_SETUP;
+	} else {
+		DEBUG_EP0("%s: not finished\n", __FUNCTION__);
+	}
+
+	if (need_zlp) {
+		DEBUG_EP0("%s: Need ZLP!\n", __FUNCTION__);
+		dev->ep0state = DATA_STATE_NEED_ZLP;
+	}
+
+	if(ret)
+	   done(ep, req, 0);
+
+	return 1;
+}
+
+static int s3c_udc_set_halt(struct usb_ep *_ep, int value)
+{
+	struct s3c_ep	*ep;
+	u32 ep_num;
+	ep = container_of(_ep, struct s3c_ep, ep);
+	ep_num =ep_index(ep);
+	
+	DEBUG("%s: ep_num = %d, value = %d\n", __FUNCTION__, ep_num, value);
+	/* TODO */
+	return 0;
+}
+
+void s3c_udc_ep_activate(struct s3c_ep *ep)
+{
+	/* TODO */
+}
+
+/*
+ * WAIT_FOR_SETUP (OUT_PKT_RDY)
+ */
+static void s3c_ep0_setup(struct s3c_udc *dev)
+{
+	struct s3c_ep *ep = &dev->ep[0];
+	int i, bytes, is_in;
+	u32 ep_ctrl;
+
+	/* Nuke all previous transfers */
+	nuke(ep, -EPROTO);
+
+	/* read control req from fifo (8 bytes) */
+	bytes = s3c_fifo_read(ep, (u32 *)&usb_ctrl, 8);
+
+	DEBUG_SETUP("Read CTRL REQ %d bytes\n", bytes);
+	DEBUG_SETUP("  CTRL.bRequestType = 0x%x (is_in %d)\n", usb_ctrl.bRequestType,
+		    usb_ctrl.bRequestType & USB_DIR_IN);
+	DEBUG_SETUP("  CTRL.bRequest = 0x%x\n", usb_ctrl.bRequest);
+	DEBUG_SETUP("  CTRL.wLength = 0x%x\n", usb_ctrl.wLength);
+	DEBUG_SETUP("  CTRL.wValue = 0x%x (%d)\n", usb_ctrl.wValue, usb_ctrl.wValue >> 8);
+	DEBUG_SETUP("  CTRL.wIndex = 0x%x\n", usb_ctrl.wIndex);
+
+	/* Set direction of EP0 */
+	if (likely(usb_ctrl.bRequestType & USB_DIR_IN)) {
+		ep->bEndpointAddress |= USB_DIR_IN;
+		is_in = 1;
+	} else {
+		ep->bEndpointAddress &= ~USB_DIR_IN;
+		is_in = 0;
+	}
+
+	dev->req_pending = 1;
+
+	/* Handle some SETUP packets ourselves */
+	switch (usb_ctrl.bRequest) {
+		case USB_REQ_SET_ADDRESS:
+			if (usb_ctrl.bRequestType
+				!= (USB_TYPE_STANDARD | USB_RECIP_DEVICE))
+				break;
+
+			DEBUG_SETUP("%s: *** USB_REQ_SET_ADDRESS (%d)\n",
+					__FUNCTION__, usb_ctrl.wValue);
+			udc_set_address(dev, usb_ctrl.wValue);
+			return;
+
+		case USB_REQ_SET_CONFIGURATION :
+			DEBUG_SETUP("============================================\n");
+			DEBUG_SETUP("%s: USB_REQ_SET_CONFIGURATION (%d)\n",
+					__FUNCTION__, usb_ctrl.wValue);
+config_change:
+			// Just to send ZLP(Zero length Packet) to HOST in response to SET CONFIGURATION
+			ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL0);
+			writel(DEPCTL_EPENA|DEPCTL_CNAK|ep_ctrl, S3C_UDC_OTG_DIEPCTL0); /* EP0: Control IN */
+
+			// For Startng EP1 on this new configuration
+			ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL1);
+			writel(DEPCTL_EPDIS|DEPCTL_CNAK|DEPCTL_BULK_TYPE|DEPCTL_USBACTEP|ep_ctrl, S3C_UDC_OTG_DOEPCTL1); /* EP1: Bulk OUT */
+
+			// For starting EP2 on this new configuration
+			ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL2);
+			writel(DEPCTL_BULK_TYPE|DEPCTL_USBACTEP|ep_ctrl, S3C_UDC_OTG_DIEPCTL2); /* EP2: Bulk IN */
+
+			// For starting EP3 on this new configuration
+			ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL3);
+			writel(DEPCTL_BULK_TYPE|DEPCTL_USBACTEP|ep_ctrl, S3C_UDC_OTG_DIEPCTL3); /* EP3: INTR IN */
+
+			DEBUG_SETUP("%s:(DOEPCTL1):0x%x, (DIEPCTL2):0x%x, (DIEPCTL3):0x%x\n",
+				__FUNCTION__,
+				readl(S3C_UDC_OTG_DOEPCTL1),
+				readl(S3C_UDC_OTG_DIEPCTL2),
+				readl(S3C_UDC_OTG_DIEPCTL3));
+
+			DEBUG_SETUP("============================================\n");
+
+			reset_available = 1;
+			dev->req_config = 1;
+			break;
+
+		case USB_REQ_GET_DESCRIPTOR:
+			DEBUG_SETUP("%s: *** USB_REQ_GET_DESCRIPTOR  \n",__FUNCTION__);
+			break;
+
+		case USB_REQ_SET_INTERFACE:
+			DEBUG_SETUP("%s: *** USB_REQ_SET_INTERFACE (%d)\n",
+					__FUNCTION__, usb_ctrl.wValue);
+
+			set_interface_first = 1;
+			goto config_change;
+			break;
+
+		case USB_REQ_GET_CONFIGURATION:
+			DEBUG_SETUP("%s: *** USB_REQ_GET_CONFIGURATION  \n",__FUNCTION__);
+			break;
+
+		case USB_REQ_GET_STATUS:
+			DEBUG_SETUP("%s: *** USB_REQ_GET_STATUS  \n",__FUNCTION__);
+			break;
+
+		default:
+			DEBUG_SETUP("%s: *** Default of usb_ctrl.bRequest=0x%x happened.\n",
+					__FUNCTION__, usb_ctrl.bRequest);
+			break;
+	}
+
+	if (likely(dev->driver)) {
+		/* device-2-host (IN) or no data setup command,
+		 * process immediately */
+		spin_unlock(&dev->lock);
+		DEBUG_SETUP("%s: ctrlrequest will be passed to fsg_setup()\n", __FUNCTION__);
+		i = dev->driver->setup(&dev->gadget, (struct usb_ctrlrequest *)&usb_ctrl);
+		spin_lock(&dev->lock);
+
+		if (i < 0) {
+			/* setup processing failed, force stall */
+			DEBUG_SETUP("%s: gadget setup FAILED (stalling), setup returned %d\n",
+				__FUNCTION__, i);
+			/* ep->stopped = 1; */
+			dev->ep0state = WAIT_FOR_SETUP;
+		}
+	}
+}
+
+/*
+ * handle ep0 interrupt
+ */
+static void s3c_handle_ep0(struct s3c_udc *dev)
+{
+	if (dev->ep0state == WAIT_FOR_SETUP) {
+		DEBUG_EP0("%s: WAIT_FOR_SETUP\n", __FUNCTION__);
+		s3c_ep0_setup(dev);
+
+	} else {
+		DEBUG_EP0("%s: strange state!!(state = %s)\n",
+			__FUNCTION__, state_names[dev->ep0state]);
+	}
+}
+
+static void s3c_ep0_kick(struct s3c_udc *dev, struct s3c_ep *ep)
+{
+	DEBUG_EP0("%s: ep_is_in = %d\n", __FUNCTION__, ep_is_in(ep));
+	if (ep_is_in(ep)) {
+		dev->ep0state = DATA_STATE_XMIT;
+		s3c_ep0_write(dev);
+	} else {
+		dev->ep0state = DATA_STATE_RECV;
+		s3c_ep0_read(dev);
+	}
+}
diff -uraN linux-3.0.8/drivers/usb/host/Kconfig linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/host/Kconfig
--- linux-3.0.8/drivers/usb/host/Kconfig	2021-07-14 21:52:04.543138430 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/host/Kconfig	2021-07-13 23:40:34.182359477 +0300
@@ -574,7 +574,22 @@
 	  Enable support for the Octeon II SOC's on-chip OHCI
 	  controller.  It is needed for low-speed USB 1.0 device
 	  support.  All CN6XXX based chips with USB are supported.
-
 config USB_OCTEON2_COMMON
 	bool
 	default y if USB_OCTEON_EHCI || USB_OCTEON_OHCI
+
+config USB_S3C_OTG_HOST
+	tristate "S3C USB OTG Host support"
+	depends on USB 
+	help
+	  Samsung's S3C64XX processors include high speed USB OTG2.0
+	  controller. It has 15 configurable endpoints, as well as
+	  endpoint zero (for control transfers).
+
+	  This driver support only OTG Host role. If you want to use
+	  OTG Device role, select USB Gadget support and S3C OTG Device.
+
+          Say "y" to link the driver statically, or "m" to build a
+          dynamically linked module called "s3c_otg_hcd" and force all
+          drivers to also be dynamically linked.
+	
diff -uraN linux-3.0.8/drivers/usb/host/ohci-hcd.c linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/host/ohci-hcd.c
--- linux-3.0.8/drivers/usb/host/ohci-hcd.c	2021-07-14 21:52:04.555138464 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/host/ohci-hcd.c	2021-07-13 23:40:34.182359477 +0300
@@ -1003,7 +1003,7 @@
 #define SA1111_DRIVER		ohci_hcd_sa1111_driver
 #endif
 
-#if defined(CONFIG_ARCH_S3C2410) || defined(CONFIG_ARCH_S3C64XX)
+#if  defined(CONFIG_ARCH_S3C2410) ||defined(CONFIG_ARCH_S3C64XX)
 #include "ohci-s3c2410.c"
 #define PLATFORM_DRIVER		ohci_hcd_s3c2410_driver
 #endif
diff -uraN linux-3.0.8/drivers/usb/host/ohci-s3c2410.c linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/host/ohci-s3c2410.c
--- linux-3.0.8/drivers/usb/host/ohci-s3c2410.c	2021-07-14 21:52:04.559138475 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/host/ohci-s3c2410.c	2021-07-13 23:40:34.158359329 +0300
@@ -21,14 +21,21 @@
 
 #include <linux/platform_device.h>
 #include <linux/clk.h>
-#include <plat/usb-control.h>
+
+#include <mach/hardware.h>
+#include <mach/usb-control.h>
 
 #define valid_port(idx) ((idx) == 1 || (idx) == 2)
 
+extern void usb_host_clk_en(void);
+
 /* clock device associated with the hcd */
 
 static struct clk *clk;
+
+#if defined(CONFIG_ARCH_2410)
 static struct clk *usb_clk;
+#endif
 
 /* forward definitions */
 
@@ -47,8 +54,10 @@
 
 	dev_dbg(&dev->dev, "s3c2410_start_hc:\n");
 
+#if defined(CONFIG_ARCH_2410)
 	clk_enable(usb_clk);
 	mdelay(2);			/* let the bus clock stabilise */
+#endif
 
 	clk_enable(clk);
 
@@ -56,8 +65,9 @@
 		info->hcd	= hcd;
 		info->report_oc = s3c2410_hcd_oc;
 
-		if (info->enable_oc != NULL)
+		if (info->enable_oc != NULL) {
 			(info->enable_oc)(info, 1);
+		}
 	}
 }
 
@@ -71,12 +81,15 @@
 		info->report_oc = NULL;
 		info->hcd	= NULL;
 
-		if (info->enable_oc != NULL)
+		if (info->enable_oc != NULL) {
 			(info->enable_oc)(info, 0);
+		}
 	}
 
 	clk_disable(clk);
+#if defined(CONFIG_ARCH_2410)
 	clk_disable(usb_clk);
+#endif
 }
 
 /* ohci_s3c2410_hub_status_data
@@ -86,14 +99,14 @@
 */
 
 static int
-ohci_s3c2410_hub_status_data(struct usb_hcd *hcd, char *buf)
+ohci_s3c2410_hub_status_data (struct usb_hcd *hcd, char *buf)
 {
 	struct s3c2410_hcd_info *info = to_s3c2410_info(hcd);
 	struct s3c2410_hcd_port *port;
 	int orig;
 	int portno;
 
-	orig  = ohci_hub_status_data(hcd, buf);
+	orig  = ohci_hub_status_data (hcd, buf);
 
 	if (info == NULL)
 		return orig;
@@ -143,7 +156,7 @@
  * request.
 */
 
-static int ohci_s3c2410_hub_control(
+static int ohci_s3c2410_hub_control (
 	struct usb_hcd	*hcd,
 	u16		typeReq,
 	u16		wValue,
@@ -197,8 +210,9 @@
 			dev_dbg(hcd->self.controller,
 				"ClearPortFeature: OVER_CURRENT\n");
 
-			if (valid_port(wIndex))
+			if (valid_port(wIndex)) {
 				info->port[wIndex-1].oc_status = 0;
+			}
 
 			goto out;
 
@@ -239,11 +253,8 @@
 		desc->wHubCharacteristics |= cpu_to_le16(0x0001);
 
 		if (info->enable_oc) {
-			desc->wHubCharacteristics &= ~cpu_to_le16(
-				HUB_CHAR_OCPM);
-			desc->wHubCharacteristics |=  cpu_to_le16(
-				0x0008 |
-				0x0001);
+			desc->wHubCharacteristics &= ~cpu_to_le16(HUB_CHAR_OCPM);
+			desc->wHubCharacteristics |=  cpu_to_le16(0x0008|0x0001);
 		}
 
 		dev_dbg(hcd->self.controller, "wHubCharacteristics after 0x%04x\n",
@@ -257,11 +268,13 @@
 		dev_dbg(hcd->self.controller, "GetPortStatus(%d)\n", wIndex);
 
 		if (valid_port(wIndex)) {
-			if (info->port[wIndex-1].oc_changed)
+			if (info->port[wIndex-1].oc_changed) {
 				*data |= cpu_to_le32(RH_PS_OCIC);
+			}
 
-			if (info->port[wIndex-1].oc_status)
+			if (info->port[wIndex-1].oc_status) {
 				*data |= cpu_to_le32(RH_PS_POCI);
+			}
 		}
 	}
 
@@ -319,7 +332,7 @@
 */
 
 static void
-usb_hcd_s3c2410_remove(struct usb_hcd *hcd, struct platform_device *dev)
+usb_hcd_s3c2410_remove (struct usb_hcd *hcd, struct platform_device *dev)
 {
 	usb_remove_hcd(hcd);
 	s3c2410_stop_hc(dev);
@@ -337,12 +350,16 @@
  * through the hotplug entry's driver_data.
  *
  */
-static int usb_hcd_s3c2410_probe(const struct hc_driver *driver,
+static int usb_hcd_s3c2410_probe (const struct hc_driver *driver,
 				  struct platform_device *dev)
 {
 	struct usb_hcd *hcd = NULL;
 	int retval;
 
+#if !defined(CONFIG_ARCH_2410)
+        usb_host_clk_en();
+#endif
+
 	s3c2410_usb_set_power(dev->dev.platform_data, 1, 1);
 	s3c2410_usb_set_power(dev->dev.platform_data, 2, 1);
 
@@ -351,7 +368,7 @@
 		return -ENOMEM;
 
 	hcd->rsrc_start = dev->resource[0].start;
-	hcd->rsrc_len	= resource_size(&dev->resource[0]);
+	hcd->rsrc_len   = dev->resource[0].end - dev->resource[0].start + 1;
 
 	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
 		dev_err(&dev->dev, "request_mem_region failed\n");
@@ -362,16 +379,18 @@
 	clk = clk_get(&dev->dev, "usb-host");
 	if (IS_ERR(clk)) {
 		dev_err(&dev->dev, "cannot get usb-host clock\n");
-		retval = PTR_ERR(clk);
+		retval = -ENOENT;
 		goto err_mem;
 	}
 
+#if defined(CONFIG_ARCH_2410)
 	usb_clk = clk_get(&dev->dev, "usb-bus-host");
 	if (IS_ERR(usb_clk)) {
-		dev_err(&dev->dev, "cannot get usb-bus-host clock\n");
-		retval = PTR_ERR(usb_clk);
+		dev_err(&dev->dev, "cannot get usb-host clock\n");
+		retval = -ENOENT;
 		goto err_clk;
 	}
+#endif
 
 	s3c2410_start_hc(dev, hcd);
 
@@ -393,10 +412,13 @@
  err_ioremap:
 	s3c2410_stop_hc(dev);
 	iounmap(hcd->regs);
+
+#if defined(CONFIG_ARCH_2410)
 	clk_put(usb_clk);
 
  err_clk:
 	clk_put(clk);
+#endif
 
  err_mem:
 	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
@@ -409,19 +431,17 @@
 /*-------------------------------------------------------------------------*/
 
 static int
-ohci_s3c2410_start(struct usb_hcd *hcd)
+ohci_s3c2410_start (struct usb_hcd *hcd)
 {
-	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
+	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 	int ret;
 
-	ret = ohci_init(ohci);
-	if (ret < 0)
+	if ((ret = ohci_init(ohci)) < 0)
 		return ret;
 
-	ret = ohci_run(ohci);
-	if (ret < 0) {
-		err("can't start %s", hcd->self.bus_name);
-		ohci_stop(hcd);
+	if ((ret = ohci_run (ohci)) < 0) {
+		err ("can't start %s", hcd->self.bus_name);
+		ohci_stop (hcd);
 		return ret;
 	}
 
@@ -473,12 +493,12 @@
 
 /* device driver */
 
-static int __devinit ohci_hcd_s3c2410_drv_probe(struct platform_device *pdev)
+static int ohci_hcd_s3c2410_drv_probe(struct platform_device *pdev)
 {
 	return usb_hcd_s3c2410_probe(&ohci_s3c2410_hc_driver, pdev);
 }
 
-static int __devexit ohci_hcd_s3c2410_drv_remove(struct platform_device *pdev)
+static int ohci_hcd_s3c2410_drv_remove(struct platform_device *pdev)
 {
 	struct usb_hcd *hcd = platform_get_drvdata(pdev);
 
@@ -488,7 +508,7 @@
 
 static struct platform_driver ohci_hcd_s3c2410_driver = {
 	.probe		= ohci_hcd_s3c2410_drv_probe,
-	.remove		= __devexit_p(ohci_hcd_s3c2410_drv_remove),
+	.remove		= ohci_hcd_s3c2410_drv_remove,
 	.shutdown	= usb_hcd_platform_shutdown,
 	/*.suspend	= ohci_hcd_s3c2410_drv_suspend, */
 	/*.resume	= ohci_hcd_s3c2410_drv_resume, */
diff -uraN linux-3.0.8/drivers/usb/Makefile linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/Makefile
--- linux-3.0.8/drivers/usb/Makefile	2021-07-14 21:52:04.503138314 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/usb/Makefile	2021-07-13 23:40:34.074358813 +0300
@@ -1,5 +1,5 @@
 #
-# Makefile for the kernel USB device drivers.
+#akefile for the kernel USB device drivers.
 #
 
 # Object files in subdirectories
@@ -23,7 +23,7 @@
 obj-$(CONFIG_USB_ISP1760_HCD)	+= host/
 obj-$(CONFIG_USB_IMX21_HCD)	+= host/
 obj-$(CONFIG_USB_FSL_MPH_DR_OF)	+= host/
-
+obj-$(CONFIG_USB_S3C_OTG_HOST)	+= host/
 obj-$(CONFIG_USB_C67X00_HCD)	+= c67x00/
 
 obj-$(CONFIG_USB_WUSB)		+= wusbcore/
diff -uraN linux-3.0.8/drivers/watchdog/fh_wdt.c linux-3.0.8-fh8632-V1.0_20180330/drivers/watchdog/fh_wdt.c
--- linux-3.0.8/drivers/watchdog/fh_wdt.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/watchdog/fh_wdt.c	2021-07-13 23:40:34.346360486 +0300
@@ -0,0 +1,461 @@
+/*
+ * Copyright 2010-2011 Picochip Ltd., Jamie Iles
+ * http://www.picochip.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * This file implements a driver for the Synopsys DesignWare watchdog device
+ * in the many ARM subsystems. The watchdog has 16 different timeout periods
+ * and these are a function of the input clock frequency.
+ *
+ * The DesignWare watchdog cannot be stopped once it has been started so we
+ * use a software timer to implement a ping that will keep the watchdog alive.
+ * If we receive an expected close for the watchdog then we keep the timer
+ * running, otherwise the timer is stopped and the watchdog will expire.
+ */
+#define pr_fmt(fmt) "fh_wdt: " fmt
+
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/fs.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/pm.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/timer.h>
+#include <linux/uaccess.h>
+#include <linux/watchdog.h>
+#include <linux/interrupt.h>
+#include <mach/pmu.h>
+#include <mach/fh_wdt.h>
+
+#define WDT_RESPONSE_MODE
+
+#define WDOG_CONTROL_REG_OFFSET		    			 0x00
+#define WDOG_CONTROL_REG_WDT_EN_MASK	  		 0x01
+#define WDOG_CONTROL_REG_RMOD_MASK               0x02
+#define WDOG_TIMEOUT_RANGE_REG_OFFSET	         0x04
+#define WDOG_CURRENT_COUNT_REG_OFFSET	         0x08
+#define WDOG_COUNTER_RESTART_REG_OFFSET       0x0c
+#define WDOG_COUNTER_RESTART_KICK_VALUE	     0x76
+
+/* Hardware timeout in seconds */
+#define WDT_HW_TIMEOUT 2
+/* User land timeout */
+#define WDT_HEARTBEAT 15
+static int heartbeat = WDT_HEARTBEAT;
+
+/* The maximum TOP (timeout period) value that can be set in the watchdog. */
+#define FH_WDT_MAX_TOP		15
+
+static int curr_top_val = FH_WDT_MAX_TOP;
+static int curr_clk_rate = 1800000;
+static int nowayout = WATCHDOG_NOWAYOUT;
+module_param(nowayout, int, 0);
+MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started "
+		 "(default=" __MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
+
+#define WDT_TIMEOUT		(HZ / 2)
+
+static struct {
+	spinlock_t		lock;
+	void __iomem		*regs;
+	struct clk		*clk;
+	unsigned long		in_use;
+	unsigned long		next_heartbeat;
+	struct timer_list	timer;
+	int			expect_close;
+	struct fh_wdt_platform_data *plat_data;
+} fh_wdt;
+
+static inline int fh_wdt_is_enabled(void)
+{
+	return readl(fh_wdt.regs + WDOG_CONTROL_REG_OFFSET) &
+		WDOG_CONTROL_REG_WDT_EN_MASK;
+}
+
+//#define WDT_CLOCK 1800000
+#define WDT_CLOCK clk_get_rate(fh_wdt.clk)
+
+static inline int fh_wdt_top_in_seconds(unsigned top)
+{
+	/*
+	 * There are 16 possible timeout values in 0..15 where the number of
+	 * cycles is 2 ^ (16 + i) and the watchdog counts down.
+	 */
+	return (1 << (16 + top)) / WDT_CLOCK;
+}
+
+static inline void fh_wdt_set_next_heartbeat(void)
+{
+	fh_wdt.next_heartbeat = jiffies + heartbeat * HZ;
+}
+
+static int fh_wdt_set_top(unsigned top_s)
+{
+	int i, top_val = FH_WDT_MAX_TOP;
+
+	/*
+	 * Iterate over the timeout values until we find the closest match. We
+	 * always look for >=.
+	 */
+
+	for (i = 0; i <= FH_WDT_MAX_TOP; ++i)
+		if (fh_wdt_top_in_seconds(i) >= top_s) {
+			top_val = i;
+			break;
+		}
+
+	/* Set the new value in the watchdog. */
+	printk("[wdt] set topval: %d", top_val);
+	writel(top_val, fh_wdt.regs + WDOG_TIMEOUT_RANGE_REG_OFFSET);
+
+	fh_wdt_set_next_heartbeat();
+
+	return fh_wdt_top_in_seconds(top_val);
+}
+
+static void fh_wdt_keepalive(void)
+{
+	writel(WDOG_COUNTER_RESTART_KICK_VALUE, fh_wdt.regs +
+	       WDOG_COUNTER_RESTART_REG_OFFSET);
+}
+
+static void fh_wdt_ping(unsigned long data)
+{
+	if (time_before(jiffies, fh_wdt.next_heartbeat) ||
+	    (!nowayout && !fh_wdt.in_use)) {
+		fh_wdt_keepalive();
+		mod_timer(&fh_wdt.timer, jiffies + WDT_TIMEOUT);
+	} else
+		pr_crit("keepalive missed, machine will reset\n");
+}
+
+static int fh_wdt_open(struct inode *inode, struct file *filp)
+{
+	if (test_and_set_bit(0, &fh_wdt.in_use))
+		return -EBUSY;
+
+	/* Make sure we don't get unloaded. */
+	__module_get(THIS_MODULE);
+
+	spin_lock(&fh_wdt.lock);
+
+	if(fh_wdt.plat_data && fh_wdt.plat_data->resume)
+		fh_wdt.plat_data->resume();
+
+	fh_wdt_set_top(WDT_HW_TIMEOUT);///3000);
+	if (!fh_wdt_is_enabled())
+	{
+        /*
+         * The watchdog is not currently enabled. Set the timeout to
+         * the maximum and then start it.
+         */
+	    u32 value;
+	    value = WDOG_CONTROL_REG_WDT_EN_MASK;
+#ifdef WDT_RESPONSE_MODE
+	    value |= WDOG_CONTROL_REG_RMOD_MASK;
+#endif
+		writel(value, fh_wdt.regs + WDOG_CONTROL_REG_OFFSET);
+		fh_wdt_keepalive();
+	}
+
+	fh_wdt_set_next_heartbeat();
+
+	spin_unlock(&fh_wdt.lock);
+
+	return nonseekable_open(inode, filp);
+}
+
+ssize_t fh_wdt_write(struct file *filp, const char __user *buf, size_t len,
+		     loff_t *offset)
+{
+	if (!len)
+		return 0;
+
+	if (!nowayout) {
+		size_t i;
+
+		fh_wdt.expect_close = 0;
+
+		for (i = 0; i < len; ++i) {
+			char c;
+
+			if (get_user(c, buf + i))
+				return -EFAULT;
+
+			if (c == 'V') {
+				fh_wdt.expect_close = 1;
+				break;
+			}
+		}
+	}
+
+	fh_wdt_set_next_heartbeat();
+	mod_timer(&fh_wdt.timer, jiffies + WDT_TIMEOUT);
+
+	return len;
+}
+
+static u32 fh_wdt_time_left(void)
+{
+	return readl(fh_wdt.regs + WDOG_CURRENT_COUNT_REG_OFFSET) /
+			WDT_CLOCK;
+}
+
+static const struct watchdog_info fh_wdt_ident = {
+	.options	= WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT |
+			  WDIOF_MAGICCLOSE,
+	.identity	= "Synopsys DesignWare Watchdog",
+};
+
+static long fh_wdt_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	unsigned long val;
+
+	switch (cmd) {
+	case WDIOC_GETSUPPORT:
+		return copy_to_user((struct watchdog_info *)arg, &fh_wdt_ident,
+				    sizeof(fh_wdt_ident)) ? -EFAULT : 0;
+
+	case WDIOC_GETSTATUS:
+	case WDIOC_GETBOOTSTATUS:
+		return put_user(0, (int *)arg);
+
+	case WDIOC_KEEPALIVE:
+		fh_wdt_set_next_heartbeat();
+		return 0;
+
+	case WDIOC_SETTIMEOUT:
+		if (get_user(val, (int __user *)arg))
+			return -EFAULT;
+
+		pr_debug("[wdt] settime value %lu", val);
+		heartbeat =  val;
+		fh_wdt_keepalive();
+		fh_wdt_set_next_heartbeat();
+
+		return put_user(val , (int __user *)arg);
+
+	case WDIOC_GETTIMEOUT:
+		return put_user(heartbeat, (int __user *)arg);
+
+	case WDIOC_GETTIMELEFT:
+		/* Get the time left until expiry. */
+		if (get_user(val, (int __user *)arg))
+			return -EFAULT;
+		return put_user(fh_wdt_time_left(), (int __user *)arg);
+
+	case WDIOC_SETOPTIONS:
+		if (get_user(val, (int __user *)arg))
+			return -EFAULT;
+
+		if (val & WDIOS_DISABLECARD) {
+			if(fh_wdt.plat_data && fh_wdt.plat_data->pause)
+				fh_wdt.plat_data->pause();
+			else
+				return -EPERM;
+		}
+
+		if (val & WDIOS_ENABLECARD) {
+			if(fh_wdt.plat_data && fh_wdt.plat_data->resume)
+				fh_wdt.plat_data->resume();
+			else
+				return -EPERM;
+		}
+
+		return 0;
+
+	default:
+		return -ENOTTY;
+	}
+}
+
+#ifdef WDT_RESPONSE_MODE
+static irqreturn_t fh_wdt_interrupt(int this_irq, void *dev_id)
+{
+    fh_pmu_stop();
+    return IRQ_HANDLED;
+}
+#endif
+
+static int fh_wdt_release(struct inode *inode, struct file *filp)
+{
+	clear_bit(0, &fh_wdt.in_use);
+
+	if (!fh_wdt.expect_close) {
+		del_timer(&fh_wdt.timer);
+		if (!nowayout)
+			pr_crit("unexpected close, system will reboot soon\n");
+		else
+			pr_crit("watchdog cannot be disabled, system will reboot soon\n");
+	}
+
+	fh_wdt.expect_close = 0;
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int fh_wdt_suspend(struct device *dev)
+{
+	clk_disable(fh_wdt.clk);
+	curr_top_val = readl(fh_wdt.regs + WDOG_TIMEOUT_RANGE_REG_OFFSET) & 0xf;
+	writel(FH_WDT_MAX_TOP, fh_wdt.regs + WDOG_TIMEOUT_RANGE_REG_OFFSET);
+    curr_clk_rate = WDT_CLOCK;
+    //clk_get_rate(fh_wdt.clk->parent) / fh_wdt.clk->prediv / fh_wdt.clk->div_reg_mask >> reg_shift
+    //clk_set_rate(fh_wdt.clk, 0xffffffff);
+    clk_set_rate(fh_wdt.clk, 843750);   /* 1800000 / 256 = 210937.5*/
+	fh_wdt_keepalive();
+
+	return 0;
+}
+
+static int fh_wdt_resume(struct device *dev)
+{
+    int err;
+
+    clk_set_rate(fh_wdt.clk, curr_clk_rate);
+	err = clk_enable(fh_wdt.clk);
+	writel(curr_top_val, fh_wdt.regs + WDOG_TIMEOUT_RANGE_REG_OFFSET);
+
+	if (err)
+	{
+	    pr_err("an error occured during wdt resume, error no: %d\n", err);
+		return err;
+	}
+
+	fh_wdt_keepalive();
+
+	return 0;
+}
+
+static const struct dev_pm_ops fh_wdt_pm_ops = {
+	.suspend	= fh_wdt_suspend,
+	.resume		= fh_wdt_resume,
+};
+#endif /* CONFIG_PM */
+
+static const struct file_operations wdt_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.open		= fh_wdt_open,
+	.write		= fh_wdt_write,
+	.unlocked_ioctl	= fh_wdt_ioctl,
+	.release	= fh_wdt_release
+};
+
+static struct miscdevice fh_wdt_miscdev = {
+	.fops		= &wdt_fops,
+	.name		= "watchdog",
+	.minor		= WATCHDOG_MINOR,
+};
+
+static int __devinit fh_wdt_drv_probe(struct platform_device *pdev)
+{
+	int ret, irq;
+	struct resource *mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	if (!mem)
+		return -EINVAL;
+
+	if (!devm_request_mem_region(&pdev->dev, mem->start, resource_size(mem),
+				     "fh_wdt"))
+		return -ENOMEM;
+
+	fh_wdt.regs = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));
+	if (!fh_wdt.regs)
+		return -ENOMEM;
+#ifdef WDT_RESPONSE_MODE
+    irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+        dev_err(&pdev->dev, "no irq resource\n");
+        return -ENXIO;
+    }
+
+	ret = request_irq(irq, fh_wdt_interrupt, IRQF_DISABLED, pdev->name,
+			&fh_wdt);
+	if (ret) {
+		dev_err(&pdev->dev, "failure requesting irq %i\n", irq);
+        return -ENXIO;
+    }
+#endif
+
+	fh_wdt.plat_data = dev_get_platdata(&pdev->dev);
+	fh_wdt.clk = clk_get( NULL,"wdt_clk");
+	if (IS_ERR(fh_wdt.clk))
+		return PTR_ERR(fh_wdt.clk);
+
+	clk_set_rate(fh_wdt.clk, 1000000);
+
+	ret = clk_enable(fh_wdt.clk);
+	if (ret)
+		goto out_put_clk;
+
+	spin_lock_init(&fh_wdt.lock);
+
+	ret = misc_register(&fh_wdt_miscdev);
+	if (ret)
+		goto out_disable_clk;
+
+	fh_wdt_set_next_heartbeat();
+	setup_timer(&fh_wdt.timer, fh_wdt_ping, 0);
+	mod_timer(&fh_wdt.timer, jiffies + WDT_TIMEOUT);
+
+	return 0;
+
+out_disable_clk:
+	clk_disable(fh_wdt.clk);
+out_put_clk:
+	clk_put(fh_wdt.clk);
+
+	return ret;
+}
+
+static int __devexit fh_wdt_drv_remove(struct platform_device *pdev)
+{
+	misc_deregister(&fh_wdt_miscdev);
+
+	clk_disable(fh_wdt.clk);
+	clk_put(fh_wdt.clk);
+
+	return 0;
+}
+
+static struct platform_driver fh_wdt_driver = {
+	.probe		= fh_wdt_drv_probe,
+	.remove		= __devexit_p(fh_wdt_drv_remove),
+	.driver		= {
+		.name	= "fh_wdt",
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_PM
+		.pm	= &fh_wdt_pm_ops,
+#endif /* CONFIG_PM */
+	},
+};
+
+static int __init fh_wdt_watchdog_init(void)
+{
+	return platform_driver_register(&fh_wdt_driver);
+}
+module_init(fh_wdt_watchdog_init);
+
+static void __exit fh_wdt_watchdog_exit(void)
+{
+	platform_driver_unregister(&fh_wdt_driver);
+}
+module_exit(fh_wdt_watchdog_exit);
+
+MODULE_AUTHOR("fullhan");
+MODULE_DESCRIPTION("Synopsys DesignWare Watchdog Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
diff -uraN linux-3.0.8/drivers/watchdog/Kconfig linux-3.0.8-fh8632-V1.0_20180330/drivers/watchdog/Kconfig
--- linux-3.0.8/drivers/watchdog/Kconfig	2021-07-14 21:52:04.787139136 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/watchdog/Kconfig	2021-07-13 23:40:34.350360510 +0300
@@ -606,7 +606,14 @@
 	  will only load on an HP ProLiant system with a minimum of iLO2 support.
 	  To compile this driver as a module, choose M here: the module will be
 	  called hpwdt.
-
+	  
+config FH_WATCHDOG
+	tristate "fullhan  watchdog driver"
+	
+	help
+	  A software monitoring watchdog and NMI sourcing driver. 
+	  
+	  
 config HPWDT_NMI_DECODING
 	bool "NMI decoding support for the HP ProLiant iLO2+ Hardware Watchdog Timer"
 	depends on HP_WATCHDOG
diff -uraN linux-3.0.8/drivers/watchdog/Makefile linux-3.0.8-fh8632-V1.0_20180330/drivers/watchdog/Makefile
--- linux-3.0.8/drivers/watchdog/Makefile	2021-07-14 21:52:04.787139136 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/drivers/watchdog/Makefile	2021-07-13 23:40:34.342360461 +0300
@@ -49,6 +49,7 @@
 obj-$(CONFIG_ADX_WATCHDOG) += adx_wdt.o
 obj-$(CONFIG_TS72XX_WATCHDOG) += ts72xx_wdt.o
 obj-$(CONFIG_IMX2_WDT) += imx2_wdt.o
+obj-$(CONFIG_FH_WATCHDOG) += fh_wdt.o
 
 # AVR32 Architecture
 obj-$(CONFIG_AT32AP700X_WDT) += at32ap700x_wdt.o
diff -uraN linux-3.0.8/fs/Kconfig linux-3.0.8-fh8632-V1.0_20180330/fs/Kconfig
--- linux-3.0.8/fs/Kconfig	2021-07-14 21:52:04.871139379 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/Kconfig	2021-07-13 23:40:33.970358169 +0300
@@ -192,6 +192,7 @@
 source "fs/befs/Kconfig"
 source "fs/bfs/Kconfig"
 source "fs/efs/Kconfig"
+source "fs/yaffs2/Kconfig"
 source "fs/jffs2/Kconfig"
 # UBIFS File system configuration
 source "fs/ubifs/Kconfig"
diff -uraN linux-3.0.8/fs/Kconfig.pre.yaffs linux-3.0.8-fh8632-V1.0_20180330/fs/Kconfig.pre.yaffs
--- linux-3.0.8/fs/Kconfig.pre.yaffs	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/Kconfig.pre.yaffs	2021-07-13 23:40:34.022358493 +0300
@@ -0,0 +1,273 @@
+#
+# File system configuration
+#
+
+menu "File systems"
+
+if BLOCK
+
+source "fs/ext2/Kconfig"
+source "fs/ext3/Kconfig"
+source "fs/ext4/Kconfig"
+
+config FS_XIP
+# execute in place
+	bool
+	depends on EXT2_FS_XIP
+	default y
+
+source "fs/jbd/Kconfig"
+source "fs/jbd2/Kconfig"
+
+config FS_MBCACHE
+# Meta block cache for Extended Attributes (ext2/ext3/ext4)
+	tristate
+	default y if EXT2_FS=y && EXT2_FS_XATTR
+	default y if EXT3_FS=y && EXT3_FS_XATTR
+	default y if EXT4_FS=y && EXT4_FS_XATTR
+	default m if EXT2_FS_XATTR || EXT3_FS_XATTR || EXT4_FS_XATTR
+
+source "fs/reiserfs/Kconfig"
+source "fs/jfs/Kconfig"
+
+source "fs/xfs/Kconfig"
+source "fs/gfs2/Kconfig"
+source "fs/ocfs2/Kconfig"
+source "fs/btrfs/Kconfig"
+source "fs/nilfs2/Kconfig"
+
+endif # BLOCK
+
+# Posix ACL utility routines
+#
+# Note: Posix ACLs can be implemented without these helpers.  Never use
+# this symbol for ifdefs in core code.
+#
+config FS_POSIX_ACL
+	def_bool n
+
+config EXPORTFS
+	tristate
+
+config FILE_LOCKING
+	bool "Enable POSIX file locking API" if EXPERT
+	default y
+	help
+	  This option enables standard file locking support, required
+          for filesystems like NFS and for the flock() system
+          call. Disabling this option saves about 11k.
+
+source "fs/notify/Kconfig"
+
+source "fs/quota/Kconfig"
+
+source "fs/autofs4/Kconfig"
+source "fs/fuse/Kconfig"
+
+config CUSE
+	tristate "Character device in Userspace support"
+	depends on FUSE_FS
+	help
+	  This FUSE extension allows character devices to be
+	  implemented in userspace.
+
+	  If you want to develop or use userspace character device
+	  based on CUSE, answer Y or M.
+
+config GENERIC_ACL
+	bool
+	select FS_POSIX_ACL
+
+menu "Caches"
+
+source "fs/fscache/Kconfig"
+source "fs/cachefiles/Kconfig"
+
+endmenu
+
+if BLOCK
+menu "CD-ROM/DVD Filesystems"
+
+source "fs/isofs/Kconfig"
+source "fs/udf/Kconfig"
+
+endmenu
+endif # BLOCK
+
+if BLOCK
+menu "DOS/FAT/NT Filesystems"
+
+source "fs/fat/Kconfig"
+source "fs/ntfs/Kconfig"
+
+endmenu
+endif # BLOCK
+
+menu "Pseudo filesystems"
+
+source "fs/proc/Kconfig"
+source "fs/sysfs/Kconfig"
+
+config TMPFS
+	bool "Virtual memory file system support (former shm fs)"
+	depends on SHMEM
+	help
+	  Tmpfs is a file system which keeps all files in virtual memory.
+
+	  Everything in tmpfs is temporary in the sense that no files will be
+	  created on your hard drive. The files live in memory and swap
+	  space. If you unmount a tmpfs instance, everything stored therein is
+	  lost.
+
+	  See <file:Documentation/filesystems/tmpfs.txt> for details.
+
+config TMPFS_POSIX_ACL
+	bool "Tmpfs POSIX Access Control Lists"
+	depends on TMPFS
+	select TMPFS_XATTR
+	select GENERIC_ACL
+	help
+	  POSIX Access Control Lists (ACLs) support permissions for users and
+	  groups beyond the owner/group/world scheme.
+
+	  To learn more about Access Control Lists, visit the POSIX ACLs for
+	  Linux website <http://acl.bestbits.at/>.
+
+	  If you don't know what Access Control Lists are, say N.
+
+config TMPFS_XATTR
+	bool "Tmpfs extended attributes"
+	depends on TMPFS
+	default n
+	help
+	  Extended attributes are name:value pairs associated with inodes by
+	  the kernel or by users (see the attr(5) manual page, or visit
+	  <http://acl.bestbits.at/> for details).
+
+	  Currently this enables support for the trusted.* and
+	  security.* namespaces.
+
+	  You need this for POSIX ACL support on tmpfs.
+
+	  If unsure, say N.
+
+config HUGETLBFS
+	bool "HugeTLB file system support"
+	depends on X86 || IA64 || SPARC64 || (S390 && 64BIT) || \
+		   SYS_SUPPORTS_HUGETLBFS || BROKEN
+	help
+	  hugetlbfs is a filesystem backing for HugeTLB pages, based on
+	  ramfs. For architectures that support it, say Y here and read
+	  <file:Documentation/vm/hugetlbpage.txt> for details.
+
+	  If unsure, say N.
+
+config HUGETLB_PAGE
+	def_bool HUGETLBFS
+
+source "fs/configfs/Kconfig"
+
+endmenu
+
+menuconfig MISC_FILESYSTEMS
+	bool "Miscellaneous filesystems"
+	default y
+	---help---
+	  Say Y here to get to see options for various miscellaneous
+	  filesystems, such as filesystems that came from other
+	  operating systems.
+
+	  This option alone does not add any kernel code.
+
+	  If you say N, all options in this submenu will be skipped and
+	  disabled; if unsure, say Y here.
+
+if MISC_FILESYSTEMS
+
+source "fs/adfs/Kconfig"
+source "fs/affs/Kconfig"
+source "fs/ecryptfs/Kconfig"
+source "fs/hfs/Kconfig"
+source "fs/hfsplus/Kconfig"
+source "fs/befs/Kconfig"
+source "fs/bfs/Kconfig"
+source "fs/efs/Kconfig"
+source "fs/jffs2/Kconfig"
+# UBIFS File system configuration
+source "fs/ubifs/Kconfig"
+source "fs/logfs/Kconfig"
+source "fs/cramfs/Kconfig"
+source "fs/squashfs/Kconfig"
+source "fs/freevxfs/Kconfig"
+source "fs/minix/Kconfig"
+source "fs/omfs/Kconfig"
+source "fs/hpfs/Kconfig"
+source "fs/qnx4/Kconfig"
+source "fs/romfs/Kconfig"
+source "fs/pstore/Kconfig"
+source "fs/sysv/Kconfig"
+source "fs/ufs/Kconfig"
+source "fs/exofs/Kconfig"
+
+endif # MISC_FILESYSTEMS
+
+menuconfig NETWORK_FILESYSTEMS
+	bool "Network File Systems"
+	default y
+	depends on NET
+	---help---
+	  Say Y here to get to see options for network filesystems and
+	  filesystem-related networking code, such as NFS daemon and
+	  RPCSEC security modules.
+
+	  This option alone does not add any kernel code.
+
+	  If you say N, all options in this submenu will be skipped and
+	  disabled; if unsure, say Y here.
+
+if NETWORK_FILESYSTEMS
+
+source "fs/nfs/Kconfig"
+source "fs/nfsd/Kconfig"
+
+config LOCKD
+	tristate
+	depends on FILE_LOCKING
+
+config LOCKD_V4
+	bool
+	depends on NFSD_V3 || NFS_V3
+	depends on FILE_LOCKING
+	default y
+
+config NFS_ACL_SUPPORT
+	tristate
+	select FS_POSIX_ACL
+
+config NFS_COMMON
+	bool
+	depends on NFSD || NFS_FS
+	default y
+
+source "net/sunrpc/Kconfig"
+source "fs/ceph/Kconfig"
+source "fs/cifs/Kconfig"
+source "fs/ncpfs/Kconfig"
+source "fs/coda/Kconfig"
+source "fs/afs/Kconfig"
+source "fs/9p/Kconfig"
+
+endif # NETWORK_FILESYSTEMS
+
+if BLOCK
+menu "Partition Types"
+
+source "fs/partitions/Kconfig"
+
+endmenu
+endif
+
+source "fs/nls/Kconfig"
+source "fs/dlm/Kconfig"
+
+endmenu
diff -uraN linux-3.0.8/fs/Makefile linux-3.0.8-fh8632-V1.0_20180330/fs/Makefile
--- linux-3.0.8/fs/Makefile	2021-07-14 21:52:04.871139379 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/Makefile	2021-07-13 23:40:33.734356687 +0300
@@ -124,3 +124,4 @@
 obj-$(CONFIG_EXOFS_FS)          += exofs/
 obj-$(CONFIG_CEPH_FS)		+= ceph/
 obj-$(CONFIG_PSTORE)		+= pstore/
+obj-$(CONFIG_YAFFS_FS)		+= yaffs2/
diff -uraN linux-3.0.8/fs/Makefile.pre.yaffs linux-3.0.8-fh8632-V1.0_20180330/fs/Makefile.pre.yaffs
--- linux-3.0.8/fs/Makefile.pre.yaffs	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/Makefile.pre.yaffs	2021-07-13 23:40:33.802357114 +0300
@@ -0,0 +1,126 @@
+#
+# Makefile for the Linux filesystems.
+#
+# 14 Sep 2000, Christoph Hellwig <hch@infradead.org>
+# Rewritten to use lists instead of if-statements.
+# 
+
+obj-y :=	open.o read_write.o file_table.o super.o \
+		char_dev.o stat.o exec.o pipe.o namei.o fcntl.o \
+		ioctl.o readdir.o select.o fifo.o dcache.o inode.o \
+		attr.o bad_inode.o file.o filesystems.o namespace.o \
+		seq_file.o xattr.o libfs.o fs-writeback.o \
+		pnode.o drop_caches.o splice.o sync.o utimes.o \
+		stack.o fs_struct.o statfs.o
+
+ifeq ($(CONFIG_BLOCK),y)
+obj-y +=	buffer.o bio.o block_dev.o direct-io.o mpage.o ioprio.o
+else
+obj-y +=	no-block.o
+endif
+
+obj-$(CONFIG_BLK_DEV_INTEGRITY) += bio-integrity.o
+obj-y				+= notify/
+obj-$(CONFIG_EPOLL)		+= eventpoll.o
+obj-$(CONFIG_ANON_INODES)	+= anon_inodes.o
+obj-$(CONFIG_SIGNALFD)		+= signalfd.o
+obj-$(CONFIG_TIMERFD)		+= timerfd.o
+obj-$(CONFIG_EVENTFD)		+= eventfd.o
+obj-$(CONFIG_AIO)               += aio.o
+obj-$(CONFIG_FILE_LOCKING)      += locks.o
+obj-$(CONFIG_COMPAT)		+= compat.o compat_ioctl.o
+obj-$(CONFIG_NFSD_DEPRECATED)	+= nfsctl.o
+obj-$(CONFIG_BINFMT_AOUT)	+= binfmt_aout.o
+obj-$(CONFIG_BINFMT_EM86)	+= binfmt_em86.o
+obj-$(CONFIG_BINFMT_MISC)	+= binfmt_misc.o
+
+# binfmt_script is always there
+obj-y				+= binfmt_script.o
+
+obj-$(CONFIG_BINFMT_ELF)	+= binfmt_elf.o
+obj-$(CONFIG_COMPAT_BINFMT_ELF)	+= compat_binfmt_elf.o
+obj-$(CONFIG_BINFMT_ELF_FDPIC)	+= binfmt_elf_fdpic.o
+obj-$(CONFIG_BINFMT_SOM)	+= binfmt_som.o
+obj-$(CONFIG_BINFMT_FLAT)	+= binfmt_flat.o
+
+obj-$(CONFIG_FS_MBCACHE)	+= mbcache.o
+obj-$(CONFIG_FS_POSIX_ACL)	+= posix_acl.o xattr_acl.o
+obj-$(CONFIG_NFS_COMMON)	+= nfs_common/
+obj-$(CONFIG_GENERIC_ACL)	+= generic_acl.o
+
+obj-$(CONFIG_FHANDLE)		+= fhandle.o
+
+obj-y				+= quota/
+
+obj-$(CONFIG_PROC_FS)		+= proc/
+obj-y				+= partitions/
+obj-$(CONFIG_SYSFS)		+= sysfs/
+obj-$(CONFIG_CONFIGFS_FS)	+= configfs/
+obj-y				+= devpts/
+
+obj-$(CONFIG_PROFILING)		+= dcookies.o
+obj-$(CONFIG_DLM)		+= dlm/
+ 
+# Do not add any filesystems before this line
+obj-$(CONFIG_FSCACHE)		+= fscache/
+obj-$(CONFIG_REISERFS_FS)	+= reiserfs/
+obj-$(CONFIG_EXT3_FS)		+= ext3/ # Before ext2 so root fs can be ext3
+obj-$(CONFIG_EXT2_FS)		+= ext2/
+# We place ext4 after ext2 so plain ext2 root fs's are mounted using ext2
+# unless explicitly requested by rootfstype
+obj-$(CONFIG_EXT4_FS)		+= ext4/
+obj-$(CONFIG_JBD)		+= jbd/
+obj-$(CONFIG_JBD2)		+= jbd2/
+obj-$(CONFIG_CRAMFS)		+= cramfs/
+obj-$(CONFIG_SQUASHFS)		+= squashfs/
+obj-y				+= ramfs/
+obj-$(CONFIG_HUGETLBFS)		+= hugetlbfs/
+obj-$(CONFIG_CODA_FS)		+= coda/
+obj-$(CONFIG_MINIX_FS)		+= minix/
+obj-$(CONFIG_FAT_FS)		+= fat/
+obj-$(CONFIG_BFS_FS)		+= bfs/
+obj-$(CONFIG_ISO9660_FS)	+= isofs/
+obj-$(CONFIG_HFSPLUS_FS)	+= hfsplus/ # Before hfs to find wrapped HFS+
+obj-$(CONFIG_HFS_FS)		+= hfs/
+obj-$(CONFIG_ECRYPT_FS)		+= ecryptfs/
+obj-$(CONFIG_VXFS_FS)		+= freevxfs/
+obj-$(CONFIG_NFS_FS)		+= nfs/
+obj-$(CONFIG_EXPORTFS)		+= exportfs/
+obj-$(CONFIG_NFSD)		+= nfsd/
+obj-$(CONFIG_LOCKD)		+= lockd/
+obj-$(CONFIG_NLS)		+= nls/
+obj-$(CONFIG_SYSV_FS)		+= sysv/
+obj-$(CONFIG_CIFS)		+= cifs/
+obj-$(CONFIG_NCP_FS)		+= ncpfs/
+obj-$(CONFIG_HPFS_FS)		+= hpfs/
+obj-$(CONFIG_NTFS_FS)		+= ntfs/
+obj-$(CONFIG_UFS_FS)		+= ufs/
+obj-$(CONFIG_EFS_FS)		+= efs/
+obj-$(CONFIG_JFFS2_FS)		+= jffs2/
+obj-$(CONFIG_LOGFS)		+= logfs/
+obj-$(CONFIG_UBIFS_FS)		+= ubifs/
+obj-$(CONFIG_AFFS_FS)		+= affs/
+obj-$(CONFIG_ROMFS_FS)		+= romfs/
+obj-$(CONFIG_QNX4FS_FS)		+= qnx4/
+obj-$(CONFIG_AUTOFS4_FS)	+= autofs4/
+obj-$(CONFIG_ADFS_FS)		+= adfs/
+obj-$(CONFIG_FUSE_FS)		+= fuse/
+obj-$(CONFIG_UDF_FS)		+= udf/
+obj-$(CONFIG_SUN_OPENPROMFS)	+= openpromfs/
+obj-$(CONFIG_OMFS_FS)		+= omfs/
+obj-$(CONFIG_JFS_FS)		+= jfs/
+obj-$(CONFIG_XFS_FS)		+= xfs/
+obj-$(CONFIG_9P_FS)		+= 9p/
+obj-$(CONFIG_AFS_FS)		+= afs/
+obj-$(CONFIG_NILFS2_FS)		+= nilfs2/
+obj-$(CONFIG_BEFS_FS)		+= befs/
+obj-$(CONFIG_HOSTFS)		+= hostfs/
+obj-$(CONFIG_HPPFS)		+= hppfs/
+obj-$(CONFIG_CACHEFILES)	+= cachefiles/
+obj-$(CONFIG_DEBUG_FS)		+= debugfs/
+obj-$(CONFIG_OCFS2_FS)		+= ocfs2/
+obj-$(CONFIG_BTRFS_FS)		+= btrfs/
+obj-$(CONFIG_GFS2_FS)           += gfs2/
+obj-$(CONFIG_EXOFS_FS)          += exofs/
+obj-$(CONFIG_CEPH_FS)		+= ceph/
+obj-$(CONFIG_PSTORE)		+= pstore/
diff -uraN linux-3.0.8/fs/yaffs2/Kconfig linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/Kconfig
--- linux-3.0.8/fs/yaffs2/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/Kconfig	2021-07-13 23:40:33.786357014 +0300
@@ -0,0 +1,161 @@
+#
+# yaffs file system configurations
+#
+
+config YAFFS_FS
+	tristate "yaffs2 file system support"
+	default n
+	depends on MTD_BLOCK
+	select YAFFS_YAFFS1
+	select YAFFS_YAFFS2
+	help
+	  yaffs2, or Yet Another Flash File System, is a file system
+	  optimised for NAND Flash chips.
+
+	  To compile the yaffs2 file system support as a module, choose M
+	  here: the module will be called yaffs2.
+
+	  If unsure, say N.
+
+	  Further information on yaffs2 is available at
+	  <http://www.aleph1.co.uk/yaffs/>.
+
+config YAFFS_YAFFS1
+	bool "512 byte / page devices"
+	depends on YAFFS_FS
+	default y
+	help
+	  Enable yaffs1 support -- yaffs for 512 byte / page devices
+
+	  Not needed for 2K-page devices.
+
+	  If unsure, say Y.
+
+config YAFFS_9BYTE_TAGS
+	bool "Use older-style on-NAND data format with pageStatus byte"
+	depends on YAFFS_YAFFS1
+	default n
+	help
+
+	  Older-style on-NAND data format has a "pageStatus" byte to record
+	  chunk/page state.  This byte is zero when the page is discarded.
+	  Choose this option if you have existing on-NAND data using this
+	  format that you need to continue to support.  New data written
+	  also uses the older-style format.  Note: Use of this option
+	  generally requires that MTD's oob layout be adjusted to use the
+	  older-style format.  See notes on tags formats and MTD versions
+	  in yaffs_mtdif1.c.
+
+	  If unsure, say N.
+
+config YAFFS_DOES_ECC
+	bool "Lets yaffs do its own ECC"
+	depends on YAFFS_FS && YAFFS_YAFFS1 && !YAFFS_9BYTE_TAGS
+	default n
+	help
+	  This enables yaffs to use its own ECC functions instead of using
+	  the ones from the generic MTD-NAND driver.
+
+	  If unsure, say N.
+
+config YAFFS_ECC_WRONG_ORDER
+	bool "Use the same ecc byte order as Steven Hill's nand_ecc.c"
+	depends on YAFFS_FS && YAFFS_DOES_ECC && !YAFFS_9BYTE_TAGS
+	default n
+	help
+	  This makes yaffs_ecc.c use the same ecc byte order as Steven
+	  Hill's nand_ecc.c. If not set, then you get the same ecc byte
+	  order as SmartMedia.
+
+	  If unsure, say N.
+
+config YAFFS_YAFFS2
+	bool "2048 byte (or larger) / page devices"
+	depends on YAFFS_FS
+	default y
+	help
+	  Enable yaffs2 support -- yaffs for >= 2K bytes per page devices
+
+	  If unsure, say Y.
+
+config YAFFS_AUTO_YAFFS2
+	bool "Autoselect yaffs2 format"
+	depends on YAFFS_YAFFS2
+	default y
+	help
+	  Without this, you need to explicitely use yaffs2 as the file
+	  system type. With this, you can say "yaffs" and yaffs or yaffs2
+	  will be used depending on the device page size (yaffs on
+	  512-byte page devices, yaffs2 on 2K page devices).
+
+	  If unsure, say Y.
+
+config YAFFS_DISABLE_TAGS_ECC
+	bool "Disable yaffs from doing ECC on tags by default"
+	depends on YAFFS_FS && YAFFS_YAFFS2
+	default n
+	help
+	  This defaults yaffs to using its own ECC calculations on tags instead of
+	  just relying on the MTD.
+	  This behavior can also be overridden with tags_ecc_on and
+	  tags_ecc_off mount options.
+
+	  If unsure, say N.
+
+config YAFFS_ALWAYS_CHECK_CHUNK_ERASED
+	bool "Force chunk erase check"
+	depends on YAFFS_FS
+	default n
+	help
+          Normally yaffs only checks chunks before writing until an erased
+	  chunk is found. This helps to detect any partially written
+	  chunks that might have happened due to power loss.
+
+	  Enabling this forces on the test that chunks are erased in flash
+	  before writing to them. This takes more time but is potentially
+	  a bit more secure.
+
+	  Suggest setting Y during development and ironing out driver
+	  issues etc. Suggest setting to N if you want faster writing.
+
+	  If unsure, say Y.
+
+config YAFFS_EMPTY_LOST_AND_FOUND
+	bool "Empty lost and found on boot"
+	depends on YAFFS_FS
+	default n
+	help
+	  If this is enabled then the contents of lost and found is
+	  automatically dumped at mount.
+
+	  If unsure, say N.
+
+config YAFFS_DISABLE_BLOCK_REFRESHING
+	bool "Disable yaffs2 block refreshing"
+	depends on YAFFS_FS
+	default n
+	help
+	 If this is set, then block refreshing is disabled.
+	 Block refreshing infrequently refreshes the oldest block in
+	 a yaffs2 file system. This mechanism helps to refresh flash to
+	 mitigate against data loss. This is particularly useful for MLC.
+
+	  If unsure, say N.
+
+config YAFFS_DISABLE_BACKGROUND
+	bool "Disable yaffs2 background processing"
+	depends on YAFFS_FS
+	default n
+	help
+	 If this is set, then background processing is disabled.
+	 Background processing makes many foreground activities faster.
+
+	 If unsure, say N.
+
+config YAFFS_XATTR
+	bool "Enable yaffs2 xattr support"
+	depends on YAFFS_FS
+	default y
+	help
+	 If this is set then yaffs2 will provide xattr support.
+	 If unsure, say Y.
diff -uraN linux-3.0.8/fs/yaffs2/Makefile linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/Makefile
--- linux-3.0.8/fs/yaffs2/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/Makefile	2021-07-13 23:40:33.782356989 +0300
@@ -0,0 +1,18 @@
+#
+# Makefile for the linux YAFFS filesystem routines.
+#
+
+obj-$(CONFIG_YAFFS_FS) += yaffs.o
+
+yaffs-y := yaffs_ecc.o yaffs_vfs.o yaffs_guts.o yaffs_checkptrw.o
+yaffs-y += yaffs_packedtags1.o yaffs_packedtags2.o yaffs_nand.o
+yaffs-y += yaffs_tagscompat.o yaffs_tagsmarshall.o
+yaffs-y += yaffs_mtdif.o
+yaffs-y += yaffs_nameval.o yaffs_attribs.o
+yaffs-y += yaffs_allocator.o
+yaffs-y += yaffs_yaffs1.o
+yaffs-y += yaffs_yaffs2.o
+yaffs-y += yaffs_bitmap.o
+yaffs-y += yaffs_summary.o
+yaffs-y += yaffs_verify.o
+
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_allocator.c linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_allocator.c
--- linux-3.0.8/fs/yaffs2/yaffs_allocator.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_allocator.c	2021-07-13 23:40:33.778356963 +0300
@@ -0,0 +1,357 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_allocator.h"
+#include "yaffs_guts.h"
+#include "yaffs_trace.h"
+#include "yportenv.h"
+
+/*
+ * Each entry in yaffs_tnode_list and yaffs_obj_list hold blocks
+ * of approx 100 objects that are themn allocated singly.
+ * This is basically a simplified slab allocator.
+ *
+ * We don't use the Linux slab allocator because slab does not allow
+ * us to dump all the objects in one hit when we do a umount and tear
+ * down  all the tnodes and objects. slab requires that we first free
+ * the individual objects.
+ *
+ * Once yaffs has been mainlined I shall try to motivate for a change
+ * to slab to provide the extra features we need here.
+ */
+
+struct yaffs_tnode_list {
+	struct yaffs_tnode_list *next;
+	struct yaffs_tnode *tnodes;
+};
+
+struct yaffs_obj_list {
+	struct yaffs_obj_list *next;
+	struct yaffs_obj *objects;
+};
+
+struct yaffs_allocator {
+	int n_tnodes_created;
+	struct yaffs_tnode *free_tnodes;
+	int n_free_tnodes;
+	struct yaffs_tnode_list *alloc_tnode_list;
+
+	int n_obj_created;
+	struct list_head free_objs;
+	int n_free_objects;
+
+	struct yaffs_obj_list *allocated_obj_list;
+};
+
+static void yaffs_deinit_raw_tnodes(struct yaffs_dev *dev)
+{
+	struct yaffs_allocator *allocator =
+	    (struct yaffs_allocator *)dev->allocator;
+	struct yaffs_tnode_list *tmp;
+
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
+	while (allocator->alloc_tnode_list) {
+		tmp = allocator->alloc_tnode_list->next;
+
+		kfree(allocator->alloc_tnode_list->tnodes);
+		kfree(allocator->alloc_tnode_list);
+		allocator->alloc_tnode_list = tmp;
+	}
+
+	allocator->free_tnodes = NULL;
+	allocator->n_free_tnodes = 0;
+	allocator->n_tnodes_created = 0;
+}
+
+static void yaffs_init_raw_tnodes(struct yaffs_dev *dev)
+{
+	struct yaffs_allocator *allocator = dev->allocator;
+
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
+	allocator->alloc_tnode_list = NULL;
+	allocator->free_tnodes = NULL;
+	allocator->n_free_tnodes = 0;
+	allocator->n_tnodes_created = 0;
+}
+
+static int yaffs_create_tnodes(struct yaffs_dev *dev, int n_tnodes)
+{
+	struct yaffs_allocator *allocator =
+	    (struct yaffs_allocator *)dev->allocator;
+	int i;
+	struct yaffs_tnode *new_tnodes;
+	u8 *mem;
+	struct yaffs_tnode *curr;
+	struct yaffs_tnode *next;
+	struct yaffs_tnode_list *tnl;
+
+	if (!allocator) {
+		BUG();
+		return YAFFS_FAIL;
+	}
+
+	if (n_tnodes < 1)
+		return YAFFS_OK;
+
+	/* make these things */
+	new_tnodes = kmalloc(n_tnodes * dev->tnode_size, GFP_NOFS);
+	mem = (u8 *) new_tnodes;
+
+	if (!new_tnodes) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"yaffs: Could not allocate Tnodes");
+		return YAFFS_FAIL;
+	}
+
+	/* New hookup for wide tnodes */
+	for (i = 0; i < n_tnodes - 1; i++) {
+		curr = (struct yaffs_tnode *)&mem[i * dev->tnode_size];
+		next = (struct yaffs_tnode *)&mem[(i + 1) * dev->tnode_size];
+		curr->internal[0] = next;
+	}
+
+	curr = (struct yaffs_tnode *)&mem[(n_tnodes - 1) * dev->tnode_size];
+	curr->internal[0] = allocator->free_tnodes;
+	allocator->free_tnodes = (struct yaffs_tnode *)mem;
+
+	allocator->n_free_tnodes += n_tnodes;
+	allocator->n_tnodes_created += n_tnodes;
+
+	/* Now add this bunch of tnodes to a list for freeing up.
+	 * NB If we can't add this to the management list it isn't fatal
+	 * but it just means we can't free this bunch of tnodes later.
+	 */
+	tnl = kmalloc(sizeof(struct yaffs_tnode_list), GFP_NOFS);
+	if (!tnl) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"Could not add tnodes to management list");
+		return YAFFS_FAIL;
+	} else {
+		tnl->tnodes = new_tnodes;
+		tnl->next = allocator->alloc_tnode_list;
+		allocator->alloc_tnode_list = tnl;
+	}
+
+	yaffs_trace(YAFFS_TRACE_ALLOCATE, "Tnodes added");
+
+	return YAFFS_OK;
+}
+
+struct yaffs_tnode *yaffs_alloc_raw_tnode(struct yaffs_dev *dev)
+{
+	struct yaffs_allocator *allocator =
+	    (struct yaffs_allocator *)dev->allocator;
+	struct yaffs_tnode *tn = NULL;
+
+	if (!allocator) {
+		BUG();
+		return NULL;
+	}
+
+	/* If there are none left make more */
+	if (!allocator->free_tnodes)
+		yaffs_create_tnodes(dev, YAFFS_ALLOCATION_NTNODES);
+
+	if (allocator->free_tnodes) {
+		tn = allocator->free_tnodes;
+		allocator->free_tnodes = allocator->free_tnodes->internal[0];
+		allocator->n_free_tnodes--;
+	}
+
+	return tn;
+}
+
+/* FreeTnode frees up a tnode and puts it back on the free list */
+void yaffs_free_raw_tnode(struct yaffs_dev *dev, struct yaffs_tnode *tn)
+{
+	struct yaffs_allocator *allocator = dev->allocator;
+
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
+	if (tn) {
+		tn->internal[0] = allocator->free_tnodes;
+		allocator->free_tnodes = tn;
+		allocator->n_free_tnodes++;
+	}
+	dev->checkpoint_blocks_required = 0;	/* force recalculation */
+}
+
+/*--------------- yaffs_obj alloaction ------------------------
+ *
+ * Free yaffs_objs are stored in a list using obj->siblings.
+ * The blocks of allocated objects are stored in a linked list.
+ */
+
+static void yaffs_init_raw_objs(struct yaffs_dev *dev)
+{
+	struct yaffs_allocator *allocator = dev->allocator;
+
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
+	allocator->allocated_obj_list = NULL;
+	INIT_LIST_HEAD(&allocator->free_objs);
+	allocator->n_free_objects = 0;
+}
+
+static void yaffs_deinit_raw_objs(struct yaffs_dev *dev)
+{
+	struct yaffs_allocator *allocator = dev->allocator;
+	struct yaffs_obj_list *tmp;
+
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
+	while (allocator->allocated_obj_list) {
+		tmp = allocator->allocated_obj_list->next;
+		kfree(allocator->allocated_obj_list->objects);
+		kfree(allocator->allocated_obj_list);
+		allocator->allocated_obj_list = tmp;
+	}
+
+	INIT_LIST_HEAD(&allocator->free_objs);
+	allocator->n_free_objects = 0;
+	allocator->n_obj_created = 0;
+}
+
+static int yaffs_create_free_objs(struct yaffs_dev *dev, int n_obj)
+{
+	struct yaffs_allocator *allocator = dev->allocator;
+	int i;
+	struct yaffs_obj *new_objs;
+	struct yaffs_obj_list *list;
+
+	if (!allocator) {
+		BUG();
+		return YAFFS_FAIL;
+	}
+
+	if (n_obj < 1)
+		return YAFFS_OK;
+
+	/* make these things */
+	new_objs = kmalloc(n_obj * sizeof(struct yaffs_obj), GFP_NOFS);
+	list = kmalloc(sizeof(struct yaffs_obj_list), GFP_NOFS);
+
+	if (!new_objs || !list) {
+		kfree(new_objs);
+		new_objs = NULL;
+		kfree(list);
+		list = NULL;
+		yaffs_trace(YAFFS_TRACE_ALLOCATE,
+			"Could not allocate more objects");
+		return YAFFS_FAIL;
+	}
+
+	/* Hook them into the free list */
+	for (i = 0; i < n_obj; i++)
+		list_add(&new_objs[i].siblings, &allocator->free_objs);
+
+	allocator->n_free_objects += n_obj;
+	allocator->n_obj_created += n_obj;
+
+	/* Now add this bunch of Objects to a list for freeing up. */
+
+	list->objects = new_objs;
+	list->next = allocator->allocated_obj_list;
+	allocator->allocated_obj_list = list;
+
+	return YAFFS_OK;
+}
+
+struct yaffs_obj *yaffs_alloc_raw_obj(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj = NULL;
+	struct list_head *lh;
+	struct yaffs_allocator *allocator = dev->allocator;
+
+	if (!allocator) {
+		BUG();
+		return obj;
+	}
+
+	/* If there are none left make more */
+	if (list_empty(&allocator->free_objs))
+		yaffs_create_free_objs(dev, YAFFS_ALLOCATION_NOBJECTS);
+
+	if (!list_empty(&allocator->free_objs)) {
+		lh = allocator->free_objs.next;
+		obj = list_entry(lh, struct yaffs_obj, siblings);
+		list_del_init(lh);
+		allocator->n_free_objects--;
+	}
+
+	return obj;
+}
+
+void yaffs_free_raw_obj(struct yaffs_dev *dev, struct yaffs_obj *obj)
+{
+
+	struct yaffs_allocator *allocator = dev->allocator;
+
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
+	/* Link into the free list. */
+	list_add(&obj->siblings, &allocator->free_objs);
+	allocator->n_free_objects++;
+}
+
+void yaffs_deinit_raw_tnodes_and_objs(struct yaffs_dev *dev)
+{
+
+	if (!dev->allocator) {
+		BUG();
+		return;
+	}
+
+	yaffs_deinit_raw_tnodes(dev);
+	yaffs_deinit_raw_objs(dev);
+	kfree(dev->allocator);
+	dev->allocator = NULL;
+}
+
+void yaffs_init_raw_tnodes_and_objs(struct yaffs_dev *dev)
+{
+	struct yaffs_allocator *allocator;
+
+	if (dev->allocator) {
+		BUG();
+		return;
+	}
+
+	allocator = kmalloc(sizeof(struct yaffs_allocator), GFP_NOFS);
+	if (allocator) {
+		dev->allocator = allocator;
+		yaffs_init_raw_tnodes(dev);
+		yaffs_init_raw_objs(dev);
+	}
+}
+
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_allocator.h linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_allocator.h
--- linux-3.0.8/fs/yaffs2/yaffs_allocator.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_allocator.h	2021-07-13 23:40:33.786357014 +0300
@@ -0,0 +1,30 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_ALLOCATOR_H__
+#define __YAFFS_ALLOCATOR_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_init_raw_tnodes_and_objs(struct yaffs_dev *dev);
+void yaffs_deinit_raw_tnodes_and_objs(struct yaffs_dev *dev);
+
+struct yaffs_tnode *yaffs_alloc_raw_tnode(struct yaffs_dev *dev);
+void yaffs_free_raw_tnode(struct yaffs_dev *dev, struct yaffs_tnode *tn);
+
+struct yaffs_obj *yaffs_alloc_raw_obj(struct yaffs_dev *dev);
+void yaffs_free_raw_obj(struct yaffs_dev *dev, struct yaffs_obj *obj);
+
+#endif
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_attribs.c linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_attribs.c
--- linux-3.0.8/fs/yaffs2/yaffs_attribs.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_attribs.c	2021-07-13 23:40:33.790357039 +0300
@@ -0,0 +1,124 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_guts.h"
+#include "yaffs_attribs.h"
+
+void yaffs_load_attribs(struct yaffs_obj *obj, struct yaffs_obj_hdr *oh)
+{
+	obj->yst_uid = oh->yst_uid;
+	obj->yst_gid = oh->yst_gid;
+	obj->yst_atime = oh->yst_atime;
+	obj->yst_mtime = oh->yst_mtime;
+	obj->yst_ctime = oh->yst_ctime;
+	obj->yst_rdev = oh->yst_rdev;
+}
+
+void yaffs_load_attribs_oh(struct yaffs_obj_hdr *oh, struct yaffs_obj *obj)
+{
+	oh->yst_uid = obj->yst_uid;
+	oh->yst_gid = obj->yst_gid;
+	oh->yst_atime = obj->yst_atime;
+	oh->yst_mtime = obj->yst_mtime;
+	oh->yst_ctime = obj->yst_ctime;
+	oh->yst_rdev = obj->yst_rdev;
+
+}
+
+void yaffs_load_current_time(struct yaffs_obj *obj, int do_a, int do_c)
+{
+	obj->yst_mtime = Y_CURRENT_TIME;
+	if (do_a)
+		obj->yst_atime = obj->yst_mtime;
+	if (do_c)
+		obj->yst_ctime = obj->yst_mtime;
+}
+
+void yaffs_attribs_init(struct yaffs_obj *obj, u32 gid, u32 uid, u32 rdev)
+{
+	yaffs_load_current_time(obj, 1, 1);
+	obj->yst_rdev = rdev;
+	obj->yst_uid = uid;
+	obj->yst_gid = gid;
+}
+
+static loff_t yaffs_get_file_size(struct yaffs_obj *obj)
+{
+	YCHAR *alias = NULL;
+	obj = yaffs_get_equivalent_obj(obj);
+
+	switch (obj->variant_type) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		return obj->variant.file_variant.file_size;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		alias = obj->variant.symlink_variant.alias;
+		if (!alias)
+			return 0;
+		return strnlen(alias, YAFFS_MAX_ALIAS_LENGTH);
+	default:
+		return 0;
+	}
+}
+
+int yaffs_set_attribs(struct yaffs_obj *obj, struct iattr *attr)
+{
+	unsigned int valid = attr->ia_valid;
+
+	if (valid & ATTR_MODE)
+		obj->yst_mode = attr->ia_mode;
+	if (valid & ATTR_UID)
+		obj->yst_uid = attr->ia_uid;
+	if (valid & ATTR_GID)
+		obj->yst_gid = attr->ia_gid;
+
+	if (valid & ATTR_ATIME)
+		obj->yst_atime = Y_TIME_CONVERT(attr->ia_atime);
+	if (valid & ATTR_CTIME)
+		obj->yst_ctime = Y_TIME_CONVERT(attr->ia_ctime);
+	if (valid & ATTR_MTIME)
+		obj->yst_mtime = Y_TIME_CONVERT(attr->ia_mtime);
+
+	if (valid & ATTR_SIZE)
+		yaffs_resize_file(obj, attr->ia_size);
+
+	yaffs_update_oh(obj, NULL, 1, 0, 0, NULL);
+
+	return YAFFS_OK;
+
+}
+
+int yaffs_get_attribs(struct yaffs_obj *obj, struct iattr *attr)
+{
+	unsigned int valid = 0;
+
+	attr->ia_mode = obj->yst_mode;
+	valid |= ATTR_MODE;
+	attr->ia_uid = obj->yst_uid;
+	valid |= ATTR_UID;
+	attr->ia_gid = obj->yst_gid;
+	valid |= ATTR_GID;
+
+	Y_TIME_CONVERT(attr->ia_atime) = obj->yst_atime;
+	valid |= ATTR_ATIME;
+	Y_TIME_CONVERT(attr->ia_ctime) = obj->yst_ctime;
+	valid |= ATTR_CTIME;
+	Y_TIME_CONVERT(attr->ia_mtime) = obj->yst_mtime;
+	valid |= ATTR_MTIME;
+
+	attr->ia_size = yaffs_get_file_size(obj);
+	valid |= ATTR_SIZE;
+
+	attr->ia_valid = valid;
+
+	return YAFFS_OK;
+}
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_attribs.h linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_attribs.h
--- linux-3.0.8/fs/yaffs2/yaffs_attribs.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_attribs.h	2021-07-13 23:40:33.782356989 +0300
@@ -0,0 +1,28 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_ATTRIBS_H__
+#define __YAFFS_ATTRIBS_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_load_attribs(struct yaffs_obj *obj, struct yaffs_obj_hdr *oh);
+void yaffs_load_attribs_oh(struct yaffs_obj_hdr *oh, struct yaffs_obj *obj);
+void yaffs_attribs_init(struct yaffs_obj *obj, u32 gid, u32 uid, u32 rdev);
+void yaffs_load_current_time(struct yaffs_obj *obj, int do_a, int do_c);
+int yaffs_set_attribs(struct yaffs_obj *obj, struct iattr *attr);
+int yaffs_get_attribs(struct yaffs_obj *obj, struct iattr *attr);
+
+#endif
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_bitmap.c linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_bitmap.c
--- linux-3.0.8/fs/yaffs2/yaffs_bitmap.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_bitmap.c	2021-07-13 23:40:33.786357014 +0300
@@ -0,0 +1,97 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_bitmap.h"
+#include "yaffs_trace.h"
+/*
+ * Chunk bitmap manipulations
+ */
+
+static inline u8 *yaffs_block_bits(struct yaffs_dev *dev, int blk)
+{
+	if (blk < dev->internal_start_block || blk > dev->internal_end_block) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"BlockBits block %d is not valid",
+			blk);
+		BUG();
+	}
+	return dev->chunk_bits +
+	    (dev->chunk_bit_stride * (blk - dev->internal_start_block));
+}
+
+void yaffs_verify_chunk_bit_id(struct yaffs_dev *dev, int blk, int chunk)
+{
+	if (blk < dev->internal_start_block || blk > dev->internal_end_block ||
+	    chunk < 0 || chunk >= dev->param.chunks_per_block) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"Chunk Id (%d:%d) invalid",
+			blk, chunk);
+		BUG();
+	}
+}
+
+void yaffs_clear_chunk_bits(struct yaffs_dev *dev, int blk)
+{
+	u8 *blk_bits = yaffs_block_bits(dev, blk);
+
+	memset(blk_bits, 0, dev->chunk_bit_stride);
+}
+
+void yaffs_clear_chunk_bit(struct yaffs_dev *dev, int blk, int chunk)
+{
+	u8 *blk_bits = yaffs_block_bits(dev, blk);
+
+	yaffs_verify_chunk_bit_id(dev, blk, chunk);
+	blk_bits[chunk / 8] &= ~(1 << (chunk & 7));
+}
+
+void yaffs_set_chunk_bit(struct yaffs_dev *dev, int blk, int chunk)
+{
+	u8 *blk_bits = yaffs_block_bits(dev, blk);
+
+	yaffs_verify_chunk_bit_id(dev, blk, chunk);
+	blk_bits[chunk / 8] |= (1 << (chunk & 7));
+}
+
+int yaffs_check_chunk_bit(struct yaffs_dev *dev, int blk, int chunk)
+{
+	u8 *blk_bits = yaffs_block_bits(dev, blk);
+
+	yaffs_verify_chunk_bit_id(dev, blk, chunk);
+	return (blk_bits[chunk / 8] & (1 << (chunk & 7))) ? 1 : 0;
+}
+
+int yaffs_still_some_chunks(struct yaffs_dev *dev, int blk)
+{
+	u8 *blk_bits = yaffs_block_bits(dev, blk);
+	int i;
+
+	for (i = 0; i < dev->chunk_bit_stride; i++) {
+		if (*blk_bits)
+			return 1;
+		blk_bits++;
+	}
+	return 0;
+}
+
+int yaffs_count_chunk_bits(struct yaffs_dev *dev, int blk)
+{
+	u8 *blk_bits = yaffs_block_bits(dev, blk);
+	int i;
+	int n = 0;
+
+	for (i = 0; i < dev->chunk_bit_stride; i++, blk_bits++)
+		n += hweight8(*blk_bits);
+
+	return n;
+}
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_bitmap.h linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_bitmap.h
--- linux-3.0.8/fs/yaffs2/yaffs_bitmap.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_bitmap.h	2021-07-13 23:40:33.790357039 +0300
@@ -0,0 +1,33 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/*
+ * Chunk bitmap manipulations
+ */
+
+#ifndef __YAFFS_BITMAP_H__
+#define __YAFFS_BITMAP_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_verify_chunk_bit_id(struct yaffs_dev *dev, int blk, int chunk);
+void yaffs_clear_chunk_bits(struct yaffs_dev *dev, int blk);
+void yaffs_clear_chunk_bit(struct yaffs_dev *dev, int blk, int chunk);
+void yaffs_set_chunk_bit(struct yaffs_dev *dev, int blk, int chunk);
+int yaffs_check_chunk_bit(struct yaffs_dev *dev, int blk, int chunk);
+int yaffs_still_some_chunks(struct yaffs_dev *dev, int blk);
+int yaffs_count_chunk_bits(struct yaffs_dev *dev, int blk);
+
+#endif
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_checkptrw.c linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_checkptrw.c
--- linux-3.0.8/fs/yaffs2/yaffs_checkptrw.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_checkptrw.c	2021-07-13 23:40:33.786357014 +0300
@@ -0,0 +1,474 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_checkptrw.h"
+#include "yaffs_getblockinfo.h"
+
+struct yaffs_checkpt_chunk_hdr {
+	int version;
+	int seq;
+	u32 sum;
+	u32 xor;
+} ;
+
+
+static int apply_chunk_offset(struct yaffs_dev *dev, int chunk)
+{
+	return chunk - dev->chunk_offset;
+}
+
+static int apply_block_offset(struct yaffs_dev *dev, int block)
+{
+	return block - dev->block_offset;
+}
+
+static void yaffs2_checkpt_init_chunk_hdr(struct yaffs_dev *dev)
+{
+	struct yaffs_checkpt_chunk_hdr hdr;
+
+	hdr.version = YAFFS_CHECKPOINT_VERSION;
+	hdr.seq = dev->checkpt_page_seq;
+	hdr.sum = dev->checkpt_sum;
+	hdr.xor = dev->checkpt_xor;
+
+	dev->checkpt_byte_offs = sizeof(hdr);
+
+	memcpy(dev->checkpt_buffer, &hdr, sizeof(hdr));
+}
+
+static int yaffs2_checkpt_check_chunk_hdr(struct yaffs_dev *dev)
+{
+	struct yaffs_checkpt_chunk_hdr hdr;
+
+	memcpy(&hdr, dev->checkpt_buffer, sizeof(hdr));
+
+	dev->checkpt_byte_offs = sizeof(hdr);
+
+	return hdr.version == YAFFS_CHECKPOINT_VERSION &&
+		hdr.seq == dev->checkpt_page_seq &&
+		hdr.sum == dev->checkpt_sum &&
+		hdr.xor == dev->checkpt_xor;
+}
+
+static int yaffs2_checkpt_space_ok(struct yaffs_dev *dev)
+{
+	int blocks_avail = dev->n_erased_blocks - dev->param.n_reserved_blocks;
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"checkpt blocks_avail = %d", blocks_avail);
+
+	return (blocks_avail <= 0) ? 0 : 1;
+}
+
+static int yaffs_checkpt_erase(struct yaffs_dev *dev)
+{
+	int i;
+
+	if (!dev->drv.drv_erase_fn)
+		return 0;
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"checking blocks %d to %d",
+		dev->internal_start_block, dev->internal_end_block);
+
+	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
+		struct yaffs_block_info *bi = yaffs_get_block_info(dev, i);
+		int offset_i = apply_block_offset(dev, i);
+		int result;
+
+		if (bi->block_state == YAFFS_BLOCK_STATE_CHECKPOINT) {
+			yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"erasing checkpt block %d", i);
+
+			dev->n_erasures++;
+
+			result = dev->drv.drv_erase_fn(dev, offset_i);
+			if(result) {
+				bi->block_state = YAFFS_BLOCK_STATE_EMPTY;
+				dev->n_erased_blocks++;
+				dev->n_free_chunks +=
+				    dev->param.chunks_per_block;
+			} else {
+				dev->drv.drv_mark_bad_fn(dev, offset_i);
+				bi->block_state = YAFFS_BLOCK_STATE_DEAD;
+			}
+		}
+	}
+
+	dev->blocks_in_checkpt = 0;
+
+	return 1;
+}
+
+static void yaffs2_checkpt_find_erased_block(struct yaffs_dev *dev)
+{
+	int i;
+	int blocks_avail = dev->n_erased_blocks - dev->param.n_reserved_blocks;
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"allocating checkpt block: erased %d reserved %d avail %d next %d ",
+		dev->n_erased_blocks, dev->param.n_reserved_blocks,
+		blocks_avail, dev->checkpt_next_block);
+
+	if (dev->checkpt_next_block >= 0 &&
+	    dev->checkpt_next_block <= dev->internal_end_block &&
+	    blocks_avail > 0) {
+
+		for (i = dev->checkpt_next_block; i <= dev->internal_end_block;
+		     i++) {
+			struct yaffs_block_info *bi;
+
+			bi = yaffs_get_block_info(dev, i);
+			if (bi->block_state == YAFFS_BLOCK_STATE_EMPTY) {
+				dev->checkpt_next_block = i + 1;
+				dev->checkpt_cur_block = i;
+				yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+					"allocating checkpt block %d", i);
+				return;
+			}
+		}
+	}
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT, "out of checkpt blocks");
+
+	dev->checkpt_next_block = -1;
+	dev->checkpt_cur_block = -1;
+}
+
+static void yaffs2_checkpt_find_block(struct yaffs_dev *dev)
+{
+	int i;
+	struct yaffs_ext_tags tags;
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"find next checkpt block: start:  blocks %d next %d",
+		dev->blocks_in_checkpt, dev->checkpt_next_block);
+
+	if (dev->blocks_in_checkpt < dev->checkpt_max_blocks)
+		for (i = dev->checkpt_next_block; i <= dev->internal_end_block;
+		     i++) {
+			int chunk = i * dev->param.chunks_per_block;
+			enum yaffs_block_state state;
+			u32 seq;
+
+			dev->tagger.read_chunk_tags_fn(dev,
+					apply_chunk_offset(dev, chunk),
+					NULL, &tags);
+			yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+				"find next checkpt block: search: block %d state %d oid %d seq %d eccr %d",
+				i, (int) state,
+				tags.obj_id, tags.seq_number,
+				tags.ecc_result);
+
+			if (tags.seq_number != YAFFS_SEQUENCE_CHECKPOINT_DATA)
+				continue;
+
+			dev->tagger.query_block_fn(dev,
+						apply_block_offset(dev, i),
+						&state, &seq);
+			if (state == YAFFS_BLOCK_STATE_DEAD)
+				continue;
+
+			/* Right kind of block */
+			dev->checkpt_next_block = tags.obj_id;
+			dev->checkpt_cur_block = i;
+			dev->checkpt_block_list[dev->blocks_in_checkpt] = i;
+			dev->blocks_in_checkpt++;
+			yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+				"found checkpt block %d", i);
+			return;
+		}
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT, "found no more checkpt blocks");
+
+	dev->checkpt_next_block = -1;
+	dev->checkpt_cur_block = -1;
+}
+
+int yaffs2_checkpt_open(struct yaffs_dev *dev, int writing)
+{
+	int i;
+
+	dev->checkpt_open_write = writing;
+
+	/* Got the functions we need? */
+	if (!dev->tagger.write_chunk_tags_fn ||
+	    !dev->tagger.read_chunk_tags_fn ||
+	    !dev->drv.drv_erase_fn ||
+	    !dev->drv.drv_mark_bad_fn)
+		return 0;
+
+	if (writing && !yaffs2_checkpt_space_ok(dev))
+		return 0;
+
+	if (!dev->checkpt_buffer)
+		dev->checkpt_buffer =
+		    kmalloc(dev->param.total_bytes_per_chunk, GFP_NOFS);
+	if (!dev->checkpt_buffer)
+		return 0;
+
+	dev->checkpt_page_seq = 0;
+	dev->checkpt_byte_count = 0;
+	dev->checkpt_sum = 0;
+	dev->checkpt_xor = 0;
+	dev->checkpt_cur_block = -1;
+	dev->checkpt_cur_chunk = -1;
+	dev->checkpt_next_block = dev->internal_start_block;
+
+	if (writing) {
+		memset(dev->checkpt_buffer, 0, dev->data_bytes_per_chunk);
+		yaffs2_checkpt_init_chunk_hdr(dev);
+		return yaffs_checkpt_erase(dev);
+	}
+
+	/* Opening for a read */
+	/* Set to a value that will kick off a read */
+	dev->checkpt_byte_offs = dev->data_bytes_per_chunk;
+	/* A checkpoint block list of 1 checkpoint block per 16 block is
+	 * (hopefully) going to be way more than we need */
+	dev->blocks_in_checkpt = 0;
+	dev->checkpt_max_blocks =
+	    (dev->internal_end_block - dev->internal_start_block) / 16 + 2;
+	dev->checkpt_block_list =
+	    kmalloc(sizeof(int) * dev->checkpt_max_blocks, GFP_NOFS);
+
+	if (!dev->checkpt_block_list)
+		return 0;
+
+	for (i = 0; i < dev->checkpt_max_blocks; i++)
+		dev->checkpt_block_list[i] = -1;
+
+	return 1;
+}
+
+int yaffs2_get_checkpt_sum(struct yaffs_dev *dev, u32 * sum)
+{
+	u32 composite_sum;
+
+	composite_sum = (dev->checkpt_sum << 8) | (dev->checkpt_xor & 0xff);
+	*sum = composite_sum;
+	return 1;
+}
+
+static int yaffs2_checkpt_flush_buffer(struct yaffs_dev *dev)
+{
+	int chunk;
+	int offset_chunk;
+	struct yaffs_ext_tags tags;
+
+	if (dev->checkpt_cur_block < 0) {
+		yaffs2_checkpt_find_erased_block(dev);
+		dev->checkpt_cur_chunk = 0;
+	}
+
+	if (dev->checkpt_cur_block < 0)
+		return 0;
+
+	tags.is_deleted = 0;
+	tags.obj_id = dev->checkpt_next_block;	/* Hint to next place to look */
+	tags.chunk_id = dev->checkpt_page_seq + 1;
+	tags.seq_number = YAFFS_SEQUENCE_CHECKPOINT_DATA;
+	tags.n_bytes = dev->data_bytes_per_chunk;
+	if (dev->checkpt_cur_chunk == 0) {
+		/* First chunk we write for the block? Set block state to
+		   checkpoint */
+		struct yaffs_block_info *bi =
+		    yaffs_get_block_info(dev, dev->checkpt_cur_block);
+		bi->block_state = YAFFS_BLOCK_STATE_CHECKPOINT;
+		dev->blocks_in_checkpt++;
+	}
+
+	chunk =
+	    dev->checkpt_cur_block * dev->param.chunks_per_block +
+	    dev->checkpt_cur_chunk;
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"checkpoint wite buffer nand %d(%d:%d) objid %d chId %d",
+		chunk, dev->checkpt_cur_block, dev->checkpt_cur_chunk,
+		tags.obj_id, tags.chunk_id);
+
+	offset_chunk = apply_chunk_offset(dev, chunk);
+
+	dev->n_page_writes++;
+
+	dev->tagger.write_chunk_tags_fn(dev, offset_chunk,
+				       dev->checkpt_buffer, &tags);
+	dev->checkpt_page_seq++;
+	dev->checkpt_cur_chunk++;
+	if (dev->checkpt_cur_chunk >= dev->param.chunks_per_block) {
+		dev->checkpt_cur_chunk = 0;
+		dev->checkpt_cur_block = -1;
+	}
+	memset(dev->checkpt_buffer, 0, dev->data_bytes_per_chunk);
+
+	yaffs2_checkpt_init_chunk_hdr(dev);
+
+
+	return 1;
+}
+
+int yaffs2_checkpt_wr(struct yaffs_dev *dev, const void *data, int n_bytes)
+{
+	int i = 0;
+	int ok = 1;
+	u8 *data_bytes = (u8 *) data;
+
+	if (!dev->checkpt_buffer)
+		return 0;
+
+	if (!dev->checkpt_open_write)
+		return -1;
+
+	while (i < n_bytes && ok) {
+		dev->checkpt_buffer[dev->checkpt_byte_offs] = *data_bytes;
+		dev->checkpt_sum += *data_bytes;
+		dev->checkpt_xor ^= *data_bytes;
+
+		dev->checkpt_byte_offs++;
+		i++;
+		data_bytes++;
+		dev->checkpt_byte_count++;
+
+		if (dev->checkpt_byte_offs < 0 ||
+		    dev->checkpt_byte_offs >= dev->data_bytes_per_chunk)
+			ok = yaffs2_checkpt_flush_buffer(dev);
+	}
+
+	return i;
+}
+
+int yaffs2_checkpt_rd(struct yaffs_dev *dev, void *data, int n_bytes)
+{
+	int i = 0;
+	int ok = 1;
+	struct yaffs_ext_tags tags;
+	int chunk;
+	int offset_chunk;
+	u8 *data_bytes = (u8 *) data;
+
+	if (!dev->checkpt_buffer)
+		return 0;
+
+	if (dev->checkpt_open_write)
+		return -1;
+
+	while (i < n_bytes && ok) {
+
+		if (dev->checkpt_byte_offs < 0 ||
+		    dev->checkpt_byte_offs >= dev->data_bytes_per_chunk) {
+
+			if (dev->checkpt_cur_block < 0) {
+				yaffs2_checkpt_find_block(dev);
+				dev->checkpt_cur_chunk = 0;
+			}
+
+			if (dev->checkpt_cur_block < 0) {
+				ok = 0;
+				break;
+			}
+
+			chunk = dev->checkpt_cur_block *
+			    dev->param.chunks_per_block +
+			    dev->checkpt_cur_chunk;
+
+			offset_chunk = apply_chunk_offset(dev, chunk);
+			dev->n_page_reads++;
+
+			/* read in the next chunk */
+			dev->tagger.read_chunk_tags_fn(dev,
+						offset_chunk,
+						dev->checkpt_buffer,
+						&tags);
+
+			if (tags.chunk_id != (dev->checkpt_page_seq + 1) ||
+			    tags.ecc_result > YAFFS_ECC_RESULT_FIXED ||
+			    tags.seq_number != YAFFS_SEQUENCE_CHECKPOINT_DATA) {
+				ok = 0;
+				break;
+			}
+			if(!yaffs2_checkpt_check_chunk_hdr(dev)) {
+				ok = 0;
+				break;
+			}
+
+			dev->checkpt_page_seq++;
+			dev->checkpt_cur_chunk++;
+
+			if (dev->checkpt_cur_chunk >=
+					dev->param.chunks_per_block)
+				dev->checkpt_cur_block = -1;
+
+		}
+
+		*data_bytes = dev->checkpt_buffer[dev->checkpt_byte_offs];
+		dev->checkpt_sum += *data_bytes;
+		dev->checkpt_xor ^= *data_bytes;
+		dev->checkpt_byte_offs++;
+		i++;
+		data_bytes++;
+		dev->checkpt_byte_count++;
+	}
+
+	return i;
+}
+
+int yaffs_checkpt_close(struct yaffs_dev *dev)
+{
+	int i;
+
+	if (dev->checkpt_open_write) {
+		if (dev->checkpt_byte_offs !=
+			sizeof(sizeof(struct yaffs_checkpt_chunk_hdr)))
+			yaffs2_checkpt_flush_buffer(dev);
+	} else if (dev->checkpt_block_list) {
+		for (i = 0;
+		     i < dev->blocks_in_checkpt &&
+		     dev->checkpt_block_list[i] >= 0; i++) {
+			int blk = dev->checkpt_block_list[i];
+			struct yaffs_block_info *bi = NULL;
+
+			if (dev->internal_start_block <= blk &&
+			    blk <= dev->internal_end_block)
+				bi = yaffs_get_block_info(dev, blk);
+			if (bi && bi->block_state == YAFFS_BLOCK_STATE_EMPTY)
+				bi->block_state = YAFFS_BLOCK_STATE_CHECKPOINT;
+		}
+		kfree(dev->checkpt_block_list);
+		dev->checkpt_block_list = NULL;
+	}
+
+	dev->n_free_chunks -=
+		dev->blocks_in_checkpt * dev->param.chunks_per_block;
+	dev->n_erased_blocks -= dev->blocks_in_checkpt;
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT, "checkpoint byte count %d",
+		dev->checkpt_byte_count);
+
+	if (dev->checkpt_buffer) {
+		/* free the buffer */
+		kfree(dev->checkpt_buffer);
+		dev->checkpt_buffer = NULL;
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+int yaffs2_checkpt_invalidate_stream(struct yaffs_dev *dev)
+{
+	/* Erase the checkpoint data */
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"checkpoint invalidate of %d blocks",
+		dev->blocks_in_checkpt);
+
+	return yaffs_checkpt_erase(dev);
+}
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_checkptrw.h linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_checkptrw.h
--- linux-3.0.8/fs/yaffs2/yaffs_checkptrw.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_checkptrw.h	2021-07-13 23:40:33.790357039 +0300
@@ -0,0 +1,33 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_CHECKPTRW_H__
+#define __YAFFS_CHECKPTRW_H__
+
+#include "yaffs_guts.h"
+
+int yaffs2_checkpt_open(struct yaffs_dev *dev, int writing);
+
+int yaffs2_checkpt_wr(struct yaffs_dev *dev, const void *data, int n_bytes);
+
+int yaffs2_checkpt_rd(struct yaffs_dev *dev, void *data, int n_bytes);
+
+int yaffs2_get_checkpt_sum(struct yaffs_dev *dev, u32 * sum);
+
+int yaffs_checkpt_close(struct yaffs_dev *dev);
+
+int yaffs2_checkpt_invalidate_stream(struct yaffs_dev *dev);
+
+#endif
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_ecc.c linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_ecc.c
--- linux-3.0.8/fs/yaffs2/yaffs_ecc.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_ecc.c	2021-07-13 23:40:33.782356989 +0300
@@ -0,0 +1,281 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * This code implements the ECC algorithm used in SmartMedia.
+ *
+ * The ECC comprises 22 bits of parity information and is stuffed into 3 bytes.
+ * The two unused bit are set to 1.
+ * The ECC can correct single bit errors in a 256-byte page of data. Thus, two
+ * such ECC blocks are used on a 512-byte NAND page.
+ *
+ */
+
+#include "yportenv.h"
+
+#include "yaffs_ecc.h"
+
+/* Table generated by gen-ecc.c
+ * Using a table means we do not have to calculate p1..p4 and p1'..p4'
+ * for each byte of data. These are instead provided in a table in bits7..2.
+ * Bit 0 of each entry indicates whether the entry has an odd or even parity,
+ * and therefore this bytes influence on the line parity.
+ */
+
+static const unsigned char column_parity_table[] = {
+	0x00, 0x55, 0x59, 0x0c, 0x65, 0x30, 0x3c, 0x69,
+	0x69, 0x3c, 0x30, 0x65, 0x0c, 0x59, 0x55, 0x00,
+	0x95, 0xc0, 0xcc, 0x99, 0xf0, 0xa5, 0xa9, 0xfc,
+	0xfc, 0xa9, 0xa5, 0xf0, 0x99, 0xcc, 0xc0, 0x95,
+	0x99, 0xcc, 0xc0, 0x95, 0xfc, 0xa9, 0xa5, 0xf0,
+	0xf0, 0xa5, 0xa9, 0xfc, 0x95, 0xc0, 0xcc, 0x99,
+	0x0c, 0x59, 0x55, 0x00, 0x69, 0x3c, 0x30, 0x65,
+	0x65, 0x30, 0x3c, 0x69, 0x00, 0x55, 0x59, 0x0c,
+	0xa5, 0xf0, 0xfc, 0xa9, 0xc0, 0x95, 0x99, 0xcc,
+	0xcc, 0x99, 0x95, 0xc0, 0xa9, 0xfc, 0xf0, 0xa5,
+	0x30, 0x65, 0x69, 0x3c, 0x55, 0x00, 0x0c, 0x59,
+	0x59, 0x0c, 0x00, 0x55, 0x3c, 0x69, 0x65, 0x30,
+	0x3c, 0x69, 0x65, 0x30, 0x59, 0x0c, 0x00, 0x55,
+	0x55, 0x00, 0x0c, 0x59, 0x30, 0x65, 0x69, 0x3c,
+	0xa9, 0xfc, 0xf0, 0xa5, 0xcc, 0x99, 0x95, 0xc0,
+	0xc0, 0x95, 0x99, 0xcc, 0xa5, 0xf0, 0xfc, 0xa9,
+	0xa9, 0xfc, 0xf0, 0xa5, 0xcc, 0x99, 0x95, 0xc0,
+	0xc0, 0x95, 0x99, 0xcc, 0xa5, 0xf0, 0xfc, 0xa9,
+	0x3c, 0x69, 0x65, 0x30, 0x59, 0x0c, 0x00, 0x55,
+	0x55, 0x00, 0x0c, 0x59, 0x30, 0x65, 0x69, 0x3c,
+	0x30, 0x65, 0x69, 0x3c, 0x55, 0x00, 0x0c, 0x59,
+	0x59, 0x0c, 0x00, 0x55, 0x3c, 0x69, 0x65, 0x30,
+	0xa5, 0xf0, 0xfc, 0xa9, 0xc0, 0x95, 0x99, 0xcc,
+	0xcc, 0x99, 0x95, 0xc0, 0xa9, 0xfc, 0xf0, 0xa5,
+	0x0c, 0x59, 0x55, 0x00, 0x69, 0x3c, 0x30, 0x65,
+	0x65, 0x30, 0x3c, 0x69, 0x00, 0x55, 0x59, 0x0c,
+	0x99, 0xcc, 0xc0, 0x95, 0xfc, 0xa9, 0xa5, 0xf0,
+	0xf0, 0xa5, 0xa9, 0xfc, 0x95, 0xc0, 0xcc, 0x99,
+	0x95, 0xc0, 0xcc, 0x99, 0xf0, 0xa5, 0xa9, 0xfc,
+	0xfc, 0xa9, 0xa5, 0xf0, 0x99, 0xcc, 0xc0, 0x95,
+	0x00, 0x55, 0x59, 0x0c, 0x65, 0x30, 0x3c, 0x69,
+	0x69, 0x3c, 0x30, 0x65, 0x0c, 0x59, 0x55, 0x00,
+};
+
+
+/* Calculate the ECC for a 256-byte block of data */
+void yaffs_ecc_calc(const unsigned char *data, unsigned char *ecc)
+{
+	unsigned int i;
+	unsigned char col_parity = 0;
+	unsigned char line_parity = 0;
+	unsigned char line_parity_prime = 0;
+	unsigned char t;
+	unsigned char b;
+
+	for (i = 0; i < 256; i++) {
+		b = column_parity_table[*data++];
+		col_parity ^= b;
+
+		if (b & 0x01) {	/* odd number of bits in the byte */
+			line_parity ^= i;
+			line_parity_prime ^= ~i;
+		}
+	}
+
+	ecc[2] = (~col_parity) | 0x03;
+
+	t = 0;
+	if (line_parity & 0x80)
+		t |= 0x80;
+	if (line_parity_prime & 0x80)
+		t |= 0x40;
+	if (line_parity & 0x40)
+		t |= 0x20;
+	if (line_parity_prime & 0x40)
+		t |= 0x10;
+	if (line_parity & 0x20)
+		t |= 0x08;
+	if (line_parity_prime & 0x20)
+		t |= 0x04;
+	if (line_parity & 0x10)
+		t |= 0x02;
+	if (line_parity_prime & 0x10)
+		t |= 0x01;
+	ecc[1] = ~t;
+
+	t = 0;
+	if (line_parity & 0x08)
+		t |= 0x80;
+	if (line_parity_prime & 0x08)
+		t |= 0x40;
+	if (line_parity & 0x04)
+		t |= 0x20;
+	if (line_parity_prime & 0x04)
+		t |= 0x10;
+	if (line_parity & 0x02)
+		t |= 0x08;
+	if (line_parity_prime & 0x02)
+		t |= 0x04;
+	if (line_parity & 0x01)
+		t |= 0x02;
+	if (line_parity_prime & 0x01)
+		t |= 0x01;
+	ecc[0] = ~t;
+
+}
+
+/* Correct the ECC on a 256 byte block of data */
+
+int yaffs_ecc_correct(unsigned char *data, unsigned char *read_ecc,
+		      const unsigned char *test_ecc)
+{
+	unsigned char d0, d1, d2;	/* deltas */
+
+	d0 = read_ecc[0] ^ test_ecc[0];
+	d1 = read_ecc[1] ^ test_ecc[1];
+	d2 = read_ecc[2] ^ test_ecc[2];
+
+	if ((d0 | d1 | d2) == 0)
+		return 0;	/* no error */
+
+	if (((d0 ^ (d0 >> 1)) & 0x55) == 0x55 &&
+	    ((d1 ^ (d1 >> 1)) & 0x55) == 0x55 &&
+	    ((d2 ^ (d2 >> 1)) & 0x54) == 0x54) {
+		/* Single bit (recoverable) error in data */
+
+		unsigned byte;
+		unsigned bit;
+
+		bit = byte = 0;
+
+		if (d1 & 0x80)
+			byte |= 0x80;
+		if (d1 & 0x20)
+			byte |= 0x40;
+		if (d1 & 0x08)
+			byte |= 0x20;
+		if (d1 & 0x02)
+			byte |= 0x10;
+		if (d0 & 0x80)
+			byte |= 0x08;
+		if (d0 & 0x20)
+			byte |= 0x04;
+		if (d0 & 0x08)
+			byte |= 0x02;
+		if (d0 & 0x02)
+			byte |= 0x01;
+
+		if (d2 & 0x80)
+			bit |= 0x04;
+		if (d2 & 0x20)
+			bit |= 0x02;
+		if (d2 & 0x08)
+			bit |= 0x01;
+
+		data[byte] ^= (1 << bit);
+
+		return 1;	/* Corrected the error */
+	}
+
+	if ((hweight8(d0) + hweight8(d1) + hweight8(d2)) == 1) {
+		/* Reccoverable error in ecc */
+
+		read_ecc[0] = test_ecc[0];
+		read_ecc[1] = test_ecc[1];
+		read_ecc[2] = test_ecc[2];
+
+		return 1;	/* Corrected the error */
+	}
+
+	/* Unrecoverable error */
+
+	return -1;
+
+}
+
+/*
+ * ECCxxxOther does ECC calcs on arbitrary n bytes of data
+ */
+void yaffs_ecc_calc_other(const unsigned char *data, unsigned n_bytes,
+			  struct yaffs_ecc_other *ecc_other)
+{
+	unsigned int i;
+	unsigned char col_parity = 0;
+	unsigned line_parity = 0;
+	unsigned line_parity_prime = 0;
+	unsigned char b;
+
+	for (i = 0; i < n_bytes; i++) {
+		b = column_parity_table[*data++];
+		col_parity ^= b;
+
+		if (b & 0x01) {
+			/* odd number of bits in the byte */
+			line_parity ^= i;
+			line_parity_prime ^= ~i;
+		}
+
+	}
+
+	ecc_other->col_parity = (col_parity >> 2) & 0x3f;
+	ecc_other->line_parity = line_parity;
+	ecc_other->line_parity_prime = line_parity_prime;
+}
+
+int yaffs_ecc_correct_other(unsigned char *data, unsigned n_bytes,
+			    struct yaffs_ecc_other *read_ecc,
+			    const struct yaffs_ecc_other *test_ecc)
+{
+	unsigned char delta_col;	/* column parity delta */
+	unsigned delta_line;	/* line parity delta */
+	unsigned delta_line_prime;	/* line parity delta */
+	unsigned bit;
+
+	delta_col = read_ecc->col_parity ^ test_ecc->col_parity;
+	delta_line = read_ecc->line_parity ^ test_ecc->line_parity;
+	delta_line_prime =
+	    read_ecc->line_parity_prime ^ test_ecc->line_parity_prime;
+
+	if ((delta_col | delta_line | delta_line_prime) == 0)
+		return 0;	/* no error */
+
+	if (delta_line == ~delta_line_prime &&
+	    (((delta_col ^ (delta_col >> 1)) & 0x15) == 0x15)) {
+		/* Single bit (recoverable) error in data */
+
+		bit = 0;
+
+		if (delta_col & 0x20)
+			bit |= 0x04;
+		if (delta_col & 0x08)
+			bit |= 0x02;
+		if (delta_col & 0x02)
+			bit |= 0x01;
+
+		if (delta_line >= n_bytes)
+			return -1;
+
+		data[delta_line] ^= (1 << bit);
+
+		return 1;	/* corrected */
+	}
+
+	if ((hweight32(delta_line) +
+	     hweight32(delta_line_prime) +
+	     hweight8(delta_col)) == 1) {
+		/* Reccoverable error in ecc */
+
+		*read_ecc = *test_ecc;
+		return 1;	/* corrected */
+	}
+
+	/* Unrecoverable error */
+
+	return -1;
+}
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_ecc.h linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_ecc.h
--- linux-3.0.8/fs/yaffs2/yaffs_ecc.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_ecc.h	2021-07-13 23:40:33.782356989 +0300
@@ -0,0 +1,44 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/*
+ * This code implements the ECC algorithm used in SmartMedia.
+ *
+ * The ECC comprises 22 bits of parity information and is stuffed into 3 bytes.
+ * The two unused bit are set to 1.
+ * The ECC can correct single bit errors in a 256-byte page of data.
+ * Thus, two such ECC blocks are used on a 512-byte NAND page.
+ *
+ */
+
+#ifndef __YAFFS_ECC_H__
+#define __YAFFS_ECC_H__
+
+struct yaffs_ecc_other {
+	unsigned char col_parity;
+	unsigned line_parity;
+	unsigned line_parity_prime;
+};
+
+void yaffs_ecc_calc(const unsigned char *data, unsigned char *ecc);
+int yaffs_ecc_correct(unsigned char *data, unsigned char *read_ecc,
+		      const unsigned char *test_ecc);
+
+void yaffs_ecc_calc_other(const unsigned char *data, unsigned n_bytes,
+			  struct yaffs_ecc_other *ecc);
+int yaffs_ecc_correct_other(unsigned char *data, unsigned n_bytes,
+			    struct yaffs_ecc_other *read_ecc,
+			    const struct yaffs_ecc_other *test_ecc);
+#endif
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_getblockinfo.h linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_getblockinfo.h
--- linux-3.0.8/fs/yaffs2/yaffs_getblockinfo.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_getblockinfo.h	2021-07-13 23:40:33.786357014 +0300
@@ -0,0 +1,35 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_GETBLOCKINFO_H__
+#define __YAFFS_GETBLOCKINFO_H__
+
+#include "yaffs_guts.h"
+#include "yaffs_trace.h"
+
+/* Function to manipulate block info */
+static inline struct yaffs_block_info *yaffs_get_block_info(struct yaffs_dev
+							      *dev, int blk)
+{
+	if (blk < dev->internal_start_block || blk > dev->internal_end_block) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"**>> yaffs: get_block_info block %d is not valid",
+			blk);
+		BUG();
+	}
+	return &dev->block_info[blk - dev->internal_start_block];
+}
+
+#endif
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_guts.c linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_guts.c
--- linux-3.0.8/fs/yaffs2/yaffs_guts.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_guts.c	2021-07-13 23:40:33.778356963 +0300
@@ -0,0 +1,5059 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yportenv.h"
+#include "yaffs_trace.h"
+
+#include "yaffs_guts.h"
+#include "yaffs_getblockinfo.h"
+#include "yaffs_tagscompat.h"
+#include "yaffs_tagsmarshall.h"
+#include "yaffs_nand.h"
+#include "yaffs_yaffs1.h"
+#include "yaffs_yaffs2.h"
+#include "yaffs_bitmap.h"
+#include "yaffs_verify.h"
+#include "yaffs_nand.h"
+#include "yaffs_packedtags2.h"
+#include "yaffs_nameval.h"
+#include "yaffs_allocator.h"
+#include "yaffs_attribs.h"
+#include "yaffs_summary.h"
+
+/* Note YAFFS_GC_GOOD_ENOUGH must be <= YAFFS_GC_PASSIVE_THRESHOLD */
+#define YAFFS_GC_GOOD_ENOUGH 2
+#define YAFFS_GC_PASSIVE_THRESHOLD 4
+
+#include "yaffs_ecc.h"
+
+/* Forward declarations */
+
+static int yaffs_wr_data_obj(struct yaffs_obj *in, int inode_chunk,
+			     const u8 *buffer, int n_bytes, int use_reserve);
+
+static void yaffs_fix_null_name(struct yaffs_obj *obj, YCHAR *name,
+				int buffer_size);
+
+/* Function to calculate chunk and offset */
+
+void yaffs_addr_to_chunk(struct yaffs_dev *dev, loff_t addr,
+				int *chunk_out, u32 *offset_out)
+{
+	int chunk;
+	u32 offset;
+
+	chunk = (u32) (addr >> dev->chunk_shift);
+
+	if (dev->chunk_div == 1) {
+		/* easy power of 2 case */
+		offset = (u32) (addr & dev->chunk_mask);
+	} else {
+		/* Non power-of-2 case */
+
+		loff_t chunk_base;
+
+		chunk /= dev->chunk_div;
+
+		chunk_base = ((loff_t) chunk) * dev->data_bytes_per_chunk;
+		offset = (u32) (addr - chunk_base);
+	}
+
+	*chunk_out = chunk;
+	*offset_out = offset;
+}
+
+/* Function to return the number of shifts for a power of 2 greater than or
+ * equal to the given number
+ * Note we don't try to cater for all possible numbers and this does not have to
+ * be hellishly efficient.
+ */
+
+static inline u32 calc_shifts_ceiling(u32 x)
+{
+	int extra_bits;
+	int shifts;
+
+	shifts = extra_bits = 0;
+
+	while (x > 1) {
+		if (x & 1)
+			extra_bits++;
+		x >>= 1;
+		shifts++;
+	}
+
+	if (extra_bits)
+		shifts++;
+
+	return shifts;
+}
+
+/* Function to return the number of shifts to get a 1 in bit 0
+ */
+
+static inline u32 calc_shifts(u32 x)
+{
+	u32 shifts;
+
+	shifts = 0;
+
+	if (!x)
+		return 0;
+
+	while (!(x & 1)) {
+		x >>= 1;
+		shifts++;
+	}
+
+	return shifts;
+}
+
+/*
+ * Temporary buffer manipulations.
+ */
+
+static int yaffs_init_tmp_buffers(struct yaffs_dev *dev)
+{
+	int i;
+	u8 *buf = (u8 *) 1;
+
+	memset(dev->temp_buffer, 0, sizeof(dev->temp_buffer));
+
+	for (i = 0; buf && i < YAFFS_N_TEMP_BUFFERS; i++) {
+		dev->temp_buffer[i].in_use = 0;
+		buf = kmalloc(dev->param.total_bytes_per_chunk, GFP_NOFS);
+		dev->temp_buffer[i].buffer = buf;
+	}
+
+	return buf ? YAFFS_OK : YAFFS_FAIL;
+}
+
+u8 *yaffs_get_temp_buffer(struct yaffs_dev * dev)
+{
+	int i;
+
+	dev->temp_in_use++;
+	if (dev->temp_in_use > dev->max_temp)
+		dev->max_temp = dev->temp_in_use;
+
+	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
+		if (dev->temp_buffer[i].in_use == 0) {
+			dev->temp_buffer[i].in_use = 1;
+			return dev->temp_buffer[i].buffer;
+		}
+	}
+
+	yaffs_trace(YAFFS_TRACE_BUFFERS, "Out of temp buffers");
+	/*
+	 * If we got here then we have to allocate an unmanaged one
+	 * This is not good.
+	 */
+
+	dev->unmanaged_buffer_allocs++;
+	return kmalloc(dev->data_bytes_per_chunk, GFP_NOFS);
+
+}
+
+void yaffs_release_temp_buffer(struct yaffs_dev *dev, u8 *buffer)
+{
+	int i;
+
+	dev->temp_in_use--;
+
+	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
+		if (dev->temp_buffer[i].buffer == buffer) {
+			dev->temp_buffer[i].in_use = 0;
+			return;
+		}
+	}
+
+	if (buffer) {
+		/* assume it is an unmanaged one. */
+		yaffs_trace(YAFFS_TRACE_BUFFERS,
+			"Releasing unmanaged temp buffer");
+		kfree(buffer);
+		dev->unmanaged_buffer_deallocs++;
+	}
+
+}
+
+/*
+ * Functions for robustisizing TODO
+ *
+ */
+
+static void yaffs_handle_chunk_wr_ok(struct yaffs_dev *dev, int nand_chunk,
+				     const u8 *data,
+				     const struct yaffs_ext_tags *tags)
+{
+	(void) dev;
+	(void) nand_chunk;
+	(void) data;
+	(void) tags;
+}
+
+static void yaffs_handle_chunk_update(struct yaffs_dev *dev, int nand_chunk,
+				      const struct yaffs_ext_tags *tags)
+{
+	(void) dev;
+	(void) nand_chunk;
+	(void) tags;
+}
+
+void yaffs_handle_chunk_error(struct yaffs_dev *dev,
+			      struct yaffs_block_info *bi)
+{
+	if (!bi->gc_prioritise) {
+		bi->gc_prioritise = 1;
+		dev->has_pending_prioritised_gc = 1;
+		bi->chunk_error_strikes++;
+
+		if (bi->chunk_error_strikes > 3) {
+			bi->needs_retiring = 1;	/* Too many stikes, so retire */
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"yaffs: Block struck out");
+
+		}
+	}
+}
+
+static void yaffs_handle_chunk_wr_error(struct yaffs_dev *dev, int nand_chunk,
+					int erased_ok)
+{
+	int flash_block = nand_chunk / dev->param.chunks_per_block;
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, flash_block);
+
+	yaffs_handle_chunk_error(dev, bi);
+
+	if (erased_ok) {
+		/* Was an actual write failure,
+		 * so mark the block for retirement.*/
+		bi->needs_retiring = 1;
+		yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+		  "**>> Block %d needs retiring", flash_block);
+	}
+
+	/* Delete the chunk */
+	yaffs_chunk_del(dev, nand_chunk, 1, __LINE__);
+	yaffs_skip_rest_of_block(dev);
+}
+
+/*
+ * Verification code
+ */
+
+/*
+ *  Simple hash function. Needs to have a reasonable spread
+ */
+
+static inline int yaffs_hash_fn(int n)
+{
+	if (n < 0)
+		n = -n;
+	return n % YAFFS_NOBJECT_BUCKETS;
+}
+
+/*
+ * Access functions to useful fake objects.
+ * Note that root might have a presence in NAND if permissions are set.
+ */
+
+struct yaffs_obj *yaffs_root(struct yaffs_dev *dev)
+{
+	return dev->root_dir;
+}
+
+struct yaffs_obj *yaffs_lost_n_found(struct yaffs_dev *dev)
+{
+	return dev->lost_n_found;
+}
+
+/*
+ *  Erased NAND checking functions
+ */
+
+int yaffs_check_ff(u8 *buffer, int n_bytes)
+{
+	/* Horrible, slow implementation */
+	while (n_bytes--) {
+		if (*buffer != 0xff)
+			return 0;
+		buffer++;
+	}
+	return 1;
+}
+
+static int yaffs_check_chunk_erased(struct yaffs_dev *dev, int nand_chunk)
+{
+	int retval = YAFFS_OK;
+	u8 *data = yaffs_get_temp_buffer(dev);
+	struct yaffs_ext_tags tags;
+	int result;
+
+	result = yaffs_rd_chunk_tags_nand(dev, nand_chunk, data, &tags);
+
+	if (tags.ecc_result > YAFFS_ECC_RESULT_NO_ERROR)
+		retval = YAFFS_FAIL;
+
+	if (!yaffs_check_ff(data, dev->data_bytes_per_chunk) ||
+		tags.chunk_used) {
+		yaffs_trace(YAFFS_TRACE_NANDACCESS,
+			"Chunk %d not erased", nand_chunk);
+		retval = YAFFS_FAIL;
+	}
+
+	yaffs_release_temp_buffer(dev, data);
+
+	return retval;
+
+}
+
+static int yaffs_verify_chunk_written(struct yaffs_dev *dev,
+				      int nand_chunk,
+				      const u8 *data,
+				      struct yaffs_ext_tags *tags)
+{
+	int retval = YAFFS_OK;
+	struct yaffs_ext_tags temp_tags;
+	u8 *buffer = yaffs_get_temp_buffer(dev);
+	int result;
+
+	result = yaffs_rd_chunk_tags_nand(dev, nand_chunk, buffer, &temp_tags);
+	if (memcmp(buffer, data, dev->data_bytes_per_chunk) ||
+	    temp_tags.obj_id != tags->obj_id ||
+	    temp_tags.chunk_id != tags->chunk_id ||
+	    temp_tags.n_bytes != tags->n_bytes)
+		retval = YAFFS_FAIL;
+
+	yaffs_release_temp_buffer(dev, buffer);
+
+	return retval;
+}
+
+
+int yaffs_check_alloc_available(struct yaffs_dev *dev, int n_chunks)
+{
+	int reserved_chunks;
+	int reserved_blocks = dev->param.n_reserved_blocks;
+	int checkpt_blocks;
+
+	checkpt_blocks = yaffs_calc_checkpt_blocks_required(dev);
+
+	reserved_chunks =
+	    (reserved_blocks + checkpt_blocks) * dev->param.chunks_per_block;
+
+	return (dev->n_free_chunks > (reserved_chunks + n_chunks));
+}
+
+static int yaffs_find_alloc_block(struct yaffs_dev *dev)
+{
+	int i;
+	struct yaffs_block_info *bi;
+
+	if (dev->n_erased_blocks < 1) {
+		/* Hoosterman we've got a problem.
+		 * Can't get space to gc
+		 */
+		yaffs_trace(YAFFS_TRACE_ERROR,
+		  "yaffs tragedy: no more erased blocks");
+
+		return -1;
+	}
+
+	/* Find an empty block. */
+
+	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
+		dev->alloc_block_finder++;
+		if (dev->alloc_block_finder < dev->internal_start_block
+		    || dev->alloc_block_finder > dev->internal_end_block) {
+			dev->alloc_block_finder = dev->internal_start_block;
+		}
+
+		bi = yaffs_get_block_info(dev, dev->alloc_block_finder);
+
+		if (bi->block_state == YAFFS_BLOCK_STATE_EMPTY) {
+			bi->block_state = YAFFS_BLOCK_STATE_ALLOCATING;
+			dev->seq_number++;
+			bi->seq_number = dev->seq_number;
+			dev->n_erased_blocks--;
+			yaffs_trace(YAFFS_TRACE_ALLOCATE,
+			  "Allocated block %d, seq  %d, %d left" ,
+			   dev->alloc_block_finder, dev->seq_number,
+			   dev->n_erased_blocks);
+			return dev->alloc_block_finder;
+		}
+	}
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs tragedy: no more erased blocks, but there should have been %d",
+		dev->n_erased_blocks);
+
+	return -1;
+}
+
+static int yaffs_alloc_chunk(struct yaffs_dev *dev, int use_reserver,
+			     struct yaffs_block_info **block_ptr)
+{
+	int ret_val;
+	struct yaffs_block_info *bi;
+
+	if (dev->alloc_block < 0) {
+		/* Get next block to allocate off */
+		dev->alloc_block = yaffs_find_alloc_block(dev);
+		dev->alloc_page = 0;
+	}
+
+	if (!use_reserver && !yaffs_check_alloc_available(dev, 1)) {
+		/* No space unless we're allowed to use the reserve. */
+		return -1;
+	}
+
+	if (dev->n_erased_blocks < dev->param.n_reserved_blocks
+	    && dev->alloc_page == 0)
+		yaffs_trace(YAFFS_TRACE_ALLOCATE, "Allocating reserve");
+
+	/* Next page please.... */
+	if (dev->alloc_block >= 0) {
+		bi = yaffs_get_block_info(dev, dev->alloc_block);
+
+		ret_val = (dev->alloc_block * dev->param.chunks_per_block) +
+		    dev->alloc_page;
+		bi->pages_in_use++;
+		yaffs_set_chunk_bit(dev, dev->alloc_block, dev->alloc_page);
+
+		dev->alloc_page++;
+
+		dev->n_free_chunks--;
+
+		/* If the block is full set the state to full */
+		if (dev->alloc_page >= dev->param.chunks_per_block) {
+			bi->block_state = YAFFS_BLOCK_STATE_FULL;
+			dev->alloc_block = -1;
+		}
+
+		if (block_ptr)
+			*block_ptr = bi;
+
+		return ret_val;
+	}
+
+	yaffs_trace(YAFFS_TRACE_ERROR,
+		"!!!!!!!!! Allocator out !!!!!!!!!!!!!!!!!");
+
+	return -1;
+}
+
+static int yaffs_get_erased_chunks(struct yaffs_dev *dev)
+{
+	int n;
+
+	n = dev->n_erased_blocks * dev->param.chunks_per_block;
+
+	if (dev->alloc_block > 0)
+		n += (dev->param.chunks_per_block - dev->alloc_page);
+
+	return n;
+
+}
+
+/*
+ * yaffs_skip_rest_of_block() skips over the rest of the allocation block
+ * if we don't want to write to it.
+ */
+void yaffs_skip_rest_of_block(struct yaffs_dev *dev)
+{
+	struct yaffs_block_info *bi;
+
+	if (dev->alloc_block > 0) {
+		bi = yaffs_get_block_info(dev, dev->alloc_block);
+		if (bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING) {
+			bi->block_state = YAFFS_BLOCK_STATE_FULL;
+			dev->alloc_block = -1;
+		}
+	}
+}
+
+static int yaffs_write_new_chunk(struct yaffs_dev *dev,
+				 const u8 *data,
+				 struct yaffs_ext_tags *tags, int use_reserver)
+{
+	int attempts = 0;
+	int write_ok = 0;
+	int chunk;
+
+	yaffs2_checkpt_invalidate(dev);
+
+	do {
+		struct yaffs_block_info *bi = 0;
+		int erased_ok = 0;
+
+		chunk = yaffs_alloc_chunk(dev, use_reserver, &bi);
+		if (chunk < 0) {
+			/* no space */
+			break;
+		}
+
+		/* First check this chunk is erased, if it needs
+		 * checking.  The checking policy (unless forced
+		 * always on) is as follows:
+		 *
+		 * Check the first page we try to write in a block.
+		 * If the check passes then we don't need to check any
+		 * more.        If the check fails, we check again...
+		 * If the block has been erased, we don't need to check.
+		 *
+		 * However, if the block has been prioritised for gc,
+		 * then we think there might be something odd about
+		 * this block and stop using it.
+		 *
+		 * Rationale: We should only ever see chunks that have
+		 * not been erased if there was a partially written
+		 * chunk due to power loss.  This checking policy should
+		 * catch that case with very few checks and thus save a
+		 * lot of checks that are most likely not needed.
+		 *
+		 * Mods to the above
+		 * If an erase check fails or the write fails we skip the
+		 * rest of the block.
+		 */
+
+		/* let's give it a try */
+		attempts++;
+
+		if (dev->param.always_check_erased)
+			bi->skip_erased_check = 0;
+
+		if (!bi->skip_erased_check) {
+			erased_ok = yaffs_check_chunk_erased(dev, chunk);
+			if (erased_ok != YAFFS_OK) {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+				  "**>> yaffs chunk %d was not erased",
+				  chunk);
+
+				/* If not erased, delete this one,
+				 * skip rest of block and
+				 * try another chunk */
+				yaffs_chunk_del(dev, chunk, 1, __LINE__);
+				yaffs_skip_rest_of_block(dev);
+				continue;
+			}
+		}
+
+		write_ok = yaffs_wr_chunk_tags_nand(dev, chunk, data, tags);
+
+		if (!bi->skip_erased_check)
+			write_ok =
+			    yaffs_verify_chunk_written(dev, chunk, data, tags);
+
+		if (write_ok != YAFFS_OK) {
+			/* Clean up aborted write, skip to next block and
+			 * try another chunk */
+			yaffs_handle_chunk_wr_error(dev, chunk, erased_ok);
+			continue;
+		}
+
+		bi->skip_erased_check = 1;
+
+		/* Copy the data into the robustification buffer */
+		yaffs_handle_chunk_wr_ok(dev, chunk, data, tags);
+
+	} while (write_ok != YAFFS_OK &&
+		 (yaffs_wr_attempts <= 0 || attempts <= yaffs_wr_attempts));
+
+	if (!write_ok)
+		chunk = -1;
+
+	if (attempts > 1) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"**>> yaffs write required %d attempts",
+			attempts);
+		dev->n_retried_writes += (attempts - 1);
+	}
+
+	return chunk;
+}
+
+/*
+ * Block retiring for handling a broken block.
+ */
+
+static void yaffs_retire_block(struct yaffs_dev *dev, int flash_block)
+{
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, flash_block);
+
+	yaffs2_checkpt_invalidate(dev);
+
+	yaffs2_clear_oldest_dirty_seq(dev, bi);
+
+	if (yaffs_mark_bad(dev, flash_block) != YAFFS_OK) {
+		if (yaffs_erase_block(dev, flash_block) != YAFFS_OK) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"yaffs: Failed to mark bad and erase block %d",
+				flash_block);
+		} else {
+			struct yaffs_ext_tags tags;
+			int chunk_id =
+			    flash_block * dev->param.chunks_per_block;
+
+			u8 *buffer = yaffs_get_temp_buffer(dev);
+
+			memset(buffer, 0xff, dev->data_bytes_per_chunk);
+			memset(&tags, 0, sizeof(tags));
+			tags.seq_number = YAFFS_SEQUENCE_BAD_BLOCK;
+			if (dev->tagger.write_chunk_tags_fn(dev, chunk_id -
+							dev->chunk_offset,
+							buffer,
+							&tags) != YAFFS_OK)
+				yaffs_trace(YAFFS_TRACE_ALWAYS,
+					"yaffs: Failed to write bad block marker to block %d",
+					flash_block);
+
+			yaffs_release_temp_buffer(dev, buffer);
+		}
+	}
+
+	bi->block_state = YAFFS_BLOCK_STATE_DEAD;
+	bi->gc_prioritise = 0;
+	bi->needs_retiring = 0;
+
+	dev->n_retired_blocks++;
+}
+
+/*---------------- Name handling functions ------------*/
+
+static u16 yaffs_calc_name_sum(const YCHAR *name)
+{
+	u16 sum = 0;
+	u16 i = 1;
+
+	if (!name)
+		return 0;
+
+	while ((*name) && i < (YAFFS_MAX_NAME_LENGTH / 2)) {
+
+		/* 0x1f mask is case insensitive */
+		sum += ((*name) & 0x1f) * i;
+		i++;
+		name++;
+	}
+	return sum;
+}
+
+
+void yaffs_set_obj_name(struct yaffs_obj *obj, const YCHAR * name)
+{
+	memset(obj->short_name, 0, sizeof(obj->short_name));
+
+	if (name && !name[0]) {
+		yaffs_fix_null_name(obj, obj->short_name,
+				YAFFS_SHORT_NAME_LENGTH);
+		name = obj->short_name;
+	} else if (name &&
+		strnlen(name, YAFFS_SHORT_NAME_LENGTH + 1) <=
+		YAFFS_SHORT_NAME_LENGTH)  {
+		strcpy(obj->short_name, name);
+	}
+
+	obj->sum = yaffs_calc_name_sum(name);
+}
+
+void yaffs_set_obj_name_from_oh(struct yaffs_obj *obj,
+				const struct yaffs_obj_hdr *oh)
+{
+#ifdef CONFIG_YAFFS_AUTO_UNICODE
+	YCHAR tmp_name[YAFFS_MAX_NAME_LENGTH + 1];
+	memset(tmp_name, 0, sizeof(tmp_name));
+	yaffs_load_name_from_oh(obj->my_dev, tmp_name, oh->name,
+				YAFFS_MAX_NAME_LENGTH + 1);
+	yaffs_set_obj_name(obj, tmp_name);
+#else
+	yaffs_set_obj_name(obj, oh->name);
+#endif
+}
+
+loff_t yaffs_max_file_size(struct yaffs_dev *dev)
+{
+	if(sizeof(loff_t) < 8)
+		return YAFFS_MAX_FILE_SIZE_32;
+	else
+		return ((loff_t) YAFFS_MAX_CHUNK_ID) * dev->data_bytes_per_chunk;
+}
+
+/*-------------------- TNODES -------------------
+
+ * List of spare tnodes
+ * The list is hooked together using the first pointer
+ * in the tnode.
+ */
+
+struct yaffs_tnode *yaffs_get_tnode(struct yaffs_dev *dev)
+{
+	struct yaffs_tnode *tn = yaffs_alloc_raw_tnode(dev);
+
+	if (tn) {
+		memset(tn, 0, dev->tnode_size);
+		dev->n_tnodes++;
+	}
+
+	dev->checkpoint_blocks_required = 0;	/* force recalculation */
+
+	return tn;
+}
+
+/* FreeTnode frees up a tnode and puts it back on the free list */
+static void yaffs_free_tnode(struct yaffs_dev *dev, struct yaffs_tnode *tn)
+{
+	yaffs_free_raw_tnode(dev, tn);
+	dev->n_tnodes--;
+	dev->checkpoint_blocks_required = 0;	/* force recalculation */
+}
+
+static void yaffs_deinit_tnodes_and_objs(struct yaffs_dev *dev)
+{
+	yaffs_deinit_raw_tnodes_and_objs(dev);
+	dev->n_obj = 0;
+	dev->n_tnodes = 0;
+}
+
+static void yaffs_load_tnode_0(struct yaffs_dev *dev, struct yaffs_tnode *tn,
+			unsigned pos, unsigned val)
+{
+	u32 *map = (u32 *) tn;
+	u32 bit_in_map;
+	u32 bit_in_word;
+	u32 word_in_map;
+	u32 mask;
+
+	pos &= YAFFS_TNODES_LEVEL0_MASK;
+	val >>= dev->chunk_grp_bits;
+
+	bit_in_map = pos * dev->tnode_width;
+	word_in_map = bit_in_map / 32;
+	bit_in_word = bit_in_map & (32 - 1);
+
+	mask = dev->tnode_mask << bit_in_word;
+
+	map[word_in_map] &= ~mask;
+	map[word_in_map] |= (mask & (val << bit_in_word));
+
+	if (dev->tnode_width > (32 - bit_in_word)) {
+		bit_in_word = (32 - bit_in_word);
+		word_in_map++;
+		mask =
+		    dev->tnode_mask >> bit_in_word;
+		map[word_in_map] &= ~mask;
+		map[word_in_map] |= (mask & (val >> bit_in_word));
+	}
+}
+
+u32 yaffs_get_group_base(struct yaffs_dev *dev, struct yaffs_tnode *tn,
+			 unsigned pos)
+{
+	u32 *map = (u32 *) tn;
+	u32 bit_in_map;
+	u32 bit_in_word;
+	u32 word_in_map;
+	u32 val;
+
+	pos &= YAFFS_TNODES_LEVEL0_MASK;
+
+	bit_in_map = pos * dev->tnode_width;
+	word_in_map = bit_in_map / 32;
+	bit_in_word = bit_in_map & (32 - 1);
+
+	val = map[word_in_map] >> bit_in_word;
+
+	if (dev->tnode_width > (32 - bit_in_word)) {
+		bit_in_word = (32 - bit_in_word);
+		word_in_map++;
+		val |= (map[word_in_map] << bit_in_word);
+	}
+
+	val &= dev->tnode_mask;
+	val <<= dev->chunk_grp_bits;
+
+	return val;
+}
+
+/* ------------------- End of individual tnode manipulation -----------------*/
+
+/* ---------Functions to manipulate the look-up tree (made up of tnodes) ------
+ * The look up tree is represented by the top tnode and the number of top_level
+ * in the tree. 0 means only the level 0 tnode is in the tree.
+ */
+
+/* FindLevel0Tnode finds the level 0 tnode, if one exists. */
+struct yaffs_tnode *yaffs_find_tnode_0(struct yaffs_dev *dev,
+				       struct yaffs_file_var *file_struct,
+				       u32 chunk_id)
+{
+	struct yaffs_tnode *tn = file_struct->top;
+	u32 i;
+	int required_depth;
+	int level = file_struct->top_level;
+
+	(void) dev;
+
+	/* Check sane level and chunk Id */
+	if (level < 0 || level > YAFFS_TNODES_MAX_LEVEL)
+		return NULL;
+
+	if (chunk_id > YAFFS_MAX_CHUNK_ID)
+		return NULL;
+
+	/* First check we're tall enough (ie enough top_level) */
+
+	i = chunk_id >> YAFFS_TNODES_LEVEL0_BITS;
+	required_depth = 0;
+	while (i) {
+		i >>= YAFFS_TNODES_INTERNAL_BITS;
+		required_depth++;
+	}
+
+	if (required_depth > file_struct->top_level)
+		return NULL;	/* Not tall enough, so we can't find it */
+
+	/* Traverse down to level 0 */
+	while (level > 0 && tn) {
+		tn = tn->internal[(chunk_id >>
+				   (YAFFS_TNODES_LEVEL0_BITS +
+				    (level - 1) *
+				    YAFFS_TNODES_INTERNAL_BITS)) &
+				  YAFFS_TNODES_INTERNAL_MASK];
+		level--;
+	}
+
+	return tn;
+}
+
+/* add_find_tnode_0 finds the level 0 tnode if it exists,
+ * otherwise first expands the tree.
+ * This happens in two steps:
+ *  1. If the tree isn't tall enough, then make it taller.
+ *  2. Scan down the tree towards the level 0 tnode adding tnodes if required.
+ *
+ * Used when modifying the tree.
+ *
+ *  If the tn argument is NULL, then a fresh tnode will be added otherwise the
+ *  specified tn will be plugged into the ttree.
+ */
+
+struct yaffs_tnode *yaffs_add_find_tnode_0(struct yaffs_dev *dev,
+					   struct yaffs_file_var *file_struct,
+					   u32 chunk_id,
+					   struct yaffs_tnode *passed_tn)
+{
+	int required_depth;
+	int i;
+	int l;
+	struct yaffs_tnode *tn;
+	u32 x;
+
+	/* Check sane level and page Id */
+	if (file_struct->top_level < 0 ||
+	    file_struct->top_level > YAFFS_TNODES_MAX_LEVEL)
+		return NULL;
+
+	if (chunk_id > YAFFS_MAX_CHUNK_ID)
+		return NULL;
+
+	/* First check we're tall enough (ie enough top_level) */
+
+	x = chunk_id >> YAFFS_TNODES_LEVEL0_BITS;
+	required_depth = 0;
+	while (x) {
+		x >>= YAFFS_TNODES_INTERNAL_BITS;
+		required_depth++;
+	}
+
+	if (required_depth > file_struct->top_level) {
+		/* Not tall enough, gotta make the tree taller */
+		for (i = file_struct->top_level; i < required_depth; i++) {
+
+			tn = yaffs_get_tnode(dev);
+
+			if (tn) {
+				tn->internal[0] = file_struct->top;
+				file_struct->top = tn;
+				file_struct->top_level++;
+			} else {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"yaffs: no more tnodes");
+				return NULL;
+			}
+		}
+	}
+
+	/* Traverse down to level 0, adding anything we need */
+
+	l = file_struct->top_level;
+	tn = file_struct->top;
+
+	if (l > 0) {
+		while (l > 0 && tn) {
+			x = (chunk_id >>
+			     (YAFFS_TNODES_LEVEL0_BITS +
+			      (l - 1) * YAFFS_TNODES_INTERNAL_BITS)) &
+			    YAFFS_TNODES_INTERNAL_MASK;
+
+			if ((l > 1) && !tn->internal[x]) {
+				/* Add missing non-level-zero tnode */
+				tn->internal[x] = yaffs_get_tnode(dev);
+				if (!tn->internal[x])
+					return NULL;
+			} else if (l == 1) {
+				/* Looking from level 1 at level 0 */
+				if (passed_tn) {
+					/* If we already have one, release it */
+					if (tn->internal[x])
+						yaffs_free_tnode(dev,
+							tn->internal[x]);
+					tn->internal[x] = passed_tn;
+
+				} else if (!tn->internal[x]) {
+					/* Don't have one, none passed in */
+					tn->internal[x] = yaffs_get_tnode(dev);
+					if (!tn->internal[x])
+						return NULL;
+				}
+			}
+
+			tn = tn->internal[x];
+			l--;
+		}
+	} else {
+		/* top is level 0 */
+		if (passed_tn) {
+			memcpy(tn, passed_tn,
+			       (dev->tnode_width * YAFFS_NTNODES_LEVEL0) / 8);
+			yaffs_free_tnode(dev, passed_tn);
+		}
+	}
+
+	return tn;
+}
+
+static int yaffs_tags_match(const struct yaffs_ext_tags *tags, int obj_id,
+			    int chunk_obj)
+{
+	return (tags->chunk_id == chunk_obj &&
+		tags->obj_id == obj_id &&
+		!tags->is_deleted) ? 1 : 0;
+
+}
+
+static int yaffs_find_chunk_in_group(struct yaffs_dev *dev, int the_chunk,
+					struct yaffs_ext_tags *tags, int obj_id,
+					int inode_chunk)
+{
+	int j;
+
+	for (j = 0; the_chunk && j < dev->chunk_grp_size; j++) {
+		if (yaffs_check_chunk_bit
+		    (dev, the_chunk / dev->param.chunks_per_block,
+		     the_chunk % dev->param.chunks_per_block)) {
+
+			if (dev->chunk_grp_size == 1)
+				return the_chunk;
+			else {
+				yaffs_rd_chunk_tags_nand(dev, the_chunk, NULL,
+							 tags);
+				if (yaffs_tags_match(tags,
+							obj_id, inode_chunk)) {
+					/* found it; */
+					return the_chunk;
+				}
+			}
+		}
+		the_chunk++;
+	}
+	return -1;
+}
+
+static int yaffs_find_chunk_in_file(struct yaffs_obj *in, int inode_chunk,
+				    struct yaffs_ext_tags *tags)
+{
+	/*Get the Tnode, then get the level 0 offset chunk offset */
+	struct yaffs_tnode *tn;
+	int the_chunk = -1;
+	struct yaffs_ext_tags local_tags;
+	int ret_val = -1;
+	struct yaffs_dev *dev = in->my_dev;
+
+	if (!tags) {
+		/* Passed a NULL, so use our own tags space */
+		tags = &local_tags;
+	}
+
+	tn = yaffs_find_tnode_0(dev, &in->variant.file_variant, inode_chunk);
+
+	if (!tn)
+		return ret_val;
+
+	the_chunk = yaffs_get_group_base(dev, tn, inode_chunk);
+
+	ret_val = yaffs_find_chunk_in_group(dev, the_chunk, tags, in->obj_id,
+					      inode_chunk);
+	return ret_val;
+}
+
+static int yaffs_find_del_file_chunk(struct yaffs_obj *in, int inode_chunk,
+				     struct yaffs_ext_tags *tags)
+{
+	/* Get the Tnode, then get the level 0 offset chunk offset */
+	struct yaffs_tnode *tn;
+	int the_chunk = -1;
+	struct yaffs_ext_tags local_tags;
+	struct yaffs_dev *dev = in->my_dev;
+	int ret_val = -1;
+
+	if (!tags) {
+		/* Passed a NULL, so use our own tags space */
+		tags = &local_tags;
+	}
+
+	tn = yaffs_find_tnode_0(dev, &in->variant.file_variant, inode_chunk);
+
+	if (!tn)
+		return ret_val;
+
+	the_chunk = yaffs_get_group_base(dev, tn, inode_chunk);
+
+	ret_val = yaffs_find_chunk_in_group(dev, the_chunk, tags, in->obj_id,
+					      inode_chunk);
+
+	/* Delete the entry in the filestructure (if found) */
+	if (ret_val != -1)
+		yaffs_load_tnode_0(dev, tn, inode_chunk, 0);
+
+	return ret_val;
+}
+
+int yaffs_put_chunk_in_file(struct yaffs_obj *in, int inode_chunk,
+			    int nand_chunk, int in_scan)
+{
+	/* NB in_scan is zero unless scanning.
+	 * For forward scanning, in_scan is > 0;
+	 * for backward scanning in_scan is < 0
+	 *
+	 * nand_chunk = 0 is a dummy insert to make sure the tnodes are there.
+	 */
+
+	struct yaffs_tnode *tn;
+	struct yaffs_dev *dev = in->my_dev;
+	int existing_cunk;
+	struct yaffs_ext_tags existing_tags;
+	struct yaffs_ext_tags new_tags;
+	unsigned existing_serial, new_serial;
+
+	if (in->variant_type != YAFFS_OBJECT_TYPE_FILE) {
+		/* Just ignore an attempt at putting a chunk into a non-file
+		 * during scanning.
+		 * If it is not during Scanning then something went wrong!
+		 */
+		if (!in_scan) {
+			yaffs_trace(YAFFS_TRACE_ERROR,
+				"yaffs tragedy:attempt to put data chunk into a non-file"
+				);
+			BUG();
+		}
+
+		yaffs_chunk_del(dev, nand_chunk, 1, __LINE__);
+		return YAFFS_OK;
+	}
+
+	tn = yaffs_add_find_tnode_0(dev,
+				    &in->variant.file_variant,
+				    inode_chunk, NULL);
+	if (!tn)
+		return YAFFS_FAIL;
+
+	if (!nand_chunk)
+		/* Dummy insert, bail now */
+		return YAFFS_OK;
+
+	existing_cunk = yaffs_get_group_base(dev, tn, inode_chunk);
+
+	if (in_scan != 0) {
+		/* If we're scanning then we need to test for duplicates
+		 * NB This does not need to be efficient since it should only
+		 * happen when the power fails during a write, then only one
+		 * chunk should ever be affected.
+		 *
+		 * Correction for YAFFS2: This could happen quite a lot and we
+		 * need to think about efficiency! TODO
+		 * Update: For backward scanning we don't need to re-read tags
+		 * so this is quite cheap.
+		 */
+
+		if (existing_cunk > 0) {
+			/* NB Right now existing chunk will not be real
+			 * chunk_id if the chunk group size > 1
+			 * thus we have to do a FindChunkInFile to get the
+			 * real chunk id.
+			 *
+			 * We have a duplicate now we need to decide which
+			 * one to use:
+			 *
+			 * Backwards scanning YAFFS2: The old one is what
+			 * we use, dump the new one.
+			 * YAFFS1: Get both sets of tags and compare serial
+			 * numbers.
+			 */
+
+			if (in_scan > 0) {
+				/* Only do this for forward scanning */
+				yaffs_rd_chunk_tags_nand(dev,
+							 nand_chunk,
+							 NULL, &new_tags);
+
+				/* Do a proper find */
+				existing_cunk =
+				    yaffs_find_chunk_in_file(in, inode_chunk,
+							     &existing_tags);
+			}
+
+			if (existing_cunk <= 0) {
+				/*Hoosterman - how did this happen? */
+
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"yaffs tragedy: existing chunk < 0 in scan"
+					);
+
+			}
+
+			/* NB The deleted flags should be false, otherwise
+			 * the chunks will not be loaded during a scan
+			 */
+
+			if (in_scan > 0) {
+				new_serial = new_tags.serial_number;
+				existing_serial = existing_tags.serial_number;
+			}
+
+			if ((in_scan > 0) &&
+			    (existing_cunk <= 0 ||
+			     ((existing_serial + 1) & 3) == new_serial)) {
+				/* Forward scanning.
+				 * Use new
+				 * Delete the old one and drop through to
+				 * update the tnode
+				 */
+				yaffs_chunk_del(dev, existing_cunk, 1,
+						__LINE__);
+			} else {
+				/* Backward scanning or we want to use the
+				 * existing one
+				 * Delete the new one and return early so that
+				 * the tnode isn't changed
+				 */
+				yaffs_chunk_del(dev, nand_chunk, 1, __LINE__);
+				return YAFFS_OK;
+			}
+		}
+
+	}
+
+	if (existing_cunk == 0)
+		in->n_data_chunks++;
+
+	yaffs_load_tnode_0(dev, tn, inode_chunk, nand_chunk);
+
+	return YAFFS_OK;
+}
+
+static void yaffs_soft_del_chunk(struct yaffs_dev *dev, int chunk)
+{
+	struct yaffs_block_info *the_block;
+	unsigned block_no;
+
+	yaffs_trace(YAFFS_TRACE_DELETION, "soft delete chunk %d", chunk);
+
+	block_no = chunk / dev->param.chunks_per_block;
+	the_block = yaffs_get_block_info(dev, block_no);
+	if (the_block) {
+		the_block->soft_del_pages++;
+		dev->n_free_chunks++;
+		yaffs2_update_oldest_dirty_seq(dev, block_no, the_block);
+	}
+}
+
+/* SoftDeleteWorker scans backwards through the tnode tree and soft deletes all
+ * the chunks in the file.
+ * All soft deleting does is increment the block's softdelete count and pulls
+ * the chunk out of the tnode.
+ * Thus, essentially this is the same as DeleteWorker except that the chunks
+ * are soft deleted.
+ */
+
+static int yaffs_soft_del_worker(struct yaffs_obj *in, struct yaffs_tnode *tn,
+				 u32 level, int chunk_offset)
+{
+	int i;
+	int the_chunk;
+	int all_done = 1;
+	struct yaffs_dev *dev = in->my_dev;
+
+	if (!tn)
+		return 1;
+
+	if (level > 0) {
+		for (i = YAFFS_NTNODES_INTERNAL - 1;
+			all_done && i >= 0;
+			i--) {
+			if (tn->internal[i]) {
+				all_done =
+				    yaffs_soft_del_worker(in,
+					tn->internal[i],
+					level - 1,
+					(chunk_offset <<
+					YAFFS_TNODES_INTERNAL_BITS)
+					+ i);
+				if (all_done) {
+					yaffs_free_tnode(dev,
+						tn->internal[i]);
+					tn->internal[i] = NULL;
+				} else {
+					/* Can this happen? */
+				}
+			}
+		}
+		return (all_done) ? 1 : 0;
+	}
+
+	/* level 0 */
+	 for (i = YAFFS_NTNODES_LEVEL0 - 1; i >= 0; i--) {
+		the_chunk = yaffs_get_group_base(dev, tn, i);
+		if (the_chunk) {
+			yaffs_soft_del_chunk(dev, the_chunk);
+			yaffs_load_tnode_0(dev, tn, i, 0);
+		}
+	}
+	return 1;
+}
+
+static void yaffs_remove_obj_from_dir(struct yaffs_obj *obj)
+{
+	struct yaffs_dev *dev = obj->my_dev;
+	struct yaffs_obj *parent;
+
+	yaffs_verify_obj_in_dir(obj);
+	parent = obj->parent;
+
+	yaffs_verify_dir(parent);
+
+	if (dev && dev->param.remove_obj_fn)
+		dev->param.remove_obj_fn(obj);
+
+	list_del_init(&obj->siblings);
+	obj->parent = NULL;
+
+	yaffs_verify_dir(parent);
+}
+
+void yaffs_add_obj_to_dir(struct yaffs_obj *directory, struct yaffs_obj *obj)
+{
+	if (!directory) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"tragedy: Trying to add an object to a null pointer directory"
+			);
+		BUG();
+		return;
+	}
+	if (directory->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"tragedy: Trying to add an object to a non-directory"
+			);
+		BUG();
+	}
+
+	if (obj->siblings.prev == NULL) {
+		/* Not initialised */
+		BUG();
+	}
+
+	yaffs_verify_dir(directory);
+
+	yaffs_remove_obj_from_dir(obj);
+
+	/* Now add it */
+	list_add(&obj->siblings, &directory->variant.dir_variant.children);
+	obj->parent = directory;
+
+	if (directory == obj->my_dev->unlinked_dir
+	    || directory == obj->my_dev->del_dir) {
+		obj->unlinked = 1;
+		obj->my_dev->n_unlinked_files++;
+		obj->rename_allowed = 0;
+	}
+
+	yaffs_verify_dir(directory);
+	yaffs_verify_obj_in_dir(obj);
+}
+
+static int yaffs_change_obj_name(struct yaffs_obj *obj,
+				 struct yaffs_obj *new_dir,
+				 const YCHAR *new_name, int force, int shadows)
+{
+	int unlink_op;
+	int del_op;
+	struct yaffs_obj *existing_target;
+
+	if (new_dir == NULL)
+		new_dir = obj->parent;	/* use the old directory */
+
+	if (new_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"tragedy: yaffs_change_obj_name: new_dir is not a directory"
+			);
+		BUG();
+	}
+
+	unlink_op = (new_dir == obj->my_dev->unlinked_dir);
+	del_op = (new_dir == obj->my_dev->del_dir);
+
+	existing_target = yaffs_find_by_name(new_dir, new_name);
+
+	/* If the object is a file going into the unlinked directory,
+	 *   then it is OK to just stuff it in since duplicate names are OK.
+	 *   else only proceed if the new name does not exist and we're putting
+	 *   it into a directory.
+	 */
+	if (!(unlink_op || del_op || force ||
+	      shadows > 0 || !existing_target) ||
+	      new_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY)
+		return YAFFS_FAIL;
+
+	yaffs_set_obj_name(obj, new_name);
+	obj->dirty = 1;
+	yaffs_add_obj_to_dir(new_dir, obj);
+
+	if (unlink_op)
+		obj->unlinked = 1;
+
+	/* If it is a deletion then we mark it as a shrink for gc  */
+	if (yaffs_update_oh(obj, new_name, 0, del_op, shadows, NULL) >= 0)
+		return YAFFS_OK;
+
+	return YAFFS_FAIL;
+}
+
+/*------------------------ Short Operations Cache ------------------------------
+ *   In many situations where there is no high level buffering  a lot of
+ *   reads might be short sequential reads, and a lot of writes may be short
+ *   sequential writes. eg. scanning/writing a jpeg file.
+ *   In these cases, a short read/write cache can provide a huge perfomance
+ *   benefit with dumb-as-a-rock code.
+ *   In Linux, the page cache provides read buffering and the short op cache
+ *   provides write buffering.
+ *
+ *   There are a small number (~10) of cache chunks per device so that we don't
+ *   need a very intelligent search.
+ */
+
+static int yaffs_obj_cache_dirty(struct yaffs_obj *obj)
+{
+	struct yaffs_dev *dev = obj->my_dev;
+	int i;
+	struct yaffs_cache *cache;
+	int n_caches = obj->my_dev->param.n_caches;
+
+	for (i = 0; i < n_caches; i++) {
+		cache = &dev->cache[i];
+		if (cache->object == obj && cache->dirty)
+			return 1;
+	}
+
+	return 0;
+}
+
+static void yaffs_flush_file_cache(struct yaffs_obj *obj)
+{
+	struct yaffs_dev *dev = obj->my_dev;
+	int lowest = -99;	/* Stop compiler whining. */
+	int i;
+	struct yaffs_cache *cache;
+	int chunk_written = 0;
+	int n_caches = obj->my_dev->param.n_caches;
+
+	if (n_caches < 1)
+		return;
+	do {
+		cache = NULL;
+
+		/* Find the lowest dirty chunk for this object */
+		for (i = 0; i < n_caches; i++) {
+			if (dev->cache[i].object == obj &&
+			    dev->cache[i].dirty) {
+				if (!cache ||
+				    dev->cache[i].chunk_id < lowest) {
+					cache = &dev->cache[i];
+					lowest = cache->chunk_id;
+				}
+			}
+		}
+
+		if (cache && !cache->locked) {
+			/* Write it out and free it up */
+			chunk_written =
+			    yaffs_wr_data_obj(cache->object,
+					      cache->chunk_id,
+					      cache->data,
+					      cache->n_bytes, 1);
+			cache->dirty = 0;
+			cache->object = NULL;
+		}
+	} while (cache && chunk_written > 0);
+
+	if (cache)
+		/* Hoosterman, disk full while writing cache out. */
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"yaffs tragedy: no space during cache write");
+}
+
+/*yaffs_flush_whole_cache(dev)
+ *
+ *
+ */
+
+void yaffs_flush_whole_cache(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj;
+	int n_caches = dev->param.n_caches;
+	int i;
+
+	/* Find a dirty object in the cache and flush it...
+	 * until there are no further dirty objects.
+	 */
+	do {
+		obj = NULL;
+		for (i = 0; i < n_caches && !obj; i++) {
+			if (dev->cache[i].object && dev->cache[i].dirty)
+				obj = dev->cache[i].object;
+		}
+		if (obj)
+			yaffs_flush_file_cache(obj);
+	} while (obj);
+
+}
+
+/* Grab us a cache chunk for use.
+ * First look for an empty one.
+ * Then look for the least recently used non-dirty one.
+ * Then look for the least recently used dirty one...., flush and look again.
+ */
+static struct yaffs_cache *yaffs_grab_chunk_worker(struct yaffs_dev *dev)
+{
+	int i;
+
+	if (dev->param.n_caches > 0) {
+		for (i = 0; i < dev->param.n_caches; i++) {
+			if (!dev->cache[i].object)
+				return &dev->cache[i];
+		}
+	}
+	return NULL;
+}
+
+static struct yaffs_cache *yaffs_grab_chunk_cache(struct yaffs_dev *dev)
+{
+	struct yaffs_cache *cache;
+	struct yaffs_obj *the_obj;
+	int usage;
+	int i;
+	int pushout;
+
+	if (dev->param.n_caches < 1)
+		return NULL;
+
+	/* Try find a non-dirty one... */
+
+	cache = yaffs_grab_chunk_worker(dev);
+
+	if (!cache) {
+		/* They were all dirty, find the LRU object and flush
+		 * its cache, then  find again.
+		 * NB what's here is not very accurate,
+		 * we actually flush the object with the LRU chunk.
+		 */
+
+		/* With locking we can't assume we can use entry zero,
+		 * Set the_obj to a valid pointer for Coverity. */
+		the_obj = dev->cache[0].object;
+		usage = -1;
+		cache = NULL;
+		pushout = -1;
+
+		for (i = 0; i < dev->param.n_caches; i++) {
+			if (dev->cache[i].object &&
+			    !dev->cache[i].locked &&
+			    (dev->cache[i].last_use < usage ||
+			    !cache)) {
+				usage = dev->cache[i].last_use;
+				the_obj = dev->cache[i].object;
+				cache = &dev->cache[i];
+				pushout = i;
+			}
+		}
+
+		if (!cache || cache->dirty) {
+			/* Flush and try again */
+			yaffs_flush_file_cache(the_obj);
+			cache = yaffs_grab_chunk_worker(dev);
+		}
+	}
+	return cache;
+}
+
+/* Find a cached chunk */
+static struct yaffs_cache *yaffs_find_chunk_cache(const struct yaffs_obj *obj,
+						  int chunk_id)
+{
+	struct yaffs_dev *dev = obj->my_dev;
+	int i;
+
+	if (dev->param.n_caches < 1)
+		return NULL;
+
+	for (i = 0; i < dev->param.n_caches; i++) {
+		if (dev->cache[i].object == obj &&
+		    dev->cache[i].chunk_id == chunk_id) {
+			dev->cache_hits++;
+
+			return &dev->cache[i];
+		}
+	}
+	return NULL;
+}
+
+/* Mark the chunk for the least recently used algorithym */
+static void yaffs_use_cache(struct yaffs_dev *dev, struct yaffs_cache *cache,
+			    int is_write)
+{
+	int i;
+
+	if (dev->param.n_caches < 1)
+		return;
+
+	if (dev->cache_last_use < 0 ||
+		dev->cache_last_use > 100000000) {
+		/* Reset the cache usages */
+		for (i = 1; i < dev->param.n_caches; i++)
+			dev->cache[i].last_use = 0;
+
+		dev->cache_last_use = 0;
+	}
+	dev->cache_last_use++;
+	cache->last_use = dev->cache_last_use;
+
+	if (is_write)
+		cache->dirty = 1;
+}
+
+/* Invalidate a single cache page.
+ * Do this when a whole page gets written,
+ * ie the short cache for this page is no longer valid.
+ */
+static void yaffs_invalidate_chunk_cache(struct yaffs_obj *object, int chunk_id)
+{
+	struct yaffs_cache *cache;
+
+	if (object->my_dev->param.n_caches > 0) {
+		cache = yaffs_find_chunk_cache(object, chunk_id);
+
+		if (cache)
+			cache->object = NULL;
+	}
+}
+
+/* Invalidate all the cache pages associated with this object
+ * Do this whenever ther file is deleted or resized.
+ */
+static void yaffs_invalidate_whole_cache(struct yaffs_obj *in)
+{
+	int i;
+	struct yaffs_dev *dev = in->my_dev;
+
+	if (dev->param.n_caches > 0) {
+		/* Invalidate it. */
+		for (i = 0; i < dev->param.n_caches; i++) {
+			if (dev->cache[i].object == in)
+				dev->cache[i].object = NULL;
+		}
+	}
+}
+
+static void yaffs_unhash_obj(struct yaffs_obj *obj)
+{
+	int bucket;
+	struct yaffs_dev *dev = obj->my_dev;
+
+	/* If it is still linked into the bucket list, free from the list */
+	if (!list_empty(&obj->hash_link)) {
+		list_del_init(&obj->hash_link);
+		bucket = yaffs_hash_fn(obj->obj_id);
+		dev->obj_bucket[bucket].count--;
+	}
+}
+
+/*  FreeObject frees up a Object and puts it back on the free list */
+static void yaffs_free_obj(struct yaffs_obj *obj)
+{
+	struct yaffs_dev *dev;
+
+	if (!obj) {
+		BUG();
+		return;
+	}
+	dev = obj->my_dev;
+	yaffs_trace(YAFFS_TRACE_OS, "FreeObject %p inode %p",
+		obj, obj->my_inode);
+	if (obj->parent)
+		BUG();
+	if (!list_empty(&obj->siblings))
+		BUG();
+
+	if (obj->my_inode) {
+		/* We're still hooked up to a cached inode.
+		 * Don't delete now, but mark for later deletion
+		 */
+		obj->defered_free = 1;
+		return;
+	}
+
+	yaffs_unhash_obj(obj);
+
+	yaffs_free_raw_obj(dev, obj);
+	dev->n_obj--;
+	dev->checkpoint_blocks_required = 0;	/* force recalculation */
+}
+
+void yaffs_handle_defered_free(struct yaffs_obj *obj)
+{
+	if (obj->defered_free)
+		yaffs_free_obj(obj);
+}
+
+static int yaffs_generic_obj_del(struct yaffs_obj *in)
+{
+	/* Iinvalidate the file's data in the cache, without flushing. */
+	yaffs_invalidate_whole_cache(in);
+
+	if (in->my_dev->param.is_yaffs2 && in->parent != in->my_dev->del_dir) {
+		/* Move to unlinked directory so we have a deletion record */
+		yaffs_change_obj_name(in, in->my_dev->del_dir, _Y("deleted"), 0,
+				      0);
+	}
+
+	yaffs_remove_obj_from_dir(in);
+	yaffs_chunk_del(in->my_dev, in->hdr_chunk, 1, __LINE__);
+	in->hdr_chunk = 0;
+
+	yaffs_free_obj(in);
+	return YAFFS_OK;
+
+}
+
+static void yaffs_soft_del_file(struct yaffs_obj *obj)
+{
+	if (!obj->deleted ||
+	    obj->variant_type != YAFFS_OBJECT_TYPE_FILE ||
+	    obj->soft_del)
+		return;
+
+	if (obj->n_data_chunks <= 0) {
+		/* Empty file with no duplicate object headers,
+		 * just delete it immediately */
+		yaffs_free_tnode(obj->my_dev, obj->variant.file_variant.top);
+		obj->variant.file_variant.top = NULL;
+		yaffs_trace(YAFFS_TRACE_TRACING,
+			"yaffs: Deleting empty file %d",
+			obj->obj_id);
+		yaffs_generic_obj_del(obj);
+	} else {
+		yaffs_soft_del_worker(obj,
+				      obj->variant.file_variant.top,
+				      obj->variant.
+				      file_variant.top_level, 0);
+		obj->soft_del = 1;
+	}
+}
+
+/* Pruning removes any part of the file structure tree that is beyond the
+ * bounds of the file (ie that does not point to chunks).
+ *
+ * A file should only get pruned when its size is reduced.
+ *
+ * Before pruning, the chunks must be pulled from the tree and the
+ * level 0 tnode entries must be zeroed out.
+ * Could also use this for file deletion, but that's probably better handled
+ * by a special case.
+ *
+ * This function is recursive. For levels > 0 the function is called again on
+ * any sub-tree. For level == 0 we just check if the sub-tree has data.
+ * If there is no data in a subtree then it is pruned.
+ */
+
+static struct yaffs_tnode *yaffs_prune_worker(struct yaffs_dev *dev,
+					      struct yaffs_tnode *tn, u32 level,
+					      int del0)
+{
+	int i;
+	int has_data;
+
+	if (!tn)
+		return tn;
+
+	has_data = 0;
+
+	if (level > 0) {
+		for (i = 0; i < YAFFS_NTNODES_INTERNAL; i++) {
+			if (tn->internal[i]) {
+				tn->internal[i] =
+				    yaffs_prune_worker(dev,
+						tn->internal[i],
+						level - 1,
+						(i == 0) ? del0 : 1);
+			}
+
+			if (tn->internal[i])
+				has_data++;
+		}
+	} else {
+		int tnode_size_u32 = dev->tnode_size / sizeof(u32);
+		u32 *map = (u32 *) tn;
+
+		for (i = 0; !has_data && i < tnode_size_u32; i++) {
+			if (map[i])
+				has_data++;
+		}
+	}
+
+	if (has_data == 0 && del0) {
+		/* Free and return NULL */
+		yaffs_free_tnode(dev, tn);
+		tn = NULL;
+	}
+	return tn;
+}
+
+static int yaffs_prune_tree(struct yaffs_dev *dev,
+			    struct yaffs_file_var *file_struct)
+{
+	int i;
+	int has_data;
+	int done = 0;
+	struct yaffs_tnode *tn;
+
+	if (file_struct->top_level < 1)
+		return YAFFS_OK;
+
+	file_struct->top =
+	   yaffs_prune_worker(dev, file_struct->top, file_struct->top_level, 0);
+
+	/* Now we have a tree with all the non-zero branches NULL but
+	 * the height is the same as it was.
+	 * Let's see if we can trim internal tnodes to shorten the tree.
+	 * We can do this if only the 0th element in the tnode is in use
+	 * (ie all the non-zero are NULL)
+	 */
+
+	while (file_struct->top_level && !done) {
+		tn = file_struct->top;
+
+		has_data = 0;
+		for (i = 1; i < YAFFS_NTNODES_INTERNAL; i++) {
+			if (tn->internal[i])
+				has_data++;
+		}
+
+		if (!has_data) {
+			file_struct->top = tn->internal[0];
+			file_struct->top_level--;
+			yaffs_free_tnode(dev, tn);
+		} else {
+			done = 1;
+		}
+	}
+
+	return YAFFS_OK;
+}
+
+/*-------------------- End of File Structure functions.-------------------*/
+
+/* alloc_empty_obj gets us a clean Object.*/
+static struct yaffs_obj *yaffs_alloc_empty_obj(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj = yaffs_alloc_raw_obj(dev);
+
+	if (!obj)
+		return obj;
+
+	dev->n_obj++;
+
+	/* Now sweeten it up... */
+
+	memset(obj, 0, sizeof(struct yaffs_obj));
+	obj->being_created = 1;
+
+	obj->my_dev = dev;
+	obj->hdr_chunk = 0;
+	obj->variant_type = YAFFS_OBJECT_TYPE_UNKNOWN;
+	INIT_LIST_HEAD(&(obj->hard_links));
+	INIT_LIST_HEAD(&(obj->hash_link));
+	INIT_LIST_HEAD(&obj->siblings);
+
+	/* Now make the directory sane */
+	if (dev->root_dir) {
+		obj->parent = dev->root_dir;
+		list_add(&(obj->siblings),
+			 &dev->root_dir->variant.dir_variant.children);
+	}
+
+	/* Add it to the lost and found directory.
+	 * NB Can't put root or lost-n-found in lost-n-found so
+	 * check if lost-n-found exists first
+	 */
+	if (dev->lost_n_found)
+		yaffs_add_obj_to_dir(dev->lost_n_found, obj);
+
+	obj->being_created = 0;
+
+	dev->checkpoint_blocks_required = 0;	/* force recalculation */
+
+	return obj;
+}
+
+static int yaffs_find_nice_bucket(struct yaffs_dev *dev)
+{
+	int i;
+	int l = 999;
+	int lowest = 999999;
+
+	/* Search for the shortest list or one that
+	 * isn't too long.
+	 */
+
+	for (i = 0; i < 10 && lowest > 4; i++) {
+		dev->bucket_finder++;
+		dev->bucket_finder %= YAFFS_NOBJECT_BUCKETS;
+		if (dev->obj_bucket[dev->bucket_finder].count < lowest) {
+			lowest = dev->obj_bucket[dev->bucket_finder].count;
+			l = dev->bucket_finder;
+		}
+	}
+
+	return l;
+}
+
+static int yaffs_new_obj_id(struct yaffs_dev *dev)
+{
+	int bucket = yaffs_find_nice_bucket(dev);
+	int found = 0;
+	struct list_head *i;
+	u32 n = (u32) bucket;
+
+	/* Now find an object value that has not already been taken
+	 * by scanning the list.
+	 */
+
+	while (!found) {
+		found = 1;
+		n += YAFFS_NOBJECT_BUCKETS;
+		if (1 || dev->obj_bucket[bucket].count > 0) {
+			list_for_each(i, &dev->obj_bucket[bucket].list) {
+				/* If there is already one in the list */
+				if (i && list_entry(i, struct yaffs_obj,
+						    hash_link)->obj_id == n) {
+					found = 0;
+				}
+			}
+		}
+	}
+	return n;
+}
+
+static void yaffs_hash_obj(struct yaffs_obj *in)
+{
+	int bucket = yaffs_hash_fn(in->obj_id);
+	struct yaffs_dev *dev = in->my_dev;
+
+	list_add(&in->hash_link, &dev->obj_bucket[bucket].list);
+	dev->obj_bucket[bucket].count++;
+}
+
+struct yaffs_obj *yaffs_find_by_number(struct yaffs_dev *dev, u32 number)
+{
+	int bucket = yaffs_hash_fn(number);
+	struct list_head *i;
+	struct yaffs_obj *in;
+
+	list_for_each(i, &dev->obj_bucket[bucket].list) {
+		/* Look if it is in the list */
+		in = list_entry(i, struct yaffs_obj, hash_link);
+		if (in->obj_id == number) {
+			/* Don't show if it is defered free */
+			if (in->defered_free)
+				return NULL;
+			return in;
+		}
+	}
+
+	return NULL;
+}
+
+static struct yaffs_obj *yaffs_new_obj(struct yaffs_dev *dev, int number,
+				enum yaffs_obj_type type)
+{
+	struct yaffs_obj *the_obj = NULL;
+	struct yaffs_tnode *tn = NULL;
+
+	if (number < 0)
+		number = yaffs_new_obj_id(dev);
+
+	if (type == YAFFS_OBJECT_TYPE_FILE) {
+		tn = yaffs_get_tnode(dev);
+		if (!tn)
+			return NULL;
+	}
+
+	the_obj = yaffs_alloc_empty_obj(dev);
+	if (!the_obj) {
+		if (tn)
+			yaffs_free_tnode(dev, tn);
+		return NULL;
+	}
+
+	the_obj->fake = 0;
+	the_obj->rename_allowed = 1;
+	the_obj->unlink_allowed = 1;
+	the_obj->obj_id = number;
+	yaffs_hash_obj(the_obj);
+	the_obj->variant_type = type;
+	yaffs_load_current_time(the_obj, 1, 1);
+
+	switch (type) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		the_obj->variant.file_variant.file_size = 0;
+		the_obj->variant.file_variant.scanned_size = 0;
+		the_obj->variant.file_variant.shrink_size =
+						yaffs_max_file_size(dev);
+		the_obj->variant.file_variant.top_level = 0;
+		the_obj->variant.file_variant.top = tn;
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		INIT_LIST_HEAD(&the_obj->variant.dir_variant.children);
+		INIT_LIST_HEAD(&the_obj->variant.dir_variant.dirty);
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		/* No action required */
+		break;
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+		/* todo this should not happen */
+		break;
+	}
+	return the_obj;
+}
+
+static struct yaffs_obj *yaffs_create_fake_dir(struct yaffs_dev *dev,
+					       int number, u32 mode)
+{
+
+	struct yaffs_obj *obj =
+	    yaffs_new_obj(dev, number, YAFFS_OBJECT_TYPE_DIRECTORY);
+
+	if (!obj)
+		return NULL;
+
+	obj->fake = 1;	/* it is fake so it might not use NAND */
+	obj->rename_allowed = 0;
+	obj->unlink_allowed = 0;
+	obj->deleted = 0;
+	obj->unlinked = 0;
+	obj->yst_mode = mode;
+	obj->my_dev = dev;
+	obj->hdr_chunk = 0;	/* Not a valid chunk. */
+	return obj;
+
+}
+
+
+static void yaffs_init_tnodes_and_objs(struct yaffs_dev *dev)
+{
+	int i;
+
+	dev->n_obj = 0;
+	dev->n_tnodes = 0;
+	yaffs_init_raw_tnodes_and_objs(dev);
+
+	for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
+		INIT_LIST_HEAD(&dev->obj_bucket[i].list);
+		dev->obj_bucket[i].count = 0;
+	}
+}
+
+struct yaffs_obj *yaffs_find_or_create_by_number(struct yaffs_dev *dev,
+						 int number,
+						 enum yaffs_obj_type type)
+{
+	struct yaffs_obj *the_obj = NULL;
+
+	if (number > 0)
+		the_obj = yaffs_find_by_number(dev, number);
+
+	if (!the_obj)
+		the_obj = yaffs_new_obj(dev, number, type);
+
+	return the_obj;
+
+}
+
+YCHAR *yaffs_clone_str(const YCHAR *str)
+{
+	YCHAR *new_str = NULL;
+	int len;
+
+	if (!str)
+		str = _Y("");
+
+	len = strnlen(str, YAFFS_MAX_ALIAS_LENGTH);
+	new_str = kmalloc((len + 1) * sizeof(YCHAR), GFP_NOFS);
+	if (new_str) {
+		strncpy(new_str, str, len);
+		new_str[len] = 0;
+	}
+	return new_str;
+
+}
+/*
+ *yaffs_update_parent() handles fixing a directories mtime and ctime when a new
+ * link (ie. name) is created or deleted in the directory.
+ *
+ * ie.
+ *   create dir/a : update dir's mtime/ctime
+ *   rm dir/a:   update dir's mtime/ctime
+ *   modify dir/a: don't update dir's mtimme/ctime
+ *
+ * This can be handled immediately or defered. Defering helps reduce the number
+ * of updates when many files in a directory are changed within a brief period.
+ *
+ * If the directory updating is defered then yaffs_update_dirty_dirs must be
+ * called periodically.
+ */
+
+static void yaffs_update_parent(struct yaffs_obj *obj)
+{
+	struct yaffs_dev *dev;
+
+	if (!obj)
+		return;
+	dev = obj->my_dev;
+	obj->dirty = 1;
+	yaffs_load_current_time(obj, 0, 1);
+	if (dev->param.defered_dir_update) {
+		struct list_head *link = &obj->variant.dir_variant.dirty;
+
+		if (list_empty(link)) {
+			list_add(link, &dev->dirty_dirs);
+			yaffs_trace(YAFFS_TRACE_BACKGROUND,
+			  "Added object %d to dirty directories",
+			   obj->obj_id);
+		}
+
+	} else {
+		yaffs_update_oh(obj, NULL, 0, 0, 0, NULL);
+	}
+}
+
+void yaffs_update_dirty_dirs(struct yaffs_dev *dev)
+{
+	struct list_head *link;
+	struct yaffs_obj *obj;
+	struct yaffs_dir_var *d_s;
+	union yaffs_obj_var *o_v;
+
+	yaffs_trace(YAFFS_TRACE_BACKGROUND, "Update dirty directories");
+
+	while (!list_empty(&dev->dirty_dirs)) {
+		link = dev->dirty_dirs.next;
+		list_del_init(link);
+
+		d_s = list_entry(link, struct yaffs_dir_var, dirty);
+		o_v = list_entry(d_s, union yaffs_obj_var, dir_variant);
+		obj = list_entry(o_v, struct yaffs_obj, variant);
+
+		yaffs_trace(YAFFS_TRACE_BACKGROUND, "Update directory %d",
+			obj->obj_id);
+
+		if (obj->dirty)
+			yaffs_update_oh(obj, NULL, 0, 0, 0, NULL);
+	}
+}
+
+/*
+ * Mknod (create) a new object.
+ * equiv_obj only has meaning for a hard link;
+ * alias_str only has meaning for a symlink.
+ * rdev only has meaning for devices (a subset of special objects)
+ */
+
+static struct yaffs_obj *yaffs_create_obj(enum yaffs_obj_type type,
+					  struct yaffs_obj *parent,
+					  const YCHAR *name,
+					  u32 mode,
+					  u32 uid,
+					  u32 gid,
+					  struct yaffs_obj *equiv_obj,
+					  const YCHAR *alias_str, u32 rdev)
+{
+	struct yaffs_obj *in;
+	YCHAR *str = NULL;
+	struct yaffs_dev *dev = parent->my_dev;
+
+	/* Check if the entry exists.
+	 * If it does then fail the call since we don't want a dup. */
+	if (yaffs_find_by_name(parent, name))
+		return NULL;
+
+	if (type == YAFFS_OBJECT_TYPE_SYMLINK) {
+		str = yaffs_clone_str(alias_str);
+		if (!str)
+			return NULL;
+	}
+
+	in = yaffs_new_obj(dev, -1, type);
+
+	if (!in) {
+		kfree(str);
+		return NULL;
+	}
+
+	in->hdr_chunk = 0;
+	in->valid = 1;
+	in->variant_type = type;
+
+	in->yst_mode = mode;
+
+	yaffs_attribs_init(in, gid, uid, rdev);
+
+	in->n_data_chunks = 0;
+
+	yaffs_set_obj_name(in, name);
+	in->dirty = 1;
+
+	yaffs_add_obj_to_dir(parent, in);
+
+	in->my_dev = parent->my_dev;
+
+	switch (type) {
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		in->variant.symlink_variant.alias = str;
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		in->variant.hardlink_variant.equiv_obj = equiv_obj;
+		in->variant.hardlink_variant.equiv_id = equiv_obj->obj_id;
+		list_add(&in->hard_links, &equiv_obj->hard_links);
+		break;
+	case YAFFS_OBJECT_TYPE_FILE:
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+		/* do nothing */
+		break;
+	}
+
+	if (yaffs_update_oh(in, name, 0, 0, 0, NULL) < 0) {
+		/* Could not create the object header, fail */
+		yaffs_del_obj(in);
+		in = NULL;
+	}
+
+	if (in)
+		yaffs_update_parent(parent);
+
+	return in;
+}
+
+struct yaffs_obj *yaffs_create_file(struct yaffs_obj *parent,
+				    const YCHAR *name, u32 mode, u32 uid,
+				    u32 gid)
+{
+	return yaffs_create_obj(YAFFS_OBJECT_TYPE_FILE, parent, name, mode,
+				uid, gid, NULL, NULL, 0);
+}
+
+struct yaffs_obj *yaffs_create_dir(struct yaffs_obj *parent, const YCHAR *name,
+				   u32 mode, u32 uid, u32 gid)
+{
+	return yaffs_create_obj(YAFFS_OBJECT_TYPE_DIRECTORY, parent, name,
+				mode, uid, gid, NULL, NULL, 0);
+}
+
+struct yaffs_obj *yaffs_create_special(struct yaffs_obj *parent,
+				       const YCHAR *name, u32 mode, u32 uid,
+				       u32 gid, u32 rdev)
+{
+	return yaffs_create_obj(YAFFS_OBJECT_TYPE_SPECIAL, parent, name, mode,
+				uid, gid, NULL, NULL, rdev);
+}
+
+struct yaffs_obj *yaffs_create_symlink(struct yaffs_obj *parent,
+				       const YCHAR *name, u32 mode, u32 uid,
+				       u32 gid, const YCHAR *alias)
+{
+	return yaffs_create_obj(YAFFS_OBJECT_TYPE_SYMLINK, parent, name, mode,
+				uid, gid, NULL, alias, 0);
+}
+
+/* yaffs_link_obj returns the object id of the equivalent object.*/
+struct yaffs_obj *yaffs_link_obj(struct yaffs_obj *parent, const YCHAR * name,
+				 struct yaffs_obj *equiv_obj)
+{
+	/* Get the real object in case we were fed a hard link obj */
+	equiv_obj = yaffs_get_equivalent_obj(equiv_obj);
+
+	if (yaffs_create_obj(YAFFS_OBJECT_TYPE_HARDLINK,
+			parent, name, 0, 0, 0,
+			equiv_obj, NULL, 0))
+		return equiv_obj;
+
+	return NULL;
+
+}
+
+
+
+/*---------------------- Block Management and Page Allocation -------------*/
+
+static void yaffs_deinit_blocks(struct yaffs_dev *dev)
+{
+	if (dev->block_info_alt && dev->block_info)
+		vfree(dev->block_info);
+	else
+		kfree(dev->block_info);
+
+	dev->block_info_alt = 0;
+
+	dev->block_info = NULL;
+
+	if (dev->chunk_bits_alt && dev->chunk_bits)
+		vfree(dev->chunk_bits);
+	else
+		kfree(dev->chunk_bits);
+	dev->chunk_bits_alt = 0;
+	dev->chunk_bits = NULL;
+}
+
+static int yaffs_init_blocks(struct yaffs_dev *dev)
+{
+	int n_blocks = dev->internal_end_block - dev->internal_start_block + 1;
+
+	dev->block_info = NULL;
+	dev->chunk_bits = NULL;
+	dev->alloc_block = -1;	/* force it to get a new one */
+
+	/* If the first allocation strategy fails, thry the alternate one */
+	dev->block_info =
+		kmalloc(n_blocks * sizeof(struct yaffs_block_info), GFP_NOFS);
+	if (!dev->block_info) {
+		dev->block_info =
+		    vmalloc(n_blocks * sizeof(struct yaffs_block_info));
+		dev->block_info_alt = 1;
+	} else {
+		dev->block_info_alt = 0;
+	}
+
+	if (!dev->block_info)
+		goto alloc_error;
+
+	/* Set up dynamic blockinfo stuff. Round up bytes. */
+	dev->chunk_bit_stride = (dev->param.chunks_per_block + 7) / 8;
+	dev->chunk_bits =
+		kmalloc(dev->chunk_bit_stride * n_blocks, GFP_NOFS);
+	if (!dev->chunk_bits) {
+		dev->chunk_bits =
+		    vmalloc(dev->chunk_bit_stride * n_blocks);
+		dev->chunk_bits_alt = 1;
+	} else {
+		dev->chunk_bits_alt = 0;
+	}
+	if (!dev->chunk_bits)
+		goto alloc_error;
+
+
+	memset(dev->block_info, 0, n_blocks * sizeof(struct yaffs_block_info));
+	memset(dev->chunk_bits, 0, dev->chunk_bit_stride * n_blocks);
+	return YAFFS_OK;
+
+alloc_error:
+	yaffs_deinit_blocks(dev);
+	return YAFFS_FAIL;
+}
+
+
+void yaffs_block_became_dirty(struct yaffs_dev *dev, int block_no)
+{
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, block_no);
+	int erased_ok = 0;
+	int i;
+
+	/* If the block is still healthy erase it and mark as clean.
+	 * If the block has had a data failure, then retire it.
+	 */
+
+	yaffs_trace(YAFFS_TRACE_GC | YAFFS_TRACE_ERASE,
+		"yaffs_block_became_dirty block %d state %d %s",
+		block_no, bi->block_state,
+		(bi->needs_retiring) ? "needs retiring" : "");
+
+	yaffs2_clear_oldest_dirty_seq(dev, bi);
+
+	bi->block_state = YAFFS_BLOCK_STATE_DIRTY;
+
+	/* If this is the block being garbage collected then stop gc'ing */
+	if (block_no == dev->gc_block)
+		dev->gc_block = 0;
+
+	/* If this block is currently the best candidate for gc
+	 * then drop as a candidate */
+	if (block_no == dev->gc_dirtiest) {
+		dev->gc_dirtiest = 0;
+		dev->gc_pages_in_use = 0;
+	}
+
+	if (!bi->needs_retiring) {
+		yaffs2_checkpt_invalidate(dev);
+		erased_ok = yaffs_erase_block(dev, block_no);
+		if (!erased_ok) {
+			dev->n_erase_failures++;
+			yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+			  "**>> Erasure failed %d", block_no);
+		}
+	}
+
+	/* Verify erasure if needed */
+	if (erased_ok &&
+	    ((yaffs_trace_mask & YAFFS_TRACE_ERASE) ||
+	     !yaffs_skip_verification(dev))) {
+		for (i = 0; i < dev->param.chunks_per_block; i++) {
+			if (!yaffs_check_chunk_erased(dev,
+				block_no * dev->param.chunks_per_block + i)) {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					">>Block %d erasure supposedly OK, but chunk %d not erased",
+					block_no, i);
+			}
+		}
+	}
+
+	if (!erased_ok) {
+		/* We lost a block of free space */
+		dev->n_free_chunks -= dev->param.chunks_per_block;
+		yaffs_retire_block(dev, block_no);
+		yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+			"**>> Block %d retired", block_no);
+		return;
+	}
+
+	/* Clean it up... */
+	bi->block_state = YAFFS_BLOCK_STATE_EMPTY;
+	bi->seq_number = 0;
+	dev->n_erased_blocks++;
+	bi->pages_in_use = 0;
+	bi->soft_del_pages = 0;
+	bi->has_shrink_hdr = 0;
+	bi->skip_erased_check = 1;	/* Clean, so no need to check */
+	bi->gc_prioritise = 0;
+	bi->has_summary = 0;
+
+	yaffs_clear_chunk_bits(dev, block_no);
+
+	yaffs_trace(YAFFS_TRACE_ERASE, "Erased block %d", block_no);
+}
+
+static inline int yaffs_gc_process_chunk(struct yaffs_dev *dev,
+					struct yaffs_block_info *bi,
+					int old_chunk, u8 *buffer)
+{
+	int new_chunk;
+	int mark_flash = 1;
+	struct yaffs_ext_tags tags;
+	struct yaffs_obj *object;
+	int matching_chunk;
+	int ret_val = YAFFS_OK;
+
+	memset(&tags, 0, sizeof(tags));
+	yaffs_rd_chunk_tags_nand(dev, old_chunk,
+				 buffer, &tags);
+	object = yaffs_find_by_number(dev, tags.obj_id);
+
+	yaffs_trace(YAFFS_TRACE_GC_DETAIL,
+		"Collecting chunk in block %d, %d %d %d ",
+		dev->gc_chunk, tags.obj_id,
+		tags.chunk_id, tags.n_bytes);
+
+	if (object && !yaffs_skip_verification(dev)) {
+		if (tags.chunk_id == 0)
+			matching_chunk =
+			    object->hdr_chunk;
+		else if (object->soft_del)
+			/* Defeat the test */
+			matching_chunk = old_chunk;
+		else
+			matching_chunk =
+			    yaffs_find_chunk_in_file
+			    (object, tags.chunk_id,
+			     NULL);
+
+		if (old_chunk != matching_chunk)
+			yaffs_trace(YAFFS_TRACE_ERROR,
+				"gc: page in gc mismatch: %d %d %d %d",
+				old_chunk,
+				matching_chunk,
+				tags.obj_id,
+				tags.chunk_id);
+	}
+
+	if (!object) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"page %d in gc has no object: %d %d %d ",
+			old_chunk,
+			tags.obj_id, tags.chunk_id,
+			tags.n_bytes);
+	}
+
+	if (object &&
+	    object->deleted &&
+	    object->soft_del && tags.chunk_id != 0) {
+		/* Data chunk in a soft deleted file,
+		 * throw it away.
+		 * It's a soft deleted data chunk,
+		 * No need to copy this, just forget
+		 * about it and fix up the object.
+		 */
+
+		/* Free chunks already includes
+		 * softdeleted chunks, how ever this
+		 * chunk is going to soon be really
+		 * deleted which will increment free
+		 * chunks. We have to decrement free
+		 * chunks so this works out properly.
+		 */
+		dev->n_free_chunks--;
+		bi->soft_del_pages--;
+
+		object->n_data_chunks--;
+		if (object->n_data_chunks <= 0) {
+			/* remeber to clean up obj */
+			dev->gc_cleanup_list[dev->n_clean_ups] = tags.obj_id;
+			dev->n_clean_ups++;
+		}
+		mark_flash = 0;
+	} else if (object) {
+		/* It's either a data chunk in a live
+		 * file or an ObjectHeader, so we're
+		 * interested in it.
+		 * NB Need to keep the ObjectHeaders of
+		 * deleted files until the whole file
+		 * has been deleted off
+		 */
+		tags.serial_number++;
+		dev->n_gc_copies++;
+
+		if (tags.chunk_id == 0) {
+			/* It is an object Id,
+			 * We need to nuke the
+			 * shrinkheader flags since its
+			 * work is done.
+			 * Also need to clean up
+			 * shadowing.
+			 */
+			struct yaffs_obj_hdr *oh;
+			oh = (struct yaffs_obj_hdr *) buffer;
+
+			oh->is_shrink = 0;
+			tags.extra_is_shrink = 0;
+			oh->shadows_obj = 0;
+			oh->inband_shadowed_obj_id = 0;
+			tags.extra_shadows = 0;
+
+			/* Update file size */
+			if (object->variant_type == YAFFS_OBJECT_TYPE_FILE) {
+				yaffs_oh_size_load(oh,
+				    object->variant.file_variant.file_size);
+				tags.extra_file_size =
+				    object->variant.file_variant.file_size;
+			}
+
+			yaffs_verify_oh(object, oh, &tags, 1);
+			new_chunk =
+			    yaffs_write_new_chunk(dev, (u8 *) oh, &tags, 1);
+		} else {
+			new_chunk =
+			    yaffs_write_new_chunk(dev, buffer, &tags, 1);
+		}
+
+		if (new_chunk < 0) {
+			ret_val = YAFFS_FAIL;
+		} else {
+
+			/* Now fix up the Tnodes etc. */
+
+			if (tags.chunk_id == 0) {
+				/* It's a header */
+				object->hdr_chunk = new_chunk;
+				object->serial = tags.serial_number;
+			} else {
+				/* It's a data chunk */
+				yaffs_put_chunk_in_file(object, tags.chunk_id,
+							new_chunk, 0);
+			}
+		}
+	}
+	if (ret_val == YAFFS_OK)
+		yaffs_chunk_del(dev, old_chunk, mark_flash, __LINE__);
+	return ret_val;
+}
+
+static int yaffs_gc_block(struct yaffs_dev *dev, int block, int whole_block)
+{
+	int old_chunk;
+	int ret_val = YAFFS_OK;
+	int i;
+	int is_checkpt_block;
+	int max_copies;
+	int chunks_before = yaffs_get_erased_chunks(dev);
+	int chunks_after;
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, block);
+
+	is_checkpt_block = (bi->block_state == YAFFS_BLOCK_STATE_CHECKPOINT);
+
+	yaffs_trace(YAFFS_TRACE_TRACING,
+		"Collecting block %d, in use %d, shrink %d, whole_block %d",
+		block, bi->pages_in_use, bi->has_shrink_hdr,
+		whole_block);
+
+	/*yaffs_verify_free_chunks(dev); */
+
+	if (bi->block_state == YAFFS_BLOCK_STATE_FULL)
+		bi->block_state = YAFFS_BLOCK_STATE_COLLECTING;
+
+	bi->has_shrink_hdr = 0;	/* clear the flag so that the block can erase */
+
+	dev->gc_disable = 1;
+
+	yaffs_summary_gc(dev, block);
+
+	if (is_checkpt_block || !yaffs_still_some_chunks(dev, block)) {
+		yaffs_trace(YAFFS_TRACE_TRACING,
+			"Collecting block %d that has no chunks in use",
+			block);
+		yaffs_block_became_dirty(dev, block);
+	} else {
+
+		u8 *buffer = yaffs_get_temp_buffer(dev);
+
+		yaffs_verify_blk(dev, bi, block);
+
+		max_copies = (whole_block) ? dev->param.chunks_per_block : 5;
+		old_chunk = block * dev->param.chunks_per_block + dev->gc_chunk;
+
+		for (/* init already done */ ;
+		     ret_val == YAFFS_OK &&
+		     dev->gc_chunk < dev->param.chunks_per_block &&
+		     (bi->block_state == YAFFS_BLOCK_STATE_COLLECTING) &&
+		     max_copies > 0;
+		     dev->gc_chunk++, old_chunk++) {
+			if (yaffs_check_chunk_bit(dev, block, dev->gc_chunk)) {
+				/* Page is in use and might need to be copied */
+				max_copies--;
+				ret_val = yaffs_gc_process_chunk(dev, bi,
+							old_chunk, buffer);
+			}
+		}
+		yaffs_release_temp_buffer(dev, buffer);
+	}
+
+	yaffs_verify_collected_blk(dev, bi, block);
+
+	if (bi->block_state == YAFFS_BLOCK_STATE_COLLECTING) {
+		/*
+		 * The gc did not complete. Set block state back to FULL
+		 * because checkpointing does not restore gc.
+		 */
+		bi->block_state = YAFFS_BLOCK_STATE_FULL;
+	} else {
+		/* The gc completed. */
+		/* Do any required cleanups */
+		for (i = 0; i < dev->n_clean_ups; i++) {
+			/* Time to delete the file too */
+			struct yaffs_obj *object =
+			    yaffs_find_by_number(dev, dev->gc_cleanup_list[i]);
+			if (object) {
+				yaffs_free_tnode(dev,
+					  object->variant.file_variant.top);
+				object->variant.file_variant.top = NULL;
+				yaffs_trace(YAFFS_TRACE_GC,
+					"yaffs: About to finally delete object %d",
+					object->obj_id);
+				yaffs_generic_obj_del(object);
+				object->my_dev->n_deleted_files--;
+			}
+
+		}
+		chunks_after = yaffs_get_erased_chunks(dev);
+		if (chunks_before >= chunks_after)
+			yaffs_trace(YAFFS_TRACE_GC,
+				"gc did not increase free chunks before %d after %d",
+				chunks_before, chunks_after);
+		dev->gc_block = 0;
+		dev->gc_chunk = 0;
+		dev->n_clean_ups = 0;
+	}
+
+	dev->gc_disable = 0;
+
+	return ret_val;
+}
+
+/*
+ * find_gc_block() selects the dirtiest block (or close enough)
+ * for garbage collection.
+ */
+
+static unsigned yaffs_find_gc_block(struct yaffs_dev *dev,
+				    int aggressive, int background)
+{
+	int i;
+	int iterations;
+	unsigned selected = 0;
+	int prioritised = 0;
+	int prioritised_exist = 0;
+	struct yaffs_block_info *bi;
+	int threshold;
+
+	/* First let's see if we need to grab a prioritised block */
+	if (dev->has_pending_prioritised_gc && !aggressive) {
+		dev->gc_dirtiest = 0;
+		bi = dev->block_info;
+		for (i = dev->internal_start_block;
+		     i <= dev->internal_end_block && !selected; i++) {
+
+			if (bi->gc_prioritise) {
+				prioritised_exist = 1;
+				if (bi->block_state == YAFFS_BLOCK_STATE_FULL &&
+				    yaffs_block_ok_for_gc(dev, bi)) {
+					selected = i;
+					prioritised = 1;
+				}
+			}
+			bi++;
+		}
+
+		/*
+		 * If there is a prioritised block and none was selected then
+		 * this happened because there is at least one old dirty block
+		 * gumming up the works. Let's gc the oldest dirty block.
+		 */
+
+		if (prioritised_exist &&
+		    !selected && dev->oldest_dirty_block > 0)
+			selected = dev->oldest_dirty_block;
+
+		if (!prioritised_exist)	/* None found, so we can clear this */
+			dev->has_pending_prioritised_gc = 0;
+	}
+
+	/* If we're doing aggressive GC then we are happy to take a less-dirty
+	 * block, and search harder.
+	 * else (leasurely gc), then we only bother to do this if the
+	 * block has only a few pages in use.
+	 */
+
+	if (!selected) {
+		int pages_used;
+		int n_blocks =
+		    dev->internal_end_block - dev->internal_start_block + 1;
+		if (aggressive) {
+			threshold = dev->param.chunks_per_block;
+			iterations = n_blocks;
+		} else {
+			int max_threshold;
+
+			if (background)
+				max_threshold = dev->param.chunks_per_block / 2;
+			else
+				max_threshold = dev->param.chunks_per_block / 8;
+
+			if (max_threshold < YAFFS_GC_PASSIVE_THRESHOLD)
+				max_threshold = YAFFS_GC_PASSIVE_THRESHOLD;
+
+			threshold = background ? (dev->gc_not_done + 2) * 2 : 0;
+			if (threshold < YAFFS_GC_PASSIVE_THRESHOLD)
+				threshold = YAFFS_GC_PASSIVE_THRESHOLD;
+			if (threshold > max_threshold)
+				threshold = max_threshold;
+
+			iterations = n_blocks / 16 + 1;
+			if (iterations > 100)
+				iterations = 100;
+		}
+
+		for (i = 0;
+		     i < iterations &&
+		     (dev->gc_dirtiest < 1 ||
+		      dev->gc_pages_in_use > YAFFS_GC_GOOD_ENOUGH);
+		     i++) {
+			dev->gc_block_finder++;
+			if (dev->gc_block_finder < dev->internal_start_block ||
+			    dev->gc_block_finder > dev->internal_end_block)
+				dev->gc_block_finder =
+				    dev->internal_start_block;
+
+			bi = yaffs_get_block_info(dev, dev->gc_block_finder);
+
+			pages_used = bi->pages_in_use - bi->soft_del_pages;
+
+			if (bi->block_state == YAFFS_BLOCK_STATE_FULL &&
+			    pages_used < dev->param.chunks_per_block &&
+			    (dev->gc_dirtiest < 1 ||
+			     pages_used < dev->gc_pages_in_use) &&
+			    yaffs_block_ok_for_gc(dev, bi)) {
+				dev->gc_dirtiest = dev->gc_block_finder;
+				dev->gc_pages_in_use = pages_used;
+			}
+		}
+
+		if (dev->gc_dirtiest > 0 && dev->gc_pages_in_use <= threshold)
+			selected = dev->gc_dirtiest;
+	}
+
+	/*
+	 * If nothing has been selected for a while, try the oldest dirty
+	 * because that's gumming up the works.
+	 */
+
+	if (!selected && dev->param.is_yaffs2 &&
+	    dev->gc_not_done >= (background ? 10 : 20)) {
+		yaffs2_find_oldest_dirty_seq(dev);
+		if (dev->oldest_dirty_block > 0) {
+			selected = dev->oldest_dirty_block;
+			dev->gc_dirtiest = selected;
+			dev->oldest_dirty_gc_count++;
+			bi = yaffs_get_block_info(dev, selected);
+			dev->gc_pages_in_use =
+			    bi->pages_in_use - bi->soft_del_pages;
+		} else {
+			dev->gc_not_done = 0;
+		}
+	}
+
+	if (selected) {
+		yaffs_trace(YAFFS_TRACE_GC,
+			"GC Selected block %d with %d free, prioritised:%d",
+			selected,
+			dev->param.chunks_per_block - dev->gc_pages_in_use,
+			prioritised);
+
+		dev->n_gc_blocks++;
+		if (background)
+			dev->bg_gcs++;
+
+		dev->gc_dirtiest = 0;
+		dev->gc_pages_in_use = 0;
+		dev->gc_not_done = 0;
+		if (dev->refresh_skip > 0)
+			dev->refresh_skip--;
+	} else {
+		dev->gc_not_done++;
+		yaffs_trace(YAFFS_TRACE_GC,
+			"GC none: finder %d skip %d threshold %d dirtiest %d using %d oldest %d%s",
+			dev->gc_block_finder, dev->gc_not_done, threshold,
+			dev->gc_dirtiest, dev->gc_pages_in_use,
+			dev->oldest_dirty_block, background ? " bg" : "");
+	}
+
+	return selected;
+}
+
+/* New garbage collector
+ * If we're very low on erased blocks then we do aggressive garbage collection
+ * otherwise we do "leasurely" garbage collection.
+ * Aggressive gc looks further (whole array) and will accept less dirty blocks.
+ * Passive gc only inspects smaller areas and only accepts more dirty blocks.
+ *
+ * The idea is to help clear out space in a more spread-out manner.
+ * Dunno if it really does anything useful.
+ */
+static int yaffs_check_gc(struct yaffs_dev *dev, int background)
+{
+	int aggressive = 0;
+	int gc_ok = YAFFS_OK;
+	int max_tries = 0;
+	int min_erased;
+	int erased_chunks;
+	int checkpt_block_adjust;
+
+	if (dev->param.gc_control_fn &&
+		(dev->param.gc_control_fn(dev) & 1) == 0)
+		return YAFFS_OK;
+
+	if (dev->gc_disable)
+		/* Bail out so we don't get recursive gc */
+		return YAFFS_OK;
+
+	/* This loop should pass the first time.
+	 * Only loops here if the collection does not increase space.
+	 */
+
+	do {
+		max_tries++;
+
+		checkpt_block_adjust = yaffs_calc_checkpt_blocks_required(dev);
+
+		min_erased =
+		    dev->param.n_reserved_blocks + checkpt_block_adjust + 1;
+		erased_chunks =
+		    dev->n_erased_blocks * dev->param.chunks_per_block;
+
+		/* If we need a block soon then do aggressive gc. */
+		if (dev->n_erased_blocks < min_erased)
+			aggressive = 1;
+		else {
+			if (!background
+			    && erased_chunks > (dev->n_free_chunks / 4))
+				break;
+
+			if (dev->gc_skip > 20)
+				dev->gc_skip = 20;
+			if (erased_chunks < dev->n_free_chunks / 2 ||
+			    dev->gc_skip < 1 || background)
+				aggressive = 0;
+			else {
+				dev->gc_skip--;
+				break;
+			}
+		}
+
+		dev->gc_skip = 5;
+
+		/* If we don't already have a block being gc'd then see if we
+		 * should start another */
+
+		if (dev->gc_block < 1 && !aggressive) {
+			dev->gc_block = yaffs2_find_refresh_block(dev);
+			dev->gc_chunk = 0;
+			dev->n_clean_ups = 0;
+		}
+		if (dev->gc_block < 1) {
+			dev->gc_block =
+			    yaffs_find_gc_block(dev, aggressive, background);
+			dev->gc_chunk = 0;
+			dev->n_clean_ups = 0;
+		}
+
+		if (dev->gc_block > 0) {
+			dev->all_gcs++;
+			if (!aggressive)
+				dev->passive_gc_count++;
+
+			yaffs_trace(YAFFS_TRACE_GC,
+				"yaffs: GC n_erased_blocks %d aggressive %d",
+				dev->n_erased_blocks, aggressive);
+
+			gc_ok = yaffs_gc_block(dev, dev->gc_block, aggressive);
+		}
+
+		if (dev->n_erased_blocks < (dev->param.n_reserved_blocks) &&
+		    dev->gc_block > 0) {
+			yaffs_trace(YAFFS_TRACE_GC,
+				"yaffs: GC !!!no reclaim!!! n_erased_blocks %d after try %d block %d",
+				dev->n_erased_blocks, max_tries,
+				dev->gc_block);
+		}
+	} while ((dev->n_erased_blocks < dev->param.n_reserved_blocks) &&
+		 (dev->gc_block > 0) && (max_tries < 2));
+
+	return aggressive ? gc_ok : YAFFS_OK;
+}
+
+/*
+ * yaffs_bg_gc()
+ * Garbage collects. Intended to be called from a background thread.
+ * Returns non-zero if at least half the free chunks are erased.
+ */
+int yaffs_bg_gc(struct yaffs_dev *dev, unsigned urgency)
+{
+	int erased_chunks = dev->n_erased_blocks * dev->param.chunks_per_block;
+
+	yaffs_trace(YAFFS_TRACE_BACKGROUND, "Background gc %u", urgency);
+
+	yaffs_check_gc(dev, 1);
+	return erased_chunks > dev->n_free_chunks / 2;
+}
+
+/*-------------------- Data file manipulation -----------------*/
+
+static int yaffs_rd_data_obj(struct yaffs_obj *in, int inode_chunk, u8 * buffer)
+{
+	int nand_chunk = yaffs_find_chunk_in_file(in, inode_chunk, NULL);
+
+	if (nand_chunk >= 0)
+		return yaffs_rd_chunk_tags_nand(in->my_dev, nand_chunk,
+						buffer, NULL);
+	else {
+		yaffs_trace(YAFFS_TRACE_NANDACCESS,
+			"Chunk %d not found zero instead",
+			nand_chunk);
+		/* get sane (zero) data if you read a hole */
+		memset(buffer, 0, in->my_dev->data_bytes_per_chunk);
+		return 0;
+	}
+
+}
+
+void yaffs_chunk_del(struct yaffs_dev *dev, int chunk_id, int mark_flash,
+		     int lyn)
+{
+	int block;
+	int page;
+	struct yaffs_ext_tags tags;
+	struct yaffs_block_info *bi;
+
+	if (chunk_id <= 0)
+		return;
+
+	dev->n_deletions++;
+	block = chunk_id / dev->param.chunks_per_block;
+	page = chunk_id % dev->param.chunks_per_block;
+
+	if (!yaffs_check_chunk_bit(dev, block, page))
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Deleting invalid chunk %d", chunk_id);
+
+	bi = yaffs_get_block_info(dev, block);
+
+	yaffs2_update_oldest_dirty_seq(dev, block, bi);
+
+	yaffs_trace(YAFFS_TRACE_DELETION,
+		"line %d delete of chunk %d",
+		lyn, chunk_id);
+
+	if (!dev->param.is_yaffs2 && mark_flash &&
+	    bi->block_state != YAFFS_BLOCK_STATE_COLLECTING) {
+
+		memset(&tags, 0, sizeof(tags));
+		tags.is_deleted = 1;
+		yaffs_wr_chunk_tags_nand(dev, chunk_id, NULL, &tags);
+		yaffs_handle_chunk_update(dev, chunk_id, &tags);
+	} else {
+		dev->n_unmarked_deletions++;
+	}
+
+	/* Pull out of the management area.
+	 * If the whole block became dirty, this will kick off an erasure.
+	 */
+	if (bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING ||
+	    bi->block_state == YAFFS_BLOCK_STATE_FULL ||
+	    bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN ||
+	    bi->block_state == YAFFS_BLOCK_STATE_COLLECTING) {
+		dev->n_free_chunks++;
+		yaffs_clear_chunk_bit(dev, block, page);
+		bi->pages_in_use--;
+
+		if (bi->pages_in_use == 0 &&
+		    !bi->has_shrink_hdr &&
+		    bi->block_state != YAFFS_BLOCK_STATE_ALLOCATING &&
+		    bi->block_state != YAFFS_BLOCK_STATE_NEEDS_SCAN) {
+			yaffs_block_became_dirty(dev, block);
+		}
+	}
+}
+
+static int yaffs_wr_data_obj(struct yaffs_obj *in, int inode_chunk,
+			     const u8 *buffer, int n_bytes, int use_reserve)
+{
+	/* Find old chunk Need to do this to get serial number
+	 * Write new one and patch into tree.
+	 * Invalidate old tags.
+	 */
+
+	int prev_chunk_id;
+	struct yaffs_ext_tags prev_tags;
+	int new_chunk_id;
+	struct yaffs_ext_tags new_tags;
+	struct yaffs_dev *dev = in->my_dev;
+
+	yaffs_check_gc(dev, 0);
+
+	/* Get the previous chunk at this location in the file if it exists.
+	 * If it does not exist then put a zero into the tree. This creates
+	 * the tnode now, rather than later when it is harder to clean up.
+	 */
+	prev_chunk_id = yaffs_find_chunk_in_file(in, inode_chunk, &prev_tags);
+	if (prev_chunk_id < 1 &&
+	    !yaffs_put_chunk_in_file(in, inode_chunk, 0, 0))
+		return 0;
+
+	/* Set up new tags */
+	memset(&new_tags, 0, sizeof(new_tags));
+
+	new_tags.chunk_id = inode_chunk;
+	new_tags.obj_id = in->obj_id;
+	new_tags.serial_number =
+	    (prev_chunk_id > 0) ? prev_tags.serial_number + 1 : 1;
+	new_tags.n_bytes = n_bytes;
+
+	if (n_bytes < 1 || n_bytes > dev->param.total_bytes_per_chunk) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+		  "Writing %d bytes to chunk!!!!!!!!!",
+		   n_bytes);
+		BUG();
+	}
+
+	new_chunk_id =
+	    yaffs_write_new_chunk(dev, buffer, &new_tags, use_reserve);
+
+	if (new_chunk_id > 0) {
+		yaffs_put_chunk_in_file(in, inode_chunk, new_chunk_id, 0);
+
+		if (prev_chunk_id > 0)
+			yaffs_chunk_del(dev, prev_chunk_id, 1, __LINE__);
+
+		yaffs_verify_file_sane(in);
+	}
+	return new_chunk_id;
+
+}
+
+
+
+static int yaffs_do_xattrib_mod(struct yaffs_obj *obj, int set,
+				const YCHAR *name, const void *value, int size,
+				int flags)
+{
+	struct yaffs_xattr_mod xmod;
+	int result;
+
+	xmod.set = set;
+	xmod.name = name;
+	xmod.data = value;
+	xmod.size = size;
+	xmod.flags = flags;
+	xmod.result = -ENOSPC;
+
+	result = yaffs_update_oh(obj, NULL, 0, 0, 0, &xmod);
+
+	if (result > 0)
+		return xmod.result;
+	else
+		return -ENOSPC;
+}
+
+static int yaffs_apply_xattrib_mod(struct yaffs_obj *obj, char *buffer,
+				   struct yaffs_xattr_mod *xmod)
+{
+	int retval = 0;
+	int x_offs = sizeof(struct yaffs_obj_hdr);
+	struct yaffs_dev *dev = obj->my_dev;
+	int x_size = dev->data_bytes_per_chunk - sizeof(struct yaffs_obj_hdr);
+	char *x_buffer = buffer + x_offs;
+
+	if (xmod->set)
+		retval =
+		    nval_set(x_buffer, x_size, xmod->name, xmod->data,
+			     xmod->size, xmod->flags);
+	else
+		retval = nval_del(x_buffer, x_size, xmod->name);
+
+	obj->has_xattr = nval_hasvalues(x_buffer, x_size);
+	obj->xattr_known = 1;
+	xmod->result = retval;
+
+	return retval;
+}
+
+static int yaffs_do_xattrib_fetch(struct yaffs_obj *obj, const YCHAR *name,
+				  void *value, int size)
+{
+	char *buffer = NULL;
+	int result;
+	struct yaffs_ext_tags tags;
+	struct yaffs_dev *dev = obj->my_dev;
+	int x_offs = sizeof(struct yaffs_obj_hdr);
+	int x_size = dev->data_bytes_per_chunk - sizeof(struct yaffs_obj_hdr);
+	char *x_buffer;
+	int retval = 0;
+
+	if (obj->hdr_chunk < 1)
+		return -ENODATA;
+
+	/* If we know that the object has no xattribs then don't do all the
+	 * reading and parsing.
+	 */
+	if (obj->xattr_known && !obj->has_xattr) {
+		if (name)
+			return -ENODATA;
+		else
+			return 0;
+	}
+
+	buffer = (char *)yaffs_get_temp_buffer(dev);
+	if (!buffer)
+		return -ENOMEM;
+
+	result =
+	    yaffs_rd_chunk_tags_nand(dev, obj->hdr_chunk, (u8 *) buffer, &tags);
+
+	if (result != YAFFS_OK)
+		retval = -ENOENT;
+	else {
+		x_buffer = buffer + x_offs;
+
+		if (!obj->xattr_known) {
+			obj->has_xattr = nval_hasvalues(x_buffer, x_size);
+			obj->xattr_known = 1;
+		}
+
+		if (name)
+			retval = nval_get(x_buffer, x_size, name, value, size);
+		else
+			retval = nval_list(x_buffer, x_size, value, size);
+	}
+	yaffs_release_temp_buffer(dev, (u8 *) buffer);
+	return retval;
+}
+
+int yaffs_set_xattrib(struct yaffs_obj *obj, const YCHAR * name,
+		      const void *value, int size, int flags)
+{
+	return yaffs_do_xattrib_mod(obj, 1, name, value, size, flags);
+}
+
+int yaffs_remove_xattrib(struct yaffs_obj *obj, const YCHAR * name)
+{
+	return yaffs_do_xattrib_mod(obj, 0, name, NULL, 0, 0);
+}
+
+int yaffs_get_xattrib(struct yaffs_obj *obj, const YCHAR * name, void *value,
+		      int size)
+{
+	return yaffs_do_xattrib_fetch(obj, name, value, size);
+}
+
+int yaffs_list_xattrib(struct yaffs_obj *obj, char *buffer, int size)
+{
+	return yaffs_do_xattrib_fetch(obj, NULL, buffer, size);
+}
+
+static void yaffs_check_obj_details_loaded(struct yaffs_obj *in)
+{
+	u8 *buf;
+	struct yaffs_obj_hdr *oh;
+	struct yaffs_dev *dev;
+	struct yaffs_ext_tags tags;
+	int result;
+	int alloc_failed = 0;
+
+	if (!in || !in->lazy_loaded || in->hdr_chunk < 1)
+		return;
+
+	dev = in->my_dev;
+	in->lazy_loaded = 0;
+	buf = yaffs_get_temp_buffer(dev);
+
+	result = yaffs_rd_chunk_tags_nand(dev, in->hdr_chunk, buf, &tags);
+	oh = (struct yaffs_obj_hdr *)buf;
+
+	in->yst_mode = oh->yst_mode;
+	yaffs_load_attribs(in, oh);
+	yaffs_set_obj_name_from_oh(in, oh);
+
+	if (in->variant_type == YAFFS_OBJECT_TYPE_SYMLINK) {
+		in->variant.symlink_variant.alias =
+		    yaffs_clone_str(oh->alias);
+		if (!in->variant.symlink_variant.alias)
+			alloc_failed = 1;	/* Not returned */
+	}
+	yaffs_release_temp_buffer(dev, buf);
+}
+
+static void yaffs_load_name_from_oh(struct yaffs_dev *dev, YCHAR *name,
+				    const YCHAR *oh_name, int buff_size)
+{
+#ifdef CONFIG_YAFFS_AUTO_UNICODE
+	if (dev->param.auto_unicode) {
+		if (*oh_name) {
+			/* It is an ASCII name, do an ASCII to
+			 * unicode conversion */
+			const char *ascii_oh_name = (const char *)oh_name;
+			int n = buff_size - 1;
+			while (n > 0 && *ascii_oh_name) {
+				*name = *ascii_oh_name;
+				name++;
+				ascii_oh_name++;
+				n--;
+			}
+		} else {
+			strncpy(name, oh_name + 1, buff_size - 1);
+		}
+	} else {
+#else
+	(void) dev;
+	{
+#endif
+		strncpy(name, oh_name, buff_size - 1);
+	}
+}
+
+static void yaffs_load_oh_from_name(struct yaffs_dev *dev, YCHAR *oh_name,
+				    const YCHAR *name)
+{
+#ifdef CONFIG_YAFFS_AUTO_UNICODE
+
+	int is_ascii;
+	YCHAR *w;
+
+	if (dev->param.auto_unicode) {
+
+		is_ascii = 1;
+		w = name;
+
+		/* Figure out if the name will fit in ascii character set */
+		while (is_ascii && *w) {
+			if ((*w) & 0xff00)
+				is_ascii = 0;
+			w++;
+		}
+
+		if (is_ascii) {
+			/* It is an ASCII name, so convert unicode to ascii */
+			char *ascii_oh_name = (char *)oh_name;
+			int n = YAFFS_MAX_NAME_LENGTH - 1;
+			while (n > 0 && *name) {
+				*ascii_oh_name = *name;
+				name++;
+				ascii_oh_name++;
+				n--;
+			}
+		} else {
+			/* Unicode name, so save starting at the second YCHAR */
+			*oh_name = 0;
+			strncpy(oh_name + 1, name, YAFFS_MAX_NAME_LENGTH - 2);
+		}
+	} else {
+#else
+	dev = dev;
+	{
+#endif
+		strncpy(oh_name, name, YAFFS_MAX_NAME_LENGTH - 1);
+	}
+}
+
+/* UpdateObjectHeader updates the header on NAND for an object.
+ * If name is not NULL, then that new name is used.
+ */
+int yaffs_update_oh(struct yaffs_obj *in, const YCHAR *name, int force,
+		    int is_shrink, int shadows, struct yaffs_xattr_mod *xmod)
+{
+
+	struct yaffs_block_info *bi;
+	struct yaffs_dev *dev = in->my_dev;
+	int prev_chunk_id;
+	int ret_val = 0;
+	int result = 0;
+	int new_chunk_id;
+	struct yaffs_ext_tags new_tags;
+	struct yaffs_ext_tags old_tags;
+	const YCHAR *alias = NULL;
+	u8 *buffer = NULL;
+	YCHAR old_name[YAFFS_MAX_NAME_LENGTH + 1];
+	struct yaffs_obj_hdr *oh = NULL;
+	loff_t file_size = 0;
+
+	strcpy(old_name, _Y("silly old name"));
+
+	if (in->fake && in != dev->root_dir && !force && !xmod)
+		return ret_val;
+
+	yaffs_check_gc(dev, 0);
+	yaffs_check_obj_details_loaded(in);
+
+	buffer = yaffs_get_temp_buffer(in->my_dev);
+	oh = (struct yaffs_obj_hdr *)buffer;
+
+	prev_chunk_id = in->hdr_chunk;
+
+	if (prev_chunk_id > 0) {
+		result = yaffs_rd_chunk_tags_nand(dev, prev_chunk_id,
+						  buffer, &old_tags);
+
+		yaffs_verify_oh(in, oh, &old_tags, 0);
+		memcpy(old_name, oh->name, sizeof(oh->name));
+		memset(buffer, 0xff, sizeof(struct yaffs_obj_hdr));
+	} else {
+		memset(buffer, 0xff, dev->data_bytes_per_chunk);
+	}
+
+	oh->type = in->variant_type;
+	oh->yst_mode = in->yst_mode;
+	oh->shadows_obj = oh->inband_shadowed_obj_id = shadows;
+
+	yaffs_load_attribs_oh(oh, in);
+
+	if (in->parent)
+		oh->parent_obj_id = in->parent->obj_id;
+	else
+		oh->parent_obj_id = 0;
+
+	if (name && *name) {
+		memset(oh->name, 0, sizeof(oh->name));
+		yaffs_load_oh_from_name(dev, oh->name, name);
+	} else if (prev_chunk_id > 0) {
+		memcpy(oh->name, old_name, sizeof(oh->name));
+	} else {
+		memset(oh->name, 0, sizeof(oh->name));
+	}
+
+	oh->is_shrink = is_shrink;
+
+	switch (in->variant_type) {
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+		/* Should not happen */
+		break;
+	case YAFFS_OBJECT_TYPE_FILE:
+		if (oh->parent_obj_id != YAFFS_OBJECTID_DELETED &&
+		    oh->parent_obj_id != YAFFS_OBJECTID_UNLINKED)
+			file_size = in->variant.file_variant.file_size;
+		yaffs_oh_size_load(oh, file_size);
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		oh->equiv_id = in->variant.hardlink_variant.equiv_id;
+		break;
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		/* Do nothing */
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		/* Do nothing */
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		alias = in->variant.symlink_variant.alias;
+		if (!alias)
+			alias = _Y("no alias");
+		strncpy(oh->alias, alias, YAFFS_MAX_ALIAS_LENGTH);
+		oh->alias[YAFFS_MAX_ALIAS_LENGTH] = 0;
+		break;
+	}
+
+	/* process any xattrib modifications */
+	if (xmod)
+		yaffs_apply_xattrib_mod(in, (char *)buffer, xmod);
+
+	/* Tags */
+	memset(&new_tags, 0, sizeof(new_tags));
+	in->serial++;
+	new_tags.chunk_id = 0;
+	new_tags.obj_id = in->obj_id;
+	new_tags.serial_number = in->serial;
+
+	/* Add extra info for file header */
+	new_tags.extra_available = 1;
+	new_tags.extra_parent_id = oh->parent_obj_id;
+	new_tags.extra_file_size = file_size;
+	new_tags.extra_is_shrink = oh->is_shrink;
+	new_tags.extra_equiv_id = oh->equiv_id;
+	new_tags.extra_shadows = (oh->shadows_obj > 0) ? 1 : 0;
+	new_tags.extra_obj_type = in->variant_type;
+	yaffs_verify_oh(in, oh, &new_tags, 1);
+
+	/* Create new chunk in NAND */
+	new_chunk_id =
+	    yaffs_write_new_chunk(dev, buffer, &new_tags,
+				  (prev_chunk_id > 0) ? 1 : 0);
+
+	if (buffer)
+		yaffs_release_temp_buffer(dev, buffer);
+
+	if (new_chunk_id < 0)
+		return new_chunk_id;
+
+	in->hdr_chunk = new_chunk_id;
+
+	if (prev_chunk_id > 0)
+		yaffs_chunk_del(dev, prev_chunk_id, 1, __LINE__);
+
+	if (!yaffs_obj_cache_dirty(in))
+		in->dirty = 0;
+
+	/* If this was a shrink, then mark the block
+	 * that the chunk lives on */
+	if (is_shrink) {
+		bi = yaffs_get_block_info(in->my_dev,
+					  new_chunk_id /
+					  in->my_dev->param.chunks_per_block);
+		bi->has_shrink_hdr = 1;
+	}
+
+
+	return new_chunk_id;
+}
+
+/*--------------------- File read/write ------------------------
+ * Read and write have very similar structures.
+ * In general the read/write has three parts to it
+ * An incomplete chunk to start with (if the read/write is not chunk-aligned)
+ * Some complete chunks
+ * An incomplete chunk to end off with
+ *
+ * Curve-balls: the first chunk might also be the last chunk.
+ */
+
+int yaffs_file_rd(struct yaffs_obj *in, u8 * buffer, loff_t offset, int n_bytes)
+{
+	int chunk;
+	u32 start;
+	int n_copy;
+	int n = n_bytes;
+	int n_done = 0;
+	struct yaffs_cache *cache;
+	struct yaffs_dev *dev;
+
+	dev = in->my_dev;
+
+	while (n > 0) {
+		yaffs_addr_to_chunk(dev, offset, &chunk, &start);
+		chunk++;
+
+		/* OK now check for the curveball where the start and end are in
+		 * the same chunk.
+		 */
+		if ((start + n) < dev->data_bytes_per_chunk)
+			n_copy = n;
+		else
+			n_copy = dev->data_bytes_per_chunk - start;
+
+		cache = yaffs_find_chunk_cache(in, chunk);
+
+		/* If the chunk is already in the cache or it is less than
+		 * a whole chunk or we're using inband tags then use the cache
+		 * (if there is caching) else bypass the cache.
+		 */
+		if (cache || n_copy != dev->data_bytes_per_chunk ||
+		    dev->param.inband_tags) {
+			if (dev->param.n_caches > 0) {
+
+				/* If we can't find the data in the cache,
+				 * then load it up. */
+
+				if (!cache) {
+					cache =
+					    yaffs_grab_chunk_cache(in->my_dev);
+					cache->object = in;
+					cache->chunk_id = chunk;
+					cache->dirty = 0;
+					cache->locked = 0;
+					yaffs_rd_data_obj(in, chunk,
+							  cache->data);
+					cache->n_bytes = 0;
+				}
+
+				yaffs_use_cache(dev, cache, 0);
+
+				cache->locked = 1;
+
+				memcpy(buffer, &cache->data[start], n_copy);
+
+				cache->locked = 0;
+			} else {
+				/* Read into the local buffer then copy.. */
+
+				u8 *local_buffer =
+				    yaffs_get_temp_buffer(dev);
+				yaffs_rd_data_obj(in, chunk, local_buffer);
+
+				memcpy(buffer, &local_buffer[start], n_copy);
+
+				yaffs_release_temp_buffer(dev, local_buffer);
+			}
+		} else {
+			/* A full chunk. Read directly into the buffer. */
+			yaffs_rd_data_obj(in, chunk, buffer);
+		}
+		n -= n_copy;
+		offset += n_copy;
+		buffer += n_copy;
+		n_done += n_copy;
+	}
+	return n_done;
+}
+
+int yaffs_do_file_wr(struct yaffs_obj *in, const u8 *buffer, loff_t offset,
+		     int n_bytes, int write_through)
+{
+
+	int chunk;
+	u32 start;
+	int n_copy;
+	int n = n_bytes;
+	int n_done = 0;
+	int n_writeback;
+	loff_t start_write = offset;
+	int chunk_written = 0;
+	u32 n_bytes_read;
+	loff_t chunk_start;
+	struct yaffs_dev *dev;
+
+	dev = in->my_dev;
+
+	while (n > 0 && chunk_written >= 0) {
+		yaffs_addr_to_chunk(dev, offset, &chunk, &start);
+
+		if (((loff_t)chunk) *
+		    dev->data_bytes_per_chunk + start != offset ||
+		    start >= dev->data_bytes_per_chunk) {
+			yaffs_trace(YAFFS_TRACE_ERROR,
+				"AddrToChunk of offset %lld gives chunk %d start %d",
+				offset, chunk, start);
+		}
+		chunk++;	/* File pos to chunk in file offset */
+
+		/* OK now check for the curveball where the start and end are in
+		 * the same chunk.
+		 */
+
+		if ((start + n) < dev->data_bytes_per_chunk) {
+			n_copy = n;
+
+			/* Now calculate how many bytes to write back....
+			 * If we're overwriting and not writing to then end of
+			 * file then we need to write back as much as was there
+			 * before.
+			 */
+
+			chunk_start = (((loff_t)(chunk - 1)) *
+					dev->data_bytes_per_chunk);
+
+			if (chunk_start > in->variant.file_variant.file_size)
+				n_bytes_read = 0;	/* Past end of file */
+			else
+				n_bytes_read =
+				    in->variant.file_variant.file_size -
+				    chunk_start;
+
+			if (n_bytes_read > dev->data_bytes_per_chunk)
+				n_bytes_read = dev->data_bytes_per_chunk;
+
+			n_writeback =
+			    (n_bytes_read >
+			     (start + n)) ? n_bytes_read : (start + n);
+
+			if (n_writeback < 0 ||
+			    n_writeback > dev->data_bytes_per_chunk)
+				BUG();
+
+		} else {
+			n_copy = dev->data_bytes_per_chunk - start;
+			n_writeback = dev->data_bytes_per_chunk;
+		}
+
+		if (n_copy != dev->data_bytes_per_chunk ||
+		    !dev->param.cache_bypass_aligned ||
+		    dev->param.inband_tags) {
+			/* An incomplete start or end chunk (or maybe both
+			 * start and end chunk), or we're using inband tags,
+			 * or we're forcing writes through the cache,
+			 * so we want to use the cache buffers.
+			 */
+			if (dev->param.n_caches > 0) {
+				struct yaffs_cache *cache;
+
+				/* If we can't find the data in the cache, then
+				 * load the cache */
+				cache = yaffs_find_chunk_cache(in, chunk);
+
+				if (!cache &&
+				    yaffs_check_alloc_available(dev, 1)) {
+					cache = yaffs_grab_chunk_cache(dev);
+					cache->object = in;
+					cache->chunk_id = chunk;
+					cache->dirty = 0;
+					cache->locked = 0;
+					yaffs_rd_data_obj(in, chunk,
+							  cache->data);
+				} else if (cache &&
+					   !cache->dirty &&
+					   !yaffs_check_alloc_available(dev,
+									1)) {
+					/* Drop the cache if it was a read cache
+					 * item and no space check has been made
+					 * for it.
+					 */
+					cache = NULL;
+				}
+
+				if (cache) {
+					yaffs_use_cache(dev, cache, 1);
+					cache->locked = 1;
+
+					memcpy(&cache->data[start], buffer,
+					       n_copy);
+
+					cache->locked = 0;
+					cache->n_bytes = n_writeback;
+
+					if (write_through) {
+						chunk_written =
+						    yaffs_wr_data_obj
+						    (cache->object,
+						     cache->chunk_id,
+						     cache->data,
+						     cache->n_bytes, 1);
+						cache->dirty = 0;
+					}
+				} else {
+					chunk_written = -1;	/* fail write */
+				}
+			} else {
+				/* An incomplete start or end chunk (or maybe
+				 * both start and end chunk). Read into the
+				 * local buffer then copy over and write back.
+				 */
+
+				u8 *local_buffer = yaffs_get_temp_buffer(dev);
+
+				yaffs_rd_data_obj(in, chunk, local_buffer);
+				memcpy(&local_buffer[start], buffer, n_copy);
+
+				chunk_written =
+				    yaffs_wr_data_obj(in, chunk,
+						      local_buffer,
+						      n_writeback, 0);
+
+				yaffs_release_temp_buffer(dev, local_buffer);
+			}
+		} else {
+			/* A full chunk. Write directly from the buffer. */
+
+			chunk_written =
+			    yaffs_wr_data_obj(in, chunk, buffer,
+					      dev->data_bytes_per_chunk, 0);
+
+			/* Since we've overwritten the cached data,
+			 * we better invalidate it. */
+			yaffs_invalidate_chunk_cache(in, chunk);
+		}
+
+		if (chunk_written >= 0) {
+			n -= n_copy;
+			offset += n_copy;
+			buffer += n_copy;
+			n_done += n_copy;
+		}
+	}
+
+	/* Update file object */
+
+	if ((start_write + n_done) > in->variant.file_variant.file_size)
+		in->variant.file_variant.file_size = (start_write + n_done);
+
+	in->dirty = 1;
+	return n_done;
+}
+
+int yaffs_wr_file(struct yaffs_obj *in, const u8 *buffer, loff_t offset,
+		  int n_bytes, int write_through)
+{
+	yaffs2_handle_hole(in, offset);
+	return yaffs_do_file_wr(in, buffer, offset, n_bytes, write_through);
+}
+
+/* ---------------------- File resizing stuff ------------------ */
+
+static void yaffs_prune_chunks(struct yaffs_obj *in, loff_t new_size)
+{
+
+	struct yaffs_dev *dev = in->my_dev;
+	loff_t old_size = in->variant.file_variant.file_size;
+	int i;
+	int chunk_id;
+	u32 dummy;
+	int last_del;
+	int start_del;
+
+	if (old_size > 0)
+		yaffs_addr_to_chunk(dev, old_size - 1, &last_del, &dummy);
+	else
+		last_del = 0;
+
+	yaffs_addr_to_chunk(dev, new_size + dev->data_bytes_per_chunk - 1,
+				&start_del, &dummy);
+	last_del++;
+	start_del++;
+
+	/* Delete backwards so that we don't end up with holes if
+	 * power is lost part-way through the operation.
+	 */
+	for (i = last_del; i >= start_del; i--) {
+		/* NB this could be optimised somewhat,
+		 * eg. could retrieve the tags and write them without
+		 * using yaffs_chunk_del
+		 */
+
+		chunk_id = yaffs_find_del_file_chunk(in, i, NULL);
+
+		if (chunk_id < 1)
+			continue;
+
+		if (chunk_id <
+		    (dev->internal_start_block * dev->param.chunks_per_block) ||
+		    chunk_id >=
+		    ((dev->internal_end_block + 1) *
+		      dev->param.chunks_per_block)) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"Found daft chunk_id %d for %d",
+				chunk_id, i);
+		} else {
+			in->n_data_chunks--;
+			yaffs_chunk_del(dev, chunk_id, 1, __LINE__);
+		}
+	}
+}
+
+void yaffs_resize_file_down(struct yaffs_obj *obj, loff_t new_size)
+{
+	int new_full;
+	u32 new_partial;
+	struct yaffs_dev *dev = obj->my_dev;
+
+	yaffs_addr_to_chunk(dev, new_size, &new_full, &new_partial);
+
+	yaffs_prune_chunks(obj, new_size);
+
+	if (new_partial != 0) {
+		int last_chunk = 1 + new_full;
+		u8 *local_buffer = yaffs_get_temp_buffer(dev);
+
+		/* Rewrite the last chunk with its new size and zero pad */
+		yaffs_rd_data_obj(obj, last_chunk, local_buffer);
+		memset(local_buffer + new_partial, 0,
+		       dev->data_bytes_per_chunk - new_partial);
+
+		yaffs_wr_data_obj(obj, last_chunk, local_buffer,
+				  new_partial, 1);
+
+		yaffs_release_temp_buffer(dev, local_buffer);
+	}
+
+	obj->variant.file_variant.file_size = new_size;
+
+	yaffs_prune_tree(dev, &obj->variant.file_variant);
+}
+
+int yaffs_resize_file(struct yaffs_obj *in, loff_t new_size)
+{
+	struct yaffs_dev *dev = in->my_dev;
+	loff_t old_size = in->variant.file_variant.file_size;
+
+	yaffs_flush_file_cache(in);
+	yaffs_invalidate_whole_cache(in);
+
+	yaffs_check_gc(dev, 0);
+
+	if (in->variant_type != YAFFS_OBJECT_TYPE_FILE)
+		return YAFFS_FAIL;
+
+	if (new_size == old_size)
+		return YAFFS_OK;
+
+	if (new_size > old_size) {
+		yaffs2_handle_hole(in, new_size);
+		in->variant.file_variant.file_size = new_size;
+	} else {
+		/* new_size < old_size */
+		yaffs_resize_file_down(in, new_size);
+	}
+
+	/* Write a new object header to reflect the resize.
+	 * show we've shrunk the file, if need be
+	 * Do this only if the file is not in the deleted directories
+	 * and is not shadowed.
+	 */
+	if (in->parent &&
+	    !in->is_shadowed &&
+	    in->parent->obj_id != YAFFS_OBJECTID_UNLINKED &&
+	    in->parent->obj_id != YAFFS_OBJECTID_DELETED)
+		yaffs_update_oh(in, NULL, 0, 0, 0, NULL);
+
+	return YAFFS_OK;
+}
+
+int yaffs_flush_file(struct yaffs_obj *in, int update_time, int data_sync)
+{
+	if (!in->dirty)
+		return YAFFS_OK;
+
+	yaffs_flush_file_cache(in);
+
+	if (data_sync)
+		return YAFFS_OK;
+
+	if (update_time)
+		yaffs_load_current_time(in, 0, 0);
+
+	return (yaffs_update_oh(in, NULL, 0, 0, 0, NULL) >= 0) ?
+				YAFFS_OK : YAFFS_FAIL;
+}
+
+
+/* yaffs_del_file deletes the whole file data
+ * and the inode associated with the file.
+ * It does not delete the links associated with the file.
+ */
+static int yaffs_unlink_file_if_needed(struct yaffs_obj *in)
+{
+	int ret_val;
+	int del_now = 0;
+	struct yaffs_dev *dev = in->my_dev;
+
+	if (!in->my_inode)
+		del_now = 1;
+
+	if (del_now) {
+		ret_val =
+		    yaffs_change_obj_name(in, in->my_dev->del_dir,
+					  _Y("deleted"), 0, 0);
+		yaffs_trace(YAFFS_TRACE_TRACING,
+			"yaffs: immediate deletion of file %d",
+			in->obj_id);
+		in->deleted = 1;
+		in->my_dev->n_deleted_files++;
+		if (dev->param.disable_soft_del || dev->param.is_yaffs2)
+			yaffs_resize_file(in, 0);
+		yaffs_soft_del_file(in);
+	} else {
+		ret_val =
+		    yaffs_change_obj_name(in, in->my_dev->unlinked_dir,
+					  _Y("unlinked"), 0, 0);
+	}
+	return ret_val;
+}
+
+static int yaffs_del_file(struct yaffs_obj *in)
+{
+	int ret_val = YAFFS_OK;
+	int deleted;	/* Need to cache value on stack if in is freed */
+	struct yaffs_dev *dev = in->my_dev;
+
+	if (dev->param.disable_soft_del || dev->param.is_yaffs2)
+		yaffs_resize_file(in, 0);
+
+	if (in->n_data_chunks > 0) {
+		/* Use soft deletion if there is data in the file.
+		 * That won't be the case if it has been resized to zero.
+		 */
+		if (!in->unlinked)
+			ret_val = yaffs_unlink_file_if_needed(in);
+
+		deleted = in->deleted;
+
+		if (ret_val == YAFFS_OK && in->unlinked && !in->deleted) {
+			in->deleted = 1;
+			deleted = 1;
+			in->my_dev->n_deleted_files++;
+			yaffs_soft_del_file(in);
+		}
+		return deleted ? YAFFS_OK : YAFFS_FAIL;
+	} else {
+		/* The file has no data chunks so we toss it immediately */
+		yaffs_free_tnode(in->my_dev, in->variant.file_variant.top);
+		in->variant.file_variant.top = NULL;
+		yaffs_generic_obj_del(in);
+
+		return YAFFS_OK;
+	}
+}
+
+int yaffs_is_non_empty_dir(struct yaffs_obj *obj)
+{
+	return (obj &&
+		obj->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY) &&
+		!(list_empty(&obj->variant.dir_variant.children));
+}
+
+static int yaffs_del_dir(struct yaffs_obj *obj)
+{
+	/* First check that the directory is empty. */
+	if (yaffs_is_non_empty_dir(obj))
+		return YAFFS_FAIL;
+
+	return yaffs_generic_obj_del(obj);
+}
+
+static int yaffs_del_symlink(struct yaffs_obj *in)
+{
+	kfree(in->variant.symlink_variant.alias);
+	in->variant.symlink_variant.alias = NULL;
+
+	return yaffs_generic_obj_del(in);
+}
+
+static int yaffs_del_link(struct yaffs_obj *in)
+{
+	/* remove this hardlink from the list associated with the equivalent
+	 * object
+	 */
+	list_del_init(&in->hard_links);
+	return yaffs_generic_obj_del(in);
+}
+
+int yaffs_del_obj(struct yaffs_obj *obj)
+{
+	int ret_val = -1;
+
+	switch (obj->variant_type) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		ret_val = yaffs_del_file(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		if (!list_empty(&obj->variant.dir_variant.dirty)) {
+			yaffs_trace(YAFFS_TRACE_BACKGROUND,
+				"Remove object %d from dirty directories",
+				obj->obj_id);
+			list_del_init(&obj->variant.dir_variant.dirty);
+		}
+		return yaffs_del_dir(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		ret_val = yaffs_del_symlink(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		ret_val = yaffs_del_link(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		ret_val = yaffs_generic_obj_del(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+		ret_val = 0;
+		break;		/* should not happen. */
+	}
+	return ret_val;
+}
+
+static int yaffs_unlink_worker(struct yaffs_obj *obj)
+{
+	int del_now = 0;
+
+	if (!obj)
+		return YAFFS_FAIL;
+
+	if (!obj->my_inode)
+		del_now = 1;
+
+	yaffs_update_parent(obj->parent);
+
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_HARDLINK) {
+		return yaffs_del_link(obj);
+	} else if (!list_empty(&obj->hard_links)) {
+		/* Curve ball: We're unlinking an object that has a hardlink.
+		 *
+		 * This problem arises because we are not strictly following
+		 * The Linux link/inode model.
+		 *
+		 * We can't really delete the object.
+		 * Instead, we do the following:
+		 * - Select a hardlink.
+		 * - Unhook it from the hard links
+		 * - Move it from its parent directory so that the rename works.
+		 * - Rename the object to the hardlink's name.
+		 * - Delete the hardlink
+		 */
+
+		struct yaffs_obj *hl;
+		struct yaffs_obj *parent;
+		int ret_val;
+		YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];
+
+		hl = list_entry(obj->hard_links.next, struct yaffs_obj,
+				hard_links);
+
+		yaffs_get_obj_name(hl, name, YAFFS_MAX_NAME_LENGTH + 1);
+		parent = hl->parent;
+
+		list_del_init(&hl->hard_links);
+
+		yaffs_add_obj_to_dir(obj->my_dev->unlinked_dir, hl);
+
+		ret_val = yaffs_change_obj_name(obj, parent, name, 0, 0);
+
+		if (ret_val == YAFFS_OK)
+			ret_val = yaffs_generic_obj_del(hl);
+
+		return ret_val;
+
+	} else if (del_now) {
+		switch (obj->variant_type) {
+		case YAFFS_OBJECT_TYPE_FILE:
+			return yaffs_del_file(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+			list_del_init(&obj->variant.dir_variant.dirty);
+			return yaffs_del_dir(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+			return yaffs_del_symlink(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+			return yaffs_generic_obj_del(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+		default:
+			return YAFFS_FAIL;
+		}
+	} else if (yaffs_is_non_empty_dir(obj)) {
+		return YAFFS_FAIL;
+	} else {
+		return yaffs_change_obj_name(obj, obj->my_dev->unlinked_dir,
+						_Y("unlinked"), 0, 0);
+	}
+}
+
+static int yaffs_unlink_obj(struct yaffs_obj *obj)
+{
+	if (obj && obj->unlink_allowed)
+		return yaffs_unlink_worker(obj);
+
+	return YAFFS_FAIL;
+}
+
+int yaffs_unlinker(struct yaffs_obj *dir, const YCHAR *name)
+{
+	struct yaffs_obj *obj;
+
+	obj = yaffs_find_by_name(dir, name);
+	return yaffs_unlink_obj(obj);
+}
+
+/* Note:
+ * If old_name is NULL then we take old_dir as the object to be renamed.
+ */
+int yaffs_rename_obj(struct yaffs_obj *old_dir, const YCHAR *old_name,
+		     struct yaffs_obj *new_dir, const YCHAR *new_name)
+{
+	struct yaffs_obj *obj = NULL;
+	struct yaffs_obj *existing_target = NULL;
+	int force = 0;
+	int result;
+	struct yaffs_dev *dev;
+
+	if (!old_dir || old_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		BUG();
+		return YAFFS_FAIL;
+	}
+	if (!new_dir || new_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		BUG();
+		return YAFFS_FAIL;
+	}
+
+	dev = old_dir->my_dev;
+
+#ifdef CONFIG_YAFFS_CASE_INSENSITIVE
+	/* Special case for case insemsitive systems.
+	 * While look-up is case insensitive, the name isn't.
+	 * Therefore we might want to change x.txt to X.txt
+	 */
+	if (old_dir == new_dir &&
+		old_name && new_name &&
+		strcmp(old_name, new_name) == 0)
+		force = 1;
+#endif
+
+	if (strnlen(new_name, YAFFS_MAX_NAME_LENGTH + 1) >
+	    YAFFS_MAX_NAME_LENGTH)
+		/* ENAMETOOLONG */
+		return YAFFS_FAIL;
+
+	if (old_name)
+		obj = yaffs_find_by_name(old_dir, old_name);
+	else{
+		obj = old_dir;
+		old_dir = obj->parent;
+	}
+
+	if (obj && obj->rename_allowed) {
+		/* Now handle an existing target, if there is one */
+		existing_target = yaffs_find_by_name(new_dir, new_name);
+		if (yaffs_is_non_empty_dir(existing_target)) {
+			return YAFFS_FAIL;	/* ENOTEMPTY */
+		} else if (existing_target && existing_target != obj) {
+			/* Nuke the target first, using shadowing,
+			 * but only if it isn't the same object.
+			 *
+			 * Note we must disable gc here otherwise it can mess
+			 * up the shadowing.
+			 *
+			 */
+			dev->gc_disable = 1;
+			yaffs_change_obj_name(obj, new_dir, new_name, force,
+					      existing_target->obj_id);
+			existing_target->is_shadowed = 1;
+			yaffs_unlink_obj(existing_target);
+			dev->gc_disable = 0;
+		}
+
+		result = yaffs_change_obj_name(obj, new_dir, new_name, 1, 0);
+
+		yaffs_update_parent(old_dir);
+		if (new_dir != old_dir)
+			yaffs_update_parent(new_dir);
+
+		return result;
+	}
+	return YAFFS_FAIL;
+}
+
+/*----------------------- Initialisation Scanning ---------------------- */
+
+void yaffs_handle_shadowed_obj(struct yaffs_dev *dev, int obj_id,
+			       int backward_scanning)
+{
+	struct yaffs_obj *obj;
+
+	if (backward_scanning) {
+		/* Handle YAFFS2 case (backward scanning)
+		 * If the shadowed object exists then ignore.
+		 */
+		obj = yaffs_find_by_number(dev, obj_id);
+		if (obj)
+			return;
+	}
+
+	/* Let's create it (if it does not exist) assuming it is a file so that
+	 * it can do shrinking etc.
+	 * We put it in unlinked dir to be cleaned up after the scanning
+	 */
+	obj =
+	    yaffs_find_or_create_by_number(dev, obj_id, YAFFS_OBJECT_TYPE_FILE);
+	if (!obj)
+		return;
+	obj->is_shadowed = 1;
+	yaffs_add_obj_to_dir(dev->unlinked_dir, obj);
+	obj->variant.file_variant.shrink_size = 0;
+	obj->valid = 1;		/* So that we don't read any other info. */
+}
+
+void yaffs_link_fixup(struct yaffs_dev *dev, struct list_head *hard_list)
+{
+	struct list_head *lh;
+	struct list_head *save;
+	struct yaffs_obj *hl;
+	struct yaffs_obj *in;
+
+	list_for_each_safe(lh, save, hard_list) {
+		hl = list_entry(lh, struct yaffs_obj, hard_links);
+		in = yaffs_find_by_number(dev,
+					hl->variant.hardlink_variant.equiv_id);
+
+		if (in) {
+			/* Add the hardlink pointers */
+			hl->variant.hardlink_variant.equiv_obj = in;
+			list_add(&hl->hard_links, &in->hard_links);
+		} else {
+			/* Todo Need to report/handle this better.
+			 * Got a problem... hardlink to a non-existant object
+			 */
+			hl->variant.hardlink_variant.equiv_obj = NULL;
+			INIT_LIST_HEAD(&hl->hard_links);
+		}
+	}
+}
+
+static void yaffs_strip_deleted_objs(struct yaffs_dev *dev)
+{
+	/*
+	 *  Sort out state of unlinked and deleted objects after scanning.
+	 */
+	struct list_head *i;
+	struct list_head *n;
+	struct yaffs_obj *l;
+
+	if (dev->read_only)
+		return;
+
+	/* Soft delete all the unlinked files */
+	list_for_each_safe(i, n,
+			   &dev->unlinked_dir->variant.dir_variant.children) {
+		l = list_entry(i, struct yaffs_obj, siblings);
+		yaffs_del_obj(l);
+	}
+
+	list_for_each_safe(i, n, &dev->del_dir->variant.dir_variant.children) {
+		l = list_entry(i, struct yaffs_obj, siblings);
+		yaffs_del_obj(l);
+	}
+}
+
+/*
+ * This code iterates through all the objects making sure that they are rooted.
+ * Any unrooted objects are re-rooted in lost+found.
+ * An object needs to be in one of:
+ * - Directly under deleted, unlinked
+ * - Directly or indirectly under root.
+ *
+ * Note:
+ *  This code assumes that we don't ever change the current relationships
+ *  between directories:
+ *   root_dir->parent == unlinked_dir->parent == del_dir->parent == NULL
+ *   lost-n-found->parent == root_dir
+ *
+ * This fixes the problem where directories might have inadvertently been
+ * deleted leaving the object "hanging" without being rooted in the
+ * directory tree.
+ */
+
+static int yaffs_has_null_parent(struct yaffs_dev *dev, struct yaffs_obj *obj)
+{
+	return (obj == dev->del_dir ||
+		obj == dev->unlinked_dir || obj == dev->root_dir);
+}
+
+static void yaffs_fix_hanging_objs(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_obj *parent;
+	int i;
+	struct list_head *lh;
+	struct list_head *n;
+	int depth_limit;
+	int hanging;
+
+	if (dev->read_only)
+		return;
+
+	/* Iterate through the objects in each hash entry,
+	 * looking at each object.
+	 * Make sure it is rooted.
+	 */
+
+	for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
+		list_for_each_safe(lh, n, &dev->obj_bucket[i].list) {
+			obj = list_entry(lh, struct yaffs_obj, hash_link);
+			parent = obj->parent;
+
+			if (yaffs_has_null_parent(dev, obj)) {
+				/* These directories are not hanging */
+				hanging = 0;
+			} else if (!parent ||
+				   parent->variant_type !=
+				   YAFFS_OBJECT_TYPE_DIRECTORY) {
+				hanging = 1;
+			} else if (yaffs_has_null_parent(dev, parent)) {
+				hanging = 0;
+			} else {
+				/*
+				 * Need to follow the parent chain to
+				 * see if it is hanging.
+				 */
+				hanging = 0;
+				depth_limit = 100;
+
+				while (parent != dev->root_dir &&
+				       parent->parent &&
+				       parent->parent->variant_type ==
+				       YAFFS_OBJECT_TYPE_DIRECTORY &&
+				       depth_limit > 0) {
+					parent = parent->parent;
+					depth_limit--;
+				}
+				if (parent != dev->root_dir)
+					hanging = 1;
+			}
+			if (hanging) {
+				yaffs_trace(YAFFS_TRACE_SCAN,
+					"Hanging object %d moved to lost and found",
+					obj->obj_id);
+				yaffs_add_obj_to_dir(dev->lost_n_found, obj);
+			}
+		}
+	}
+}
+
+/*
+ * Delete directory contents for cleaning up lost and found.
+ */
+static void yaffs_del_dir_contents(struct yaffs_obj *dir)
+{
+	struct yaffs_obj *obj;
+	struct list_head *lh;
+	struct list_head *n;
+
+	if (dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY)
+		BUG();
+
+	list_for_each_safe(lh, n, &dir->variant.dir_variant.children) {
+		obj = list_entry(lh, struct yaffs_obj, siblings);
+		if (obj->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY)
+			yaffs_del_dir_contents(obj);
+		yaffs_trace(YAFFS_TRACE_SCAN,
+			"Deleting lost_found object %d",
+			obj->obj_id);
+		yaffs_unlink_obj(obj);
+	}
+}
+
+static void yaffs_empty_l_n_f(struct yaffs_dev *dev)
+{
+	yaffs_del_dir_contents(dev->lost_n_found);
+}
+
+
+struct yaffs_obj *yaffs_find_by_name(struct yaffs_obj *directory,
+				     const YCHAR *name)
+{
+	int sum;
+	struct list_head *i;
+	YCHAR buffer[YAFFS_MAX_NAME_LENGTH + 1];
+	struct yaffs_obj *l;
+
+	if (!name)
+		return NULL;
+
+	if (!directory) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"tragedy: yaffs_find_by_name: null pointer directory"
+			);
+		BUG();
+		return NULL;
+	}
+	if (directory->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"tragedy: yaffs_find_by_name: non-directory"
+			);
+		BUG();
+	}
+
+	sum = yaffs_calc_name_sum(name);
+
+	list_for_each(i, &directory->variant.dir_variant.children) {
+		l = list_entry(i, struct yaffs_obj, siblings);
+
+		if (l->parent != directory)
+			BUG();
+
+		yaffs_check_obj_details_loaded(l);
+
+		/* Special case for lost-n-found */
+		if (l->obj_id == YAFFS_OBJECTID_LOSTNFOUND) {
+			if (!strcmp(name, YAFFS_LOSTNFOUND_NAME))
+				return l;
+		} else if (l->sum == sum || l->hdr_chunk <= 0) {
+			/* LostnFound chunk called Objxxx
+			 * Do a real check
+			 */
+			yaffs_get_obj_name(l, buffer,
+				YAFFS_MAX_NAME_LENGTH + 1);
+			if (!strncmp(name, buffer, YAFFS_MAX_NAME_LENGTH))
+				return l;
+		}
+	}
+	return NULL;
+}
+
+/* GetEquivalentObject dereferences any hard links to get to the
+ * actual object.
+ */
+
+struct yaffs_obj *yaffs_get_equivalent_obj(struct yaffs_obj *obj)
+{
+	if (obj && obj->variant_type == YAFFS_OBJECT_TYPE_HARDLINK) {
+		obj = obj->variant.hardlink_variant.equiv_obj;
+		yaffs_check_obj_details_loaded(obj);
+	}
+	return obj;
+}
+
+/*
+ *  A note or two on object names.
+ *  * If the object name is missing, we then make one up in the form objnnn
+ *
+ *  * ASCII names are stored in the object header's name field from byte zero
+ *  * Unicode names are historically stored starting from byte zero.
+ *
+ * Then there are automatic Unicode names...
+ * The purpose of these is to save names in a way that can be read as
+ * ASCII or Unicode names as appropriate, thus allowing a Unicode and ASCII
+ * system to share files.
+ *
+ * These automatic unicode are stored slightly differently...
+ *  - If the name can fit in the ASCII character space then they are saved as
+ *    ascii names as per above.
+ *  - If the name needs Unicode then the name is saved in Unicode
+ *    starting at oh->name[1].
+
+ */
+static void yaffs_fix_null_name(struct yaffs_obj *obj, YCHAR *name,
+				int buffer_size)
+{
+	/* Create an object name if we could not find one. */
+	if (strnlen(name, YAFFS_MAX_NAME_LENGTH) == 0) {
+		YCHAR local_name[20];
+		YCHAR num_string[20];
+		YCHAR *x = &num_string[19];
+		unsigned v = obj->obj_id;
+		num_string[19] = 0;
+		while (v > 0) {
+			x--;
+			*x = '0' + (v % 10);
+			v /= 10;
+		}
+		/* make up a name */
+		strcpy(local_name, YAFFS_LOSTNFOUND_PREFIX);
+		strcat(local_name, x);
+		strncpy(name, local_name, buffer_size - 1);
+	}
+}
+
+int yaffs_get_obj_name(struct yaffs_obj *obj, YCHAR *name, int buffer_size)
+{
+	memset(name, 0, buffer_size * sizeof(YCHAR));
+	yaffs_check_obj_details_loaded(obj);
+	if (obj->obj_id == YAFFS_OBJECTID_LOSTNFOUND) {
+		strncpy(name, YAFFS_LOSTNFOUND_NAME, buffer_size - 1);
+	} else if (obj->short_name[0]) {
+		strcpy(name, obj->short_name);
+	} else if (obj->hdr_chunk > 0) {
+		int result;
+		u8 *buffer = yaffs_get_temp_buffer(obj->my_dev);
+
+		struct yaffs_obj_hdr *oh = (struct yaffs_obj_hdr *)buffer;
+
+		memset(buffer, 0, obj->my_dev->data_bytes_per_chunk);
+
+		if (obj->hdr_chunk > 0) {
+			result = yaffs_rd_chunk_tags_nand(obj->my_dev,
+							  obj->hdr_chunk,
+							  buffer, NULL);
+		}
+		yaffs_load_name_from_oh(obj->my_dev, name, oh->name,
+					buffer_size);
+
+		yaffs_release_temp_buffer(obj->my_dev, buffer);
+	}
+
+	yaffs_fix_null_name(obj, name, buffer_size);
+
+	return strnlen(name, YAFFS_MAX_NAME_LENGTH);
+}
+
+loff_t yaffs_get_obj_length(struct yaffs_obj *obj)
+{
+	/* Dereference any hard linking */
+	obj = yaffs_get_equivalent_obj(obj);
+
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_FILE)
+		return obj->variant.file_variant.file_size;
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_SYMLINK) {
+		if (!obj->variant.symlink_variant.alias)
+			return 0;
+		return strnlen(obj->variant.symlink_variant.alias,
+				     YAFFS_MAX_ALIAS_LENGTH);
+	} else {
+		/* Only a directory should drop through to here */
+		return obj->my_dev->data_bytes_per_chunk;
+	}
+}
+
+int yaffs_get_obj_link_count(struct yaffs_obj *obj)
+{
+	int count = 0;
+	struct list_head *i;
+
+	if (!obj->unlinked)
+		count++;	/* the object itself */
+
+	list_for_each(i, &obj->hard_links)
+	    count++;		/* add the hard links; */
+
+	return count;
+}
+
+int yaffs_get_obj_inode(struct yaffs_obj *obj)
+{
+	obj = yaffs_get_equivalent_obj(obj);
+
+	return obj->obj_id;
+}
+
+unsigned yaffs_get_obj_type(struct yaffs_obj *obj)
+{
+	obj = yaffs_get_equivalent_obj(obj);
+
+	switch (obj->variant_type) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		return DT_REG;
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		return DT_DIR;
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		return DT_LNK;
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		return DT_REG;
+		break;
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		if (S_ISFIFO(obj->yst_mode))
+			return DT_FIFO;
+		if (S_ISCHR(obj->yst_mode))
+			return DT_CHR;
+		if (S_ISBLK(obj->yst_mode))
+			return DT_BLK;
+		if (S_ISSOCK(obj->yst_mode))
+			return DT_SOCK;
+		return DT_REG;
+		break;
+	default:
+		return DT_REG;
+		break;
+	}
+}
+
+YCHAR *yaffs_get_symlink_alias(struct yaffs_obj *obj)
+{
+	obj = yaffs_get_equivalent_obj(obj);
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_SYMLINK)
+		return yaffs_clone_str(obj->variant.symlink_variant.alias);
+	else
+		return yaffs_clone_str(_Y(""));
+}
+
+/*--------------------------- Initialisation code -------------------------- */
+
+static int yaffs_check_dev_fns(struct yaffs_dev *dev)
+{
+	struct yaffs_driver *drv = &dev->drv;
+	struct yaffs_tags_handler *tagger = &dev->tagger;
+
+	/* Common functions, gotta have */
+	if (!drv->drv_read_chunk_fn ||
+	    !drv->drv_write_chunk_fn ||
+	    !drv->drv_erase_fn)
+		return 0;
+
+	if (dev->param.is_yaffs2 &&
+	     (!drv->drv_mark_bad_fn  || !drv->drv_check_bad_fn))
+		return 0;
+
+	/* Install the default tags marshalling functions if needed. */
+	yaffs_tags_compat_install(dev);
+	yaffs_tags_marshall_install(dev);
+
+	/* Check we now have the marshalling functions required. */
+	if (!tagger->write_chunk_tags_fn ||
+	    !tagger->read_chunk_tags_fn ||
+	    !tagger->query_block_fn ||
+	    !tagger->mark_bad_fn)
+		return 0;
+
+	return 1;
+}
+
+static int yaffs_create_initial_dir(struct yaffs_dev *dev)
+{
+	/* Initialise the unlinked, deleted, root and lost+found directories */
+	dev->lost_n_found = dev->root_dir = NULL;
+	dev->unlinked_dir = dev->del_dir = NULL;
+	dev->unlinked_dir =
+	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_UNLINKED, S_IFDIR);
+	dev->del_dir =
+	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_DELETED, S_IFDIR);
+	dev->root_dir =
+	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_ROOT,
+				  YAFFS_ROOT_MODE | S_IFDIR);
+	dev->lost_n_found =
+	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_LOSTNFOUND,
+				  YAFFS_LOSTNFOUND_MODE | S_IFDIR);
+
+	if (dev->lost_n_found && dev->root_dir && dev->unlinked_dir
+	    && dev->del_dir) {
+		yaffs_add_obj_to_dir(dev->root_dir, dev->lost_n_found);
+		return YAFFS_OK;
+	}
+	return YAFFS_FAIL;
+}
+
+int yaffs_guts_initialise(struct yaffs_dev *dev)
+{
+	int init_failed = 0;
+	unsigned x;
+	int bits;
+
+	yaffs_trace(YAFFS_TRACE_TRACING, "yaffs: yaffs_guts_initialise()");
+
+	/* Check stuff that must be set */
+
+	if (!dev) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"yaffs: Need a device"
+			);
+		return YAFFS_FAIL;
+	}
+
+	if (dev->is_mounted) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "device already mounted");
+		return YAFFS_FAIL;
+	}
+
+	dev->internal_start_block = dev->param.start_block;
+	dev->internal_end_block = dev->param.end_block;
+	dev->block_offset = 0;
+	dev->chunk_offset = 0;
+	dev->n_free_chunks = 0;
+
+	dev->gc_block = 0;
+
+	if (dev->param.start_block == 0) {
+		dev->internal_start_block = dev->param.start_block + 1;
+		dev->internal_end_block = dev->param.end_block + 1;
+		dev->block_offset = 1;
+		dev->chunk_offset = dev->param.chunks_per_block;
+	}
+
+	/* Check geometry parameters. */
+
+	if ((!dev->param.inband_tags && dev->param.is_yaffs2 &&
+		dev->param.total_bytes_per_chunk < 1024) ||
+		(!dev->param.is_yaffs2 &&
+			dev->param.total_bytes_per_chunk < 512) ||
+		(dev->param.inband_tags && !dev->param.is_yaffs2) ||
+		 dev->param.chunks_per_block < 2 ||
+		 dev->param.n_reserved_blocks < 2 ||
+		dev->internal_start_block <= 0 ||
+		dev->internal_end_block <= 0 ||
+		dev->internal_end_block <=
+		(dev->internal_start_block + dev->param.n_reserved_blocks + 2)
+		) {
+		/* otherwise it is too small */
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"NAND geometry problems: chunk size %d, type is yaffs%s, inband_tags %d ",
+			dev->param.total_bytes_per_chunk,
+			dev->param.is_yaffs2 ? "2" : "",
+			dev->param.inband_tags);
+		return YAFFS_FAIL;
+	}
+
+	if (yaffs_init_nand(dev) != YAFFS_OK) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "InitialiseNAND failed");
+		return YAFFS_FAIL;
+	}
+
+	/* Sort out space for inband tags, if required */
+	if (dev->param.inband_tags)
+		dev->data_bytes_per_chunk =
+		    dev->param.total_bytes_per_chunk -
+		    sizeof(struct yaffs_packed_tags2_tags_only);
+	else
+		dev->data_bytes_per_chunk = dev->param.total_bytes_per_chunk;
+
+	/* Got the right mix of functions? */
+	if (!yaffs_check_dev_fns(dev)) {
+		/* Function missing */
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"device function(s) missing or wrong");
+
+		return YAFFS_FAIL;
+	}
+
+	/* Finished with most checks. Further checks happen later on too. */
+
+	dev->is_mounted = 1;
+
+	/* OK now calculate a few things for the device */
+
+	/*
+	 *  Calculate all the chunk size manipulation numbers:
+	 */
+	x = dev->data_bytes_per_chunk;
+	/* We always use dev->chunk_shift and dev->chunk_div */
+	dev->chunk_shift = calc_shifts(x);
+	x >>= dev->chunk_shift;
+	dev->chunk_div = x;
+	/* We only use chunk mask if chunk_div is 1 */
+	dev->chunk_mask = (1 << dev->chunk_shift) - 1;
+
+	/*
+	 * Calculate chunk_grp_bits.
+	 * We need to find the next power of 2 > than internal_end_block
+	 */
+
+	x = dev->param.chunks_per_block * (dev->internal_end_block + 1);
+
+	bits = calc_shifts_ceiling(x);
+
+	/* Set up tnode width if wide tnodes are enabled. */
+	if (!dev->param.wide_tnodes_disabled) {
+		/* bits must be even so that we end up with 32-bit words */
+		if (bits & 1)
+			bits++;
+		if (bits < 16)
+			dev->tnode_width = 16;
+		else
+			dev->tnode_width = bits;
+	} else {
+		dev->tnode_width = 16;
+	}
+
+	dev->tnode_mask = (1 << dev->tnode_width) - 1;
+
+	/* Level0 Tnodes are 16 bits or wider (if wide tnodes are enabled),
+	 * so if the bitwidth of the
+	 * chunk range we're using is greater than 16 we need
+	 * to figure out chunk shift and chunk_grp_size
+	 */
+
+	if (bits <= dev->tnode_width)
+		dev->chunk_grp_bits = 0;
+	else
+		dev->chunk_grp_bits = bits - dev->tnode_width;
+
+	dev->tnode_size = (dev->tnode_width * YAFFS_NTNODES_LEVEL0) / 8;
+	if (dev->tnode_size < sizeof(struct yaffs_tnode))
+		dev->tnode_size = sizeof(struct yaffs_tnode);
+
+	dev->chunk_grp_size = 1 << dev->chunk_grp_bits;
+
+	if (dev->param.chunks_per_block < dev->chunk_grp_size) {
+		/* We have a problem because the soft delete won't work if
+		 * the chunk group size > chunks per block.
+		 * This can be remedied by using larger "virtual blocks".
+		 */
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "chunk group too large");
+
+		return YAFFS_FAIL;
+	}
+
+	/* Finished verifying the device, continue with initialisation */
+
+	/* More device initialisation */
+	dev->all_gcs = 0;
+	dev->passive_gc_count = 0;
+	dev->oldest_dirty_gc_count = 0;
+	dev->bg_gcs = 0;
+	dev->gc_block_finder = 0;
+	dev->buffered_block = -1;
+	dev->doing_buffered_block_rewrite = 0;
+	dev->n_deleted_files = 0;
+	dev->n_bg_deletions = 0;
+	dev->n_unlinked_files = 0;
+	dev->n_ecc_fixed = 0;
+	dev->n_ecc_unfixed = 0;
+	dev->n_tags_ecc_fixed = 0;
+	dev->n_tags_ecc_unfixed = 0;
+	dev->n_erase_failures = 0;
+	dev->n_erased_blocks = 0;
+	dev->gc_disable = 0;
+	dev->has_pending_prioritised_gc = 1;
+		/* Assume the worst for now, will get fixed on first GC */
+	INIT_LIST_HEAD(&dev->dirty_dirs);
+	dev->oldest_dirty_seq = 0;
+	dev->oldest_dirty_block = 0;
+
+	/* Initialise temporary buffers and caches. */
+	if (!yaffs_init_tmp_buffers(dev))
+		init_failed = 1;
+
+	dev->cache = NULL;
+	dev->gc_cleanup_list = NULL;
+
+	if (!init_failed && dev->param.n_caches > 0) {
+		int i;
+		void *buf;
+		int cache_bytes =
+		    dev->param.n_caches * sizeof(struct yaffs_cache);
+
+		if (dev->param.n_caches > YAFFS_MAX_SHORT_OP_CACHES)
+			dev->param.n_caches = YAFFS_MAX_SHORT_OP_CACHES;
+
+		dev->cache = kmalloc(cache_bytes, GFP_NOFS);
+
+		buf = (u8 *) dev->cache;
+
+		if (dev->cache)
+			memset(dev->cache, 0, cache_bytes);
+
+		for (i = 0; i < dev->param.n_caches && buf; i++) {
+			dev->cache[i].object = NULL;
+			dev->cache[i].last_use = 0;
+			dev->cache[i].dirty = 0;
+			dev->cache[i].data = buf =
+			    kmalloc(dev->param.total_bytes_per_chunk, GFP_NOFS);
+		}
+		if (!buf)
+			init_failed = 1;
+
+		dev->cache_last_use = 0;
+	}
+
+	dev->cache_hits = 0;
+
+	if (!init_failed) {
+		dev->gc_cleanup_list =
+		    kmalloc(dev->param.chunks_per_block * sizeof(u32),
+					GFP_NOFS);
+		if (!dev->gc_cleanup_list)
+			init_failed = 1;
+	}
+
+	if (dev->param.is_yaffs2)
+		dev->param.use_header_file_size = 1;
+
+	if (!init_failed && !yaffs_init_blocks(dev))
+		init_failed = 1;
+
+	yaffs_init_tnodes_and_objs(dev);
+
+	if (!init_failed && !yaffs_create_initial_dir(dev))
+		init_failed = 1;
+
+	if (!init_failed && dev->param.is_yaffs2 &&
+		!dev->param.disable_summary &&
+		!yaffs_summary_init(dev))
+		init_failed = 1;
+
+	if (!init_failed) {
+		/* Now scan the flash. */
+		if (dev->param.is_yaffs2) {
+			if (yaffs2_checkpt_restore(dev)) {
+				yaffs_check_obj_details_loaded(dev->root_dir);
+				yaffs_trace(YAFFS_TRACE_CHECKPOINT |
+					YAFFS_TRACE_MOUNT,
+					"yaffs: restored from checkpoint"
+					);
+			} else {
+
+				/* Clean up the mess caused by an aborted
+				 * checkpoint load then scan backwards.
+				 */
+				yaffs_deinit_blocks(dev);
+
+				yaffs_deinit_tnodes_and_objs(dev);
+
+				dev->n_erased_blocks = 0;
+				dev->n_free_chunks = 0;
+				dev->alloc_block = -1;
+				dev->alloc_page = -1;
+				dev->n_deleted_files = 0;
+				dev->n_unlinked_files = 0;
+				dev->n_bg_deletions = 0;
+
+				if (!init_failed && !yaffs_init_blocks(dev))
+					init_failed = 1;
+
+				yaffs_init_tnodes_and_objs(dev);
+
+				if (!init_failed
+				    && !yaffs_create_initial_dir(dev))
+					init_failed = 1;
+
+				if (!init_failed && !yaffs2_scan_backwards(dev))
+					init_failed = 1;
+			}
+		} else if (!yaffs1_scan(dev)) {
+			init_failed = 1;
+		}
+
+		yaffs_strip_deleted_objs(dev);
+		yaffs_fix_hanging_objs(dev);
+		if (dev->param.empty_lost_n_found)
+			yaffs_empty_l_n_f(dev);
+	}
+
+	if (init_failed) {
+		/* Clean up the mess */
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+		  "yaffs: yaffs_guts_initialise() aborted.");
+
+		yaffs_deinitialise(dev);
+		return YAFFS_FAIL;
+	}
+
+	/* Zero out stats */
+	dev->n_page_reads = 0;
+	dev->n_page_writes = 0;
+	dev->n_erasures = 0;
+	dev->n_gc_copies = 0;
+	dev->n_retried_writes = 0;
+
+	dev->n_retired_blocks = 0;
+
+	yaffs_verify_free_chunks(dev);
+	yaffs_verify_blocks(dev);
+
+	/* Clean up any aborted checkpoint data */
+	if (!dev->is_checkpointed && dev->blocks_in_checkpt > 0)
+		yaffs2_checkpt_invalidate(dev);
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+	  "yaffs: yaffs_guts_initialise() done.");
+	return YAFFS_OK;
+}
+
+void yaffs_deinitialise(struct yaffs_dev *dev)
+{
+	if (dev->is_mounted) {
+		int i;
+
+		yaffs_deinit_blocks(dev);
+		yaffs_deinit_tnodes_and_objs(dev);
+		yaffs_summary_deinit(dev);
+
+		if (dev->param.n_caches > 0 && dev->cache) {
+
+			for (i = 0; i < dev->param.n_caches; i++) {
+				kfree(dev->cache[i].data);
+				dev->cache[i].data = NULL;
+			}
+
+			kfree(dev->cache);
+			dev->cache = NULL;
+		}
+
+		kfree(dev->gc_cleanup_list);
+
+		for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++)
+			kfree(dev->temp_buffer[i].buffer);
+
+		dev->is_mounted = 0;
+
+		yaffs_deinit_nand(dev);
+	}
+}
+
+int yaffs_count_free_chunks(struct yaffs_dev *dev)
+{
+	int n_free = 0;
+	int b;
+	struct yaffs_block_info *blk;
+
+	blk = dev->block_info;
+	for (b = dev->internal_start_block; b <= dev->internal_end_block; b++) {
+		switch (blk->block_state) {
+		case YAFFS_BLOCK_STATE_EMPTY:
+		case YAFFS_BLOCK_STATE_ALLOCATING:
+		case YAFFS_BLOCK_STATE_COLLECTING:
+		case YAFFS_BLOCK_STATE_FULL:
+			n_free +=
+			    (dev->param.chunks_per_block - blk->pages_in_use +
+			     blk->soft_del_pages);
+			break;
+		default:
+			break;
+		}
+		blk++;
+	}
+	return n_free;
+}
+
+int yaffs_get_n_free_chunks(struct yaffs_dev *dev)
+{
+	/* This is what we report to the outside world */
+	int n_free;
+	int n_dirty_caches;
+	int blocks_for_checkpt;
+	int i;
+
+	n_free = dev->n_free_chunks;
+	n_free += dev->n_deleted_files;
+
+	/* Now count and subtract the number of dirty chunks in the cache. */
+
+	for (n_dirty_caches = 0, i = 0; i < dev->param.n_caches; i++) {
+		if (dev->cache[i].dirty)
+			n_dirty_caches++;
+	}
+
+	n_free -= n_dirty_caches;
+
+	n_free -=
+	    ((dev->param.n_reserved_blocks + 1) * dev->param.chunks_per_block);
+
+	/* Now figure checkpoint space and report that... */
+	blocks_for_checkpt = yaffs_calc_checkpt_blocks_required(dev);
+
+	n_free -= (blocks_for_checkpt * dev->param.chunks_per_block);
+
+	if (n_free < 0)
+		n_free = 0;
+
+	return n_free;
+}
+
+
+int yaffs_format_dev(struct yaffs_dev *dev)
+{
+	int i;
+	enum yaffs_block_state state;
+	u32 dummy;
+
+	if(dev->is_mounted)
+		return YAFFS_FAIL;
+
+	/*
+	* The runtime variables might not have been set up,
+	* so set up what we need.
+	*/
+	dev->internal_start_block = dev->param.start_block;
+	dev->internal_end_block = dev->param.end_block;
+	dev->block_offset = 0;
+	dev->chunk_offset = 0;
+
+	if (dev->param.start_block == 0) {
+		dev->internal_start_block = dev->param.start_block + 1;
+		dev->internal_end_block = dev->param.end_block + 1;
+		dev->block_offset = 1;
+		dev->chunk_offset = dev->param.chunks_per_block;
+	}
+
+	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
+		yaffs_query_init_block_state(dev, i, &state, &dummy);
+		if (state != YAFFS_BLOCK_STATE_DEAD)
+			yaffs_erase_block(dev, i);
+	}
+
+	return YAFFS_OK;
+}
+
+
+/*
+ * Marshalling functions to get loff_t file sizes into and out of
+ * object headers.
+ */
+void yaffs_oh_size_load(struct yaffs_obj_hdr *oh, loff_t fsize)
+{
+	oh->file_size_low = (fsize & 0xFFFFFFFF);
+	oh->file_size_high = ((fsize >> 32) & 0xFFFFFFFF);
+}
+
+loff_t yaffs_oh_to_size(struct yaffs_obj_hdr *oh)
+{
+	loff_t retval;
+
+	if (sizeof(loff_t) >= 8 && ~(oh->file_size_high))
+		retval = (((loff_t) oh->file_size_high) << 32) |
+			(((loff_t) oh->file_size_low) & 0xFFFFFFFF);
+	else
+		retval = (loff_t) oh->file_size_low;
+
+	return retval;
+}
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_guts.h linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_guts.h
--- linux-3.0.8/fs/yaffs2/yaffs_guts.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_guts.h	2021-07-13 23:40:33.786357014 +0300
@@ -0,0 +1,990 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_GUTS_H__
+#define __YAFFS_GUTS_H__
+
+#include "yportenv.h"
+
+#define YAFFS_OK	1
+#define YAFFS_FAIL  0
+
+/* Give us a  Y=0x59,
+ * Give us an A=0x41,
+ * Give us an FF=0xff
+ * Give us an S=0x53
+ * And what have we got...
+ */
+#define YAFFS_MAGIC			0x5941ff53
+
+/*
+ * Tnodes form a tree with the tnodes in "levels"
+ * Levels greater than 0 hold 8 slots which point to other tnodes.
+ * Those at level 0 hold 16 slots which point to chunks in NAND.
+ *
+ * A maximum level of 8 thust supports files of size up to:
+ *
+ * 2^(3*MAX_LEVEL+4)
+ *
+ * Thus a max level of 8 supports files with up to 2^^28 chunks which gives
+ * a maximum file size of around 512Gbytees with 2k chunks.
+ */
+#define YAFFS_NTNODES_LEVEL0		16
+#define YAFFS_TNODES_LEVEL0_BITS	4
+#define YAFFS_TNODES_LEVEL0_MASK	0xf
+
+#define YAFFS_NTNODES_INTERNAL		(YAFFS_NTNODES_LEVEL0 / 2)
+#define YAFFS_TNODES_INTERNAL_BITS	(YAFFS_TNODES_LEVEL0_BITS - 1)
+#define YAFFS_TNODES_INTERNAL_MASK	0x7
+#define YAFFS_TNODES_MAX_LEVEL		8
+#define YAFFS_TNODES_MAX_BITS		(YAFFS_TNODES_LEVEL0_BITS + \
+					YAFFS_TNODES_INTERNAL_BITS * \
+					YAFFS_TNODES_MAX_LEVEL)
+#define YAFFS_MAX_CHUNK_ID		((1 << YAFFS_TNODES_MAX_BITS) - 1)
+
+#define YAFFS_MAX_FILE_SIZE_32		0x7fffffff
+
+/* Constants for YAFFS1 mode */
+#define YAFFS_BYTES_PER_SPARE		16
+#define YAFFS_BYTES_PER_CHUNK		512
+#define YAFFS_CHUNK_SIZE_SHIFT		9
+#define YAFFS_CHUNKS_PER_BLOCK		32
+#define YAFFS_BYTES_PER_BLOCK	(YAFFS_CHUNKS_PER_BLOCK*YAFFS_BYTES_PER_CHUNK)
+
+#define YAFFS_MIN_YAFFS2_CHUNK_SIZE	1024
+#define YAFFS_MIN_YAFFS2_SPARE_SIZE	32
+
+
+
+#define YAFFS_ALLOCATION_NOBJECTS	100
+#define YAFFS_ALLOCATION_NTNODES	100
+#define YAFFS_ALLOCATION_NLINKS		100
+
+#define YAFFS_NOBJECT_BUCKETS		256
+
+#define YAFFS_OBJECT_SPACE		0x40000
+#define YAFFS_MAX_OBJECT_ID		(YAFFS_OBJECT_SPACE - 1)
+
+/* Binary data version stamps */
+#define YAFFS_SUMMARY_VERSION		1
+#define YAFFS_CHECKPOINT_VERSION	7
+
+#ifdef CONFIG_YAFFS_UNICODE
+#define YAFFS_MAX_NAME_LENGTH		127
+#define YAFFS_MAX_ALIAS_LENGTH		79
+#else
+#define YAFFS_MAX_NAME_LENGTH		255
+#define YAFFS_MAX_ALIAS_LENGTH		159
+#endif
+
+#define YAFFS_SHORT_NAME_LENGTH		15
+
+/* Some special object ids for pseudo objects */
+#define YAFFS_OBJECTID_ROOT		1
+#define YAFFS_OBJECTID_LOSTNFOUND	2
+#define YAFFS_OBJECTID_UNLINKED		3
+#define YAFFS_OBJECTID_DELETED		4
+
+/* Fake object Id for summary data */
+#define YAFFS_OBJECTID_SUMMARY		0x10
+
+/* Pseudo object ids for checkpointing */
+#define YAFFS_OBJECTID_CHECKPOINT_DATA	0x20
+#define YAFFS_SEQUENCE_CHECKPOINT_DATA	0x21
+
+#define YAFFS_MAX_SHORT_OP_CACHES	20
+
+#define YAFFS_N_TEMP_BUFFERS		6
+
+/* We limit the number attempts at sucessfully saving a chunk of data.
+ * Small-page devices have 32 pages per block; large-page devices have 64.
+ * Default to something in the order of 5 to 10 blocks worth of chunks.
+ */
+#define YAFFS_WR_ATTEMPTS		(5*64)
+
+/* Sequence numbers are used in YAFFS2 to determine block allocation order.
+ * The range is limited slightly to help distinguish bad numbers from good.
+ * This also allows us to perhaps in the future use special numbers for
+ * special purposes.
+ * EFFFFF00 allows the allocation of 8 blocks/second (~1Mbytes) for 15 years,
+ * and is a larger number than the lifetime of a 2GB device.
+ */
+#define YAFFS_LOWEST_SEQUENCE_NUMBER	0x00001000
+#define YAFFS_HIGHEST_SEQUENCE_NUMBER	0xefffff00
+
+/* Special sequence number for bad block that failed to be marked bad */
+#define YAFFS_SEQUENCE_BAD_BLOCK	0xffff0000
+
+/* ChunkCache is used for short read/write operations.*/
+struct yaffs_cache {
+	struct yaffs_obj *object;
+	int chunk_id;
+	int last_use;
+	int dirty;
+	int n_bytes;		/* Only valid if the cache is dirty */
+	int locked;		/* Can't push out or flush while locked. */
+	u8 *data;
+};
+
+/* yaffs1 tags structures in RAM
+ * NB This uses bitfield. Bitfields should not straddle a u32 boundary
+ * otherwise the structure size will get blown out.
+ */
+
+struct yaffs_tags {
+	unsigned chunk_id:20;
+	unsigned serial_number:2;
+	unsigned n_bytes_lsb:10;
+	unsigned obj_id:18;
+	unsigned ecc:12;
+	unsigned n_bytes_msb:2;
+};
+
+union yaffs_tags_union {
+	struct yaffs_tags as_tags;
+	u8 as_bytes[8];
+};
+
+
+/* Stuff used for extended tags in YAFFS2 */
+
+enum yaffs_ecc_result {
+	YAFFS_ECC_RESULT_UNKNOWN,
+	YAFFS_ECC_RESULT_NO_ERROR,
+	YAFFS_ECC_RESULT_FIXED,
+	YAFFS_ECC_RESULT_UNFIXED
+};
+
+enum yaffs_obj_type {
+	YAFFS_OBJECT_TYPE_UNKNOWN,
+	YAFFS_OBJECT_TYPE_FILE,
+	YAFFS_OBJECT_TYPE_SYMLINK,
+	YAFFS_OBJECT_TYPE_DIRECTORY,
+	YAFFS_OBJECT_TYPE_HARDLINK,
+	YAFFS_OBJECT_TYPE_SPECIAL
+};
+
+#define YAFFS_OBJECT_TYPE_MAX YAFFS_OBJECT_TYPE_SPECIAL
+
+struct yaffs_ext_tags {
+	unsigned chunk_used;	/*  Status of the chunk: used or unused */
+	unsigned obj_id;	/* If 0 this is not used */
+	unsigned chunk_id;	/* If 0 this is a header, else a data chunk */
+	unsigned n_bytes;	/* Only valid for data chunks */
+
+	/* The following stuff only has meaning when we read */
+	enum yaffs_ecc_result ecc_result;
+	unsigned block_bad;
+
+	/* YAFFS 1 stuff */
+	unsigned is_deleted;	/* The chunk is marked deleted */
+	unsigned serial_number;	/* Yaffs1 2-bit serial number */
+
+	/* YAFFS2 stuff */
+	unsigned seq_number;	/* The sequence number of this block */
+
+	/* Extra info if this is an object header (YAFFS2 only) */
+
+	unsigned extra_available;	/* Extra info available if not zero */
+	unsigned extra_parent_id;	/* The parent object */
+	unsigned extra_is_shrink;	/* Is it a shrink header? */
+	unsigned extra_shadows;	/* Does this shadow another object? */
+
+	enum yaffs_obj_type extra_obj_type;	/* What object type? */
+
+	loff_t extra_file_size;		/* Length if it is a file */
+	unsigned extra_equiv_id;	/* Equivalent object for a hard link */
+};
+
+/* Spare structure for YAFFS1 */
+struct yaffs_spare {
+	u8 tb0;
+	u8 tb1;
+	u8 tb2;
+	u8 tb3;
+	u8 page_status;		/* set to 0 to delete the chunk */
+	u8 block_status;
+	u8 tb4;
+	u8 tb5;
+	u8 ecc1[3];
+	u8 tb6;
+	u8 tb7;
+	u8 ecc2[3];
+};
+
+/*Special structure for passing through to mtd */
+struct yaffs_nand_spare {
+	struct yaffs_spare spare;
+	int eccres1;
+	int eccres2;
+};
+
+/* Block data in RAM */
+
+enum yaffs_block_state {
+	YAFFS_BLOCK_STATE_UNKNOWN = 0,
+
+	YAFFS_BLOCK_STATE_SCANNING,
+	/* Being scanned */
+
+	YAFFS_BLOCK_STATE_NEEDS_SCAN,
+	/* The block might have something on it (ie it is allocating or full,
+	 * perhaps empty) but it needs to be scanned to determine its true
+	 * state.
+	 * This state is only valid during scanning.
+	 * NB We tolerate empty because the pre-scanner might be incapable of
+	 * deciding
+	 * However, if this state is returned on a YAFFS2 device,
+	 * then we expect a sequence number
+	 */
+
+	YAFFS_BLOCK_STATE_EMPTY,
+	/* This block is empty */
+
+	YAFFS_BLOCK_STATE_ALLOCATING,
+	/* This block is partially allocated.
+	 * At least one page holds valid data.
+	 * This is the one currently being used for page
+	 * allocation. Should never be more than one of these.
+	 * If a block is only partially allocated at mount it is treated as
+	 * full.
+	 */
+
+	YAFFS_BLOCK_STATE_FULL,
+	/* All the pages in this block have been allocated.
+	 * If a block was only partially allocated when mounted we treat
+	 * it as fully allocated.
+	 */
+
+	YAFFS_BLOCK_STATE_DIRTY,
+	/* The block was full and now all chunks have been deleted.
+	 * Erase me, reuse me.
+	 */
+
+	YAFFS_BLOCK_STATE_CHECKPOINT,
+	/* This block is assigned to holding checkpoint data. */
+
+	YAFFS_BLOCK_STATE_COLLECTING,
+	/* This block is being garbage collected */
+
+	YAFFS_BLOCK_STATE_DEAD
+	    /* This block has failed and is not in use */
+};
+
+#define	YAFFS_NUMBER_OF_BLOCK_STATES (YAFFS_BLOCK_STATE_DEAD + 1)
+
+struct yaffs_block_info {
+
+	int soft_del_pages:10;	/* number of soft deleted pages */
+	int pages_in_use:10;	/* number of pages in use */
+	unsigned block_state:4;	/* One of the above block states. */
+				/* NB use unsigned because enum is sometimes
+				 * an int */
+	u32 needs_retiring:1;	/* Data has failed on this block, */
+				/*need to get valid data off and retire*/
+	u32 skip_erased_check:1;/* Skip the erased check on this block */
+	u32 gc_prioritise:1;	/* An ECC check or blank check has failed.
+				   Block should be prioritised for GC */
+	u32 chunk_error_strikes:3;	/* How many times we've had ecc etc
+				failures on this block and tried to reuse it */
+	u32 has_summary:1;	/* The block has a summary */
+
+	u32 has_shrink_hdr:1;	/* This block has at least one shrink header */
+	u32 seq_number;		/* block sequence number for yaffs2 */
+
+};
+
+/* -------------------------- Object structure -------------------------------*/
+/* This is the object structure as stored on NAND */
+
+struct yaffs_obj_hdr {
+	enum yaffs_obj_type type;
+
+	/* Apply to everything  */
+	int parent_obj_id;
+	u16 sum_no_longer_used;	/* checksum of name. No longer used */
+	YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];
+
+	/* The following apply to all object types except for hard links */
+	u32 yst_mode;		/* protection */
+
+	u32 yst_uid;
+	u32 yst_gid;
+	u32 yst_atime;
+	u32 yst_mtime;
+	u32 yst_ctime;
+
+	/* File size  applies to files only */
+	u32 file_size_low;
+
+	/* Equivalent object id applies to hard links only. */
+	int equiv_id;
+
+	/* Alias is for symlinks only. */
+	YCHAR alias[YAFFS_MAX_ALIAS_LENGTH + 1];
+
+	u32 yst_rdev;	/* stuff for block and char devices (major/min) */
+
+	u32 win_ctime[2];
+	u32 win_atime[2];
+	u32 win_mtime[2];
+
+	u32 inband_shadowed_obj_id;
+	u32 inband_is_shrink;
+
+	u32 file_size_high;
+	u32 reserved[1];
+	int shadows_obj;	/* This object header shadows the
+				specified object if > 0 */
+
+	/* is_shrink applies to object headers written when wemake a hole. */
+	u32 is_shrink;
+
+};
+
+/*--------------------------- Tnode -------------------------- */
+
+struct yaffs_tnode {
+	struct yaffs_tnode *internal[YAFFS_NTNODES_INTERNAL];
+};
+
+/*------------------------  Object -----------------------------*/
+/* An object can be one of:
+ * - a directory (no data, has children links
+ * - a regular file (data.... not prunes :->).
+ * - a symlink [symbolic link] (the alias).
+ * - a hard link
+ */
+
+struct yaffs_file_var {
+	loff_t file_size;
+	loff_t scanned_size;
+	loff_t shrink_size;
+	int top_level;
+	struct yaffs_tnode *top;
+};
+
+struct yaffs_dir_var {
+	struct list_head children;	/* list of child links */
+	struct list_head dirty;	/* Entry for list of dirty directories */
+};
+
+struct yaffs_symlink_var {
+	YCHAR *alias;
+};
+
+struct yaffs_hardlink_var {
+	struct yaffs_obj *equiv_obj;
+	u32 equiv_id;
+};
+
+union yaffs_obj_var {
+	struct yaffs_file_var file_variant;
+	struct yaffs_dir_var dir_variant;
+	struct yaffs_symlink_var symlink_variant;
+	struct yaffs_hardlink_var hardlink_variant;
+};
+
+struct yaffs_obj {
+	u8 deleted:1;		/* This should only apply to unlinked files. */
+	u8 soft_del:1;		/* it has also been soft deleted */
+	u8 unlinked:1;		/* An unlinked file.*/
+	u8 fake:1;		/* A fake object has no presence on NAND. */
+	u8 rename_allowed:1;	/* Some objects cannot be renamed. */
+	u8 unlink_allowed:1;
+	u8 dirty:1;		/* the object needs to be written to flash */
+	u8 valid:1;		/* When the file system is being loaded up, this
+				 * object might be created before the data
+				 * is available
+				 * ie. file data chunks encountered before
+				* the header.
+				 */
+	u8 lazy_loaded:1;	/* This object has been lazy loaded and
+				 * is missing some detail */
+
+	u8 defered_free:1;	/* Object is removed from NAND, but is
+				 * still in the inode cache.
+				 * Free of object is defered.
+				 * until the inode is released.
+				 */
+	u8 being_created:1;	/* This object is still being created
+				 * so skip some verification checks. */
+	u8 is_shadowed:1;	/* This object is shadowed on the way
+				 * to being renamed. */
+
+	u8 xattr_known:1;	/* We know if this has object has xattribs
+				 * or not. */
+	u8 has_xattr:1;		/* This object has xattribs.
+				 * Only valid if xattr_known. */
+
+	u8 serial;		/* serial number of chunk in NAND.*/
+	u16 sum;		/* sum of the name to speed searching */
+
+	struct yaffs_dev *my_dev;	/* The device I'm on */
+
+	struct list_head hash_link;	/* list of objects in hash bucket */
+
+	struct list_head hard_links;	/* hard linked object chain*/
+
+	/* directory structure stuff */
+	/* also used for linking up the free list */
+	struct yaffs_obj *parent;
+	struct list_head siblings;
+
+	/* Where's my object header in NAND? */
+	int hdr_chunk;
+
+	int n_data_chunks;	/* Number of data chunks for this file. */
+
+	u32 obj_id;		/* the object id value */
+
+	u32 yst_mode;
+
+	YCHAR short_name[YAFFS_SHORT_NAME_LENGTH + 1];
+
+#ifdef CONFIG_YAFFS_WINCE
+	u32 win_ctime[2];
+	u32 win_mtime[2];
+	u32 win_atime[2];
+#else
+	u32 yst_uid;
+	u32 yst_gid;
+	u32 yst_atime;
+	u32 yst_mtime;
+	u32 yst_ctime;
+#endif
+
+	u32 yst_rdev;
+
+	void *my_inode;
+
+	enum yaffs_obj_type variant_type;
+
+	union yaffs_obj_var variant;
+
+};
+
+struct yaffs_obj_bucket {
+	struct list_head list;
+	int count;
+};
+
+/* yaffs_checkpt_obj holds the definition of an object as dumped
+ * by checkpointing.
+ */
+
+struct yaffs_checkpt_obj {
+	int struct_type;
+	u32 obj_id;
+	u32 parent_id;
+	int hdr_chunk;
+	enum yaffs_obj_type variant_type:3;
+	u8 deleted:1;
+	u8 soft_del:1;
+	u8 unlinked:1;
+	u8 fake:1;
+	u8 rename_allowed:1;
+	u8 unlink_allowed:1;
+	u8 serial;
+	int n_data_chunks;
+	loff_t size_or_equiv_obj;
+};
+
+/*--------------------- Temporary buffers ----------------
+ *
+ * These are chunk-sized working buffers. Each device has a few.
+ */
+
+struct yaffs_buffer {
+	u8 *buffer;
+	int in_use;
+};
+
+/*----------------- Device ---------------------------------*/
+
+struct yaffs_param {
+	const YCHAR *name;
+
+	/*
+	 * Entry parameters set up way early. Yaffs sets up the rest.
+	 * The structure should be zeroed out before use so that unused
+	 * and default values are zero.
+	 */
+
+	int inband_tags;	/* Use unband tags */
+	u32 total_bytes_per_chunk;	/* Should be >= 512, does not need to
+					 be a power of 2 */
+	int chunks_per_block;	/* does not need to be a power of 2 */
+	int spare_bytes_per_chunk;	/* spare area size */
+	int start_block;	/* Start block we're allowed to use */
+	int end_block;		/* End block we're allowed to use */
+	int n_reserved_blocks;	/* Tuneable so that we can reduce
+				 * reserved blocks on NOR and RAM. */
+
+	int n_caches;		/* If <= 0, then short op caching is disabled,
+				 * else the number of short op caches.
+				 */
+	int cache_bypass_aligned; /* If non-zero then bypass the cache for
+				   * aligned writes.
+				   */
+
+	int use_nand_ecc;	/* Flag to decide whether or not to use
+				 * NAND driver ECC on data (yaffs1) */
+	int tags_9bytes;	/* Use 9 byte tags */
+	int no_tags_ecc;	/* Flag to decide whether or not to do ECC
+				 * on packed tags (yaffs2) */
+
+	int is_yaffs2;		/* Use yaffs2 mode on this device */
+
+	int empty_lost_n_found;	/* Auto-empty lost+found directory on mount */
+
+	int refresh_period;	/* How often to check for a block refresh */
+
+	/* Checkpoint control. Can be set before or after initialisation */
+	u8 skip_checkpt_rd;
+	u8 skip_checkpt_wr;
+
+	int enable_xattr;	/* Enable xattribs */
+
+	int max_objects;	/*
+				 * Set to limit the number of objects created.
+				 * 0 = no limit.
+				*/
+
+	/* The remove_obj_fn function must be supplied by OS flavours that
+	 * need it.
+	 * yaffs direct uses it to implement the faster readdir.
+	 * Linux uses it to protect the directory during unlocking.
+	 */
+	void (*remove_obj_fn) (struct yaffs_obj *obj);
+
+	/* Callback to mark the superblock dirty */
+	void (*sb_dirty_fn) (struct yaffs_dev *dev);
+
+	/*  Callback to control garbage collection. */
+	unsigned (*gc_control_fn) (struct yaffs_dev *dev);
+
+	/* Debug control flags. Don't use unless you know what you're doing */
+	int use_header_file_size;	/* Flag to determine if we should use
+					 * file sizes from the header */
+	int disable_lazy_load;	/* Disable lazy loading on this device */
+	int wide_tnodes_disabled;	/* Set to disable wide tnodes */
+	int disable_soft_del;	/* yaffs 1 only: Set to disable the use of
+				 * softdeletion. */
+
+	int defered_dir_update;	/* Set to defer directory updates */
+
+#ifdef CONFIG_YAFFS_AUTO_UNICODE
+	int auto_unicode;
+#endif
+	int always_check_erased;	/* Force chunk erased check always on */
+
+	int disable_summary;
+
+};
+
+struct yaffs_driver {
+	int (*drv_write_chunk_fn) (struct yaffs_dev *dev, int nand_chunk,
+				   const u8 *data, int data_len,
+				   const u8 *oob, int oob_len);
+	int (*drv_read_chunk_fn) (struct yaffs_dev *dev, int nand_chunk,
+				   u8 *data, int data_len,
+				   u8 *oob, int oob_len,
+				   enum yaffs_ecc_result *ecc_result);
+	int (*drv_erase_fn) (struct yaffs_dev *dev, int block_no);
+	int (*drv_mark_bad_fn) (struct yaffs_dev *dev, int block_no);
+	int (*drv_check_bad_fn) (struct yaffs_dev *dev, int block_no);
+	int (*drv_initialise_fn) (struct yaffs_dev *dev);
+	int (*drv_deinitialise_fn) (struct yaffs_dev *dev);
+};
+
+struct yaffs_tags_handler {
+	int (*write_chunk_tags_fn) (struct yaffs_dev *dev,
+				    int nand_chunk, const u8 *data,
+				    const struct yaffs_ext_tags *tags);
+	int (*read_chunk_tags_fn) (struct yaffs_dev *dev,
+				   int nand_chunk, u8 *data,
+				   struct yaffs_ext_tags *tags);
+
+	int (*query_block_fn) (struct yaffs_dev *dev, int block_no,
+			       enum yaffs_block_state *state,
+			       u32 *seq_number);
+	int (*mark_bad_fn) (struct yaffs_dev *dev, int block_no);
+};
+
+struct yaffs_dev {
+	struct yaffs_param param;
+	struct yaffs_driver drv;
+	struct yaffs_tags_handler tagger;
+
+	/* Context storage. Holds extra OS specific data for this device */
+
+	void *os_context;
+	void *driver_context;
+
+	struct list_head dev_list;
+
+	/* Runtime parameters. Set up by YAFFS. */
+	int data_bytes_per_chunk;
+
+	/* Non-wide tnode stuff */
+	u16 chunk_grp_bits;	/* Number of bits that need to be resolved if
+				 * the tnodes are not wide enough.
+				 */
+	u16 chunk_grp_size;	/* == 2^^chunk_grp_bits */
+
+	/* Stuff to support wide tnodes */
+	u32 tnode_width;
+	u32 tnode_mask;
+	u32 tnode_size;
+
+	/* Stuff for figuring out file offset to chunk conversions */
+	u32 chunk_shift;	/* Shift value */
+	u32 chunk_div;		/* Divisor after shifting: 1 for 2^n sizes */
+	u32 chunk_mask;		/* Mask to use for power-of-2 case */
+
+	int is_mounted;
+	int read_only;
+	int is_checkpointed;
+
+	/* Stuff to support block offsetting to support start block zero */
+	int internal_start_block;
+	int internal_end_block;
+	int block_offset;
+	int chunk_offset;
+
+	/* Runtime checkpointing stuff */
+	int checkpt_page_seq;	/* running sequence number of checkpt pages */
+	int checkpt_byte_count;
+	int checkpt_byte_offs;
+	u8 *checkpt_buffer;
+	int checkpt_open_write;
+	int blocks_in_checkpt;
+	int checkpt_cur_chunk;
+	int checkpt_cur_block;
+	int checkpt_next_block;
+	int *checkpt_block_list;
+	int checkpt_max_blocks;
+	u32 checkpt_sum;
+	u32 checkpt_xor;
+
+	int checkpoint_blocks_required;	/* Number of blocks needed to store
+					 * current checkpoint set */
+
+	/* Block Info */
+	struct yaffs_block_info *block_info;
+	u8 *chunk_bits;		/* bitmap of chunks in use */
+	unsigned block_info_alt:1;	/* allocated using alternative alloc */
+	unsigned chunk_bits_alt:1;	/* allocated using alternative alloc */
+	int chunk_bit_stride;	/* Number of bytes of chunk_bits per block.
+				 * Must be consistent with chunks_per_block.
+				 */
+
+	int n_erased_blocks;
+	int alloc_block;	/* Current block being allocated off */
+	u32 alloc_page;
+	int alloc_block_finder;	/* Used to search for next allocation block */
+
+	/* Object and Tnode memory management */
+	void *allocator;
+	int n_obj;
+	int n_tnodes;
+
+	int n_hardlinks;
+
+	struct yaffs_obj_bucket obj_bucket[YAFFS_NOBJECT_BUCKETS];
+	u32 bucket_finder;
+
+	int n_free_chunks;
+
+	/* Garbage collection control */
+	u32 *gc_cleanup_list;	/* objects to delete at the end of a GC. */
+	u32 n_clean_ups;
+
+	unsigned has_pending_prioritised_gc;	/* We think this device might
+						have pending prioritised gcs */
+	unsigned gc_disable;
+	unsigned gc_block_finder;
+	unsigned gc_dirtiest;
+	unsigned gc_pages_in_use;
+	unsigned gc_not_done;
+	unsigned gc_block;
+	unsigned gc_chunk;
+	unsigned gc_skip;
+	struct yaffs_summary_tags *gc_sum_tags;
+
+	/* Special directories */
+	struct yaffs_obj *root_dir;
+	struct yaffs_obj *lost_n_found;
+
+	int buffered_block;	/* Which block is buffered here? */
+	int doing_buffered_block_rewrite;
+
+	struct yaffs_cache *cache;
+	int cache_last_use;
+
+	/* Stuff for background deletion and unlinked files. */
+	struct yaffs_obj *unlinked_dir;	/* Directory where unlinked and deleted
+					 files live. */
+	struct yaffs_obj *del_dir;	/* Directory where deleted objects are
+					sent to disappear. */
+	struct yaffs_obj *unlinked_deletion;	/* Current file being
+							background deleted. */
+	int n_deleted_files;	/* Count of files awaiting deletion; */
+	int n_unlinked_files;	/* Count of unlinked files. */
+	int n_bg_deletions;	/* Count of background deletions. */
+
+	/* Temporary buffer management */
+	struct yaffs_buffer temp_buffer[YAFFS_N_TEMP_BUFFERS];
+	int max_temp;
+	int temp_in_use;
+	int unmanaged_buffer_allocs;
+	int unmanaged_buffer_deallocs;
+
+	/* yaffs2 runtime stuff */
+	unsigned seq_number;	/* Sequence number of currently
+					allocating block */
+	unsigned oldest_dirty_seq;
+	unsigned oldest_dirty_block;
+
+	/* Block refreshing */
+	int refresh_skip;	/* A skip down counter.
+				 * Refresh happens when this gets to zero. */
+
+	/* Dirty directory handling */
+	struct list_head dirty_dirs;	/* List of dirty directories */
+
+	/* Summary */
+	int chunks_per_summary;
+	struct yaffs_summary_tags *sum_tags;
+
+	/* Statistics */
+	u32 n_page_writes;
+	u32 n_page_reads;
+	u32 n_erasures;
+	u32 n_bad_markings;
+	u32 n_erase_failures;
+	u32 n_gc_copies;
+	u32 all_gcs;
+	u32 passive_gc_count;
+	u32 oldest_dirty_gc_count;
+	u32 n_gc_blocks;
+	u32 bg_gcs;
+	u32 n_retried_writes;
+	u32 n_retired_blocks;
+	u32 n_ecc_fixed;
+	u32 n_ecc_unfixed;
+	u32 n_tags_ecc_fixed;
+	u32 n_tags_ecc_unfixed;
+	u32 n_deletions;
+	u32 n_unmarked_deletions;
+	u32 refresh_count;
+	u32 cache_hits;
+	u32 tags_used;
+	u32 summary_used;
+
+};
+
+/* The CheckpointDevice structure holds the device information that changes
+ *at runtime and must be preserved over unmount/mount cycles.
+ */
+struct yaffs_checkpt_dev {
+	int struct_type;
+	int n_erased_blocks;
+	int alloc_block;	/* Current block being allocated off */
+	u32 alloc_page;
+	int n_free_chunks;
+
+	int n_deleted_files;	/* Count of files awaiting deletion; */
+	int n_unlinked_files;	/* Count of unlinked files. */
+	int n_bg_deletions;	/* Count of background deletions. */
+
+	/* yaffs2 runtime stuff */
+	unsigned seq_number;	/* Sequence number of currently
+				 * allocating block */
+
+};
+
+struct yaffs_checkpt_validity {
+	int struct_type;
+	u32 magic;
+	u32 version;
+	u32 head;
+};
+
+struct yaffs_shadow_fixer {
+	int obj_id;
+	int shadowed_id;
+	struct yaffs_shadow_fixer *next;
+};
+
+/* Structure for doing xattr modifications */
+struct yaffs_xattr_mod {
+	int set;		/* If 0 then this is a deletion */
+	const YCHAR *name;
+	const void *data;
+	int size;
+	int flags;
+	int result;
+};
+
+/*----------------------- YAFFS Functions -----------------------*/
+
+int yaffs_guts_initialise(struct yaffs_dev *dev);
+void yaffs_deinitialise(struct yaffs_dev *dev);
+
+int yaffs_get_n_free_chunks(struct yaffs_dev *dev);
+
+int yaffs_rename_obj(struct yaffs_obj *old_dir, const YCHAR * old_name,
+		     struct yaffs_obj *new_dir, const YCHAR * new_name);
+
+int yaffs_unlinker(struct yaffs_obj *dir, const YCHAR * name);
+int yaffs_del_obj(struct yaffs_obj *obj);
+
+int yaffs_get_obj_name(struct yaffs_obj *obj, YCHAR * name, int buffer_size);
+loff_t yaffs_get_obj_length(struct yaffs_obj *obj);
+int yaffs_get_obj_inode(struct yaffs_obj *obj);
+unsigned yaffs_get_obj_type(struct yaffs_obj *obj);
+int yaffs_get_obj_link_count(struct yaffs_obj *obj);
+
+/* File operations */
+int yaffs_file_rd(struct yaffs_obj *obj, u8 * buffer, loff_t offset,
+		  int n_bytes);
+int yaffs_wr_file(struct yaffs_obj *obj, const u8 * buffer, loff_t offset,
+		  int n_bytes, int write_trhrough);
+int yaffs_resize_file(struct yaffs_obj *obj, loff_t new_size);
+
+struct yaffs_obj *yaffs_create_file(struct yaffs_obj *parent,
+				    const YCHAR *name, u32 mode, u32 uid,
+				    u32 gid);
+
+int yaffs_flush_file(struct yaffs_obj *obj, int update_time, int data_sync);
+
+/* Flushing and checkpointing */
+void yaffs_flush_whole_cache(struct yaffs_dev *dev);
+
+int yaffs_checkpoint_save(struct yaffs_dev *dev);
+int yaffs_checkpoint_restore(struct yaffs_dev *dev);
+
+/* Directory operations */
+struct yaffs_obj *yaffs_create_dir(struct yaffs_obj *parent, const YCHAR *name,
+				   u32 mode, u32 uid, u32 gid);
+struct yaffs_obj *yaffs_find_by_name(struct yaffs_obj *the_dir,
+				     const YCHAR *name);
+struct yaffs_obj *yaffs_find_by_number(struct yaffs_dev *dev, u32 number);
+
+/* Link operations */
+struct yaffs_obj *yaffs_link_obj(struct yaffs_obj *parent, const YCHAR *name,
+				 struct yaffs_obj *equiv_obj);
+
+struct yaffs_obj *yaffs_get_equivalent_obj(struct yaffs_obj *obj);
+
+/* Symlink operations */
+struct yaffs_obj *yaffs_create_symlink(struct yaffs_obj *parent,
+				       const YCHAR *name, u32 mode, u32 uid,
+				       u32 gid, const YCHAR *alias);
+YCHAR *yaffs_get_symlink_alias(struct yaffs_obj *obj);
+
+/* Special inodes (fifos, sockets and devices) */
+struct yaffs_obj *yaffs_create_special(struct yaffs_obj *parent,
+				       const YCHAR *name, u32 mode, u32 uid,
+				       u32 gid, u32 rdev);
+
+int yaffs_set_xattrib(struct yaffs_obj *obj, const YCHAR *name,
+		      const void *value, int size, int flags);
+int yaffs_get_xattrib(struct yaffs_obj *obj, const YCHAR *name, void *value,
+		      int size);
+int yaffs_list_xattrib(struct yaffs_obj *obj, char *buffer, int size);
+int yaffs_remove_xattrib(struct yaffs_obj *obj, const YCHAR *name);
+
+/* Special directories */
+struct yaffs_obj *yaffs_root(struct yaffs_dev *dev);
+struct yaffs_obj *yaffs_lost_n_found(struct yaffs_dev *dev);
+
+void yaffs_handle_defered_free(struct yaffs_obj *obj);
+
+void yaffs_update_dirty_dirs(struct yaffs_dev *dev);
+
+int yaffs_bg_gc(struct yaffs_dev *dev, unsigned urgency);
+
+/* Debug dump  */
+int yaffs_dump_obj(struct yaffs_obj *obj);
+
+void yaffs_guts_test(struct yaffs_dev *dev);
+
+/* A few useful functions to be used within the core files*/
+void yaffs_chunk_del(struct yaffs_dev *dev, int chunk_id, int mark_flash,
+		     int lyn);
+int yaffs_check_ff(u8 *buffer, int n_bytes);
+void yaffs_handle_chunk_error(struct yaffs_dev *dev,
+			      struct yaffs_block_info *bi);
+
+u8 *yaffs_get_temp_buffer(struct yaffs_dev *dev);
+void yaffs_release_temp_buffer(struct yaffs_dev *dev, u8 *buffer);
+
+struct yaffs_obj *yaffs_find_or_create_by_number(struct yaffs_dev *dev,
+						 int number,
+						 enum yaffs_obj_type type);
+int yaffs_put_chunk_in_file(struct yaffs_obj *in, int inode_chunk,
+			    int nand_chunk, int in_scan);
+void yaffs_set_obj_name(struct yaffs_obj *obj, const YCHAR *name);
+void yaffs_set_obj_name_from_oh(struct yaffs_obj *obj,
+				const struct yaffs_obj_hdr *oh);
+void yaffs_add_obj_to_dir(struct yaffs_obj *directory, struct yaffs_obj *obj);
+YCHAR *yaffs_clone_str(const YCHAR *str);
+void yaffs_link_fixup(struct yaffs_dev *dev, struct list_head *hard_list);
+void yaffs_block_became_dirty(struct yaffs_dev *dev, int block_no);
+int yaffs_update_oh(struct yaffs_obj *in, const YCHAR *name,
+		    int force, int is_shrink, int shadows,
+		    struct yaffs_xattr_mod *xop);
+void yaffs_handle_shadowed_obj(struct yaffs_dev *dev, int obj_id,
+			       int backward_scanning);
+int yaffs_check_alloc_available(struct yaffs_dev *dev, int n_chunks);
+struct yaffs_tnode *yaffs_get_tnode(struct yaffs_dev *dev);
+struct yaffs_tnode *yaffs_add_find_tnode_0(struct yaffs_dev *dev,
+					   struct yaffs_file_var *file_struct,
+					   u32 chunk_id,
+					   struct yaffs_tnode *passed_tn);
+
+int yaffs_do_file_wr(struct yaffs_obj *in, const u8 *buffer, loff_t offset,
+		     int n_bytes, int write_trhrough);
+void yaffs_resize_file_down(struct yaffs_obj *obj, loff_t new_size);
+void yaffs_skip_rest_of_block(struct yaffs_dev *dev);
+
+int yaffs_count_free_chunks(struct yaffs_dev *dev);
+
+struct yaffs_tnode *yaffs_find_tnode_0(struct yaffs_dev *dev,
+				       struct yaffs_file_var *file_struct,
+				       u32 chunk_id);
+
+u32 yaffs_get_group_base(struct yaffs_dev *dev, struct yaffs_tnode *tn,
+			 unsigned pos);
+
+int yaffs_is_non_empty_dir(struct yaffs_obj *obj);
+
+int yaffs_format_dev(struct yaffs_dev *dev);
+
+void yaffs_addr_to_chunk(struct yaffs_dev *dev, loff_t addr,
+				int *chunk_out, u32 *offset_out);
+/*
+ * Marshalling functions to get loff_t file sizes into aand out of
+ * object headers.
+ */
+void yaffs_oh_size_load(struct yaffs_obj_hdr *oh, loff_t fsize);
+loff_t yaffs_oh_to_size(struct yaffs_obj_hdr *oh);
+loff_t yaffs_max_file_size(struct yaffs_dev *dev);
+
+
+#endif
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_linux.h linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_linux.h
--- linux-3.0.8/fs/yaffs2/yaffs_linux.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_linux.h	2021-07-13 23:40:33.782356989 +0300
@@ -0,0 +1,48 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_LINUX_H__
+#define __YAFFS_LINUX_H__
+
+#include "yportenv.h"
+
+struct yaffs_linux_context {
+	struct list_head context_list;	/* List of these we have mounted */
+	struct yaffs_dev *dev;
+	struct super_block *super;
+	struct task_struct *bg_thread;	/* Background thread for this device */
+	int bg_running;
+	struct mutex gross_lock;	/* Gross locking mutex*/
+	u8 *spare_buffer;	/* For mtdif2 use. Don't know the buffer size
+				 * at compile time so we have to allocate it.
+				 */
+	struct list_head search_contexts;
+	struct task_struct *readdir_process;
+	unsigned mount_id;
+	int dirty;
+};
+
+#define yaffs_dev_to_lc(dev) ((struct yaffs_linux_context *)((dev)->os_context))
+#define yaffs_dev_to_mtd(dev) ((struct mtd_info *)((dev)->driver_context))
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+#define WRITE_SIZE_STR "writesize"
+#define WRITE_SIZE(mtd) ((mtd)->writesize)
+#else
+#define WRITE_SIZE_STR "oobblock"
+#define WRITE_SIZE(mtd) ((mtd)->oobblock)
+#endif
+
+#endif
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_mtdif.c linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_mtdif.c
--- linux-3.0.8/fs/yaffs2/yaffs_mtdif.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_mtdif.c	2021-07-13 23:40:33.782356989 +0300
@@ -0,0 +1,294 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yportenv.h"
+
+#include "yaffs_mtdif.h"
+
+#include "linux/mtd/mtd.h"
+#include "linux/types.h"
+#include "linux/time.h"
+#include "linux/mtd/nand.h"
+#include "linux/kernel.h"
+#include "linux/version.h"
+#include "linux/types.h"
+
+#include "yaffs_trace.h"
+#include "yaffs_guts.h"
+#include "yaffs_linux.h"
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0))
+#define MTD_OPS_AUTO_OOB MTD_OOB_AUTO
+#endif
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0))
+#define mtd_erase(m, ei) (m)->erase(m, ei)
+#define mtd_write_oob(m, addr, pops) (m)->write_oob(m, addr, pops)
+#define mtd_read_oob(m, addr, pops) (m)->read_oob(m, addr, pops)
+#define mtd_block_isbad(m, offs) (m)->block_isbad(m, offs)
+#define mtd_block_markbad(m, offs) (m)->block_markbad(m, offs)
+#endif
+
+
+
+int nandmtd_erase_block(struct yaffs_dev *dev, int block_no)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	u32 addr =
+	    ((loff_t) block_no) * dev->param.total_bytes_per_chunk *
+	    dev->param.chunks_per_block;
+	struct erase_info ei;
+	int retval = 0;
+
+	ei.mtd = mtd;
+	ei.addr = addr;
+	ei.len = dev->param.total_bytes_per_chunk * dev->param.chunks_per_block;
+	ei.time = 1000;
+	ei.retries = 2;
+	ei.callback = NULL;
+	ei.priv = (u_long) dev;
+
+	retval = mtd_erase(mtd, &ei);
+
+	if (retval == 0)
+		return YAFFS_OK;
+
+	return YAFFS_FAIL;
+}
+
+
+static 	int yaffs_mtd_write(struct yaffs_dev *dev, int nand_chunk,
+				   const u8 *data, int data_len,
+				   const u8 *oob, int oob_len)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	loff_t addr;
+	struct mtd_oob_ops ops;
+	int retval;
+
+	addr = ((loff_t) nand_chunk) * dev->param.total_bytes_per_chunk;
+	memset(&ops, 0, sizeof(ops));
+	ops.mode = MTD_OPS_AUTO_OOB;
+	ops.len = (data) ? data_len : 0;
+	ops.ooblen = oob_len;
+	ops.datbuf = (u8 *)data;
+	ops.oobbuf = (u8 *)oob;
+
+	retval = mtd_write_oob(mtd, addr, &ops);
+	if (retval) {
+		yaffs_trace(YAFFS_TRACE_MTD,
+			"write_oob failed, chunk %d, mtd error %d",
+			nand_chunk, retval);
+	}
+	return retval ? YAFFS_FAIL : YAFFS_OK;
+}
+
+static int yaffs_mtd_read(struct yaffs_dev *dev, int nand_chunk,
+				   u8 *data, int data_len,
+				   u8 *oob, int oob_len,
+				   enum yaffs_ecc_result *ecc_result)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	loff_t addr;
+	struct mtd_oob_ops ops;
+	int retval;
+
+	addr = ((loff_t) nand_chunk) * dev->data_bytes_per_chunk;
+	memset(&ops, 0, sizeof(ops));
+	ops.mode = MTD_OPS_AUTO_OOB;
+	ops.len = (data) ? data_len : 0;
+	ops.ooblen = oob_len;
+	ops.datbuf = data;
+	ops.oobbuf = oob;
+
+#if (MTD_VERSION_CODE < MTD_VERSION(2, 6, 20))
+	/* In MTD 2.6.18 to 2.6.19 nand_base.c:nand_do_read_oob() has a bug;
+	 * help it out with ops.len = ops.ooblen when ops.datbuf == NULL.
+	 */
+	ops.len = (ops.datbuf) ? ops.len : ops.ooblen;
+#endif
+	/* Read page and oob using MTD.
+	 * Check status and determine ECC result.
+	 */
+	retval = mtd_read_oob(mtd, addr, &ops);
+	if (retval)
+		yaffs_trace(YAFFS_TRACE_MTD,
+			"read_oob failed, chunk %d, mtd error %d",
+			nand_chunk, retval);
+
+	switch (retval) {
+	case 0:
+		/* no error */
+		if(ecc_result)
+			*ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+		break;
+
+	case -EUCLEAN:
+		/* MTD's ECC fixed the data */
+		if(ecc_result)
+			*ecc_result = YAFFS_ECC_RESULT_FIXED;
+		dev->n_ecc_fixed++;
+		break;
+
+	case -EBADMSG:
+	default:
+		/* MTD's ECC could not fix the data */
+		dev->n_ecc_unfixed++;
+		if(ecc_result)
+			*ecc_result = YAFFS_ECC_RESULT_UNFIXED;
+		return YAFFS_FAIL;
+	}
+
+	return YAFFS_OK;
+}
+
+static 	int yaffs_mtd_erase(struct yaffs_dev *dev, int block_no)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+
+	loff_t addr;
+	struct erase_info ei;
+	int retval = 0;
+	u32 block_size;
+
+	block_size = dev->param.total_bytes_per_chunk *
+		     dev->param.chunks_per_block;
+	addr = ((loff_t) block_no) * block_size;
+
+	ei.mtd = mtd;
+	ei.addr = addr;
+	ei.len = block_size;
+	ei.time = 1000;
+	ei.retries = 2;
+	ei.callback = NULL;
+	ei.priv = (u_long) dev;
+
+	retval = mtd_erase(mtd, &ei);
+
+	if (retval == 0)
+		return YAFFS_OK;
+
+	return YAFFS_FAIL;
+}
+
+static int yaffs_mtd_mark_bad(struct yaffs_dev *dev, int block_no)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int blocksize = dev->param.chunks_per_block * dev->data_bytes_per_chunk;
+	int retval;
+
+	yaffs_trace(YAFFS_TRACE_BAD_BLOCKS, "marking block %d bad", block_no);
+
+	retval = mtd_block_markbad(mtd, (loff_t) blocksize * block_no);
+	return (retval) ? YAFFS_FAIL : YAFFS_OK;
+}
+
+static int yaffs_mtd_check_bad(struct yaffs_dev *dev, int block_no)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int blocksize = dev->param.chunks_per_block * dev->data_bytes_per_chunk;
+	int retval;
+
+	yaffs_trace(YAFFS_TRACE_BAD_BLOCKS, "checking block %d bad", block_no);
+
+	retval = mtd_block_isbad(mtd, (loff_t) blocksize * block_no);
+	return (retval) ? YAFFS_FAIL : YAFFS_OK;
+}
+
+static int yaffs_mtd_initialise(struct yaffs_dev *dev)
+{
+	return YAFFS_OK;
+}
+
+static int yaffs_mtd_deinitialise(struct yaffs_dev *dev)
+{
+	return YAFFS_OK;
+}
+
+
+void yaffs_mtd_drv_install(struct yaffs_dev *dev)
+{
+	struct yaffs_driver *drv = &dev->drv;
+
+	drv->drv_write_chunk_fn = yaffs_mtd_write;
+	drv->drv_read_chunk_fn = yaffs_mtd_read;
+	drv->drv_erase_fn = yaffs_mtd_erase;
+	drv->drv_mark_bad_fn = yaffs_mtd_mark_bad;
+	drv->drv_check_bad_fn = yaffs_mtd_check_bad;
+	drv->drv_initialise_fn = yaffs_mtd_initialise;
+	drv->drv_deinitialise_fn = yaffs_mtd_deinitialise;
+}
+
+
+struct mtd_info * yaffs_get_mtd_device(dev_t sdev)
+{
+	struct mtd_info *mtd;
+
+	mtd = yaffs_get_mtd_device(sdev);
+
+	/* Check it's an mtd device..... */
+	if (MAJOR(sdev) != MTD_BLOCK_MAJOR)
+		return NULL;	/* This isn't an mtd device */
+
+	/* Check it's NAND */
+	if (mtd->type != MTD_NANDFLASH) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"yaffs: MTD device is not NAND it's type %d",
+			mtd->type);
+		return NULL;
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS, " %s %d", WRITE_SIZE_STR, WRITE_SIZE(mtd));
+	yaffs_trace(YAFFS_TRACE_OS, " oobsize %d", mtd->oobsize);
+	yaffs_trace(YAFFS_TRACE_OS, " erasesize %d", mtd->erasesize);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
+	yaffs_trace(YAFFS_TRACE_OS, " size %u", mtd->size);
+#else
+	yaffs_trace(YAFFS_TRACE_OS, " size %lld", mtd->size);
+#endif
+
+	return mtd;
+}
+
+int yaffs_verify_mtd(struct mtd_info *mtd, int yaffs_version, int inband_tags)
+{
+	if (yaffs_version == 2) {
+		if ((WRITE_SIZE(mtd) < YAFFS_MIN_YAFFS2_CHUNK_SIZE ||
+		     mtd->oobsize < YAFFS_MIN_YAFFS2_SPARE_SIZE) &&
+		    !inband_tags) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not have the right page sizes"
+			);
+			return -1;
+		}
+	} else {
+		if (WRITE_SIZE(mtd) < YAFFS_BYTES_PER_CHUNK ||
+		    mtd->oobsize != YAFFS_BYTES_PER_SPARE) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not support have the right page sizes"
+			);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+
+void yaffs_put_mtd_device(struct mtd_info *mtd)
+{
+	if(mtd)
+		put_mtd_device(mtd);
+}
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_mtdif.h linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_mtdif.h
--- linux-3.0.8/fs/yaffs2/yaffs_mtdif.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_mtdif.h	2021-07-13 23:40:33.786357014 +0300
@@ -0,0 +1,25 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_MTDIF_H__
+#define __YAFFS_MTDIF_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_mtd_drv_install(struct yaffs_dev *dev);
+struct mtd_info * yaffs_get_mtd_device(dev_t sdev);
+void yaffs_put_mtd_device(struct mtd_info *mtd);
+int yaffs_verify_mtd(struct mtd_info *mtd, int yaffs_version, int inband_tags);
+#endif
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_nameval.c linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_nameval.c
--- linux-3.0.8/fs/yaffs2/yaffs_nameval.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_nameval.c	2021-07-13 23:40:33.782356989 +0300
@@ -0,0 +1,208 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * This simple implementation of a name-value store assumes a small number of
+* values and fits into a small finite buffer.
+ *
+ * Each attribute is stored as a record:
+ *  sizeof(int) bytes   record size.
+ *  strnlen+1 bytes name null terminated.
+ *  nbytes    value.
+ *  ----------
+ *  total size  stored in record size
+ *
+ * This code has not been tested with unicode yet.
+ */
+
+#include "yaffs_nameval.h"
+
+#include "yportenv.h"
+
+static int nval_find(const char *xb, int xb_size, const YCHAR *name,
+		     int *exist_size)
+{
+	int pos = 0;
+	int size;
+
+	memcpy(&size, xb, sizeof(int));
+	while (size > 0 && (size < xb_size) && (pos + size < xb_size)) {
+		if (!strncmp((YCHAR *) (xb + pos + sizeof(int)),
+				name, size)) {
+			if (exist_size)
+				*exist_size = size;
+			return pos;
+		}
+		pos += size;
+		if (pos < xb_size - sizeof(int))
+			memcpy(&size, xb + pos, sizeof(int));
+		else
+			size = 0;
+	}
+	if (exist_size)
+		*exist_size = 0;
+	return -ENODATA;
+}
+
+static int nval_used(const char *xb, int xb_size)
+{
+	int pos = 0;
+	int size;
+
+	memcpy(&size, xb + pos, sizeof(int));
+	while (size > 0 && (size < xb_size) && (pos + size < xb_size)) {
+		pos += size;
+		if (pos < xb_size - sizeof(int))
+			memcpy(&size, xb + pos, sizeof(int));
+		else
+			size = 0;
+	}
+	return pos;
+}
+
+int nval_del(char *xb, int xb_size, const YCHAR *name)
+{
+	int pos = nval_find(xb, xb_size, name, NULL);
+	int size;
+
+	if (pos < 0 || pos >= xb_size)
+		return -ENODATA;
+
+	/* Find size, shift rest over this record,
+	 * then zero out the rest of buffer */
+	memcpy(&size, xb + pos, sizeof(int));
+	memcpy(xb + pos, xb + pos + size, xb_size - (pos + size));
+	memset(xb + (xb_size - size), 0, size);
+	return 0;
+}
+
+int nval_set(char *xb, int xb_size, const YCHAR *name, const char *buf,
+		int bsize, int flags)
+{
+	int pos;
+	int namelen = strnlen(name, xb_size);
+	int reclen;
+	int size_exist = 0;
+	int space;
+	int start;
+
+	pos = nval_find(xb, xb_size, name, &size_exist);
+
+	if (flags & XATTR_CREATE && pos >= 0)
+		return -EEXIST;
+	if (flags & XATTR_REPLACE && pos < 0)
+		return -ENODATA;
+
+	start = nval_used(xb, xb_size);
+	space = xb_size - start + size_exist;
+
+	reclen = (sizeof(int) + namelen + 1 + bsize);
+
+	if (reclen > space)
+		return -ENOSPC;
+
+	if (pos >= 0) {
+		nval_del(xb, xb_size, name);
+		start = nval_used(xb, xb_size);
+	}
+
+	pos = start;
+
+	memcpy(xb + pos, &reclen, sizeof(int));
+	pos += sizeof(int);
+	strncpy((YCHAR *) (xb + pos), name, reclen);
+	pos += (namelen + 1);
+	memcpy(xb + pos, buf, bsize);
+	return 0;
+}
+
+int nval_get(const char *xb, int xb_size, const YCHAR * name, char *buf,
+	     int bsize)
+{
+	int pos = nval_find(xb, xb_size, name, NULL);
+	int size;
+
+	if (pos >= 0 && pos < xb_size) {
+
+		memcpy(&size, xb + pos, sizeof(int));
+		pos += sizeof(int);	/* advance past record length */
+		size -= sizeof(int);
+
+		/* Advance over name string */
+		while (xb[pos] && size > 0 && pos < xb_size) {
+			pos++;
+			size--;
+		}
+		/*Advance over NUL */
+		pos++;
+		size--;
+
+		/* If bsize is zero then this is a size query.
+		 * Return the size, but don't copy.
+		 */
+		if (!bsize)
+			return size;
+
+		if (size <= bsize) {
+			memcpy(buf, xb + pos, size);
+			return size;
+		}
+	}
+	if (pos >= 0)
+		return -ERANGE;
+
+	return -ENODATA;
+}
+
+int nval_list(const char *xb, int xb_size, char *buf, int bsize)
+{
+	int pos = 0;
+	int size;
+	int name_len;
+	int ncopied = 0;
+	int filled = 0;
+
+	memcpy(&size, xb + pos, sizeof(int));
+	while (size > sizeof(int) &&
+		size <= xb_size &&
+		(pos + size) < xb_size &&
+		!filled) {
+		pos += sizeof(int);
+		size -= sizeof(int);
+		name_len = strnlen((YCHAR *) (xb + pos), size);
+		if (ncopied + name_len + 1 < bsize) {
+			memcpy(buf, xb + pos, name_len * sizeof(YCHAR));
+			buf += name_len;
+			*buf = '\0';
+			buf++;
+			if (sizeof(YCHAR) > 1) {
+				*buf = '\0';
+				buf++;
+			}
+			ncopied += (name_len + 1);
+		} else {
+			filled = 1;
+		}
+		pos += size;
+		if (pos < xb_size - sizeof(int))
+			memcpy(&size, xb + pos, sizeof(int));
+		else
+			size = 0;
+	}
+	return ncopied;
+}
+
+int nval_hasvalues(const char *xb, int xb_size)
+{
+	return nval_used(xb, xb_size) > 0;
+}
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_nameval.h linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_nameval.h
--- linux-3.0.8/fs/yaffs2/yaffs_nameval.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_nameval.h	2021-07-13 23:40:33.790357039 +0300
@@ -0,0 +1,28 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __NAMEVAL_H__
+#define __NAMEVAL_H__
+
+#include "yportenv.h"
+
+int nval_del(char *xb, int xb_size, const YCHAR * name);
+int nval_set(char *xb, int xb_size, const YCHAR * name, const char *buf,
+	     int bsize, int flags);
+int nval_get(const char *xb, int xb_size, const YCHAR * name, char *buf,
+	     int bsize);
+int nval_list(const char *xb, int xb_size, char *buf, int bsize);
+int nval_hasvalues(const char *xb, int xb_size);
+#endif
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_nand.c linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_nand.c
--- linux-3.0.8/fs/yaffs2/yaffs_nand.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_nand.c	2021-07-13 23:40:33.790357039 +0300
@@ -0,0 +1,118 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_nand.h"
+#include "yaffs_tagscompat.h"
+
+#include "yaffs_getblockinfo.h"
+#include "yaffs_summary.h"
+
+static int apply_chunk_offset(struct yaffs_dev *dev, int chunk)
+{
+	return chunk - dev->chunk_offset;
+}
+
+int yaffs_rd_chunk_tags_nand(struct yaffs_dev *dev, int nand_chunk,
+			     u8 *buffer, struct yaffs_ext_tags *tags)
+{
+	int result;
+	struct yaffs_ext_tags local_tags;
+	int flash_chunk = apply_chunk_offset(dev, nand_chunk);
+
+	dev->n_page_reads++;
+
+	/* If there are no tags provided use local tags. */
+	if (!tags)
+		tags = &local_tags;
+
+	result = dev->tagger.read_chunk_tags_fn(dev, flash_chunk, buffer, tags);
+	if (tags && tags->ecc_result > YAFFS_ECC_RESULT_NO_ERROR) {
+
+		struct yaffs_block_info *bi;
+		bi = yaffs_get_block_info(dev,
+					  nand_chunk /
+					  dev->param.chunks_per_block);
+		yaffs_handle_chunk_error(dev, bi);
+	}
+	return result;
+}
+
+int yaffs_wr_chunk_tags_nand(struct yaffs_dev *dev,
+				int nand_chunk,
+				const u8 *buffer, struct yaffs_ext_tags *tags)
+{
+	int result;
+	int flash_chunk = apply_chunk_offset(dev, nand_chunk);
+
+	dev->n_page_writes++;
+
+	if (!tags) {
+		yaffs_trace(YAFFS_TRACE_ERROR, "Writing with no tags");
+		BUG();
+		return YAFFS_FAIL;
+	}
+
+	tags->seq_number = dev->seq_number;
+	tags->chunk_used = 1;
+	yaffs_trace(YAFFS_TRACE_WRITE,
+		"Writing chunk %d tags %d %d",
+		nand_chunk, tags->obj_id, tags->chunk_id);
+
+	result = dev->tagger.write_chunk_tags_fn(dev, flash_chunk,
+							buffer, tags);
+
+	yaffs_summary_add(dev, tags, nand_chunk);
+
+	return result;
+}
+
+int yaffs_mark_bad(struct yaffs_dev *dev, int block_no)
+{
+	block_no -= dev->block_offset;
+	dev->n_bad_markings++;
+	return dev->tagger.mark_bad_fn(dev, block_no);
+}
+
+
+int yaffs_query_init_block_state(struct yaffs_dev *dev,
+				 int block_no,
+				 enum yaffs_block_state *state,
+				 u32 *seq_number)
+{
+	block_no -= dev->block_offset;
+	return dev->tagger.query_block_fn(dev, block_no, state, seq_number);
+}
+
+int yaffs_erase_block(struct yaffs_dev *dev, int block_no)
+{
+	int result;
+
+	block_no -= dev->block_offset;
+	dev->n_erasures++;
+	result = dev->drv.drv_erase_fn(dev, block_no);
+	return result;
+}
+
+int yaffs_init_nand(struct yaffs_dev *dev)
+{
+	if (dev->drv.drv_initialise_fn)
+		return dev->drv.drv_initialise_fn(dev);
+	return YAFFS_OK;
+}
+
+int yaffs_deinit_nand(struct yaffs_dev *dev)
+{
+	if (dev->drv.drv_deinitialise_fn)
+		return dev->drv.drv_deinitialise_fn(dev);
+	return YAFFS_OK;
+}
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_nand.h linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_nand.h
--- linux-3.0.8/fs/yaffs2/yaffs_nand.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_nand.h	2021-07-13 23:40:33.782356989 +0300
@@ -0,0 +1,39 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_NAND_H__
+#define __YAFFS_NAND_H__
+#include "yaffs_guts.h"
+
+int yaffs_rd_chunk_tags_nand(struct yaffs_dev *dev, int nand_chunk,
+			     u8 *buffer, struct yaffs_ext_tags *tags);
+
+int yaffs_wr_chunk_tags_nand(struct yaffs_dev *dev,
+			     int nand_chunk,
+			     const u8 *buffer, struct yaffs_ext_tags *tags);
+
+int yaffs_mark_bad(struct yaffs_dev *dev, int block_no);
+
+int yaffs_query_init_block_state(struct yaffs_dev *dev,
+				 int block_no,
+				 enum yaffs_block_state *state,
+				 unsigned *seq_number);
+
+int yaffs_erase_block(struct yaffs_dev *dev, int flash_block);
+
+int yaffs_init_nand(struct yaffs_dev *dev);
+int yaffs_deinit_nand(struct yaffs_dev *dev);
+
+#endif
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_packedtags1.c linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_packedtags1.c
--- linux-3.0.8/fs/yaffs2/yaffs_packedtags1.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_packedtags1.c	2021-07-13 23:40:33.782356989 +0300
@@ -0,0 +1,56 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_packedtags1.h"
+#include "yportenv.h"
+
+static const u8 all_ff[20] = {
+	0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff
+};
+
+void yaffs_pack_tags1(struct yaffs_packed_tags1 *pt,
+		      const struct yaffs_ext_tags *t)
+{
+	pt->chunk_id = t->chunk_id;
+	pt->serial_number = t->serial_number;
+	pt->n_bytes = t->n_bytes;
+	pt->obj_id = t->obj_id;
+	pt->ecc = 0;
+	pt->deleted = (t->is_deleted) ? 0 : 1;
+	pt->unused_stuff = 0;
+	pt->should_be_ff = 0xffffffff;
+}
+
+void yaffs_unpack_tags1(struct yaffs_ext_tags *t,
+			const struct yaffs_packed_tags1 *pt)
+{
+
+	if (memcmp(all_ff, pt, sizeof(struct yaffs_packed_tags1))) {
+		t->block_bad = 0;
+		if (pt->should_be_ff != 0xffffffff)
+			t->block_bad = 1;
+		t->chunk_used = 1;
+		t->obj_id = pt->obj_id;
+		t->chunk_id = pt->chunk_id;
+		t->n_bytes = pt->n_bytes;
+		t->ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+		t->is_deleted = (pt->deleted) ? 0 : 1;
+		t->serial_number = pt->serial_number;
+	} else {
+		memset(t, 0, sizeof(struct yaffs_ext_tags));
+	}
+}
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_packedtags1.h linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_packedtags1.h
--- linux-3.0.8/fs/yaffs2/yaffs_packedtags1.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_packedtags1.h	2021-07-13 23:40:33.778356963 +0300
@@ -0,0 +1,39 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/* This is used to pack YAFFS1 tags, not YAFFS2 tags. */
+
+#ifndef __YAFFS_PACKEDTAGS1_H__
+#define __YAFFS_PACKEDTAGS1_H__
+
+#include "yaffs_guts.h"
+
+struct yaffs_packed_tags1 {
+	unsigned chunk_id:20;
+	unsigned serial_number:2;
+	unsigned n_bytes:10;
+	unsigned obj_id:18;
+	unsigned ecc:12;
+	unsigned deleted:1;
+	unsigned unused_stuff:1;
+	unsigned should_be_ff;
+
+};
+
+void yaffs_pack_tags1(struct yaffs_packed_tags1 *pt,
+		      const struct yaffs_ext_tags *t);
+void yaffs_unpack_tags1(struct yaffs_ext_tags *t,
+			const struct yaffs_packed_tags1 *pt);
+#endif
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_packedtags2.c linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_packedtags2.c
--- linux-3.0.8/fs/yaffs2/yaffs_packedtags2.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_packedtags2.c	2021-07-13 23:40:33.786357014 +0300
@@ -0,0 +1,197 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_packedtags2.h"
+#include "yportenv.h"
+#include "yaffs_trace.h"
+
+/* This code packs a set of extended tags into a binary structure for
+ * NAND storage
+ */
+
+/* Some of the information is "extra" struff which can be packed in to
+ * speed scanning
+ * This is defined by having the EXTRA_HEADER_INFO_FLAG set.
+ */
+
+/* Extra flags applied to chunk_id */
+
+#define EXTRA_HEADER_INFO_FLAG	0x80000000
+#define EXTRA_SHRINK_FLAG	0x40000000
+#define EXTRA_SHADOWS_FLAG	0x20000000
+#define EXTRA_SPARE_FLAGS	0x10000000
+
+#define ALL_EXTRA_FLAGS		0xf0000000
+
+/* Also, the top 4 bits of the object Id are set to the object type. */
+#define EXTRA_OBJECT_TYPE_SHIFT (28)
+#define EXTRA_OBJECT_TYPE_MASK  ((0x0f) << EXTRA_OBJECT_TYPE_SHIFT)
+
+static void yaffs_dump_packed_tags2_tags_only(
+				const struct yaffs_packed_tags2_tags_only *ptt)
+{
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"packed tags obj %d chunk %d byte %d seq %d",
+		ptt->obj_id, ptt->chunk_id, ptt->n_bytes, ptt->seq_number);
+}
+
+static void yaffs_dump_packed_tags2(const struct yaffs_packed_tags2 *pt)
+{
+	yaffs_dump_packed_tags2_tags_only(&pt->t);
+}
+
+static void yaffs_dump_tags2(const struct yaffs_ext_tags *t)
+{
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"ext.tags eccres %d blkbad %d chused %d obj %d chunk%d byte %d del %d ser %d seq %d",
+		t->ecc_result, t->block_bad, t->chunk_used, t->obj_id,
+		t->chunk_id, t->n_bytes, t->is_deleted, t->serial_number,
+		t->seq_number);
+
+}
+
+static int yaffs_check_tags_extra_packable(const struct yaffs_ext_tags *t)
+{
+	if (t->chunk_id != 0 || !t->extra_available)
+		return 0;
+
+	/* Check if the file size is too long to store */
+	if (t->extra_obj_type == YAFFS_OBJECT_TYPE_FILE &&
+	    (t->extra_file_size >> 31) != 0)
+		return 0;
+	return 1;
+}
+
+void yaffs_pack_tags2_tags_only(struct yaffs_packed_tags2_tags_only *ptt,
+				const struct yaffs_ext_tags *t)
+{
+	ptt->chunk_id = t->chunk_id;
+	ptt->seq_number = t->seq_number;
+	ptt->n_bytes = t->n_bytes;
+	ptt->obj_id = t->obj_id;
+
+	/* Only store extra tags for object headers.
+	 * If it is a file then only store  if the file size is short\
+	 * enough to fit.
+	 */
+	if (yaffs_check_tags_extra_packable(t)) {
+		/* Store the extra header info instead */
+		/* We save the parent object in the chunk_id */
+		ptt->chunk_id = EXTRA_HEADER_INFO_FLAG | t->extra_parent_id;
+		if (t->extra_is_shrink)
+			ptt->chunk_id |= EXTRA_SHRINK_FLAG;
+		if (t->extra_shadows)
+			ptt->chunk_id |= EXTRA_SHADOWS_FLAG;
+
+		ptt->obj_id &= ~EXTRA_OBJECT_TYPE_MASK;
+		ptt->obj_id |= (t->extra_obj_type << EXTRA_OBJECT_TYPE_SHIFT);
+
+		if (t->extra_obj_type == YAFFS_OBJECT_TYPE_HARDLINK)
+			ptt->n_bytes = t->extra_equiv_id;
+		else if (t->extra_obj_type == YAFFS_OBJECT_TYPE_FILE)
+			ptt->n_bytes = (unsigned) t->extra_file_size;
+		else
+			ptt->n_bytes = 0;
+	}
+
+	yaffs_dump_packed_tags2_tags_only(ptt);
+	yaffs_dump_tags2(t);
+}
+
+void yaffs_pack_tags2(struct yaffs_packed_tags2 *pt,
+		      const struct yaffs_ext_tags *t, int tags_ecc)
+{
+	yaffs_pack_tags2_tags_only(&pt->t, t);
+
+	if (tags_ecc)
+		yaffs_ecc_calc_other((unsigned char *)&pt->t,
+				    sizeof(struct yaffs_packed_tags2_tags_only),
+				    &pt->ecc);
+}
+
+void yaffs_unpack_tags2_tags_only(struct yaffs_ext_tags *t,
+				  struct yaffs_packed_tags2_tags_only *ptt)
+{
+	memset(t, 0, sizeof(struct yaffs_ext_tags));
+
+	if (ptt->seq_number == 0xffffffff)
+		return;
+
+	t->block_bad = 0;
+	t->chunk_used = 1;
+	t->obj_id = ptt->obj_id;
+	t->chunk_id = ptt->chunk_id;
+	t->n_bytes = ptt->n_bytes;
+	t->is_deleted = 0;
+	t->serial_number = 0;
+	t->seq_number = ptt->seq_number;
+
+	/* Do extra header info stuff */
+	if (ptt->chunk_id & EXTRA_HEADER_INFO_FLAG) {
+		t->chunk_id = 0;
+		t->n_bytes = 0;
+
+		t->extra_available = 1;
+		t->extra_parent_id = ptt->chunk_id & (~(ALL_EXTRA_FLAGS));
+		t->extra_is_shrink = ptt->chunk_id & EXTRA_SHRINK_FLAG ? 1 : 0;
+		t->extra_shadows = ptt->chunk_id & EXTRA_SHADOWS_FLAG ? 1 : 0;
+		t->extra_obj_type = ptt->obj_id >> EXTRA_OBJECT_TYPE_SHIFT;
+		t->obj_id &= ~EXTRA_OBJECT_TYPE_MASK;
+
+		if (t->extra_obj_type == YAFFS_OBJECT_TYPE_HARDLINK)
+			t->extra_equiv_id = ptt->n_bytes;
+		else
+			t->extra_file_size = ptt->n_bytes;
+	}
+	yaffs_dump_packed_tags2_tags_only(ptt);
+	yaffs_dump_tags2(t);
+}
+
+void yaffs_unpack_tags2(struct yaffs_ext_tags *t, struct yaffs_packed_tags2 *pt,
+			int tags_ecc)
+{
+	enum yaffs_ecc_result ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+
+	if (pt->t.seq_number != 0xffffffff && tags_ecc) {
+		/* Chunk is in use and we need to do ECC */
+
+		struct yaffs_ecc_other ecc;
+		int result;
+		yaffs_ecc_calc_other((unsigned char *)&pt->t,
+				sizeof(struct yaffs_packed_tags2_tags_only),
+				&ecc);
+		result =
+		    yaffs_ecc_correct_other((unsigned char *)&pt->t,
+				sizeof(struct yaffs_packed_tags2_tags_only),
+				&pt->ecc, &ecc);
+		switch (result) {
+		case 0:
+			ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+			break;
+		case 1:
+			ecc_result = YAFFS_ECC_RESULT_FIXED;
+			break;
+		case -1:
+			ecc_result = YAFFS_ECC_RESULT_UNFIXED;
+			break;
+		default:
+			ecc_result = YAFFS_ECC_RESULT_UNKNOWN;
+		}
+	}
+	yaffs_unpack_tags2_tags_only(t, &pt->t);
+
+	t->ecc_result = ecc_result;
+
+	yaffs_dump_packed_tags2(pt);
+	yaffs_dump_tags2(t);
+}
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_packedtags2.h linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_packedtags2.h
--- linux-3.0.8/fs/yaffs2/yaffs_packedtags2.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_packedtags2.h	2021-07-13 23:40:33.790357039 +0300
@@ -0,0 +1,47 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/* This is used to pack YAFFS2 tags, not YAFFS1tags. */
+
+#ifndef __YAFFS_PACKEDTAGS2_H__
+#define __YAFFS_PACKEDTAGS2_H__
+
+#include "yaffs_guts.h"
+#include "yaffs_ecc.h"
+
+struct yaffs_packed_tags2_tags_only {
+	unsigned seq_number;
+	unsigned obj_id;
+	unsigned chunk_id;
+	unsigned n_bytes;
+};
+
+struct yaffs_packed_tags2 {
+	struct yaffs_packed_tags2_tags_only t;
+	struct yaffs_ecc_other ecc;
+};
+
+/* Full packed tags with ECC, used for oob tags */
+void yaffs_pack_tags2(struct yaffs_packed_tags2 *pt,
+		      const struct yaffs_ext_tags *t, int tags_ecc);
+void yaffs_unpack_tags2(struct yaffs_ext_tags *t, struct yaffs_packed_tags2 *pt,
+			int tags_ecc);
+
+/* Only the tags part (no ECC for use with inband tags */
+void yaffs_pack_tags2_tags_only(struct yaffs_packed_tags2_tags_only *pt,
+				const struct yaffs_ext_tags *t);
+void yaffs_unpack_tags2_tags_only(struct yaffs_ext_tags *t,
+				  struct yaffs_packed_tags2_tags_only *pt);
+#endif
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_summary.c linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_summary.c
--- linux-3.0.8/fs/yaffs2/yaffs_summary.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_summary.c	2021-07-13 23:40:33.786357014 +0300
@@ -0,0 +1,313 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* Summaries write the useful part of the tags for the chunks in a block into an
+ * an array which is written to the last n chunks of the block.
+ * Reading the summaries gives all the tags for the block in one read. Much
+ * faster.
+ *
+ * Chunks holding summaries are marked with tags making it look like
+ * they are part of a fake file.
+ *
+ * The summary could also be used during gc.
+ *
+ */
+
+#include "yaffs_summary.h"
+#include "yaffs_packedtags2.h"
+#include "yaffs_nand.h"
+#include "yaffs_getblockinfo.h"
+#include "yaffs_bitmap.h"
+
+/*
+ * The summary is built up in an array of summary tags.
+ * This gets written to the last one or two (maybe more) chunks in a block.
+ * A summary header is written as the first part of each chunk of summary data.
+ * The summary header must match or the summary is rejected.
+ */
+
+/* Summary tags don't need the sequence number because that is redundant. */
+struct yaffs_summary_tags {
+	unsigned obj_id;
+	unsigned chunk_id;
+	unsigned n_bytes;
+};
+
+/* Summary header */
+struct yaffs_summary_header {
+	unsigned version;	/* Must match current version */
+	unsigned block;		/* Must be this block */
+	unsigned seq;		/* Must be this sequence number */
+	unsigned sum;		/* Just add up all the bytes in the tags */
+};
+
+
+static void yaffs_summary_clear(struct yaffs_dev *dev)
+{
+	if (!dev->sum_tags)
+		return;
+	memset(dev->sum_tags, 0, dev->chunks_per_summary *
+		sizeof(struct yaffs_summary_tags));
+}
+
+
+void yaffs_summary_deinit(struct yaffs_dev *dev)
+{
+	kfree(dev->sum_tags);
+	dev->sum_tags = NULL;
+	kfree(dev->gc_sum_tags);
+	dev->gc_sum_tags = NULL;
+	dev->chunks_per_summary = 0;
+}
+
+int yaffs_summary_init(struct yaffs_dev *dev)
+{
+	int sum_bytes;
+	int chunks_used; /* Number of chunks used by summary */
+	int sum_tags_bytes;
+
+	sum_bytes = dev->param.chunks_per_block *
+			sizeof(struct yaffs_summary_tags);
+
+	chunks_used = (sum_bytes + dev->data_bytes_per_chunk - 1)/
+			(dev->data_bytes_per_chunk -
+				sizeof(struct yaffs_summary_header));
+
+	dev->chunks_per_summary = dev->param.chunks_per_block - chunks_used;
+	sum_tags_bytes = sizeof(struct yaffs_summary_tags) *
+				dev->chunks_per_summary;
+	dev->sum_tags = kmalloc(sum_tags_bytes, GFP_NOFS);
+	dev->gc_sum_tags = kmalloc(sum_tags_bytes, GFP_NOFS);
+	if (!dev->sum_tags || !dev->gc_sum_tags) {
+		yaffs_summary_deinit(dev);
+		return YAFFS_FAIL;
+	}
+
+	yaffs_summary_clear(dev);
+
+	return YAFFS_OK;
+}
+
+static unsigned yaffs_summary_sum(struct yaffs_dev *dev)
+{
+	u8 *sum_buffer = (u8 *)dev->sum_tags;
+	int i;
+	unsigned sum = 0;
+
+	i = sizeof(struct yaffs_summary_tags) *
+				dev->chunks_per_summary;
+	while (i > 0) {
+		sum += *sum_buffer;
+		sum_buffer++;
+		i--;
+	}
+
+	return sum;
+}
+
+static int yaffs_summary_write(struct yaffs_dev *dev, int blk)
+{
+	struct yaffs_ext_tags tags;
+	u8 *buffer;
+	u8 *sum_buffer = (u8 *)dev->sum_tags;
+	int n_bytes;
+	int chunk_in_nand;
+	int chunk_in_block;
+	int result;
+	int this_tx;
+	struct yaffs_summary_header hdr;
+	int sum_bytes_per_chunk = dev->data_bytes_per_chunk - sizeof(hdr);
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, blk);
+
+	buffer = yaffs_get_temp_buffer(dev);
+	n_bytes = sizeof(struct yaffs_summary_tags) *
+				dev->chunks_per_summary;
+	memset(&tags, 0, sizeof(struct yaffs_ext_tags));
+	tags.obj_id = YAFFS_OBJECTID_SUMMARY;
+	tags.chunk_id = 1;
+	chunk_in_block = dev->chunks_per_summary;
+	chunk_in_nand = dev->alloc_block * dev->param.chunks_per_block +
+						dev->chunks_per_summary;
+	hdr.version = YAFFS_SUMMARY_VERSION;
+	hdr.block = blk;
+	hdr.seq = bi->seq_number;
+	hdr.sum = yaffs_summary_sum(dev);
+
+	do {
+		this_tx = n_bytes;
+		if (this_tx > sum_bytes_per_chunk)
+			this_tx = sum_bytes_per_chunk;
+		memcpy(buffer, &hdr, sizeof(hdr));
+		memcpy(buffer + sizeof(hdr), sum_buffer, this_tx);
+		tags.n_bytes = this_tx + sizeof(hdr);
+		result = yaffs_wr_chunk_tags_nand(dev, chunk_in_nand,
+						buffer, &tags);
+
+		if (result != YAFFS_OK)
+			break;
+		yaffs_set_chunk_bit(dev, blk, chunk_in_block);
+		bi->pages_in_use++;
+		dev->n_free_chunks--;
+
+		n_bytes -= this_tx;
+		sum_buffer += this_tx;
+		chunk_in_nand++;
+		chunk_in_block++;
+		tags.chunk_id++;
+	} while (result == YAFFS_OK && n_bytes > 0);
+	yaffs_release_temp_buffer(dev, buffer);
+
+
+	if (result == YAFFS_OK)
+		bi->has_summary = 1;
+
+
+	return result;
+}
+
+int yaffs_summary_read(struct yaffs_dev *dev,
+			struct yaffs_summary_tags *st,
+			int blk)
+{
+	struct yaffs_ext_tags tags;
+	u8 *buffer;
+	u8 *sum_buffer = (u8 *)st;
+	int n_bytes;
+	int chunk_id;
+	int chunk_in_nand;
+	int chunk_in_block;
+	int result;
+	int this_tx;
+	struct yaffs_summary_header hdr;
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, blk);
+	int sum_bytes_per_chunk = dev->data_bytes_per_chunk - sizeof(hdr);
+	int sum_tags_bytes;
+
+	sum_tags_bytes = sizeof(struct yaffs_summary_tags) *
+				dev->chunks_per_summary;
+	buffer = yaffs_get_temp_buffer(dev);
+	n_bytes = sizeof(struct yaffs_summary_tags) * dev->chunks_per_summary;
+	chunk_in_block = dev->chunks_per_summary;
+	chunk_in_nand = blk * dev->param.chunks_per_block +
+							dev->chunks_per_summary;
+	chunk_id = 1;
+	do {
+		this_tx = n_bytes;
+		if (this_tx > sum_bytes_per_chunk)
+			this_tx = sum_bytes_per_chunk;
+		result = yaffs_rd_chunk_tags_nand(dev, chunk_in_nand,
+						buffer, &tags);
+
+		if (tags.chunk_id != chunk_id ||
+			tags.obj_id != YAFFS_OBJECTID_SUMMARY ||
+			tags.chunk_used == 0 ||
+			tags.ecc_result > YAFFS_ECC_RESULT_FIXED ||
+			tags.n_bytes != (this_tx + sizeof(hdr)))
+				result = YAFFS_FAIL;
+		if (result != YAFFS_OK)
+			break;
+
+		if (st == dev->sum_tags) {
+			/* If we're scanning then update the block info */
+			yaffs_set_chunk_bit(dev, blk, chunk_in_block);
+			bi->pages_in_use++;
+		}
+		memcpy(&hdr, buffer, sizeof(hdr));
+		memcpy(sum_buffer, buffer + sizeof(hdr), this_tx);
+		n_bytes -= this_tx;
+		sum_buffer += this_tx;
+		chunk_in_nand++;
+		chunk_in_block++;
+		chunk_id++;
+	} while (result == YAFFS_OK && n_bytes > 0);
+	yaffs_release_temp_buffer(dev, buffer);
+
+	if (result == YAFFS_OK) {
+		/* Verify header */
+		if (hdr.version != YAFFS_SUMMARY_VERSION ||
+		    hdr.block != blk ||
+		    hdr.seq != bi->seq_number ||
+		    hdr.sum != yaffs_summary_sum(dev))
+			result = YAFFS_FAIL;
+	}
+
+	if (st == dev->sum_tags && result == YAFFS_OK)
+		bi->has_summary = 1;
+
+	return result;
+}
+
+int yaffs_summary_add(struct yaffs_dev *dev,
+			struct yaffs_ext_tags *tags,
+			int chunk_in_nand)
+{
+	struct yaffs_packed_tags2_tags_only tags_only;
+	struct yaffs_summary_tags *sum_tags;
+	int block_in_nand = chunk_in_nand / dev->param.chunks_per_block;
+	int chunk_in_block = chunk_in_nand % dev->param.chunks_per_block;
+
+	if (!dev->sum_tags)
+		return YAFFS_OK;
+
+	if (chunk_in_block >= 0 && chunk_in_block < dev->chunks_per_summary) {
+		yaffs_pack_tags2_tags_only(&tags_only, tags);
+		sum_tags = &dev->sum_tags[chunk_in_block];
+		sum_tags->chunk_id = tags_only.chunk_id;
+		sum_tags->n_bytes = tags_only.n_bytes;
+		sum_tags->obj_id = tags_only.obj_id;
+
+		if (chunk_in_block == dev->chunks_per_summary - 1) {
+			/* Time to write out the summary */
+			yaffs_summary_write(dev, block_in_nand);
+			yaffs_summary_clear(dev);
+			yaffs_skip_rest_of_block(dev);
+		}
+	}
+	return YAFFS_OK;
+}
+
+int yaffs_summary_fetch(struct yaffs_dev *dev,
+			struct yaffs_ext_tags *tags,
+			int chunk_in_block)
+{
+	struct yaffs_packed_tags2_tags_only tags_only;
+	struct yaffs_summary_tags *sum_tags;
+	if (chunk_in_block >= 0 && chunk_in_block < dev->chunks_per_summary) {
+		sum_tags = &dev->sum_tags[chunk_in_block];
+		tags_only.chunk_id = sum_tags->chunk_id;
+		tags_only.n_bytes = sum_tags->n_bytes;
+		tags_only.obj_id = sum_tags->obj_id;
+		yaffs_unpack_tags2_tags_only(tags, &tags_only);
+		return YAFFS_OK;
+	}
+	return YAFFS_FAIL;
+}
+
+void yaffs_summary_gc(struct yaffs_dev *dev, int blk)
+{
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, blk);
+	int i;
+
+	if (!bi->has_summary)
+		return;
+
+	for (i = dev->chunks_per_summary;
+	     i < dev->param.chunks_per_block;
+	     i++) {
+		if (yaffs_check_chunk_bit(dev, blk, i)) {
+			yaffs_clear_chunk_bit(dev, blk, i);
+			bi->pages_in_use--;
+			dev->n_free_chunks++;
+		}
+	}
+}
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_summary.h linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_summary.h
--- linux-3.0.8/fs/yaffs2/yaffs_summary.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_summary.h	2021-07-13 23:40:33.790357039 +0300
@@ -0,0 +1,37 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_SUMMARY_H__
+#define __YAFFS_SUMMARY_H__
+
+#include "yaffs_packedtags2.h"
+
+
+int yaffs_summary_init(struct yaffs_dev *dev);
+void yaffs_summary_deinit(struct yaffs_dev *dev);
+
+int yaffs_summary_add(struct yaffs_dev *dev,
+			struct yaffs_ext_tags *tags,
+			int chunk_in_block);
+int yaffs_summary_fetch(struct yaffs_dev *dev,
+			struct yaffs_ext_tags *tags,
+			int chunk_in_block);
+int yaffs_summary_read(struct yaffs_dev *dev,
+			struct yaffs_summary_tags *st,
+			int blk);
+void yaffs_summary_gc(struct yaffs_dev *dev, int blk);
+
+
+#endif
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_tagscompat.c linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_tagscompat.c
--- linux-3.0.8/fs/yaffs2/yaffs_tagscompat.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_tagscompat.c	2021-07-13 23:40:33.790357039 +0300
@@ -0,0 +1,381 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_guts.h"
+#include "yaffs_tagscompat.h"
+#include "yaffs_ecc.h"
+#include "yaffs_getblockinfo.h"
+#include "yaffs_trace.h"
+
+static void yaffs_handle_rd_data_error(struct yaffs_dev *dev, int nand_chunk);
+
+
+/********** Tags ECC calculations  *********/
+
+
+void yaffs_calc_tags_ecc(struct yaffs_tags *tags)
+{
+	/* Calculate an ecc */
+	unsigned char *b = ((union yaffs_tags_union *)tags)->as_bytes;
+	unsigned i, j;
+	unsigned ecc = 0;
+	unsigned bit = 0;
+
+	tags->ecc = 0;
+
+	for (i = 0; i < 8; i++) {
+		for (j = 1; j & 0xff; j <<= 1) {
+			bit++;
+			if (b[i] & j)
+				ecc ^= bit;
+		}
+	}
+	tags->ecc = ecc;
+}
+
+int yaffs_check_tags_ecc(struct yaffs_tags *tags)
+{
+	unsigned ecc = tags->ecc;
+
+	yaffs_calc_tags_ecc(tags);
+
+	ecc ^= tags->ecc;
+
+	if (ecc && ecc <= 64) {
+		/* TODO: Handle the failure better. Retire? */
+		unsigned char *b = ((union yaffs_tags_union *)tags)->as_bytes;
+
+		ecc--;
+
+		b[ecc / 8] ^= (1 << (ecc & 7));
+
+		/* Now recvalc the ecc */
+		yaffs_calc_tags_ecc(tags);
+
+		return 1;	/* recovered error */
+	} else if (ecc) {
+		/* Wierd ecc failure value */
+		/* TODO Need to do somethiong here */
+		return -1;	/* unrecovered error */
+	}
+	return 0;
+}
+
+/********** Tags **********/
+
+static void yaffs_load_tags_to_spare(struct yaffs_spare *spare_ptr,
+				     struct yaffs_tags *tags_ptr)
+{
+	union yaffs_tags_union *tu = (union yaffs_tags_union *)tags_ptr;
+
+	yaffs_calc_tags_ecc(tags_ptr);
+
+	spare_ptr->tb0 = tu->as_bytes[0];
+	spare_ptr->tb1 = tu->as_bytes[1];
+	spare_ptr->tb2 = tu->as_bytes[2];
+	spare_ptr->tb3 = tu->as_bytes[3];
+	spare_ptr->tb4 = tu->as_bytes[4];
+	spare_ptr->tb5 = tu->as_bytes[5];
+	spare_ptr->tb6 = tu->as_bytes[6];
+	spare_ptr->tb7 = tu->as_bytes[7];
+}
+
+static void yaffs_get_tags_from_spare(struct yaffs_dev *dev,
+				      struct yaffs_spare *spare_ptr,
+				      struct yaffs_tags *tags_ptr)
+{
+	union yaffs_tags_union *tu = (union yaffs_tags_union *)tags_ptr;
+	int result;
+
+	tu->as_bytes[0] = spare_ptr->tb0;
+	tu->as_bytes[1] = spare_ptr->tb1;
+	tu->as_bytes[2] = spare_ptr->tb2;
+	tu->as_bytes[3] = spare_ptr->tb3;
+	tu->as_bytes[4] = spare_ptr->tb4;
+	tu->as_bytes[5] = spare_ptr->tb5;
+	tu->as_bytes[6] = spare_ptr->tb6;
+	tu->as_bytes[7] = spare_ptr->tb7;
+
+	result = yaffs_check_tags_ecc(tags_ptr);
+	if (result > 0)
+		dev->n_tags_ecc_fixed++;
+	else if (result < 0)
+		dev->n_tags_ecc_unfixed++;
+}
+
+static void yaffs_spare_init(struct yaffs_spare *spare)
+{
+	memset(spare, 0xff, sizeof(struct yaffs_spare));
+}
+
+static int yaffs_wr_nand(struct yaffs_dev *dev,
+			 int nand_chunk, const u8 *data,
+			 struct yaffs_spare *spare)
+{
+	int data_size = dev->data_bytes_per_chunk;
+
+	return dev->drv.drv_write_chunk_fn(dev, nand_chunk,
+				data, data_size,
+				(u8 *) spare, sizeof(*spare));
+}
+
+static int yaffs_rd_chunk_nand(struct yaffs_dev *dev,
+			       int nand_chunk,
+			       u8 *data,
+			       struct yaffs_spare *spare,
+			       enum yaffs_ecc_result *ecc_result,
+			       int correct_errors)
+{
+	int ret_val;
+	struct yaffs_spare local_spare;
+	int data_size;
+	int spare_size;
+	int ecc_result1, ecc_result2;
+	u8 calc_ecc[3];
+
+	if (!spare) {
+		/* If we don't have a real spare, then we use a local one. */
+		/* Need this for the calculation of the ecc */
+		spare = &local_spare;
+	}
+	data_size = dev->data_bytes_per_chunk;
+	spare_size = sizeof(struct yaffs_spare);
+
+	if (dev->param.use_nand_ecc)
+		return dev->drv.drv_read_chunk_fn(dev, nand_chunk,
+						data, data_size,
+						(u8 *) spare, spare_size,
+						ecc_result);
+
+
+	/* Handle the ECC at this level. */
+
+	ret_val = dev->drv.drv_read_chunk_fn(dev, nand_chunk,
+						 data, data_size,
+						 (u8 *)spare, spare_size,
+						NULL);
+	if (!data || !correct_errors)
+		return ret_val;
+
+	/* Do ECC correction if needed. */
+	yaffs_ecc_calc(data, calc_ecc);
+	ecc_result1 = yaffs_ecc_correct(data, spare->ecc1, calc_ecc);
+	yaffs_ecc_calc(&data[256], calc_ecc);
+	ecc_result2 = yaffs_ecc_correct(&data[256], spare->ecc2, calc_ecc);
+
+	if (ecc_result1 > 0) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"**>>yaffs ecc error fix performed on chunk %d:0",
+			nand_chunk);
+		dev->n_ecc_fixed++;
+	} else if (ecc_result1 < 0) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"**>>yaffs ecc error unfixed on chunk %d:0",
+			nand_chunk);
+		dev->n_ecc_unfixed++;
+	}
+
+	if (ecc_result2 > 0) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"**>>yaffs ecc error fix performed on chunk %d:1",
+			nand_chunk);
+		dev->n_ecc_fixed++;
+	} else if (ecc_result2 < 0) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"**>>yaffs ecc error unfixed on chunk %d:1",
+			nand_chunk);
+		dev->n_ecc_unfixed++;
+	}
+
+	if (ecc_result1 || ecc_result2) {
+		/* We had a data problem on this page */
+		yaffs_handle_rd_data_error(dev, nand_chunk);
+	}
+
+	if (ecc_result1 < 0 || ecc_result2 < 0)
+		*ecc_result = YAFFS_ECC_RESULT_UNFIXED;
+	else if (ecc_result1 > 0 || ecc_result2 > 0)
+		*ecc_result = YAFFS_ECC_RESULT_FIXED;
+	else
+		*ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+
+	return ret_val;
+}
+
+/*
+ * Functions for robustisizing
+ */
+
+static void yaffs_handle_rd_data_error(struct yaffs_dev *dev, int nand_chunk)
+{
+	int flash_block = nand_chunk / dev->param.chunks_per_block;
+
+	/* Mark the block for retirement */
+	yaffs_get_block_info(dev, flash_block + dev->block_offset)->
+		needs_retiring = 1;
+	yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+		"**>>Block %d marked for retirement",
+		flash_block);
+
+	/* TODO:
+	 * Just do a garbage collection on the affected block
+	 * then retire the block
+	 * NB recursion
+	 */
+}
+
+static int yaffs_tags_compat_wr(struct yaffs_dev *dev,
+			 int nand_chunk,
+			 const u8 *data, const struct yaffs_ext_tags *ext_tags)
+{
+	struct yaffs_spare spare;
+	struct yaffs_tags tags;
+
+	yaffs_spare_init(&spare);
+
+	if (ext_tags->is_deleted)
+		spare.page_status = 0;
+	else {
+		tags.obj_id = ext_tags->obj_id;
+		tags.chunk_id = ext_tags->chunk_id;
+
+		tags.n_bytes_lsb = ext_tags->n_bytes & (1024 - 1);
+
+		if (dev->data_bytes_per_chunk >= 1024)
+			tags.n_bytes_msb = (ext_tags->n_bytes >> 10) & 3;
+		else
+			tags.n_bytes_msb = 3;
+
+		tags.serial_number = ext_tags->serial_number;
+
+		if (!dev->param.use_nand_ecc && data) {
+			yaffs_ecc_calc(data, spare.ecc1);
+			yaffs_ecc_calc(&data[256], spare.ecc2);
+		}
+
+		yaffs_load_tags_to_spare(&spare, &tags);
+	}
+	return yaffs_wr_nand(dev, nand_chunk, data, &spare);
+}
+
+static int yaffs_tags_compat_rd(struct yaffs_dev *dev,
+			 int nand_chunk,
+			 u8 *data, struct yaffs_ext_tags *ext_tags)
+{
+	struct yaffs_spare spare;
+	struct yaffs_tags tags;
+	enum yaffs_ecc_result ecc_result = YAFFS_ECC_RESULT_UNKNOWN;
+	static struct yaffs_spare spare_ff;
+	static int init;
+	int deleted;
+
+	if (!init) {
+		memset(&spare_ff, 0xff, sizeof(spare_ff));
+		init = 1;
+	}
+
+	if (!yaffs_rd_chunk_nand(dev, nand_chunk,
+					data, &spare, &ecc_result, 1))
+		return YAFFS_FAIL;
+
+	/* ext_tags may be NULL */
+	if (!ext_tags)
+		return YAFFS_OK;
+
+	deleted = (hweight8(spare.page_status) < 7) ? 1 : 0;
+
+	ext_tags->is_deleted = deleted;
+	ext_tags->ecc_result = ecc_result;
+	ext_tags->block_bad = 0;	/* We're reading it */
+	/* therefore it is not a bad block */
+	ext_tags->chunk_used =
+		memcmp(&spare_ff, &spare, sizeof(spare_ff)) ? 1 : 0;
+
+	if (ext_tags->chunk_used) {
+		yaffs_get_tags_from_spare(dev, &spare, &tags);
+		ext_tags->obj_id = tags.obj_id;
+		ext_tags->chunk_id = tags.chunk_id;
+		ext_tags->n_bytes = tags.n_bytes_lsb;
+
+		if (dev->data_bytes_per_chunk >= 1024)
+			ext_tags->n_bytes |=
+				(((unsigned)tags.n_bytes_msb) << 10);
+
+		ext_tags->serial_number = tags.serial_number;
+	}
+
+	return YAFFS_OK;
+}
+
+static int yaffs_tags_compat_mark_bad(struct yaffs_dev *dev, int flash_block)
+{
+	struct yaffs_spare spare;
+
+	memset(&spare, 0xff, sizeof(struct yaffs_spare));
+
+	spare.block_status = 'Y';
+
+	yaffs_wr_nand(dev, flash_block * dev->param.chunks_per_block, NULL,
+		      &spare);
+	yaffs_wr_nand(dev, flash_block * dev->param.chunks_per_block + 1,
+		      NULL, &spare);
+
+	return YAFFS_OK;
+}
+
+static int yaffs_tags_compat_query_block(struct yaffs_dev *dev,
+				  int block_no,
+				  enum yaffs_block_state *state,
+				  u32 *seq_number)
+{
+	struct yaffs_spare spare0, spare1;
+	static struct yaffs_spare spare_ff;
+	static int init;
+	enum yaffs_ecc_result dummy;
+
+	if (!init) {
+		memset(&spare_ff, 0xff, sizeof(spare_ff));
+		init = 1;
+	}
+
+	*seq_number = 0;
+
+	/* Look for bad block markers in the first two chunks */
+	yaffs_rd_chunk_nand(dev, block_no * dev->param.chunks_per_block,
+			    NULL, &spare0, &dummy, 0);
+	yaffs_rd_chunk_nand(dev, block_no * dev->param.chunks_per_block + 1,
+			    NULL, &spare1, &dummy, 0);
+
+	if (hweight8(spare0.block_status & spare1.block_status) < 7)
+		*state = YAFFS_BLOCK_STATE_DEAD;
+	else if (memcmp(&spare_ff, &spare0, sizeof(spare_ff)) == 0)
+		*state = YAFFS_BLOCK_STATE_EMPTY;
+	else
+		*state = YAFFS_BLOCK_STATE_NEEDS_SCAN;
+
+	return YAFFS_OK;
+}
+
+void yaffs_tags_compat_install(struct yaffs_dev *dev)
+{
+	if(dev->param.is_yaffs2)
+		return;
+	if(!dev->tagger.write_chunk_tags_fn)
+		dev->tagger.write_chunk_tags_fn = yaffs_tags_compat_wr;
+	if(!dev->tagger.read_chunk_tags_fn)
+		dev->tagger.read_chunk_tags_fn = yaffs_tags_compat_rd;
+	if(!dev->tagger.query_block_fn)
+		dev->tagger.query_block_fn = yaffs_tags_compat_query_block;
+	if(!dev->tagger.mark_bad_fn)
+		dev->tagger.mark_bad_fn = yaffs_tags_compat_mark_bad;
+}
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_tagscompat.h linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_tagscompat.h
--- linux-3.0.8/fs/yaffs2/yaffs_tagscompat.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_tagscompat.h	2021-07-13 23:40:33.778356963 +0300
@@ -0,0 +1,44 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_TAGSCOMPAT_H__
+#define __YAFFS_TAGSCOMPAT_H__
+
+
+#include "yaffs_guts.h"
+
+#if 0
+
+
+int yaffs_tags_compat_wr(struct yaffs_dev *dev,
+			 int nand_chunk,
+			 const u8 *data, const struct yaffs_ext_tags *tags);
+int yaffs_tags_compat_rd(struct yaffs_dev *dev,
+			 int nand_chunk,
+			 u8 *data, struct yaffs_ext_tags *tags);
+int yaffs_tags_compat_mark_bad(struct yaffs_dev *dev, int block_no);
+int yaffs_tags_compat_query_block(struct yaffs_dev *dev,
+				  int block_no,
+				  enum yaffs_block_state *state,
+				  u32 *seq_number);
+
+#endif
+
+
+void yaffs_tags_compat_install(struct yaffs_dev *dev);
+void yaffs_calc_tags_ecc(struct yaffs_tags *tags);
+int yaffs_check_tags_ecc(struct yaffs_tags *tags);
+
+#endif
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_tagsmarshall.c linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_tagsmarshall.c
--- linux-3.0.8/fs/yaffs2/yaffs_tagsmarshall.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_tagsmarshall.c	2021-07-13 23:40:33.786357014 +0300
@@ -0,0 +1,199 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_guts.h"
+#include "yaffs_trace.h"
+#include "yaffs_packedtags2.h"
+
+static int yaffs_tags_marshall_write(struct yaffs_dev *dev,
+				    int nand_chunk, const u8 *data,
+				    const struct yaffs_ext_tags *tags)
+{
+	struct yaffs_packed_tags2 pt;
+	int retval;
+
+	int packed_tags_size =
+	    dev->param.no_tags_ecc ? sizeof(pt.t) : sizeof(pt);
+	void *packed_tags_ptr =
+	    dev->param.no_tags_ecc ? (void *)&pt.t : (void *)&pt;
+
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"yaffs_tags_marshall_write chunk %d data %p tags %p",
+		nand_chunk, data, tags);
+
+	/* For yaffs2 writing there must be both data and tags.
+	 * If we're using inband tags, then the tags are stuffed into
+	 * the end of the data buffer.
+	 */
+	if (!data || !tags)
+		BUG();
+	else if (dev->param.inband_tags) {
+		struct yaffs_packed_tags2_tags_only *pt2tp;
+		pt2tp =
+		    (struct yaffs_packed_tags2_tags_only *)(data +
+							dev->
+							data_bytes_per_chunk);
+		yaffs_pack_tags2_tags_only(pt2tp, tags);
+	} else {
+		yaffs_pack_tags2(&pt, tags, !dev->param.no_tags_ecc);
+	}
+
+	retval = dev->drv.drv_write_chunk_fn(dev, nand_chunk,
+			data, dev->param.total_bytes_per_chunk,
+			(dev->param.inband_tags) ? NULL : packed_tags_ptr,
+			(dev->param.inband_tags) ? 0 : packed_tags_size);
+
+	return retval;
+}
+
+static int yaffs_tags_marshall_read(struct yaffs_dev *dev,
+				   int nand_chunk, u8 *data,
+				   struct yaffs_ext_tags *tags)
+{
+	int retval = 0;
+	int local_data = 0;
+	u8 spare_buffer[100];
+	enum yaffs_ecc_result ecc_result;
+
+	struct yaffs_packed_tags2 pt;
+
+	int packed_tags_size =
+	    dev->param.no_tags_ecc ? sizeof(pt.t) : sizeof(pt);
+	void *packed_tags_ptr =
+	    dev->param.no_tags_ecc ? (void *)&pt.t : (void *)&pt;
+
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"yaffs_tags_marshall_read chunk %d data %p tags %p",
+		nand_chunk, data, tags);
+
+	if (dev->param.inband_tags) {
+		if (!data) {
+			local_data = 1;
+			data = yaffs_get_temp_buffer(dev);
+		}
+	}
+
+	if (dev->param.inband_tags || (data && !tags))
+		retval = dev->drv.drv_read_chunk_fn(dev, nand_chunk,
+					data, dev->param.total_bytes_per_chunk,
+					NULL, 0,
+					&ecc_result);
+	else if (tags)
+		retval = dev->drv.drv_read_chunk_fn(dev, nand_chunk,
+					data, dev->param.total_bytes_per_chunk,
+					spare_buffer, packed_tags_size,
+					&ecc_result);
+	else
+		BUG();
+
+
+	if (dev->param.inband_tags) {
+		if (tags) {
+			struct yaffs_packed_tags2_tags_only *pt2tp;
+			pt2tp =
+				(struct yaffs_packed_tags2_tags_only *)
+				&data[dev->data_bytes_per_chunk];
+			yaffs_unpack_tags2_tags_only(tags, pt2tp);
+		}
+	} else if (tags) {
+		memcpy(packed_tags_ptr, spare_buffer, packed_tags_size);
+		yaffs_unpack_tags2(tags, &pt, !dev->param.no_tags_ecc);
+	}
+
+	if (local_data)
+		yaffs_release_temp_buffer(dev, data);
+
+	if (tags && ecc_result == YAFFS_ECC_RESULT_UNFIXED) {
+		tags->ecc_result = YAFFS_ECC_RESULT_UNFIXED;
+		dev->n_ecc_unfixed++;
+	}
+
+	if (tags && ecc_result == -YAFFS_ECC_RESULT_FIXED) {
+		if (tags->ecc_result <= YAFFS_ECC_RESULT_NO_ERROR)
+			tags->ecc_result = YAFFS_ECC_RESULT_FIXED;
+		dev->n_ecc_fixed++;
+	}
+
+	if (ecc_result < YAFFS_ECC_RESULT_UNFIXED)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
+static int yaffs_tags_marshall_query_block(struct yaffs_dev *dev, int block_no,
+			       enum yaffs_block_state *state,
+			       u32 *seq_number)
+{
+	int retval;
+
+	yaffs_trace(YAFFS_TRACE_MTD, "yaffs_tags_marshall_query_block %d",
+			block_no);
+
+	retval = dev->drv.drv_check_bad_fn(dev, block_no);
+
+	if (retval== YAFFS_FAIL) {
+		yaffs_trace(YAFFS_TRACE_MTD, "block is bad");
+
+		*state = YAFFS_BLOCK_STATE_DEAD;
+		*seq_number = 0;
+	} else {
+		struct yaffs_ext_tags t;
+
+		yaffs_tags_marshall_read(dev,
+				    block_no * dev->param.chunks_per_block,
+				    NULL, &t);
+
+		if (t.chunk_used) {
+			*seq_number = t.seq_number;
+			*state = YAFFS_BLOCK_STATE_NEEDS_SCAN;
+		} else {
+			*seq_number = 0;
+			*state = YAFFS_BLOCK_STATE_EMPTY;
+		}
+	}
+
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"block query returns  seq %d state %d",
+		*seq_number, *state);
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
+static int yaffs_tags_marshall_mark_bad(struct yaffs_dev *dev, int block_no)
+{
+	return dev->drv.drv_mark_bad_fn(dev, block_no);
+
+}
+
+
+void yaffs_tags_marshall_install(struct yaffs_dev *dev)
+{
+	if (!dev->param.is_yaffs2)
+		return;
+
+	if (!dev->tagger.write_chunk_tags_fn)
+		dev->tagger.write_chunk_tags_fn = yaffs_tags_marshall_write;
+
+	if (!dev->tagger.read_chunk_tags_fn)
+		dev->tagger.read_chunk_tags_fn = yaffs_tags_marshall_read;
+
+	if (!dev->tagger.query_block_fn)
+		dev->tagger.query_block_fn = yaffs_tags_marshall_query_block;
+
+	if (!dev->tagger.mark_bad_fn)
+		dev->tagger.mark_bad_fn = yaffs_tags_marshall_mark_bad;
+
+}
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_tagsmarshall.h linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_tagsmarshall.h
--- linux-3.0.8/fs/yaffs2/yaffs_tagsmarshall.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_tagsmarshall.h	2021-07-13 23:40:33.782356989 +0300
@@ -0,0 +1,22 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_TAGSMARSHALL_H__
+#define __YAFFS_TAGSMARSHALL_H__
+
+#include "yaffs_guts.h"
+void yaffs_tags_marshall_install(struct yaffs_dev *dev);
+
+#endif
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_trace.h linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_trace.h
--- linux-3.0.8/fs/yaffs2/yaffs_trace.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_trace.h	2021-07-13 23:40:33.782356989 +0300
@@ -0,0 +1,57 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YTRACE_H__
+#define __YTRACE_H__
+
+extern unsigned int yaffs_trace_mask;
+extern unsigned int yaffs_wr_attempts;
+
+/*
+ * Tracing flags.
+ * The flags masked in YAFFS_TRACE_ALWAYS are always traced.
+ */
+
+#define YAFFS_TRACE_OS			0x00000002
+#define YAFFS_TRACE_ALLOCATE		0x00000004
+#define YAFFS_TRACE_SCAN		0x00000008
+#define YAFFS_TRACE_BAD_BLOCKS		0x00000010
+#define YAFFS_TRACE_ERASE		0x00000020
+#define YAFFS_TRACE_GC			0x00000040
+#define YAFFS_TRACE_WRITE		0x00000080
+#define YAFFS_TRACE_TRACING		0x00000100
+#define YAFFS_TRACE_DELETION		0x00000200
+#define YAFFS_TRACE_BUFFERS		0x00000400
+#define YAFFS_TRACE_NANDACCESS		0x00000800
+#define YAFFS_TRACE_GC_DETAIL		0x00001000
+#define YAFFS_TRACE_SCAN_DEBUG		0x00002000
+#define YAFFS_TRACE_MTD			0x00004000
+#define YAFFS_TRACE_CHECKPOINT		0x00008000
+
+#define YAFFS_TRACE_VERIFY		0x00010000
+#define YAFFS_TRACE_VERIFY_NAND		0x00020000
+#define YAFFS_TRACE_VERIFY_FULL		0x00040000
+#define YAFFS_TRACE_VERIFY_ALL		0x000f0000
+
+#define YAFFS_TRACE_SYNC		0x00100000
+#define YAFFS_TRACE_BACKGROUND		0x00200000
+#define YAFFS_TRACE_LOCK		0x00400000
+#define YAFFS_TRACE_MOUNT		0x00800000
+
+#define YAFFS_TRACE_ERROR		0x40000000
+#define YAFFS_TRACE_BUG			0x80000000
+#define YAFFS_TRACE_ALWAYS		0xf0000000
+
+#endif
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_verify.c linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_verify.c
--- linux-3.0.8/fs/yaffs2/yaffs_verify.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_verify.c	2021-07-13 23:40:33.786357014 +0300
@@ -0,0 +1,529 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_verify.h"
+#include "yaffs_trace.h"
+#include "yaffs_bitmap.h"
+#include "yaffs_getblockinfo.h"
+#include "yaffs_nand.h"
+
+int yaffs_skip_verification(struct yaffs_dev *dev)
+{
+	(void) dev;
+	return !(yaffs_trace_mask &
+		 (YAFFS_TRACE_VERIFY | YAFFS_TRACE_VERIFY_FULL));
+}
+
+static int yaffs_skip_full_verification(struct yaffs_dev *dev)
+{
+	(void) dev;
+	return !(yaffs_trace_mask & (YAFFS_TRACE_VERIFY_FULL));
+}
+
+static int yaffs_skip_nand_verification(struct yaffs_dev *dev)
+{
+	(void) dev;
+	return !(yaffs_trace_mask & (YAFFS_TRACE_VERIFY_NAND));
+}
+
+static const char * const block_state_name[] = {
+	"Unknown",
+	"Needs scan",
+	"Scanning",
+	"Empty",
+	"Allocating",
+	"Full",
+	"Dirty",
+	"Checkpoint",
+	"Collecting",
+	"Dead"
+};
+
+void yaffs_verify_blk(struct yaffs_dev *dev, struct yaffs_block_info *bi, int n)
+{
+	int actually_used;
+	int in_use;
+
+	if (yaffs_skip_verification(dev))
+		return;
+
+	/* Report illegal runtime states */
+	if (bi->block_state >= YAFFS_NUMBER_OF_BLOCK_STATES)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Block %d has undefined state %d",
+			n, bi->block_state);
+
+	switch (bi->block_state) {
+	case YAFFS_BLOCK_STATE_UNKNOWN:
+	case YAFFS_BLOCK_STATE_SCANNING:
+	case YAFFS_BLOCK_STATE_NEEDS_SCAN:
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Block %d has bad run-state %s",
+			n, block_state_name[bi->block_state]);
+	}
+
+	/* Check pages in use and soft deletions are legal */
+
+	actually_used = bi->pages_in_use - bi->soft_del_pages;
+
+	if (bi->pages_in_use < 0 ||
+	    bi->pages_in_use > dev->param.chunks_per_block ||
+	    bi->soft_del_pages < 0 ||
+	    bi->soft_del_pages > dev->param.chunks_per_block ||
+	    actually_used < 0 || actually_used > dev->param.chunks_per_block)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Block %d has illegal values pages_in_used %d soft_del_pages %d",
+			n, bi->pages_in_use, bi->soft_del_pages);
+
+	/* Check chunk bitmap legal */
+	in_use = yaffs_count_chunk_bits(dev, n);
+	if (in_use != bi->pages_in_use)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Block %d has inconsistent values pages_in_use %d counted chunk bits %d",
+			n, bi->pages_in_use, in_use);
+}
+
+void yaffs_verify_collected_blk(struct yaffs_dev *dev,
+				struct yaffs_block_info *bi, int n)
+{
+	yaffs_verify_blk(dev, bi, n);
+
+	/* After collection the block should be in the erased state */
+
+	if (bi->block_state != YAFFS_BLOCK_STATE_COLLECTING &&
+	    bi->block_state != YAFFS_BLOCK_STATE_EMPTY) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"Block %d is in state %d after gc, should be erased",
+			n, bi->block_state);
+	}
+}
+
+void yaffs_verify_blocks(struct yaffs_dev *dev)
+{
+	int i;
+	int state_count[YAFFS_NUMBER_OF_BLOCK_STATES];
+	int illegal_states = 0;
+
+	if (yaffs_skip_verification(dev))
+		return;
+
+	memset(state_count, 0, sizeof(state_count));
+
+	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
+		struct yaffs_block_info *bi = yaffs_get_block_info(dev, i);
+		yaffs_verify_blk(dev, bi, i);
+
+		if (bi->block_state < YAFFS_NUMBER_OF_BLOCK_STATES)
+			state_count[bi->block_state]++;
+		else
+			illegal_states++;
+	}
+
+	yaffs_trace(YAFFS_TRACE_VERIFY,	"Block summary");
+
+	yaffs_trace(YAFFS_TRACE_VERIFY,
+		"%d blocks have illegal states",
+		illegal_states);
+	if (state_count[YAFFS_BLOCK_STATE_ALLOCATING] > 1)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Too many allocating blocks");
+
+	for (i = 0; i < YAFFS_NUMBER_OF_BLOCK_STATES; i++)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"%s %d blocks",
+			block_state_name[i], state_count[i]);
+
+	if (dev->blocks_in_checkpt != state_count[YAFFS_BLOCK_STATE_CHECKPOINT])
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Checkpoint block count wrong dev %d count %d",
+			dev->blocks_in_checkpt,
+			state_count[YAFFS_BLOCK_STATE_CHECKPOINT]);
+
+	if (dev->n_erased_blocks != state_count[YAFFS_BLOCK_STATE_EMPTY])
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Erased block count wrong dev %d count %d",
+			dev->n_erased_blocks,
+			state_count[YAFFS_BLOCK_STATE_EMPTY]);
+
+	if (state_count[YAFFS_BLOCK_STATE_COLLECTING] > 1)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Too many collecting blocks %d (max is 1)",
+			state_count[YAFFS_BLOCK_STATE_COLLECTING]);
+}
+
+/*
+ * Verify the object header. oh must be valid, but obj and tags may be NULL in
+ * which case those tests will not be performed.
+ */
+void yaffs_verify_oh(struct yaffs_obj *obj, struct yaffs_obj_hdr *oh,
+		     struct yaffs_ext_tags *tags, int parent_check)
+{
+	if (obj && yaffs_skip_verification(obj->my_dev))
+		return;
+
+	if (!(tags && obj && oh)) {
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Verifying object header tags %p obj %p oh %p",
+			tags, obj, oh);
+		return;
+	}
+
+	if (oh->type <= YAFFS_OBJECT_TYPE_UNKNOWN ||
+	    oh->type > YAFFS_OBJECT_TYPE_MAX)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d header type is illegal value 0x%x",
+			tags->obj_id, oh->type);
+
+	if (tags->obj_id != obj->obj_id)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d header mismatch obj_id %d",
+			tags->obj_id, obj->obj_id);
+
+	/*
+	 * Check that the object's parent ids match if parent_check requested.
+	 *
+	 * Tests do not apply to the root object.
+	 */
+
+	if (parent_check && tags->obj_id > 1 && !obj->parent)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d header mismatch parent_id %d obj->parent is NULL",
+			tags->obj_id, oh->parent_obj_id);
+
+	if (parent_check && obj->parent &&
+	    oh->parent_obj_id != obj->parent->obj_id &&
+	    (oh->parent_obj_id != YAFFS_OBJECTID_UNLINKED ||
+	     obj->parent->obj_id != YAFFS_OBJECTID_DELETED))
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d header mismatch parent_id %d parent_obj_id %d",
+			tags->obj_id, oh->parent_obj_id,
+			obj->parent->obj_id);
+
+	if (tags->obj_id > 1 && oh->name[0] == 0)	/* Null name */
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d header name is NULL",
+			obj->obj_id);
+
+	if (tags->obj_id > 1 && ((u8) (oh->name[0])) == 0xff)	/* Junk name */
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d header name is 0xff",
+			obj->obj_id);
+}
+
+void yaffs_verify_file(struct yaffs_obj *obj)
+{
+	u32 x;
+	int required_depth;
+	int actual_depth;
+	int last_chunk;
+	u32 offset_in_chunk;
+	u32 the_chunk;
+
+	u32 i;
+	struct yaffs_dev *dev;
+	struct yaffs_ext_tags tags;
+	struct yaffs_tnode *tn;
+	u32 obj_id;
+
+	if (!obj)
+		return;
+
+	if (yaffs_skip_verification(obj->my_dev))
+		return;
+
+	dev = obj->my_dev;
+	obj_id = obj->obj_id;
+
+
+	/* Check file size is consistent with tnode depth */
+	yaffs_addr_to_chunk(dev, obj->variant.file_variant.file_size,
+				&last_chunk, &offset_in_chunk);
+	last_chunk++;
+	x = last_chunk >> YAFFS_TNODES_LEVEL0_BITS;
+	required_depth = 0;
+	while (x > 0) {
+		x >>= YAFFS_TNODES_INTERNAL_BITS;
+		required_depth++;
+	}
+
+	actual_depth = obj->variant.file_variant.top_level;
+
+	/* Check that the chunks in the tnode tree are all correct.
+	 * We do this by scanning through the tnode tree and
+	 * checking the tags for every chunk match.
+	 */
+
+	if (yaffs_skip_nand_verification(dev))
+		return;
+
+	for (i = 1; i <= last_chunk; i++) {
+		tn = yaffs_find_tnode_0(dev, &obj->variant.file_variant, i);
+
+		if (!tn)
+			continue;
+
+		the_chunk = yaffs_get_group_base(dev, tn, i);
+		if (the_chunk > 0) {
+			yaffs_rd_chunk_tags_nand(dev, the_chunk, NULL,
+						 &tags);
+			if (tags.obj_id != obj_id || tags.chunk_id != i)
+				yaffs_trace(YAFFS_TRACE_VERIFY,
+					"Object %d chunk_id %d NAND mismatch chunk %d tags (%d:%d)",
+					obj_id, i, the_chunk,
+					tags.obj_id, tags.chunk_id);
+		}
+	}
+}
+
+void yaffs_verify_link(struct yaffs_obj *obj)
+{
+	if (obj && yaffs_skip_verification(obj->my_dev))
+		return;
+
+	/* Verify sane equivalent object */
+}
+
+void yaffs_verify_symlink(struct yaffs_obj *obj)
+{
+	if (obj && yaffs_skip_verification(obj->my_dev))
+		return;
+
+	/* Verify symlink string */
+}
+
+void yaffs_verify_special(struct yaffs_obj *obj)
+{
+	if (obj && yaffs_skip_verification(obj->my_dev))
+		return;
+}
+
+void yaffs_verify_obj(struct yaffs_obj *obj)
+{
+	struct yaffs_dev *dev;
+	u32 chunk_min;
+	u32 chunk_max;
+	u32 chunk_id_ok;
+	u32 chunk_in_range;
+	u32 chunk_wrongly_deleted;
+	u32 chunk_valid;
+
+	if (!obj)
+		return;
+
+	if (obj->being_created)
+		return;
+
+	dev = obj->my_dev;
+
+	if (yaffs_skip_verification(dev))
+		return;
+
+	/* Check sane object header chunk */
+
+	chunk_min = dev->internal_start_block * dev->param.chunks_per_block;
+	chunk_max =
+	    (dev->internal_end_block + 1) * dev->param.chunks_per_block - 1;
+
+	chunk_in_range = (((unsigned)(obj->hdr_chunk)) >= chunk_min &&
+			  ((unsigned)(obj->hdr_chunk)) <= chunk_max);
+	chunk_id_ok = chunk_in_range || (obj->hdr_chunk == 0);
+	chunk_valid = chunk_in_range &&
+	    yaffs_check_chunk_bit(dev,
+				  obj->hdr_chunk / dev->param.chunks_per_block,
+				  obj->hdr_chunk % dev->param.chunks_per_block);
+	chunk_wrongly_deleted = chunk_in_range && !chunk_valid;
+
+	if (!obj->fake && (!chunk_id_ok || chunk_wrongly_deleted))
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d has chunk_id %d %s %s",
+			obj->obj_id, obj->hdr_chunk,
+			chunk_id_ok ? "" : ",out of range",
+			chunk_wrongly_deleted ? ",marked as deleted" : "");
+
+	if (chunk_valid && !yaffs_skip_nand_verification(dev)) {
+		struct yaffs_ext_tags tags;
+		struct yaffs_obj_hdr *oh;
+		u8 *buffer = yaffs_get_temp_buffer(dev);
+
+		oh = (struct yaffs_obj_hdr *)buffer;
+
+		yaffs_rd_chunk_tags_nand(dev, obj->hdr_chunk, buffer, &tags);
+
+		yaffs_verify_oh(obj, oh, &tags, 1);
+
+		yaffs_release_temp_buffer(dev, buffer);
+	}
+
+	/* Verify it has a parent */
+	if (obj && !obj->fake && (!obj->parent || obj->parent->my_dev != dev)) {
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d has parent pointer %p which does not look like an object",
+			obj->obj_id, obj->parent);
+	}
+
+	/* Verify parent is a directory */
+	if (obj->parent &&
+	    obj->parent->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d's parent is not a directory (type %d)",
+			obj->obj_id, obj->parent->variant_type);
+	}
+
+	switch (obj->variant_type) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		yaffs_verify_file(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		yaffs_verify_symlink(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		yaffs_verify_dir(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		yaffs_verify_link(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		yaffs_verify_special(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+	default:
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d has illegaltype %d",
+		   obj->obj_id, obj->variant_type);
+		break;
+	}
+}
+
+void yaffs_verify_objects(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj;
+	int i;
+	struct list_head *lh;
+
+	if (yaffs_skip_verification(dev))
+		return;
+
+	/* Iterate through the objects in each hash entry */
+
+	for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
+		list_for_each(lh, &dev->obj_bucket[i].list) {
+			obj = list_entry(lh, struct yaffs_obj, hash_link);
+			yaffs_verify_obj(obj);
+		}
+	}
+}
+
+void yaffs_verify_obj_in_dir(struct yaffs_obj *obj)
+{
+	struct list_head *lh;
+	struct yaffs_obj *list_obj;
+	int count = 0;
+
+	if (!obj) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "No object to verify");
+		BUG();
+		return;
+	}
+
+	if (yaffs_skip_verification(obj->my_dev))
+		return;
+
+	if (!obj->parent) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "Object does not have parent");
+		BUG();
+		return;
+	}
+
+	if (obj->parent->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "Parent is not directory");
+		BUG();
+	}
+
+	/* Iterate through the objects in each hash entry */
+
+	list_for_each(lh, &obj->parent->variant.dir_variant.children) {
+		list_obj = list_entry(lh, struct yaffs_obj, siblings);
+		yaffs_verify_obj(list_obj);
+		if (obj == list_obj)
+			count++;
+	}
+
+	if (count != 1) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"Object in directory %d times",
+			count);
+		BUG();
+	}
+}
+
+void yaffs_verify_dir(struct yaffs_obj *directory)
+{
+	struct list_head *lh;
+	struct yaffs_obj *list_obj;
+
+	if (!directory) {
+		BUG();
+		return;
+	}
+
+	if (yaffs_skip_full_verification(directory->my_dev))
+		return;
+
+	if (directory->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"Directory has wrong type: %d",
+			directory->variant_type);
+		BUG();
+	}
+
+	/* Iterate through the objects in each hash entry */
+
+	list_for_each(lh, &directory->variant.dir_variant.children) {
+		list_obj = list_entry(lh, struct yaffs_obj, siblings);
+		if (list_obj->parent != directory) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"Object in directory list has wrong parent %p",
+				list_obj->parent);
+			BUG();
+		}
+		yaffs_verify_obj_in_dir(list_obj);
+	}
+}
+
+static int yaffs_free_verification_failures;
+
+void yaffs_verify_free_chunks(struct yaffs_dev *dev)
+{
+	int counted;
+	int difference;
+
+	if (yaffs_skip_verification(dev))
+		return;
+
+	counted = yaffs_count_free_chunks(dev);
+
+	difference = dev->n_free_chunks - counted;
+
+	if (difference) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"Freechunks verification failure %d %d %d",
+			dev->n_free_chunks, counted, difference);
+		yaffs_free_verification_failures++;
+	}
+}
+
+int yaffs_verify_file_sane(struct yaffs_obj *in)
+{
+	(void) in;
+	return YAFFS_OK;
+}
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_verify.h linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_verify.h
--- linux-3.0.8/fs/yaffs2/yaffs_verify.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_verify.h	2021-07-13 23:40:33.786357014 +0300
@@ -0,0 +1,43 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_VERIFY_H__
+#define __YAFFS_VERIFY_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_verify_blk(struct yaffs_dev *dev, struct yaffs_block_info *bi,
+		      int n);
+void yaffs_verify_collected_blk(struct yaffs_dev *dev,
+				struct yaffs_block_info *bi, int n);
+void yaffs_verify_blocks(struct yaffs_dev *dev);
+
+void yaffs_verify_oh(struct yaffs_obj *obj, struct yaffs_obj_hdr *oh,
+		     struct yaffs_ext_tags *tags, int parent_check);
+void yaffs_verify_file(struct yaffs_obj *obj);
+void yaffs_verify_link(struct yaffs_obj *obj);
+void yaffs_verify_symlink(struct yaffs_obj *obj);
+void yaffs_verify_special(struct yaffs_obj *obj);
+void yaffs_verify_obj(struct yaffs_obj *obj);
+void yaffs_verify_objects(struct yaffs_dev *dev);
+void yaffs_verify_obj_in_dir(struct yaffs_obj *obj);
+void yaffs_verify_dir(struct yaffs_obj *directory);
+void yaffs_verify_free_chunks(struct yaffs_dev *dev);
+
+int yaffs_verify_file_sane(struct yaffs_obj *obj);
+
+int yaffs_skip_verification(struct yaffs_dev *dev);
+
+#endif
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_vfs.c linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_vfs.c
--- linux-3.0.8/fs/yaffs2/yaffs_vfs.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_vfs.c	2021-07-13 23:40:33.778356963 +0300
@@ -0,0 +1,3354 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ * Acknowledgements:
+ * Luc van OostenRyck for numerous patches.
+ * Nick Bane for numerous patches.
+ * Nick Bane for 2.5/2.6 integration.
+ * Andras Toth for mknod rdev issue.
+ * Michael Fischer for finding the problem with inode inconsistency.
+ * Some code bodily lifted from JFFS
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ *
+ * This is the file system front-end to YAFFS that hooks it up to
+ * the VFS.
+ *
+ * Special notes:
+ * >> 2.4: sb->u.generic_sbp points to the struct yaffs_dev associated with
+ *         this superblock
+ * >> 2.6: sb->s_fs_info  points to the struct yaffs_dev associated with this
+ *         superblock
+ * >> inode->u.generic_ip points to the associated struct yaffs_obj.
+ */
+
+/*
+ * There are two variants of the VFS glue code. This variant should compile
+ * for any version of Linux.
+ */
+#include <linux/version.h>
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 10))
+#define YAFFS_COMPILE_BACKGROUND
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23))
+#define YAFFS_COMPILE_FREEZER
+#endif
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28))
+#define YAFFS_COMPILE_EXPORTFS
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
+#define YAFFS_USE_SETATTR_COPY
+#define YAFFS_USE_TRUNCATE_SETSIZE
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
+#define YAFFS_HAS_EVICT_INODE
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+#define YAFFS_NEW_FOLLOW_LINK 1
+#else
+#define YAFFS_NEW_FOLLOW_LINK 0
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0))
+#define YAFFS_HAS_WRITE_SUPER
+#endif
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+#include <linux/config.h>
+#endif
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 39))
+#include <linux/smp_lock.h>
+#endif
+#include <linux/pagemap.h>
+#include <linux/mtd/mtd.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+#include <linux/namei.h>
+#endif
+
+#ifdef YAFFS_COMPILE_EXPORTFS
+#include <linux/exportfs.h>
+#endif
+
+#ifdef YAFFS_COMPILE_BACKGROUND
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#endif
+#ifdef YAFFS_COMPILE_FREEZER
+#include <linux/freezer.h>
+#endif
+
+#include <asm/div64.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
+#include <linux/statfs.h>
+
+#define UnlockPage(p) unlock_page(p)
+#define Page_Uptodate(page)	test_bit(PG_uptodate, &(page)->flags)
+
+/* FIXME: use sb->s_id instead ? */
+#define yaffs_devname(sb, buf)	bdevname(sb->s_bdev, buf)
+
+#else
+
+#include <linux/locks.h>
+#define	BDEVNAME_SIZE		0
+#define	yaffs_devname(sb, buf)	kdevname(sb->s_dev)
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0))
+/* added NCB 26/5/2006 for 2.4.25-vrs2-tcl1 kernel */
+#define __user
+#endif
+
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
+#define YPROC_ROOT  (&proc_root)
+#else
+#define YPROC_ROOT  NULL
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
+#define Y_INIT_TIMER(a)	init_timer(a)
+#else
+#define Y_INIT_TIMER(a)	init_timer_on_stack(a)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 27))
+#define YAFFS_USE_WRITE_BEGIN_END 1
+#else
+#define YAFFS_USE_WRITE_BEGIN_END 0
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0))
+#define YAFFS_SUPER_HAS_DIRTY
+#endif
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0))
+#define set_nlink(inode, count)  do { (inode)->i_nlink = (count); } while(0)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 28))
+static uint32_t YCALCBLOCKS(uint64_t partition_size, uint32_t block_size)
+{
+	uint64_t result = partition_size;
+	do_div(result, block_size);
+	return (uint32_t) result;
+}
+#else
+#define YCALCBLOCKS(s, b) ((s)/(b))
+#endif
+
+#include <linux/uaccess.h>
+#include <linux/mtd/mtd.h>
+
+#include "yportenv.h"
+#include "yaffs_trace.h"
+#include "yaffs_guts.h"
+#include "yaffs_attribs.h"
+
+#include "yaffs_linux.h"
+
+#include "yaffs_mtdif.h"
+
+unsigned int yaffs_trace_mask = YAFFS_TRACE_BAD_BLOCKS | YAFFS_TRACE_ALWAYS;
+unsigned int yaffs_wr_attempts = YAFFS_WR_ATTEMPTS;
+unsigned int yaffs_auto_checkpoint = 1;
+unsigned int yaffs_gc_control = 1;
+unsigned int yaffs_bg_enable = 1;
+unsigned int yaffs_auto_select = 1;
+/* Module Parameters */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+module_param(yaffs_trace_mask, uint, 0644);
+module_param(yaffs_wr_attempts, uint, 0644);
+module_param(yaffs_auto_checkpoint, uint, 0644);
+module_param(yaffs_gc_control, uint, 0644);
+module_param(yaffs_bg_enable, uint, 0644);
+#else
+MODULE_PARM(yaffs_trace_mask, "i");
+MODULE_PARM(yaffs_wr_attempts, "i");
+MODULE_PARM(yaffs_auto_checkpoint, "i");
+MODULE_PARM(yaffs_gc_control, "i");
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25))
+/* use iget and read_inode */
+#define Y_IGET(sb, inum) iget((sb), (inum))
+
+#else
+/* Call local equivalent */
+#define YAFFS_USE_OWN_IGET
+#define Y_IGET(sb, inum) yaffs_iget((sb), (inum))
+
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
+#define yaffs_inode_to_obj_lv(iptr) ((iptr)->i_private)
+#else
+#define yaffs_inode_to_obj_lv(iptr) ((iptr)->u.generic_ip)
+#endif
+
+#define yaffs_inode_to_obj(iptr) \
+	((struct yaffs_obj *)(yaffs_inode_to_obj_lv(iptr)))
+#define yaffs_dentry_to_obj(dptr) yaffs_inode_to_obj((dptr)->d_inode)
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+#define yaffs_super_to_dev(sb)	((struct yaffs_dev *)sb->s_fs_info)
+#else
+#define yaffs_super_to_dev(sb)	((struct yaffs_dev *)sb->u.generic_sbp)
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0))
+#define Y_CLEAR_INODE(i) clear_inode(i)
+#else
+#define Y_CLEAR_INODE(i) end_writeback(i)
+#endif
+
+
+#define update_dir_time(dir) do {\
+			(dir)->i_ctime = (dir)->i_mtime = CURRENT_TIME; \
+		} while (0)
+
+static void yaffs_fill_inode_from_obj(struct inode *inode,
+				      struct yaffs_obj *obj);
+
+
+static void yaffs_gross_lock(struct yaffs_dev *dev)
+{
+	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs locking %p", current);
+	mutex_lock(&(yaffs_dev_to_lc(dev)->gross_lock));
+	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs locked %p", current);
+}
+
+static void yaffs_gross_unlock(struct yaffs_dev *dev)
+{
+	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs unlocking %p", current);
+	mutex_unlock(&(yaffs_dev_to_lc(dev)->gross_lock));
+}
+
+
+static int yaffs_readpage_nolock(struct file *f, struct page *pg)
+{
+	/* Lifted from jffs2 */
+
+	struct yaffs_obj *obj;
+	unsigned char *pg_buf;
+	int ret;
+	loff_t pos = ((loff_t) pg->index) << PAGE_CACHE_SHIFT;
+	struct yaffs_dev *dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_readpage_nolock at %lld, size %08x",
+		(long long)pos,
+		(unsigned)PAGE_CACHE_SIZE);
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	BUG_ON(!PageLocked(pg));
+#else
+	if (!PageLocked(pg))
+		PAGE_BUG(pg);
+#endif
+
+	pg_buf = kmap(pg);
+	/* FIXME: Can kmap fail? */
+
+	yaffs_gross_lock(dev);
+
+	ret = yaffs_file_rd(obj, pg_buf, pos, PAGE_CACHE_SIZE);
+
+	yaffs_gross_unlock(dev);
+
+	if (ret >= 0)
+		ret = 0;
+
+	if (ret) {
+		ClearPageUptodate(pg);
+		SetPageError(pg);
+	} else {
+		SetPageUptodate(pg);
+		ClearPageError(pg);
+	}
+
+	flush_dcache_page(pg);
+	kunmap(pg);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage_nolock done");
+	return ret;
+}
+
+static int yaffs_readpage_unlock(struct file *f, struct page *pg)
+{
+	int ret = yaffs_readpage_nolock(f, pg);
+	UnlockPage(pg);
+	return ret;
+}
+
+static int yaffs_readpage(struct file *f, struct page *pg)
+{
+	int ret;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage");
+	ret = yaffs_readpage_unlock(f, pg);
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage done");
+	return ret;
+}
+
+
+static void yaffs_set_super_dirty_val(struct yaffs_dev *dev, int val)
+{
+	struct yaffs_linux_context *lc = yaffs_dev_to_lc(dev);
+
+	if (lc)
+		lc->dirty = val;
+
+# ifdef YAFFS_SUPER_HAS_DIRTY
+	{
+		struct super_block *sb = lc->super;
+
+		if (sb)
+			sb->s_dirt = val;
+	}
+#endif
+
+}
+
+static void yaffs_set_super_dirty(struct yaffs_dev *dev)
+{
+	yaffs_set_super_dirty_val(dev, 1);
+}
+
+static void yaffs_clear_super_dirty(struct yaffs_dev *dev)
+{
+	yaffs_set_super_dirty_val(dev, 0);
+}
+
+static int yaffs_check_super_dirty(struct yaffs_dev *dev)
+{
+	struct yaffs_linux_context *lc = yaffs_dev_to_lc(dev);
+
+	if (lc && lc->dirty)
+		return 1;
+
+# ifdef YAFFS_SUPER_HAS_DIRTY
+	{
+		struct super_block *sb = lc->super;
+
+		if (sb && sb->s_dirt)
+			return 1;
+	}
+#endif
+	return 0;
+
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_writepage(struct page *page, struct writeback_control *wbc)
+#else
+static int yaffs_writepage(struct page *page)
+#endif
+{
+	struct yaffs_dev *dev;
+	struct address_space *mapping = page->mapping;
+	struct inode *inode;
+	unsigned long end_index;
+	char *buffer;
+	struct yaffs_obj *obj;
+	int n_written = 0;
+	unsigned n_bytes;
+	loff_t i_size;
+
+	if (!mapping)
+		BUG();
+	inode = mapping->host;
+	if (!inode)
+		BUG();
+	i_size = i_size_read(inode);
+
+	end_index = i_size >> PAGE_CACHE_SHIFT;
+
+	if (page->index < end_index)
+		n_bytes = PAGE_CACHE_SIZE;
+	else {
+		n_bytes = i_size & (PAGE_CACHE_SIZE - 1);
+
+		if (page->index > end_index || !n_bytes) {
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_writepage at %lld, inode size = %lld!!",
+				((loff_t)page->index) << PAGE_CACHE_SHIFT,
+				inode->i_size);
+			yaffs_trace(YAFFS_TRACE_OS,
+				"                -> don't care!!");
+
+			zero_user_segment(page, 0, PAGE_CACHE_SIZE);
+			set_page_writeback(page);
+			unlock_page(page);
+			end_page_writeback(page);
+			return 0;
+		}
+	}
+
+	if (n_bytes != PAGE_CACHE_SIZE)
+		zero_user_segment(page, n_bytes, PAGE_CACHE_SIZE);
+
+	get_page(page);
+
+	buffer = kmap(page);
+
+	obj = yaffs_inode_to_obj(inode);
+	dev = obj->my_dev;
+	yaffs_gross_lock(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_writepage at %lld, size %08x",
+		((loff_t)page->index) << PAGE_CACHE_SHIFT, n_bytes);
+	yaffs_trace(YAFFS_TRACE_OS,
+		"writepag0: obj = %lld, ino = %lld",
+		obj->variant.file_variant.file_size, inode->i_size);
+
+	n_written = yaffs_wr_file(obj, buffer,
+				  ((loff_t)page->index) << PAGE_CACHE_SHIFT, n_bytes, 0);
+
+	yaffs_set_super_dirty(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"writepag1: obj = %lld, ino = %lld",
+		obj->variant.file_variant.file_size, inode->i_size);
+
+	yaffs_gross_unlock(dev);
+
+	kunmap(page);
+	set_page_writeback(page);
+	unlock_page(page);
+	end_page_writeback(page);
+	put_page(page);
+
+	return (n_written == n_bytes) ? 0 : -ENOSPC;
+}
+
+/* Space holding and freeing is done to ensure we have space available for write_begin/end */
+/* For now we just assume few parallel writes and check against a small number. */
+/* Todo: need to do this with a counter to handle parallel reads better */
+
+static ssize_t yaffs_hold_space(struct file *f)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+
+	int n_free_chunks;
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	n_free_chunks = yaffs_get_n_free_chunks(dev);
+
+	yaffs_gross_unlock(dev);
+
+	return (n_free_chunks > 20) ? 1 : 0;
+}
+
+static void yaffs_release_space(struct file *f)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	yaffs_gross_unlock(dev);
+}
+
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+			     loff_t pos, unsigned len, unsigned flags,
+			     struct page **pagep, void **fsdata)
+{
+	struct page *pg = NULL;
+	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
+
+	int ret = 0;
+	int space_held = 0;
+
+	/* Get a page */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+	pg = grab_cache_page_write_begin(mapping, index, flags);
+#else
+	pg = __grab_cache_page(mapping, index);
+#endif
+
+	*pagep = pg;
+	if (!pg) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	yaffs_trace(YAFFS_TRACE_OS,
+		"start yaffs_write_begin index %d(%x) uptodate %d",
+		(int)index, (int)index, Page_Uptodate(pg) ? 1 : 0);
+
+	/* Get fs space */
+	space_held = yaffs_hold_space(filp);
+
+	if (!space_held) {
+		ret = -ENOSPC;
+		goto out;
+	}
+
+	/* Update page if required */
+
+	if (!Page_Uptodate(pg))
+		ret = yaffs_readpage_nolock(filp, pg);
+
+	if (ret)
+		goto out;
+
+	/* Happy path return */
+	yaffs_trace(YAFFS_TRACE_OS, "end yaffs_write_begin - ok");
+
+	return 0;
+
+out:
+	yaffs_trace(YAFFS_TRACE_OS,
+		"end yaffs_write_begin fail returning %d", ret);
+	if (space_held)
+		yaffs_release_space(filp);
+	if (pg) {
+		unlock_page(pg);
+		page_cache_release(pg);
+	}
+	return ret;
+}
+
+#else
+
+static int yaffs_prepare_write(struct file *f, struct page *pg,
+			       unsigned offset, unsigned to)
+{
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_prepair_write");
+
+	if (!Page_Uptodate(pg))
+		return yaffs_readpage_nolock(f, pg);
+	return 0;
+}
+#endif
+
+
+static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
+				loff_t * pos)
+{
+	struct yaffs_obj *obj;
+	int n_written;
+	loff_t ipos;
+	struct inode *inode;
+	struct yaffs_dev *dev;
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	if (!obj) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_file_write: hey obj is null!");
+                return -EINVAL;
+        }
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	inode = f->f_dentry->d_inode;
+
+	if (!S_ISBLK(inode->i_mode) && f->f_flags & O_APPEND)
+		ipos = inode->i_size;
+	else
+		ipos = *pos;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_write about to write writing %u(%x) bytes to object %d at %lld",
+		(unsigned)n, (unsigned)n, obj->obj_id, ipos);
+
+	n_written = yaffs_wr_file(obj, buf, ipos, n, 0);
+
+	yaffs_set_super_dirty(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_write: %d(%x) bytes written",
+		(unsigned)n, (unsigned)n);
+
+	if (n_written > 0) {
+		ipos += n_written;
+		*pos = ipos;
+		if (ipos > inode->i_size) {
+			inode->i_size = ipos;
+			inode->i_blocks = (ipos + 511) >> 9;
+
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_file_write size updated to %lld bytes, %d blocks",
+				ipos, (int)(inode->i_blocks));
+		}
+
+	}
+	yaffs_gross_unlock(dev);
+	return (n_written == 0) && (n > 0) ? -ENOSPC : n_written;
+}
+
+
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+			   loff_t pos, unsigned len, unsigned copied,
+			   struct page *pg, void *fsdadata)
+{
+	int ret = 0;
+	void *addr, *kva;
+	uint32_t offset_into_page = pos & (PAGE_CACHE_SIZE - 1);
+
+	kva = kmap(pg);
+	addr = kva + offset_into_page;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_write_end addr %p pos %lld n_bytes %d",
+		addr, pos, copied);
+
+	ret = yaffs_file_write(filp, addr, copied, &pos);
+
+	if (ret != copied) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_write_end not same size ret %d  copied %d",
+			ret, copied);
+		SetPageError(pg);
+	}
+
+	kunmap(pg);
+
+	yaffs_release_space(filp);
+	unlock_page(pg);
+	page_cache_release(pg);
+	return ret;
+}
+#else
+
+static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,
+			      unsigned to)
+{
+	void *addr, *kva;
+
+	loff_t pos = (((loff_t) pg->index) << PAGE_CACHE_SHIFT) + offset;
+	int n_bytes = to - offset;
+	int n_written;
+
+	kva = kmap(pg);
+	addr = kva + offset;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_commit_write addr %p pos %lld n_bytes %d",
+		addr, pos, n_bytes);
+
+	n_written = yaffs_file_write(f, addr, n_bytes, &pos);
+
+	if (n_written != n_bytes) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_commit_write not same size n_written %d  n_bytes %d",
+			n_written, n_bytes);
+		SetPageError(pg);
+	}
+	kunmap(pg);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_commit_write returning %d",
+		n_written == n_bytes ? 0 : n_written);
+
+	return n_written == n_bytes ? 0 : n_written;
+}
+#endif
+
+static struct address_space_operations yaffs_file_address_operations = {
+	.readpage = yaffs_readpage,
+	.writepage = yaffs_writepage,
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+	.write_begin = yaffs_write_begin,
+	.write_end = yaffs_write_end,
+#else
+	.prepare_write = yaffs_prepare_write,
+	.commit_write = yaffs_commit_write,
+#endif
+};
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_file_flush(struct file *file, fl_owner_t id)
+#else
+static int yaffs_file_flush(struct file *file)
+#endif
+{
+	struct yaffs_obj *obj = yaffs_dentry_to_obj(file->f_dentry);
+
+	struct yaffs_dev *dev = obj->my_dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_flush object %d (%s)",
+		obj->obj_id,
+		obj->dirty ? "dirty" : "clean");
+
+	yaffs_gross_lock(dev);
+
+	yaffs_flush_file(obj, 1, 0);
+
+	yaffs_gross_unlock(dev);
+
+	return 0;
+}
+
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+static int yaffs_sync_object(struct file *file, loff_t start, loff_t end, int datasync)
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
+static int yaffs_sync_object(struct file *file, int datasync)
+#else
+static int yaffs_sync_object(struct file *file, struct dentry *dentry,
+			     int datasync)
+#endif
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
+	struct dentry *dentry = file->f_path.dentry;
+#endif
+
+	obj = yaffs_dentry_to_obj(dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC,
+		"yaffs_sync_object");
+	yaffs_gross_lock(dev);
+	yaffs_flush_file(obj, 1, datasync);
+	yaffs_gross_unlock(dev);
+	return 0;
+}
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22))
+static const struct file_operations yaffs_file_operations = {
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = generic_file_aio_read,
+	.aio_write = generic_file_aio_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+	.splice_read = generic_file_splice_read,
+	.splice_write = generic_file_splice_write,
+	.llseek = generic_file_llseek,
+};
+
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
+
+static const struct file_operations yaffs_file_operations = {
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = generic_file_aio_read,
+	.aio_write = generic_file_aio_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+	.sendfile = generic_file_sendfile,
+};
+
+#else
+
+static const struct file_operations yaffs_file_operations = {
+	.read = generic_file_read,
+	.write = generic_file_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	.sendfile = generic_file_sendfile,
+#endif
+};
+#endif
+
+
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25))
+static void zero_user_segment(struct page *page, unsigned start, unsigned end)
+{
+	void *kaddr = kmap_atomic(page, KM_USER0);
+	memset(kaddr + start, 0, end - start);
+	kunmap_atomic(kaddr, KM_USER0);
+	flush_dcache_page(page);
+}
+#endif
+
+
+static int yaffs_vfs_setsize(struct inode *inode, loff_t newsize)
+{
+#ifdef YAFFS_USE_TRUNCATE_SETSIZE
+	truncate_setsize(inode, newsize);
+	return 0;
+#else
+	truncate_inode_pages(&inode->i_data, newsize);
+	return 0;
+#endif
+
+}
+
+
+static int yaffs_vfs_setattr(struct inode *inode, struct iattr *attr)
+{
+#ifdef YAFFS_USE_SETATTR_COPY
+	setattr_copy(inode, attr);
+	return 0;
+#else
+	return inode_setattr(inode, attr);
+#endif
+
+}
+
+static int yaffs_setattr(struct dentry *dentry, struct iattr *attr)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_setattr of object %d",
+		yaffs_inode_to_obj(inode)->obj_id);
+#if 0
+	/* Fail if a requested resize >= 2GB */
+	if (attr->ia_valid & ATTR_SIZE && (attr->ia_size >> 31))
+		error = -EINVAL;
+#endif
+
+	if (error == 0)
+		error = inode_change_ok(inode, attr);
+	if (error == 0) {
+		int result;
+		if (!error) {
+			error = yaffs_vfs_setattr(inode, attr);
+			yaffs_trace(YAFFS_TRACE_OS, "inode_setattr called");
+			if (attr->ia_valid & ATTR_SIZE) {
+				yaffs_vfs_setsize(inode, attr->ia_size);
+				inode->i_blocks = (inode->i_size + 511) >> 9;
+			}
+		}
+		dev = yaffs_inode_to_obj(inode)->my_dev;
+		if (attr->ia_valid & ATTR_SIZE) {
+			yaffs_trace(YAFFS_TRACE_OS,
+				"resize to %d(%x)",
+				(int)(attr->ia_size),
+				(int)(attr->ia_size));
+		}
+		yaffs_gross_lock(dev);
+		result = yaffs_set_attribs(yaffs_inode_to_obj(inode), attr);
+		if (result == YAFFS_OK) {
+			error = 0;
+		} else {
+			error = -EPERM;
+		}
+		yaffs_gross_unlock(dev);
+
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setattr done returning %d", error);
+
+	return error;
+}
+
+static int yaffs_setxattr(struct dentry *dentry, const char *name,
+		   const void *value, size_t size, int flags)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setxattr of object %d", obj->obj_id);
+
+	if (error == 0) {
+		int result;
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		result = yaffs_set_xattrib(obj, name, value, size, flags);
+		if (result == YAFFS_OK)
+			error = 0;
+		else if (result < 0)
+			error = result;
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setxattr done returning %d", error);
+
+	return error;
+}
+
+static ssize_t yaffs_getxattr(struct dentry * dentry, const char *name,
+			void *buff, size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_getxattr \"%s\" from object %d",
+		name, obj->obj_id);
+
+	if (error == 0) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		error = yaffs_get_xattrib(obj, name, buff, size);
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_getxattr done returning %d", error);
+
+	return error;
+}
+
+static int yaffs_removexattr(struct dentry *dentry, const char *name)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_removexattr of object %d", obj->obj_id);
+
+	if (error == 0) {
+		int result;
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		result = yaffs_remove_xattrib(obj, name);
+		if (result == YAFFS_OK)
+			error = 0;
+		else if (result < 0)
+			error = result;
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_removexattr done returning %d", error);
+
+	return error;
+}
+
+static ssize_t yaffs_listxattr(struct dentry * dentry, char *buff, size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_listxattr of object %d", obj->obj_id);
+
+	if (error == 0) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		error = yaffs_list_xattrib(obj, buff, size);
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_listxattr done returning %d", error);
+
+	return error;
+}
+
+
+static const struct inode_operations yaffs_file_inode_operations = {
+	.setattr = yaffs_setattr,
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+};
+
+
+static int yaffs_readlink(struct dentry *dentry, char __user * buffer,
+			  int buflen)
+{
+	unsigned char *alias;
+	int ret;
+
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	alias = yaffs_get_symlink_alias(yaffs_dentry_to_obj(dentry));
+
+	yaffs_gross_unlock(dev);
+
+	if (!alias)
+		return -ENOMEM;
+
+	ret = vfs_readlink(dentry, buffer, buflen, alias);
+	kfree(alias);
+	return ret;
+}
+
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	void *ret;
+#else
+static int yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	int ret
+#endif
+	unsigned char *alias;
+	int ret_int = 0;
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	alias = yaffs_get_symlink_alias(yaffs_dentry_to_obj(dentry));
+	yaffs_gross_unlock(dev);
+
+	if (!alias) {
+		ret_int = -ENOMEM;
+		goto out;
+	}
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+	nd_set_link(nd, alias);
+	ret = alias;
+out:
+	if (ret_int)
+		ret = ERR_PTR(ret_int);
+	return ret;
+#else
+	ret = vfs_follow_link(nd, alias);
+	kfree(alias);
+out:
+	if (ret_int)
+		ret = ret_int;
+	return ret;
+#endif
+}
+
+
+#ifdef YAFFS_HAS_PUT_INODE
+
+/* For now put inode is just for debugging
+ * Put inode is called when the inode **structure** is put.
+ */
+static void yaffs_put_inode(struct inode *inode)
+{
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_put_inode: ino %d, count %d"),
+		(int)inode->i_ino, atomic_read(&inode->i_count);
+
+}
+#endif
+
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+void yaffs_put_link(struct dentry *dentry, struct nameidata *nd, void *alias)
+{
+	kfree(alias);
+}
+#endif
+
+static const struct inode_operations yaffs_symlink_inode_operations = {
+	.readlink = yaffs_readlink,
+	.follow_link = yaffs_follow_link,
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+	.put_link = yaffs_put_link,
+#endif
+	.setattr = yaffs_setattr,
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+};
+
+#ifdef YAFFS_USE_OWN_IGET
+
+static struct inode *yaffs_iget(struct super_block *sb, unsigned long ino)
+{
+	struct inode *inode;
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_iget for %lu", ino);
+
+	inode = iget_locked(sb, ino);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+	if (!(inode->i_state & I_NEW))
+		return inode;
+
+	/* NB This is called as a side effect of other functions, but
+	 * we had to release the lock to prevent deadlocks, so
+	 * need to lock again.
+	 */
+
+	yaffs_gross_lock(dev);
+
+	obj = yaffs_find_by_number(dev, inode->i_ino);
+
+	yaffs_fill_inode_from_obj(inode, obj);
+
+	yaffs_gross_unlock(dev);
+
+	unlock_new_inode(inode);
+	return inode;
+}
+
+#else
+
+static void yaffs_read_inode(struct inode *inode)
+{
+	/* NB This is called as a side effect of other functions, but
+	 * we had to release the lock to prevent deadlocks, so
+	 * need to lock again.
+	 */
+
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev = yaffs_super_to_dev(inode->i_sb);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_inode for %d", (int)inode->i_ino);
+
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_lock(dev);
+
+	obj = yaffs_find_by_number(dev, inode->i_ino);
+
+	yaffs_fill_inode_from_obj(inode, obj);
+
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_unlock(dev);
+}
+
+#endif
+
+
+
+struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,
+			      struct yaffs_obj *obj)
+{
+	struct inode *inode;
+
+	if (!sb) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_get_inode for NULL super_block!!");
+		return NULL;
+
+	}
+
+	if (!obj) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_get_inode for NULL object!!");
+		return NULL;
+
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_get_inode for object %d", obj->obj_id);
+
+	inode = Y_IGET(sb, obj->obj_id);
+	if (IS_ERR(inode))
+		return NULL;
+
+	/* NB Side effect: iget calls back to yaffs_read_inode(). */
+	/* iget also increments the inode's i_count */
+	/* NB You can't be holding gross_lock or deadlock will happen! */
+
+	return inode;
+}
+
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
+#define YCRED(x) x
+#else
+#define YCRED(x) (x->cred)
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,
+		       dev_t rdev)
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       dev_t rdev)
+#else
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       int rdev)
+#endif
+{
+	struct inode *inode;
+
+	struct yaffs_obj *obj = NULL;
+	struct yaffs_dev *dev;
+
+	struct yaffs_obj *parent = yaffs_inode_to_obj(dir);
+
+	int error = -ENOSPC;
+	uid_t uid = YCRED(current)->fsuid;
+	gid_t gid =
+	    (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
+
+	if ((dir->i_mode & S_ISGID) && S_ISDIR(mode))
+		mode |= S_ISGID;
+
+	if (parent) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod: parent object %d type %d",
+			parent->obj_id, parent->variant_type);
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod: could not get parent object");
+		return -EPERM;
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_mknod: making oject for %s, mode %x dev %x",
+		dentry->d_name.name, mode, rdev);
+
+	dev = parent->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	switch (mode & S_IFMT) {
+	default:
+		/* Special (socket, fifo, device...) */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making special");
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+		obj =
+		    yaffs_create_special(parent, dentry->d_name.name, mode, uid,
+					 gid, old_encode_dev(rdev));
+#else
+		obj =
+		    yaffs_create_special(parent, dentry->d_name.name, mode, uid,
+					 gid, rdev);
+#endif
+		break;
+	case S_IFREG:		/* file          */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making file");
+		obj = yaffs_create_file(parent, dentry->d_name.name, mode, uid,
+					gid);
+		break;
+	case S_IFDIR:		/* directory */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making directory");
+		obj = yaffs_create_dir(parent, dentry->d_name.name, mode,
+				       uid, gid);
+		break;
+	case S_IFLNK:		/* symlink */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making symlink");
+		obj = NULL;	/* Do we ever get here? */
+		break;
+	}
+
+	/* Can not call yaffs_get_inode() with gross lock held */
+	yaffs_gross_unlock(dev);
+
+	if (obj) {
+		inode = yaffs_get_inode(dir->i_sb, mode, rdev, obj);
+		d_instantiate(dentry, inode);
+		update_dir_time(dir);
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod created object %d count = %d",
+			obj->obj_id, atomic_read(&inode->i_count));
+		error = 0;
+		yaffs_fill_inode_from_obj(dir, parent);
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod failed making object");
+		error = -ENOMEM;
+	}
+
+	return error;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
+#else
+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+#endif
+{
+	int ret_val;
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_mkdir");
+	ret_val = yaffs_mknod(dir, dentry, mode | S_IFDIR, 0);
+	return ret_val;
+}
+
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
+static int yaffs_create(struct inode *dir, struct dentry *dentry, umode_t mode,
+			bool dummy)
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
+static int yaffs_create(struct inode *dir, struct dentry *dentry, umode_t mode,
+			struct nameidata *n)
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
+			struct nameidata *n)
+#else
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode)
+#endif
+{
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_create");
+	return yaffs_mknod(dir, dentry, mode | S_IFREG, 0);
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+				   unsigned int dummy)
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+				   struct nameidata *n)
+#else
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry)
+#endif
+{
+	struct yaffs_obj *obj;
+	struct inode *inode = NULL;	/* NCB 2.5/2.6 needs NULL here */
+
+	struct yaffs_dev *dev = yaffs_inode_to_obj(dir)->my_dev;
+
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_lock(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_lookup for %d:%s",
+		yaffs_inode_to_obj(dir)->obj_id, dentry->d_name.name);
+
+	obj = yaffs_find_by_name(yaffs_inode_to_obj(dir), dentry->d_name.name);
+
+	obj = yaffs_get_equivalent_obj(obj);	/* in case it was a hardlink */
+
+	/* Can't hold gross lock when calling yaffs_get_inode() */
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_unlock(dev);
+
+	if (obj) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_lookup found %d", obj->obj_id);
+
+		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_lookup not found");
+
+	}
+
+/* added NCB for 2.5/6 compatability - forces add even if inode is
+ * NULL which creates dentry hash */
+	d_add(dentry, inode);
+
+	return NULL;
+}
+
+/*
+ * Create a link...
+ */
+static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
+		      struct dentry *dentry)
+{
+	struct inode *inode = old_dentry->d_inode;
+	struct yaffs_obj *obj = NULL;
+	struct yaffs_obj *link = NULL;
+	struct yaffs_dev *dev;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_link");
+
+	obj = yaffs_inode_to_obj(inode);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	if (!S_ISDIR(inode->i_mode))	/* Don't link directories */
+		link =
+		    yaffs_link_obj(yaffs_inode_to_obj(dir), dentry->d_name.name,
+				   obj);
+
+	if (link) {
+		set_nlink(old_dentry->d_inode, yaffs_get_obj_link_count(obj));
+		d_instantiate(dentry, old_dentry->d_inode);
+		atomic_inc(&old_dentry->d_inode->i_count);
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_link link count %d i_count %d",
+			old_dentry->d_inode->i_nlink,
+			atomic_read(&old_dentry->d_inode->i_count));
+	}
+
+	yaffs_gross_unlock(dev);
+
+	if (link) {
+		update_dir_time(dir);
+		return 0;
+	}
+
+	return -EPERM;
+}
+
+static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
+			 const char *symname)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	uid_t uid = YCRED(current)->fsuid;
+	gid_t gid =
+	    (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_symlink");
+
+	if (strnlen(dentry->d_name.name, YAFFS_MAX_NAME_LENGTH + 1) >
+				YAFFS_MAX_NAME_LENGTH)
+		return -ENAMETOOLONG;
+
+	if (strnlen(symname, YAFFS_MAX_ALIAS_LENGTH + 1) >
+				YAFFS_MAX_ALIAS_LENGTH)
+		return -ENAMETOOLONG;
+
+	dev = yaffs_inode_to_obj(dir)->my_dev;
+	yaffs_gross_lock(dev);
+	obj = yaffs_create_symlink(yaffs_inode_to_obj(dir), dentry->d_name.name,
+				   S_IFLNK | S_IRWXUGO, uid, gid, symname);
+	yaffs_gross_unlock(dev);
+
+	if (obj) {
+		struct inode *inode;
+
+		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+		d_instantiate(dentry, inode);
+		update_dir_time(dir);
+		yaffs_trace(YAFFS_TRACE_OS, "symlink created OK");
+		return 0;
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS, "symlink not created");
+	}
+
+	return -ENOMEM;
+}
+
+/*
+ * The VFS layer already does all the dentry stuff for rename.
+ *
+ * NB: POSIX says you can rename an object over an old object of the same name
+ */
+static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			struct inode *new_dir, struct dentry *new_dentry)
+{
+	struct yaffs_dev *dev;
+	int ret_val = YAFFS_FAIL;
+	struct yaffs_obj *target;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_rename");
+	dev = yaffs_inode_to_obj(old_dir)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	/* Check if the target is an existing directory that is not empty. */
+	target = yaffs_find_by_name(yaffs_inode_to_obj(new_dir),
+				    new_dentry->d_name.name);
+
+	if (target && target->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY &&
+	    !list_empty(&target->variant.dir_variant.children)) {
+
+		yaffs_trace(YAFFS_TRACE_OS, "target is non-empty dir");
+
+		ret_val = YAFFS_FAIL;
+	} else {
+		/* Now does unlinking internally using shadowing mechanism */
+		yaffs_trace(YAFFS_TRACE_OS, "calling yaffs_rename_obj");
+
+		ret_val = yaffs_rename_obj(yaffs_inode_to_obj(old_dir),
+					   old_dentry->d_name.name,
+					   yaffs_inode_to_obj(new_dir),
+					   new_dentry->d_name.name);
+	}
+	yaffs_gross_unlock(dev);
+
+	if (ret_val == YAFFS_OK) {
+		if (target)
+			inode_dec_link_count(new_dentry->d_inode);
+
+		update_dir_time(old_dir);
+		if (old_dir != new_dir)
+			update_dir_time(new_dir);
+		return 0;
+	} else {
+		return -ENOTEMPTY;
+	}
+}
+
+
+
+
+static int yaffs_unlink(struct inode *dir, struct dentry *dentry)
+{
+	int ret_val;
+
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_unlink %d:%s",
+		(int)(dir->i_ino), dentry->d_name.name);
+	obj = yaffs_inode_to_obj(dir);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	ret_val = yaffs_unlinker(obj, dentry->d_name.name);
+
+	if (ret_val == YAFFS_OK) {
+		inode_dec_link_count(dentry->d_inode);
+		dir->i_version++;
+		yaffs_gross_unlock(dev);
+		update_dir_time(dir);
+		return 0;
+	}
+	yaffs_gross_unlock(dev);
+	return -ENOTEMPTY;
+}
+
+
+
+static const struct inode_operations yaffs_dir_inode_operations = {
+	.create = yaffs_create,
+	.lookup = yaffs_lookup,
+	.link = yaffs_link,
+	.unlink = yaffs_unlink,
+	.symlink = yaffs_symlink,
+	.mkdir = yaffs_mkdir,
+	.rmdir = yaffs_unlink,
+	.mknod = yaffs_mknod,
+	.rename = yaffs_rename,
+	.setattr = yaffs_setattr,
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+};
+
+/*-----------------------------------------------------------------*/
+/* Directory search context allows us to unlock access to yaffs during
+ * filldir without causing problems with the directory being modified.
+ * This is similar to the tried and tested mechanism used in yaffs direct.
+ *
+ * A search context iterates along a doubly linked list of siblings in the
+ * directory. If the iterating object is deleted then this would corrupt
+ * the list iteration, likely causing a crash. The search context avoids
+ * this by using the remove_obj_fn to move the search context to the
+ * next object before the object is deleted.
+ *
+ * Many readdirs (and thus seach conexts) may be alive simulateously so
+ * each struct yaffs_dev has a list of these.
+ *
+ * A seach context lives for the duration of a readdir.
+ *
+ * All these functions must be called while yaffs is locked.
+ */
+
+struct yaffs_search_context {
+	struct yaffs_dev *dev;
+	struct yaffs_obj *dir_obj;
+	struct yaffs_obj *next_return;
+	struct list_head others;
+};
+
+/*
+ * yaffs_new_search() creates a new search context, initialises it and
+ * adds it to the device's search context list.
+ *
+ * Called at start of readdir.
+ */
+static struct yaffs_search_context *yaffs_new_search(struct yaffs_obj *dir)
+{
+	struct yaffs_dev *dev = dir->my_dev;
+	struct yaffs_search_context *sc =
+	    kmalloc(sizeof(struct yaffs_search_context), GFP_NOFS);
+	if (sc) {
+		sc->dir_obj = dir;
+		sc->dev = dev;
+		if (list_empty(&sc->dir_obj->variant.dir_variant.children))
+			sc->next_return = NULL;
+		else
+			sc->next_return =
+			    list_entry(dir->variant.dir_variant.children.next,
+				       struct yaffs_obj, siblings);
+		INIT_LIST_HEAD(&sc->others);
+		list_add(&sc->others, &(yaffs_dev_to_lc(dev)->search_contexts));
+	}
+	return sc;
+}
+
+/*
+ * yaffs_search_end() disposes of a search context and cleans up.
+ */
+static void yaffs_search_end(struct yaffs_search_context *sc)
+{
+	if (sc) {
+		list_del(&sc->others);
+		kfree(sc);
+	}
+}
+
+/*
+ * yaffs_search_advance() moves a search context to the next object.
+ * Called when the search iterates or when an object removal causes
+ * the search context to be moved to the next object.
+ */
+static void yaffs_search_advance(struct yaffs_search_context *sc)
+{
+	if (!sc)
+		return;
+
+	if (sc->next_return == NULL ||
+	    list_empty(&sc->dir_obj->variant.dir_variant.children))
+		sc->next_return = NULL;
+	else {
+		struct list_head *next = sc->next_return->siblings.next;
+
+		if (next == &sc->dir_obj->variant.dir_variant.children)
+			sc->next_return = NULL;	/* end of list */
+		else
+			sc->next_return =
+			    list_entry(next, struct yaffs_obj, siblings);
+	}
+}
+
+/*
+ * yaffs_remove_obj_callback() is called when an object is unlinked.
+ * We check open search contexts and advance any which are currently
+ * on the object being iterated.
+ */
+static void yaffs_remove_obj_callback(struct yaffs_obj *obj)
+{
+
+	struct list_head *i;
+	struct yaffs_search_context *sc;
+	struct list_head *search_contexts =
+	    &(yaffs_dev_to_lc(obj->my_dev)->search_contexts);
+
+	/* Iterate through the directory search contexts.
+	 * If any are currently on the object being removed, then advance
+	 * the search context to the next object to prevent a hanging pointer.
+	 */
+	list_for_each(i, search_contexts) {
+		sc = list_entry(i, struct yaffs_search_context, others);
+		if (sc->next_return == obj)
+			yaffs_search_advance(sc);
+	}
+
+}
+
+
+/*-----------------------------------------------------------------*/
+
+static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	struct yaffs_search_context *sc;
+	struct inode *inode = f->f_dentry->d_inode;
+	unsigned long offset, curoffs;
+	struct yaffs_obj *l;
+	int ret_val = 0;
+
+	char name[YAFFS_MAX_NAME_LENGTH + 1];
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	yaffs_dev_to_lc(dev)->readdir_process = current;
+
+	offset = f->f_pos;
+
+	sc = yaffs_new_search(obj);
+	if (!sc) {
+		ret_val = -ENOMEM;
+		goto out;
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_readdir: starting at %d", (int)offset);
+
+	if (offset == 0) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_readdir: entry . ino %d",
+			(int)inode->i_ino);
+		yaffs_gross_unlock(dev);
+		if (filldir(dirent, ".", 1, offset, inode->i_ino, DT_DIR) < 0) {
+			yaffs_gross_lock(dev);
+			goto out;
+		}
+		yaffs_gross_lock(dev);
+		offset++;
+		f->f_pos++;
+	}
+	if (offset == 1) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_readdir: entry .. ino %d",
+			(int)f->f_dentry->d_parent->d_inode->i_ino);
+		yaffs_gross_unlock(dev);
+		if (filldir(dirent, "..", 2, offset,
+			    f->f_dentry->d_parent->d_inode->i_ino,
+			    DT_DIR) < 0) {
+			yaffs_gross_lock(dev);
+			goto out;
+		}
+		yaffs_gross_lock(dev);
+		offset++;
+		f->f_pos++;
+	}
+
+	curoffs = 1;
+
+	/* If the directory has changed since the open or last call to
+	   readdir, rewind to after the 2 canned entries. */
+	if (f->f_version != inode->i_version) {
+		offset = 2;
+		f->f_pos = offset;
+		f->f_version = inode->i_version;
+	}
+
+	while (sc->next_return) {
+		curoffs++;
+		l = sc->next_return;
+		if (curoffs >= offset) {
+			int this_inode = yaffs_get_obj_inode(l);
+			int this_type = yaffs_get_obj_type(l);
+
+			yaffs_get_obj_name(l, name, YAFFS_MAX_NAME_LENGTH + 1);
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_readdir: %s inode %d",
+				name, yaffs_get_obj_inode(l));
+
+			yaffs_gross_unlock(dev);
+
+			if (filldir(dirent,
+				    name,
+				    strlen(name),
+				    offset, this_inode, this_type) < 0) {
+				yaffs_gross_lock(dev);
+				goto out;
+			}
+
+			yaffs_gross_lock(dev);
+
+			offset++;
+			f->f_pos++;
+		}
+		yaffs_search_advance(sc);
+	}
+
+out:
+	yaffs_search_end(sc);
+	yaffs_dev_to_lc(dev)->readdir_process = NULL;
+	yaffs_gross_unlock(dev);
+
+	return ret_val;
+}
+
+static const struct file_operations yaffs_dir_operations = {
+	.read = generic_read_dir,
+	.readdir = yaffs_readdir,
+	.fsync = yaffs_sync_object,
+	.llseek = generic_file_llseek,
+};
+
+static void yaffs_fill_inode_from_obj(struct inode *inode,
+				      struct yaffs_obj *obj)
+{
+	if (inode && obj) {
+
+		/* Check mode against the variant type and attempt to repair if broken. */
+		u32 mode = obj->yst_mode;
+		switch (obj->variant_type) {
+		case YAFFS_OBJECT_TYPE_FILE:
+			if (!S_ISREG(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFREG;
+			}
+
+			break;
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+			if (!S_ISLNK(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFLNK;
+			}
+
+			break;
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+			if (!S_ISDIR(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFDIR;
+			}
+
+			break;
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+		default:
+			/* TODO? */
+			break;
+		}
+
+		inode->i_flags |= S_NOATIME;
+
+		inode->i_ino = obj->obj_id;
+		inode->i_mode = obj->yst_mode;
+		inode->i_uid = obj->yst_uid;
+		inode->i_gid = obj->yst_gid;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+		inode->i_blksize = inode->i_sb->s_blocksize;
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
+		inode->i_rdev = old_decode_dev(obj->yst_rdev);
+		inode->i_atime.tv_sec = (time_t) (obj->yst_atime);
+		inode->i_atime.tv_nsec = 0;
+		inode->i_mtime.tv_sec = (time_t) obj->yst_mtime;
+		inode->i_mtime.tv_nsec = 0;
+		inode->i_ctime.tv_sec = (time_t) obj->yst_ctime;
+		inode->i_ctime.tv_nsec = 0;
+#else
+		inode->i_rdev = obj->yst_rdev;
+		inode->i_atime = obj->yst_atime;
+		inode->i_mtime = obj->yst_mtime;
+		inode->i_ctime = obj->yst_ctime;
+#endif
+		inode->i_size = yaffs_get_obj_length(obj);
+		inode->i_blocks = (inode->i_size + 511) >> 9;
+
+		set_nlink(inode, yaffs_get_obj_link_count(obj));
+
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_fill_inode mode %x uid %d gid %d size %lld count %d",
+			inode->i_mode, inode->i_uid, inode->i_gid,
+			inode->i_size, atomic_read(&inode->i_count));
+
+		switch (obj->yst_mode & S_IFMT) {
+		default:	/* fifo, device or socket */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+			init_special_inode(inode, obj->yst_mode,
+					   old_decode_dev(obj->yst_rdev));
+#else
+			init_special_inode(inode, obj->yst_mode,
+					   (dev_t) (obj->yst_rdev));
+#endif
+			break;
+		case S_IFREG:	/* file */
+			inode->i_op = &yaffs_file_inode_operations;
+			inode->i_fop = &yaffs_file_operations;
+			inode->i_mapping->a_ops =
+			    &yaffs_file_address_operations;
+			break;
+		case S_IFDIR:	/* directory */
+			inode->i_op = &yaffs_dir_inode_operations;
+			inode->i_fop = &yaffs_dir_operations;
+			break;
+		case S_IFLNK:	/* symlink */
+			inode->i_op = &yaffs_symlink_inode_operations;
+			break;
+		}
+
+		yaffs_inode_to_obj_lv(inode) = obj;
+
+		obj->my_inode = inode;
+
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_fill_inode invalid parameters");
+	}
+
+}
+
+
+
+/*
+ * yaffs background thread functions .
+ * yaffs_bg_thread_fn() the thread function
+ * yaffs_bg_start() launches the background thread.
+ * yaffs_bg_stop() cleans up the background thread.
+ *
+ * NB:
+ * The thread should only run after the yaffs is initialised
+ * The thread should be stopped before yaffs is unmounted.
+ * The thread should not do any writing while the fs is in read only.
+ */
+
+static unsigned yaffs_bg_gc_urgency(struct yaffs_dev *dev)
+{
+	unsigned erased_chunks =
+	    dev->n_erased_blocks * dev->param.chunks_per_block;
+	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
+	unsigned scattered = 0;	/* Free chunks not in an erased block */
+
+	if (erased_chunks < dev->n_free_chunks)
+		scattered = (dev->n_free_chunks - erased_chunks);
+
+	if (!context->bg_running)
+		return 0;
+	else if (scattered < (dev->param.chunks_per_block * 2))
+		return 0;
+	else if (erased_chunks > dev->n_free_chunks / 2)
+		return 0;
+	else if (erased_chunks > dev->n_free_chunks / 4)
+		return 1;
+	else
+		return 2;
+}
+
+#ifdef YAFFS_COMPILE_BACKGROUND
+
+void yaffs_background_waker(unsigned long data)
+{
+	wake_up_process((struct task_struct *)data);
+}
+
+static int yaffs_bg_thread_fn(void *data)
+{
+	struct yaffs_dev *dev = (struct yaffs_dev *)data;
+	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
+	unsigned long now = jiffies;
+	unsigned long next_dir_update = now;
+	unsigned long next_gc = now;
+	unsigned long expires;
+	unsigned int urgency;
+
+	int gc_result;
+	struct timer_list timer;
+
+	yaffs_trace(YAFFS_TRACE_BACKGROUND,
+		"yaffs_background starting for dev %p", (void *)dev);
+
+#ifdef YAFFS_COMPILE_FREEZER
+	set_freezable();
+#endif
+	while (context->bg_running) {
+		yaffs_trace(YAFFS_TRACE_BACKGROUND, "yaffs_background");
+
+		if (kthread_should_stop())
+			break;
+
+#ifdef YAFFS_COMPILE_FREEZER
+		if (try_to_freeze())
+			continue;
+#endif
+		yaffs_gross_lock(dev);
+
+		now = jiffies;
+
+		if (time_after(now, next_dir_update) && yaffs_bg_enable) {
+			yaffs_update_dirty_dirs(dev);
+			next_dir_update = now + HZ;
+		}
+
+		if (time_after(now, next_gc) && yaffs_bg_enable) {
+			if (!dev->is_checkpointed) {
+				urgency = yaffs_bg_gc_urgency(dev);
+				gc_result = yaffs_bg_gc(dev, urgency);
+				if (urgency > 1)
+					next_gc = now + HZ / 20 + 1;
+				else if (urgency > 0)
+					next_gc = now + HZ / 10 + 1;
+				else
+					next_gc = now + HZ * 2;
+			} else	{
+			        /*
+				 * gc not running so set to next_dir_update
+				 * to cut down on wake ups
+				 */
+				next_gc = next_dir_update;
+                        }
+		}
+		yaffs_gross_unlock(dev);
+#if 1
+		expires = next_dir_update;
+		if (time_before(next_gc, expires))
+			expires = next_gc;
+		if (time_before(expires, now))
+			expires = now + HZ;
+
+		Y_INIT_TIMER(&timer);
+		timer.expires = expires + 1;
+		timer.data = (unsigned long)current;
+		timer.function = yaffs_background_waker;
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_timer(&timer);
+		schedule();
+		del_timer_sync(&timer);
+#else
+		msleep(10);
+#endif
+	}
+
+	return 0;
+}
+
+static int yaffs_bg_start(struct yaffs_dev *dev)
+{
+	int retval = 0;
+	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
+
+	if (dev->read_only)
+		return -1;
+
+	context->bg_running = 1;
+
+	context->bg_thread = kthread_run(yaffs_bg_thread_fn,
+					 (void *)dev, "yaffs-bg-%d",
+					 context->mount_id);
+
+	if (IS_ERR(context->bg_thread)) {
+		retval = PTR_ERR(context->bg_thread);
+		context->bg_thread = NULL;
+		context->bg_running = 0;
+	}
+	return retval;
+}
+
+static void yaffs_bg_stop(struct yaffs_dev *dev)
+{
+	struct yaffs_linux_context *ctxt = yaffs_dev_to_lc(dev);
+
+	ctxt->bg_running = 0;
+
+	if (ctxt->bg_thread) {
+		kthread_stop(ctxt->bg_thread);
+		ctxt->bg_thread = NULL;
+	}
+}
+#else
+static int yaffs_bg_thread_fn(void *data)
+{
+	return 0;
+}
+
+static int yaffs_bg_start(struct yaffs_dev *dev)
+{
+	return 0;
+}
+
+static void yaffs_bg_stop(struct yaffs_dev *dev)
+{
+}
+#endif
+
+
+static void yaffs_flush_inodes(struct super_block *sb)
+{
+	struct inode *iptr;
+	struct yaffs_obj *obj;
+
+	list_for_each_entry(iptr, &sb->s_inodes, i_sb_list) {
+		obj = yaffs_inode_to_obj(iptr);
+		if (obj) {
+			yaffs_trace(YAFFS_TRACE_OS,
+				"flushing obj %d",
+				obj->obj_id);
+			yaffs_flush_file(obj, 1, 0);
+		}
+	}
+}
+
+static void yaffs_flush_super(struct super_block *sb, int do_checkpoint)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+	if (!dev)
+		return;
+
+	yaffs_flush_inodes(sb);
+	yaffs_update_dirty_dirs(dev);
+	yaffs_flush_whole_cache(dev);
+	if (do_checkpoint)
+		yaffs_checkpoint_save(dev);
+}
+
+static LIST_HEAD(yaffs_context_list);
+struct mutex yaffs_context_lock;
+
+static void yaffs_put_super(struct super_block *sb)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_ALWAYS,
+			"yaffs_put_super");
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_BACKGROUND,
+		"Shutting down yaffs background thread");
+	yaffs_bg_stop(dev);
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_BACKGROUND,
+		"yaffs background thread shut down");
+
+	yaffs_gross_lock(dev);
+
+	yaffs_flush_super(sb, 1);
+
+	yaffs_deinitialise(dev);
+
+	yaffs_gross_unlock(dev);
+
+	mutex_lock(&yaffs_context_lock);
+	list_del_init(&(yaffs_dev_to_lc(dev)->context_list));
+	mutex_unlock(&yaffs_context_lock);
+
+	if (yaffs_dev_to_lc(dev)->spare_buffer) {
+		kfree(yaffs_dev_to_lc(dev)->spare_buffer);
+		yaffs_dev_to_lc(dev)->spare_buffer = NULL;
+	}
+
+	kfree(dev);
+
+	yaffs_put_mtd_device(mtd);
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_ALWAYS,
+			"yaffs_put_super done");
+}
+
+
+static unsigned yaffs_gc_control_callback(struct yaffs_dev *dev)
+{
+	return yaffs_gc_control;
+}
+
+
+#ifdef YAFFS_COMPILE_EXPORTFS
+
+static struct inode *yaffs2_nfs_get_inode(struct super_block *sb, uint64_t ino,
+					  uint32_t generation)
+{
+	return Y_IGET(sb, ino);
+}
+
+static struct dentry *yaffs2_fh_to_dentry(struct super_block *sb,
+					  struct fid *fid, int fh_len,
+					  int fh_type)
+{
+	return generic_fh_to_dentry(sb, fid, fh_len, fh_type,
+				    yaffs2_nfs_get_inode);
+}
+
+static struct dentry *yaffs2_fh_to_parent(struct super_block *sb,
+					  struct fid *fid, int fh_len,
+					  int fh_type)
+{
+	return generic_fh_to_parent(sb, fid, fh_len, fh_type,
+				    yaffs2_nfs_get_inode);
+}
+
+struct dentry *yaffs2_get_parent(struct dentry *dentry)
+{
+
+	struct super_block *sb = dentry->d_inode->i_sb;
+	struct dentry *parent = ERR_PTR(-ENOENT);
+	struct inode *inode;
+	unsigned long parent_ino;
+	struct yaffs_obj *d_obj;
+	struct yaffs_obj *parent_obj;
+
+	d_obj = yaffs_inode_to_obj(dentry->d_inode);
+
+	if (d_obj) {
+		parent_obj = d_obj->parent;
+		if (parent_obj) {
+			parent_ino = yaffs_get_obj_inode(parent_obj);
+			inode = Y_IGET(sb, parent_ino);
+
+			if (IS_ERR(inode)) {
+				parent = ERR_CAST(inode);
+			} else {
+				parent = d_obtain_alias(inode);
+				if (!IS_ERR(parent)) {
+					parent = ERR_PTR(-ENOMEM);
+					iput(inode);
+				}
+			}
+		}
+	}
+
+	return parent;
+}
+
+/* Just declare a zero structure as a NULL value implies
+ * using the default functions of exportfs.
+ */
+
+static struct export_operations yaffs_export_ops = {
+	.fh_to_dentry = yaffs2_fh_to_dentry,
+	.fh_to_parent = yaffs2_fh_to_parent,
+	.get_parent = yaffs2_get_parent,
+};
+
+#endif
+
+static void yaffs_unstitch_obj(struct inode *inode, struct yaffs_obj *obj)
+{
+	/* Clear the association between the inode and
+	 * the struct yaffs_obj.
+	 */
+	obj->my_inode = NULL;
+	yaffs_inode_to_obj_lv(inode) = NULL;
+
+	/* If the object freeing was deferred, then the real
+	 * free happens now.
+	 * This should fix the inode inconsistency problem.
+	 */
+	yaffs_handle_defered_free(obj);
+}
+
+#ifdef YAFFS_HAS_EVICT_INODE
+/* yaffs_evict_inode combines into one operation what was previously done in
+ * yaffs_clear_inode() and yaffs_delete_inode()
+ *
+ */
+static void yaffs_evict_inode(struct inode *inode)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	int deleteme = 0;
+
+	obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_evict_inode: ino %d, count %d %s",
+		(int)inode->i_ino, atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object");
+
+	if (!inode->i_nlink && !is_bad_inode(inode))
+		deleteme = 1;
+	truncate_inode_pages(&inode->i_data, 0);
+	Y_CLEAR_INODE(inode);
+
+	if (deleteme && obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_del_obj(obj);
+		yaffs_gross_unlock(dev);
+	}
+	if (obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_unstitch_obj(inode, obj);
+		yaffs_gross_unlock(dev);
+	}
+}
+#else
+
+/* clear is called to tell the fs to release any per-inode data it holds.
+ * The object might still exist on disk and is just being thrown out of the cache
+ * or else the object has actually been deleted and we're being called via
+ * the chain
+ *   yaffs_delete_inode() -> clear_inode()->yaffs_clear_inode()
+ */
+
+static void yaffs_clear_inode(struct inode *inode)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+
+	obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_clear_inode: ino %d, count %d %s",
+		(int)inode->i_ino, atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object");
+
+	if (obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_unstitch_obj(inode, obj);
+		yaffs_gross_unlock(dev);
+	}
+
+}
+
+/* delete is called when the link count is zero and the inode
+ * is put (ie. nobody wants to know about it anymore, time to
+ * delete the file).
+ * NB Must call clear_inode()
+ */
+static void yaffs_delete_inode(struct inode *inode)
+{
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+	struct yaffs_dev *dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_delete_inode: ino %d, count %d %s",
+		(int)inode->i_ino, atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object");
+
+	if (obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_del_obj(obj);
+		yaffs_gross_unlock(dev);
+	}
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+	truncate_inode_pages(&inode->i_data, 0);
+#endif
+	clear_inode(inode);
+}
+#endif
+
+
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+	struct super_block *sb = dentry->d_sb;
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_statfs(struct super_block *sb, struct kstatfs *buf)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+#else
+static int yaffs_statfs(struct super_block *sb, struct statfs *buf)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+#endif
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_statfs");
+
+	yaffs_gross_lock(dev);
+
+	buf->f_type = YAFFS_MAGIC;
+	buf->f_bsize = sb->s_blocksize;
+	buf->f_namelen = 255;
+
+	if (dev->data_bytes_per_chunk & (dev->data_bytes_per_chunk - 1)) {
+		/* Do this if chunk size is not a power of 2 */
+
+		uint64_t bytes_in_dev;
+		uint64_t bytes_free;
+
+		bytes_in_dev =
+		    ((uint64_t)
+		     ((dev->param.end_block - dev->param.start_block +
+		       1))) * ((uint64_t) (dev->param.chunks_per_block *
+					   dev->data_bytes_per_chunk));
+
+		do_div(bytes_in_dev, sb->s_blocksize);	/* bytes_in_dev becomes the number of blocks */
+		buf->f_blocks = bytes_in_dev;
+
+		bytes_free = ((uint64_t) (yaffs_get_n_free_chunks(dev))) *
+		    ((uint64_t) (dev->data_bytes_per_chunk));
+
+		do_div(bytes_free, sb->s_blocksize);
+
+		buf->f_bfree = bytes_free;
+
+	} else if (sb->s_blocksize > dev->data_bytes_per_chunk) {
+
+		buf->f_blocks =
+		    (dev->param.end_block - dev->param.start_block + 1) *
+		    dev->param.chunks_per_block /
+		    (sb->s_blocksize / dev->data_bytes_per_chunk);
+		buf->f_bfree =
+		    yaffs_get_n_free_chunks(dev) /
+		    (sb->s_blocksize / dev->data_bytes_per_chunk);
+	} else {
+		buf->f_blocks =
+		    (dev->param.end_block - dev->param.start_block + 1) *
+		    dev->param.chunks_per_block *
+		    (dev->data_bytes_per_chunk / sb->s_blocksize);
+
+		buf->f_bfree =
+		    yaffs_get_n_free_chunks(dev) *
+		    (dev->data_bytes_per_chunk / sb->s_blocksize);
+	}
+
+	buf->f_files = 0;
+	buf->f_ffree = 0;
+	buf->f_bavail = buf->f_bfree;
+
+	yaffs_gross_unlock(dev);
+	return 0;
+}
+
+
+
+static int yaffs_do_sync_fs(struct super_block *sb, int request_checkpoint)
+{
+
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+	unsigned int oneshot_checkpoint = (yaffs_auto_checkpoint & 4);
+	unsigned gc_urgent = yaffs_bg_gc_urgency(dev);
+	int do_checkpoint;
+	int dirty = yaffs_check_super_dirty(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC | YAFFS_TRACE_BACKGROUND,
+		"yaffs_do_sync_fs: gc-urgency %d %s %s%s",
+		gc_urgent,
+		dirty ? "dirty" : "clean",
+		request_checkpoint ? "checkpoint requested" : "no checkpoint",
+		oneshot_checkpoint ? " one-shot" : "");
+
+	yaffs_gross_lock(dev);
+	do_checkpoint = ((request_checkpoint && !gc_urgent) ||
+			 oneshot_checkpoint) && !dev->is_checkpointed;
+
+	if (dirty || do_checkpoint) {
+		yaffs_flush_super(sb, !dev->is_checkpointed && do_checkpoint);
+		yaffs_clear_super_dirty(dev);
+		if (oneshot_checkpoint)
+			yaffs_auto_checkpoint &= ~4;
+	}
+	yaffs_gross_unlock(dev);
+
+	return 0;
+}
+
+
+#ifdef YAFFS_HAS_WRITE_SUPER
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static void yaffs_write_super(struct super_block *sb)
+#else
+static int yaffs_write_super(struct super_block *sb)
+#endif
+{
+	unsigned request_checkpoint = (yaffs_auto_checkpoint >= 2);
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC | YAFFS_TRACE_BACKGROUND,
+		"yaffs_write_super %s",
+		request_checkpoint ? " checkpt" : "");
+
+	yaffs_do_sync_fs(sb, request_checkpoint);
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
+	return 0;
+#endif
+}
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_sync_fs(struct super_block *sb, int wait)
+#else
+static int yaffs_sync_fs(struct super_block *sb)
+#endif
+{
+	unsigned request_checkpoint = (yaffs_auto_checkpoint >= 1);
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC,
+		"yaffs_sync_fs%s", request_checkpoint ? " checkpt" : "");
+
+	yaffs_do_sync_fs(sb, request_checkpoint);
+
+	return 0;
+}
+
+
+
+static const struct super_operations yaffs_super_ops = {
+	.statfs = yaffs_statfs,
+
+#ifndef YAFFS_USE_OWN_IGET
+	.read_inode = yaffs_read_inode,
+#endif
+#ifdef YAFFS_HAS_PUT_INODE
+	.put_inode = yaffs_put_inode,
+#endif
+	.put_super = yaffs_put_super,
+#ifdef YAFFS_HAS_EVICT_INODE
+	.evict_inode = yaffs_evict_inode,
+#else
+	.delete_inode = yaffs_delete_inode,
+	.clear_inode = yaffs_clear_inode,
+#endif
+	.sync_fs = yaffs_sync_fs,
+#ifdef YAFFS_HAS_WRITE_SUPER
+	.write_super = yaffs_write_super,
+#endif
+};
+
+struct yaffs_options {
+	int inband_tags;
+	int skip_checkpoint_read;
+	int skip_checkpoint_write;
+	int no_cache;
+	int tags_ecc_on;
+	int tags_ecc_overridden;
+	int lazy_loading_enabled;
+	int lazy_loading_overridden;
+	int empty_lost_and_found;
+	int empty_lost_and_found_overridden;
+	int disable_summary;
+};
+
+#define MAX_OPT_LEN 30
+static int yaffs_parse_options(struct yaffs_options *options,
+			       const char *options_str)
+{
+	char cur_opt[MAX_OPT_LEN + 1];
+	int p;
+	int error = 0;
+
+	/* Parse through the options which is a comma seperated list */
+
+	while (options_str && *options_str && !error) {
+		memset(cur_opt, 0, MAX_OPT_LEN + 1);
+		p = 0;
+
+		while (*options_str == ',')
+			options_str++;
+
+		while (*options_str && *options_str != ',') {
+			if (p < MAX_OPT_LEN) {
+				cur_opt[p] = *options_str;
+				p++;
+			}
+			options_str++;
+		}
+
+		if (!strcmp(cur_opt, "inband-tags")) {
+			options->inband_tags = 1;
+		} else if (!strcmp(cur_opt, "tags-ecc-off")) {
+			options->tags_ecc_on = 0;
+			options->tags_ecc_overridden = 1;
+		} else if (!strcmp(cur_opt, "tags-ecc-on")) {
+			options->tags_ecc_on = 1;
+			options->tags_ecc_overridden = 1;
+		} else if (!strcmp(cur_opt, "lazy-loading-off")) {
+			options->lazy_loading_enabled = 0;
+			options->lazy_loading_overridden = 1;
+		} else if (!strcmp(cur_opt, "lazy-loading-on")) {
+			options->lazy_loading_enabled = 1;
+			options->lazy_loading_overridden = 1;
+		} else if (!strcmp(cur_opt, "disable-summary")) {
+			options->disable_summary = 1;
+		} else if (!strcmp(cur_opt, "empty-lost-and-found-off")) {
+			options->empty_lost_and_found = 0;
+			options->empty_lost_and_found_overridden = 1;
+		} else if (!strcmp(cur_opt, "empty-lost-and-found-on")) {
+			options->empty_lost_and_found = 1;
+			options->empty_lost_and_found_overridden = 1;
+		} else if (!strcmp(cur_opt, "no-cache")) {
+			options->no_cache = 1;
+		} else if (!strcmp(cur_opt, "no-checkpoint-read")) {
+			options->skip_checkpoint_read = 1;
+		} else if (!strcmp(cur_opt, "no-checkpoint-write")) {
+			options->skip_checkpoint_write = 1;
+		} else if (!strcmp(cur_opt, "no-checkpoint")) {
+			options->skip_checkpoint_read = 1;
+			options->skip_checkpoint_write = 1;
+		} else {
+			printk(KERN_INFO "yaffs: Bad mount option \"%s\"\n",
+			       cur_opt);
+			error = 1;
+		}
+	}
+
+	return error;
+}
+
+
+static struct dentry *yaffs_make_root(struct inode *inode)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0))
+	struct dentry *root = d_alloc_root(inode);
+
+	if (!root)
+		iput(inode);
+
+        return root;
+#else
+        return d_make_root(inode);
+#endif
+}
+
+
+
+
+static struct super_block *yaffs_internal_read_super(int yaffs_version,
+						     struct super_block *sb,
+						     void *data, int silent)
+{
+	int n_blocks;
+	struct inode *inode = NULL;
+	struct dentry *root;
+	struct yaffs_dev *dev = 0;
+	char devname_buf[BDEVNAME_SIZE + 1];
+	struct mtd_info *mtd;
+	int err;
+	char *data_str = (char *)data;
+	struct yaffs_linux_context *context = NULL;
+	struct yaffs_param *param;
+
+	int read_only = 0;
+
+	struct yaffs_options options;
+
+	unsigned mount_id;
+	int found;
+	struct yaffs_linux_context *context_iterator;
+	struct list_head *l;
+
+	if (!sb) {
+		printk(KERN_INFO "yaffs: sb is NULL\n");
+		return NULL;
+        }
+
+	sb->s_magic = YAFFS_MAGIC;
+	sb->s_op = &yaffs_super_ops;
+	sb->s_flags |= MS_NOATIME;
+
+	read_only = ((sb->s_flags & MS_RDONLY) != 0);
+
+#ifdef YAFFS_COMPILE_EXPORTFS
+	sb->s_export_op = &yaffs_export_ops;
+#endif
+
+	if (!sb->s_dev)
+		printk(KERN_INFO "yaffs: sb->s_dev is NULL\n");
+	else if (!yaffs_devname(sb, devname_buf))
+		printk(KERN_INFO "yaffs: devname is NULL\n");
+	else
+		printk(KERN_INFO "yaffs: dev is %d name is \"%s\" %s\n",
+		       sb->s_dev,
+		       yaffs_devname(sb, devname_buf), read_only ? "ro" : "rw");
+
+	if (!data_str)
+		data_str = "";
+
+	printk(KERN_INFO "yaffs: passed flags \"%s\"\n", data_str);
+
+	memset(&options, 0, sizeof(options));
+
+	if (yaffs_parse_options(&options, data_str)) {
+		/* Option parsing failed */
+		return NULL;
+	}
+
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_super: Using yaffs%d", yaffs_version);
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_super: block size %d", (int)(sb->s_blocksize));
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs: Attempting MTD mount of %u.%u,\"%s\"",
+		MAJOR(sb->s_dev), MINOR(sb->s_dev),
+		yaffs_devname(sb, devname_buf));
+
+	/* Get the device */
+	mtd = get_mtd_device(NULL, MINOR(sb->s_dev));
+	if (!mtd) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"yaffs: MTD device %u either not valid or unavailable",
+			MINOR(sb->s_dev));
+		return NULL;
+	}
+
+	if (yaffs_auto_select && yaffs_version == 1 && WRITE_SIZE(mtd) >= 2048) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "auto selecting yaffs2");
+		yaffs_version = 2;
+	}
+
+	/* Added NCB 26/5/2006 for completeness */
+	if (yaffs_version == 2 && !options.inband_tags
+	    && WRITE_SIZE(mtd) == 512) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "auto selecting yaffs1");
+		yaffs_version = 1;
+	}
+
+	if(yaffs_verify_mtd(mtd, yaffs_version, options.inband_tags) < 0)
+		return NULL;
+
+	/* OK, so if we got here, we have an MTD that's NAND and looks
+	 * like it has the right capabilities
+	 * Set the struct yaffs_dev up for mtd
+	 */
+
+	if (!read_only && !(mtd->flags & MTD_WRITEABLE)) {
+		read_only = 1;
+		printk(KERN_INFO
+		       "yaffs: mtd is read only, setting superblock read only\n"
+		);
+		sb->s_flags |= MS_RDONLY;
+	}
+
+	dev = kmalloc(sizeof(struct yaffs_dev), GFP_KERNEL);
+	context = kmalloc(sizeof(struct yaffs_linux_context), GFP_KERNEL);
+
+	if (!dev || !context) {
+		if (dev)
+			kfree(dev);
+		if (context)
+			kfree(context);
+		dev = NULL;
+		context = NULL;
+	}
+
+	if (!dev) {
+		/* Deep shit could not allocate device structure */
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"yaffs_read_super: Failed trying to allocate struct yaffs_dev."
+		);
+		return NULL;
+	}
+	memset(dev, 0, sizeof(struct yaffs_dev));
+	param = &(dev->param);
+
+	memset(context, 0, sizeof(struct yaffs_linux_context));
+	dev->os_context = context;
+	INIT_LIST_HEAD(&(context->context_list));
+	context->dev = dev;
+	context->super = sb;
+
+	dev->read_only = read_only;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	sb->s_fs_info = dev;
+#else
+	sb->u.generic_sbp = dev;
+#endif
+
+
+	dev->driver_context = mtd;
+	param->name = mtd->name;
+
+	/* Set up the memory size parameters.... */
+
+
+	param->n_reserved_blocks = 5;
+	param->n_caches = (options.no_cache) ? 0 : 10;
+	param->inband_tags = options.inband_tags;
+
+	param->enable_xattr = 1;
+	if (options.lazy_loading_overridden)
+		param->disable_lazy_load = !options.lazy_loading_enabled;
+
+	param->defered_dir_update = 1;
+
+	if (options.tags_ecc_overridden)
+		param->no_tags_ecc = !options.tags_ecc_on;
+
+	param->empty_lost_n_found = 1;
+	param->refresh_period = 500;
+	param->disable_summary = options.disable_summary;
+
+	if (options.empty_lost_and_found_overridden)
+		param->empty_lost_n_found = options.empty_lost_and_found;
+
+	/* ... and the functions. */
+	if (yaffs_version == 2) {
+		param->is_yaffs2 = 1;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		param->total_bytes_per_chunk = mtd->writesize;
+		param->chunks_per_block = mtd->erasesize / mtd->writesize;
+#else
+		param->total_bytes_per_chunk = mtd->oobblock;
+		param->chunks_per_block = mtd->erasesize / mtd->oobblock;
+#endif
+		n_blocks = YCALCBLOCKS(mtd->size, mtd->erasesize);
+
+		param->start_block = 0;
+		param->end_block = n_blocks - 1;
+	} else {
+		param->is_yaffs2 = 0;
+		n_blocks = YCALCBLOCKS(mtd->size,
+			     YAFFS_CHUNKS_PER_BLOCK * YAFFS_BYTES_PER_CHUNK);
+
+		param->chunks_per_block = YAFFS_CHUNKS_PER_BLOCK;
+		param->total_bytes_per_chunk = YAFFS_BYTES_PER_CHUNK;
+	}
+
+	param->start_block = 0;
+	param->end_block = n_blocks - 1;
+
+	yaffs_mtd_drv_install(dev);
+
+	param->sb_dirty_fn = yaffs_set_super_dirty;
+	param->gc_control_fn = yaffs_gc_control_callback;
+
+	yaffs_dev_to_lc(dev)->super = sb;
+
+	param->use_nand_ecc = 1;
+
+	param->skip_checkpt_rd = options.skip_checkpoint_read;
+	param->skip_checkpt_wr = options.skip_checkpoint_write;
+
+	mutex_lock(&yaffs_context_lock);
+	/* Get a mount id */
+	found = 0;
+	for (mount_id = 0; !found; mount_id++) {
+		found = 1;
+		list_for_each(l, &yaffs_context_list) {
+			context_iterator =
+			    list_entry(l, struct yaffs_linux_context,
+				       context_list);
+			if (context_iterator->mount_id == mount_id)
+				found = 0;
+		}
+	}
+	context->mount_id = mount_id;
+
+	list_add_tail(&(yaffs_dev_to_lc(dev)->context_list),
+		      &yaffs_context_list);
+	mutex_unlock(&yaffs_context_lock);
+
+	/* Directory search handling... */
+	INIT_LIST_HEAD(&(yaffs_dev_to_lc(dev)->search_contexts));
+	param->remove_obj_fn = yaffs_remove_obj_callback;
+
+	mutex_init(&(yaffs_dev_to_lc(dev)->gross_lock));
+
+	yaffs_gross_lock(dev);
+
+	err = yaffs_guts_initialise(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_super: guts initialised %s",
+		(err == YAFFS_OK) ? "OK" : "FAILED");
+
+	if (err == YAFFS_OK)
+		yaffs_bg_start(dev);
+
+	if (!context->bg_thread)
+		param->defered_dir_update = 0;
+
+	sb->s_maxbytes = yaffs_max_file_size(dev);
+
+	/* Release lock before yaffs_get_inode() */
+	yaffs_gross_unlock(dev);
+
+	/* Create root inode */
+	if (err == YAFFS_OK)
+		inode = yaffs_get_inode(sb, S_IFDIR | 0755, 0, yaffs_root(dev));
+
+	if (!inode)
+		return NULL;
+
+	inode->i_op = &yaffs_dir_inode_operations;
+	inode->i_fop = &yaffs_dir_operations;
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS, "yaffs_read_super: got root inode");
+
+	root = yaffs_make_root(inode);
+
+	if (!root)
+		return NULL;
+
+	sb->s_root = root;
+	if(!dev->is_checkpointed)
+		yaffs_set_super_dirty(dev);
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs_read_super: is_checkpointed %d",
+		dev->is_checkpointed);
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS, "yaffs_read_super: done");
+	return sb;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_internal_read_super_mtd(struct super_block *sb, void *data,
+					 int silent)
+{
+	return yaffs_internal_read_super(1, sb, data, silent) ? 0 : -EINVAL;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+static struct dentry *yaffs_mount(struct file_system_type *fs_type, int flags,
+        const char *dev_name, void *data)
+{
+    return mount_bdev(fs_type, flags, dev_name, data, yaffs_internal_read_super_mtd);
+}
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_read_super(struct file_system_type *fs,
+			    int flags, const char *dev_name,
+			    void *data, struct vfsmount *mnt)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs_internal_read_super_mtd, mnt);
+}
+#else
+static struct super_block *yaffs_read_super(struct file_system_type *fs,
+					    int flags, const char *dev_name,
+					    void *data)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs_internal_read_super_mtd);
+}
+#endif
+
+static struct file_system_type yaffs_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "yaffs",
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+        .mount = yaffs_mount,
+#else
+        .get_sb = yaffs_read_super,
+#endif
+     	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV,
+};
+#else
+static struct super_block *yaffs_read_super(struct super_block *sb, void *data,
+					    int silent)
+{
+	return yaffs_internal_read_super(1, sb, data, silent);
+}
+
+static DECLARE_FSTYPE(yaffs_fs_type, "yaffs", yaffs_read_super,
+		      FS_REQUIRES_DEV);
+#endif
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs2_internal_read_super_mtd(struct super_block *sb, void *data,
+					  int silent)
+{
+	return yaffs_internal_read_super(2, sb, data, silent) ? 0 : -EINVAL;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+static struct dentry *yaffs2_mount(struct file_system_type *fs_type, int flags,
+        const char *dev_name, void *data)
+{
+        return mount_bdev(fs_type, flags, dev_name, data, yaffs2_internal_read_super_mtd);
+}
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs2_read_super(struct file_system_type *fs,
+			     int flags, const char *dev_name, void *data,
+			     struct vfsmount *mnt)
+{
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs2_internal_read_super_mtd, mnt);
+}
+#else
+static struct super_block *yaffs2_read_super(struct file_system_type *fs,
+					     int flags, const char *dev_name,
+					     void *data)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs2_internal_read_super_mtd);
+}
+#endif
+
+static struct file_system_type yaffs2_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "yaffs2",
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+        .mount = yaffs2_mount,
+#else
+        .get_sb = yaffs2_read_super,
+#endif
+     	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV,
+};
+#else
+static struct super_block *yaffs2_read_super(struct super_block *sb,
+					     void *data, int silent)
+{
+	return yaffs_internal_read_super(2, sb, data, silent);
+}
+
+static DECLARE_FSTYPE(yaffs2_fs_type, "yaffs2", yaffs2_read_super,
+		      FS_REQUIRES_DEV);
+#endif
+
+
+static struct proc_dir_entry *my_proc_entry;
+
+static char *yaffs_dump_dev_part0(char *buf, struct yaffs_dev *dev)
+{
+	struct yaffs_param *param = &dev->param;
+
+	buf += sprintf(buf, "start_block.......... %d\n", param->start_block);
+	buf += sprintf(buf, "end_block............ %d\n", param->end_block);
+	buf += sprintf(buf, "total_bytes_per_chunk %d\n",
+				param->total_bytes_per_chunk);
+	buf += sprintf(buf, "use_nand_ecc......... %d\n", param->use_nand_ecc);
+	buf += sprintf(buf, "no_tags_ecc.......... %d\n", param->no_tags_ecc);
+	buf += sprintf(buf, "is_yaffs2............ %d\n", param->is_yaffs2);
+	buf += sprintf(buf, "inband_tags.......... %d\n", param->inband_tags);
+	buf += sprintf(buf, "empty_lost_n_found... %d\n",
+				param->empty_lost_n_found);
+	buf += sprintf(buf, "disable_lazy_load.... %d\n",
+				param->disable_lazy_load);
+	buf += sprintf(buf, "refresh_period....... %d\n",
+				param->refresh_period);
+	buf += sprintf(buf, "n_caches............. %d\n", param->n_caches);
+	buf += sprintf(buf, "n_reserved_blocks.... %d\n",
+				param->n_reserved_blocks);
+	buf += sprintf(buf, "always_check_erased.. %d\n",
+				param->always_check_erased);
+	buf += sprintf(buf, "\n");
+
+	return buf;
+}
+
+static char *yaffs_dump_dev_part1(char *buf, struct yaffs_dev *dev)
+{
+	buf += sprintf(buf, "max file size....... %lld\n",
+				(long long) yaffs_max_file_size(dev));
+	buf += sprintf(buf, "data_bytes_per_chunk. %d\n",
+				dev->data_bytes_per_chunk);
+	buf += sprintf(buf, "chunk_grp_bits....... %d\n", dev->chunk_grp_bits);
+	buf += sprintf(buf, "chunk_grp_size....... %d\n", dev->chunk_grp_size);
+	buf += sprintf(buf, "n_erased_blocks...... %d\n", dev->n_erased_blocks);
+	buf += sprintf(buf, "blocks_in_checkpt.... %d\n",
+				dev->blocks_in_checkpt);
+	buf += sprintf(buf, "\n");
+	buf += sprintf(buf, "n_tnodes............. %d\n", dev->n_tnodes);
+	buf += sprintf(buf, "n_obj................ %d\n", dev->n_obj);
+	buf += sprintf(buf, "n_free_chunks........ %d\n", dev->n_free_chunks);
+	buf += sprintf(buf, "\n");
+	buf += sprintf(buf, "n_page_writes........ %u\n", dev->n_page_writes);
+	buf += sprintf(buf, "n_page_reads......... %u\n", dev->n_page_reads);
+	buf += sprintf(buf, "n_erasures........... %u\n", dev->n_erasures);
+	buf += sprintf(buf, "n_gc_copies.......... %u\n", dev->n_gc_copies);
+	buf += sprintf(buf, "all_gcs.............. %u\n", dev->all_gcs);
+	buf += sprintf(buf, "passive_gc_count..... %u\n",
+				dev->passive_gc_count);
+	buf += sprintf(buf, "oldest_dirty_gc_count %u\n",
+				dev->oldest_dirty_gc_count);
+	buf += sprintf(buf, "n_gc_blocks.......... %u\n", dev->n_gc_blocks);
+	buf += sprintf(buf, "bg_gcs............... %u\n", dev->bg_gcs);
+	buf += sprintf(buf, "n_retried_writes..... %u\n",
+				dev->n_retried_writes);
+	buf += sprintf(buf, "n_retired_blocks..... %u\n",
+				dev->n_retired_blocks);
+	buf += sprintf(buf, "n_ecc_fixed.......... %u\n", dev->n_ecc_fixed);
+	buf += sprintf(buf, "n_ecc_unfixed........ %u\n", dev->n_ecc_unfixed);
+	buf += sprintf(buf, "n_tags_ecc_fixed..... %u\n",
+				dev->n_tags_ecc_fixed);
+	buf += sprintf(buf, "n_tags_ecc_unfixed... %u\n",
+				dev->n_tags_ecc_unfixed);
+	buf += sprintf(buf, "cache_hits........... %u\n", dev->cache_hits);
+	buf += sprintf(buf, "n_deleted_files...... %u\n", dev->n_deleted_files);
+	buf += sprintf(buf, "n_unlinked_files..... %u\n",
+				dev->n_unlinked_files);
+	buf += sprintf(buf, "refresh_count........ %u\n", dev->refresh_count);
+	buf += sprintf(buf, "n_bg_deletions....... %u\n", dev->n_bg_deletions);
+	buf += sprintf(buf, "tags_used............ %u\n", dev->tags_used);
+	buf += sprintf(buf, "summary_used......... %u\n", dev->summary_used);
+
+	return buf;
+}
+
+static int yaffs_proc_read(char *page,
+			   char **start,
+			   off_t offset, int count, int *eof, void *data)
+{
+	struct list_head *item;
+	char *buf = page;
+	int step = offset;
+	int n = 0;
+
+	/* Get proc_file_read() to step 'offset' by one on each sucessive call.
+	 * We use 'offset' (*ppos) to indicate where we are in dev_list.
+	 * This also assumes the user has posted a read buffer large
+	 * enough to hold the complete output; but that's life in /proc.
+	 */
+
+	*(int *)start = 1;
+
+	/* Print header first */
+	if (step == 0)
+		buf +=
+		    sprintf(buf,
+			    "Multi-version YAFFS built:" __DATE__ " " __TIME__
+			    "\n");
+	else if (step == 1)
+		buf += sprintf(buf, "\n");
+	else {
+		step -= 2;
+
+		mutex_lock(&yaffs_context_lock);
+
+		/* Locate and print the Nth entry.  Order N-squared but N is small. */
+		list_for_each(item, &yaffs_context_list) {
+			struct yaffs_linux_context *dc =
+			    list_entry(item, struct yaffs_linux_context,
+				       context_list);
+			struct yaffs_dev *dev = dc->dev;
+
+			if (n < (step & ~1)) {
+				n += 2;
+				continue;
+			}
+			if ((step & 1) == 0) {
+				buf +=
+				    sprintf(buf, "\nDevice %d \"%s\"\n", n,
+					    dev->param.name);
+				buf = yaffs_dump_dev_part0(buf, dev);
+			} else {
+				buf = yaffs_dump_dev_part1(buf, dev);
+                        }
+
+			break;
+		}
+		mutex_unlock(&yaffs_context_lock);
+	}
+
+	return buf - page < count ? buf - page : count;
+}
+
+/**
+ * Set the verbosity of the warnings and error messages.
+ *
+ * Note that the names can only be a..z or _ with the current code.
+ */
+
+static struct {
+	char *mask_name;
+	unsigned mask_bitfield;
+} mask_flags[] = {
+	{"allocate", YAFFS_TRACE_ALLOCATE},
+	{"always", YAFFS_TRACE_ALWAYS},
+	{"background", YAFFS_TRACE_BACKGROUND},
+	{"bad_blocks", YAFFS_TRACE_BAD_BLOCKS},
+	{"buffers", YAFFS_TRACE_BUFFERS},
+	{"bug", YAFFS_TRACE_BUG},
+	{"checkpt", YAFFS_TRACE_CHECKPOINT},
+	{"deletion", YAFFS_TRACE_DELETION},
+	{"erase", YAFFS_TRACE_ERASE},
+	{"error", YAFFS_TRACE_ERROR},
+	{"gc_detail", YAFFS_TRACE_GC_DETAIL},
+	{"gc", YAFFS_TRACE_GC},
+	{"lock", YAFFS_TRACE_LOCK},
+	{"mtd", YAFFS_TRACE_MTD},
+	{"nandaccess", YAFFS_TRACE_NANDACCESS},
+	{"os", YAFFS_TRACE_OS},
+	{"scan_debug", YAFFS_TRACE_SCAN_DEBUG},
+	{"scan", YAFFS_TRACE_SCAN},
+	{"mount", YAFFS_TRACE_MOUNT},
+	{"tracing", YAFFS_TRACE_TRACING},
+	{"sync", YAFFS_TRACE_SYNC},
+	{"write", YAFFS_TRACE_WRITE},
+	{"verify", YAFFS_TRACE_VERIFY},
+	{"verify_nand", YAFFS_TRACE_VERIFY_NAND},
+	{"verify_full", YAFFS_TRACE_VERIFY_FULL},
+	{"verify_all", YAFFS_TRACE_VERIFY_ALL},
+	{"all", 0xffffffff},
+	{"none", 0},
+	{NULL, 0},
+};
+
+#define MAX_MASK_NAME_LENGTH 40
+static int yaffs_proc_write_trace_options(struct file *file, const char *buf,
+					  unsigned long count, void *data)
+{
+	unsigned rg = 0, mask_bitfield;
+	char *end;
+	char *mask_name;
+	const char *x;
+	char substring[MAX_MASK_NAME_LENGTH + 1];
+	int i;
+	int done = 0;
+	int add, len = 0;
+	int pos = 0;
+
+	rg = yaffs_trace_mask;
+
+	while (!done && (pos < count)) {
+		done = 1;
+		while ((pos < count) && isspace(buf[pos]))
+			pos++;
+
+		switch (buf[pos]) {
+		case '+':
+		case '-':
+		case '=':
+			add = buf[pos];
+			pos++;
+			break;
+
+		default:
+			add = ' ';
+			break;
+		}
+		mask_name = NULL;
+
+		mask_bitfield = simple_strtoul(buf + pos, &end, 0);
+
+		if (end > buf + pos) {
+			mask_name = "numeral";
+			len = end - (buf + pos);
+			pos += len;
+			done = 0;
+		} else {
+			for (x = buf + pos, i = 0;
+			     (*x == '_' || (*x >= 'a' && *x <= 'z')) &&
+			     i < MAX_MASK_NAME_LENGTH; x++, i++, pos++)
+				substring[i] = *x;
+			substring[i] = '\0';
+
+			for (i = 0; mask_flags[i].mask_name != NULL; i++) {
+				if (strcmp(substring, mask_flags[i].mask_name)
+				    == 0) {
+					mask_name = mask_flags[i].mask_name;
+					mask_bitfield =
+					    mask_flags[i].mask_bitfield;
+					done = 0;
+					break;
+				}
+			}
+		}
+
+		if (mask_name != NULL) {
+			done = 0;
+			switch (add) {
+			case '-':
+				rg &= ~mask_bitfield;
+				break;
+			case '+':
+				rg |= mask_bitfield;
+				break;
+			case '=':
+				rg = mask_bitfield;
+				break;
+			default:
+				rg |= mask_bitfield;
+				break;
+			}
+		}
+	}
+
+	yaffs_trace_mask = rg | YAFFS_TRACE_ALWAYS;
+
+	printk(KERN_DEBUG "new trace = 0x%08X\n", yaffs_trace_mask);
+
+	if (rg & YAFFS_TRACE_ALWAYS) {
+		for (i = 0; mask_flags[i].mask_name != NULL; i++) {
+			char flag;
+			flag = ((rg & mask_flags[i].mask_bitfield) ==
+				mask_flags[i].mask_bitfield) ? '+' : '-';
+			printk(KERN_DEBUG "%c%s\n", flag,
+			       mask_flags[i].mask_name);
+		}
+	}
+
+	return count;
+}
+
+static int yaffs_proc_write(struct file *file, const char *buf,
+			    unsigned long count, void *data)
+{
+	return yaffs_proc_write_trace_options(file, buf, count, data);
+}
+
+/* Stuff to handle installation of file systems */
+struct file_system_to_install {
+	struct file_system_type *fst;
+	int installed;
+};
+
+static struct file_system_to_install fs_to_install[] = {
+	{&yaffs_fs_type, 0},
+	{&yaffs2_fs_type, 0},
+	{NULL, 0}
+};
+
+static int __init init_yaffs_fs(void)
+{
+	int error = 0;
+	struct file_system_to_install *fsinst;
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs built " __DATE__ " " __TIME__ " Installing.");
+
+	mutex_init(&yaffs_context_lock);
+
+	/* Install the proc_fs entries */
+	my_proc_entry = create_proc_entry("yaffs",
+					  S_IRUGO | S_IFREG, YPROC_ROOT);
+
+	if (my_proc_entry) {
+		my_proc_entry->write_proc = yaffs_proc_write;
+		my_proc_entry->read_proc = yaffs_proc_read;
+		my_proc_entry->data = NULL;
+	} else {
+		return -ENOMEM;
+        }
+
+	/* Now add the file system entries */
+
+	fsinst = fs_to_install;
+
+	while (fsinst->fst && !error) {
+		error = register_filesystem(fsinst->fst);
+		if (!error)
+			fsinst->installed = 1;
+		fsinst++;
+	}
+
+	/* Any errors? uninstall  */
+	if (error) {
+		fsinst = fs_to_install;
+
+		while (fsinst->fst) {
+			if (fsinst->installed) {
+				unregister_filesystem(fsinst->fst);
+				fsinst->installed = 0;
+			}
+			fsinst++;
+		}
+	}
+
+	return error;
+}
+
+static void __exit exit_yaffs_fs(void)
+{
+
+	struct file_system_to_install *fsinst;
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs built " __DATE__ " " __TIME__ " removing.");
+
+	remove_proc_entry("yaffs", YPROC_ROOT);
+
+	fsinst = fs_to_install;
+
+	while (fsinst->fst) {
+		if (fsinst->installed) {
+			unregister_filesystem(fsinst->fst);
+			fsinst->installed = 0;
+		}
+		fsinst++;
+	}
+}
+
+module_init(init_yaffs_fs)
+    module_exit(exit_yaffs_fs)
+
+    MODULE_DESCRIPTION("YAFFS2 - a NAND specific flash file system");
+MODULE_AUTHOR("Charles Manning, Aleph One Ltd., 2002-2011");
+MODULE_LICENSE("GPL");
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_yaffs1.c linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_yaffs1.c
--- linux-3.0.8/fs/yaffs2/yaffs_yaffs1.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_yaffs1.c	2021-07-13 23:40:33.790357039 +0300
@@ -0,0 +1,422 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_yaffs1.h"
+#include "yportenv.h"
+#include "yaffs_trace.h"
+#include "yaffs_bitmap.h"
+#include "yaffs_getblockinfo.h"
+#include "yaffs_nand.h"
+#include "yaffs_attribs.h"
+
+int yaffs1_scan(struct yaffs_dev *dev)
+{
+	struct yaffs_ext_tags tags;
+	int blk;
+	int result;
+	int chunk;
+	int c;
+	int deleted;
+	enum yaffs_block_state state;
+	LIST_HEAD(hard_list);
+	struct yaffs_block_info *bi;
+	u32 seq_number;
+	struct yaffs_obj_hdr *oh;
+	struct yaffs_obj *in;
+	struct yaffs_obj *parent;
+	int alloc_failed = 0;
+	struct yaffs_shadow_fixer *shadow_fixers = NULL;
+	u8 *chunk_data;
+
+	yaffs_trace(YAFFS_TRACE_SCAN,
+		"yaffs1_scan starts  intstartblk %d intendblk %d...",
+		dev->internal_start_block, dev->internal_end_block);
+
+	chunk_data = yaffs_get_temp_buffer(dev);
+
+	dev->seq_number = YAFFS_LOWEST_SEQUENCE_NUMBER;
+
+	/* Scan all the blocks to determine their state */
+	bi = dev->block_info;
+	for (blk = dev->internal_start_block; blk <= dev->internal_end_block;
+	     blk++) {
+		yaffs_clear_chunk_bits(dev, blk);
+		bi->pages_in_use = 0;
+		bi->soft_del_pages = 0;
+
+		yaffs_query_init_block_state(dev, blk, &state, &seq_number);
+
+		bi->block_state = state;
+		bi->seq_number = seq_number;
+
+		if (bi->seq_number == YAFFS_SEQUENCE_BAD_BLOCK)
+			bi->block_state = state = YAFFS_BLOCK_STATE_DEAD;
+
+		yaffs_trace(YAFFS_TRACE_SCAN_DEBUG,
+			"Block scanning block %d state %d seq %d",
+			blk, state, seq_number);
+
+		if (state == YAFFS_BLOCK_STATE_DEAD) {
+			yaffs_trace(YAFFS_TRACE_BAD_BLOCKS,
+				"block %d is bad", blk);
+		} else if (state == YAFFS_BLOCK_STATE_EMPTY) {
+			yaffs_trace(YAFFS_TRACE_SCAN_DEBUG, "Block empty ");
+			dev->n_erased_blocks++;
+			dev->n_free_chunks += dev->param.chunks_per_block;
+		}
+		bi++;
+	}
+
+	/* For each block.... */
+	for (blk = dev->internal_start_block;
+	     !alloc_failed && blk <= dev->internal_end_block; blk++) {
+
+		cond_resched();
+
+		bi = yaffs_get_block_info(dev, blk);
+		state = bi->block_state;
+
+		deleted = 0;
+
+		/* For each chunk in each block that needs scanning.... */
+		for (c = 0;
+			!alloc_failed && c < dev->param.chunks_per_block &&
+			state == YAFFS_BLOCK_STATE_NEEDS_SCAN; c++) {
+			/* Read the tags and decide what to do */
+			chunk = blk * dev->param.chunks_per_block + c;
+
+			result = yaffs_rd_chunk_tags_nand(dev, chunk, NULL,
+							  &tags);
+
+			/* Let's have a good look at this chunk... */
+
+			if (tags.ecc_result == YAFFS_ECC_RESULT_UNFIXED ||
+			    tags.is_deleted) {
+				/* YAFFS1 only...
+				 * A deleted chunk
+				 */
+				deleted++;
+				dev->n_free_chunks++;
+			} else if (!tags.chunk_used) {
+				/* An unassigned chunk in the block
+				 * This means that either the block is empty or
+				 * this is the one being allocated from
+				 */
+
+				if (c == 0) {
+					/* We're looking at the first chunk in
+					 *the block so the block is unused */
+					state = YAFFS_BLOCK_STATE_EMPTY;
+					dev->n_erased_blocks++;
+				} else {
+					/* this is the block being allocated */
+					yaffs_trace(YAFFS_TRACE_SCAN,
+						" Allocating from %d %d",
+						blk, c);
+					state = YAFFS_BLOCK_STATE_ALLOCATING;
+					dev->alloc_block = blk;
+					dev->alloc_page = c;
+					dev->alloc_block_finder = blk;
+
+				}
+
+				dev->n_free_chunks +=
+				    (dev->param.chunks_per_block - c);
+			} else if (tags.chunk_id > 0) {
+				/* chunk_id > 0 so it is a data chunk... */
+				unsigned int endpos;
+
+				yaffs_set_chunk_bit(dev, blk, c);
+				bi->pages_in_use++;
+
+				in = yaffs_find_or_create_by_number(dev,
+							tags.obj_id,
+							YAFFS_OBJECT_TYPE_FILE);
+				/* PutChunkIntoFile checks for a clash
+				 * (two data chunks with the same chunk_id).
+				 */
+
+				if (!in)
+					alloc_failed = 1;
+
+				if (in) {
+					if (!yaffs_put_chunk_in_file
+					    (in, tags.chunk_id, chunk, 1))
+						alloc_failed = 1;
+				}
+
+				endpos =
+				    (tags.chunk_id - 1) *
+				    dev->data_bytes_per_chunk +
+				    tags.n_bytes;
+				if (in &&
+				    in->variant_type ==
+				     YAFFS_OBJECT_TYPE_FILE &&
+				    in->variant.file_variant.scanned_size <
+				      endpos) {
+					in->variant.file_variant.scanned_size =
+					    endpos;
+					if (!dev->param.use_header_file_size) {
+						in->variant.
+						    file_variant.file_size =
+						    in->variant.
+						    file_variant.scanned_size;
+					}
+
+				}
+			} else {
+				/* chunk_id == 0, so it is an ObjectHeader.
+				 * Make the object
+				 */
+				yaffs_set_chunk_bit(dev, blk, c);
+				bi->pages_in_use++;
+
+				result = yaffs_rd_chunk_tags_nand(dev, chunk,
+								  chunk_data,
+								  NULL);
+
+				oh = (struct yaffs_obj_hdr *)chunk_data;
+
+				in = yaffs_find_by_number(dev, tags.obj_id);
+				if (in && in->variant_type != oh->type) {
+					/* This should not happen, but somehow
+					 * Wev'e ended up with an obj_id that
+					 * has been reused but not yet deleted,
+					 * and worse still it has changed type.
+					 * Delete the old object.
+					 */
+
+					yaffs_del_obj(in);
+					in = NULL;
+				}
+
+				in = yaffs_find_or_create_by_number(dev,
+								tags.obj_id,
+								oh->type);
+
+				if (!in)
+					alloc_failed = 1;
+
+				if (in && oh->shadows_obj > 0) {
+
+					struct yaffs_shadow_fixer *fixer;
+					fixer =
+						kmalloc(sizeof
+						(struct yaffs_shadow_fixer),
+						GFP_NOFS);
+					if (fixer) {
+						fixer->next = shadow_fixers;
+						shadow_fixers = fixer;
+						fixer->obj_id = tags.obj_id;
+						fixer->shadowed_id =
+						    oh->shadows_obj;
+						yaffs_trace(YAFFS_TRACE_SCAN,
+							" Shadow fixer: %d shadows %d",
+							fixer->obj_id,
+							fixer->shadowed_id);
+
+					}
+
+				}
+
+				if (in && in->valid) {
+					/* We have already filled this one.
+					 * We have a duplicate and need to
+					 * resolve it. */
+
+					unsigned existing_serial = in->serial;
+					unsigned new_serial =
+					    tags.serial_number;
+
+					if (((existing_serial + 1) & 3) ==
+					    new_serial) {
+						/* Use new one - destroy the
+						 * exisiting one */
+						yaffs_chunk_del(dev,
+								in->hdr_chunk,
+								1, __LINE__);
+						in->valid = 0;
+					} else {
+						/* Use existing - destroy
+						 * this one. */
+						yaffs_chunk_del(dev, chunk, 1,
+								__LINE__);
+					}
+				}
+
+				if (in && !in->valid &&
+				    (tags.obj_id == YAFFS_OBJECTID_ROOT ||
+				     tags.obj_id ==
+				     YAFFS_OBJECTID_LOSTNFOUND)) {
+					/* We only load some info, don't fiddle
+					 * with directory structure */
+					in->valid = 1;
+					in->variant_type = oh->type;
+
+					in->yst_mode = oh->yst_mode;
+					yaffs_load_attribs(in, oh);
+					in->hdr_chunk = chunk;
+					in->serial = tags.serial_number;
+
+				} else if (in && !in->valid) {
+					/* we need to load this info */
+
+					in->valid = 1;
+					in->variant_type = oh->type;
+
+					in->yst_mode = oh->yst_mode;
+					yaffs_load_attribs(in, oh);
+					in->hdr_chunk = chunk;
+					in->serial = tags.serial_number;
+
+					yaffs_set_obj_name_from_oh(in, oh);
+					in->dirty = 0;
+
+					/* directory stuff...
+					 * hook up to parent
+					 */
+
+					parent =
+					    yaffs_find_or_create_by_number
+					    (dev, oh->parent_obj_id,
+					     YAFFS_OBJECT_TYPE_DIRECTORY);
+					if (!parent)
+						alloc_failed = 1;
+					if (parent && parent->variant_type ==
+					    YAFFS_OBJECT_TYPE_UNKNOWN) {
+						/* Set up as a directory */
+						parent->variant_type =
+						    YAFFS_OBJECT_TYPE_DIRECTORY;
+						INIT_LIST_HEAD(&parent->
+							variant.dir_variant.
+							children);
+					} else if (!parent ||
+						parent->variant_type !=
+						YAFFS_OBJECT_TYPE_DIRECTORY) {
+						/* Hoosterman, a problem....
+						 * We're trying to use a
+						 * non-directory as a directory
+						 */
+
+						yaffs_trace(YAFFS_TRACE_ERROR,
+							"yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."
+							);
+						parent = dev->lost_n_found;
+					}
+
+					yaffs_add_obj_to_dir(parent, in);
+
+					switch (in->variant_type) {
+					case YAFFS_OBJECT_TYPE_UNKNOWN:
+						/* Todo got a problem */
+						break;
+					case YAFFS_OBJECT_TYPE_FILE:
+						if (dev->param.
+						    use_header_file_size)
+							in->variant.
+							file_variant.file_size
+							= yaffs_oh_to_size(oh);
+						break;
+					case YAFFS_OBJECT_TYPE_HARDLINK:
+						in->variant.
+						    hardlink_variant.equiv_id =
+						    oh->equiv_id;
+						list_add(&in->hard_links,
+								&hard_list);
+						break;
+					case YAFFS_OBJECT_TYPE_DIRECTORY:
+						/* Do nothing */
+						break;
+					case YAFFS_OBJECT_TYPE_SPECIAL:
+						/* Do nothing */
+						break;
+					case YAFFS_OBJECT_TYPE_SYMLINK:
+						in->variant.symlink_variant.
+						    alias =
+						    yaffs_clone_str(oh->alias);
+						if (!in->variant.
+						    symlink_variant.alias)
+							alloc_failed = 1;
+						break;
+					}
+				}
+			}
+		}
+
+		if (state == YAFFS_BLOCK_STATE_NEEDS_SCAN) {
+			/* If we got this far while scanning,
+			 * then the block is fully allocated. */
+			state = YAFFS_BLOCK_STATE_FULL;
+		}
+
+		if (state == YAFFS_BLOCK_STATE_ALLOCATING) {
+			/* If the block was partially allocated then
+			 * treat it as fully allocated. */
+			state = YAFFS_BLOCK_STATE_FULL;
+			dev->alloc_block = -1;
+		}
+
+		bi->block_state = state;
+
+		/* Now let's see if it was dirty */
+		if (bi->pages_in_use == 0 &&
+		    !bi->has_shrink_hdr &&
+		    bi->block_state == YAFFS_BLOCK_STATE_FULL)
+			yaffs_block_became_dirty(dev, blk);
+	}
+
+	/* Ok, we've done all the scanning.
+	 * Fix up the hard link chains.
+	 * We should now have scanned all the objects, now it's time to add
+	 * these hardlinks.
+	 */
+
+	yaffs_link_fixup(dev, &hard_list);
+
+	/*
+	 * Fix up any shadowed objects.
+	 * There should not be more than one of these.
+	 */
+	{
+		struct yaffs_shadow_fixer *fixer;
+		struct yaffs_obj *obj;
+
+		while (shadow_fixers) {
+			fixer = shadow_fixers;
+			shadow_fixers = fixer->next;
+			/* Complete the rename transaction by deleting the
+			 * shadowed object then setting the object header
+			 to unshadowed.
+			 */
+			obj = yaffs_find_by_number(dev, fixer->shadowed_id);
+			if (obj)
+				yaffs_del_obj(obj);
+
+			obj = yaffs_find_by_number(dev, fixer->obj_id);
+
+			if (obj)
+				yaffs_update_oh(obj, NULL, 1, 0, 0, NULL);
+
+			kfree(fixer);
+		}
+	}
+
+	yaffs_release_temp_buffer(dev, chunk_data);
+
+	if (alloc_failed)
+		return YAFFS_FAIL;
+
+	yaffs_trace(YAFFS_TRACE_SCAN, "yaffs1_scan ends");
+
+	return YAFFS_OK;
+}
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_yaffs1.h linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_yaffs1.h
--- linux-3.0.8/fs/yaffs2/yaffs_yaffs1.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_yaffs1.h	2021-07-13 23:40:33.786357014 +0300
@@ -0,0 +1,22 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_YAFFS1_H__
+#define __YAFFS_YAFFS1_H__
+
+#include "yaffs_guts.h"
+int yaffs1_scan(struct yaffs_dev *dev);
+
+#endif
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_yaffs2.c linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_yaffs2.c
--- linux-3.0.8/fs/yaffs2/yaffs_yaffs2.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_yaffs2.c	2021-07-13 23:40:33.782356989 +0300
@@ -0,0 +1,1532 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_guts.h"
+#include "yaffs_trace.h"
+#include "yaffs_yaffs2.h"
+#include "yaffs_checkptrw.h"
+#include "yaffs_bitmap.h"
+#include "yaffs_nand.h"
+#include "yaffs_getblockinfo.h"
+#include "yaffs_verify.h"
+#include "yaffs_attribs.h"
+#include "yaffs_summary.h"
+
+/*
+ * Checkpoints are really no benefit on very small partitions.
+ *
+ * To save space on small partitions don't bother with checkpoints unless
+ * the partition is at least this big.
+ */
+#define YAFFS_CHECKPOINT_MIN_BLOCKS 60
+#define YAFFS_SMALL_HOLE_THRESHOLD 4
+
+/*
+ * Oldest Dirty Sequence Number handling.
+ */
+
+/* yaffs_calc_oldest_dirty_seq()
+ * yaffs2_find_oldest_dirty_seq()
+ * Calculate the oldest dirty sequence number if we don't know it.
+ */
+void yaffs_calc_oldest_dirty_seq(struct yaffs_dev *dev)
+{
+	int i;
+	unsigned seq;
+	unsigned block_no = 0;
+	struct yaffs_block_info *b;
+
+	if (!dev->param.is_yaffs2)
+		return;
+
+	/* Find the oldest dirty sequence number. */
+	seq = dev->seq_number + 1;
+	b = dev->block_info;
+	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
+		if (b->block_state == YAFFS_BLOCK_STATE_FULL &&
+		    (b->pages_in_use - b->soft_del_pages) <
+		    dev->param.chunks_per_block &&
+		    b->seq_number < seq) {
+			seq = b->seq_number;
+			block_no = i;
+		}
+		b++;
+	}
+
+	if (block_no) {
+		dev->oldest_dirty_seq = seq;
+		dev->oldest_dirty_block = block_no;
+	}
+}
+
+void yaffs2_find_oldest_dirty_seq(struct yaffs_dev *dev)
+{
+	if (!dev->param.is_yaffs2)
+		return;
+
+	if (!dev->oldest_dirty_seq)
+		yaffs_calc_oldest_dirty_seq(dev);
+}
+
+/*
+ * yaffs_clear_oldest_dirty_seq()
+ * Called when a block is erased or marked bad. (ie. when its seq_number
+ * becomes invalid). If the value matches the oldest then we clear
+ * dev->oldest_dirty_seq to force its recomputation.
+ */
+void yaffs2_clear_oldest_dirty_seq(struct yaffs_dev *dev,
+				   struct yaffs_block_info *bi)
+{
+
+	if (!dev->param.is_yaffs2)
+		return;
+
+	if (!bi || bi->seq_number == dev->oldest_dirty_seq) {
+		dev->oldest_dirty_seq = 0;
+		dev->oldest_dirty_block = 0;
+	}
+}
+
+/*
+ * yaffs2_update_oldest_dirty_seq()
+ * Update the oldest dirty sequence number whenever we dirty a block.
+ * Only do this if the oldest_dirty_seq is actually being tracked.
+ */
+void yaffs2_update_oldest_dirty_seq(struct yaffs_dev *dev, unsigned block_no,
+				    struct yaffs_block_info *bi)
+{
+	if (!dev->param.is_yaffs2)
+		return;
+
+	if (dev->oldest_dirty_seq) {
+		if (dev->oldest_dirty_seq > bi->seq_number) {
+			dev->oldest_dirty_seq = bi->seq_number;
+			dev->oldest_dirty_block = block_no;
+		}
+	}
+}
+
+int yaffs_block_ok_for_gc(struct yaffs_dev *dev, struct yaffs_block_info *bi)
+{
+
+	if (!dev->param.is_yaffs2)
+		return 1;	/* disqualification only applies to yaffs2. */
+
+	if (!bi->has_shrink_hdr)
+		return 1;	/* can gc */
+
+	yaffs2_find_oldest_dirty_seq(dev);
+
+	/* Can't do gc of this block if there are any blocks older than this
+	 * one that have discarded pages.
+	 */
+	return (bi->seq_number <= dev->oldest_dirty_seq);
+}
+
+/*
+ * yaffs2_find_refresh_block()
+ * periodically finds the oldest full block by sequence number for refreshing.
+ * Only for yaffs2.
+ */
+u32 yaffs2_find_refresh_block(struct yaffs_dev *dev)
+{
+	u32 b;
+	u32 oldest = 0;
+	u32 oldest_seq = 0;
+	struct yaffs_block_info *bi;
+
+	if (!dev->param.is_yaffs2)
+		return oldest;
+
+	/*
+	 * If refresh period < 10 then refreshing is disabled.
+	 */
+	if (dev->param.refresh_period < 10)
+		return oldest;
+
+	/*
+	 * Fix broken values.
+	 */
+	if (dev->refresh_skip > dev->param.refresh_period)
+		dev->refresh_skip = dev->param.refresh_period;
+
+	if (dev->refresh_skip > 0)
+		return oldest;
+
+	/*
+	 * Refresh skip is now zero.
+	 * We'll do a refresh this time around....
+	 * Update the refresh skip and find the oldest block.
+	 */
+	dev->refresh_skip = dev->param.refresh_period;
+	dev->refresh_count++;
+	bi = dev->block_info;
+	for (b = dev->internal_start_block; b <= dev->internal_end_block; b++) {
+
+		if (bi->block_state == YAFFS_BLOCK_STATE_FULL) {
+
+			if (oldest < 1 || bi->seq_number < oldest_seq) {
+				oldest = b;
+				oldest_seq = bi->seq_number;
+			}
+		}
+		bi++;
+	}
+
+	if (oldest > 0) {
+		yaffs_trace(YAFFS_TRACE_GC,
+			"GC refresh count %d selected block %d with seq_number %d",
+			dev->refresh_count, oldest, oldest_seq);
+	}
+
+	return oldest;
+}
+
+int yaffs2_checkpt_required(struct yaffs_dev *dev)
+{
+	int nblocks;
+
+	if (!dev->param.is_yaffs2)
+		return 0;
+
+	nblocks = dev->internal_end_block - dev->internal_start_block + 1;
+
+	return !dev->param.skip_checkpt_wr &&
+	    !dev->read_only && (nblocks >= YAFFS_CHECKPOINT_MIN_BLOCKS);
+}
+
+int yaffs_calc_checkpt_blocks_required(struct yaffs_dev *dev)
+{
+	int retval;
+	int n_bytes = 0;
+	int n_blocks;
+	int dev_blocks;
+
+	if (!dev->param.is_yaffs2)
+		return 0;
+
+	if (!dev->checkpoint_blocks_required && yaffs2_checkpt_required(dev)) {
+		/* Not a valid value so recalculate */
+		dev_blocks = dev->param.end_block - dev->param.start_block + 1;
+		n_bytes += sizeof(struct yaffs_checkpt_validity);
+		n_bytes += sizeof(struct yaffs_checkpt_dev);
+		n_bytes += dev_blocks * sizeof(struct yaffs_block_info);
+		n_bytes += dev_blocks * dev->chunk_bit_stride;
+		n_bytes +=
+		    (sizeof(struct yaffs_checkpt_obj) + sizeof(u32)) *
+		    dev->n_obj;
+		n_bytes += (dev->tnode_size + sizeof(u32)) * dev->n_tnodes;
+		n_bytes += sizeof(struct yaffs_checkpt_validity);
+		n_bytes += sizeof(u32);	/* checksum */
+
+		/* Round up and add 2 blocks to allow for some bad blocks,
+		 * so add 3 */
+
+		n_blocks =
+		    (n_bytes /
+		     (dev->data_bytes_per_chunk *
+		      dev->param.chunks_per_block)) + 3;
+
+		dev->checkpoint_blocks_required = n_blocks;
+	}
+
+	retval = dev->checkpoint_blocks_required - dev->blocks_in_checkpt;
+	if (retval < 0)
+		retval = 0;
+	return retval;
+}
+
+/*--------------------- Checkpointing --------------------*/
+
+static int yaffs2_wr_checkpt_validity_marker(struct yaffs_dev *dev, int head)
+{
+	struct yaffs_checkpt_validity cp;
+
+	memset(&cp, 0, sizeof(cp));
+
+	cp.struct_type = sizeof(cp);
+	cp.magic = YAFFS_MAGIC;
+	cp.version = YAFFS_CHECKPOINT_VERSION;
+	cp.head = (head) ? 1 : 0;
+
+	return (yaffs2_checkpt_wr(dev, &cp, sizeof(cp)) == sizeof(cp)) ? 1 : 0;
+}
+
+static int yaffs2_rd_checkpt_validity_marker(struct yaffs_dev *dev, int head)
+{
+	struct yaffs_checkpt_validity cp;
+	int ok;
+
+	ok = (yaffs2_checkpt_rd(dev, &cp, sizeof(cp)) == sizeof(cp));
+
+	if (ok)
+		ok = (cp.struct_type == sizeof(cp)) &&
+		    (cp.magic == YAFFS_MAGIC) &&
+		    (cp.version == YAFFS_CHECKPOINT_VERSION) &&
+		    (cp.head == ((head) ? 1 : 0));
+	return ok ? 1 : 0;
+}
+
+static void yaffs2_dev_to_checkpt_dev(struct yaffs_checkpt_dev *cp,
+				      struct yaffs_dev *dev)
+{
+	cp->n_erased_blocks = dev->n_erased_blocks;
+	cp->alloc_block = dev->alloc_block;
+	cp->alloc_page = dev->alloc_page;
+	cp->n_free_chunks = dev->n_free_chunks;
+
+	cp->n_deleted_files = dev->n_deleted_files;
+	cp->n_unlinked_files = dev->n_unlinked_files;
+	cp->n_bg_deletions = dev->n_bg_deletions;
+	cp->seq_number = dev->seq_number;
+
+}
+
+static void yaffs_checkpt_dev_to_dev(struct yaffs_dev *dev,
+				     struct yaffs_checkpt_dev *cp)
+{
+	dev->n_erased_blocks = cp->n_erased_blocks;
+	dev->alloc_block = cp->alloc_block;
+	dev->alloc_page = cp->alloc_page;
+	dev->n_free_chunks = cp->n_free_chunks;
+
+	dev->n_deleted_files = cp->n_deleted_files;
+	dev->n_unlinked_files = cp->n_unlinked_files;
+	dev->n_bg_deletions = cp->n_bg_deletions;
+	dev->seq_number = cp->seq_number;
+}
+
+static int yaffs2_wr_checkpt_dev(struct yaffs_dev *dev)
+{
+	struct yaffs_checkpt_dev cp;
+	u32 n_bytes;
+	u32 n_blocks = dev->internal_end_block - dev->internal_start_block + 1;
+	int ok;
+
+	/* Write device runtime values */
+	yaffs2_dev_to_checkpt_dev(&cp, dev);
+	cp.struct_type = sizeof(cp);
+
+	ok = (yaffs2_checkpt_wr(dev, &cp, sizeof(cp)) == sizeof(cp));
+	if (!ok)
+		return 0;
+
+	/* Write block info */
+	n_bytes = n_blocks * sizeof(struct yaffs_block_info);
+	ok = (yaffs2_checkpt_wr(dev, dev->block_info, n_bytes) == n_bytes);
+	if (!ok)
+		return 0;
+
+	/* Write chunk bits */
+	n_bytes = n_blocks * dev->chunk_bit_stride;
+	ok = (yaffs2_checkpt_wr(dev, dev->chunk_bits, n_bytes) == n_bytes);
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs2_rd_checkpt_dev(struct yaffs_dev *dev)
+{
+	struct yaffs_checkpt_dev cp;
+	u32 n_bytes;
+	u32 n_blocks =
+	    (dev->internal_end_block - dev->internal_start_block + 1);
+	int ok;
+
+	ok = (yaffs2_checkpt_rd(dev, &cp, sizeof(cp)) == sizeof(cp));
+	if (!ok)
+		return 0;
+
+	if (cp.struct_type != sizeof(cp))
+		return 0;
+
+	yaffs_checkpt_dev_to_dev(dev, &cp);
+
+	n_bytes = n_blocks * sizeof(struct yaffs_block_info);
+
+	ok = (yaffs2_checkpt_rd(dev, dev->block_info, n_bytes) == n_bytes);
+
+	if (!ok)
+		return 0;
+
+	n_bytes = n_blocks * dev->chunk_bit_stride;
+
+	ok = (yaffs2_checkpt_rd(dev, dev->chunk_bits, n_bytes) == n_bytes);
+
+	return ok ? 1 : 0;
+}
+
+static void yaffs2_obj_checkpt_obj(struct yaffs_checkpt_obj *cp,
+				   struct yaffs_obj *obj)
+{
+	cp->obj_id = obj->obj_id;
+	cp->parent_id = (obj->parent) ? obj->parent->obj_id : 0;
+	cp->hdr_chunk = obj->hdr_chunk;
+	cp->variant_type = obj->variant_type;
+	cp->deleted = obj->deleted;
+	cp->soft_del = obj->soft_del;
+	cp->unlinked = obj->unlinked;
+	cp->fake = obj->fake;
+	cp->rename_allowed = obj->rename_allowed;
+	cp->unlink_allowed = obj->unlink_allowed;
+	cp->serial = obj->serial;
+	cp->n_data_chunks = obj->n_data_chunks;
+
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_FILE)
+		cp->size_or_equiv_obj = obj->variant.file_variant.file_size;
+	else if (obj->variant_type == YAFFS_OBJECT_TYPE_HARDLINK)
+		cp->size_or_equiv_obj = obj->variant.hardlink_variant.equiv_id;
+}
+
+static int yaffs2_checkpt_obj_to_obj(struct yaffs_obj *obj,
+				     struct yaffs_checkpt_obj *cp)
+{
+	struct yaffs_obj *parent;
+
+	if (obj->variant_type != cp->variant_type) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"Checkpoint read object %d type %d chunk %d does not match existing object type %d",
+			cp->obj_id, cp->variant_type, cp->hdr_chunk,
+			obj->variant_type);
+		return 0;
+	}
+
+	obj->obj_id = cp->obj_id;
+
+	if (cp->parent_id)
+		parent = yaffs_find_or_create_by_number(obj->my_dev,
+						cp->parent_id,
+						YAFFS_OBJECT_TYPE_DIRECTORY);
+	else
+		parent = NULL;
+
+	if (parent) {
+		if (parent->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"Checkpoint read object %d parent %d type %d chunk %d Parent type, %d, not directory",
+				cp->obj_id, cp->parent_id,
+				cp->variant_type, cp->hdr_chunk,
+				parent->variant_type);
+			return 0;
+		}
+		yaffs_add_obj_to_dir(parent, obj);
+	}
+
+	obj->hdr_chunk = cp->hdr_chunk;
+	obj->variant_type = cp->variant_type;
+	obj->deleted = cp->deleted;
+	obj->soft_del = cp->soft_del;
+	obj->unlinked = cp->unlinked;
+	obj->fake = cp->fake;
+	obj->rename_allowed = cp->rename_allowed;
+	obj->unlink_allowed = cp->unlink_allowed;
+	obj->serial = cp->serial;
+	obj->n_data_chunks = cp->n_data_chunks;
+
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_FILE)
+		obj->variant.file_variant.file_size = cp->size_or_equiv_obj;
+	else if (obj->variant_type == YAFFS_OBJECT_TYPE_HARDLINK)
+		obj->variant.hardlink_variant.equiv_id = cp->size_or_equiv_obj;
+
+	if (obj->hdr_chunk > 0)
+		obj->lazy_loaded = 1;
+	return 1;
+}
+
+static int yaffs2_checkpt_tnode_worker(struct yaffs_obj *in,
+				       struct yaffs_tnode *tn, u32 level,
+				       int chunk_offset)
+{
+	int i;
+	struct yaffs_dev *dev = in->my_dev;
+	int ok = 1;
+	u32 base_offset;
+
+	if (!tn)
+		return 1;
+
+	if (level > 0) {
+		for (i = 0; i < YAFFS_NTNODES_INTERNAL && ok; i++) {
+			if (!tn->internal[i])
+				continue;
+			ok = yaffs2_checkpt_tnode_worker(in,
+				 tn->internal[i],
+				 level - 1,
+				 (chunk_offset <<
+				  YAFFS_TNODES_INTERNAL_BITS) + i);
+		}
+		return ok;
+	}
+
+	/* Level 0 tnode */
+	base_offset = chunk_offset << YAFFS_TNODES_LEVEL0_BITS;
+	ok = (yaffs2_checkpt_wr(dev, &base_offset, sizeof(base_offset)) ==
+			sizeof(base_offset));
+	if (ok)
+		ok = (yaffs2_checkpt_wr(dev, tn, dev->tnode_size) ==
+			dev->tnode_size);
+
+	return ok;
+}
+
+static int yaffs2_wr_checkpt_tnodes(struct yaffs_obj *obj)
+{
+	u32 end_marker = ~0;
+	int ok = 1;
+
+	if (obj->variant_type != YAFFS_OBJECT_TYPE_FILE)
+		return ok;
+
+	ok = yaffs2_checkpt_tnode_worker(obj,
+					 obj->variant.file_variant.top,
+					 obj->variant.file_variant.
+					 top_level, 0);
+	if (ok)
+		ok = (yaffs2_checkpt_wr(obj->my_dev, &end_marker,
+				sizeof(end_marker)) == sizeof(end_marker));
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs2_rd_checkpt_tnodes(struct yaffs_obj *obj)
+{
+	u32 base_chunk;
+	int ok = 1;
+	struct yaffs_dev *dev = obj->my_dev;
+	struct yaffs_file_var *file_stuct_ptr = &obj->variant.file_variant;
+	struct yaffs_tnode *tn;
+	int nread = 0;
+
+	ok = (yaffs2_checkpt_rd(dev, &base_chunk, sizeof(base_chunk)) ==
+	      sizeof(base_chunk));
+
+	while (ok && (~base_chunk)) {
+		nread++;
+		/* Read level 0 tnode */
+
+		tn = yaffs_get_tnode(dev);
+		if (tn)
+			ok = (yaffs2_checkpt_rd(dev, tn, dev->tnode_size) ==
+				dev->tnode_size);
+		else
+			ok = 0;
+
+		if (tn && ok)
+			ok = yaffs_add_find_tnode_0(dev,
+						    file_stuct_ptr,
+						    base_chunk, tn) ? 1 : 0;
+
+		if (ok)
+			ok = (yaffs2_checkpt_rd
+			      (dev, &base_chunk,
+			       sizeof(base_chunk)) == sizeof(base_chunk));
+	}
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"Checkpoint read tnodes %d records, last %d. ok %d",
+		nread, base_chunk, ok);
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs2_wr_checkpt_objs(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_checkpt_obj cp;
+	int i;
+	int ok = 1;
+	struct list_head *lh;
+
+	/* Iterate through the objects in each hash entry,
+	 * dumping them to the checkpointing stream.
+	 */
+
+	for (i = 0; ok && i < YAFFS_NOBJECT_BUCKETS; i++) {
+		list_for_each(lh, &dev->obj_bucket[i].list) {
+			obj = list_entry(lh, struct yaffs_obj, hash_link);
+			if (!obj->defered_free) {
+				yaffs2_obj_checkpt_obj(&cp, obj);
+				cp.struct_type = sizeof(cp);
+
+				yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+					"Checkpoint write object %d parent %d type %d chunk %d obj addr %p",
+					cp.obj_id, cp.parent_id,
+					cp.variant_type, cp.hdr_chunk, obj);
+
+				ok = (yaffs2_checkpt_wr(dev, &cp,
+						sizeof(cp)) == sizeof(cp));
+
+				if (ok &&
+					obj->variant_type ==
+					YAFFS_OBJECT_TYPE_FILE)
+					ok = yaffs2_wr_checkpt_tnodes(obj);
+			}
+		}
+	}
+
+	/* Dump end of list */
+	memset(&cp, 0xff, sizeof(struct yaffs_checkpt_obj));
+	cp.struct_type = sizeof(cp);
+
+	if (ok)
+		ok = (yaffs2_checkpt_wr(dev, &cp, sizeof(cp)) == sizeof(cp));
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs2_rd_checkpt_objs(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_checkpt_obj cp;
+	int ok = 1;
+	int done = 0;
+	LIST_HEAD(hard_list);
+
+
+	while (ok && !done) {
+		ok = (yaffs2_checkpt_rd(dev, &cp, sizeof(cp)) == sizeof(cp));
+		if (cp.struct_type != sizeof(cp)) {
+			yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+				"struct size %d instead of %d ok %d",
+				cp.struct_type, (int)sizeof(cp), ok);
+			ok = 0;
+		}
+
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"Checkpoint read object %d parent %d type %d chunk %d ",
+			cp.obj_id, cp.parent_id, cp.variant_type,
+			cp.hdr_chunk);
+
+		if (ok && cp.obj_id == ~0) {
+			done = 1;
+		} else if (ok) {
+			obj =
+			    yaffs_find_or_create_by_number(dev, cp.obj_id,
+							   cp.variant_type);
+			if (obj) {
+				ok = yaffs2_checkpt_obj_to_obj(obj, &cp);
+				if (!ok)
+					break;
+				if (obj->variant_type ==
+					YAFFS_OBJECT_TYPE_FILE) {
+					ok = yaffs2_rd_checkpt_tnodes(obj);
+				} else if (obj->variant_type ==
+					YAFFS_OBJECT_TYPE_HARDLINK) {
+					list_add(&obj->hard_links, &hard_list);
+				}
+			} else {
+				ok = 0;
+			}
+		}
+	}
+
+	if (ok)
+		yaffs_link_fixup(dev, &hard_list);
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs2_wr_checkpt_sum(struct yaffs_dev *dev)
+{
+	u32 checkpt_sum;
+	int ok;
+
+	yaffs2_get_checkpt_sum(dev, &checkpt_sum);
+
+	ok = (yaffs2_checkpt_wr(dev, &checkpt_sum, sizeof(checkpt_sum)) ==
+		sizeof(checkpt_sum));
+
+	if (!ok)
+		return 0;
+
+	return 1;
+}
+
+static int yaffs2_rd_checkpt_sum(struct yaffs_dev *dev)
+{
+	u32 checkpt_sum0;
+	u32 checkpt_sum1;
+	int ok;
+
+	yaffs2_get_checkpt_sum(dev, &checkpt_sum0);
+
+	ok = (yaffs2_checkpt_rd(dev, &checkpt_sum1, sizeof(checkpt_sum1)) ==
+		sizeof(checkpt_sum1));
+
+	if (!ok)
+		return 0;
+
+	if (checkpt_sum0 != checkpt_sum1)
+		return 0;
+
+	return 1;
+}
+
+static int yaffs2_wr_checkpt_data(struct yaffs_dev *dev)
+{
+	int ok = 1;
+
+	if (!yaffs2_checkpt_required(dev)) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"skipping checkpoint write");
+		ok = 0;
+	}
+
+	if (ok)
+		ok = yaffs2_checkpt_open(dev, 1);
+
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"write checkpoint validity");
+		ok = yaffs2_wr_checkpt_validity_marker(dev, 1);
+	}
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"write checkpoint device");
+		ok = yaffs2_wr_checkpt_dev(dev);
+	}
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"write checkpoint objects");
+		ok = yaffs2_wr_checkpt_objs(dev);
+	}
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"write checkpoint validity");
+		ok = yaffs2_wr_checkpt_validity_marker(dev, 0);
+	}
+
+	if (ok)
+		ok = yaffs2_wr_checkpt_sum(dev);
+
+	if (!yaffs_checkpt_close(dev))
+		ok = 0;
+
+	if (ok)
+		dev->is_checkpointed = 1;
+	else
+		dev->is_checkpointed = 0;
+
+	return dev->is_checkpointed;
+}
+
+static int yaffs2_rd_checkpt_data(struct yaffs_dev *dev)
+{
+	int ok = 1;
+
+	if (!dev->param.is_yaffs2)
+		ok = 0;
+
+	if (ok && dev->param.skip_checkpt_rd) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"skipping checkpoint read");
+		ok = 0;
+	}
+
+	if (ok)
+		ok = yaffs2_checkpt_open(dev, 0); /* open for read */
+
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"read checkpoint validity");
+		ok = yaffs2_rd_checkpt_validity_marker(dev, 1);
+	}
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"read checkpoint device");
+		ok = yaffs2_rd_checkpt_dev(dev);
+	}
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"read checkpoint objects");
+		ok = yaffs2_rd_checkpt_objs(dev);
+	}
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"read checkpoint validity");
+		ok = yaffs2_rd_checkpt_validity_marker(dev, 0);
+	}
+
+	if (ok) {
+		ok = yaffs2_rd_checkpt_sum(dev);
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"read checkpoint checksum %d", ok);
+	}
+
+	if (!yaffs_checkpt_close(dev))
+		ok = 0;
+
+	if (ok)
+		dev->is_checkpointed = 1;
+	else
+		dev->is_checkpointed = 0;
+
+	return ok ? 1 : 0;
+}
+
+void yaffs2_checkpt_invalidate(struct yaffs_dev *dev)
+{
+	if (dev->is_checkpointed || dev->blocks_in_checkpt > 0) {
+		dev->is_checkpointed = 0;
+		yaffs2_checkpt_invalidate_stream(dev);
+	}
+	if (dev->param.sb_dirty_fn)
+		dev->param.sb_dirty_fn(dev);
+}
+
+int yaffs_checkpoint_save(struct yaffs_dev *dev)
+{
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"save entry: is_checkpointed %d",
+		dev->is_checkpointed);
+
+	yaffs_verify_objects(dev);
+	yaffs_verify_blocks(dev);
+	yaffs_verify_free_chunks(dev);
+
+	if (!dev->is_checkpointed) {
+		yaffs2_checkpt_invalidate(dev);
+		yaffs2_wr_checkpt_data(dev);
+	}
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT | YAFFS_TRACE_MOUNT,
+		"save exit: is_checkpointed %d",
+		dev->is_checkpointed);
+
+	return dev->is_checkpointed;
+}
+
+int yaffs2_checkpt_restore(struct yaffs_dev *dev)
+{
+	int retval;
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"restore entry: is_checkpointed %d",
+		dev->is_checkpointed);
+
+	retval = yaffs2_rd_checkpt_data(dev);
+
+	if (dev->is_checkpointed) {
+		yaffs_verify_objects(dev);
+		yaffs_verify_blocks(dev);
+		yaffs_verify_free_chunks(dev);
+	}
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"restore exit: is_checkpointed %d",
+		dev->is_checkpointed);
+
+	return retval;
+}
+
+int yaffs2_handle_hole(struct yaffs_obj *obj, loff_t new_size)
+{
+	/* if new_size > old_file_size.
+	 * We're going to be writing a hole.
+	 * If the hole is small then write zeros otherwise write a start
+	 * of hole marker.
+	 */
+	loff_t old_file_size;
+	loff_t increase;
+	int small_hole;
+	int result = YAFFS_OK;
+	struct yaffs_dev *dev = NULL;
+	u8 *local_buffer = NULL;
+	int small_increase_ok = 0;
+
+	if (!obj)
+		return YAFFS_FAIL;
+
+	if (obj->variant_type != YAFFS_OBJECT_TYPE_FILE)
+		return YAFFS_FAIL;
+
+	dev = obj->my_dev;
+
+	/* Bail out if not yaffs2 mode */
+	if (!dev->param.is_yaffs2)
+		return YAFFS_OK;
+
+	old_file_size = obj->variant.file_variant.file_size;
+
+	if (new_size <= old_file_size)
+		return YAFFS_OK;
+
+	increase = new_size - old_file_size;
+
+	if (increase < YAFFS_SMALL_HOLE_THRESHOLD * dev->data_bytes_per_chunk &&
+	    yaffs_check_alloc_available(dev, YAFFS_SMALL_HOLE_THRESHOLD + 1))
+		small_hole = 1;
+	else
+		small_hole = 0;
+
+	if (small_hole)
+		local_buffer = yaffs_get_temp_buffer(dev);
+
+	if (local_buffer) {
+		/* fill hole with zero bytes */
+		loff_t pos = old_file_size;
+		int this_write;
+		int written;
+		memset(local_buffer, 0, dev->data_bytes_per_chunk);
+		small_increase_ok = 1;
+
+		while (increase > 0 && small_increase_ok) {
+			this_write = increase;
+			if (this_write > dev->data_bytes_per_chunk)
+				this_write = dev->data_bytes_per_chunk;
+			written =
+			    yaffs_do_file_wr(obj, local_buffer, pos, this_write,
+					     0);
+			if (written == this_write) {
+				pos += this_write;
+				increase -= this_write;
+			} else {
+				small_increase_ok = 0;
+			}
+		}
+
+		yaffs_release_temp_buffer(dev, local_buffer);
+
+		/* If out of space then reverse any chunks we've added */
+		if (!small_increase_ok)
+			yaffs_resize_file_down(obj, old_file_size);
+	}
+
+	if (!small_increase_ok &&
+	    obj->parent &&
+	    obj->parent->obj_id != YAFFS_OBJECTID_UNLINKED &&
+	    obj->parent->obj_id != YAFFS_OBJECTID_DELETED) {
+		/* Write a hole start header with the old file size */
+		yaffs_update_oh(obj, NULL, 0, 1, 0, NULL);
+	}
+
+	return result;
+}
+
+struct yaffs_block_index {
+	int seq;
+	int block;
+};
+
+static int yaffs2_ybicmp(const void *a, const void *b)
+{
+	int aseq = ((struct yaffs_block_index *)a)->seq;
+	int bseq = ((struct yaffs_block_index *)b)->seq;
+	int ablock = ((struct yaffs_block_index *)a)->block;
+	int bblock = ((struct yaffs_block_index *)b)->block;
+
+	if (aseq == bseq)
+		return ablock - bblock;
+
+	return aseq - bseq;
+}
+
+static inline int yaffs2_scan_chunk(struct yaffs_dev *dev,
+		struct yaffs_block_info *bi,
+		int blk, int chunk_in_block,
+		int *found_chunks,
+		u8 *chunk_data,
+		struct list_head *hard_list,
+		int summary_available)
+{
+	struct yaffs_obj_hdr *oh;
+	struct yaffs_obj *in;
+	struct yaffs_obj *parent;
+	int equiv_id;
+	loff_t file_size;
+	int is_shrink;
+	int is_unlinked;
+	struct yaffs_ext_tags tags;
+	int result;
+	int alloc_failed = 0;
+	int chunk = blk * dev->param.chunks_per_block + chunk_in_block;
+	struct yaffs_file_var *file_var;
+	struct yaffs_hardlink_var *hl_var;
+	struct yaffs_symlink_var *sl_var;
+
+	if (summary_available) {
+		result = yaffs_summary_fetch(dev, &tags, chunk_in_block);
+		tags.seq_number = bi->seq_number;
+	}
+
+	if (!summary_available || tags.obj_id == 0) {
+		result = yaffs_rd_chunk_tags_nand(dev, chunk, NULL, &tags);
+		dev->tags_used++;
+	} else {
+		dev->summary_used++;
+	}
+
+	/* Let's have a good look at this chunk... */
+
+	if (!tags.chunk_used) {
+		/* An unassigned chunk in the block.
+		 * If there are used chunks after this one, then
+		 * it is a chunk that was skipped due to failing
+		 * the erased check. Just skip it so that it can
+		 * be deleted.
+		 * But, more typically, We get here when this is
+		 * an unallocated chunk and his means that
+		 * either the block is empty or this is the one
+		 * being allocated from
+		 */
+
+		if (*found_chunks) {
+			/* This is a chunk that was skipped due
+			 * to failing the erased check */
+		} else if (chunk_in_block == 0) {
+			/* We're looking at the first chunk in
+			 * the block so the block is unused */
+			bi->block_state = YAFFS_BLOCK_STATE_EMPTY;
+			dev->n_erased_blocks++;
+		} else {
+			if (bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN ||
+			    bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING) {
+				if (dev->seq_number == bi->seq_number) {
+					/* Allocating from this block*/
+					yaffs_trace(YAFFS_TRACE_SCAN,
+					    " Allocating from %d %d",
+					    blk, chunk_in_block);
+
+					bi->block_state =
+						YAFFS_BLOCK_STATE_ALLOCATING;
+					dev->alloc_block = blk;
+					dev->alloc_page = chunk_in_block;
+					dev->alloc_block_finder = blk;
+				} else {
+					/* This is a partially written block
+					 * that is not the current
+					 * allocation block.
+					 */
+					yaffs_trace(YAFFS_TRACE_SCAN,
+						"Partially written block %d detected. gc will fix this.",
+						blk);
+				}
+			}
+		}
+
+		dev->n_free_chunks++;
+
+	} else if (tags.ecc_result ==
+		YAFFS_ECC_RESULT_UNFIXED) {
+		yaffs_trace(YAFFS_TRACE_SCAN,
+			" Unfixed ECC in chunk(%d:%d), chunk ignored",
+			blk, chunk_in_block);
+			dev->n_free_chunks++;
+	} else if (tags.obj_id > YAFFS_MAX_OBJECT_ID ||
+		   tags.chunk_id > YAFFS_MAX_CHUNK_ID ||
+		   tags.obj_id == YAFFS_OBJECTID_SUMMARY ||
+		   (tags.chunk_id > 0 &&
+		     tags.n_bytes > dev->data_bytes_per_chunk) ||
+		   tags.seq_number != bi->seq_number) {
+		yaffs_trace(YAFFS_TRACE_SCAN,
+			"Chunk (%d:%d) with bad tags:obj = %d, chunk_id = %d, n_bytes = %d, ignored",
+			blk, chunk_in_block, tags.obj_id,
+			tags.chunk_id, tags.n_bytes);
+		dev->n_free_chunks++;
+	} else if (tags.chunk_id > 0) {
+		/* chunk_id > 0 so it is a data chunk... */
+		loff_t endpos;
+		loff_t chunk_base = (tags.chunk_id - 1) *
+					dev->data_bytes_per_chunk;
+
+		*found_chunks = 1;
+
+		yaffs_set_chunk_bit(dev, blk, chunk_in_block);
+		bi->pages_in_use++;
+
+		in = yaffs_find_or_create_by_number(dev,
+					tags.obj_id,
+					YAFFS_OBJECT_TYPE_FILE);
+		if (!in)
+			/* Out of memory */
+			alloc_failed = 1;
+
+		if (in &&
+		    in->variant_type == YAFFS_OBJECT_TYPE_FILE &&
+		    chunk_base < in->variant.file_variant.shrink_size) {
+			/* This has not been invalidated by
+			 * a resize */
+			if (!yaffs_put_chunk_in_file(in, tags.chunk_id,
+								chunk, -1))
+				alloc_failed = 1;
+
+			/* File size is calculated by looking at
+			 * the data chunks if we have not
+			 * seen an object header yet.
+			 * Stop this practice once we find an
+			 * object header.
+			 */
+			endpos = chunk_base + tags.n_bytes;
+
+			if (!in->valid &&
+			    in->variant.file_variant.scanned_size < endpos) {
+				in->variant.file_variant.
+				    scanned_size = endpos;
+				in->variant.file_variant.
+				    file_size = endpos;
+			}
+		} else if (in) {
+			/* This chunk has been invalidated by a
+			 * resize, or a past file deletion
+			 * so delete the chunk*/
+			yaffs_chunk_del(dev, chunk, 1, __LINE__);
+		}
+	} else {
+		/* chunk_id == 0, so it is an ObjectHeader.
+		 * Thus, we read in the object header and make
+		 * the object
+		 */
+		*found_chunks = 1;
+
+		yaffs_set_chunk_bit(dev, blk, chunk_in_block);
+		bi->pages_in_use++;
+
+		oh = NULL;
+		in = NULL;
+
+		if (tags.extra_available) {
+			in = yaffs_find_or_create_by_number(dev,
+					tags.obj_id,
+					tags.extra_obj_type);
+			if (!in)
+				alloc_failed = 1;
+		}
+
+		if (!in ||
+		    (!in->valid && dev->param.disable_lazy_load) ||
+		    tags.extra_shadows ||
+		    (!in->valid && (tags.obj_id == YAFFS_OBJECTID_ROOT ||
+				 tags.obj_id == YAFFS_OBJECTID_LOSTNFOUND))) {
+
+			/* If we don't have  valid info then we
+			 * need to read the chunk
+			 * TODO In future we can probably defer
+			 * reading the chunk and living with
+			 * invalid data until needed.
+			 */
+
+			result = yaffs_rd_chunk_tags_nand(dev,
+						  chunk,
+						  chunk_data,
+						  NULL);
+
+			oh = (struct yaffs_obj_hdr *)chunk_data;
+
+			if (dev->param.inband_tags) {
+				/* Fix up the header if they got
+				 * corrupted by inband tags */
+				oh->shadows_obj =
+				    oh->inband_shadowed_obj_id;
+				oh->is_shrink =
+				    oh->inband_is_shrink;
+			}
+
+			if (!in) {
+				in = yaffs_find_or_create_by_number(dev,
+							tags.obj_id, oh->type);
+				if (!in)
+					alloc_failed = 1;
+			}
+		}
+
+		if (!in) {
+			/* TODO Hoosterman we have a problem! */
+			yaffs_trace(YAFFS_TRACE_ERROR,
+				"yaffs tragedy: Could not make object for object  %d at chunk %d during scan",
+				tags.obj_id, chunk);
+			return YAFFS_FAIL;
+		}
+
+		if (in->valid) {
+			/* We have already filled this one.
+			 * We have a duplicate that will be
+			 * discarded, but we first have to suck
+			 * out resize info if it is a file.
+			 */
+			if ((in->variant_type == YAFFS_OBJECT_TYPE_FILE) &&
+				((oh && oh->type == YAFFS_OBJECT_TYPE_FILE) ||
+				 (tags.extra_available &&
+				  tags.extra_obj_type == YAFFS_OBJECT_TYPE_FILE)
+				)) {
+				loff_t this_size = (oh) ?
+					yaffs_oh_to_size(oh) :
+					tags.extra_file_size;
+				u32 parent_obj_id = (oh) ?
+					oh->parent_obj_id :
+					tags.extra_parent_id;
+
+				is_shrink = (oh) ?
+					oh->is_shrink :
+					tags.extra_is_shrink;
+
+				/* If it is deleted (unlinked
+				 * at start also means deleted)
+				 * we treat the file size as
+				 * being zeroed at this point.
+				 */
+				if (parent_obj_id == YAFFS_OBJECTID_DELETED ||
+				    parent_obj_id == YAFFS_OBJECTID_UNLINKED) {
+					this_size = 0;
+					is_shrink = 1;
+				}
+
+				if (is_shrink &&
+				    in->variant.file_variant.shrink_size >
+				    this_size)
+					in->variant.file_variant.shrink_size =
+					this_size;
+
+				if (is_shrink)
+					bi->has_shrink_hdr = 1;
+			}
+			/* Use existing - destroy this one. */
+			yaffs_chunk_del(dev, chunk, 1, __LINE__);
+		}
+
+		if (!in->valid && in->variant_type !=
+		    (oh ? oh->type : tags.extra_obj_type))
+			yaffs_trace(YAFFS_TRACE_ERROR,
+				"yaffs tragedy: Bad object type, %d != %d, for object %d at chunk %d during scan",
+				oh ? oh->type : tags.extra_obj_type,
+				in->variant_type, tags.obj_id,
+				chunk);
+
+		if (!in->valid &&
+		    (tags.obj_id == YAFFS_OBJECTID_ROOT ||
+		     tags.obj_id == YAFFS_OBJECTID_LOSTNFOUND)) {
+			/* We only load some info, don't fiddle
+			 * with directory structure */
+			in->valid = 1;
+
+			if (oh) {
+				in->yst_mode = oh->yst_mode;
+				yaffs_load_attribs(in, oh);
+				in->lazy_loaded = 0;
+			} else {
+				in->lazy_loaded = 1;
+			}
+			in->hdr_chunk = chunk;
+
+		} else if (!in->valid) {
+			/* we need to load this info */
+			in->valid = 1;
+			in->hdr_chunk = chunk;
+			if (oh) {
+				in->variant_type = oh->type;
+				in->yst_mode = oh->yst_mode;
+				yaffs_load_attribs(in, oh);
+
+				if (oh->shadows_obj > 0)
+					yaffs_handle_shadowed_obj(dev,
+					     oh->shadows_obj, 1);
+
+				yaffs_set_obj_name_from_oh(in, oh);
+				parent = yaffs_find_or_create_by_number(dev,
+						oh->parent_obj_id,
+						YAFFS_OBJECT_TYPE_DIRECTORY);
+				file_size = yaffs_oh_to_size(oh);
+				is_shrink = oh->is_shrink;
+				equiv_id = oh->equiv_id;
+			} else {
+				in->variant_type = tags.extra_obj_type;
+				parent = yaffs_find_or_create_by_number(dev,
+						tags.extra_parent_id,
+						YAFFS_OBJECT_TYPE_DIRECTORY);
+				file_size = tags.extra_file_size;
+				is_shrink = tags.extra_is_shrink;
+				equiv_id = tags.extra_equiv_id;
+				in->lazy_loaded = 1;
+			}
+			in->dirty = 0;
+
+			if (!parent)
+				alloc_failed = 1;
+
+			/* directory stuff...
+			 * hook up to parent
+			 */
+
+			if (parent &&
+			    parent->variant_type == YAFFS_OBJECT_TYPE_UNKNOWN) {
+				/* Set up as a directory */
+				parent->variant_type =
+					YAFFS_OBJECT_TYPE_DIRECTORY;
+				INIT_LIST_HEAD(&parent->
+						variant.dir_variant.children);
+			} else if (!parent ||
+				   parent->variant_type !=
+					YAFFS_OBJECT_TYPE_DIRECTORY) {
+				/* Hoosterman, another problem....
+				 * Trying to use a non-directory as a directory
+				 */
+
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."
+					);
+				parent = dev->lost_n_found;
+			}
+			yaffs_add_obj_to_dir(parent, in);
+
+			is_unlinked = (parent == dev->del_dir) ||
+					(parent == dev->unlinked_dir);
+
+			if (is_shrink)
+				/* Mark the block */
+				bi->has_shrink_hdr = 1;
+
+			/* Note re hardlinks.
+			 * Since we might scan a hardlink before its equivalent
+			 * object is scanned we put them all in a list.
+			 * After scanning is complete, we should have all the
+			 * objects, so we run through this list and fix up all
+			 * the chains.
+			 */
+
+			switch (in->variant_type) {
+			case YAFFS_OBJECT_TYPE_UNKNOWN:
+				/* Todo got a problem */
+				break;
+			case YAFFS_OBJECT_TYPE_FILE:
+				file_var = &in->variant.file_variant;
+				if (file_var->scanned_size < file_size) {
+					/* This covers the case where the file
+					 * size is greater than the data held.
+					 * This will happen if the file is
+					 * resized to be larger than its
+					 * current data extents.
+					 */
+					file_var->file_size = file_size;
+					file_var->scanned_size = file_size;
+				}
+
+				if (file_var->shrink_size > file_size)
+					file_var->shrink_size = file_size;
+
+				break;
+			case YAFFS_OBJECT_TYPE_HARDLINK:
+				hl_var = &in->variant.hardlink_variant;
+				if (!is_unlinked) {
+					hl_var->equiv_id = equiv_id;
+					list_add(&in->hard_links, hard_list);
+				}
+				break;
+			case YAFFS_OBJECT_TYPE_DIRECTORY:
+				/* Do nothing */
+				break;
+			case YAFFS_OBJECT_TYPE_SPECIAL:
+				/* Do nothing */
+				break;
+			case YAFFS_OBJECT_TYPE_SYMLINK:
+				sl_var = &in->variant.symlink_variant;
+				if (oh) {
+					sl_var->alias =
+					    yaffs_clone_str(oh->alias);
+					if (!sl_var->alias)
+						alloc_failed = 1;
+				}
+				break;
+			}
+		}
+	}
+	return alloc_failed ? YAFFS_FAIL : YAFFS_OK;
+}
+
+int yaffs2_scan_backwards(struct yaffs_dev *dev)
+{
+	int blk;
+	int block_iter;
+	int start_iter;
+	int end_iter;
+	int n_to_scan = 0;
+	enum yaffs_block_state state;
+	int c;
+	int deleted;
+	LIST_HEAD(hard_list);
+	struct yaffs_block_info *bi;
+	u32 seq_number;
+	int n_blocks = dev->internal_end_block - dev->internal_start_block + 1;
+	u8 *chunk_data;
+	int found_chunks;
+	int alloc_failed = 0;
+	struct yaffs_block_index *block_index = NULL;
+	int alt_block_index = 0;
+	int summary_available;
+
+	yaffs_trace(YAFFS_TRACE_SCAN,
+		"yaffs2_scan_backwards starts  intstartblk %d intendblk %d...",
+		dev->internal_start_block, dev->internal_end_block);
+
+	dev->seq_number = YAFFS_LOWEST_SEQUENCE_NUMBER;
+
+	block_index =
+		kmalloc(n_blocks * sizeof(struct yaffs_block_index), GFP_NOFS);
+
+	if (!block_index) {
+		block_index =
+		    vmalloc(n_blocks * sizeof(struct yaffs_block_index));
+		alt_block_index = 1;
+	}
+
+	if (!block_index) {
+		yaffs_trace(YAFFS_TRACE_SCAN,
+			"yaffs2_scan_backwards() could not allocate block index!"
+			);
+		return YAFFS_FAIL;
+	}
+
+	dev->blocks_in_checkpt = 0;
+
+	chunk_data = yaffs_get_temp_buffer(dev);
+
+	/* Scan all the blocks to determine their state */
+	bi = dev->block_info;
+	for (blk = dev->internal_start_block; blk <= dev->internal_end_block;
+	     blk++) {
+		yaffs_clear_chunk_bits(dev, blk);
+		bi->pages_in_use = 0;
+		bi->soft_del_pages = 0;
+
+		yaffs_query_init_block_state(dev, blk, &state, &seq_number);
+
+		bi->block_state = state;
+		bi->seq_number = seq_number;
+
+		if (bi->seq_number == YAFFS_SEQUENCE_CHECKPOINT_DATA)
+			bi->block_state = YAFFS_BLOCK_STATE_CHECKPOINT;
+		if (bi->seq_number == YAFFS_SEQUENCE_BAD_BLOCK)
+			bi->block_state = YAFFS_BLOCK_STATE_DEAD;
+
+		yaffs_trace(YAFFS_TRACE_SCAN_DEBUG,
+			"Block scanning block %d state %d seq %d",
+			blk, bi->block_state, seq_number);
+
+		if (bi->block_state == YAFFS_BLOCK_STATE_CHECKPOINT) {
+			dev->blocks_in_checkpt++;
+
+		} else if (bi->block_state == YAFFS_BLOCK_STATE_DEAD) {
+			yaffs_trace(YAFFS_TRACE_BAD_BLOCKS,
+				"block %d is bad", blk);
+		} else if (bi->block_state == YAFFS_BLOCK_STATE_EMPTY) {
+			yaffs_trace(YAFFS_TRACE_SCAN_DEBUG, "Block empty ");
+			dev->n_erased_blocks++;
+			dev->n_free_chunks += dev->param.chunks_per_block;
+		} else if (bi->block_state ==
+				YAFFS_BLOCK_STATE_NEEDS_SCAN) {
+			/* Determine the highest sequence number */
+			if (seq_number >= YAFFS_LOWEST_SEQUENCE_NUMBER &&
+			    seq_number < YAFFS_HIGHEST_SEQUENCE_NUMBER) {
+				block_index[n_to_scan].seq = seq_number;
+				block_index[n_to_scan].block = blk;
+				n_to_scan++;
+				if (seq_number >= dev->seq_number)
+					dev->seq_number = seq_number;
+			} else {
+				/* TODO: Nasty sequence number! */
+				yaffs_trace(YAFFS_TRACE_SCAN,
+					"Block scanning block %d has bad sequence number %d",
+					blk, seq_number);
+			}
+		}
+		bi++;
+	}
+
+	yaffs_trace(YAFFS_TRACE_SCAN, "%d blocks to be sorted...", n_to_scan);
+
+	cond_resched();
+
+	/* Sort the blocks by sequence number */
+	sort(block_index, n_to_scan, sizeof(struct yaffs_block_index),
+		   yaffs2_ybicmp, NULL);
+
+	cond_resched();
+
+	yaffs_trace(YAFFS_TRACE_SCAN, "...done");
+
+	/* Now scan the blocks looking at the data. */
+	start_iter = 0;
+	end_iter = n_to_scan - 1;
+	yaffs_trace(YAFFS_TRACE_SCAN_DEBUG, "%d blocks to scan", n_to_scan);
+
+	/* For each block.... backwards */
+	for (block_iter = end_iter;
+	     !alloc_failed && block_iter >= start_iter;
+	     block_iter--) {
+		/* Cooperative multitasking! This loop can run for so
+		   long that watchdog timers expire. */
+		cond_resched();
+
+		/* get the block to scan in the correct order */
+		blk = block_index[block_iter].block;
+		bi = yaffs_get_block_info(dev, blk);
+		deleted = 0;
+
+		summary_available = yaffs_summary_read(dev, dev->sum_tags, blk);
+
+		/* For each chunk in each block that needs scanning.... */
+		found_chunks = 0;
+		if (summary_available)
+			c = dev->chunks_per_summary - 1;
+		else
+			c = dev->param.chunks_per_block - 1;
+
+		for (/* c is already initialised */;
+		     !alloc_failed && c >= 0 &&
+		     (bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN ||
+		      bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING);
+		      c--) {
+			/* Scan backwards...
+			 * Read the tags and decide what to do
+			 */
+			if (yaffs2_scan_chunk(dev, bi, blk, c,
+					&found_chunks, chunk_data,
+					&hard_list, summary_available) ==
+					YAFFS_FAIL)
+				alloc_failed = 1;
+		}
+
+		if (bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN) {
+			/* If we got this far while scanning, then the block
+			 * is fully allocated. */
+			bi->block_state = YAFFS_BLOCK_STATE_FULL;
+		}
+
+		/* Now let's see if it was dirty */
+		if (bi->pages_in_use == 0 &&
+		    !bi->has_shrink_hdr &&
+		    bi->block_state == YAFFS_BLOCK_STATE_FULL) {
+			yaffs_block_became_dirty(dev, blk);
+		}
+	}
+
+	yaffs_skip_rest_of_block(dev);
+
+	if (alt_block_index)
+		vfree(block_index);
+	else
+		kfree(block_index);
+
+	/* Ok, we've done all the scanning.
+	 * Fix up the hard link chains.
+	 * We have scanned all the objects, now it's time to add these
+	 * hardlinks.
+	 */
+	yaffs_link_fixup(dev, &hard_list);
+
+	yaffs_release_temp_buffer(dev, chunk_data);
+
+	if (alloc_failed)
+		return YAFFS_FAIL;
+
+	yaffs_trace(YAFFS_TRACE_SCAN, "yaffs2_scan_backwards ends");
+
+	return YAFFS_OK;
+}
diff -uraN linux-3.0.8/fs/yaffs2/yaffs_yaffs2.h linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_yaffs2.h
--- linux-3.0.8/fs/yaffs2/yaffs_yaffs2.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yaffs_yaffs2.h	2021-07-13 23:40:33.782356989 +0300
@@ -0,0 +1,39 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_YAFFS2_H__
+#define __YAFFS_YAFFS2_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_calc_oldest_dirty_seq(struct yaffs_dev *dev);
+void yaffs2_find_oldest_dirty_seq(struct yaffs_dev *dev);
+void yaffs2_clear_oldest_dirty_seq(struct yaffs_dev *dev,
+				   struct yaffs_block_info *bi);
+void yaffs2_update_oldest_dirty_seq(struct yaffs_dev *dev, unsigned block_no,
+				    struct yaffs_block_info *bi);
+int yaffs_block_ok_for_gc(struct yaffs_dev *dev, struct yaffs_block_info *bi);
+u32 yaffs2_find_refresh_block(struct yaffs_dev *dev);
+int yaffs2_checkpt_required(struct yaffs_dev *dev);
+int yaffs_calc_checkpt_blocks_required(struct yaffs_dev *dev);
+
+void yaffs2_checkpt_invalidate(struct yaffs_dev *dev);
+int yaffs2_checkpt_save(struct yaffs_dev *dev);
+int yaffs2_checkpt_restore(struct yaffs_dev *dev);
+
+int yaffs2_handle_hole(struct yaffs_obj *obj, loff_t new_size);
+int yaffs2_scan_backwards(struct yaffs_dev *dev);
+
+#endif
diff -uraN linux-3.0.8/fs/yaffs2/yportenv.h linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yportenv.h
--- linux-3.0.8/fs/yaffs2/yportenv.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/fs/yaffs2/yportenv.h	2021-07-13 23:40:33.786357014 +0300
@@ -0,0 +1,82 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YPORTENV_H__
+#define __YPORTENV_H__
+
+/*
+ * Define the MTD version in terms of Linux Kernel versions
+ * This allows yaffs to be used independantly of the kernel
+ * as well as with it.
+ */
+
+#define MTD_VERSION(a, b, c) (((a) << 16) + ((b) << 8) + (c))
+
+#ifdef YAFFS_OUT_OF_TREE
+#include "moduleconfig.h"
+#endif
+
+#include <linux/version.h>
+#define MTD_VERSION_CODE LINUX_VERSION_CODE
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+#include <linux/config.h>
+#endif
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/xattr.h>
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/stat.h>
+#include <linux/sort.h>
+#include <linux/bitops.h>
+
+/*  These type wrappings are used to support Unicode names in WinCE. */
+#define YCHAR char
+#define YUCHAR unsigned char
+#define _Y(x)     x
+
+#define YAFFS_LOSTNFOUND_NAME		"lost+found"
+#define YAFFS_LOSTNFOUND_PREFIX		"obj"
+
+
+#define YAFFS_ROOT_MODE			0755
+#define YAFFS_LOSTNFOUND_MODE		0700
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+#define Y_CURRENT_TIME CURRENT_TIME.tv_sec
+#define Y_TIME_CONVERT(x) (x).tv_sec
+#else
+#define Y_CURRENT_TIME CURRENT_TIME
+#define Y_TIME_CONVERT(x) (x)
+#endif
+
+#define compile_time_assertion(assertion) \
+	({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })
+
+
+#define yaffs_trace(msk, fmt, ...) do { \
+	if (yaffs_trace_mask & (msk)) \
+		printk(KERN_DEBUG "yaffs: " fmt "\n", ##__VA_ARGS__); \
+} while (0)
+
+
+#endif
diff -uraN linux-3.0.8/.gitignore linux-3.0.8-fh8632-V1.0_20180330/.gitignore
--- linux-3.0.8/.gitignore	2021-07-14 21:51:58.059119660 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1,81 +0,0 @@
-#
-# NOTE! Don't add files that are generated in specific
-# subdirectories here. Add them in the ".gitignore" file
-# in that subdirectory instead.
-#
-# NOTE! Please use 'git ls-files -i --exclude-standard'
-# command after changing this file, to see if there are
-# any tracked files which get ignored after the change.
-#
-# Normal rules
-#
-.*
-*.o
-*.o.*
-*.a
-*.s
-*.ko
-*.so
-*.so.dbg
-*.mod.c
-*.i
-*.lst
-*.symtypes
-*.order
-modules.builtin
-*.elf
-*.bin
-*.gz
-*.bz2
-*.lzma
-*.xz
-*.lzo
-*.patch
-*.gcno
-
-#
-# Top-level generic files
-#
-/tags
-/TAGS
-/linux
-/vmlinux
-/vmlinuz
-/System.map
-/Module.markers
-/Module.symvers
-
-#
-# git files that we don't want to ignore even it they are dot-files
-#
-!.gitignore
-!.mailmap
-
-#
-# Generated include files
-#
-include/config
-include/linux/version.h
-include/generated
-arch/*/include/generated
-
-# stgit generated dirs
-patches-*
-
-# quilt's files
-patches
-series
-
-# cscope files
-cscope.*
-ncscope.*
-
-# gnu global files
-GPATH
-GRTAGS
-GSYMS
-GTAGS
-
-*.orig
-*~
-\#*#
diff -uraN linux-3.0.8/include/linux/clk.h linux-3.0.8-fh8632-V1.0_20180330/include/linux/clk.h
--- linux-3.0.8/include/linux/clk.h	2021-07-14 21:52:05.359140791 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/include/linux/clk.h	2021-07-13 23:40:38.914387427 +0300
@@ -64,6 +64,11 @@
  */
 void clk_disable(struct clk *clk);
 
+/*
+ * clk_reset
+ */
+void clk_reset(struct clk *clk);
+
 /**
  * clk_get_rate - obtain the current clock rate (in Hz) for a clock source.
  *		  This is only valid once the clock source has been enabled.
@@ -155,4 +160,6 @@
 int clk_add_alias(const char *alias, const char *alias_dev_name, char *id,
 			struct device *dev);
 
+void clk_change_parent(struct clk *clk, int select);
+
 #endif
diff -uraN linux-3.0.8/include/linux/dmaengine.h linux-3.0.8-fh8632-V1.0_20180330/include/linux/dmaengine.h
--- linux-3.0.8/include/linux/dmaengine.h	2021-07-14 21:52:05.387140873 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/include/linux/dmaengine.h	2021-07-13 23:40:38.894387313 +0300
@@ -18,12 +18,16 @@
  * The full GNU General Public License is included in this distribution in the
  * file called COPYING.
  */
-#ifndef DMAENGINE_H
-#define DMAENGINE_H
+#ifndef LINUX_DMAENGINE_H
+#define LINUX_DMAENGINE_H
 
 #include <linux/device.h>
 #include <linux/uio.h>
-#include <linux/dma-mapping.h>
+#include <linux/bug.h>
+#include <linux/scatterlist.h>
+#include <linux/bitmap.h>
+#include <linux/types.h>
+#include <asm/page.h>
 
 /**
  * typedef dma_cookie_t - an opaque DMA cookie
@@ -31,8 +35,8 @@
  * if dma_cookie_t is >0 it's a DMA request cookie, <0 it's an error code
  */
 typedef s32 dma_cookie_t;
-#define DMA_MIN_COOKIE	1
-#define DMA_MAX_COOKIE	INT_MAX
+#define DMA_MIN_COOKIE  1
+#define DMA_MAX_COOKIE  INT_MAX
 
 #define dma_submit_error(cookie) ((cookie) < 0 ? 1 : 0)
 
@@ -44,10 +48,10 @@
  * @DMA_ERROR: transaction failed
  */
 enum dma_status {
-	DMA_SUCCESS,
-	DMA_IN_PROGRESS,
-	DMA_PAUSED,
-	DMA_ERROR,
+    DMA_SUCCESS,
+    DMA_IN_PROGRESS,
+    DMA_PAUSED,
+    DMA_ERROR,
 };
 
 /**
@@ -57,23 +61,105 @@
  * automatically set as dma devices are registered.
  */
 enum dma_transaction_type {
-	DMA_MEMCPY,
-	DMA_XOR,
-	DMA_PQ,
-	DMA_XOR_VAL,
-	DMA_PQ_VAL,
-	DMA_MEMSET,
-	DMA_INTERRUPT,
-	DMA_SG,
-	DMA_PRIVATE,
-	DMA_ASYNC_TX,
-	DMA_SLAVE,
-	DMA_CYCLIC,
+    DMA_MEMCPY,
+    DMA_XOR,
+    DMA_PQ,
+    DMA_XOR_VAL,
+    DMA_PQ_VAL,
+    DMA_MEMSET,
+    DMA_INTERRUPT,
+    DMA_SG,
+    DMA_PRIVATE,
+    DMA_ASYNC_TX,
+    DMA_SLAVE,
+    DMA_CYCLIC,
+    DMA_INTERLEAVE,
+/* last transaction type for creation of the capabilities mask */
+    DMA_TX_TYPE_END,
 };
 
-/* last transaction type for creation of the capabilities mask */
-#define DMA_TX_TYPE_END (DMA_CYCLIC + 1)
+/**
+ * enum dma_transfer_direction - dma transfer mode and direction indicator
+ * @DMA_MEM_TO_MEM: Async/Memcpy mode
+ * @DMA_MEM_TO_DEV: Slave mode & From Memory to Device
+ * @DMA_DEV_TO_MEM: Slave mode & From Device to Memory
+ * @DMA_DEV_TO_DEV: Slave mode & From Device to Device
+ */
+enum dma_transfer_direction {
+    DMA_MEM_TO_MEM,
+    DMA_MEM_TO_DEV,
+    DMA_DEV_TO_MEM,
+    DMA_DEV_TO_DEV,
+    DMA_TRANS_NONE,
+};
+
+/**
+ * Interleaved Transfer Request
+ * ----------------------------
+ * A chunk is collection of contiguous bytes to be transfered.
+ * The gap(in bytes) between two chunks is called inter-chunk-gap(ICG).
+ * ICGs may or maynot change between chunks.
+ * A FRAME is the smallest series of contiguous {chunk,icg} pairs,
+ *  that when repeated an integral number of times, specifies the transfer.
+ * A transfer template is specification of a Frame, the number of times
+ *  it is to be repeated and other per-transfer attributes.
+ *
+ * Practically, a client driver would have ready a template for each
+ *  type of transfer it is going to need during its lifetime and
+ *  set only 'src_start' and 'dst_start' before submitting the requests.
+ *
+ *
+ *  |      Frame-1        |       Frame-2       | ~ |       Frame-'numf'  |
+ *  |====....==.===...=...|====....==.===...=...| ~ |====....==.===...=...|
+ *
+ *    ==  Chunk size
+ *    ... ICG
+ */
+
+/**
+ * struct data_chunk - Element of scatter-gather list that makes a frame.
+ * @size: Number of bytes to read from source.
+ *    size_dst := fn(op, size_src), so doesn't mean much for destination.
+ * @icg: Number of bytes to jump after last src/dst address of this
+ *   chunk and before first src/dst address for next chunk.
+ *   Ignored for dst(assumed 0), if dst_inc is true and dst_sgl is false.
+ *   Ignored for src(assumed 0), if src_inc is true and src_sgl is false.
+ */
+struct data_chunk {
+    size_t size;
+    size_t icg;
+};
 
+/**
+ * struct dma_interleaved_template - Template to convey DMAC the transfer pattern
+ *   and attributes.
+ * @src_start: Bus address of source for the first chunk.
+ * @dst_start: Bus address of destination for the first chunk.
+ * @dir: Specifies the type of Source and Destination.
+ * @src_inc: If the source address increments after reading from it.
+ * @dst_inc: If the destination address increments after writing to it.
+ * @src_sgl: If the 'icg' of sgl[] applies to Source (scattered read).
+ *      Otherwise, source is read contiguously (icg ignored).
+ *      Ignored if src_inc is false.
+ * @dst_sgl: If the 'icg' of sgl[] applies to Destination (scattered write).
+ *      Otherwise, destination is filled contiguously (icg ignored).
+ *      Ignored if dst_inc is false.
+ * @numf: Number of frames in this template.
+ * @frame_size: Number of chunks in a frame i.e, size of sgl[].
+ * @sgl: Array of {chunk,icg} pairs that make up a frame.
+ */
+struct dma_interleaved_template {
+    dma_addr_t src_start;
+    dma_addr_t dst_start;
+    enum dma_transfer_direction dir;
+    bool src_inc;
+    bool dst_inc;
+    bool src_sgl;
+    bool dst_sgl;
+    size_t numf;
+    size_t frame_size;
+    struct data_chunk sgl[0];
+};
 
 /**
  * enum dma_ctrl_flags - DMA flags to augment operation preparation,
@@ -86,9 +172,9 @@
  * @DMA_COMPL_SKIP_SRC_UNMAP - set to disable dma-unmapping the source buffer(s)
  * @DMA_COMPL_SKIP_DEST_UNMAP - set to disable dma-unmapping the destination(s)
  * @DMA_COMPL_SRC_UNMAP_SINGLE - set to do the source dma-unmapping as single
- * 	(if not set, do the source dma-unmapping as page)
+ *  (if not set, do the source dma-unmapping as page)
  * @DMA_COMPL_DEST_UNMAP_SINGLE - set to do the destination dma-unmapping as single
- * 	(if not set, do the destination dma-unmapping as page)
+ *  (if not set, do the destination dma-unmapping as page)
  * @DMA_PREP_PQ_DISABLE_P - prevent generation of P while generating Q
  * @DMA_PREP_PQ_DISABLE_Q - prevent generation of Q while generating P
  * @DMA_PREP_CONTINUE - indicate to a driver that it is reusing buffers as
@@ -98,16 +184,16 @@
  *  on the result of this operation
  */
 enum dma_ctrl_flags {
-	DMA_PREP_INTERRUPT = (1 << 0),
-	DMA_CTRL_ACK = (1 << 1),
-	DMA_COMPL_SKIP_SRC_UNMAP = (1 << 2),
-	DMA_COMPL_SKIP_DEST_UNMAP = (1 << 3),
-	DMA_COMPL_SRC_UNMAP_SINGLE = (1 << 4),
-	DMA_COMPL_DEST_UNMAP_SINGLE = (1 << 5),
-	DMA_PREP_PQ_DISABLE_P = (1 << 6),
-	DMA_PREP_PQ_DISABLE_Q = (1 << 7),
-	DMA_PREP_CONTINUE = (1 << 8),
-	DMA_PREP_FENCE = (1 << 9),
+    DMA_PREP_INTERRUPT = (1 << 0),
+    DMA_CTRL_ACK = (1 << 1),
+    DMA_COMPL_SKIP_SRC_UNMAP = (1 << 2),
+    DMA_COMPL_SKIP_DEST_UNMAP = (1 << 3),
+    DMA_COMPL_SRC_UNMAP_SINGLE = (1 << 4),
+    DMA_COMPL_DEST_UNMAP_SINGLE = (1 << 5),
+    DMA_PREP_PQ_DISABLE_P = (1 << 6),
+    DMA_PREP_PQ_DISABLE_Q = (1 << 7),
+    DMA_PREP_CONTINUE = (1 << 8),
+    DMA_PREP_FENCE = (1 << 9),
 };
 
 /**
@@ -125,19 +211,19 @@
  * into external start mode.
  */
 enum dma_ctrl_cmd {
-	DMA_TERMINATE_ALL,
-	DMA_PAUSE,
-	DMA_RESUME,
-	DMA_SLAVE_CONFIG,
-	FSLDMA_EXTERNAL_START,
+    DMA_TERMINATE_ALL,
+    DMA_PAUSE,
+    DMA_RESUME,
+    DMA_SLAVE_CONFIG,
+    FSLDMA_EXTERNAL_START,
 };
 
 /**
  * enum sum_check_bits - bit position of pq_check_flags
  */
 enum sum_check_bits {
-	SUM_CHECK_P = 0,
-	SUM_CHECK_Q = 1,
+    SUM_CHECK_P = 0,
+    SUM_CHECK_Q = 1,
 };
 
 /**
@@ -146,8 +232,8 @@
  * @SUM_CHECK_Q_RESULT - 1 if reed-solomon zero sum error, 0 otherwise
  */
 enum sum_check_flags {
-	SUM_CHECK_P_RESULT = (1 << SUM_CHECK_P),
-	SUM_CHECK_Q_RESULT = (1 << SUM_CHECK_Q),
+    SUM_CHECK_P_RESULT = (1 << SUM_CHECK_P),
+    SUM_CHECK_Q_RESULT = (1 << SUM_CHECK_Q),
 };
 
 
@@ -164,15 +250,16 @@
  */
 
 struct dma_chan_percpu {
-	/* stats */
-	unsigned long memcpy_count;
-	unsigned long bytes_transferred;
+    /* stats */
+    unsigned long memcpy_count;
+    unsigned long bytes_transferred;
 };
 
 /**
  * struct dma_chan - devices supply DMA channels, clients use them
  * @device: ptr to the dma device who supplies this channel, always !%NULL
  * @cookie: last cookie value returned to client
+ * @completed_cookie: last completed cookie for this channel
  * @chan_id: channel ID for sysfs
  * @dev: class device for sysfs
  * @device_node: used to add this to the device chan list
@@ -182,18 +269,19 @@
  * @private: private data for certain client-channel associations
  */
 struct dma_chan {
-	struct dma_device *device;
-	dma_cookie_t cookie;
-
-	/* sysfs */
-	int chan_id;
-	struct dma_chan_dev *dev;
-
-	struct list_head device_node;
-	struct dma_chan_percpu __percpu *local;
-	int client_count;
-	int table_count;
-	void *private;
+    struct dma_device *device;
+    dma_cookie_t cookie;
+    dma_cookie_t completed_cookie;
+
+    /* sysfs */
+    int chan_id;
+    struct dma_chan_dev *dev;
+
+    struct list_head device_node;
+    struct dma_chan_percpu __percpu *local;
+    int client_count;
+    int table_count;
+    void *private;
 };
 
 /**
@@ -204,10 +292,10 @@
  * @idr_ref - reference count to gate release of dma_device dev_id
  */
 struct dma_chan_dev {
-	struct dma_chan *chan;
-	struct device device;
-	int dev_id;
-	atomic_t *idr_ref;
+    struct dma_chan *chan;
+    struct device device;
+    int dev_id;
+    atomic_t *idr_ref;
 };
 
 /**
@@ -215,11 +303,11 @@
  * device, source or target buses
  */
 enum dma_slave_buswidth {
-	DMA_SLAVE_BUSWIDTH_UNDEFINED = 0,
-	DMA_SLAVE_BUSWIDTH_1_BYTE = 1,
-	DMA_SLAVE_BUSWIDTH_2_BYTES = 2,
-	DMA_SLAVE_BUSWIDTH_4_BYTES = 4,
-	DMA_SLAVE_BUSWIDTH_8_BYTES = 8,
+    DMA_SLAVE_BUSWIDTH_UNDEFINED = 0,
+    DMA_SLAVE_BUSWIDTH_1_BYTE = 1,
+    DMA_SLAVE_BUSWIDTH_2_BYTES = 2,
+    DMA_SLAVE_BUSWIDTH_4_BYTES = 4,
+    DMA_SLAVE_BUSWIDTH_8_BYTES = 8,
 };
 
 /**
@@ -247,6 +335,12 @@
  * may or may not be applicable on memory sources.
  * @dst_maxburst: same as src_maxburst but for destination target
  * mutatis mutandis.
+ * @device_fc: Flow Controller Settings. Only valid for slave channels. Fill
+ * with 'true' if peripheral should be flow controller. Direction will be
+ * selected at Runtime.
+ * @slave_id: Slave requester id. Only valid for slave channels. The dma
+ * slave peripheral will have unique id as dma requester which need to be
+ * pass as slave config.
  *
  * This struct is passed in as configuration data to a DMA engine
  * in order to set up a certain channel for DMA transport at runtime.
@@ -266,18 +360,20 @@
  * struct, if applicable.
  */
 struct dma_slave_config {
-	enum dma_data_direction direction;
-	dma_addr_t src_addr;
-	dma_addr_t dst_addr;
-	enum dma_slave_buswidth src_addr_width;
-	enum dma_slave_buswidth dst_addr_width;
-	u32 src_maxburst;
-	u32 dst_maxburst;
+    enum dma_transfer_direction direction;
+    dma_addr_t src_addr;
+    dma_addr_t dst_addr;
+    enum dma_slave_buswidth src_addr_width;
+    enum dma_slave_buswidth dst_addr_width;
+    u32 src_maxburst;
+    u32 dst_maxburst;
+    bool device_fc;
+    unsigned int slave_id;
 };
 
 static inline const char *dma_chan_name(struct dma_chan *chan)
 {
-	return dev_name(&chan->dev->device);
+    return dev_name(&chan->dev->device);
 }
 
 void dma_chan_cleanup(struct kref *kref);
@@ -300,9 +396,9 @@
  * struct dma_async_tx_descriptor - async transaction descriptor
  * ---dma generic offload fields---
  * @cookie: tracking cookie for this transaction, set to -EBUSY if
- *	this tx is sitting on a dependency list
+ *  this tx is sitting on a dependency list
  * @flags: flags to augment operation preparation, control completion, and
- * 	communicate status
+ *  communicate status
  * @phys: physical address of the descriptor
  * @chan: target channel for this operation
  * @tx_submit: set the prepared descriptor(s) to be executed by the engine
@@ -314,17 +410,17 @@
  * @lock: protect the parent and next pointers
  */
 struct dma_async_tx_descriptor {
-	dma_cookie_t cookie;
-	enum dma_ctrl_flags flags; /* not a 'long' to pack with cookie */
-	dma_addr_t phys;
-	struct dma_chan *chan;
-	dma_cookie_t (*tx_submit)(struct dma_async_tx_descriptor *tx);
-	dma_async_tx_callback callback;
-	void *callback_param;
+    dma_cookie_t cookie;
+    enum dma_ctrl_flags flags; /* not a 'long' to pack with cookie */
+    dma_addr_t phys;
+    struct dma_chan *chan;
+    dma_cookie_t (*tx_submit)(struct dma_async_tx_descriptor *tx);
+    dma_async_tx_callback callback;
+    void *callback_param;
 #ifdef CONFIG_ASYNC_TX_ENABLE_CHANNEL_SWITCH
-	struct dma_async_tx_descriptor *next;
-	struct dma_async_tx_descriptor *parent;
-	spinlock_t lock;
+    struct dma_async_tx_descriptor *next;
+    struct dma_async_tx_descriptor *parent;
+    spinlock_t lock;
 #endif
 };
 
@@ -337,7 +433,7 @@
 }
 static inline void txd_chain(struct dma_async_tx_descriptor *txd, struct dma_async_tx_descriptor *next)
 {
-	BUG();
+    BUG();
 }
 static inline void txd_clear_parent(struct dma_async_tx_descriptor *txd)
 {
@@ -347,42 +443,42 @@
 }
 static inline struct dma_async_tx_descriptor *txd_next(struct dma_async_tx_descriptor *txd)
 {
-	return NULL;
+    return NULL;
 }
 static inline struct dma_async_tx_descriptor *txd_parent(struct dma_async_tx_descriptor *txd)
 {
-	return NULL;
+    return NULL;
 }
 
 #else
 static inline void txd_lock(struct dma_async_tx_descriptor *txd)
 {
-	spin_lock_bh(&txd->lock);
+    spin_lock_bh(&txd->lock);
 }
 static inline void txd_unlock(struct dma_async_tx_descriptor *txd)
 {
-	spin_unlock_bh(&txd->lock);
+    spin_unlock_bh(&txd->lock);
 }
 static inline void txd_chain(struct dma_async_tx_descriptor *txd, struct dma_async_tx_descriptor *next)
 {
-	txd->next = next;
-	next->parent = txd;
+    txd->next = next;
+    next->parent = txd;
 }
 static inline void txd_clear_parent(struct dma_async_tx_descriptor *txd)
 {
-	txd->parent = NULL;
+    txd->parent = NULL;
 }
 static inline void txd_clear_next(struct dma_async_tx_descriptor *txd)
 {
-	txd->next = NULL;
+    txd->next = NULL;
 }
 static inline struct dma_async_tx_descriptor *txd_parent(struct dma_async_tx_descriptor *txd)
 {
-	return txd->parent;
+    return txd->parent;
 }
 static inline struct dma_async_tx_descriptor *txd_next(struct dma_async_tx_descriptor *txd)
 {
-	return txd->next;
+    return txd->next;
 }
 #endif
 
@@ -392,13 +488,13 @@
  * @last: last completed DMA cookie
  * @used: last issued DMA cookie (i.e. the one in progress)
  * @residue: the remaining number of bytes left to transmit
- *	on the selected transfer for states DMA_IN_PROGRESS and
- *	DMA_PAUSED if this is implemented in the driver, else 0
+ *  on the selected transfer for states DMA_IN_PROGRESS and
+ *  DMA_PAUSED if this is implemented in the driver, else 0
  */
 struct dma_tx_state {
-	dma_cookie_t last;
-	dma_cookie_t used;
-	u32 residue;
+    dma_cookie_t last;
+    dma_cookie_t used;
+    u32 residue;
 };
 
 /**
@@ -417,7 +513,7 @@
  * @dev_id: unique device ID
  * @dev: struct device reference for dma mapping api
  * @device_alloc_chan_resources: allocate resources and return the
- *	number of allocated descriptors
+ *  number of allocated descriptors
  * @device_free_chan_resources: release DMA channel's resources
  * @device_prep_dma_memcpy: prepares a memcpy operation
  * @device_prep_dma_xor: prepares a xor operation
@@ -428,179 +524,247 @@
  * @device_prep_dma_interrupt: prepares an end of chain interrupt operation
  * @device_prep_slave_sg: prepares a slave dma operation
  * @device_prep_dma_cyclic: prepare a cyclic dma operation suitable for audio.
- *	The function takes a buffer of size buf_len. The callback function will
- *	be called after period_len bytes have been transferred.
+ *  The function takes a buffer of size buf_len. The callback function will
+ *  be called after period_len bytes have been transferred.
+ * @device_prep_interleaved_dma: Transfer expression in a generic way.
  * @device_control: manipulate all pending operations on a channel, returns
- *	zero or error code
+ *  zero or error code
  * @device_tx_status: poll for transaction completion, the optional
- *	txstate parameter can be supplied with a pointer to get a
- *	struct with auxiliary transfer status information, otherwise the call
- *	will just return a simple status code
+ *  txstate parameter can be supplied with a pointer to get a
+ *  struct with auxiliary transfer status information, otherwise the call
+ *  will just return a simple status code
  * @device_issue_pending: push pending transactions to hardware
  */
 struct dma_device {
 
-	unsigned int chancnt;
-	unsigned int privatecnt;
-	struct list_head channels;
-	struct list_head global_node;
-	dma_cap_mask_t  cap_mask;
-	unsigned short max_xor;
-	unsigned short max_pq;
-	u8 copy_align;
-	u8 xor_align;
-	u8 pq_align;
-	u8 fill_align;
-	#define DMA_HAS_PQ_CONTINUE (1 << 15)
-
-	int dev_id;
-	struct device *dev;
-
-	int (*device_alloc_chan_resources)(struct dma_chan *chan);
-	void (*device_free_chan_resources)(struct dma_chan *chan);
-
-	struct dma_async_tx_descriptor *(*device_prep_dma_memcpy)(
-		struct dma_chan *chan, dma_addr_t dest, dma_addr_t src,
-		size_t len, unsigned long flags);
-	struct dma_async_tx_descriptor *(*device_prep_dma_xor)(
-		struct dma_chan *chan, dma_addr_t dest, dma_addr_t *src,
-		unsigned int src_cnt, size_t len, unsigned long flags);
-	struct dma_async_tx_descriptor *(*device_prep_dma_xor_val)(
-		struct dma_chan *chan, dma_addr_t *src,	unsigned int src_cnt,
-		size_t len, enum sum_check_flags *result, unsigned long flags);
-	struct dma_async_tx_descriptor *(*device_prep_dma_pq)(
-		struct dma_chan *chan, dma_addr_t *dst, dma_addr_t *src,
-		unsigned int src_cnt, const unsigned char *scf,
-		size_t len, unsigned long flags);
-	struct dma_async_tx_descriptor *(*device_prep_dma_pq_val)(
-		struct dma_chan *chan, dma_addr_t *pq, dma_addr_t *src,
-		unsigned int src_cnt, const unsigned char *scf, size_t len,
-		enum sum_check_flags *pqres, unsigned long flags);
-	struct dma_async_tx_descriptor *(*device_prep_dma_memset)(
-		struct dma_chan *chan, dma_addr_t dest, int value, size_t len,
-		unsigned long flags);
-	struct dma_async_tx_descriptor *(*device_prep_dma_interrupt)(
-		struct dma_chan *chan, unsigned long flags);
-	struct dma_async_tx_descriptor *(*device_prep_dma_sg)(
-		struct dma_chan *chan,
-		struct scatterlist *dst_sg, unsigned int dst_nents,
-		struct scatterlist *src_sg, unsigned int src_nents,
-		unsigned long flags);
-
-	struct dma_async_tx_descriptor *(*device_prep_slave_sg)(
-		struct dma_chan *chan, struct scatterlist *sgl,
-		unsigned int sg_len, enum dma_data_direction direction,
-		unsigned long flags);
-	struct dma_async_tx_descriptor *(*device_prep_dma_cyclic)(
-		struct dma_chan *chan, dma_addr_t buf_addr, size_t buf_len,
-		size_t period_len, enum dma_data_direction direction);
-	int (*device_control)(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
-		unsigned long arg);
-
-	enum dma_status (*device_tx_status)(struct dma_chan *chan,
-					    dma_cookie_t cookie,
-					    struct dma_tx_state *txstate);
-	void (*device_issue_pending)(struct dma_chan *chan);
+    unsigned int chancnt;
+    unsigned int privatecnt;
+    struct list_head channels;
+    struct list_head global_node;
+    dma_cap_mask_t  cap_mask;
+    unsigned short max_xor;
+    unsigned short max_pq;
+    u8 copy_align;
+    u8 xor_align;
+    u8 pq_align;
+    u8 fill_align;
+    #define DMA_HAS_PQ_CONTINUE (1 << 15)
+
+    int dev_id;
+    struct device *dev;
+
+    int (*device_alloc_chan_resources)(struct dma_chan *chan);
+    void (*device_free_chan_resources)(struct dma_chan *chan);
+
+    struct dma_async_tx_descriptor *(*device_prep_dma_memcpy)(
+        struct dma_chan *chan, dma_addr_t dest, dma_addr_t src,
+        size_t len, unsigned long flags);
+    struct dma_async_tx_descriptor *(*device_prep_dma_xor)(
+        struct dma_chan *chan, dma_addr_t dest, dma_addr_t *src,
+        unsigned int src_cnt, size_t len, unsigned long flags);
+    struct dma_async_tx_descriptor *(*device_prep_dma_xor_val)(
+        struct dma_chan *chan, dma_addr_t *src, unsigned int src_cnt,
+        size_t len, enum sum_check_flags *result, unsigned long flags);
+    struct dma_async_tx_descriptor *(*device_prep_dma_pq)(
+        struct dma_chan *chan, dma_addr_t *dst, dma_addr_t *src,
+        unsigned int src_cnt, const unsigned char *scf,
+        size_t len, unsigned long flags);
+    struct dma_async_tx_descriptor *(*device_prep_dma_pq_val)(
+        struct dma_chan *chan, dma_addr_t *pq, dma_addr_t *src,
+        unsigned int src_cnt, const unsigned char *scf, size_t len,
+        enum sum_check_flags *pqres, unsigned long flags);
+    struct dma_async_tx_descriptor *(*device_prep_dma_memset)(
+        struct dma_chan *chan, dma_addr_t dest, int value, size_t len,
+        unsigned long flags);
+    struct dma_async_tx_descriptor *(*device_prep_dma_interrupt)(
+        struct dma_chan *chan, unsigned long flags);
+    struct dma_async_tx_descriptor *(*device_prep_dma_sg)(
+        struct dma_chan *chan,
+        struct scatterlist *dst_sg, unsigned int dst_nents,
+        struct scatterlist *src_sg, unsigned int src_nents,
+        unsigned long flags);
+
+    struct dma_async_tx_descriptor *(*device_prep_slave_sg)(
+        struct dma_chan *chan, struct scatterlist *sgl,
+        unsigned int sg_len, enum dma_transfer_direction direction,
+        unsigned long flags, void *context);
+    struct dma_async_tx_descriptor *(*device_prep_dma_cyclic)(
+        struct dma_chan *chan, dma_addr_t buf_addr, size_t buf_len,
+        size_t period_len, enum dma_transfer_direction direction,
+        unsigned long flags, void *context);
+    struct dma_async_tx_descriptor *(*device_prep_interleaved_dma)(
+        struct dma_chan *chan, struct dma_interleaved_template *xt,
+        unsigned long flags);
+    int (*device_control)(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
+        unsigned long arg);
+
+    enum dma_status (*device_tx_status)(struct dma_chan *chan,
+                        dma_cookie_t cookie,
+                        struct dma_tx_state *txstate);
+    void (*device_issue_pending)(struct dma_chan *chan);
 };
 
 static inline int dmaengine_device_control(struct dma_chan *chan,
-					   enum dma_ctrl_cmd cmd,
-					   unsigned long arg)
+                       enum dma_ctrl_cmd cmd,
+                       unsigned long arg)
 {
-	return chan->device->device_control(chan, cmd, arg);
+    if (chan->device->device_control)
+        return chan->device->device_control(chan, cmd, arg);
+
+    return -ENOSYS;
 }
 
 static inline int dmaengine_slave_config(struct dma_chan *chan,
-					  struct dma_slave_config *config)
+                      struct dma_slave_config *config)
+{
+    return dmaengine_device_control(chan, DMA_SLAVE_CONFIG,
+            (unsigned long)config);
+}
+
+static inline bool is_slave_direction(enum dma_transfer_direction direction)
+{
+    return (direction == DMA_MEM_TO_DEV) || (direction == DMA_DEV_TO_MEM);
+}
+
+static inline struct dma_async_tx_descriptor *dmaengine_prep_slave_single(
+    struct dma_chan *chan, dma_addr_t buf, size_t len,
+    enum dma_transfer_direction dir, unsigned long flags)
+{
+    struct scatterlist sg;
+    sg_init_table(&sg, 1);
+    sg_dma_address(&sg) = buf;
+    sg_dma_len(&sg) = len;
+
+    return chan->device->device_prep_slave_sg(chan, &sg, 1,
+                          dir, flags, NULL);
+}
+
+static inline struct dma_async_tx_descriptor *dmaengine_prep_slave_sg(
+    struct dma_chan *chan, struct scatterlist *sgl, unsigned int sg_len,
+    enum dma_transfer_direction dir, unsigned long flags)
 {
-	return dmaengine_device_control(chan, DMA_SLAVE_CONFIG,
-			(unsigned long)config);
+    return chan->device->device_prep_slave_sg(chan, sgl, sg_len,
+                          dir, flags, NULL);
+}
+
+#ifdef CONFIG_RAPIDIO_DMA_ENGINE
+struct rio_dma_ext;
+static inline struct dma_async_tx_descriptor *dmaengine_prep_rio_sg(
+    struct dma_chan *chan, struct scatterlist *sgl, unsigned int sg_len,
+    enum dma_transfer_direction dir, unsigned long flags,
+    struct rio_dma_ext *rio_ext)
+{
+    return chan->device->device_prep_slave_sg(chan, sgl, sg_len,
+                          dir, flags, rio_ext);
+}
+#endif
+
+static inline struct dma_async_tx_descriptor *dmaengine_prep_dma_cyclic(
+        struct dma_chan *chan, dma_addr_t buf_addr, size_t buf_len,
+        size_t period_len, enum dma_transfer_direction dir,
+        unsigned long flags)
+{
+    return chan->device->device_prep_dma_cyclic(chan, buf_addr, buf_len,
+                        period_len, dir, flags, NULL);
+}
+
+static inline struct dma_async_tx_descriptor *dmaengine_prep_interleaved_dma(
+        struct dma_chan *chan, struct dma_interleaved_template *xt,
+        unsigned long flags)
+{
+    return chan->device->device_prep_interleaved_dma(chan, xt, flags);
 }
 
 static inline int dmaengine_terminate_all(struct dma_chan *chan)
 {
-	return dmaengine_device_control(chan, DMA_TERMINATE_ALL, 0);
+    return dmaengine_device_control(chan, DMA_TERMINATE_ALL, 0);
 }
 
 static inline int dmaengine_pause(struct dma_chan *chan)
 {
-	return dmaengine_device_control(chan, DMA_PAUSE, 0);
+    return dmaengine_device_control(chan, DMA_PAUSE, 0);
 }
 
 static inline int dmaengine_resume(struct dma_chan *chan)
 {
-	return dmaengine_device_control(chan, DMA_RESUME, 0);
+    return dmaengine_device_control(chan, DMA_RESUME, 0);
+}
+
+static inline enum dma_status dmaengine_tx_status(struct dma_chan *chan,
+    dma_cookie_t cookie, struct dma_tx_state *state)
+{
+    return chan->device->device_tx_status(chan, cookie, state);
 }
 
 static inline dma_cookie_t dmaengine_submit(struct dma_async_tx_descriptor *desc)
 {
-	return desc->tx_submit(desc);
+    return desc->tx_submit(desc);
 }
 
 static inline bool dmaengine_check_align(u8 align, size_t off1, size_t off2, size_t len)
 {
-	size_t mask;
+    size_t mask;
 
-	if (!align)
-		return true;
-	mask = (1 << align) - 1;
-	if (mask & (off1 | off2 | len))
-		return false;
-	return true;
+    if (!align)
+        return true;
+    mask = (1 << align) - 1;
+    if (mask & (off1 | off2 | len))
+        return false;
+    return true;
 }
 
 static inline bool is_dma_copy_aligned(struct dma_device *dev, size_t off1,
-				       size_t off2, size_t len)
+                       size_t off2, size_t len)
 {
-	return dmaengine_check_align(dev->copy_align, off1, off2, len);
+    return dmaengine_check_align(dev->copy_align, off1, off2, len);
 }
 
 static inline bool is_dma_xor_aligned(struct dma_device *dev, size_t off1,
-				      size_t off2, size_t len)
+                      size_t off2, size_t len)
 {
-	return dmaengine_check_align(dev->xor_align, off1, off2, len);
+    return dmaengine_check_align(dev->xor_align, off1, off2, len);
 }
 
 static inline bool is_dma_pq_aligned(struct dma_device *dev, size_t off1,
-				     size_t off2, size_t len)
+                     size_t off2, size_t len)
 {
-	return dmaengine_check_align(dev->pq_align, off1, off2, len);
+    return dmaengine_check_align(dev->pq_align, off1, off2, len);
 }
 
 static inline bool is_dma_fill_aligned(struct dma_device *dev, size_t off1,
-				       size_t off2, size_t len)
+                       size_t off2, size_t len)
 {
-	return dmaengine_check_align(dev->fill_align, off1, off2, len);
+    return dmaengine_check_align(dev->fill_align, off1, off2, len);
 }
 
 static inline void
 dma_set_maxpq(struct dma_device *dma, int maxpq, int has_pq_continue)
 {
-	dma->max_pq = maxpq;
-	if (has_pq_continue)
-		dma->max_pq |= DMA_HAS_PQ_CONTINUE;
+    dma->max_pq = maxpq;
+    if (has_pq_continue)
+        dma->max_pq |= DMA_HAS_PQ_CONTINUE;
 }
 
 static inline bool dmaf_continue(enum dma_ctrl_flags flags)
 {
-	return (flags & DMA_PREP_CONTINUE) == DMA_PREP_CONTINUE;
+    return (flags & DMA_PREP_CONTINUE) == DMA_PREP_CONTINUE;
 }
 
 static inline bool dmaf_p_disabled_continue(enum dma_ctrl_flags flags)
 {
-	enum dma_ctrl_flags mask = DMA_PREP_CONTINUE | DMA_PREP_PQ_DISABLE_P;
+    enum dma_ctrl_flags mask = DMA_PREP_CONTINUE | DMA_PREP_PQ_DISABLE_P;
 
-	return (flags & mask) == mask;
+    return (flags & mask) == mask;
 }
 
 static inline bool dma_dev_has_pq_continue(struct dma_device *dma)
 {
-	return (dma->max_pq & DMA_HAS_PQ_CONTINUE) == DMA_HAS_PQ_CONTINUE;
+    return (dma->max_pq & DMA_HAS_PQ_CONTINUE) == DMA_HAS_PQ_CONTINUE;
 }
 
 static inline unsigned short dma_dev_to_maxpq(struct dma_device *dma)
 {
-	return dma->max_pq & ~DMA_HAS_PQ_CONTINUE;
+    return dma->max_pq & ~DMA_HAS_PQ_CONTINUE;
 }
 
 /* dma_maxpq - reduce maxpq in the face of continued operations
@@ -618,13 +782,13 @@
  */
 static inline int dma_maxpq(struct dma_device *dma, enum dma_ctrl_flags flags)
 {
-	if (dma_dev_has_pq_continue(dma) || !dmaf_continue(flags))
-		return dma_dev_to_maxpq(dma);
-	else if (dmaf_p_disabled_continue(flags))
-		return dma_dev_to_maxpq(dma) - 1;
-	else if (dmaf_continue(flags))
-		return dma_dev_to_maxpq(dma) - 3;
-	BUG();
+    if (dma_dev_has_pq_continue(dma) || !dmaf_continue(flags))
+        return dma_dev_to_maxpq(dma);
+    else if (dmaf_p_disabled_continue(flags))
+        return dma_dev_to_maxpq(dma) - 1;
+    else if (dmaf_continue(flags))
+        return dma_dev_to_maxpq(dma) - 3;
+    BUG();
 }
 
 /* --- public DMA engine API --- */
@@ -642,8 +806,8 @@
 #endif
 
 #ifdef CONFIG_NET_DMA
-#define net_dmaengine_get()	dmaengine_get()
-#define net_dmaengine_put()	dmaengine_put()
+#define net_dmaengine_get() dmaengine_get()
+#define net_dmaengine_put() dmaengine_put()
 #else
 static inline void net_dmaengine_get(void)
 {
@@ -654,8 +818,8 @@
 #endif
 
 #ifdef CONFIG_ASYNC_TX_DMA
-#define async_dmaengine_get()	dmaengine_get()
-#define async_dmaengine_put()	dmaengine_put()
+#define async_dmaengine_get()   dmaengine_get()
+#define async_dmaengine_put()   dmaengine_put()
 #ifndef CONFIG_ASYNC_TX_ENABLE_CHANNEL_SWITCH
 #define async_dma_find_channel(type) dma_find_channel(DMA_ASYNC_TX)
 #else
@@ -671,80 +835,64 @@
 static inline struct dma_chan *
 async_dma_find_channel(enum dma_transaction_type type)
 {
-	return NULL;
+    return NULL;
 }
 #endif /* CONFIG_ASYNC_TX_DMA */
 
 dma_cookie_t dma_async_memcpy_buf_to_buf(struct dma_chan *chan,
-	void *dest, void *src, size_t len);
+    void *dest, void *src, size_t len);
 dma_cookie_t dma_async_memcpy_buf_to_pg(struct dma_chan *chan,
-	struct page *page, unsigned int offset, void *kdata, size_t len);
+    struct page *page, unsigned int offset, void *kdata, size_t len);
 dma_cookie_t dma_async_memcpy_pg_to_pg(struct dma_chan *chan,
-	struct page *dest_pg, unsigned int dest_off, struct page *src_pg,
-	unsigned int src_off, size_t len);
+    struct page *dest_pg, unsigned int dest_off, struct page *src_pg,
+    unsigned int src_off, size_t len);
 void dma_async_tx_descriptor_init(struct dma_async_tx_descriptor *tx,
-	struct dma_chan *chan);
+    struct dma_chan *chan);
 
 static inline void async_tx_ack(struct dma_async_tx_descriptor *tx)
 {
-	tx->flags |= DMA_CTRL_ACK;
+    tx->flags |= DMA_CTRL_ACK;
 }
 
 static inline void async_tx_clear_ack(struct dma_async_tx_descriptor *tx)
 {
-	tx->flags &= ~DMA_CTRL_ACK;
+    tx->flags &= ~DMA_CTRL_ACK;
 }
 
 static inline bool async_tx_test_ack(struct dma_async_tx_descriptor *tx)
 {
-	return (tx->flags & DMA_CTRL_ACK) == DMA_CTRL_ACK;
-}
-
-#define first_dma_cap(mask) __first_dma_cap(&(mask))
-static inline int __first_dma_cap(const dma_cap_mask_t *srcp)
-{
-	return min_t(int, DMA_TX_TYPE_END,
-		find_first_bit(srcp->bits, DMA_TX_TYPE_END));
-}
-
-#define next_dma_cap(n, mask) __next_dma_cap((n), &(mask))
-static inline int __next_dma_cap(int n, const dma_cap_mask_t *srcp)
-{
-	return min_t(int, DMA_TX_TYPE_END,
-		find_next_bit(srcp->bits, DMA_TX_TYPE_END, n+1));
+    return (tx->flags & DMA_CTRL_ACK) == DMA_CTRL_ACK;
 }
 
 #define dma_cap_set(tx, mask) __dma_cap_set((tx), &(mask))
 static inline void
 __dma_cap_set(enum dma_transaction_type tx_type, dma_cap_mask_t *dstp)
 {
-	set_bit(tx_type, dstp->bits);
+    set_bit(tx_type, dstp->bits);
 }
 
 #define dma_cap_clear(tx, mask) __dma_cap_clear((tx), &(mask))
 static inline void
 __dma_cap_clear(enum dma_transaction_type tx_type, dma_cap_mask_t *dstp)
 {
-	clear_bit(tx_type, dstp->bits);
+    clear_bit(tx_type, dstp->bits);
 }
 
 #define dma_cap_zero(mask) __dma_cap_zero(&(mask))
 static inline void __dma_cap_zero(dma_cap_mask_t *dstp)
 {
-	bitmap_zero(dstp->bits, DMA_TX_TYPE_END);
+    bitmap_zero(dstp->bits, DMA_TX_TYPE_END);
 }
 
 #define dma_has_cap(tx, mask) __dma_has_cap((tx), &(mask))
 static inline int
 __dma_has_cap(enum dma_transaction_type tx_type, dma_cap_mask_t *srcp)
 {
-	return test_bit(tx_type, srcp->bits);
+    return test_bit(tx_type, srcp->bits);
 }
 
 #define for_each_dma_cap_mask(cap, mask) \
-	for ((cap) = first_dma_cap(mask);	\
-		(cap) < DMA_TX_TYPE_END;	\
-		(cap) = next_dma_cap((cap), (mask)))
+    for_each_set_bit(cap, mask.bits, DMA_TX_TYPE_END)
 
 /**
  * dma_async_issue_pending - flush pending transactions to HW
@@ -755,11 +903,9 @@
  */
 static inline void dma_async_issue_pending(struct dma_chan *chan)
 {
-	chan->device->device_issue_pending(chan);
+    chan->device->device_issue_pending(chan);
 }
 
-#define dma_async_memcpy_issue_pending(chan) dma_async_issue_pending(chan)
-
 /**
  * dma_async_is_tx_complete - poll for transaction completion
  * @chan: DMA channel
@@ -772,72 +918,76 @@
  * the status of multiple cookies without re-checking hardware state.
  */
 static inline enum dma_status dma_async_is_tx_complete(struct dma_chan *chan,
-	dma_cookie_t cookie, dma_cookie_t *last, dma_cookie_t *used)
+    dma_cookie_t cookie, dma_cookie_t *last, dma_cookie_t *used)
 {
-	struct dma_tx_state state;
-	enum dma_status status;
+    struct dma_tx_state state;
+    enum dma_status status;
 
-	status = chan->device->device_tx_status(chan, cookie, &state);
-	if (last)
-		*last = state.last;
-	if (used)
-		*used = state.used;
-	return status;
+    status = chan->device->device_tx_status(chan, cookie, &state);
+    if (last)
+        *last = state.last;
+    if (used)
+        *used = state.used;
+    return status;
 }
 
-#define dma_async_memcpy_complete(chan, cookie, last, used)\
-	dma_async_is_tx_complete(chan, cookie, last, used)
-
 /**
  * dma_async_is_complete - test a cookie against chan state
  * @cookie: transaction identifier to test status of
  * @last_complete: last know completed transaction
  * @last_used: last cookie value handed out
  *
- * dma_async_is_complete() is used in dma_async_memcpy_complete()
+ * dma_async_is_complete() is used in dma_async_is_tx_complete()
  * the test logic is separated for lightweight testing of multiple cookies
  */
 static inline enum dma_status dma_async_is_complete(dma_cookie_t cookie,
-			dma_cookie_t last_complete, dma_cookie_t last_used)
+            dma_cookie_t last_complete, dma_cookie_t last_used)
 {
-	if (last_complete <= last_used) {
-		if ((cookie <= last_complete) || (cookie > last_used))
-			return DMA_SUCCESS;
-	} else {
-		if ((cookie <= last_complete) && (cookie > last_used))
-			return DMA_SUCCESS;
-	}
-	return DMA_IN_PROGRESS;
+    if (last_complete <= last_used) {
+        if ((cookie <= last_complete) || (cookie > last_used))
+            return DMA_SUCCESS;
+    } else {
+        if ((cookie <= last_complete) && (cookie > last_used))
+            return DMA_SUCCESS;
+    }
+    return DMA_IN_PROGRESS;
 }
 
 static inline void
 dma_set_tx_state(struct dma_tx_state *st, dma_cookie_t last, dma_cookie_t used, u32 residue)
 {
-	if (st) {
-		st->last = last;
-		st->used = used;
-		st->residue = residue;
-	}
+    if (st) {
+        st->last = last;
+        st->used = used;
+        st->residue = residue;
+    }
 }
 
 enum dma_status dma_sync_wait(struct dma_chan *chan, dma_cookie_t cookie);
 #ifdef CONFIG_DMA_ENGINE
 enum dma_status dma_wait_for_async_tx(struct dma_async_tx_descriptor *tx);
 void dma_issue_pending_all(void);
-struct dma_chan *__dma_request_channel(dma_cap_mask_t *mask, dma_filter_fn fn, void *fn_param);
+struct dma_chan *__dma_request_channel(const dma_cap_mask_t *mask,
+                    dma_filter_fn fn, void *fn_param);
+struct dma_chan *dma_request_slave_channel(struct device *dev, const char *name);
 void dma_release_channel(struct dma_chan *chan);
 #else
 static inline enum dma_status dma_wait_for_async_tx(struct dma_async_tx_descriptor *tx)
 {
-	return DMA_SUCCESS;
+    return DMA_SUCCESS;
 }
 static inline void dma_issue_pending_all(void)
 {
 }
-static inline struct dma_chan *__dma_request_channel(dma_cap_mask_t *mask,
-					      dma_filter_fn fn, void *fn_param)
+static inline struct dma_chan *__dma_request_channel(const dma_cap_mask_t *mask,
+                          dma_filter_fn fn, void *fn_param)
 {
-	return NULL;
+    return NULL;
+}
+static inline struct dma_chan *dma_request_slave_channel(struct device *dev,
+                             const char *name)
+{
+    return NULL;
 }
 static inline void dma_release_channel(struct dma_chan *chan)
 {
@@ -850,28 +1000,45 @@
 void dma_async_device_unregister(struct dma_device *device);
 void dma_run_dependencies(struct dma_async_tx_descriptor *tx);
 struct dma_chan *dma_find_channel(enum dma_transaction_type tx_type);
+struct dma_chan *net_dma_find_channel(void);
 #define dma_request_channel(mask, x, y) __dma_request_channel(&(mask), x, y)
+#define dma_request_slave_channel_compat(mask, x, y, dev, name) \
+    __dma_request_slave_channel_compat(&(mask), x, y, dev, name)
+
+static inline struct dma_chan
+*__dma_request_slave_channel_compat(const dma_cap_mask_t *mask,
+                  dma_filter_fn fn, void *fn_param,
+                  struct device *dev, char *name)
+{
+    struct dma_chan *chan;
+
+    chan = dma_request_slave_channel(dev, name);
+    if (chan)
+        return chan;
+
+    return __dma_request_channel(mask, fn, fn_param);
+}
 
 /* --- Helper iov-locking functions --- */
 
 struct dma_page_list {
-	char __user *base_address;
-	int nr_pages;
-	struct page **pages;
+    char __user *base_address;
+    int nr_pages;
+    struct page **pages;
 };
 
 struct dma_pinned_list {
-	int nr_iovecs;
-	struct dma_page_list page_list[0];
+    int nr_iovecs;
+    struct dma_page_list page_list[0];
 };
 
 struct dma_pinned_list *dma_pin_iovec_pages(struct iovec *iov, size_t len);
 void dma_unpin_iovec_pages(struct dma_pinned_list* pinned_list);
 
 dma_cookie_t dma_memcpy_to_iovec(struct dma_chan *chan, struct iovec *iov,
-	struct dma_pinned_list *pinned_list, unsigned char *kdata, size_t len);
+    struct dma_pinned_list *pinned_list, unsigned char *kdata, size_t len);
 dma_cookie_t dma_memcpy_pg_to_iovec(struct dma_chan *chan, struct iovec *iov,
-	struct dma_pinned_list *pinned_list, struct page *page,
-	unsigned int offset, size_t len);
+    struct dma_pinned_list *pinned_list, struct page *page,
+    unsigned int offset, size_t len);
 
 #endif /* DMAENGINE_H */
diff -uraN linux-3.0.8/include/linux/dw_dmac.h linux-3.0.8-fh8632-V1.0_20180330/include/linux/dw_dmac.h
--- linux-3.0.8/include/linux/dw_dmac.h	2021-07-14 21:52:05.391140884 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/include/linux/dw_dmac.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,139 +0,0 @@
-/*
- * Driver for the Synopsys DesignWare DMA Controller (aka DMACA on
- * AVR32 systems.)
- *
- * Copyright (C) 2007 Atmel Corporation
- * Copyright (C) 2010-2011 ST Microelectronics
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-#ifndef DW_DMAC_H
-#define DW_DMAC_H
-
-#include <linux/dmaengine.h>
-
-/**
- * struct dw_dma_platform_data - Controller configuration parameters
- * @nr_channels: Number of channels supported by hardware (max 8)
- * @is_private: The device channels should be marked as private and not for
- *	by the general purpose DMA channel allocator.
- */
-struct dw_dma_platform_data {
-	unsigned int	nr_channels;
-	bool		is_private;
-#define CHAN_ALLOCATION_ASCENDING	0	/* zero to seven */
-#define CHAN_ALLOCATION_DESCENDING	1	/* seven to zero */
-	unsigned char	chan_allocation_order;
-#define CHAN_PRIORITY_ASCENDING		0	/* chan0 highest */
-#define CHAN_PRIORITY_DESCENDING	1	/* chan7 highest */
-	unsigned char	chan_priority;
-};
-
-/**
- * enum dw_dma_slave_width - DMA slave register access width.
- * @DMA_SLAVE_WIDTH_8BIT: Do 8-bit slave register accesses
- * @DMA_SLAVE_WIDTH_16BIT: Do 16-bit slave register accesses
- * @DMA_SLAVE_WIDTH_32BIT: Do 32-bit slave register accesses
- */
-enum dw_dma_slave_width {
-	DW_DMA_SLAVE_WIDTH_8BIT,
-	DW_DMA_SLAVE_WIDTH_16BIT,
-	DW_DMA_SLAVE_WIDTH_32BIT,
-};
-
-/* bursts size */
-enum dw_dma_msize {
-	DW_DMA_MSIZE_1,
-	DW_DMA_MSIZE_4,
-	DW_DMA_MSIZE_8,
-	DW_DMA_MSIZE_16,
-	DW_DMA_MSIZE_32,
-	DW_DMA_MSIZE_64,
-	DW_DMA_MSIZE_128,
-	DW_DMA_MSIZE_256,
-};
-
-/* flow controller */
-enum dw_dma_fc {
-	DW_DMA_FC_D_M2M,
-	DW_DMA_FC_D_M2P,
-	DW_DMA_FC_D_P2M,
-	DW_DMA_FC_D_P2P,
-	DW_DMA_FC_P_P2M,
-	DW_DMA_FC_SP_P2P,
-	DW_DMA_FC_P_M2P,
-	DW_DMA_FC_DP_P2P,
-};
-
-/**
- * struct dw_dma_slave - Controller-specific information about a slave
- *
- * @dma_dev: required DMA master device
- * @tx_reg: physical address of data register used for
- *	memory-to-peripheral transfers
- * @rx_reg: physical address of data register used for
- *	peripheral-to-memory transfers
- * @reg_width: peripheral register width
- * @cfg_hi: Platform-specific initializer for the CFG_HI register
- * @cfg_lo: Platform-specific initializer for the CFG_LO register
- * @src_master: src master for transfers on allocated channel.
- * @dst_master: dest master for transfers on allocated channel.
- * @src_msize: src burst size.
- * @dst_msize: dest burst size.
- * @fc: flow controller for DMA transfer
- */
-struct dw_dma_slave {
-	struct device		*dma_dev;
-	dma_addr_t		tx_reg;
-	dma_addr_t		rx_reg;
-	enum dw_dma_slave_width	reg_width;
-	u32			cfg_hi;
-	u32			cfg_lo;
-	u8			src_master;
-	u8			dst_master;
-	u8			src_msize;
-	u8			dst_msize;
-	u8			fc;
-};
-
-/* Platform-configurable bits in CFG_HI */
-#define DWC_CFGH_FCMODE		(1 << 0)
-#define DWC_CFGH_FIFO_MODE	(1 << 1)
-#define DWC_CFGH_PROTCTL(x)	((x) << 2)
-#define DWC_CFGH_SRC_PER(x)	((x) << 7)
-#define DWC_CFGH_DST_PER(x)	((x) << 11)
-
-/* Platform-configurable bits in CFG_LO */
-#define DWC_CFGL_LOCK_CH_XFER	(0 << 12)	/* scope of LOCK_CH */
-#define DWC_CFGL_LOCK_CH_BLOCK	(1 << 12)
-#define DWC_CFGL_LOCK_CH_XACT	(2 << 12)
-#define DWC_CFGL_LOCK_BUS_XFER	(0 << 14)	/* scope of LOCK_BUS */
-#define DWC_CFGL_LOCK_BUS_BLOCK	(1 << 14)
-#define DWC_CFGL_LOCK_BUS_XACT	(2 << 14)
-#define DWC_CFGL_LOCK_CH	(1 << 15)	/* channel lockout */
-#define DWC_CFGL_LOCK_BUS	(1 << 16)	/* busmaster lockout */
-#define DWC_CFGL_HS_DST_POL	(1 << 18)	/* dst handshake active low */
-#define DWC_CFGL_HS_SRC_POL	(1 << 19)	/* src handshake active low */
-
-/* DMA API extensions */
-struct dw_cyclic_desc {
-	struct dw_desc	**desc;
-	unsigned long	periods;
-	void		(*period_callback)(void *param);
-	void		*period_callback_param;
-};
-
-struct dw_cyclic_desc *dw_dma_cyclic_prep(struct dma_chan *chan,
-		dma_addr_t buf_addr, size_t buf_len, size_t period_len,
-		enum dma_data_direction direction);
-void dw_dma_cyclic_free(struct dma_chan *chan);
-int dw_dma_cyclic_start(struct dma_chan *chan);
-void dw_dma_cyclic_stop(struct dma_chan *chan);
-
-dma_addr_t dw_dma_get_src_addr(struct dma_chan *chan);
-
-dma_addr_t dw_dma_get_dst_addr(struct dma_chan *chan);
-
-#endif /* DW_DMAC_H */
diff -uraN linux-3.0.8/include/linux/mmc/dw_mmc.h linux-3.0.8-fh8632-V1.0_20180330/include/linux/mmc/dw_mmc.h
--- linux-3.0.8/include/linux/mmc/dw_mmc.h	2021-07-14 21:52:05.511141232 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/include/linux/mmc/dw_mmc.h	2021-07-13 23:40:38.606385679 +0300
@@ -14,6 +14,12 @@
 #ifndef _LINUX_MMC_DW_MMC_H_
 #define _LINUX_MMC_DW_MMC_H_
 
+#include <linux/scatterlist.h>
+#include <linux/compiler.h>
+#include <linux/types.h>
+#include <linux/io.h>
+#include <linux/mmc/host.h>
+
 #define MAX_MCI_SLOTS	2
 
 enum dw_mci_state {
@@ -117,6 +123,8 @@
 
 	/* DMA interface members*/
 	int			use_dma;
+	int 		using_dma;
+	unsigned int		prev_blksz;
 
 	dma_addr_t		sg_dma;
 	void			*sg_cpu;
@@ -154,6 +162,9 @@
 	u32			quirks;
 
 	struct regulator	*vmmc;	/* Power regulator */
+
+	int 		dma_data_mapped;
+	int 		data_error_flag;
 };
 
 /* DMA ops for Internal/External DMAC interface */
@@ -200,7 +211,7 @@
 	/* delay in mS before detecting cards after interrupt */
 	u32 detect_delay_ms;
 
-	int (*init)(u32 slot_id, irq_handler_t , void *);
+	int (*init)(u32 slot_id,void* irq_handler_t , void *);
 	int (*get_ro)(u32 slot_id);
 	int (*get_cd)(u32 slot_id);
 	int (*get_ocr)(u32 slot_id);
diff -uraN linux-3.0.8/include/linux/mmc/sdio.h linux-3.0.8-fh8632-V1.0_20180330/include/linux/mmc/sdio.h
--- linux-3.0.8/include/linux/mmc/sdio.h	2021-07-14 21:52:05.515141243 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/include/linux/mmc/sdio.h	2021-07-13 23:40:38.610385702 +0300
@@ -72,6 +72,7 @@
 #define  SDIO_CCCR_REV_1_00	0	/* CCCR/FBR Version 1.00 */
 #define  SDIO_CCCR_REV_1_10	1	/* CCCR/FBR Version 1.10 */
 #define  SDIO_CCCR_REV_1_20	2	/* CCCR/FBR Version 1.20 */
+#define  SDIO_CCCR_REV_3_00	3	/* to support SDIO 3.0 (luoc) */
 
 #define  SDIO_SDIO_REV_1_00	0	/* SDIO Spec Version 1.00 */
 #define  SDIO_SDIO_REV_1_10	1	/* SDIO Spec Version 1.10 */
diff -uraN linux-3.0.8/include/linux/mtd/bbm.h linux-3.0.8-fh8632-V1.0_20180330/include/linux/mtd/bbm.h
--- linux-3.0.8/include/linux/mtd/bbm.h	2021-07-14 21:52:05.519141254 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/include/linux/mtd/bbm.h	2021-07-13 23:40:38.778386655 +0300
@@ -101,10 +101,28 @@
 /* Chip stores bad block marker on BOTH 1st and 6th bytes of OOB */
 #define NAND_BBT_SCANBYTE1AND6 0x00100000
 /* The nand_bbt_descr was created dynamicaly and must be freed */
-#define NAND_BBT_DYNAMICSTRUCT 0x00200000
+/*#define NAND_BBT_DYNAMICSTRUCT 0x00200000*/
+/*
+ * Use a flash based bad block table. By default, OOB identifier is saved in
+ * OOB area. This option is passed to the default bad block table function.
+ */
+#define NAND_BBT_USE_FLASH      0x00020000
+
 /* The bad block table does not OOB for marker */
 #define NAND_BBT_NO_OOB		0x00400000
 
+/*
+ * Do not write new bad block markers to OOB; useful, e.g., when ECC covers
+ * entire spare area. Must be used with NAND_BBT_USE_FLASH.
+ */
+#define NAND_BBT_NO_OOB_BBM     0x00800000
+/*
+ * Flag set by nand_create_default_bbt_descr(), marking that the nand_bbt_descr
+ * was allocated dynamicaly and must be freed in nand_release(). Has no meaning
+ * in nand_chip.bbt_options.
+ */
+#define NAND_BBT_DYNAMICSTRUCT  0x80000000
+
 /* The maximum number of blocks to scan for a bbt */
 #define NAND_BBT_SCAN_MAXBLOCKS	4
 
diff -uraN linux-3.0.8/include/linux/mtd/spi-nand.h linux-3.0.8-fh8632-V1.0_20180330/include/linux/mtd/spi-nand.h
--- linux-3.0.8/include/linux/mtd/spi-nand.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/include/linux/mtd/spi-nand.h	2021-07-13 23:40:38.778386655 +0300
@@ -0,0 +1,334 @@
+/*-
+ *
+ * Copyright (c) 2009-2014 Micron Technology, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Peter Pan <peterpandong at micron.com>
+ *
+ * based on mt29f_spinand.h
+ */
+#ifndef __LINUX_MTD_SPI_NAND_H
+#define __LINUX_MTD_SPI_NAND_H
+
+#include <linux/wait.h>
+#include <linux/spinlock.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/flashchip.h>
+
+
+/*
+ * Standard SPI-NAND flash commands
+ */
+#define SPINAND_CMD_READ			0x13
+#define SPINAND_CMD_READ_RDM			0x03
+#define SPINAND_CMD_PROG_LOAD			0x02
+#define SPINAND_CMD_PROG_RDM			0x84
+#define SPINAND_CMD_PROG			0x10
+#define SPINAND_CMD_ERASE_BLK			0xd8
+#define SPINAND_CMD_WR_ENABLE			0x06
+#define SPINAND_CMD_WR_DISABLE			0x04
+#define SPINAND_CMD_READ_ID			0x9f
+#define SPINAND_CMD_RESET			0xff
+#define SPINAND_CMD_READ_REG			0x0f
+#define SPINAND_CMD_WRITE_REG			0x1f
+
+#define SPINAND_CMD_READ_CACHE_X2		0x3b
+#define SPINAND_CMD_READ_CACHE_X4		0x6b
+#define SPINAND_CMD_READ_CACHE_DUAL		0xbb
+#define SPINAND_CMD_READ_CACHE_QUAD		0xeb
+
+#define SPINAND_CMD_PROG_LOAD_X4		0x32
+#define SPINAND_CMD_PROG_RDM_X4			0xC4 /*or 34*/
+
+/* feature registers */
+#define REG_BLOCK_LOCK			0xa0
+#define REG_OTP				0xb0
+#define REG_STATUS			0xc0/* timing */
+
+/* status */
+#define STATUS_OIP_MASK			0x01
+#define STATUS_READY			(0 << 0)
+#define STATUS_BUSY			(1 << 0)
+
+#define STATUS_E_FAIL_MASK		0x04
+#define STATUS_E_FAIL			(1 << 2)
+
+#define STATUS_P_FAIL_MASK		0x08
+#define STATUS_P_FAIL			(1 << 3)
+
+/*OTP register defines*/
+#define OTP_ECC_MASK			0X10
+#define OTP_ECC_ENABLE			(1 << 4)
+#define OTP_ENABLE			(1 << 6)
+#define OTP_LOCK			(1 << 7)
+
+/* block lock */
+#define BL_ALL_LOCKED      0x38
+#define BL_1_2_LOCKED      0x30
+#define BL_1_4_LOCKED      0x28
+#define BL_1_8_LOCKED      0x20
+#define BL_1_16_LOCKED     0x18
+#define BL_1_32_LOCKED     0x10
+#define BL_1_64_LOCKED     0x08
+#define BL_ALL_UNLOCKED    0
+
+#define SPI_NAND_ECC_SHIFT		4
+
+#define SPI_NAND_MT29F_ECC_MASK		3
+#define SPI_NAND_MT29F_ECC_CORRECTED	1
+#define SPI_NAND_MT29F_ECC_UNCORR	2
+#define SPI_NAND_MT29F_ECC_RESERVED	3
+#define SPI_NAND_MT29F_ECC_SHIFT	4
+
+#define SPI_NAND_GD5F_ECC_MASK		7
+#define SPI_NAND_GD5F_ECC_UNCORR	7
+#define SPI_NAND_GD5F_ECC_SHIFT		4
+
+struct spi_nand_onfi_params {
+	/* rev info and features block */
+	/* 'O' 'N' 'F' 'I'  */
+	u8		sig[4];				/*0-3*/
+	__le16		revision;			/*4-5*/
+	__le16		features;			/*6-7*/
+	__le16		opt_cmd;			/*8-9*/
+	u8		reserved0[22];			/*10-31*/
+
+	/* manufacturer information block */
+	char		manufacturer[12];		/*32-43*/
+	char		model[20];			/*44-63*/
+	u8		mfr_id;				/*64*/
+	__le16		date_code;			/*65-66*/
+	u8		reserved1[13];			/*67-79*/
+
+	/* memory organization block */
+	__le32		byte_per_page;			/*80-83*/
+	__le16		spare_bytes_per_page;		/*84*85*/
+	__le32		data_bytes_per_ppage;		/*86-89*/
+	__le16		spare_bytes_per_ppage;		/*90-91*/
+	__le32		pages_per_block;		/*92-95*/
+	__le32		blocks_per_lun;			/*96-99*/
+	u8		lun_count;			/*100*/
+	u8		addr_cycles;			/*101*/
+	u8		bits_per_cell;			/*102*/
+	__le16		bb_per_lun;			/*103-104*/
+	__le16		block_endurance;		/*105-106*/
+	u8		guaranteed_good_blocks;		/*107*/
+	__le16		guaranteed_block_endurance;	/*108-109*/
+	u8		programs_per_page;		/*110*/
+	u8		ppage_attr;			/*111*/
+	u8		ecc_bits;			/*112*/
+	u8		interleaved_bits;		/*113*/
+	u8		interleaved_ops;		/*114*/
+	u8		reserved2[13];			/*115-127*/
+
+	/* electrical parameter block */
+	u8		io_pin_capacitance_max;		/*128*/
+	__le16		timing_mode;			/*129-130*/
+	__le16		program_cache_timing_mode;	/*131-132*/
+	__le16		t_prog;				/*133-134*/
+	__le16		t_bers;				/*135-136*/
+	__le16		t_r;				/*137-138*/
+	__le16		t_ccs;				/*139-140*/
+	u8		reserved3[23];			/*141-163*/
+
+	/* vendor */
+	__le16		vendor_specific_revision;	/*164-165*/
+	u8		vendor_specific[88];		/*166-253*/
+
+	__le16		crc;				/*254-255*/
+} __packed;
+
+#define ONFI_CRC_BASE	0x4F4E
+
+#define SPINAND_MAX_ID_LEN		4
+
+/**
+ * struct spi_nand_chip - SPI-NAND Private Flash Chip Data
+ * @chip_lock:		[INTERN] protection lock
+ * @name:		name of the chip
+ * @wq:			[INTERN] wait queue to sleep on if a SPI-NAND operation
+ *			is in progress used instead of the per chip wait queue
+ *			when a hw controller is available.
+ * @mfr_id:		[BOARDSPECIFIC] manufacture id
+ * @dev_id:		[BOARDSPECIFIC] device id
+ * @state:		[INTERN] the current state of the SPI-NAND device
+ * @spi:		[INTERN] point to spi device structure
+ * @mtd:		[INTERN] point to MTD device structure
+ * @reset:		[REPLACEABLE] function to reset the device
+ * @read_id:		[REPLACEABLE] read manufacture id and device id
+ * @load_page:		[REPLACEABLE] load page from NAND to cache
+ * @read_cache:		[REPLACEABLE] read data from cache
+ * @store_cache:	[REPLACEABLE] write data to cache
+ * @write_page:		[REPLACEABLE] program NAND with cache data
+ * @erase_block:	[REPLACEABLE] erase a given block
+ * @waitfunc:		[REPLACEABLE] wait for ready.
+ * @write_enable:	[REPLACEABLE] set write enable latch
+ * @get_ecc_status:	[REPLACEABLE] get ecc and bitflip status
+ * @enable_ecc:		[REPLACEABLE] enable on-die ecc
+ * @disable_ecc:	[REPLACEABLE] disable on-die ecc
+ * @buf:		[INTERN] buffer for read/write
+ * @oobbuf:		[INTERN] buffer for read/write oob
+ * @pagebuf:		[INTERN] holds the pagenumber which is currently in
+ *			data_buf.
+ * @pagebuf_bitflips:	[INTERN] holds the bitflip count for the page which is
+ *			currently in data_buf.
+ * @size:		[INTERN] the size of chip
+ * @block_size:		[INTERN] the size of eraseblock
+ * @page_size:		[INTERN] the size of page
+ * @page_spare_size:	[INTERN] the size of page oob size
+ * @block_shift:	[INTERN] number of address bits in a eraseblock
+ * @page_shift:		[INTERN] number of address bits in a page (column
+ *			address bits).
+ * @pagemask:		[INTERN] page number mask = number of (pages / chip) - 1
+ * @options:		[BOARDSPECIFIC] various chip options. They can partly
+ *			be set to inform nand_scan about special functionality.
+ * @ecc_strength_ds:	[INTERN] ECC correctability from the datasheet.
+ *			Minimum amount of bit errors per @ecc_step_ds guaranteed
+ *			to be correctable. If unknown, set to zero.
+ * @ecc_step_ds:	[INTERN] ECC step required by the @ecc_strength_ds,
+ *                      also from the datasheet. It is the recommended ECC step
+ *			size, if known; if unknown, set to zero.
+ * @ecc_mask:
+ * @ecc_uncorr:
+ * @bits_per_cell:	[INTERN] number of bits per cell. i.e., 1 means SLC.
+ * @ecclayout:		[BOARDSPECIFIC] ECC layout control structure
+ *			See the defines for further explanation.
+ * @bbt_options:	[INTERN] bad block specific options. All options used
+ *			here must come from bbm.h. By default, these options
+ *			will be copied to the appropriate nand_bbt_descr's.
+ * @bbt:		[INTERN] bad block table pointer
+ * @badblockpos:	[INTERN] position of the bad block marker in the oob
+ *			area.
+ * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash
+ *			lookup.
+ * @bbt_md:		[REPLACEABLE] bad block table mirror descriptor
+ * @badblock_pattern:	[REPLACEABLE] bad block scan pattern used for initial
+ *			bad block scan.
+ * @onfi_params:	[INTERN] holds the ONFI page parameter when ONFI is
+ *			supported, 0 otherwise.
+ */
+struct spi_nand_chip {
+	spinlock_t	chip_lock;
+	char		*name;
+	wait_queue_head_t wq;
+	u8		dev_id_len;
+	u8		dev_id[SPINAND_MAX_ID_LEN];
+	flstate_t	state;
+	struct spi_device	*spi;
+	struct mtd_info	*mtd;
+
+	int (*reset)(struct spi_nand_chip *chip);
+	int (*read_id)(struct spi_nand_chip *chip, u8 *id);
+	int (*load_page)(struct spi_nand_chip *chip, unsigned int page_addr);
+	int (*read_cache)(struct spi_nand_chip *chip, unsigned int page_addr,
+		unsigned int page_offset,	size_t length, u8 *read_buf);
+	int (*store_cache)(struct spi_nand_chip *chip, unsigned int page_addr,
+		unsigned int page_offset,	size_t length, u8 *write_buf);
+	int (*write_page)(struct spi_nand_chip *chip, unsigned int page_addr);
+	int (*erase_block)(struct spi_nand_chip *chip, u32 page_addr);
+	int (*waitfunc)(struct spi_nand_chip *chip, u8 *status);
+	int (*write_enable)(struct spi_nand_chip *chip);
+	void (*get_ecc_status)(struct spi_nand_chip *chip, unsigned int status,
+						unsigned int *corrected,
+						unsigned int *ecc_errors);
+	int (*enable_ecc)(struct spi_nand_chip *chip);
+	int (*disable_ecc)(struct spi_nand_chip *chip);
+	int (*block_bad)(struct mtd_info *mtd, loff_t ofs, int getchip);
+
+	u8		*buf;
+	u8		*oobbuf;
+	int		pagebuf;
+	u32		pagebuf_bitflips;
+	u64		size;
+	u32		block_size;
+	u16		page_size;
+	u16		page_spare_size;
+	u8		block_shift;
+	u8		page_shift;
+	u16		page_mask;
+	u32		options;
+	u16		ecc_strength_ds;
+	u16		ecc_step_ds;
+	u8		ecc_mask;
+	u8		ecc_uncorr;
+	u8		bits_per_cell;
+	struct nand_ecclayout *ecclayout;
+	u32		bbt_options;
+	u8		*bbt;
+	int		badblockpos;
+	struct nand_bbt_descr *bbt_td;
+	struct nand_bbt_descr *bbt_md;
+	struct nand_bbt_descr *badblock_pattern;
+	struct spi_nand_onfi_params	 onfi_params;
+};
+
+
+struct spi_nand_id_info{
+#define SPI_NAND_ID_NO_DUMMY  (0xff)
+	u8 id_addr;
+	u8 id_len;
+};
+
+struct spi_nand_flash {
+	char		*name;
+	struct spi_nand_id_info id_info;
+	u8		dev_id[SPINAND_MAX_ID_LEN];
+	u32		page_size;
+	u32		page_spare_size;
+	u32		pages_per_blk;
+	u32		blks_per_chip;
+	u32		options;
+	u8		ecc_mask;
+	u8		ecc_uncorr;
+	struct nand_ecclayout *ecc_layout;
+};
+
+struct spi_nand_cmd {
+	u8		cmd;
+	u32		n_addr;		/* Number of address */
+	u8		addr[3];	/* Reg Offset */
+	u32		n_tx;		/* Number of tx bytes */
+	u8		*tx_buf;	/* Tx buf */
+	u8		tx_nbits;
+	u32		n_rx;		/* Number of rx bytes */
+	u8		*rx_buf;	/* Rx buf */
+	u8		rx_nbits;
+};
+
+#define SPI_NAND_INFO(nm, mid, did, pagesz, sparesz, pg_per_blk,\
+	blk_per_chip, opts)				\
+	{ .name = (nm), .mfr_id = (mid), .dev_id = (did),\
+	.page_size = (pagesz), .page_spare_size = (sparesz),\
+	.pages_per_blk = (pg_per_blk), .blks_per_chip = (blk_per_chip),\
+	.options = (opts) }
+
+#define SPINAND_NEED_PLANE_SELECT	(1 << 0)
+
+#define SPINAND_MFR_MICRON		0x2C
+#define SPINAND_MFR_GIGADEVICE	0xC8
+
+int spi_nand_send_cmd(struct spi_device *spi, struct spi_nand_cmd *cmd);
+int spi_nand_read_from_cache(struct spi_nand_chip *chip,
+		u32 page_addr, u32 column, size_t len, u8 *rbuf);
+int spi_nand_read_from_cache_snor_protocol(struct spi_nand_chip *chip,
+		u32 page_addr, u32 column, size_t len, u8 *rbuf);
+int spi_nand_scan_ident(struct mtd_info *mtd);
+int spi_nand_scan_tail(struct mtd_info *mtd);
+int spi_nand_scan_ident_release(struct mtd_info *mtd);
+int spi_nand_scan_tail_release(struct mtd_info *mtd);
+int spi_nand_release(struct mtd_info *mtd);
+int __spi_nand_erase(struct mtd_info *mtd, struct erase_info *einfo,
+		int allowbbt);
+int spi_nand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt);
+int spi_nand_default_bbt(struct mtd_info *mtd);
+int spi_nand_markbad_bbt(struct mtd_info *mtd, loff_t offs);
+#endif /* __LINUX_MTD_SPI_NAND_H */
+
diff -uraN linux-3.0.8/include/linux/pwm.h linux-3.0.8-fh8632-V1.0_20180330/include/linux/pwm.h
--- linux-3.0.8/include/linux/pwm.h	2021-07-14 21:52:05.607141509 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/include/linux/pwm.h	2021-07-13 23:40:38.670386043 +0300
@@ -1,8 +1,13 @@
 #ifndef __LINUX_PWM_H
 #define __LINUX_PWM_H
 
+#include <linux/err.h>
+#include <linux/of.h>
+
 struct pwm_device;
+struct seq_file;
 
+#if defined(CONFIG_PWM) || defined(CONFIG_HAVE_PWM)
 /*
  * pwm_request - request a PWM device
  */
@@ -27,5 +32,251 @@
  * pwm_disable - stop a PWM output toggling
  */
 void pwm_disable(struct pwm_device *pwm);
+#else
+static inline struct pwm_device *pwm_request(int pwm_id, const char *label)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline void pwm_free(struct pwm_device *pwm)
+{
+}
+
+static inline int pwm_config(struct pwm_device *pwm, int duty_ns, int period_ns)
+{
+	return -EINVAL;
+}
+
+static inline int pwm_enable(struct pwm_device *pwm)
+{
+	return -EINVAL;
+}
+
+static inline void pwm_disable(struct pwm_device *pwm)
+{
+}
+#endif
+
+struct pwm_chip;
+
+/**
+ * enum pwm_polarity - polarity of a PWM signal
+ * @PWM_POLARITY_NORMAL: a high signal for the duration of the duty-
+ * cycle, followed by a low signal for the remainder of the pulse
+ * period
+ * @PWM_POLARITY_INVERSED: a low signal for the duration of the duty-
+ * cycle, followed by a high signal for the remainder of the pulse
+ * period
+ */
+enum pwm_polarity {
+	PWM_POLARITY_NORMAL,
+	PWM_POLARITY_INVERSED,
+};
+
+enum {
+	PWMF_REQUESTED = 1 << 0,
+	PWMF_ENABLED = 1 << 1,
+};
+
+struct pwm_device {
+	const char		*label;
+	unsigned long		flags;
+	unsigned int		hwpwm;
+	unsigned int		pwm;
+	struct pwm_chip		*chip;
+	void			*chip_data;
+
+	unsigned int		period; /* in nanoseconds */
+};
+
+static inline void pwm_set_period(struct pwm_device *pwm, unsigned int period)
+{
+	if (pwm)
+		pwm->period = period;
+}
+
+static inline unsigned int pwm_get_period(struct pwm_device *pwm)
+{
+	return pwm ? pwm->period : 0;
+}
+
+/*
+ * pwm_set_polarity - configure the polarity of a PWM signal
+ */
+int pwm_set_polarity(struct pwm_device *pwm, enum pwm_polarity polarity);
+
+/**
+ * struct pwm_ops - PWM controller operations
+ * @request: optional hook for requesting a PWM
+ * @free: optional hook for freeing a PWM
+ * @config: configure duty cycles and period length for this PWM
+ * @set_polarity: configure the polarity of this PWM
+ * @enable: enable PWM output toggling
+ * @disable: disable PWM output toggling
+ * @dbg_show: optional routine to show contents in debugfs
+ * @owner: helps prevent removal of modules exporting active PWMs
+ */
+struct pwm_ops {
+	int			(*request)(struct pwm_chip *chip,
+					   struct pwm_device *pwm);
+	void			(*free)(struct pwm_chip *chip,
+					struct pwm_device *pwm);
+	int			(*config)(struct pwm_chip *chip,
+					  struct pwm_device *pwm,
+					  int duty_ns, int period_ns);
+	int			(*set_polarity)(struct pwm_chip *chip,
+					  struct pwm_device *pwm,
+					  enum pwm_polarity polarity);
+	int			(*enable)(struct pwm_chip *chip,
+					  struct pwm_device *pwm);
+	void			(*disable)(struct pwm_chip *chip,
+					   struct pwm_device *pwm);
+#ifdef CONFIG_DEBUG_FS
+	void			(*dbg_show)(struct pwm_chip *chip,
+					    struct seq_file *s);
+#endif
+	struct module		*owner;
+};
+
+/**
+ * struct pwm_chip - abstract a PWM controller
+ * @dev: device providing the PWMs
+ * @list: list node for internal use
+ * @ops: callbacks for this PWM controller
+ * @base: number of first PWM controlled by this chip
+ * @npwm: number of PWMs controlled by this chip
+ * @pwms: array of PWM devices allocated by the framework
+ * @can_sleep: must be true if the .config(), .enable() or .disable()
+ *             operations may sleep
+ */
+struct pwm_chip {
+	struct device		*dev;
+	struct list_head	list;
+	const struct pwm_ops	*ops;
+	int			base;
+	unsigned int		npwm;
+
+	struct pwm_device	*pwms;
+/*
+	struct pwm_device *	(*of_xlate)(struct pwm_chip *pc,
+					    const struct of_phandle_args *args);
+*/
+	unsigned int		of_pwm_n_cells;
+	bool			can_sleep;
+};
+
+#if defined(CONFIG_PWM)
+int pwm_set_chip_data(struct pwm_device *pwm, void *data);
+void *pwm_get_chip_data(struct pwm_device *pwm);
+
+int pwmchip_add(struct pwm_chip *chip);
+int pwmchip_remove(struct pwm_chip *chip);
+struct pwm_device *pwm_request_from_chip(struct pwm_chip *chip,
+					 unsigned int index,
+					 const char *label);
+/*
+struct pwm_device *of_pwm_xlate_with_flags(struct pwm_chip *pc,
+		const struct of_phandle_args *args);
+*/
+struct pwm_device *pwm_get(struct device *dev, const char *con_id);
+struct pwm_device *of_pwm_get(struct device_node *np, const char *con_id);
+void pwm_put(struct pwm_device *pwm);
+
+struct pwm_device *devm_pwm_get(struct device *dev, const char *con_id);
+struct pwm_device *devm_of_pwm_get(struct device *dev, struct device_node *np,
+				   const char *con_id);
+void devm_pwm_put(struct device *dev, struct pwm_device *pwm);
+
+bool pwm_can_sleep(struct pwm_device *pwm);
+#else
+static inline int pwm_set_chip_data(struct pwm_device *pwm, void *data)
+{
+	return -EINVAL;
+}
+
+static inline void *pwm_get_chip_data(struct pwm_device *pwm)
+{
+	return NULL;
+}
+
+static inline int pwmchip_add(struct pwm_chip *chip)
+{
+	return -EINVAL;
+}
+
+static inline int pwmchip_remove(struct pwm_chip *chip)
+{
+	return -EINVAL;
+}
+
+static inline struct pwm_device *pwm_request_from_chip(struct pwm_chip *chip,
+						       unsigned int index,
+						       const char *label)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline struct pwm_device *pwm_get(struct device *dev,
+					 const char *consumer)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline struct pwm_device *of_pwm_get(struct device_node *np,
+					    const char *con_id)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline void pwm_put(struct pwm_device *pwm)
+{
+}
+
+static inline struct pwm_device *devm_pwm_get(struct device *dev,
+					      const char *consumer)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline struct pwm_device *devm_of_pwm_get(struct device *dev,
+						 struct device_node *np,
+						 const char *con_id)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline void devm_pwm_put(struct device *dev, struct pwm_device *pwm)
+{
+}
+
+static inline bool pwm_can_sleep(struct pwm_device *pwm)
+{
+	return false;
+}
+#endif
+
+struct pwm_lookup {
+	struct list_head list;
+	const char *provider;
+	unsigned int index;
+	const char *dev_id;
+	const char *con_id;
+};
+
+#define PWM_LOOKUP(_provider, _index, _dev_id, _con_id)	\
+	{						\
+		.provider = _provider,			\
+		.index = _index,			\
+		.dev_id = _dev_id,			\
+		.con_id = _con_id,			\
+	}
+
+#if defined(CONFIG_PWM)
+void pwm_add_table(struct pwm_lookup *table, size_t num);
+#else
+static inline void pwm_add_table(struct pwm_lookup *table, size_t num)
+{
+}
+#endif
 
 #endif /* __LINUX_PWM_H */
diff -uraN linux-3.0.8/include/linux/rtc.h linux-3.0.8-fh8632-V1.0_20180330/include/linux/rtc.h
--- linux-3.0.8/include/linux/rtc.h	2021-07-14 21:52:05.623141556 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/include/linux/rtc.h	2021-07-13 23:40:38.674386065 +0300
@@ -18,15 +18,15 @@
  */
 
 struct rtc_time {
-	int tm_sec;
-	int tm_min;
-	int tm_hour;
-	int tm_mday;
-	int tm_mon;
-	int tm_year;
-	int tm_wday;
-	int tm_yday;
-	int tm_isdst;
+	int tm_sec;		//0~59
+	int tm_min;		//0~59
+	int tm_hour;	//0~23
+	int tm_mday;	//1~31
+	int tm_mon;		//0~11
+	int tm_year;	//offset from 1900
+	int tm_wday;	//0~6   sunday:0
+	int tm_yday;	//offset from 1.1    0~365
+	int tm_isdst;	//???
 };
 
 /*
diff -uraN linux-3.0.8/include/linux/spi/dw_spi.h linux-3.0.8-fh8632-V1.0_20180330/include/linux/spi/dw_spi.h
--- linux-3.0.8/include/linux/spi/dw_spi.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/include/linux/spi/dw_spi.h	2021-07-13 23:40:38.630385815 +0300
@@ -0,0 +1,269 @@
+#ifndef DW_SPI_HEADER_H
+#define DW_SPI_HEADER_H
+
+#include <linux/io.h>
+#include <linux/scatterlist.h>
+
+
+#define YU_ADD_ISR_TASKLET
+
+#ifdef CONFIG_JLINK_DEBUG
+#	define DEBUG_DW_SPI0
+
+#	ifdef DEBUG_DW_SPI0
+#		define DW_SPI0_REG_BASE			(0xf0500000)
+		#define DW_SPI0_CS_REG				(0xf0300000)
+
+#	else
+		#define DW_SPI_REG_BASE			(0xfe400000)
+		#define DW_SPI0_CS_REG			(0xfe500000)
+#	endif
+
+#else
+#	define DW_SPI0_CS_REG			(0xfe500000)
+#endif
+
+
+
+/* Bit fields in CTRLR0 */
+#define SPI_DFS_OFFSET			0
+
+#define SPI_FRF_OFFSET			4
+#define SPI_FRF_SPI			0x0
+#define SPI_FRF_SSP			0x1
+#define SPI_FRF_MICROWIRE		0x2
+#define SPI_FRF_RESV			0x3
+
+#define SPI_MODE_OFFSET			6
+#define SPI_SCPH_OFFSET			6
+#define SPI_SCOL_OFFSET			7
+
+#define SPI_TMOD_OFFSET			8
+#define SPI_TMOD_MASK			(0x3 << SPI_TMOD_OFFSET)
+#define	SPI_TMOD_TR			0x0		/* xmit & recv */
+#define SPI_TMOD_TO			0x1		/* xmit only */
+#define SPI_TMOD_RO			0x2		/* recv only */
+#define SPI_TMOD_EPROMREAD		0x3		/* eeprom read mode */
+
+#define SPI_SLVOE_OFFSET		10
+#define SPI_SRL_OFFSET			11
+#define SPI_CFS_OFFSET			12
+
+/* Bit fields in SR, 7 bits */
+#define SR_MASK				0x7f		/* cover 7 bits */
+#define SR_BUSY				(1 << 0)
+#define SR_TF_NOT_FULL			(1 << 1)
+#define SR_TF_EMPT			(1 << 2)
+#define SR_RF_NOT_EMPT			(1 << 3)
+#define SR_RF_FULL			(1 << 4)
+#define SR_TX_ERR			(1 << 5)
+#define SR_DCOL				(1 << 6)
+
+/* Bit fields in ISR, IMR, RISR, 7 bits */
+#define SPI_INT_TXEI			(1 << 0)
+#define SPI_INT_TXOI			(1 << 1)
+#define SPI_INT_RXUI			(1 << 2)
+#define SPI_INT_RXOI			(1 << 3)
+#define SPI_INT_RXFI			(1 << 4)
+#define SPI_INT_MSTI			(1 << 5)
+
+/* TX RX interrupt level threshold, max can be 256 */
+#define SPI_INT_THRESHOLD		32
+
+enum dw_ssi_type {
+	SSI_MOTO_SPI = 0,
+	SSI_TI_SSP,
+	SSI_NS_MICROWIRE,
+};
+
+struct dw_spi_reg {
+	u32	ctrl0;
+	u32	ctrl1;
+	u32	ssienr;
+	u32	mwcr;
+	u32	ser;
+	u32	baudr;
+	u32	txfltr;
+	u32	rxfltr;
+	u32	txflr;
+	u32	rxflr;
+	u32	sr;
+	u32	imr;
+	u32	isr;
+	u32	risr;
+	u32	txoicr;
+	u32	rxoicr;
+	u32	rxuicr;
+	u32	msticr;
+	u32	icr;
+	u32	dmacr;
+	u32	dmatdlr;
+	u32	dmardlr;
+	u32	idr;
+	u32	version;
+	u32	dr;		/* Currently oper as 32 bits,
+				though only low 16 bits matters */
+} __packed;
+
+struct dw_spi;
+struct dw_spi_dma_ops {
+	int (*dma_init)(struct dw_spi *dws);
+	void (*dma_exit)(struct dw_spi *dws);
+	int (*dma_transfer)(struct dw_spi *dws, int cs_change);
+};
+
+struct dw_spi {
+	struct spi_master	*master;
+	struct spi_device	*cur_dev;
+	struct device		*parent_dev;
+	enum dw_ssi_type	type;
+
+	void __iomem		*regs;
+	unsigned long		paddr;
+	u32			iolen;
+	int			irq;
+	u32			fifo_len;	/* depth of the FIFO buffer */
+	u32			max_freq;	/* max bus freq supported */
+
+	u16			bus_num;
+	u16			num_cs;		/* supported slave numbers */
+
+	/* Driver message queue */
+	struct workqueue_struct	*workqueue;
+	struct work_struct	pump_messages;
+	spinlock_t		lock;
+	struct list_head	queue;
+	int			busy;
+	int			run;
+
+	/* Message Transfer pump */
+	struct tasklet_struct	pump_transfers;
+
+	/* Current message transfer state info */
+	struct spi_message	*cur_msg;
+	struct spi_transfer	*cur_transfer;
+	struct chip_data	*cur_chip;
+	struct chip_data	*prev_chip;
+	size_t			len;
+	void			*tx;
+	void			*tx_end;
+	void			*rx;
+	void			*rx_end;
+	int			dma_mapped;
+	dma_addr_t		rx_dma;
+	dma_addr_t		tx_dma;
+	size_t			rx_map_len;
+	size_t			tx_map_len;
+	u8			n_bytes;	/* current is a 1/2 bytes op */
+	u8			max_bits_per_word;	/* maxim is 16b */
+	u32			dma_width;
+	int			cs_change;
+	irqreturn_t		(*transfer_handler)(struct dw_spi *dws);
+	void			(*cs_control)(struct spi_device *spi, u32 command);
+
+	/* Dma info */
+	int			dma_inited;
+	struct dma_chan		*txchan;
+	struct scatterlist	tx_sgl;
+	struct dma_chan		*rxchan;
+	struct scatterlist	rx_sgl;
+	int			dma_chan_done;
+	struct device		*dma_dev;
+	dma_addr_t		dma_addr; /* phy address of the Data register */
+	struct dw_spi_dma_ops	*dma_ops;
+	void			*dma_priv; /* platform relate info */
+	struct pci_dev		*dmac;
+	void * dma_rx_dummy;
+	void * dma_tx_dummy;
+
+	/* Bus interface info */
+	void			*priv;
+
+
+#ifdef YU_ADD_ISR_TASKLET
+	struct tasklet_struct	yu_add_isr_tasklet;
+
+#endif
+
+#ifdef CONFIG_DEBUG_FS
+	struct dentry *debugfs;
+#endif
+};
+
+#define dw_readl(dw, name) \
+	__raw_readl(&(((struct dw_spi_reg *)dw->regs)->name))
+#define dw_writel(dw, name, val) \
+	__raw_writel((val), &(((struct dw_spi_reg *)dw->regs)->name))
+#define dw_readw(dw, name) \
+	__raw_readw(&(((struct dw_spi_reg *)dw->regs)->name))
+#define dw_writew(dw, name, val) \
+	__raw_writew((val), &(((struct dw_spi_reg *)dw->regs)->name))
+
+
+#define yu_write(val,add)    __raw_writel((val), (add))
+
+
+static inline void spi_enable_chip(struct dw_spi *dws, int enable)
+{
+	dw_writel(dws, ssienr, (enable ? 1 : 0));
+}
+
+static inline void spi_set_clk(struct dw_spi *dws, u16 div)
+{
+	dw_writel(dws, baudr, div);
+}
+
+static inline void spi_chip_sel(struct dw_spi *dws, struct spi_device *spi)
+{
+	 u16 cs = spi->chip_select;
+	if (cs > dws->num_cs)
+		return;
+
+	if (dws->cs_control)
+		dws->cs_control(spi, 1);
+
+	dw_writel(dws, ser, 1 << cs);
+}
+
+
+/* Disable IRQ bits */
+static inline void spi_mask_intr(struct dw_spi *dws, u32 mask)
+{
+	u32 new_mask;
+
+	new_mask = dw_readl(dws, imr) & ~mask;
+	dw_writel(dws, imr, new_mask);
+}
+
+/* Enable IRQ bits */
+static inline void spi_umask_intr(struct dw_spi *dws, u32 mask)
+{
+	u32 new_mask;
+
+	new_mask = dw_readl(dws, imr) | mask;
+	dw_writel(dws, imr, new_mask);
+}
+
+/*
+ * Each SPI slave device to work with dw_api controller should
+ * has such a structure claiming its working mode (PIO/DMA etc),
+ * which can be save in the "controller_data" member of the
+ * struct spi_device
+ */
+struct dw_spi_chip {
+	u8 poll_mode;	/* 0 for contoller polling mode */
+	u8 type;	/* SPI/SSP/Micrwire */
+	u8 enable_dma;
+	void *cs_control;
+//	void (*cs_control)(u32 command);
+};
+
+extern int dw_spi_add_host(struct dw_spi *dws);
+extern void dw_spi_remove_host(struct dw_spi *dws);
+extern int dw_spi_suspend_host(struct dw_spi *dws);
+extern int dw_spi_resume_host(struct dw_spi *dws);
+extern void dw_spi_xfer_done(struct dw_spi *dws);
+
+/* platform related setup */
+extern int dw_spi_mid_init(struct dw_spi *dws); /* Intel MID platforms */
+#endif /* DW_SPI_HEADER_H */
diff -uraN linux-3.0.8/include/linux/usb/ch11.h linux-3.0.8-fh8632-V1.0_20180330/include/linux/usb/ch11.h
--- linux-3.0.8/include/linux/usb/ch11.h	2021-07-14 21:52:05.687141741 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/include/linux/usb/ch11.h	2021-07-13 23:40:38.614385724 +0300
@@ -18,6 +18,16 @@
 #define USB_RT_HUB	(USB_TYPE_CLASS | USB_RECIP_DEVICE)
 #define USB_RT_PORT	(USB_TYPE_CLASS | USB_RECIP_OTHER)
 
+#define HUB_CHAR_LPSM		0x0003 /* Logical Power Switching Mode mask */
+#define HUB_CHAR_COMMON_LPSM	0x0000 /* All ports power control at once */
+#define HUB_CHAR_INDV_PORT_LPSM	0x0001 /* per-port power control */
+#define HUB_CHAR_NO_LPSM	0x0002 /* no power switching */
+#define HUB_CHAR_COMPOUND	0x0004 /* hub is part of a compound device */
+
+
+
+
+
 /*
  * Hub class requests
  * See USB 2.0 spec Table 11-16
@@ -54,6 +64,7 @@
 #define USB_PORT_FEAT_L1		5	/* L1 suspend */
 #define USB_PORT_FEAT_POWER		8
 #define USB_PORT_FEAT_LOWSPEED		9	/* Should never be used */
+#define USB_PORT_FEAT_HIGHSPEED		10
 #define USB_PORT_FEAT_C_CONNECTION	16
 #define USB_PORT_FEAT_C_ENABLE		17
 #define USB_PORT_FEAT_C_SUSPEND		18
@@ -168,6 +179,7 @@
 #define HUB_CHAR_LPSM		0x0003 /* D1 .. D0 */
 #define HUB_CHAR_COMPOUND	0x0004 /* D2       */
 #define HUB_CHAR_OCPM		0x0018 /* D4 .. D3 */
+#define HUB_CHAR_INDV_PORT_OCPM	0x0008 /* per-port Over-current reporting */
 #define HUB_CHAR_TTTT           0x0060 /* D6 .. D5 */
 #define HUB_CHAR_PORTIND        0x0080 /* D7       */
 
diff -uraN linux-3.0.8/include/linux/usb/gadget.h linux-3.0.8-fh8632-V1.0_20180330/include/linux/usb/gadget.h
--- linux-3.0.8/include/linux/usb/gadget.h	2021-07-14 21:52:05.687141741 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/include/linux/usb/gadget.h	2021-07-13 23:40:38.614385724 +0300
@@ -16,7 +16,7 @@
 #define __LINUX_USB_GADGET_H
 
 #include <linux/slab.h>
-
+#include <linux/usb/ch9.h>
 struct usb_ep;
 
 /**
diff -uraN linux-3.0.8/include/linux/usb/hcd.h linux-3.0.8-fh8632-V1.0_20180330/include/linux/usb/hcd.h
--- linux-3.0.8/include/linux/usb/hcd.h	2021-07-14 21:52:05.687141741 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/include/linux/usb/hcd.h	2021-07-13 23:40:38.618385747 +0300
@@ -19,10 +19,10 @@
 #ifndef __USB_CORE_HCD_H
 #define __USB_CORE_HCD_H
 
-#ifdef __KERNEL__
+//#ifdef __KERNEL__
 
 #include <linux/rwsem.h>
-
+#include <linux/usb.h>
 #define MAX_TOPO_LEVEL		6
 
 /* This file contains declarations of usbcore internals that are mostly
@@ -505,6 +505,11 @@
 /* class requests from USB 3.0 hub spec, table 10-5 */
 #define SetHubDepth		(0x3000 | HUB_SET_DEPTH)
 #define GetPortErrorCount	(0x8000 | HUB_GET_PORT_ERR_COUNT)
+/*-------------------------------------------------------------------------*/
+
+/* hub.h ... DeviceRemovable in 2.4.2-ac11, gone in 2.4.10 */
+/* bleech -- resurfaced in 2.4.11 or 2.4.12 */
+#define bitmap 	DeviceRemovable
 
 /*
  * Generic bandwidth allocation constants/support
@@ -669,6 +674,6 @@
 #define USB_EHCI_LOADED		2
 extern unsigned long usb_hcds_loaded;
 
-#endif /* __KERNEL__ */
+//#endif /* __KERNEL__ */
 
 #endif /* __USB_CORE_HCD_H */
diff -uraN linux-3.0.8/include/linux/usb/otg.h linux-3.0.8-fh8632-V1.0_20180330/include/linux/usb/otg.h
--- linux-3.0.8/include/linux/usb/otg.h	2021-07-14 21:52:05.691141753 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/include/linux/usb/otg.h	2021-07-13 23:40:38.618385747 +0300
@@ -11,6 +11,12 @@
 
 #include <linux/notifier.h>
 
+enum usb_dr_mode {
+	USB_DR_MODE_UNKNOWN,
+	USB_DR_MODE_HOST,
+	USB_DR_MODE_PERIPHERAL,
+	USB_DR_MODE_OTG,
+};
 /* OTG defines lots of enumeration states before device reset */
 enum usb_otg_state {
 	OTG_STATE_UNDEFINED = 0,
diff -uraN linux-3.0.8/include/net/cfg80211.h linux-3.0.8-fh8632-V1.0_20180330/include/net/cfg80211.h
--- linux-3.0.8/include/net/cfg80211.h	2021-07-14 21:52:05.739141892 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/include/net/cfg80211.h	2021-07-13 23:40:39.026388060 +0300
@@ -426,7 +426,8 @@
  * @STATION_INFO_RX_BITRATE: @rxrate fields are filled
  * @STATION_INFO_BSS_PARAM: @bss_param filled
  * @STATION_INFO_CONNECTED_TIME: @connected_time filled
- */
+ * @STATION_INFO_ASSOC_REQ_IES: @assos_req_ies filled
+*/
 enum station_info_flags {
 	STATION_INFO_INACTIVE_TIME	= 1<<0,
 	STATION_INFO_RX_BYTES		= 1<<1,
@@ -443,8 +444,10 @@
 	STATION_INFO_RX_DROP_MISC	= 1<<12,
 	STATION_INFO_SIGNAL_AVG		= 1<<13,
 	STATION_INFO_RX_BITRATE		= 1<<14,
-	STATION_INFO_BSS_PARAM          = 1<<15,
-	STATION_INFO_CONNECTED_TIME	= 1<<16
+	STATION_INFO_BSS_PARAM		= 1<<15,
+	STATION_INFO_CONNECTED_TIME	= 1<<16,
+	STATION_INFO_ASSOC_REQ_IES	= 1<<17
+
 };
 
 /**
@@ -536,6 +539,11 @@
  *	This number should increase every time the list of stations
  *	changes, i.e. when a station is added or removed, so that
  *	userspace can tell whether it got a consistent snapshot.
+ * @assoc_req_ies: IEs from (Re)Association Request.
+ *	This is used only when in AP mode with drivers that do not use
+ *	user space MLME/SME implementation. The information is provided for
+ *	the cfg80211_new_sta() calls to notify user space of the IEs.
+ * @assoc_req_ies_len: Length of assoc_req_ies buffer in octets.
  */
 struct station_info {
 	u32 filled;
@@ -558,6 +566,9 @@
 	struct sta_bss_parameters bss_param;
 
 	int generation;
+
+	const u8 *assoc_req_ies;
+	size_t assoc_req_ies_len;
 };
 
 /**
diff -uraN linux-3.0.8/lib/Kconfig.debug linux-3.0.8-fh8632-V1.0_20180330/lib/Kconfig.debug
--- linux-3.0.8/lib/Kconfig.debug	2021-07-14 21:52:05.919142412 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/lib/Kconfig.debug	2021-07-13 23:40:37.594379889 +0300
@@ -1,4 +1,11 @@
 
+config TEST_BOOT_TIME
+	bool "Set GPIO level for measuring boot time."
+	default n
+	help
+	  This option will set GPIO 4 to level high at the beginning of
+	  kernel decompressing stage.
+
 config PRINTK_TIME
 	bool "Show timing information on printks"
 	depends on PRINTK
diff -uraN linux-3.0.8/.mailmap linux-3.0.8-fh8632-V1.0_20180330/.mailmap
--- linux-3.0.8/.mailmap	2021-07-14 21:51:58.059119660 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/.mailmap	1970-01-01 03:00:00.000000000 +0300
@@ -1,114 +0,0 @@
-#
-# This list is used by git-shortlog to fix a few botched name translations
-# in the git archive, either because the author's full name was messed up
-# and/or not always written the same way, making contributions from the
-# same person appearing not to be so or badly displayed.
-#
-# repo-abbrev: /pub/scm/linux/kernel/git/
-#
-
-Aaron Durbin <adurbin@google.com>
-Adam Oldham <oldhamca@gmail.com>
-Adam Radford <aradford@gmail.com>
-Adrian Bunk <bunk@stusta.de>
-Alan Cox <alan@lxorguk.ukuu.org.uk>
-Alan Cox <root@hraefn.swansea.linux.org.uk>
-Aleksey Gorelov <aleksey_gorelov@phoenix.com>
-Al Viro <viro@ftp.linux.org.uk>
-Al Viro <viro@zenIV.linux.org.uk>
-Andreas Herrmann <aherrman@de.ibm.com>
-Andrew Morton <akpm@osdl.org>
-Andrew Vasquez <andrew.vasquez@qlogic.com>
-Andy Adamson <andros@citi.umich.edu>
-Archit Taneja <archit@ti.com>
-Arnaud Patard <arnaud.patard@rtp-net.org>
-Arnd Bergmann <arnd@arndb.de>
-Axel Dyks <xl@xlsigned.net>
-Axel Lin <axel.lin@gmail.com>
-Ben Gardner <bgardner@wabtec.com>
-Ben M Cahill <ben.m.cahill@intel.com>
-Bjrn Steinbrink <B.Steinbrink@gmx.de>
-Brian Avery <b.avery@hp.com>
-Brian King <brking@us.ibm.com>
-Christoph Hellwig <hch@lst.de>
-Corey Minyard <minyard@acm.org>
-Damian Hobson-Garcia <dhobsong@igel.co.jp>
-David Brownell <david-b@pacbell.net>
-David Woodhouse <dwmw2@shinybook.infradead.org>
-Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
-Domen Puncer <domen@coderock.org>
-Douglas Gilbert <dougg@torque.net>
-Ed L. Cashin <ecashin@coraid.com>
-Evgeniy Polyakov <johnpol@2ka.mipt.ru>
-Felipe W Damasio <felipewd@terra.com.br>
-Felix Kuhling <fxkuehl@gmx.de>
-Felix Moeller <felix@derklecks.de>
-Filipe Lautert <filipe@icewall.org>
-Franck Bui-Huu <vagabon.xyz@gmail.com>
-Frank Zago <fzago@systemfabricworks.com>
-Greg Kroah-Hartman <greg@echidna.(none)>
-Greg Kroah-Hartman <gregkh@suse.de>
-Greg Kroah-Hartman <greg@kroah.com>
-Henk Vergonet <Henk.Vergonet@gmail.com>
-Henrik Kretzschmar <henne@nachtwindheim.de>
-Herbert Xu <herbert@gondor.apana.org.au>
-Jacob Shin <Jacob.Shin@amd.com>
-James Bottomley <jejb@mulgrave.(none)>
-James Bottomley <jejb@titanic.il.steeleye.com>
-James E Wilson <wilson@specifix.com>
-James Ketrenos <jketreno@io.(none)>
-Jean Tourrilhes <jt@hpl.hp.com>
-Jeff Garzik <jgarzik@pretzel.yyz.us>
-Jens Axboe <axboe@suse.de>
-Jens Osterkamp <Jens.Osterkamp@de.ibm.com>
-John Stultz <johnstul@us.ibm.com>
-Juha Yrjola <at solidboot.com>
-Juha Yrjola <juha.yrjola@nokia.com>
-Juha Yrjola <juha.yrjola@solidboot.com>
-Kay Sievers <kay.sievers@vrfy.org>
-Kenneth W Chen <kenneth.w.chen@intel.com>
-Koushik <raghavendra.koushik@neterion.com>
-Leonid I Ananiev <leonid.i.ananiev@intel.com>
-Linas Vepstas <linas@austin.ibm.com>
-Mark Brown <broonie@sirena.org.uk>
-Matthieu CASTET <castet.matthieu@free.fr>
-Mayuresh Janorkar <mayur@ti.com>
-Michael Buesch <mb@bu3sch.de>
-Michael Buesch <mbuesch@freenet.de>
-Michel Dnzer <michel@tungstengraphics.com>
-Mitesh shah <mshah@teja.com>
-Morten Welinder <terra@gnome.org>
-Morten Welinder <welinder@anemone.rentec.com>
-Morten Welinder <welinder@darter.rentec.com>
-Morten Welinder <welinder@troll.com>
-Mythri P K <mythripk@ti.com>
-Nguyen Anh Quynh <aquynh@gmail.com>
-Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
-Patrick Mochel <mochel@digitalimplant.org>
-Peter A Jonsson <pj@ludd.ltu.se>
-Peter Oruba <peter@oruba.de>
-Peter Oruba <peter.oruba@amd.com>
-Praveen BP <praveenbp@ti.com>
-Rajesh Shah <rajesh.shah@intel.com>
-Ralf Baechle <ralf@linux-mips.org>
-Ralf Wildenhues <Ralf.Wildenhues@gmx.de>
-Rmi Denis-Courmont <rdenis@simphalempin.com>
-Rudolf Marek <R.Marek@sh.cvut.cz>
-Rui Saraiva <rmps@joel.ist.utl.pt>
-Sachin P Sant <ssant@in.ibm.com>
-Sam Ravnborg <sam@mars.ravnborg.org>
-Sascha Hauer <s.hauer@pengutronix.de>
-S.alar Onur <caglar@pardus.org.tr>
-Simon Kelley <simon@thekelleys.org.uk>
-Stphane Witzmann <stephane.witzmann@ubpmes.univ-bpclermont.fr>
-Stephen Hemminger <shemminger@osdl.org>
-Sumit Semwal <sumit.semwal@ti.com>
-Tejun Heo <htejun@gmail.com>
-Thomas Graf <tgraf@suug.ch>
-Tony Luck <tony.luck@intel.com>
-Tsuneo Yoshioka <Tsuneo.Yoshioka@f-secure.com>
-Uwe Kleine-Knig <ukleinek@informatik.uni-freiburg.de>
-Uwe Kleine-Knig <ukl@pengutronix.de>
-Uwe Kleine-Knig <Uwe.Kleine-Koenig@digi.com>
-Valdis Kletnieks <Valdis.Kletnieks@vt.edu>
-Takashi YOSHII <takashi.yoshii.zj@renesas.com>
diff -uraN linux-3.0.8/net/wireless/Kconfig linux-3.0.8-fh8632-V1.0_20180330/net/wireless/Kconfig
--- linux-3.0.8/net/wireless/Kconfig	2021-07-14 21:52:06.275143443 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/net/wireless/Kconfig	2021-07-13 23:40:37.846381348 +0300
@@ -1,5 +1,5 @@
 config WIRELESS_EXT
-	bool
+	def_bool y
 
 config WEXT_CORE
 	def_bool y
@@ -14,7 +14,7 @@
 	bool
 
 config WEXT_PRIV
-	bool
+	def_bool y
 
 config CFG80211
 	tristate "cfg80211 - wireless configuration API"
diff -uraN linux-3.0.8/net/wireless/nl80211.c linux-3.0.8-fh8632-V1.0_20180330/net/wireless/nl80211.c
--- linux-3.0.8/net/wireless/nl80211.c	2021-07-14 21:52:06.279143455 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/net/wireless/nl80211.c	2021-07-13 23:40:37.846381348 +0300
@@ -2209,6 +2209,10 @@
 	}
 	nla_nest_end(msg, sinfoattr);
 
+	if(sinfo->filled & STATION_INFO_ASSOC_REQ_IES)
+		NLA_PUT(msg,NL80211_ATTR_IE,sinfo->assoc_req_ies_len,
+		sinfo->assoc_req_ies);
+
 	return genlmsg_end(msg, hdr);
 
  nla_put_failure:
diff -uraN linux-3.0.8/sound/arm/Kconfig linux-3.0.8-fh8632-V1.0_20180330/sound/arm/Kconfig
--- linux-3.0.8/sound/arm/Kconfig	2021-07-14 21:52:06.387143767 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/sound/arm/Kconfig	2021-07-13 23:40:38.022382365 +0300
@@ -27,7 +27,26 @@
 
 config SND_PXA2XX_LIB_AC97
 	bool
+	
+config SND_FH_LIB
+	tristate
+	select SND_FH_CODEC if SND_FH_LIB_AC97
 
+config SND_FH_LIB_AC97
+	bool	
+config SND_FH_PCM
+	bool
+config SND_FH_AC97
+	tristate "AC97 driver for the Intel FH chip"
+	
+	select SND_FH_PCM
+	select SND_AC97_CODEC
+	select SND_FH_LIB
+	select SND_FH_LIB_AC97
+	help
+	  Say Y or M if you want to support any AC97 codec attached to
+	  the fh81 AC97 interface.
+	
 config SND_PXA2XX_AC97
 	tristate "AC97 driver for the Intel PXA2xx chip"
 	depends on ARCH_PXA
diff -uraN linux-3.0.8/sound/arm/Makefile linux-3.0.8-fh8632-V1.0_20180330/sound/arm/Makefile
--- linux-3.0.8/sound/arm/Makefile	2021-07-14 21:52:06.387143767 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/sound/arm/Makefile	2021-07-13 23:40:38.022382365 +0300
@@ -7,10 +7,16 @@
 
 obj-$(CONFIG_SND_PXA2XX_PCM)	+= snd-pxa2xx-pcm.o
 snd-pxa2xx-pcm-objs		:= pxa2xx-pcm.o
+obj-$(CONFIG_SND_FH_PCM)	+= snd-fh-pcm.o
+snd-fh-pcm-objs		:= fh_pcm.o
 
 obj-$(CONFIG_SND_PXA2XX_LIB)	+= snd-pxa2xx-lib.o
+obj-$(CONFIG_SND_FH_LIB)	+= snd-fh-lib.o
 snd-pxa2xx-lib-y		:= pxa2xx-pcm-lib.o
+snd-fh-lib-y		:= fh-pcm-lib.o
 snd-pxa2xx-lib-$(CONFIG_SND_PXA2XX_LIB_AC97)	+= pxa2xx-ac97-lib.o
-
+snd-fh-lib-$(CONFIG_SND_FH_LIB_AC97)	+= fh-ac97-lib.o
 obj-$(CONFIG_SND_PXA2XX_AC97)	+= snd-pxa2xx-ac97.o
+obj-$(CONFIG_SND_FH_AC97)	+= snd-fh-ac97.o
 snd-pxa2xx-ac97-objs		:= pxa2xx-ac97.o
+snd-fh-ac97-objs		:= fh-ac97.o
\ No newline at end of file
diff -uraN linux-3.0.8/sound/soc/codecs/fsh0ls029aa.c linux-3.0.8-fh8632-V1.0_20180330/sound/soc/codecs/fsh0ls029aa.c
--- linux-3.0.8/sound/soc/codecs/fsh0ls029aa.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/sound/soc/codecs/fsh0ls029aa.c	2021-07-13 23:40:38.278383818 +0300
@@ -0,0 +1,99 @@
+/*
+ * ad73311.c  --  ALSA Soc AD73311 codec support
+ *
+ * Copyright:	Analog Device Inc.
+ * Author:	Cliff Cai <cliff.cai@analog.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/ac97_codec.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include "fsh0ls029aa.h"
+static int ak4104_set_dai_fmt(){
+
+	return 0;
+}
+static int ak4104_hw_params(){
+
+	return 0;
+}
+static int ak4104_sys_params(){
+
+	return 0;
+}
+static struct snd_soc_dai_ops ak4101_dai_ops = {
+	.hw_params = ak4104_hw_params,
+	.set_fmt = ak4104_set_dai_fmt,
+	.set_sysclk=ak4104_sys_params,
+};
+
+static struct snd_soc_dai_driver ad73311_dai = {
+	.name = "fh-acodec-hifi",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE, },
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE, },
+		.ops=&ak4101_dai_ops,
+};
+
+static struct snd_soc_codec_driver soc_codec_dev_ad73311;
+
+static int ad73311_probe(struct platform_device *pdev)
+{
+//	printk("ad73311 probe \n");
+	return snd_soc_register_codec(&pdev->dev,
+			&soc_codec_dev_ad73311, &ad73311_dai, 1);
+}
+
+static int __devexit ad73311_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver ad73311_codec_driver = {
+	.driver = {
+			.name = "fh-acodec",
+			.owner = THIS_MODULE,
+	},
+
+	.probe = ad73311_probe,
+	.remove = __devexit_p(ad73311_remove),
+};
+
+static int __init ad73311_init(void)
+{
+	return platform_driver_register(&ad73311_codec_driver);
+}
+module_init(ad73311_init);
+
+static void __exit ad73311_exit(void)
+{
+	platform_driver_unregister(&ad73311_codec_driver);
+}
+module_exit(ad73311_exit);
+
+MODULE_DESCRIPTION("ASoC ad73311 driver");
+MODULE_AUTHOR("Cliff Cai ");
+MODULE_LICENSE("GPL");
diff -uraN linux-3.0.8/sound/soc/codecs/fsh0ls029aa.h linux-3.0.8-fh8632-V1.0_20180330/sound/soc/codecs/fsh0ls029aa.h
--- linux-3.0.8/sound/soc/codecs/fsh0ls029aa.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/sound/soc/codecs/fsh0ls029aa.h	2021-07-13 23:40:38.310383999 +0300
@@ -0,0 +1,88 @@
+/*
+ * File:         sound/soc/codec/ad73311.h
+ * Based on:
+ * Author:       Cliff Cai <cliff.cai@analog.com>
+ *
+ * Created:      Thur Sep 25, 2008
+ * Description:  definitions for AD73311 registers
+ *
+ *
+ * Modified:
+ *               Copyright 2006 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef __AD73311_H__
+#define __AD73311_H__
+
+#define AD_CONTROL	0x8000
+#define AD_DATA		0x0000
+#define AD_READ		0x4000
+#define AD_WRITE	0x0000
+
+/* Control register A */
+#define CTRL_REG_A	(0 << 8)
+
+#define REGA_MODE_PRO	0x00
+#define REGA_MODE_DATA	0x01
+#define REGA_MODE_MIXED	0x03
+#define REGA_DLB		0x04
+#define REGA_SLB		0x08
+#define REGA_DEVC(x)		((x & 0x7) << 4)
+#define REGA_RESET		0x80
+
+/* Control register B */
+#define CTRL_REG_B	(1 << 8)
+
+#define REGB_DIRATE(x)	(x & 0x3)
+#define REGB_SCDIV(x)	((x & 0x3) << 2)
+#define REGB_MCDIV(x)	((x & 0x7) << 4)
+#define REGB_CEE		(1 << 7)
+
+/* Control register C */
+#define CTRL_REG_C	(2 << 8)
+
+#define REGC_PUDEV		(1 << 0)
+#define REGC_PUADC		(1 << 3)
+#define REGC_PUDAC		(1 << 4)
+#define REGC_PUREF		(1 << 5)
+#define REGC_REFUSE		(1 << 6)
+
+/* Control register D */
+#define CTRL_REG_D	(3 << 8)
+
+#define REGD_IGS(x)		(x & 0x7)
+#define REGD_RMOD		(1 << 3)
+#define REGD_OGS(x)		((x & 0x7) << 4)
+#define REGD_MUTE		(1 << 7)
+
+/* Control register E */
+#define CTRL_REG_E	(4 << 8)
+
+#define REGE_DA(x)		(x & 0x1f)
+#define REGE_IBYP		(1 << 5)
+
+/* Control register F */
+#define CTRL_REG_F	(5 << 8)
+
+#define REGF_SEEN		(1 << 5)
+#define REGF_INV		(1 << 6)
+#define REGF_ALB		(1 << 7)
+
+#endif
diff -uraN linux-3.0.8/sound/soc/codecs/Kconfig linux-3.0.8-fh8632-V1.0_20180330/sound/soc/codecs/Kconfig
--- linux-3.0.8/sound/soc/codecs/Kconfig	2021-07-14 21:52:06.579144323 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/sound/soc/codecs/Kconfig	2021-07-13 23:40:38.306383977 +0300
@@ -119,6 +119,11 @@
 	tristate
 	select SND_AC97_CODEC
 
+config SND_SOC_FH_CODEC
+	tristate
+	select SND_FH_CODEC
+	select SND_AC97_CODEC
+
 config SND_SOC_AD1836
 	tristate
 
@@ -222,6 +227,9 @@
 config SND_SOC_TLV320AIC23
 	tristate
 
+config SND_SOC_FSH0LS029AA
+	tristate
+
 config SND_SOC_TLV320AIC26
 	tristate "TI TLV320AIC26 Codec support" if SND_SOC_OF_SIMPLE
 	depends on SPI
diff -uraN linux-3.0.8/sound/soc/codecs/Makefile linux-3.0.8-fh8632-V1.0_20180330/sound/soc/codecs/Makefile
--- linux-3.0.8/sound/soc/codecs/Makefile	2021-07-14 21:52:06.579144323 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/sound/soc/codecs/Makefile	2021-07-13 23:40:38.282383840 +0300
@@ -1,5 +1,6 @@
 snd-soc-88pm860x-objs := 88pm860x-codec.o
 snd-soc-ac97-objs := ac97.o
+snd-soc-fh-objs := fh.o
 snd-soc-ad1836-objs := ad1836.o
 snd-soc-ad193x-objs := ad193x.o
 snd-soc-ad1980-objs := ad1980.o
@@ -30,6 +31,7 @@
 snd-soc-ssm2602-objs := ssm2602.o
 snd-soc-stac9766-objs := stac9766.o
 snd-soc-tlv320aic23-objs := tlv320aic23.o
+snd-soc-fsh0ls029aa-objs := fsh0ls029aa.o
 snd-soc-tlv320aic26-objs := tlv320aic26.o
 snd-soc-tlv320aic3x-objs := tlv320aic3x.o
 snd-soc-tlv320aic32x4-objs := tlv320aic32x4.o
@@ -91,6 +93,7 @@
 
 obj-$(CONFIG_SND_SOC_88PM860X)	+= snd-soc-88pm860x.o
 obj-$(CONFIG_SND_SOC_AC97_CODEC)	+= snd-soc-ac97.o
+obj-$(CONFIG_SND_SOC_FH_CODEC)	+= snd-soc-fh.o
 obj-$(CONFIG_SND_SOC_AD1836)	+= snd-soc-ad1836.o
 obj-$(CONFIG_SND_SOC_AD193X)	+= snd-soc-ad193x.o
 obj-$(CONFIG_SND_SOC_AD1980)	+= snd-soc-ad1980.o
@@ -122,6 +125,7 @@
 obj-$(CONFIG_SND_SOC_SSM2602)	+= snd-soc-ssm2602.o
 obj-$(CONFIG_SND_SOC_STAC9766)	+= snd-soc-stac9766.o
 obj-$(CONFIG_SND_SOC_TLV320AIC23)	+= snd-soc-tlv320aic23.o
+obj-$(CONFIG_SND_SOC_FSH0LS029AA)	+= snd-soc-fsh0ls029aa.o
 obj-$(CONFIG_SND_SOC_TLV320AIC26)	+= snd-soc-tlv320aic26.o
 obj-$(CONFIG_SND_SOC_TLV320AIC3X)	+= snd-soc-tlv320aic3x.o
 obj-$(CONFIG_SND_SOC_TVL320AIC32X4)     += snd-soc-tlv320aic32x4.o
diff -uraN linux-3.0.8/sound/soc/dwc/dma.c linux-3.0.8-fh8632-V1.0_20180330/sound/soc/dwc/dma.c
--- linux-3.0.8/sound/soc/dwc/dma.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/sound/soc/dwc/dma.c	2021-07-13 23:40:38.318384044 +0300
@@ -0,0 +1,636 @@
+
+/*******************************************
+ * 
+ * new drive add by xuww
+ * 
+ * 
+ * **********************************/
+/**
+* @file			
+* @brief  
+* @version 
+* @author		xuww
+* @date			
+* @note
+*      
+*      
+* @copy
+*
+* 
+* 
+*
+* <h1><center>&copy; COPYRIGHT 2013 fullhan</center></h1>
+*/
+/* Includes ------------------------------------------------------------------*/
+#include "dma.h"
+#include <mach/fh_predefined.h>
+
+#define		MAX_DMA_CHANS				(4)
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+/*******************************************************************************
+* Function Name  : Dma_GetChanStatus
+* Description    : get the channel status 
+* Input          : nChanID :channel ID 
+* Output         : None
+* Return         : None
+* 		                                      
+ *******************************************************************************/
+int Dma_GetChanStatus( int nChanID )
+{
+	return (int)(GET_REG( REG_DMAC_CHAN_EN ) & ( 1 << nChanID ));
+}
+/*******************************************************************************
+* Function Name  : Dma_EnableChan
+* Description    : enable channel
+* Input          : nChanID   :channel ID 
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_EnableChan( int nChanID )
+{
+	int nMask = (1 << (nChanID + 8)) | ( 1 << nChanID );
+
+	SET_REG_M( REG_DMAC_CHAN_EN, nMask, nMask );
+}
+/*******************************************************************************
+* Function Name  : Dma_DisableChan
+* Description    : disable channel  
+* Input          : nChanID :channel ID 
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_DisableChan( int nChanID )
+{
+	int nMask = ( 1 << ( nChanID + 8 ) );
+
+	SET_REG_M( REG_DMAC_CHAN_EN, nMask, (nMask + (1 << nChanID)) );
+	while( GET_REG( REG_DMAC_CHAN_EN) & (1 << nChanID) );
+}
+/*******************************************************************************
+* Function Name  : Dma_ClearIsrBit
+* Description    : clear the  interruput   bit 
+* Input          : iChan :channel ID    nMask :unchange bit
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_ClearIsrBit( int iChan, int nMask )
+{
+	if( nMask & DMA_INTT_TXR)
+		SET_REG( REG_DMAC_INTCLR_TFR, 1 << iChan );
+	if( nMask & DMA_INTT_BLOCK)
+		SET_REG( REG_DMAC_INTCLR_BLK, 1 << iChan );
+	if( nMask & DMA_INTT_SOURCE )
+		SET_REG( REG_DMAC_INTCLR_SRCTXR, 1 << iChan );
+	if( nMask & DMA_INTT_DEST )
+		SET_REG( REG_DMAC_INTCLR_DSTTXR, 1 << iChan );
+	if( nMask & DMA_INTT_ERR )
+		SET_REG( REG_DMAC_INTCLR_ERR, 1 << iChan );
+}
+/*******************************************************************************
+* Function Name  : Dma_EnableIsrBit
+* Description    : enable intruput bit  
+* Input          : iChan :channel ID    nMask:unchange bit 
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_EnableIsrBit( int iChan, int nMask )
+{
+	int nEnable = (1 << (iChan + 8)) | (1 << iChan);
+	
+	if( nMask & DMA_INTT_TXR) 
+		SET_REG_M( REG_DMAC_INTMSK_TFR, nEnable, nEnable );
+	if( nMask & DMA_INTT_BLOCK)
+		SET_REG_M( REG_DMAC_INTMSK_BLK, nEnable, nEnable );
+	if( nMask & DMA_INTT_SOURCE)
+		SET_REG_M( REG_DMAC_INTMSK_SRCTXR, nEnable, nEnable );
+	if( nMask & DMA_INTT_DEST)
+		SET_REG_M( REG_DMAC_INTMSK_DSTTXR, nEnable, nEnable );
+	if( nMask & DMA_INTT_ERR)
+		SET_REG_M( REG_DMAC_INTMSK_ERR, nEnable, nEnable );
+	
+	SET_REG_M( REG_DMAC_CTXi(iChan), 1, 1 );		// Enable isr.
+}
+/*******************************************************************************
+* Function Name  : Dma_DisableIsrBit
+* Description    : disbale interruput  
+* Input          : iChan:channel ID    nMask:unchange bit
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+
+void Dma_DisableIsrBit( int iChan, int nMask )
+{
+	int nEnable = (1 << (iChan + 8)) | (1 << iChan);
+	
+	if( nMask & DMA_INTT_TXR) 
+		SET_REG_M( REG_DMAC_INTCLR_TFR, 0, nEnable );
+	if( nMask & DMA_INTT_BLOCK)
+		SET_REG_M( REG_DMAC_INTCLR_BLK, 0, nEnable );
+	if( nMask & DMA_INTT_SOURCE)
+		SET_REG_M( REG_DMAC_INTCLR_SRCTXR, 0, nEnable );
+	if( nMask & DMA_INTT_DEST)
+		SET_REG_M( REG_DMAC_INTCLR_DSTTXR, 0, nEnable );
+	if( nMask & DMA_INTT_ERR)
+		SET_REG_M( REG_DMAC_INTCLR_ERR, 0, nEnable );
+}
+/*******************************************************************************
+* Function Name  : Dma_QueryISRStatus
+* Description    : not use 
+* Input          : None
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+int Dma_QueryISRStatus( int iChan )
+{
+	return 0;
+}
+/*******************************************************************************
+* Function Name  : Dma_ClearTfrDone
+* Description    : clear tfr Done bit
+* Input          : iChan:channel ID 
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_ClearTfrDone(int iChan )
+{
+	SET_REG_M( REG_DMAC_CTXi(iChan) + 4, 0, 1 << 12 );
+}
+/*******************************************************************************
+* Function Name  : Dma_SetTxrSize
+* Description    : set txr size 
+* Input          : iChan:channel ID   nByes:size 
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_SetTxrSize( int iChan, int nBytes )
+{
+	if( nBytes > 4095 )
+		nBytes = 4095;
+	SET_REG_M( REG_DMAC_CTXi(iChan) + 4, (unsigned long long)nBytes, 0xfff );
+}
+/*******************************************************************************
+* Function Name  : Dma_SetSrcWidth
+* Description    : set source width 
+* Input          : iChan:channel ID   nWidth :fifo width
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_SetSrcWidth( int iChan, int nWidth )
+{
+	SET_REG_M( REG_DMAC_CTXi(iChan), nWidth << 4, 0x70 );
+}
+/*******************************************************************************
+* Function Name  : Dma_SetDstWidth
+* Description    : set destination  
+* Input          : iChan:channel ID   nWidth :fifo width
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_SetDstWidth( int iChan, int nWidth )
+{
+	SET_REG_M( REG_DMAC_CTXi(iChan), nWidth << 1, 0xe );
+}
+/*******************************************************************************
+* Function Name  : Dma_SetSrcSize
+* Description    : set source size  
+* Input          : iChan :channel ID  nSize : fifo depth
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_SetSrcSize( int iChan, int nSize )		// burst size
+{
+	SET_REG_M( REG_DMAC_CTXi(iChan), nSize << 14, 0x1c000 );
+}
+/*******************************************************************************
+* Function Name  : Dma_SetDstSize
+* Description    : set  destination size 
+* Input          : iChan :channel ID  nSize : fifo depth
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_SetDstSize( int iChan, int nSize )
+{
+	SET_REG_M( REG_DMAC_CTXi(iChan), nSize << 11, 0x3800 );
+}
+/*******************************************************************************
+* Function Name  : Dma_EnableSrcBlkChain
+* Description    : enable source  block chain 
+* Input          : iChan:channel ID 
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_EnableSrcBlkChain(int iChan )
+{
+	SET_REG_M( REG_DMAC_CTXi(iChan), 1 << 28, 1 << 28 );
+}
+/*******************************************************************************
+* Function Name  : Dma_EnableDstBlkChain
+* Description    : enable destinationg block chain 
+* Input          : iChan:channel ID    
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_EnableDstBlkChain(int iChan )
+{
+	SET_REG_M( REG_DMAC_CTXi(iChan), 1 << 27, 1 << 27 );
+}
+/*******************************************************************************
+* Function Name  : Dma_SetTxrType
+* Description    : set   txr  mode 
+* Input          : iChan:channel ID    nMode :transation mode
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_SetTxrType( int iChan, int nMode )
+{
+	if( nMode >= 0 && nMode < DMA_TTFC_INVALID )
+	{
+		SET_REG_M( REG_DMAC_CTXi(iChan), nMode << 20, 0x7 << 20 );	
+	}
+}
+/*******************************************************************************
+* Function Name  : Dma_SetDstIncDirection
+* Description    : set source address increment decrement   or not change 
+* Input          : iChan:channel ID    nDir :0 :increment  1:decrement   other :not   change
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_SetSrcIncDirection( int iChan, int nDir )
+{
+	if( nDir == DMA_DIR_INC )
+		SET_REG_M( REG_DMAC_CTXi(iChan), 0, 0x600 );
+	else if( nDir == DMA_DIR_DEC )
+		SET_REG_M( REG_DMAC_CTXi(iChan), 0x200, 0x200 );
+	else
+		SET_REG_M( REG_DMAC_CTXi(iChan), 0x400, 0x400 );
+}
+/*******************************************************************************
+* Function Name  : Dma_SetDstIncDirection
+* Description    : set destination address increment decrement   or not change
+* Input          : iChan:channel ID    nDir :0 :increment  1:decrement   other :not   change
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_SetDstIncDirection( int iChan, int nDir )
+{
+	if( nDir == DMA_DIR_INC )
+		SET_REG_M( REG_DMAC_CTXi(iChan), 0, 0x180 );
+	else if( nDir == DMA_DIR_DEC )
+		SET_REG_M( REG_DMAC_CTXi(iChan), 0x80, 0x080 );
+	else
+		SET_REG_M( REG_DMAC_CTXi(iChan), 0x100, 0x100 );
+}
+/*******************************************************************************
+* Function Name  : Dma_EnableGather
+* Description    : set   enable   gather
+* Input          : iChan :channel ID    bEnable :0 disable   1:enable
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_EnableGather(int iChan, int bEnable )
+{
+	int v;
+	if( bEnable ) v = 1;
+	else v = 0;
+	SET_REG_M( REG_DMAC_CTXi(iChan), v << 17, 1 << 17 );	
+}
+/*******************************************************************************
+* Function Name  : Dma_EnableScatter
+* Description    : set   enable   scatter  
+* Input          : iChan :channel ID    bEnable :0 disable   1:enable 
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_EnableScatter(int iChan, int bEnable )
+{
+	int v = 0;
+	if( bEnable ) v = 1;
+	SET_REG_M( REG_DMAC_CTXi(iChan), v << 18, 1 << 18 );	
+}
+/*******************************************************************************
+* Function Name  : Dma_SetSrcHsMode
+* Description    : set the source handshaking  mode  
+* Input          : iChan:channe ID    nMode:0 hardware  1:software
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_SetSrcHsMode( int iChan, int nMode )
+{
+	nMode &= 0x1;
+	SET_REG_M( REG_DMAC_CFGi(iChan), nMode << 11, 1 << 11 );
+}
+/*******************************************************************************
+* Function Name  : Dma_SetDstHsMode
+* Description    : set the destination handshaking  mode  
+* Input          : iChan:channe ID    nMode:0 hardware  1:software
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_SetDstHsMode( int iChan, int nMode )
+{
+	nMode &= 1;
+	SET_REG_M( REG_DMAC_CFGi(iChan), nMode << 10, 1 << 10 );
+}
+/*******************************************************************************
+* Function Name  : Dma_SetFifoMode
+* Description    : set fifo request transation mode 
+* Input          : iChan :channel   nMode  :1:half  fifo  or 0:enough one burst
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_SetFifoMode( int iChan, int nMode )
+{
+	nMode &= 1;
+	SET_REG_M( REG_DMAC_CFGi(iChan) + 4, nMode << 1, 1 << 1 );
+}
+/*******************************************************************************
+* Function Name  : Dma_SetFlowCtrl
+* Description    : set dam flow control :source or  destionation 
+* Input          : iChan :channel ID      ctrl:0: source   1:destinationg
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_SetFlowCtrl( int iChan, int ctrl )
+{
+	ctrl &= 1;
+	SET_REG_M( REG_DMAC_CFGi(iChan) + 4, ctrl, 1 );
+}
+/*******************************************************************************
+* Function Name  : Dma_SetSrcAutoload
+* Description    : set  destination auto load  the   init address
+* Input          : iChan :channel ID    bEnable :enable or disable
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_SetSrcAutoload(int iChan, int bEnable )
+{
+	int v = bEnable ? 1 : 0;
+	SET_REG_M( REG_DMAC_CFGi(iChan), v << 30, 1 << 30 );
+}
+/*******************************************************************************
+* Function Name  : Dma_SetDstAutoload
+* Description    : set  destination auto load  the   init address
+* Input          : iChan :channel ID    bEnable :enable or disable 
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_SetDstAutoload(int iChan, int bEnable )
+{
+	int v = bEnable ? 1 : 0;
+	SET_REG_M( REG_DMAC_CFGi(iChan), v << 31, 1 << 31 );
+}
+/*******************************************************************************
+* Function Name  : Write_Regm
+* Description    : write the   reg   mask the unchange bit  
+* Input          : addr: reg address   value :reg value    mask :unchange bit 
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+static void Write_Regm( unsigned int addr, unsigned int value, unsigned int mask )
+{
+	unsigned int tmp = GET_REG(addr);
+	tmp &= ~mask;
+	value &= mask;
+	tmp |= value;
+	SET_REG(addr, tmp);
+}
+/*******************************************************************************
+* Function Name  : Dma_SetMaxBurst
+* Description    : set the max burst size
+* Input          : iChan:channel ID     nSize :  burst size
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_SetMaxBurst( int iChan, int nSize )
+{
+	if( nSize > 1023 )
+		nSize = 1023; 
+	Write_Regm( REG_DMAC_CFGi(iChan), (nSize << 20), 0x3ff00000 );
+}
+/*******************************************************************************
+* Function Name  : Dma_SetSrcHsPol
+* Description    : set the  source handshaking polatity
+* Input          : iChan:channel ID      nPol: polarity  high or low
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_SetSrcHsPol( int iChan, int nPol )
+{
+	nPol &= 1;
+	SET_REG_M( REG_DMAC_CFGi(iChan), nPol << 19, 1 << 19 );
+}
+/*******************************************************************************
+* Function Name  : Dma_SetDstHsPol
+* Description    : set the  destination handshaking polatity
+* Input          : iChan:channel ID      nPol: polarity  high or low
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_SetDstHsPol( int iChan, int nPol )
+{
+	nPol &= 1;
+	SET_REG_M( REG_DMAC_CFGi(iChan), nPol << 18, 1 << 18 );
+}
+/*******************************************************************************
+* Function Name  : Dma_SetLinkEntry
+* Description    : enbale the  link list 
+* Input          : iChan:channel ID    nAddr :link list address
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_SetLinkEntry( int iChan, unsigned int nAddr )
+{
+	nAddr &= 0xfffffffc;
+	// force to use AHB Master 0, for this is the only AHB Master.
+	SET_REG_M( REG_DMAC_LLPi(iChan), nAddr, 0xffffffff );
+}
+/*******************************************************************************
+* Function Name  : Dma_SetSrcAddress
+* Description    : set source address 
+* Input          : iChan:channel ID     nAddr:destination address
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_SetSrcAddress( int iChan, unsigned int nAddr )
+{
+	SET_REG_M( REG_DMAC_SARi(iChan), nAddr, 0xffffffff );
+}
+/*******************************************************************************
+* Function Name  : Dma_SetDstAddress
+* Description    : set destination address 
+* Input          : iChan:channel ID     nAddr:destination address
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_SetDstAddress( int iChan, unsigned int nAddr )
+{
+	SET_REG_M( REG_DMAC_DARi(iChan), nAddr, 0xffffffff );
+}
+/*******************************************************************************
+* Function Name  : Dma_SetSrcPe
+* Description    : select the hardshaking   interface
+* Input          : iChan:channel ID   nPer:handshaking interface
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_SetSrcPer( int iChan, unsigned int nPer )
+{
+	if( nPer < DMA_HSP_INVALID ) 
+	{
+		SET_REG_M( REG_DMAC_CFGi(iChan) + 4, nPer << 7, 0xf << 7 );
+	}
+}
+/*******************************************************************************
+* Function Name  : Dma_SetDstPer
+* Description    : select the hardshaking   interface
+* Input          : iChan:channel ID   nPer:handshaking interface
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_SetDstPer( int iChan, unsigned int nPer )
+{
+	if( nPer < DMA_HSP_INVALID )
+	{
+		SET_REG_M( REG_DMAC_CFGi(iChan) + 4, nPer << 11, 0xf << 11 );
+	}
+}
+/*******************************************************************************
+* Function Name  : Dma_GetIsrChan
+* Description    : get the status of dam interruput  
+* Input          : iChan :channel ID 
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+unsigned int Dma_GetIsrChan(unsigned int nMask)
+{
+	if( nMask & DMA_INTT_TXR )
+		return GET_REG(REG_DMAC_INTSTAT_TFR);
+	if( nMask & DMA_INTT_BLOCK )
+		return GET_REG(REG_DMAC_INTSTAT_BLK);
+	if( nMask & DMA_INTT_SOURCE )
+		return GET_REG(REG_DMAC_INTSTAT_SRCTXR);
+	if( nMask & DMA_INTT_DEST )
+		return GET_REG(REG_DMAC_INTSTAT_DSTTXR);
+	if( nMask & DMA_INTT_ERR )
+		return GET_REG(REG_DMAC_INTSTAT_ERR);
+	
+	return 0;
+}
+/*******************************************************************************
+* Function Name  : Dma_StartSrctfr
+* Description    : dma source start transaction 
+* Input          : iChan:channel
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_StartSrctfr( int iChan )
+{
+	int nMask = 0x101 << (iChan);
+
+	SET_REG( REG_DMAC_REQSRC, 0x101 );
+	SET_REG( REG_DMAC_SGLREQSRC, 0x101 );
+}
+/*******************************************************************************
+* Function Name  : Dma_StartDsttfr
+* Description    : destination transaction  request
+* Input          : iChan: channel ID
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_StartDsttfr( int iChan )
+{
+	int nMask = 0x101 << (iChan);
+	SET_REG( REG_DMAC_REQDST, nMask );
+	SET_REG( REG_DMAC_SGLREQDST, nMask );
+}
+/*******************************************************************************
+* Function Name  : fh_dma_init
+* Description    : dma init
+* Input          : None
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void fh_dma_init()
+{
+		Dma_Init();
+}
+/*******************************************************************************
+* Function Name  : Dma_Init
+* Description    : dma init 
+* Input          : None
+* Output         : None
+* Return         : None   	
+* 		                                      
+ *******************************************************************************/
+void Dma_Init()
+{
+	int i;
+	SET_REG( REG_DMAC_CFG_REG, 1 );
+	
+	for( i = 0; i < MAX_DMA_CHANS; i ++ )
+	{
+		Dma_DisableChan(i);
+		Dma_ClearIsrBit( i, DMA_INTT_TXR | DMA_INTT_BLOCK | DMA_INTT_SOURCE | DMA_INTT_DEST | DMA_INTT_ERR );
+		Dma_ClearTfrDone(i);
+		Dma_SetTxrType(i, DMA_TTFC_M2P_DMAC);
+		Dma_SetSrcWidth( i, DMA_TXR_32BITS );
+		Dma_SetSrcSize( i, DMA_BURST_8 );	
+		Dma_SetDstWidth( i, DMA_TXR_8BITS );
+		Dma_SetDstSize( i, DMA_BURST_8 );
+		Dma_SetSrcHsPol( i, DMA_HSPOL_ACTHIGH );  
+		Dma_SetDstHsPol( i, DMA_HSPOL_ACTHIGH );	
+		Dma_SetSrcIncDirection( i, DMA_DIR_INC );
+		Dma_SetDstIncDirection( i, DMA_DIR_UNCHG );
+		Dma_SetSrcHsMode( i, DMA_HSMODE_SOFTWARE );
+		Dma_SetDstHsMode( i, DMA_HSMODE_SOFTWARE );
+		Dma_SetMaxBurst( i, 0 );
+		Dma_SetFifoMode( i, 0 );
+		Dma_SetLinkEntry( i, 0 );
+		Dma_EnableGather( i, 0 );
+		Dma_EnableScatter( i, 0 );
+	}
+}
diff -uraN linux-3.0.8/sound/soc/dwc/dma.h linux-3.0.8-fh8632-V1.0_20180330/sound/soc/dwc/dma.h
--- linux-3.0.8/sound/soc/dwc/dma.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/sound/soc/dwc/dma.h	2021-07-13 23:40:38.318384044 +0300
@@ -0,0 +1,212 @@
+
+/*********************************
+ * 
+ * new drive add by xuww
+ * 
+ * ****************************/
+#ifndef DMA__H
+#define	DMA__H
+
+
+#if(1)
+enum
+{
+	DMA_INTT_TXR = 1,
+	DMA_INTT_BLOCK = 2,
+	DMA_INTT_SOURCE = 4,
+	DMA_INTT_DEST = 8,
+	DMA_INTT_ERR = 16
+};
+
+enum
+{
+	DMA_TXR_8BITS = 0,
+	DMA_TXR_16BITS = 1,
+	DMA_TXR_32BITS = 2,
+	DMA_TXR_64BITS = 3,
+	DMA_TXR_128BITS = 4,
+	DMA_TXR_256BITS = 5,
+	DMA_TXR_INVALID = 6
+};
+
+enum
+{
+	DMA_BURST_1 = 0,
+	DMA_BURST_4 = 1,
+	DMA_BURST_8 = 2,
+	DMA_BURST_16 = 3,
+	DMA_BURST_32 = 4,
+	DMA_BURST_64 = 5,
+	DMA_BURST_128 = 6,
+	DMA_BURST_256 = 7,
+	DMA_BURST_INVALID = 8
+};
+
+enum
+{
+	DMA_TTFC_M2M_DMAC,
+	DMA_TTFC_M2P_DMAC,
+	DMA_TTFC_P2M_DMAC,
+	DMA_TTFC_P2P_DMAC,
+	DMA_TTFC_P2M_PFR,
+	DMA_TTFC_P2P_PSRC,
+	DMA_TTFC_M2P_PFR,
+	DMA_TTFC_P2P_PDST,
+	DMA_TTFC_INVALID
+};
+
+enum
+{
+	DMA_DIR_INC,
+	DMA_DIR_DEC,
+	DMA_DIR_UNCHG,
+	DMA_DIR_INVALID
+};
+
+enum
+{
+	DMA_HSPOL_ACTHIGH,
+	DMA_HSPOL_ACTLOW
+};
+
+enum
+{
+	DMA_HSMODE_HARDWARE = 0,
+	DMA_HSMODE_SOFTWARE = 1
+};
+
+enum
+{
+	DMA_HSP_SDC,
+	DMA_HSP_AIFRX,
+	DMA_HSP_AIFTX,
+	DMA_HSP_TAE,
+	DMA_HSP_I2SRX,
+	DMA_HSP_I2STX,
+	DMA_HSP_SPI0RX,
+	DMA_HSP_SPI0TX,
+	DMA_HSP_SPI1RX,
+	DMA_HSP_SPI1TX,
+	DMA_HSP_UART0RX,
+	DMA_HSP_UART0TX,
+	DMA_HSP_UART1RX,
+	DMA_HSP_UART1TX,
+	DMA_HSP_SPI2RX,
+	DMA_HSP_SPI2TX,
+	DMA_HSP_INVALID
+};
+#endif
+#define		DMAC_REG_BASE		(0xfe600000)
+#define     REG_DMAC_SAR_OFFSET     (0x0)
+#define     REG_DMAC_DAR_OFFSET     (0x8)
+#define     REG_DMAC_LLP_OFFSET     (0x10)
+#define     REG_DMAC_CTX_OFFSET     (0x18)
+#define     REG_DMAC_SSTAT_OFFSET       (0x20)
+#define     REG_DMAC_DSTAT_OFFSET       (0x28)
+#define     REG_DMAC_SSTATAR_OFFSET (0x30)
+#define     REG_DMAC_DSTATAR_OFFSET (0x38)
+#define     REG_DMAC_CFG_OFFSET     (0x40)
+#define     REG_DMAC_SGR_OFFSET     (0x48)
+#define     REG_DMAC_DSR_OFFSET     (0x50)
+#define     REG_DMAC_SARi(n)            (DMAC_REG_BASE + (n) * 0x58 + REG_DMAC_SAR_OFFSET)
+#define     REG_DMAC_DARi(n)            (DMAC_REG_BASE + (n) * 0x58 + REG_DMAC_DAR_OFFSET)
+#define     REG_DMAC_LLPi(n)            (DMAC_REG_BASE + (n) * 0x58 + REG_DMAC_LLP_OFFSET)
+#define     REG_DMAC_CTXi(n)            (DMAC_REG_BASE + (n) * 0x58 + REG_DMAC_CTX_OFFSET)
+#define     REG_DMAC_SSTATi(n)          (DMAC_REG_BASE + (n) * 0x58 + REG_DMAC_SSTAT_OFFSET)
+#define     REG_DMAC_DSTATi(n)          (DMAC_REG_BASE + (n) * 0x58 + REG_DMAC_DSTAT_OFFSET)
+#define     REG_DMAC_SSTATARi(n)        (DMAC_REG_BASE + (n) * 0x58 + REG_DMAC_SSTATAR_OFFSET)
+#define     REG_DMAC_DSTATARi(n)        (DMAC_REG_BASE + (n) * 0x58 + REG_DMAC_DSTATAR_OFFSET)
+#define     REG_DMAC_CFGi(n)            (DMAC_REG_BASE + (n) * 0x58 + REG_DMAC_CFG_OFFSET)
+#define     REG_DMAC_SGRi(n)            (DMAC_REG_BASE + (n) * 0x58 + REG_DMAC_SGR_OFFSET)
+#define     REG_DMAC_DSRi(n)            (DMAC_REG_BASE + (n) * 0x58 + REG_DMAC_DSR_OFFSETR)
+
+#define     REG_DMAC_INTRAWTFR          (DMAC_REG_BASE + 0x2c0)
+#define     REG_DMAC_INTRAWBLK          (DMAC_REG_BASE + 0x2c8)
+#define     REG_DMAC_INTRAWSRCTXR       (DMAC_REG_BASE + 0x2d0)
+#define     REG_DMAC_INTRAWDSTTXR       (DMAC_REG_BASE + 0x2d8)
+#define     REG_DMAC_INTRAWERR          (DMAC_REG_BASE + 0x2e0)
+#define     REG_DMAC_INTSTAT_TFR        (DMAC_REG_BASE + 0x2e8)
+#define     REG_DMAC_INTSTAT_BLK        (DMAC_REG_BASE + 0x2f0)
+#define     REG_DMAC_INTSTAT_SRCTXR     (DMAC_REG_BASE + 0x2f8)
+#define     REG_DMAC_INTSTAT_DSTTXR     (DMAC_REG_BASE + 0x300)
+#define     REG_DMAC_INTSTAT_ERR        (DMAC_REG_BASE + 0x308)
+#define     REG_DMAC_INTMSK_TFR         (DMAC_REG_BASE + 0x310)
+#define     REG_DMAC_INTMSK_BLK         (DMAC_REG_BASE + 0x318)
+#define     REG_DMAC_INTMSK_SRCTXR      (DMAC_REG_BASE + 0x320)
+#define     REG_DMAC_INTMSK_DSTTXR      (DMAC_REG_BASE + 0x328)
+#define     REG_DMAC_INTMSK_ERR         (DMAC_REG_BASE + 0x330)
+#define     REG_DMAC_INTCLR_TFR         (DMAC_REG_BASE + 0x338)
+#define     REG_DMAC_INTCLR_BLK         (DMAC_REG_BASE + 0x340)
+#define     REG_DMAC_INTCLR_SRCTXR      (DMAC_REG_BASE + 0x348)
+#define     REG_DMAC_INTCLR_DSTTXR      (DMAC_REG_BASE + 0x350)
+#define     REG_DMAC_INTCLR_ERR         (DMAC_REG_BASE + 0x358)
+#define     REG_DMAC_INT_STATUS_ALL     (DMAC_REG_BASE + 0x360)
+
+#define     REG_DMAC_REQSRC             (DMAC_REG_BASE + 0x368)
+#define     REG_DMAC_REQDST             (DMAC_REG_BASE + 0x370)
+#define     REG_DMAC_SGLREQSRC          (DMAC_REG_BASE + 0x378)
+#define     REG_DMAC_SGLREQDST          (DMAC_REG_BASE + 0x380)
+#define     REG_DMAC_LSTSRC             (DMAC_REG_BASE + 0x388)
+#define     REG_DMAC_LSTDST             (DMAC_REG_BASE + 0x390)
+#define     REG_DMAC_CFG_REG            (DMAC_REG_BASE + 0x398)
+#define     REG_DMAC_CHAN_EN            (DMAC_REG_BASE + 0x3a0)
+#define     REG_DMAC_IDREG              (DMAC_REG_BASE + 0x3a8)
+#define     REG_DMAC_TESTREG            (DMAC_REG_BASE + 0x3b0)
+#define     REG_DMAC_COMPARAMS_6        (DMAC_REG_BASE + 0x3c8)
+#define     REG_DMAC_COMPARAMS_5        (DMAC_REG_BASE + 0x3d0)
+#define     REG_DMAC_COMPARAMS_4        (DMAC_REG_BASE + 0x3d8)
+#define     REG_DMAC_COMPARAMS_3        (DMAC_REG_BASE + 0x3e0)
+#define     REG_DMAC_COMPARAMS_2        (DMAC_REG_BASE + 0x3e8)
+#define     REG_DMAC_COMPARAMS_1        (DMAC_REG_BASE + 0x3f0)
+#define     REG_DMAC_COMP_IDREG         (DMAC_REG_BASE + 0x3f8)
+int 	Dma_GetChanStatus( int nChanID );
+void 	Dma_EnableChan( int nChanID );
+void 	Dma_DisableChan( int nChanID );
+
+void 	Dma_ClearIsrBit( int iChan, int nMask );
+void 	Dma_EnableIsrBit( int iChan, int nMask );
+void 	Dma_DisableIsrBit( int iChan, int nMask );
+unsigned int Dma_GetIsrChan(unsigned int nMask);
+int 	Dma_QueryIsrStatus( );
+
+void 	Dma_ClearTfrDone(int iChan);
+void 	Dma_SetTxrSize( int iChan, int nBytes );
+void 	Dma_SetSrcWidth( int iChan, int nWidth );
+void	Dma_SetDstWidth( int iChan, int nWidth );
+void 	Dma_SetSrcSize( int iChan, int nSize );		// burst size
+void	Dma_SetDstSize( int iChan, int nSize );
+void 	Dma_EnableSrcBlkChain(int iChan);
+void	Dma_EnableDstBlkChain(int iChan);
+
+void 	Dma_SetTxrType( int iChan, int nMode );
+void	Dma_SetSrcIncDirection( int iChan, int nDir );
+void	Dma_SetDstIncDirection( int iChan, int nDir );
+
+void 	Dma_EnableGather( int iChan, int bEnable );
+void 	Dma_EnableScatter( int iChan, int bEnable);
+
+void 	Dma_SetSrcHsMode( int iChan, int nMode );
+void 	Dma_SetDstHsMode( int iChan, int nMode );
+
+void	Dma_SetFifoMode( int iChan, int nMode );
+void 	Dma_SetFlowCtrl( int iChan, int ctrl );
+void 	Dma_SetSrcAutoload(int iChan, int bEnable );
+void	Dma_SetDstAutoload(int iChan, int bEnable );
+void	Dma_SetMaxBurst( int iChan, int nSize );
+
+void 	Dma_SetSrcHsPol( int iChan, int nPol );
+void 	Dma_SetDstHsPol( int iChan, int nPol );
+
+void 	Dma_SetLinkEntry( int iChan, unsigned int nAddr );
+void 	Dma_SetSrcAddress( int iChan, unsigned int nAddr );
+void 	Dma_SetDstAddress( int iChan, unsigned int nAddr );
+void	Dma_SetSrcPer( int iChan, unsigned int nPer );
+void 	Dma_SetDstPer( int iChan, unsigned int nPer );
+
+void 	Dma_StartSrctfr( int iChan );
+void 	Dma_StartDsttfr( int iChan );
+
+void Dma_Init();
+
+#endif
+
diff -uraN linux-3.0.8/sound/soc/dwc/fh.c linux-3.0.8-fh8632-V1.0_20180330/sound/soc/dwc/fh.c
--- linux-3.0.8/sound/soc/dwc/fh.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/sound/soc/dwc/fh.c	2021-07-13 23:40:38.322384067 +0300
@@ -0,0 +1,240 @@
+/*
+ * ASoC driver for Stretch s6105 IP camera platform
+ *
+ * Author:      Daniel Gloeckner, <dg@emlix.com>
+ * Copyright:   (C) 2009 emlix GmbH <info@emlix.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+
+
+
+#include "fullhan-pcm.h"
+#include "fh_i2s.h"
+
+#define S6105_CAM_CODEC_CLOCK 12288000
+
+static int s6105_hw_params(struct snd_pcm_substream *substream,
+			   struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	int ret = 0;
+
+	/* set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+					     SND_SOC_DAIFMT_CBM_CFM);
+	if (ret < 0)
+		return ret;
+	/* set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_CBM_CFM |
+					   SND_SOC_DAIFMT_NB_NF);
+	if (ret < 0)
+		return ret;
+
+	/* set the codec system clock */
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0, S6105_CAM_CODEC_CLOCK,
+					    SND_SOC_CLOCK_OUT);
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+
+static struct snd_soc_ops s6105_ops = {
+	.hw_params = s6105_hw_params,
+};
+
+/* s6105 machine dapm widgets */
+static const struct snd_soc_dapm_widget aic3x_dapm_widgets[] = {
+	SND_SOC_DAPM_LINE("Audio Out Differential", NULL),
+	SND_SOC_DAPM_LINE("Audio Out Stereo", NULL),
+	SND_SOC_DAPM_LINE("Audio In", NULL),
+};
+
+/* s6105 machine audio_mapnections to the codec pins */
+static const struct snd_soc_dapm_route audio_map[] = {
+	/* Audio Out connected to HPLOUT, HPLCOM, HPROUT */
+	{"Audio Out Differential", NULL, "HPLOUT"},
+	{"Audio Out Differential", NULL, "HPLCOM"},
+	{"Audio Out Stereo", NULL, "HPLOUT"},
+	{"Audio Out Stereo", NULL, "HPROUT"},
+
+	/* Audio In connected to LINE1L, LINE1R */
+	{"LINE1L", NULL, "Audio In"},
+	{"LINE1R", NULL, "Audio In"},
+};
+
+static int output_type_info(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 2;
+	if (uinfo->value.enumerated.item) {
+		uinfo->value.enumerated.item = 1;
+		strcpy(uinfo->value.enumerated.name, "HPLOUT/HPROUT");
+	} else {
+		strcpy(uinfo->value.enumerated.name, "HPLOUT/HPLCOM");
+	}
+	return 0;
+}
+
+static int output_type_get(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.enumerated.item[0] = kcontrol->private_value;
+	return 0;
+}
+
+static int output_type_put(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = kcontrol->private_data;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+	unsigned int val = (ucontrol->value.enumerated.item[0] != 0);
+	char *differential = "Audio Out Differential";
+	char *stereo = "Audio Out Stereo";
+
+	if (kcontrol->private_value == val)
+		return 0;
+	kcontrol->private_value = val;
+	snd_soc_dapm_disable_pin(dapm, val ? differential : stereo);
+	snd_soc_dapm_sync(dapm);
+	snd_soc_dapm_enable_pin(dapm, val ? stereo : differential);
+	snd_soc_dapm_sync(dapm);
+
+	return 1;
+}
+
+static const struct snd_kcontrol_new audio_out_mux = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Master Output Mux",
+	.index = 0,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+	.info = output_type_info,
+	.get = output_type_get,
+	.put = output_type_put,
+	.private_value = 1 /* default to stereo */
+};
+
+/* Logic for a aic3x as connected on the s6105 ip camera ref design */
+static int s6105_aic3x_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_codec *codec = rtd->codec;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+
+	/* Add s6105 specific widgets */
+	snd_soc_dapm_new_controls(dapm, aic3x_dapm_widgets,
+				  ARRAY_SIZE(aic3x_dapm_widgets));
+
+	/* Set up s6105 specific audio path audio_map */
+	snd_soc_dapm_add_routes(dapm, audio_map, ARRAY_SIZE(audio_map));
+
+	/* not present */
+	snd_soc_dapm_nc_pin(dapm, "MONO_LOUT");
+	snd_soc_dapm_nc_pin(dapm, "LINE2L");
+	snd_soc_dapm_nc_pin(dapm, "LINE2R");
+
+	/* not connected */
+	snd_soc_dapm_nc_pin(dapm, "MIC3L"); /* LINE2L on this chip */
+	snd_soc_dapm_nc_pin(dapm, "MIC3R"); /* LINE2R on this chip */
+	snd_soc_dapm_nc_pin(dapm, "LLOUT");
+	snd_soc_dapm_nc_pin(dapm, "RLOUT");
+	snd_soc_dapm_nc_pin(dapm, "HPRCOM");
+
+	/* always connected */
+	snd_soc_dapm_enable_pin(dapm, "Audio In");
+
+	/* must correspond to audio_out_mux.private_value initializer */
+	snd_soc_dapm_disable_pin(dapm, "Audio Out Differential");
+	snd_soc_dapm_sync(dapm);
+	snd_soc_dapm_enable_pin(dapm, "Audio Out Stereo");
+
+	snd_soc_dapm_sync(dapm);
+
+	snd_ctl_add(codec->card->snd_card, snd_ctl_new1(&audio_out_mux, codec));
+
+	return 0;
+}
+
+/* s6105 digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link s6105_dai = {
+	.name = "TLV320AIC31",
+	.stream_name = "AIC31",
+	.cpu_dai_name = "s6000-i2s.0",
+	.codec_dai_name = "fh-acodec-hifi",
+	.platform_name = "fh-pcm-audio",
+	.codec_name = "fh-acodec",
+	.init = s6105_aic3x_init,
+	.ops = &s6105_ops,
+};
+
+/* s6105 audio machine driver */
+static struct snd_soc_card snd_soc_card_s6105 = {
+	.name = "Stretch IP Camera",
+	.dai_link = &s6105_dai,
+	.num_links = 1,
+};
+
+static struct s6000_snd_platform_data __initdata s6105_snd_data = {
+	.wide		= 0,
+	.channel_in	= 0,
+	.channel_out	= 1,
+	.lines_in	= 1,
+	.lines_out	= 1,
+	.same_rate	= 1,
+};
+
+static struct platform_device *s6105_snd_device;
+
+/* temporary i2c device creation until this can be moved into the machine
+ * support file.
+*/
+static struct i2c_board_info i2c_device[] = {
+	{ I2C_BOARD_INFO("tlv320aic33", 0x18), }
+};
+
+static int __init s6105_init(void)
+{
+	int ret;
+	i2c_register_board_info(0, i2c_device, ARRAY_SIZE(i2c_device));
+
+	s6105_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!s6105_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(s6105_snd_device, &snd_soc_card_s6105);
+	platform_device_add_data(s6105_snd_device, &s6105_snd_data,
+				 sizeof(s6105_snd_data));
+
+	ret = platform_device_add(s6105_snd_device);
+	if (ret)
+		platform_device_put(s6105_snd_device);
+
+	return ret;
+}
+
+static void __exit s6105_exit(void)
+{
+	platform_device_unregister(s6105_snd_device);
+}
+
+module_init(s6105_init);
+module_exit(s6105_exit);
+
+MODULE_AUTHOR("Daniel Gloeckner");
+MODULE_DESCRIPTION("Stretch s6105 IP camera ASoC driver");
+MODULE_LICENSE("GPL");
diff -uraN linux-3.0.8/sound/soc/dwc/fh_i2s.c linux-3.0.8-fh8632-V1.0_20180330/sound/soc/dwc/fh_i2s.c
--- linux-3.0.8/sound/soc/dwc/fh_i2s.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/sound/soc/dwc/fh_i2s.c	2021-07-13 23:40:38.318384044 +0300
@@ -0,0 +1,1072 @@
+/*
+ * ALSA SoC I2S (McBSP) Audio Layer for TI DAVINCI processor
+ *
+ * Author:      Vladimir Barinov, <vbarinov@embeddedalley.com>
+ * Copyright:   (C) 2007 MontaVista Software, Inc., <source@mvista.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/i2c.h>
+#include <linux/irqreturn.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+#include <linux/kernel.h>
+//#include <mach/asp.h>
+
+#include "fullhan-pcm.h"
+#include "fh_i2s.h"
+
+#define I2S_FIFO_LEN_RX  40
+#define I2S_FIFO_LEN_TX  40
+extern void i2s_irq_enquen(int type, u8 *buff, u8 len,u8 reset);
+/*
+ * NOTE:  terminology here is confusing.
+ *
+ *  - This driver supports the "Audio Serial Port" (ASP),
+ *    found on dm6446, dm355, and other DaVinci chips.
+ *
+ *  - But it labels it a "Multi-channel Buffered Serial Port"
+ *    (McBSP) as on older chips like the dm642 ... which was
+ *    backward-compatible, possibly explaining that confusion.
+ *
+ *  - OMAP chips have a controller called McBSP, which is
+ *    incompatible with the DaVinci flavor of McBSP.
+ *
+ *  - Newer DaVinci chips have a controller called McASP,
+ *    incompatible with ASP and with either McBSP.
+ *
+ * In short:  this uses ASP to implement I2S, not McBSP.
+ * And it won't be the only DaVinci implemention of I2S.
+ */
+#define DAVINCI_MCBSP_DRR_REG	0x00
+#define DAVINCI_MCBSP_DXR_REG	0x04
+#define DAVINCI_MCBSP_SPCR_REG	0x08
+#define DAVINCI_MCBSP_RCR_REG	0x0c
+#define DAVINCI_MCBSP_XCR_REG	0x10
+#define DAVINCI_MCBSP_SRGR_REG	0x14
+#define DAVINCI_MCBSP_PCR_REG	0x24
+
+#define DAVINCI_MCBSP_SPCR_RRST		(1 << 0)
+#define DAVINCI_MCBSP_SPCR_RINTM(v)	((v) << 4)
+#define DAVINCI_MCBSP_SPCR_XRST		(1 << 16)
+#define DAVINCI_MCBSP_SPCR_XINTM(v)	((v) << 20)
+#define DAVINCI_MCBSP_SPCR_GRST		(1 << 22)
+#define DAVINCI_MCBSP_SPCR_FRST		(1 << 23)
+#define DAVINCI_MCBSP_SPCR_FREE		(1 << 25)
+
+#define DAVINCI_MCBSP_RCR_RWDLEN1(v)	((v) << 5)
+#define DAVINCI_MCBSP_RCR_RFRLEN1(v)	((v) << 8)
+#define DAVINCI_MCBSP_RCR_RDATDLY(v)	((v) << 16)
+#define DAVINCI_MCBSP_RCR_RFIG		(1 << 18)
+#define DAVINCI_MCBSP_RCR_RWDLEN2(v)	((v) << 21)
+#define DAVINCI_MCBSP_RCR_RFRLEN2(v)	((v) << 24)
+#define DAVINCI_MCBSP_RCR_RPHASE	BIT(31)
+
+#define DAVINCI_MCBSP_XCR_XWDLEN1(v)	((v) << 5)
+#define DAVINCI_MCBSP_XCR_XFRLEN1(v)	((v) << 8)
+#define DAVINCI_MCBSP_XCR_XDATDLY(v)	((v) << 16)
+#define DAVINCI_MCBSP_XCR_XFIG		(1 << 18)
+#define DAVINCI_MCBSP_XCR_XWDLEN2(v)	((v) << 21)
+#define DAVINCI_MCBSP_XCR_XFRLEN2(v)	((v) << 24)
+#define DAVINCI_MCBSP_XCR_XPHASE	BIT(31)
+
+#define DAVINCI_MCBSP_SRGR_FWID(v)	((v) << 8)
+#define DAVINCI_MCBSP_SRGR_FPER(v)	((v) << 16)
+#define DAVINCI_MCBSP_SRGR_FSGM		(1 << 28)
+#define DAVINCI_MCBSP_SRGR_CLKSM	BIT(29)
+
+#define DAVINCI_MCBSP_PCR_CLKRP		(1 << 0)
+#define DAVINCI_MCBSP_PCR_CLKXP		(1 << 1)
+#define DAVINCI_MCBSP_PCR_FSRP		(1 << 2)
+#define DAVINCI_MCBSP_PCR_FSXP		(1 << 3)
+#define DAVINCI_MCBSP_PCR_SCLKME	(1 << 7)
+#define DAVINCI_MCBSP_PCR_CLKRM		(1 << 8)
+#define DAVINCI_MCBSP_PCR_CLKXM		(1 << 9)
+#define DAVINCI_MCBSP_PCR_FSRM		(1 << 10)
+#define DAVINCI_MCBSP_PCR_FSXM		(1 << 11)
+
+enum {
+	DAVINCI_MCBSP_WORD_8 = 0,
+	DAVINCI_MCBSP_WORD_12,
+	DAVINCI_MCBSP_WORD_16,
+	DAVINCI_MCBSP_WORD_20,
+	DAVINCI_MCBSP_WORD_24,
+	DAVINCI_MCBSP_WORD_32,
+};
+struct my_data{
+	struct work_struct my_work;
+	int value;
+	u8 buff;
+	u8 len;
+	void __iomem *base;
+	};
+struct my_data *rx_md,*tx_md;
+struct work_struct rx_work_queue,tx_work_queue;
+int g_i2s_base;
+//init test data
+struct my_data *init_data(struct my_data *md,struct work_struct  work_queue)
+{
+md = (struct my_data *)kmalloc(sizeof(struct my_data),GFP_KERNEL);
+md->my_work=work_queue;
+return md;
+}
+
+
+static const unsigned char data_type[SNDRV_PCM_FORMAT_S32_LE + 1] = {
+		[SNDRV_PCM_FORMAT_S8] = 1, [SNDRV_PCM_FORMAT_S16_LE] = 2,
+		[SNDRV_PCM_FORMAT_S32_LE] = 4, };
+
+static const unsigned char asp_word_length[SNDRV_PCM_FORMAT_S32_LE + 1] = {
+		[SNDRV_PCM_FORMAT_S8] = DAVINCI_MCBSP_WORD_8, [SNDRV_PCM_FORMAT_S16_LE
+				] = DAVINCI_MCBSP_WORD_16, [SNDRV_PCM_FORMAT_S32_LE
+				] = DAVINCI_MCBSP_WORD_32, };
+
+static const unsigned char double_fmt[SNDRV_PCM_FORMAT_S32_LE + 1] = {
+		[SNDRV_PCM_FORMAT_S8] = SNDRV_PCM_FORMAT_S16_LE,
+		[SNDRV_PCM_FORMAT_S16_LE] = SNDRV_PCM_FORMAT_S32_LE, };
+enum dma_event_q {
+	EVENTQ_0 = 0, EVENTQ_1 = 1, EVENTQ_2 = 2, EVENTQ_3 = 3, EVENTQ_DEFAULT = -1
+};
+struct davinci_pcm_dma_params {
+	int channel; /* sync dma channel ID */
+	unsigned short acnt;
+	dma_addr_t dma_addr; /* device physical address for DMA */
+	unsigned sram_size;
+	enum dma_event_q asp_chan_q; /* event queue number for ASP channel */
+	enum dma_event_q ram_chan_q; /* event queue number for RAM channel */
+	unsigned char data_type; /* xfer data type */
+	unsigned char convert_mono_stereo;
+	unsigned int fifo_level;
+	int (*trigger)(struct snd_pcm_substream *substream, int cmd, int after);
+};
+struct s6000_i2s_dev {
+	dma_addr_t sifbase;
+	u8 __iomem *scbbase;
+	unsigned int wide;
+	unsigned int channel_in;
+	unsigned int channel_out;
+	unsigned int lines_in;
+	unsigned int lines_out;
+	struct s6000_pcm_dma_params dma_params;
+	int irq;
+	void __iomem *base;
+	struct clk *clk;
+	struct device *dev;
+};
+struct davinci_mcbsp_dev {
+	struct device *dev;
+	struct davinci_pcm_dma_params dma_params;
+	void __iomem *base;
+#define MOD_DSP_A	0
+#define MOD_DSP_B	1
+	int mode;
+	u32 pcr;
+	struct clk *clk;
+	/*
+	 * Combining both channels into 1 element will at least double the
+	 * amount of time between servicing the dma channel, increase
+	 * effiency, and reduce the chance of overrun/underrun. But,
+	 * it will result in the left & right channels being swapped.
+	 *
+	 * If relabeling the left and right channels is not possible,
+	 * you may want to let the codec know to swap them back.
+	 *
+	 * It may allow x10 the amount of time to service dma requests,
+	 * if the codec is master and is using an unnecessarily fast bit clock
+	 * (ie. tlvaic23b), independent of the sample rate. So, having an
+	 * entire frame at once means it can be serviced at the sample rate
+	 * instead of the bit clock rate.
+	 *
+	 * In the now unlikely case that an underrun still
+	 * occurs, both the left and right samples will be repeated
+	 * so that no pops are heard, and the left and right channels
+	 * won't end up being swapped because of the underrun.
+	 */
+	unsigned enable_channel_combine :1;
+
+	unsigned int fmt;
+	int clk_div;
+	int clk_input_pin;
+	bool i2s_accurate_sck;
+};
+struct i2c_adapter *codec_i2c_adapter;
+void set_i2c_codec_adapter(struct i2c_adapter * adapter) {
+	codec_i2c_adapter = adapter;
+}
+EXPORT_SYMBOL(set_i2c_codec_adapter);
+
+int i2c_write_codec(u8 addr, u8 data) {
+	int rval;
+	struct i2c_msg msgs[1];
+	u8 send[2];
+	msgs[0].len = 2;
+	msgs[0].addr = 0x1a;
+	msgs[0].flags = 0;
+	msgs[0].buf = send;
+	send[0] = addr;
+	send[1] = data;
+	rval = i2c_transfer(codec_i2c_adapter, msgs, 1);
+	return rval;
+}
+
+static inline void davinci_mcbsp_write_reg(struct davinci_mcbsp_dev *dev,
+		int reg, u32 val) {
+	__raw_writel(val, dev->base + reg);
+}
+
+static inline u32 davinci_mcbsp_read_reg(struct davinci_mcbsp_dev *dev, int reg) {
+	return __raw_readl(dev->base + reg);
+}
+
+static void toggle_clock(struct davinci_mcbsp_dev *dev, int playback) {
+	u32 m = playback ? DAVINCI_MCBSP_PCR_CLKXP : DAVINCI_MCBSP_PCR_CLKRP;
+	/* The clock needs to toggle to complete reset.
+	 * So, fake it by toggling the clk polarity.
+	 */
+	davinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_PCR_REG, dev->pcr ^ m);
+	davinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_PCR_REG, dev->pcr);
+}
+
+static void davinci_mcbsp_start(struct davinci_mcbsp_dev *dev,
+		struct snd_pcm_substream *substream) {
+//	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+//	struct snd_soc_platform *platform = rtd->platform;
+//	int playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);
+//	u32 spcr;
+//	u32 mask = playback ? DAVINCI_MCBSP_SPCR_XRST : DAVINCI_MCBSP_SPCR_RRST;
+//	spcr = davinci_mcbsp_read_reg(dev, DAVINCI_MCBSP_SPCR_REG);
+//	if (spcr & mask) {
+//		/* start off disabled */
+//		davinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_SPCR_REG,
+//				spcr & ~mask);
+//		toggle_clock(dev, playback);
+//	}
+//	if (dev->pcr & (DAVINCI_MCBSP_PCR_FSXM | DAVINCI_MCBSP_PCR_FSRM |
+//			DAVINCI_MCBSP_PCR_CLKXM | DAVINCI_MCBSP_PCR_CLKRM)) {
+//		/* Start the sample generator */
+//		spcr |= DAVINCI_MCBSP_SPCR_GRST;
+//		davinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_SPCR_REG, spcr);
+//	}
+//
+//	if (playback) {
+//		/* Stop the DMA to avoid data loss */
+//		/* while the transmitter is out of reset to handle XSYNCERR */
+//		if (platform->driver->ops->trigger) {
+//			int ret = platform->driver->ops->trigger(substream,
+//				SNDRV_PCM_TRIGGER_STOP);
+//			if (ret < 0)
+//				printk(KERN_DEBUG "Playback DMA stop failed\n");
+//		}
+//
+//		/* Enable the transmitter */
+//		spcr = davinci_mcbsp_read_reg(dev, DAVINCI_MCBSP_SPCR_REG);
+//		spcr |= DAVINCI_MCBSP_SPCR_XRS		SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
+
+//		davinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_SPCR_REG, spcr);
+//
+//		/* wait for any unexpected frame sync error to occur */
+//		udelay(100);
+//
+//		/* Disable the transmitter to clear any outstanding XSYNCERR */
+//		spcr = davinci_mcbsp_read_reg(dev, DAVINCI_MCBSP_SPCR_REG);
+//		spcr &= ~DAVINCI_MCBSP_SPCR_XRST;
+//		davinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_SPCR_REG, spcr);
+//		toggle_clock(dev, playback);
+//
+//		/* Restart the DMA */
+//		if (platform->driver->ops->trigger) {
+//			int ret = platform->driver->ops->trigger(substream,
+//				SNDRV_PCM_TRIGGER_START);2
+//			if (ret < 0)
+//				printk(KERN_DEBUG "Playback DMA start failed\n");
+//		}
+//	}
+//
+//	/* Enable transmitter or receiver */
+//	spcr = davinci_mcbsp_read_reg(dev, DAVINCI_MCBSP_SPCR_REG);
+//	spcr |= mask;
+//
+//	if (dev->pcr & (DAVINCI_MCBSP_PCR_FSXM | DAVINCI_MCBSP_PCR_FSRM)) {
+//		/* Start frame sync */
+//		spcr |= DAVINCI_MCBSP_SPCR_FRST;
+//	}
+//	davinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_SPCR_REG, spcr);
+}
+
+static void davinci_mcbsp_stop(struct davinci_mcbsp_dev *dev, int playback) {
+
+//	u32 spcr;
+//
+//	/* Reset transmitter/receiver and sample rate/frame sync generators */
+//	spcr = davinci_mcbsp_read_reg(dev, DAVINCI_MCBSP_SPCR_REG);
+//	spcr &= ~(DAVINCI_MCBSP_SPCR_GRST | DAVINCI_MCBSP_SPCR_FRST);
+//	spcr &= playback ? ~DAVINCI_MCBSP_SPCR_XRST : ~DAVINCI_MCBSP_SPCR_RRST;
+//	davinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_SPCR_REG, spcr);
+//	toggle_clock(dev, playback);
+}
+
+#define DEFAULT_BITPERSAMPLE	16
+
+static int davinci_i2s_set_dai_fmt(struct snd_soc_dai *cpu_dai,
+		unsigned int fmt) {
+//	struct davinci_mcbsp_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);
+//	unsigned int pcr;
+//	unsigned int srgr;
+//	/* Attention srgr is updated by hw_params! */
+//	srgr = DAVINCI_MCBSP_SRGR_FSGM |
+//		DAVINCI_MCBSP_SRGR_FPER(DEFAULT_BITPERSAMPLE * 2 - 1) |
+//		DAVINCI_MCBSP_SRGR_FWID(DEFAULT_BITPERSAMPLE - 1);
+//
+//	dev->fmt = fmt;
+//	/* set master/slave audio interface */
+//	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+//	case SND_SOC_DAIFMT_CBS_CFS:
+//		/* cpu is master */
+//		pcr = DAVINCI_MCBSP_PCR_FSXM |
+//			DAVINCI_MCBSP_PCR_FSRM |
+//			DAVINCI_MCBSP_PCR_CLKXM |
+//			DAVINCI_MCBSP_PCR_CLKRM;
+//		break;
+//	case SND_SOC_DAIFMT_CBM_CFS:
+//		pcr = DAVINCI_MCBSP_PCR_FSRM | DAVINCI_MCBSP_PCR_FSXM;
+//		/*
+//		 * Selection of the clock input pin that is the
+//		 * input for the Sample Rate Generator.
+//		 * McBSP FSR and FSX are driven by the Sample Rate
+//		 * Generator.
+//		 */
+//		switch (dev->clk_input_pin) {
+//		case MCBSP_CLKS:
+//			pcr |= DAVINCI_MCBSP_PCR_CLKXM |
+//				DAVINCI_MCBSP_PCR_CLKRM;
+//			break;
+//		case MCBSP_CLKR:
+//			pcr |= DAVINCI_MCBSP_PCR_SCLKME;
+//			break;
+//		default:
+//			dev_err(dev->dev, "bad clk_input_pin\n");
+//			return -EINVAL;
+//		}
+//
+//		break;
+//	case SND_SOC_DAIFMT_CBM_CFM:
+//		/* codec is master */
+//		pcr = 0;
+//		break;
+//	default:
+//		printk(KERN_ERR "%s:bad master\n", __func__);
+//		return -EINVAL;
+//	}
+//
+//	/* interface format */
+//	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+//	case SND_SOC_DAIFMT_I2S:
+//		/* Davinci doesn't support TRUE I2S, but some codecs will have
+//		 * the left and right channels contiguous. This allows
+//		 * dsp_a mode to be used with an inverted normal frame clk.
+//		 * If your codec is master and does not have contiguous
+//		 * channels, then you will have sound on only one channel.
+//		 * Try using a different mode, or codec as slave.
+//		 *
+//		 * The TLV320AIC33 is an example of a codec where this works.
+//		 * It has a variable bit clock frequency allowing it to have
+//		 * valid data on every bit clock.
+//		 *
+//		 * The TLV320AIC23 is an example of a codec where this does not
+//		 * work. It has a fixed bit clock frequency with progressively
+//		 * more empty bit clock slots between channels as the sample
+//		 * rate is lowered.
+//		 */
+//		fmt ^= SND_SOC_DAIFMT_NB_IF;
+//	case SND_SOC_DAIFMT_DSP_A:
+//		dev->mode = MOD_DSP_A;
+//		break;
+//	case SND_SOC_DAIFMT_DSP_B:
+//		dev->mode = MOD_DSP_B;
+//		break;
+//	default:
+//		printk(KERN_ERR "%s:bad format\n", __func__);
+//		return -EINVAL;
+//	}
+//
+//	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+//	case SND_SOC_DAIFMT_NB_NF:
+//		/* CLKRP Receive clock polarity,
+//		 *	1 - sampled on rising edge of CLKR
+//		 *	valid on rising edge
+//		 * CLKXP Transmit clock polarity,
+//		 *	1 - clocked on falling edge of CLKX
+//		 *	valid on rising edge
+//		 * FSRP  Receive frame sync pol, 0 - active high
+//		 * FSXP  Transmit frame sync pol, 0 - active high
+//		 */
+//		pcr |= (DAVINCI_MCBSP_PCR_CLKXP | DAVINCI_MCBSP_PCR_CLKRP);
+//		break;
+//	case SND_SOC_DAIFMT_IB_IF:
+//		/* CLKRP Receive clock polarity,
+//		 *	0 - sampled on falling edge of CLKR
+//		 *	valid on falling edge
+//		 * CLKXP Transmit clock polarity,
+//		 *	0 - clocked on rising edge of CLKX
+//		 *	valid on falling edge
+//		 * FSRP  Receive frame sync pol, 1 - active low
+//		 * FSXP  Transmit frame sync pol, 1 - active low
+//		 */
+//		pcr |= (DAVINCI_MCBSP_PCR_FSXP | DAVINCI_MCBSP_PCR_FSRP);
+//		break;
+//	case SND_SOC_DAIFMT_NB_IF:
+//		/* CLKRP Receive clock polarity,
+//		 *	1 - sampled on rising edge of CLKR
+//		 *	valid on rising edge
+//		 * CLKXP Transmit clock polarity,
+//		 *	1 - clocked on falling edge of CLKX
+//		 *	valid on rising edge
+//		 * FSRP  Receive frame sync pol, 1 - active low
+//		 * FSXP  Transmit frame sync pol, 1 - active low
+//		 */
+//		pcr |= (DAVINCI_MCBSP_PCR_CLKXP | DAVINCI_MCBSP_PCR_CLKRP |
+//			DAVINCI_MCBSP_PCR_FSXP | DAVINCI_MCBSP_PCR_FSRP);
+//		break;
+//	case SND_SOC_DAIFMT_IB_NF:
+//		/* CLKRP Receive clock polarity,
+//		 *	0 - sampled on falling edge of CLKR
+//		 *	valid on falling edge
+//		 * CLKXP Transmit clock polarity,
+//		 *	0 - clocked on rising edge of CLKX
+//		 *	valid on falling edge
+//		 * FSRP  Receive frame sync pol, 0 - active high
+//		 * FSXP  Transmit frame sync pol, 0 - active high
+//		 */
+//		break;
+//	default:
+//		return -EINVAL;
+//	}
+//	davinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_SRGR_REG, srgr);
+//	dev->pcr = pcr;
+//	davinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_PCR_REG, pcr);
+	return 0;
+}
+
+static int davinci_i2s_dai_set_clkdiv(struct snd_soc_dai *cpu_dai, int div_id,
+		int div) {
+
+//	struct davinci_mcbsp_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);
+//
+//	if (div_id != DAVINCI_MCBSP_CLKGDV)
+//		return -ENODEV;
+//
+//	dev->clk_div = div;
+	return 0;
+}
+
+static int davinci_i2s_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai) {
+
+
+	struct davinci_mcbsp_dev *dev = snd_soc_dai_get_drvdata(dai);
+	struct davinci_pcm_dma_params *dma_params = &dev->dma_params;
+	struct snd_interval *i = NULL;
+	int mcbsp_word_length, master;
+	unsigned int rcr, xcr, srgr, clk_div, freq, framesize;
+	u32 spcr;
+	snd_pcm_format_t fmt;
+	unsigned element_cnt = 1;
+
+	/* general line settings */
+#if 0
+	spcr = davinci_mcbsp_read_reg(dev, DAVINCI_MCBSP_SPCR_REG);
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		spcr |= DAVINCI_MCBSP_SPCR_RINTM(3) | DAVINCI_MCBSP_SPCR_FREE;
+		davinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_SPCR_REG, spcr);
+	} else {
+		spcr |= DAVINCI_MCBSP_SPCR_XINTM(3) | DAVINCI_MCBSP_SPCR_FREE;
+		davinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_SPCR_REG, spcr);
+	}
+
+	master = dev->fmt & SND_SOC_DAIFMT_MASTER_MASK;
+	fmt = params_format(params);
+	mcbsp_word_length = asp_word_length[fmt];
+
+	switch (master) {
+		case SND_SOC_DAIFMT_CBS_CFS:
+		freq = clk_get_rate(dev->clk);
+		srgr = DAVINCI_MCBSP_SRGR_FSGM |
+		DAVINCI_MCBSP_SRGR_CLKSM;
+		srgr |= DAVINCI_MCBSP_SRGR_FWID(mcbsp_word_length *
+				8 - 1);
+		if (dev->i2s_accurate_sck) {
+			clk_div = 256;
+			do {
+				framesize = (freq / (--clk_div)) /
+				params->rate_num *
+				params->rate_den;
+			}while (((framesize < 33) || (fram		SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
+					SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_JOINT_DUPLEX), .formats =
+					(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE), .rates =
+					(SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_5512 |
+					SNDRV_PCM_RATE_8000_192000), .rate_min = 0, .rate_max = 1562500,
+					.channels_min = 2, .channels_max = 8, .buffer_bytes_max = 0x7ffffff0,
+					.period_bytes_min = 16, .period_bytes_max = 0xfffff0, .periods_min = 2,
+					.periods_max = 1024, /* no limit */
+					.fifo_size = 0, };
+esize > 4095)) &&
+					(clk_div));
+			clk_div--;
+			srgr |= DAVINCI_MCBSP_SRGR_FPER(framesize - 1);
+		} else {
+			/* symmetric waveforms */
+			clk_div = freq / (mcbsp_word_length * 16) /
+			params->rate_num * params->rate_den;
+			srgr |= DAVINCI_MCBSP_SRGR_FPER(mcbsp_word_length *
+					16 - 1);
+		}
+		clk_div &= 0xFF;
+		srgr |= clk_div;
+		break;
+		case SND_SOC_DAIFMT_CBM_CFS:
+		srgr = DAVINCI_MCBSP_SRGR_FSGM;
+		clk_div = dev->clk_div - 1;
+		srgr |= DAVINCI_MCBSP_SRGR_FWID(mcbsp_word_length * 8 - 1);
+		srgr |= DAVINCI_MCBSP_SRGR_FPER(mcbsp_word_length * 16 - 1);
+		clk_div &= 0xFF;
+		srgr |= clk_div;
+		break;
+		case SND_SOC_DAIFMT_CBM_CFM:
+		/* Clock and frame sync given from external sources */
+		i = hw_param_interval(params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS);
+		srgr = DAVINCI_MCBSP_SRGR_FSGM;
+		srgr |= DAVINCI_MCBSP_SRGR_FWID(snd_interval_value(i) - 1);
+		pr_debug("%s - %d  FWID set: re-read srgr = %X\n",
+				__func__, __LINE__, snd_interval_value(i) - 1);
+
+		i = hw_param_interval(params, SNDRV_PCM_HW_PARAM_FRAME_BITS);
+		srgr |= DAVINCI_MCBSP_SRGR_FPER(snd_interval_value(i) - 1);
+		break;
+		default:
+		return -EINVAL;
+	}
+	davinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_SRGR_REG, srgr);
+
+	rcr = DAVINCI_MCBSP_RCR_RFIG;
+	xcr = DAVINCI_MCBSP_XCR_XFIG;
+	if (dev->mode == MOD_DSP_B) {
+		rcr |= DAVINCI_MCBSP_RCR_RDATDLY(0);
+		xcr |= DAVINCI_MCBSP_XCR_XDATDLY(0);
+	} else {
+		rcr |= DAVINCI_MCBSP_RCR_RDATDLY(1);
+		xcr |= DAVINCI_MCBSP_XCR_XDATDLY(1);
+	}
+	/* Determine xfer data type */
+	fmt = params_format(params);
+	if ((fmt > SNDRV_PCM_FORMAT_S32_LE) || !data_type[fmt]) {
+		printk(KERN_WARNING "davinci-i2s: unsupported PCM format\n");
+		return -EINVAL;
+	}
+
+	if (params_channels(params) == 2) {
+		element_cnt = 2;
+		if (double_fmt[fmt] && dev->enad work_func(struct work_struct *work)
+		{
+			printk("%s \n",__FUNCTION__);ble_channel_combine) {
+			element_cnt = 1;
+			fmt = double_fmt[fmt];
+		}
+		switch (master) {
+			case SND_SOC_DAIFMT_CBS_CFS:
+			case SND_SOC_DAIFMT_CBS_CFM:
+			rcr |= DAVINCI_MCBSP_RCR_RFRLEN2(0);
+			xcr |= DAVINCI_MCBSP_XCR_XFRLEN2(0);
+			rcr |= DAVINCI_MCBSP_RCR_RPHASE;
+			xcr |= DAVINCI_MCBSP_XCR_XPHASE;
+			break;
+			case SND_SOC_DAIFMT_CBM_CFM:
+			case SND_SOC_DAIFMT_CBM_CFS:
+			rcr |= DAVINCI_MCBSP_RCR_RFRLEN2(element_cnt - 1);
+			xcr |= DAVINCI_MCBSP_XCR_XFRLEN2(element_cnt - 1);
+			break;
+			default:
+			return -EINVAL;
+		}
+	}
+//	dma_params->acnt = dma_params->data_type = data_type[fmt];
+//	dma_params->fifo_level = 0;
+	mcbsp_word_length = asp_word_length[fmt];
+
+	switch (master) {
+		case SND_SOC_DAIFMT_CBS_CFS:
+		case SND_SOC_DAIFMT_CBS_CFM:
+		rcr |= DAVINCI_MCBSP_RCR_RFRLEN1(0);
+		xcr |= DAVINCI_MCBSP_XCR_XFRLEN1(0);
+		break;
+		case SND_SOC_DAIFMT_CBM_CFM:
+		case SND_SOC_DAIFMT_CBM_CFS:
+		rcr |= DAVINCI_MCBSP_RCR_RFRLEN1(element_cnt - 1);
+		xcr |= DAVINCI_MCBSP_XCR_XFRLEN1(element_cnt - 1);
+		break;
+		default:
+		return -EINVAL;
+	}
+
+	rcr |= DAVINCI_MCBSP_RCR_RWDLEN1(mcbsp_word_length) |
+	DAVINCI_MCBSP_RCR_RWDLEN2(mcbsp_word_length);
+	xcr |= DAVINCI_MCBSP_XCR_XWDLEN1(mcbsp_word_length) |
+	DAVINCI_MCBSP_XCR_XWDLEN2(mcbsp_word_length);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	davinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_XCR_REG, xcr);
+	else
+	davinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_RCR_REG, rcr);
+
+	pr_debug("%s - %d  srgr=%X\n", __func__, __LINE__, srgr);
+	pr_debug("%s - %d  xcr=%X\n", __func__, __LINE__, xcr);
+	pr_debug("%s - %d  rcr=%X\n", __func__, __LINE__, rcr);
+#endif
+
+
+	return 0;
+}
+
+static int davinci_i2s_prepare(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai) {
+
+//	struct davinci_mcbsp_dev *dev = snd_soc_dai_get_drvdata(dai);
+//	int playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);
+//	davinci_mcbsp_stop(dev, playback);
+	return 0;
+}
+static struct {
+	spinlock_t lock;
+	void __iomem *regs;
+	struct clk *clk;
+	unsigned long in_use;
+	unsigned long next_heartbeat;
+	struct timer_list timer;
+	int expect_close;
+} dw_i2s;
+#define	I2S_IOCTL_BASE	'W'
+#define	I2S_GETSUPPORT	_IOR(I2S_IOCTL_BASE, 3, int)
+typedef unsigned short UINT16;
+typedef unsigned int uint32;
+//#define BASEADDR_I2S_REG                    dw_i2s.regs
+#define	OFFSET_I2S_IER                      0x0000
+#define	OFFSET_I2S_IRER                     0x0004
+#define	OFFSET_I2S_ITER                     0x0008
+#define	OFFSET_I2S_CER                      0x000c
+#define	OFFSET_I2S_CCR                      0x0010
+#define	OFFSET_I2S_RXFFR                    0x0014
+#define	OFFSET_I2S_TXFFR                    0x0018
+#define	OFFSET_I2S_LRBR0                    0x0020
+#define	OFFSET_I2S_LRBR1                    0x0060
+#define	OFFSET_I2S_LRBR2                    0x00A0
+#define	OFFSET_I2S_LRBR3                    0x00E0
+#define	OFFSET_I2S_LTHR0                    0x0020
+#define	OFFSET_I2S_LTHR1                    0x0060
+#define	OFFSET_I2S_LTHR2                    0x00A0
+#define OFFSET_I2S_LTHR3                    0x00E0
+#define	OFFSET_I2S_RRBR0                    0x0024
+#define	OFFSET_I2S_RRBR1                    0x0064
+#define	OFFSET_I2S_RRBR2                    0x00A4
+#define	OFFSET_I2S_RRBR3                    0x00E4
+#define	OFFSET_I2S_RTHR0                    0x0024
+#define	OFFSET_I2S_RTHR1                    0x0064
+#define	OFFSET_I2S_RTHR2                    0x00A4
+#define	OFFSET_I2S_RTHR3                    0x00E4
+#define	OFFSET_I2S_RER0                     0x0028
+#define	OFFSET_I2S_RER1                     0x0068
+#define OFFSET_I2S_RER2                     0x00A8
+#define OFFSET_I2S_RER3                     0x00E8
+#define	OFFSET_I2S_TER0                     0x002C
+#define	OFFSET_I2S_TER1                     0x006C
+#define	OFFSET_I2S_TER2                     0x00AC
+#define	OFFSET_I2S_TER3                     0x00EC
+#define	OFFSET_I2S_RCR0                     0x0030
+#define	OFFSET_I2S_RCR1                     0x0070
+#define	OFFSET_I2S_RCR2                     0x00B0
+#define	OFFSET_I2S_RCR3                     0x00F0
+#define	OFFSET_I2S_TCR0                     0x0034
+#define	OFFSET_I2S_TCR1                     0x0074
+#define	OFFSET_I2S_TCR2                     0x00B4
+#define	OFFSET_I2S_TCR3                     0x00F4
+#define	OFFSET_I2S_ISR0                     0x0038
+#define	OFFSET_I2S_ISR1                     0x0078
+#define	OFFSET_I2S_ISR2                     0x00B8
+#define	OFFSET_I2S_ISR3                     0x00F8
+#define	OFFSET_I2S_IMR0                     0x003C
+#define	OFFSET_I2S_IMR1                     0x007C
+#define	OFFSET_I2S_IMR2                     0x00BC
+#define	OFFSET_I2S_IMR3                     0x00FC
+#define	OFFSET_I2S_ROR0                     0x0040
+#define OFFSET_I2S_ROR1                     0x0080
+#define	OFFSET_I2S_ROR2                     0x00C0
+#define	OFFSET_I2S_ROR3                     0x0100
+#define	OFFSET_I2S_TOR0                     0x0044
+#define	OFFSET_I2S_TOR1                     0x0084
+#define	OFFSET_I2S_TOR2                     0x00C4
+#define	OFFSET_I2S_TOR3                     0x0104
+#define	OFFSET_I2S_RFCR0                    0x0048
+#define	OFFSET_I2S_RFCR1                    0x0088
+#define	OFFSET_I2S_RFCR2                    0x00C8
+#define	OFFSET_I2S_RFCR3                    0x0108
+#define OFFSET_I2S_TFCR0                    0x004C
+#define OFFSET_I2S_TFCR1                    0x008C
+#define	OFFSET_I2S_TFCR2                    0x00CC
+#define	OFFSET_I2S_TFCR3                    0x010C
+#define	OFFSET_I2S_RFF0                     0x0050
+#define	OFFSET_I2S_RFF1                     0x0090
+#define	OFFSET_I2S_RFF2                     0x00D4
+#define	OFFSET_I2S_RFF3                     0x0110
+#define	OFFSET_I2S_TFF0                     0x0054
+#define OFFSET_I2S_TFF1                     0x0094
+#define OFFSET_I2S_TFF2                     0x00D4
+#define	OFFSET_I2S_TFF3                     0x0114
+#define	OFFSET_I2S_RXDMA                    0x01C0
+#define	OFFSET_I2S_RRXDMA                   0x01C4
+#define	OFFSET_I2S_TXDMA                    0x01C8
+#define	OFFSET_I2S_RTXDMA                   0x01CC
+#define	OFFSET_I2S_COMP_PARAM_2             0x01f0
+#define	OFFSET_I2S_COMP_PARAM_1             0x01f4
+#define	OFFSET_I2S_COMP_VERSION             0x01f8
+#define	OFFSET_I2S_COMP_TYPE                0x01fc
+#define RESOLUTION12
+#define write_reg(addr,reg)  (*((volatile uint32 *)(addr)))=(uint32)(reg)
+#define read_reg(addr)  (*((volatile uint32 *)(addr)))
+static int dw_i2s_action(void * base,int channel) {
+
+	int data, rx_data_right, rx_data_left,temp;
+	unsigned int i2s_base;
+	i2s_base = base;
+	temp = read_reg(OFFSET_I2S_IMR0 + i2s_base);
+	if (SNDRV_PCM_STREAM_PLAYBACK == channel) {
+		write_reg(OFFSET_I2S_TCR0 + i2s_base, 0x4);
+		write_reg(OFFSET_I2S_TFCR0 + i2s_base, 0x10);
+		write_reg(OFFSET_I2S_ITER + i2s_base, 0x01);
+		write_reg(OFFSET_I2S_TXFFR + i2s_base, 1);
+		temp &=~(1<<4);
+		temp |= (1<<1);
+		temp |= (1<<5);
+		write_reg(OFFSET_I2S_TER0 + i2s_base, 1);
+
+	} else {
+		write_reg(OFFSET_I2S_IRER + i2s_base, 0x01);
+		write_reg(OFFSET_I2S_RCR0 + i2s_base, 0x4);
+		write_reg(OFFSET_I2S_RFCR0 + i2s_base, I2S_FIFO_LEN_RX);
+		write_reg(OFFSET_I2S_RXFFR + i2s_base, 1);
+		temp &=~(1<<0);
+		temp |= (1<<1);
+		temp |= (1<<5);
+		write_reg(OFFSET_I2S_RER0 + i2s_base, 1);
+
+	}
+	write_reg(OFFSET_I2S_IMR0 + i2s_base, temp); //interrupt mask
+}
+
+static void codec_config(void)
+{
+		i2c_write_codec(0x0, 0x44);//set 8K sample
+		i2c_write_codec(0x9, 0x2);
+		i2c_write_codec(0x4, 0x10);
+		i2c_write_codec(0x1, 0x3c);
+		i2c_write_codec(0x5, 0x5);
+		i2c_write_codec(0x7, 0xe6);
+		i2c_write_codec(0x2, 0x14);
+		i2c_write_codec(0x8, 0x38);
+		i2c_write_codec(0xf, 0x1b);
+		i2c_write_codec(0x10, 0x1b);
+}
+
+static int s6000_i2s_start_channel(struct s6000_i2s_dev *dev, int channel) {
+
+	dw_i2s_action(dev->base,channel);
+	return 0;
+}
+static void s6000_i2s_start(struct snd_pcm_substream *substream) {
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct s6000_i2s_dev *dev = snd_soc_dai_get_drvdata(rtd->cpu_dai);
+	s6000_i2s_start_channel(dev, substream->stream);
+
+}
+static int s6000_i2s_stop_channel(struct s6000_i2s_dev *dev, int channel) {
+	int temp,i;
+	temp = read_reg(OFFSET_I2S_IMR0 + dev->base);
+	if (SNDRV_PCM_STREAM_PLAYBACK == channel) {
+		write_reg(OFFSET_I2S_TER0 + dev->base, 0);
+		temp |=(1<<4);
+		temp |= (1<<1);
+		temp |= (1<<5);
+		write_reg(OFFSET_I2S_IMR0 + dev->base,temp); //interrupt mask
+
+
+	} else {
+		write_reg(OFFSET_I2S_RER0 + dev->base, 0);
+		temp |=(1<<0);
+		temp |= (1<<1);
+		temp |= (1<<5);
+		write_reg(OFFSET_I2S_IMR0 + dev->base,temp); //interrupt mask
+
+	}
+	return 0;
+
+}
+static void s6000_i2s_stop(struct snd_pcm_substream *substream) {
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct s6000_i2s_dev *dev = snd_soc_dai_get_drvdata(rtd->cpu_dai);
+	s6000_i2s_stop_channel(dev, substream->stream);
+}
+static int davinci_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
+		int after) {
+	int ret = 0;
+	int playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		s6000_i2s_start(substream);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	//	if (!after)
+			s6000_i2s_stop(substream);
+				break;
+	}
+	return 0;
+}
+
+static int davinci_i2s_startup(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai) {
+//	struct davinci_mcbsp_dev *dev = snd_soc_dai_get_drvdata(dai);
+//
+//	snd_soc_dai_set_dma_data(dai, substream, dev->dma_params);
+	return 0;
+}
+
+static void davinci_i2s_shutdown(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai) {
+//	struct davinci_mcbsp_dev *dev = snd_soc_dai_get_drvdata(dai);
+//	int playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);
+//	davinci_mcbsp_stop(dev, playback);
+}
+
+#define DAVINCI_I2S_RATES	SNDRV_PCM_RATE_8000_96000
+
+static struct snd_soc_dai_ops davinci_i2s_dai_ops = { .startup =
+		davinci_i2s_startup, .shutdown = davinci_i2s_shutdown, .prepare =
+		davinci_i2s_prepare, .trigger = davinci_i2s_trigger, .hw_params =
+		davinci_i2s_hw_params, .set_fmt = davinci_i2s_set_dai_fmt, .set_clkdiv =
+		davinci_i2s_dai_set_clkdiv,
+
+};
+int  s6000_i2s_dai_probe(struct snd_soc_dai *dai) {
+
+	struct s6000_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+	struct s6000_snd_platform_data *pdata = dai->dev->platform_data;
+	dai->capture_dma_data = &dev->dma_params;
+	dai->playback_dma_data = &dev->dma_params;
+	dev->dma_params.trigger = davinci_i2s_trigger;
+//	dev->wide = pdata->wide;
+//	dev->channel_in = pdata->channel_in;
+//	dev->channel_out = pdata->channel_out;
+//	dev->lines_in = pdata->lines_in;
+//	dev->lines_out = pdata->lines_out;
+	dev->dma_params.sif_in = 0xf0901c0;
+	dev->dma_params.sif_out = 0xf0901c8;
+	return 0;
+
+}
+static struct snd_soc_dai_driver davinci_i2s_dai = { .probe =
+		s6000_i2s_dai_probe, .playback = { .channels_min = 2, .channels_max = 2,
+		.rates = DAVINCI_I2S_RATES, .formats = SNDRV_PCM_FMTBIT_S16_LE, },
+		.capture = { .channels_min = 2, .channels_max = 2, .rates =
+				DAVINCI_I2S_RATES, .formats = SNDRV_PCM_FMTBIT_S16_LE, }, .ops =
+				&davinci_i2s_dai_ops,
+
+};
+//work queue funtion
+
+
+ void capture_work_func(struct work_struct *work)
+{
+	uint32 count_data,i,audio_data,temp;
+	uint32 buff[I2S_FIFO_LEN_RX];
+	for(count_data=0;count_data<I2S_FIFO_LEN_RX;count_data++) {
+			audio_data = read_reg(OFFSET_I2S_RRBR0 + g_i2s_base);
+			i = read_reg(OFFSET_I2S_LRBR0 + g_i2s_base);
+			buff[count_data] = audio_data;
+	}
+	i2s_irq_enquen(SNDRV_PCM_STREAM_CAPTURE,(u8 *)buff,count_data<<2,0);
+	temp = read_reg(OFFSET_I2S_IMR0 + g_i2s_base);
+	temp &=~(1<<0);
+	write_reg(OFFSET_I2S_IMR0 + g_i2s_base,temp);
+}
+ void playback_work_func(struct work_struct *work)
+{
+	uint32 count_data,temp;
+	uint32 buff[I2S_FIFO_LEN_TX];
+	i2s_irq_enquen(SNDRV_PCM_STREAM_PLAYBACK,(u8 *)buff,I2S_FIFO_LEN_TX<<2,0);
+	for(count_data=0;count_data<I2S_FIFO_LEN_TX;count_data++) {
+			write_reg(OFFSET_I2S_RTHR0 + g_i2s_base,buff[count_data]);
+			write_reg(OFFSET_I2S_LTHR0 + g_i2s_base,buff[count_data]);
+	}
+	temp = read_reg(OFFSET_I2S_IMR0 + g_i2s_base);
+	temp &=~(1<<4);
+	write_reg(OFFSET_I2S_IMR0 + g_i2s_base,temp);
+}
+
+static irqreturn_t davinci_i2s_irq(int irq, void *data) {
+	uint32 irq_data,temp;
+	struct s6000_i2s_dev *fdev = data;
+	irq_data = read_reg(OFFSET_I2S_ISR0 + fdev->base);
+	temp = read_reg(OFFSET_I2S_IMR0 + fdev->base);
+	if ( (irq_data & 0x10)&&( !(temp&(1<<4))) ) {
+		temp |= (1<<4);
+		write_reg(OFFSET_I2S_IMR0 + fdev->base,temp);
+		schedule_work(&tx_md->my_work);
+		//playback_work_func(&tx_md->my_work);
+	}
+	if ( (irq_data & 0x01)&&( !(temp&(1<<0))) ) {
+		temp|= (1<<0);
+		write_reg(OFFSET_I2S_IMR0 +fdev->base,temp);
+		schedule_work(&rx_md->my_work);
+		//capture_work_func(&rx_md->my_work);
+	}
+		return IRQ_HANDLED;
+	}
+
+static void i2s_config(void)
+{
+	write_reg(OFFSET_I2S_IER + g_i2s_base, 0x01);//i2s   enable
+	write_reg(OFFSET_I2S_CCR + g_i2s_base, 0x8);
+	write_reg(OFFSET_I2S_CER + g_i2s_base, 0x01);
+}
+	static int davinci_i2s_probe(struct platform_device *pdev) {
+		struct snd_platform_data *pdata = pdev->dev.platform_data;
+		struct s6000_i2s_dev *dev;
+		struct resource *mem, *ioarea, *res;
+
+
+		if (!pdata)
+			return -EINVAL;
+
+		int ret;
+
+		rx_md=init_data(rx_md,rx_work_queue);
+		INIT_WORK(&rx_md->my_work,capture_work_func);
+		//rx_wq=create_singlethread_workqueue("capture_workqueue");
+		tx_md = init_data(tx_md,tx_work_queue);
+		INIT_WORK(&tx_md->my_work,playback_work_func);
+		//tx_wq=create_singlethread_workqueue("capture_workqueue");
+		//queue_work(wq,&md->my_work);
+		mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		if (!mem) {
+			printk("i2s platform get resource err\n");
+			dev_err(&pdev->dev, "no mem resource?\n");
+			return -ENODEV;
+		}
+
+		ioarea = request_mem_region(mem->start, resource_size(mem), pdev->name);
+		if (!ioarea) {
+			printk("i2s request mem region err\n");
+			dev_err(&pdev->dev, "McBSP region already claimed\n");
+			return -EBUSY;
+		}
+
+		dev = kzalloc(sizeof(struct s6000_i2s_dev), GFP_KERNEL);
+		if (!dev) {
+			printk("i2s kzalloc err \n");
+			ret = -ENOMEM;
+			goto err_release_region;
+		}
+		dev->irq = platform_get_irq(pdev, 0);
+		int rc;
+		rc = request_irq(dev->irq, davinci_i2s_irq,
+		IRQF_DISABLED, pdev->name, dev);
+		if (rc) {
+			printk("request irq err \n");
+			free_irq(dev->irq, dev);
+		}
+
+		dev->base = ioremap(mem->start, resource_size(mem));
+		g_i2s_base = dev->base;
+		rx_md->base =dev->base;
+		tx_md->base = rx_md->base;
+		if (!dev->base) {
+			dev_err(&pdev->dev, "ioremap failed\n");
+			ret = -ENOMEM;
+			goto err_release_clk;
+		}
+
+		dev->dev = &pdev->dev;
+
+		dev_set_drvdata(&pdev->dev, dev);
+
+		ret = snd_soc_register_dai(&pdev->dev, &davinci_i2s_dai);
+		if (ret != 0)
+			goto err_iounmap;
+
+		codec_config();
+		i2s_config();
+
+		return 0;
+
+		err_iounmap: iounmap(dev->base);
+		err_release_clk: clk_disable(dev->clk);
+		clk_put(dev->clk);
+		err_free_mem: kfree(dev);
+		err_release_region:
+		release_mem_region(mem->start, resource_size(mem));
+
+		return ret;
+	}
+
+	static int davinci_i2s_remove(struct platform_device *pdev) {
+		struct davinci_mcbsp_dev *dev = dev_get_drvdata(&pdev->dev);
+		struct resource *mem;
+
+		snd_soc_unregister_dai(&pdev->dev);
+//	clk_disable(dev->clk);
+//	clk_put(dev->clk);
+//	dev->clk = NULL;
+		kfree(dev);
+		mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		release_mem_region(mem->start, resource_size(mem));
+
+		return 0;
+	}
+
+	static struct platform_driver davinci_mcbsp_driver = {
+			.probe =davinci_i2s_probe,
+			.remove = davinci_i2s_remove,
+			.driver = {
+					.name =
+							"s6000-i2s", .owner = THIS_MODULE,
+			},
+	};
+
+static int __init davinci_i2s_init(void)
+{
+	return platform_driver_register(&davinci_mcbsp_driver);
+}
+	module_init(davinci_i2s_init);
+
+static void __exit davinci_i2s_exit(void)
+{
+	platform_driver_unregister(&davinci_mcbsp_driver);
+}
+	module_exit(davinci_i2s_exit);
+
+	MODULE_AUTHOR("Vladimir Barinov");
+	MODULE_DESCRIPTION("TI DAVINCI I2S (McBSP) SoC Interface");
+	MODULE_LICENSE("GPL");
diff -uraN linux-3.0.8/sound/soc/dwc/fh_i2s_dai.c linux-3.0.8-fh8632-V1.0_20180330/sound/soc/dwc/fh_i2s_dai.c
--- linux-3.0.8/sound/soc/dwc/fh_i2s_dai.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/sound/soc/dwc/fh_i2s_dai.c	2021-07-13 23:40:38.318384044 +0300
@@ -0,0 +1,1003 @@
+/*
+ * ALSA SoC McASP Audio Layer for TI DAVINCI processor
+ *
+ * Multi-channel Audio Serial Port Driver
+ *
+ * Author: Nirmal Pandey <n-pandey@ti.com>,
+ *         Suresh Rajashekara <suresh.r@ti.com>
+ *         Steve Chen <schen@.mvista.com>
+ *
+ * Copyright:   (C) 2009 MontaVista Software, Inc., <source@mvista.com>
+ * Copyright:   (C) 2009  Texas Instruments, India
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include "fullhan-pcm.h"
+#include "fh_i2s_dai.h"
+
+/*
+ * McASP register definitions
+ */
+#define DAVINCI_MCASP_PID_REG		0x00
+#define DAVINCI_MCASP_PWREMUMGT_REG	0x04
+
+#define DAVINCI_MCASP_PFUNC_REG		0x10
+#define DAVINCI_MCASP_PDIR_REG		0x14
+#define DAVINCI_MCASP_PDOUT_REG		0x18
+#define DAVINCI_MCASP_PDSET_REG		0x1c
+
+#define DAVINCI_MCASP_PDCLR_REG		0x20
+
+#define DAVINCI_MCASP_TLGC_REG		0x30
+#define DAVINCI_MCASP_TLMR_REG		0x34
+
+#define DAVINCI_MCASP_GBLCTL_REG	0x44
+#define DAVINCI_MCASP_AMUTE_REG		0x48
+#define DAVINCI_MCASP_LBCTL_REG		0x4c
+
+#define DAVINCI_MCASP_TXDITCTL_REG	0x50
+
+#define DAVINCI_MCASP_GBLCTLR_REG	0x60
+#define DAVINCI_MCASP_RXMASK_REG	0x64
+#define DAVINCI_MCASP_RXFMT_REG		0x68
+#define DAVINCI_MCASP_RXFMCTL_REG	0x6c
+
+#define DAVINCI_MCASP_ACLKRCTL_REG	0x70
+#define DAVINCI_MCASP_AHCLKRCTL_REG	0x74
+#define DAVINCI_MCASP_RXTDM_REG		0x78
+#define DAVINCI_MCASP_EVTCTLR_REG	0x7c
+
+#define DAVINCI_MCASP_RXSTAT_REG	0x80
+#define DAVINCI_MCASP_RXTDMSLOT_REG	0x84
+#define DAVINCI_MCASP_RXCLKCHK_REG	0x88
+#define DAVINCI_MCASP_REVTCTL_REG	0x8c
+
+#define DAVINCI_MCASP_GBLCTLX_REG	0xa0
+#define DAVINCI_MCASP_TXMASK_REG	0xa4
+#define DAVINCI_MCASP_TXFMT_REG		0xa8
+#define DAVINCI_MCASP_TXFMCTL_REG	0xac
+
+#define DAVINCI_MCASP_ACLKXCTL_REG	0xb0
+#define DAVINCI_MCASP_AHCLKXCTL_REG	0xb4
+#define DAVINCI_MCASP_TXTDM_REG		0xb8
+#define DAVINCI_MCASP_EVTCTLX_REG	0xbc
+
+#define DAVINCI_MCASP_TXSTAT_REG	0xc0
+#define DAVINCI_MCASP_TXTDMSLOT_REG	0xc4
+#define DAVINCI_MCASP_TXCLKCHK_REG	0xc8
+#define DAVINCI_MCASP_XEVTCTL_REG	0xcc
+
+/* Left(even TDM Slot) Channel Status Register File */
+#define DAVINCI_MCASP_DITCSRA_REG	0x100
+/* Right(odd TDM slot) Channel Status Register File */
+#define DAVINCI_MCASP_DITCSRB_REG	0x118
+/* Left(even TDM slot) User Data Register File */
+#define DAVINCI_MCASP_DITUDRA_REG	0x130
+/* Right(odd TDM Slot) User Data Register File */
+#define DAVINCI_MCASP_DITUDRB_REG	0x148
+
+/* Serializer n Control Register */
+#define DAVINCI_MCASP_XRSRCTL_BASE_REG	0x180
+#define DAVINCI_MCASP_XRSRCTL_REG(n)	(DAVINCI_MCASP_XRSRCTL_BASE_REG + \
+						(n << 2))
+
+/* Transmit Buffer for Serializer n */
+#define DAVINCI_MCASP_TXBUF_REG		0x200
+/* Receive Buffer for Serializer n */
+#define DAVINCI_MCASP_RXBUF_REG		0x280
+
+/* McASP FIFO Registers */
+#define DAVINCI_MCASP_WFIFOCTL		(0x1010)
+#define DAVINCI_MCASP_WFIFOSTS		(0x1014)
+#define DAVINCI_MCASP_RFIFOCTL		(0x1018)
+#define DAVINCI_MCASP_RFIFOSTS		(0x101C)
+
+/*
+ * DAVINCI_MCASP_PWREMUMGT_REG - Power Down and Emulation Management
+ *     Register Bits
+ */
+#define MCASP_FREE	BIT(0)
+#define MCASP_SOFT	BIT(1)
+
+/*
+ * DAVINCI_MCASP_PFUNC_REG - Pin Function / GPIO Enable Register Bits
+ */
+#define AXR(n)		(1<<n)
+#define PFUNC_AMUTE	BIT(25)
+#define ACLKX		BIT(26)
+#define AHCLKX		BIT(27)
+#define AFSX		BIT(28)
+#define ACLKR		BIT(29)
+#define AHCLKR		BIT(30)
+#define AFSR		BIT(31)
+
+/*
+ * DAVINCI_MCASP_PDIR_REG - Pin Direction Register Bits
+ */
+#define AXR(n)		(1<<n)
+#define PDIR_AMUTE	BIT(25)
+#define ACLKX		BIT(26)
+#define AHCLKX		BIT(27)
+#define AFSX		BIT(28)
+#define ACLKR		BIT(29)
+#define AHCLKR		BIT(30)
+#define AFSR		BIT(31)
+
+/*
+ * DAVINCI_MCASP_TXDITCTL_REG - Transmit DIT Control Register Bits
+ */
+#define DITEN	BIT(0)	/* Transmit DIT mode enable/disable */
+#define VA	BIT(2)
+#define VB	BIT(3)
+
+/*
+ * DAVINCI_MCASP_TXFMT_REG - Transmit Bitstream Format Register Bits
+ */
+#define TXROT(val)	(val)
+#define TXSEL		BIT(3)
+#define TXSSZ(val)	(val<<4)
+#define TXPBIT(val)	(val<<8)
+#define TXPAD(val)	(val<<13)
+#define TXORD		BIT(15)
+#define FSXDLY(val)	(val<<16)
+
+/*
+ * DAVINCI_MCASP_RXFMT_REG - Receive Bitstream Format Register Bits
+ */
+#define RXROT(val)	(val)
+#define RXSEL		BIT(3)
+#define RXSSZ(val)	(val<<4)
+#define RXPBIT(val)	(val<<8)
+#define RXPAD(val)	(val<<13)
+#define RXORD		BIT(15)
+#define FSRDLY(val)	(val<<16)
+
+/*
+ * DAVINCI_MCASP_TXFMCTL_REG -  Transmit Frame Control Register Bits
+ */
+#define FSXPOL		BIT(0)
+#define AFSXE		BIT(1)
+#define FSXDUR		BIT(4)
+#define FSXMOD(val)	(val<<7)
+
+/*
+ * DAVINCI_MCASP_RXFMCTL_REG - Receive Frame Control Register Bits
+ */
+#define FSRPOL		BIT(0)
+#define AFSRE		BIT(1)
+#define FSRDUR		BIT(4)
+#define FSRMOD(val)	(val<<7)
+
+/*
+ * DAVINCI_MCASP_ACLKXCTL_REG - Transmit Clock Control Register Bits
+ */
+#define ACLKXDIV(val)	(val)
+#define ACLKXE		BIT(5)
+#define TX_ASYNC	BIT(6)
+#define ACLKXPOL	BIT(7)
+
+/*
+ * DAVINCI_MCASP_ACLKRCTL_REG Receive Clock Control Register Bits
+ */
+#define ACLKRDIV(val)	(val)
+#define ACLKRE		BIT(5)
+#define RX_ASYNC	BIT(6)
+#define ACLKRPOL	BIT(7)
+
+/*
+ * DAVINCI_MCASP_AHCLKXCTL_REG - High Frequency Transmit Clock Control
+ *     Register Bits
+ */
+#define AHCLKXDIV(val)	(val)
+#define AHCLKXPOL	BIT(14)
+#define AHCLKXE		BIT(15)
+
+/*
+ * DAVINCI_MCASP_AHCLKRCTL_REG - High Frequency Receive Clock Control
+ *     Register Bits
+ */
+#define AHCLKRDIV(val)	(val)
+#define AHCLKRPOL	BIT(14)
+#define AHCLKRE		BIT(15)
+
+/*
+ * DAVINCI_MCASP_XRSRCTL_BASE_REG -  Serializer Control Register Bits
+ */
+#define MODE(val)	(val)
+#define DISMOD		(val)(val<<2)
+#define TXSTATE		BIT(4)
+#define RXSTATE		BIT(5)
+
+/*
+ * DAVINCI_MCASP_LBCTL_REG - Loop Back Control Register Bits
+ */
+#define LBEN		BIT(0)
+#define LBORD		BIT(1)
+#define LBGENMODE(val)	(val<<2)
+
+/*
+ * DAVINCI_MCASP_TXTDMSLOT_REG - Transmit TDM Slot Register configuration
+ */
+#define TXTDMS(n)	(1<<n)
+
+/*
+ * DAVINCI_MCASP_RXTDMSLOT_REG - Receive TDM Slot Register configuration
+ */
+#define RXTDMS(n)	(1<<n)
+
+/*
+ * DAVINCI_MCASP_GBLCTL_REG -  Global Control Register Bits
+ */
+#define RXCLKRST	BIT(0)	/* Receiver Clock Divider Reset */
+#define RXHCLKRST	BIT(1)	/* Receiver High Frequency Clock Divider */
+#define RXSERCLR	BIT(2)	/* Receiver Serializer Clear */
+#define RXSMRST		BIT(3)	/* Receiver State Machine Reset */
+#define RXFSRST		BIT(4)	/* Frame Sync Generator Reset */
+#define TXCLKRST	BIT(8)	/* Transmitter Clock Divider Reset */
+#define TXHCLKRST	BIT(9)	/* Transmitter High Frequency Clock Divider*/
+#define TXSERCLR	BIT(10)	/* Transmit Serializer Clear */
+#define TXSMRST		BIT(11)	/* Transmitter State Machine Reset */
+#define TXFSRST		BIT(12)	/* Frame Sync Generator Reset */
+
+/*
+ * DAVINCI_MCASP_AMUTE_REG -  Mute Control Register Bits
+ */
+#define MUTENA(val)	(val)
+#define MUTEINPOL	BIT(2)
+#define MUTEINENA	BIT(3)
+#define MUTEIN		BIT(4)
+#define MUTER		BIT(5)
+#define MUTEX		BIT(6)
+#define MUTEFSR		BIT(7)
+#define MUTEFSX		BIT(8)
+#define MUTEBADCLKR	BIT(9)
+#define MUTEBADCLKX	BIT(10)
+#define MUTERXDMAERR	BIT(11)
+#define MUTETXDMAERR	BIT(12)
+
+/*
+ * DAVINCI_MCASP_REVTCTL_REG - Receiver DMA Event Control Register bits
+ */
+#define RXDATADMADIS	BIT(0)
+
+/*
+ * DAVINCI_MCASP_XEVTCTL_REG - Transmitter DMA Event Control Register bits
+ */
+#define TXDATADMADIS	BIT(0)
+
+/*
+ * DAVINCI_MCASP_W[R]FIFOCTL - Write/Read FIFO Control Register bits
+ */
+#define FIFO_ENABLE	BIT(16)
+#define NUMEVT_MASK	(0xFF << 8)
+#define NUMDMA_MASK	(0xFF)
+
+#define DAVINCI_MCASP_NUM_SERIALIZER	16
+
+static inline void mcasp_set_bits(void __iomem *reg, u32 val)
+{
+	__raw_writel(__raw_readl(reg) | val, reg);
+}
+
+static inline void mcasp_clr_bits(void __iomem *reg, u32 val)
+{
+	__raw_writel((__raw_readl(reg) & ~(val)), reg);
+}
+
+static inline void mcasp_mod_bits(void __iomem *reg, u32 val, u32 mask)
+{
+	__raw_writel((__raw_readl(reg) & ~mask) | val, reg);
+}
+
+static inline void mcasp_set_reg(void __iomem *reg, u32 val)
+{
+	__raw_writel(val, reg);
+}
+
+static inline u32 mcasp_get_reg(void __iomem *reg)
+{
+	return (unsigned int)__raw_readl(reg);
+}
+
+static inline void mcasp_set_ctl_reg(void __iomem *regs, u32 val)
+{
+//	int i = 0;
+//
+//	mcasp_set_bits(regs, val);
+//
+//	/* programming GBLCTL needs to read back from GBLCTL and verfiy */
+//	/* loop count is to avoid the lock-up */
+//	for (i = 0; i < 1000; i++) {
+//		if ((mcasp_get_reg(regs) & val) == val)
+//			break;
+//	}
+//
+//	if (i == 1000 && ((mcasp_get_reg(regs) & val) != val))
+//		printk(KERN_ERR "GBLCTL write error\n");
+}
+
+static void mcasp_start_rx(struct davinci_audio_dev *dev)
+{
+//	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXHCLKRST);
+//	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXCLKRST);
+//	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXSERCLR);
+//	mcasp_set_reg(dev->base + DAVINCI_MCASP_RXBUF_REG, 0);
+//
+//	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXSMRST);
+//	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXFSRST);
+//	mcasp_set_reg(dev->base + DAVINCI_MCASP_RXBUF_REG, 0);
+//
+//	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXSMRST);
+//	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXFSRST);
+}
+
+static void mcasp_start_tx(struct davinci_audio_dev *dev)
+{
+//	u8 offset = 0, i;
+//	u32 cnt;
+//
+//	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXHCLKRST);
+//	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXCLKRST);
+//	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXSERCLR);
+//	mcasp_set_reg(dev->base + DAVINCI_MCASP_TXBUF_REG, 0);
+//
+//	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXSMRST);
+//	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXFSRST);
+//	mcasp_set_reg(dev->base + DAVINCI_MCASP_TXBUF_REG, 0);
+//	for (i = 0; i < dev->num_serializer; i++) {
+//		if (dev->serial_dir[i] == TX_MODE) {
+//			offset = i;
+//			break;
+//		}
+//	}
+//
+//	/* wait for TX ready */
+//	cnt = 0;
+//	while (!(mcasp_get_reg(dev->base + DAVINCI_MCASP_XRSRCTL_REG(offset)) &
+//		 TXSTATE) && (cnt < 100000))
+//		cnt++;
+//
+//	mcasp_set_reg(dev->base + DAVINCI_MCASP_TXBUF_REG, 0);
+}
+
+static void davinci_mcasp_start(struct davinci_audio_dev *dev, int stream)
+{
+//	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+//		if (dev->txnumevt)	/* enable FIFO */
+//			mcasp_set_bits(dev->base + DAVINCI_MCASP_WFIFOCTL,
+//								FIFO_ENABLE);
+//		mcasp_start_tx(dev);
+//	} else {
+//		if (dev->rxnumevt)	/* enable FIFO */
+//			mcasp_set_bits(dev->base + DAVINCI_MCASP_RFIFOCTL,
+//								FIFO_ENABLE);
+//		mcasp_start_rx(dev);
+//	}
+}
+
+static void mcasp_stop_rx(struct davinci_audio_dev *dev)
+{
+//	mcasp_set_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, 0);
+//	mcasp_set_reg(dev->base + DAVINCI_MCASP_RXSTAT_REG, 0xFFFFFFFF);
+}
+
+static void mcasp_stop_tx(struct davinci_audio_dev *dev)
+{
+//	mcasp_set_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, 0);
+//	mcasp_set_reg(dev->base + DAVINCI_MCASP_TXSTAT_REG, 0xFFFFFFFF);
+}
+
+static void davinci_mcasp_stop(struct davinci_audio_dev *dev, int stream)
+{
+//	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+//		if (dev->txnumevt)	/* disable FIFO */
+//			mcasp_clr_bits(dev->base + DAVINCI_MCASP_WFIFOCTL,
+//								FIFO_ENABLE);
+//		mcasp_stop_tx(dev);
+//	} else {
+//		if (dev->rxnumevt)	/* disable FIFO */
+//			mcasp_clr_bits(dev->base + DAVINCI_MCASP_RFIFOCTL,
+//								FIFO_ENABLE);
+//		mcasp_stop_rx(dev);
+//	}
+}
+
+static int davinci_mcasp_set_dai_fmt(struct snd_soc_dai *cpu_dai,
+					 unsigned int fmt)
+{
+//	struct davinci_audio_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);
+//	void __iomem *base = dev->base;
+//
+//	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+//	case SND_SOC_DAIFMT_CBS_CFS:
+//		/* codec is clock and frame slave */
+//		mcasp_set_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXE);
+//		mcasp_set_bits(base + DAVINCI_MCASP_TXFMCTL_REG, AFSXE);
+//
+//		mcasp_set_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRE);
+//		mcasp_set_bits(base + DAVINCI_MCASP_RXFMCTL_REG, AFSRE);
+//
+//		mcasp_set_bits(base + DAVINCI_MCASP_PDIR_REG,
+//				ACLKX | AHCLKX | AFSX);
+//		break;
+//	case SND_SOC_DAIFMT_CBM_CFS:
+//		/* codec is clock master and frame slave */
+//		mcasp_clr_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXE);
+//		mcasp_set_bits(base + DAVINCI_MCASP_TXFMCTL_REG, AFSXE);
+//
+//		mcasp_clr_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRE);
+//		mcasp_set_bits(base + DAVINCI_MCASP_RXFMCTL_REG, AFSRE);
+//
+//		mcasp_clr_bits(base + DAVINCI_MCASP_PDIR_REG,
+//				ACLKX | ACLKR);
+//		mcasp_set_bits(base + DAVINCI_MCASP_PDIR_REG,
+//				AFSX | AFSR);
+//		break;
+//	case SND_SOC_DAIFMT_CBM_CFM:
+//		/* codec is clock and frame master */
+//		mcasp_clr_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXE);
+//		mcasp_clr_bits(base + DAVINCI_MCASP_TXFMCTL_REG, AFSXE);
+//
+//		mcasp_clr_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRE);
+//		mcasp_clr_bits(base + DAVINCI_MCASP_RXFMCTL_REG, AFSRE);
+//
+//		mcasp_clr_bits(base + DAVINCI_MCASP_PDIR_REG,
+//				ACLKX | AHCLKX | AFSX | ACLKR | AHCLKR | AFSR);
+//		break;
+//
+//	default:
+//		return -EINVAL;
+//	}
+//
+//	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+//	case SND_SOC_DAIFMT_IB_NF:
+//		mcasp_clr_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXPOL);
+//		mcasp_clr_bits(base + DAVINCI_MCASP_TXFMCTL_REG, FSXPOL);
+//
+//		mcasp_set_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);
+//		mcasp_clr_bits(base + DAVINCI_MCASP_RXFMCTL_REG, FSRPOL);
+//		break;
+//
+//	case SND_SOC_DAIFMT_NB_IF:
+//		mcasp_set_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXPOL);
+//		mcasp_set_bits(base + DAVINCI_MCASP_TXFMCTL_REG, FSXPOL);
+//
+//		mcasp_clr_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);
+//		mcasp_set_bits(base + DAVINCI_MCASP_RXFMCTL_REG, FSRPOL);
+//		break;
+//
+//	case SND_SOC_DAIFMT_IB_IF:
+//		mcasp_clr_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXPOL);
+//		mcasp_set_bits(base + DAVINCI_MCASP_TXFMCTL_REG, FSXPOL);
+//
+//		mcasp_set_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);
+//		mcasp_set_bits(base + DAVINCI_MCASP_RXFMCTL_REG, FSRPOL);
+//		break;
+//
+//	case SND_SOC_DAIFMT_NB_NF:
+//		mcasp_set_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXPOL);
+//		mcasp_clr_bits(base + DAVINCI_MCASP_TXFMCTL_REG, FSXPOL);
+//
+//		mcasp_clr_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);
+//		mcasp_clr_bits(base + DAVINCI_MCASP_RXFMCTL_REG, FSRPOL);
+//		break;
+//
+//	default:
+//		return -EINVAL;
+//	}
+
+	return 0;
+}
+
+static int davinci_config_channel_size(struct davinci_audio_dev *dev,
+				       int channel_size)
+{
+//	u32 fmt = 0;
+//	u32 mask, rotate;
+//
+//	switch (channel_size) {
+//	case DAVINCI_AUDIO_WORD_8:
+//		fmt = 0x03;
+//		rotate = 6;
+//		mask = 0x000000ff;
+//		break;
+//
+//	case DAVINCI_AUDIO_WORD_12:
+//		fmt = 0x05;
+//		rotate = 5;
+//		mask = 0x00000fff;
+//		break;
+//
+//	case DAVINCI_AUDIO_WORD_16:
+//		fmt = 0x07;
+//		rotate = 4;
+//		mask = 0x0000ffff;
+//		break;
+//
+//	case DAVINCI_AUDIO_WORD_20:
+//		fmt = 0x09;
+//		rotate = 3;
+//		mask = 0x000fffff;
+//		break;
+//
+//	case DAVINCI_AUDIO_WORD_24:
+//		fmt = 0x0B;
+//		rotate = 2;
+//		mask = 0x00ffffff;
+//		break;
+//
+//	case DAVINCI_AUDIO_WORD_28:
+//		fmt = 0x0D;
+//		rotate = 1;
+//		mask = 0x0fffffff;
+//		break;
+//
+//	case DAVINCI_AUDIO_WORD_32:
+//		fmt = 0x0F;
+//		rotate = 0;
+//		mask = 0xffffffff;
+//		break;
+//
+//	default:
+//		return -EINVAL;
+//	}
+//
+//	mcasp_mod_bits(dev->base + DAVINCI_MCASP_RXFMT_REG,
+//					RXSSZ(fmt), RXSSZ(0x0F));
+//	mcasp_mod_bits(dev->base + DAVINCI_MCASP_TXFMT_REG,
+//					TXSSZ(fmt), TXSSZ(0x0F));
+//	mcasp_mod_bits(dev->base + DAVINCI_MCASP_TXFMT_REG, TXROT(rotate),
+//							TXROT(7));
+//	mcasp_mod_bits(dev->base + DAVINCI_MCASP_RXFMT_REG, RXROT(rotate),
+//							RXROT(7));
+//	mcasp_set_reg(dev->base + DAVINCI_MCASP_TXMASK_REG, mask);
+//	mcasp_set_reg(dev->base + DAVINCI_MCASP_RXMASK_REG, mask);
+//
+//	return 0;
+}
+
+static void davinci_hw_common_param(struct davinci_audio_dev *dev, int stream)
+{
+//	int i;
+//	u8 tx_ser = 0;
+//	u8 rx_ser = 0;
+//
+//	/* Default configuration */
+//	mcasp_set_bits(dev->base + DAVINCI_MCASP_PWREMUMGT_REG, MCASP_SOFT);
+//
+//	/* All PINS as McASP */
+//	mcasp_set_reg(dev->base + DAVINCI_MCASP_PFUNC_REG, 0x00000000);
+//
+//	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+//		mcasp_set_reg(dev->base + DAVINCI_MCASP_TXSTAT_REG, 0xFFFFFFFF);
+//		mcasp_clr_bits(dev->base + DAVINCI_MCASP_XEVTCTL_REG,
+//				TXDATADMADIS);
+//	} else {
+//		mcasp_set_reg(dev->base + DAVINCI_MCASP_RXSTAT_REG, 0xFFFFFFFF);
+//		mcasp_clr_bits(dev->base + DAVINCI_MCASP_REVTCTL_REG,
+//				RXDATADMADIS);
+//	}
+//
+//	for (i = 0; i < dev->num_serializer; i++) {
+//		mcasp_set_bits(dev->base + DAVINCI_MCASP_XRSRCTL_REG(i),
+//					dev->serial_dir[i]);
+//		if (dev->serial_dir[i] == TX_MODE) {
+//			mcasp_set_bits(dev->base + DAVINCI_MCASP_PDIR_REG,
+//					AXR(i));
+//			tx_ser++;
+//		} else if (dev->serial_dir[i] == RX_MODE) {
+//			mcasp_clr_bits(dev->base + DAVINCI_MCASP_PDIR_REG,
+//					AXR(i));
+//			rx_ser++;
+//		}
+//	}
+//
+//	if (dev->txnumevt && stream == SNDRV_PCM_STREAM_PLAYBACK) {
+//		if (dev->txnumevt * tx_ser > 64)
+//			dev->txnumevt = 1;
+//
+//		mcasp_mod_bits(dev->base + DAVINCI_MCASP_WFIFOCTL, tx_ser,
+//								NUMDMA_MASK);
+//		mcasp_mod_bits(dev->base + DAVINCI_MCASP_WFIFOCTL,
+//				((dev->txnumevt * tx_ser) << 8), NUMEVT_MASK);
+//	}
+//
+//	if (dev->rxnumevt && stream == SNDRV_PCM_STREAM_CAPTURE) {
+//		if (dev->rxnumevt * rx_ser > 64)
+//			dev->rxnumevt = 1;
+//
+//		mcasp_mod_bits(dev->base + DAVINCI_MCASP_RFIFOCTL, rx_ser,
+//								NUMDMA_MASK);
+//		mcasp_mod_bits(dev->base + DAVINCI_MCASP_RFIFOCTL,
+//				((dev->rxnumevt * rx_ser) << 8), NUMEVT_MASK);
+//	}
+}
+
+static void davinci_hw_param(struct davinci_audio_dev *dev, int stream)
+{
+//	int i, active_slots;
+//	u32 mask = 0;
+//
+//	active_slots = (dev->tdm_slots > 31) ? 32 : dev->tdm_slots;
+//	for (i = 0; i < active_slots; i++)
+//		mask |= (1 << i);
+//
+//	mcasp_clr_bits(dev->base + DAVINCI_MCASP_ACLKXCTL_REG, TX_ASYNC);
+//
+//	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+//		/* bit stream is MSB first  with no delay */
+//		/* DSP_B mode */
+//		mcasp_set_bits(dev->base + DAVINCI_MCASP_AHCLKXCTL_REG,
+//				AHCLKXE);
+//		mcasp_set_reg(dev->base + DAVINCI_MCASP_TXTDM_REG, mask);
+//		mcasp_set_bits(dev->base + DAVINCI_MCASP_TXFMT_REG, TXORD);
+//
+//		if ((dev->tdm_slots >= 2) && (dev->tdm_slots <= 32))
+//			mcasp_mod_bits(dev->base + DAVINCI_MCASP_TXFMCTL_REG,
+//					FSXMOD(dev->tdm_slots), FSXMOD(0x1FF));
+//		else
+//			printk(KERN_ERR "playback tdm slot %d not supported\n",
+//				dev->tdm_slots);
+//
+//		mcasp_clr_bits(dev->base + DAVINCI_MCASP_TXFMCTL_REG, FSXDUR);
+//	} else {
+//		/* bit stream is MSB first with no delay */
+//		/* DSP_B mode */
+//		mcasp_set_bits(dev->base + DAVINCI_MCASP_RXFMT_REG, RXORD);
+//		mcasp_set_bits(dev->base + DAVINCI_MCASP_AHCLKRCTL_REG,
+//				AHCLKRE);
+//		mcasp_set_reg(dev->base + DAVINCI_MCASP_RXTDM_REG, mask);
+//
+//		if ((dev->tdm_slots >= 2) && (dev->tdm_slots <= 32))
+//			mcasp_mod_bits(dev->base + DAVINCI_MCASP_RXFMCTL_REG,
+//					FSRMOD(dev->tdm_slots), FSRMOD(0x1FF));
+//		else
+//			printk(KERN_ERR "capture tdm slot %d not supported\n",
+//				dev->tdm_slots);
+//
+//		mcasp_clr_bits(dev->base + DAVINCI_MCASP_RXFMCTL_REG, FSRDUR);
+//	}
+}
+
+/* S/PDIF */
+static void davinci_hw_dit_param(struct davinci_audio_dev *dev)
+{
+//	/* Set the PDIR for Serialiser as output */
+//	mcasp_set_bits(dev->base + DAVINCI_MCASP_PDIR_REG, AFSX);
+//
+//	/* TXMASK for 24 bits */
+//	mcasp_set_reg(dev->base + DAVINCI_MCASP_TXMASK_REG, 0x00FFFFFF);
+//
+//	/* Set the TX format : 24 bit right rotation, 32 bit slot, Pad 0
+//	   and LSB first */
+//	mcasp_set_bits(dev->base + DAVINCI_MCASP_TXFMT_REG,
+//						TXROT(6) | TXSSZ(15));
+//
+//	/* Set TX frame synch : DIT Mode, 1 bit width, internal, rising edge */
+//	mcasp_set_reg(dev->base + DAVINCI_MCASP_TXFMCTL_REG,
+//						AFSXE | FSXMOD(0x180));
+//
+//	/* Set the TX tdm : for all the slots */
+//	mcasp_set_reg(dev->base + DAVINCI_MCASP_TXTDM_REG, 0xFFFFFFFF);
+//
+//	/* Set the TX clock controls : div = 1 and internal */
+//	mcasp_set_bits(dev->base + DAVINCI_MCASP_ACLKXCTL_REG,
+//						ACLKXE | TX_ASYNC);
+//
+//	mcasp_clr_bits(dev->base + DAVINCI_MCASP_XEVTCTL_REG, TXDATADMADIS);
+//
+//	/* Only 44100 and 48000 are valid, both have the same setting */
+//	mcasp_set_bits(dev->base + DAVINCI_MCASP_AHCLKXCTL_REG, AHCLKXDIV(3));
+//
+//	/* Enable the DIT */
+//	mcasp_set_bits(dev->base + DAVINCI_MCASP_TXDITCTL_REG, DITEN);
+}
+
+static int davinci_mcasp_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params,
+					struct snd_soc_dai *cpu_dai)
+{
+//	struct davinci_audio_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);
+//	struct davinci_pcm_dma_params *dma_params =
+//					&dev->dma_params[substream->stream];
+//	int word_length;
+//	u8 fifo_level;
+//
+//	davinci_hw_common_param(dev, substream->stream);
+//	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+//		fifo_level = dev->txnumevt;
+//	else
+//		fifo_level = dev->rxnumevt;
+//
+//	if (dev->op_mode == DAVINCI_MCASP_DIT_MODE)
+//		davinci_hw_dit_param(dev);
+//	else
+//		davinci_hw_param(dev, substream->stream);
+//
+//	switch (params_format(params)) {
+//	case SNDRV_PCM_FORMAT_S8:
+//		dma_params->data_type = 1;
+//		word_length = DAVINCI_AUDIO_WORD_8;
+//		break;
+//
+//	case SNDRV_PCM_FORMAT_S16_LE:
+//		dma_params->data_type = 2;
+//		word_length = DAVINCI_AUDIO_WORD_16;
+//		break;
+//
+//	case SNDRV_PCM_FORMAT_S32_LE:
+//		dma_params->data_type = 4;
+//		word_length = DAVINCI_AUDIO_WORD_32;
+//		break;
+//
+//	default:
+//		printk(KERN_WARNING "davinci-mcasp: unsupported PCM format");
+//		return -EINVAL;
+//	}
+//
+//	if (dev->version == MCASP_VERSION_2 && !fifo_level)
+//		dma_params->acnt = 4;
+//	else
+//		dma_params->acnt = dma_params->data_type;
+//
+//	dma_params->fifo_level = fifo_level;
+//	davinci_config_channel_size(dev, word_length);
+
+	return 0;
+}
+
+static int davinci_mcasp_trigger(struct snd_pcm_substream *substream,
+				     int cmd, struct snd_soc_dai *cpu_dai)
+{
+	struct davinci_audio_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (!dev->clk_active) {
+			clk_enable(dev->clk);
+			dev->clk_active = 1;
+		}
+		davinci_mcasp_start(dev, substream->stream);
+		break;
+
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		davinci_mcasp_stop(dev, substream->stream);
+		if (dev->clk_active) {
+			clk_disable(dev->clk);
+			dev->clk_active = 0;
+		}
+
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		davinci_mcasp_stop(dev, substream->stream);
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int davinci_mcasp_startup(struct snd_pcm_substream *substream,
+				 struct snd_soc_dai *dai)
+{
+	struct davinci_audio_dev *dev = snd_soc_dai_get_drvdata(dai);
+
+	//snd_soc_dai_set_dma_data(dai, substream, dev->dma_params);
+	return 0;
+}
+
+static struct snd_soc_dai_ops davinci_mcasp_dai_ops = {
+	.startup	= davinci_mcasp_startup,
+	.trigger	= davinci_mcasp_trigger,
+	.hw_params	= davinci_mcasp_hw_params,
+	.set_fmt	= davinci_mcasp_set_dai_fmt,
+
+};
+
+static struct snd_soc_dai_driver davinci_mcasp_dai[] = {
+	{
+		.name		= "davinci-mcasp.0",
+		.playback	= {
+			.channels_min	= 2,
+			.channels_max 	= 2,
+			.rates 		= DAVINCI_MCASP_RATES,
+			.formats 	= SNDRV_PCM_FMTBIT_S8 |
+						SNDRV_PCM_FMTBIT_S16_LE |
+						SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.capture 	= {
+			.channels_min 	= 2,
+			.channels_max 	= 2,
+			.rates 		= DAVINCI_MCASP_RATES,
+			.formats	= SNDRV_PCM_FMTBIT_S8 |
+						SNDRV_PCM_FMTBIT_S16_LE |
+						SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.ops 		= &davinci_mcasp_dai_ops,
+
+	},
+	{
+		"davinci-mcasp.1",
+		.playback 	= {
+			.channels_min	= 1,
+			.channels_max	= 384,
+			.rates		= DAVINCI_MCASP_RATES,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE,
+		},
+		.ops 		= &davinci_mcasp_dai_ops,
+	},
+
+};
+
+static int davinci_mcasp_probe(struct platform_device *pdev)
+{
+	struct davinci_pcm_dma_params *dma_data;
+	struct resource *mem, *ioarea, *res;
+	struct snd_platform_data *pdata;
+	struct davinci_audio_dev *dev;
+	int ret = 0;
+
+	dev = kzalloc(sizeof(struct davinci_audio_dev), GFP_KERNEL);
+	if (!dev)
+		return	-ENOMEM;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem) {
+		dev_err(&pdev->dev, "no mem resource?\n");
+		ret = -ENODEV;
+		goto err_release_data;
+	}
+
+	ioarea = request_mem_region(mem->start,
+			resource_size(mem), pdev->name);
+	if (!ioarea) {
+		dev_err(&pdev->dev, "Audio region already claimed\n");
+		ret = -EBUSY;
+		goto err_release_data;
+	}
+
+	pdata = pdev->dev.platform_data;
+	dev->clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(dev->clk)) {
+		ret = -ENODEV;
+		goto err_release_region;
+	}
+
+	clk_enable(dev->clk);
+	dev->clk_active = 1;
+
+	dev->base = ioremap(mem->start, resource_size(mem));
+	if (!dev->base) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		ret = -ENOMEM;
+		goto err_release_clk;
+	}
+
+//	dev->op_mode = pdata->op_mode;
+//	dev->tdm_slots = pdata->tdm_slots;
+//	dev->num_serializer = pdata->num_serializer;
+//	dev->serial_dir = pdata->serial_dir;
+//	dev->codec_fmt = pdata->codec_fmt;
+//	dev->version = pdata->version;
+//	dev->txnumevt = pdata->txnumevt;
+//	dev->rxnumevt = pdata->rxnumevt;
+
+//	dma_data = &dev->dma_params[SNDRV_PCM_STREAM_PLAYBACK];
+//	dma_data->asp_chan_q = pdata->asp_chan_q;
+//	dma_data->ram_chan_q = pdata->ram_chan_q;
+//	dma_data->sram_size = pdata->sram_size_playback;
+//	dma_data->dma_addr = (dma_addr_t) (pdata->tx_dma_offset +
+//							mem->start);
+
+	/* first TX, then RX */
+//	res = platform_get_resource(pdev, IORESOURCE_DMA, 0);
+//	if (!res) {
+//		dev_err(&pdev->dev, "no DMA resource\n");
+//		ret = -ENODEV;
+//		goto err_iounmap;
+//	}
+
+//	dma_data->channel = res->start;
+//
+//	dma_data = &dev->dma_params[SNDRV_PCM_STREAM_CAPTURE];
+//	dma_data->asp_chan_q = pdata->asp_chan_q;
+//	dma_data->ram_chan_q = pdata->ram_chan_q;
+//	dma_data->sram_size = pdata->sram_size_capture;
+//	dma_data->dma_addr = (dma_addr_t)(pdata->rx_dma_offset +
+//							mem->start);
+
+//	res = platform_get_resource(pdev, IORESOURCE_DMA, 1);
+//	if (!res) {
+//		dev_err(&pdev->dev, "no DMA resource\n");
+//		ret = -ENODEV;
+//		goto err_iounmap;
+//	}
+
+//	dma_data->channel = res->start;
+	dev_set_drvdata(&pdev->dev, dev);
+	ret = snd_soc_register_dai(&pdev->dev, &davinci_mcasp_dai[0]);
+
+	if (ret != 0)
+		goto err_iounmap;
+	return 0;
+
+err_iounmap:
+	iounmap(dev->base);
+err_release_clk:
+	clk_disable(dev->clk);
+	clk_put(dev->clk);
+err_release_region:
+	release_mem_region(mem->start, resource_size(mem));
+err_release_data:
+	kfree(dev);
+
+	return ret;
+}
+
+static int davinci_mcasp_remove(struct platform_device *pdev)
+{
+	struct davinci_audio_dev *dev = dev_get_drvdata(&pdev->dev);
+	struct resource *mem;
+
+	snd_soc_unregister_dai(&pdev->dev);
+	clk_disable(dev->clk);
+	clk_put(dev->clk);
+	dev->clk = NULL;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(mem->start, resource_size(mem));
+
+	kfree(dev);
+
+	return 0;
+}
+
+static struct platform_driver davinci_mcasp_driver = {
+	.probe		= davinci_mcasp_probe,
+	.remove		= davinci_mcasp_remove,
+	.driver		= {
+		.name	= "davinci-mcasp",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init davinci_mcasp_init(void)
+{
+	return platform_driver_register(&davinci_mcasp_driver);
+}
+module_init(davinci_mcasp_init);
+
+static void __exit davinci_mcasp_exit(void)
+{
+	platform_driver_unregister(&davinci_mcasp_driver);
+}
+module_exit(davinci_mcasp_exit);
+
+MODULE_AUTHOR("Steve Chen");
+MODULE_DESCRIPTION("TI DAVINCI McASP SoC Interface");
+MODULE_LICENSE("GPL");
+
diff -uraN linux-3.0.8/sound/soc/dwc/fh_i2s_dai.h linux-3.0.8-fh8632-V1.0_20180330/sound/soc/dwc/fh_i2s_dai.h
--- linux-3.0.8/sound/soc/dwc/fh_i2s_dai.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/sound/soc/dwc/fh_i2s_dai.h	2021-07-13 23:40:38.318384044 +0300
@@ -0,0 +1,59 @@
+/*
+ * ALSA SoC McASP Audio Layer for TI DAVINCI processor
+ *
+ * MCASP related definitions
+ *
+ * Author: Nirmal Pandey <n-pandey@ti.com>,
+ *         Suresh Rajashekara <suresh.r@ti.com>
+ *         Steve Chen <schen@.mvista.com>
+ *
+ * Copyright:   (C) 2009 MontaVista Software, Inc., <source@mvista.com>
+ * Copyright:   (C) 2009  Texas Instruments, India
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef DAVINCI_MCASP_H
+#define DAVINCI_MCASP_H
+
+#include <linux/io.h>
+//#include <mach/asp.h>
+#include "fullhan-pcm.h"
+
+#define DAVINCI_MCASP_RATES	SNDRV_PCM_RATE_8000_96000
+#define DAVINCI_MCASP_I2S_DAI	0
+#define DAVINCI_MCASP_DIT_DAI	1
+
+enum {
+	DAVINCI_AUDIO_WORD_8 = 0,
+	DAVINCI_AUDIO_WORD_12,
+	DAVINCI_AUDIO_WORD_16,
+	DAVINCI_AUDIO_WORD_20,
+	DAVINCI_AUDIO_WORD_24,
+	DAVINCI_AUDIO_WORD_32,
+	DAVINCI_AUDIO_WORD_28,  /* This is only valid for McASP */
+};
+
+struct davinci_audio_dev {
+	//struct davinci_pcm_dma_params dma_params[2];
+	void __iomem *base;
+	int sample_rate;
+	struct clk *clk;
+	unsigned int codec_fmt;
+	u8 clk_active;
+
+	/* McASP specific data */
+	int	tdm_slots;
+	u8	op_mode;
+	u8	num_serializer;
+	u8	*serial_dir;
+	u8	version;
+
+	/* McASP FIFO related */
+	u8	txnumevt;
+	u8	rxnumevt;
+};
+
+#endif	/* DAVINCI_MCASP_H */
diff -uraN linux-3.0.8/sound/soc/dwc/fh_i2s.h linux-3.0.8-fh8632-V1.0_20180330/sound/soc/dwc/fh_i2s.h
--- linux-3.0.8/sound/soc/dwc/fh_i2s.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/sound/soc/dwc/fh_i2s.h	2021-07-13 23:40:38.318384044 +0300
@@ -0,0 +1,23 @@
+/*
+ * ALSA SoC I2S Audio Layer for the Stretch s6000 family
+ *
+ * Author:      Daniel Gloeckner, <dg@emlix.com>
+ * Copyright:   (C) 2009 emlix GmbH <info@emlix.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _S6000_I2S_H
+#define _S6000_I2S_H
+
+struct s6000_snd_platform_data {
+	int lines_in;
+	int lines_out;
+	int channel_in;
+	int channel_out;
+	int wide;
+	int same_rate;
+};
+#endif
diff -uraN linux-3.0.8/sound/soc/dwc/fullhan-pcm.c linux-3.0.8-fh8632-V1.0_20180330/sound/soc/dwc/fullhan-pcm.c
--- linux-3.0.8/sound/soc/dwc/fullhan-pcm.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/sound/soc/dwc/fullhan-pcm.c	2021-07-13 23:40:38.318384044 +0300
@@ -0,0 +1,555 @@
+/*
+ * ALSA PCM interface for the Stetch s6000 family
+ *
+ * Author:      Daniel Gloeckner, <dg@emlix.com>
+ * Copyright:   (C) 2009 emlix GmbH <info@emlix.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/kthread.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <linux/delay.h>
+#include <linux/completion.h>
+#include <asm/dma.h>
+//#include <variant/dmac.h>
+#include "dma.h"
+#include "fullhan-pcm.h"
+
+#define S6_PCM_PREALLOCATE_SIZE (96 * 1024)
+#define S6_PCM_PREALLOCATE_MAX  (2048 * 1024)
+
+
+struct snd_pcm_substream *capture_substream,*play_substream;
+
+
+
+static struct snd_pcm_hardware s6000_pcm_hardware = { .info =
+		(SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |
+		SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
+		SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_JOINT_DUPLEX), .formats =
+		(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE), .rates =
+		(SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_5512 |
+		SNDRV_PCM_RATE_8000_192000), .rate_min = 0, .rate_max = 1562500,
+		.channels_min = 2, .channels_max = 8, .buffer_bytes_max = 0x7ffffff0,
+		.period_bytes_min = 16, .period_bytes_max = 0xfffff0, .periods_min = 2,
+		.periods_max = 1024, /* no limit */
+		.fifo_size = 0, };
+
+struct s6000_runtime_data {
+	spinlock_t lock;
+	int period; /* current DMA period */
+	int pos;
+};
+
+
+void test_dma_copy(unsigned int src, unsigned int dst) {
+	Dma_SetTxrType(0, DMA_TTFC_M2M_DMAC);
+	Dma_SetSrcWidth(0, 2);
+	Dma_SetSrcSize(0, 0);
+	Dma_SetDstWidth(0, 2);				// UART can only accept 8bits input
+	Dma_SetDstSize(0, 0);		// burst size, UART has 16bytes FIFO, 1/2 thrl
+	Dma_SetSrcAddress(0, src);
+	Dma_SetDstAddress(0, dst);
+	Dma_SetSrcIncDirection(0, DMA_DIR_INC);
+	Dma_SetDstIncDirection(0, DMA_DIR_INC);
+	Dma_EnableIsrBit(0, DMA_INTT_BLOCK);		// block finish ISR.
+
+	Dma_SetTxrSize(0, 4);					// copy 1K bytes.
+
+	Dma_EnableChan(0);
+
+}
+
+static void copy_finish(struct snd_pcm_substream *substream ) {
+	snd_pcm_period_elapsed(substream);
+}
+
+void i2s_irq_enquen(int type, u8 *buff, u8 len,u8 reset)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_pcm_runtime *runtime;
+	struct s6000_runtime_data *prtd;
+	static int rx_count = 0,tx_count = 0;
+	if (SNDRV_PCM_STREAM_PLAYBACK == type) {
+		if(reset){
+			tx_count = 0;
+			return;
+		}
+		if (!play_substream) {
+			return;
+		}
+		substream = play_substream;
+		runtime = substream->runtime;
+		prtd = runtime->private_data;
+		memcpy(buff,runtime->dma_area+prtd->pos,len);
+		tx_count += len;
+		if (tx_count >= snd_pcm_lib_period_bytes(substream)) {
+			tx_count = 0;
+			copy_finish(substream);
+		}
+	} else {
+		if(reset){
+					rx_count = 0;
+					return;
+			}
+		if(!capture_substream){
+			return;
+		}
+		substream = capture_substream;
+		runtime = substream->runtime;
+		prtd = runtime->private_data;
+		memcpy(runtime->dma_area+prtd->pos,buff,len);
+		rx_count += len;
+		if (rx_count >= snd_pcm_lib_period_bytes(substream) ) {
+			rx_count = 0;
+			copy_finish(substream);
+		}
+	}
+	prtd->pos += len;
+	if (prtd->pos  >= snd_pcm_lib_buffer_bytes(substream)) {
+			prtd->pos = 0;
+	}
+}
+EXPORT_SYMBOL(i2s_irq_enquen);
+
+
+static irqreturn_t s6000_pcm_irq(int irq, void *data) {
+//	struct snd_pcm *pcm = data;
+//	struct snd_soc_pcm_runtime *runtime = pcm->private_data;
+//	struct s6000_runtime_data *prtd;
+//	unsigned int has_xrun;
+//	int i, ret = IRQ_NONE;
+//
+//	for (i = 0; i < 2; ++i) {
+//		struct snd_pcm_substream *substream = pcm->streams[i].substream;
+//		struct s6000_pcm_dma_params *params = snd_soc_dai_get_dma_data(
+//				runtime->cpu_dai, substream);
+//		u32 channel;
+//		unsigned int pending;
+//
+//		if (substream == SNDRV_PCM_STREAM_PLAYBACK)
+//			channel = params->dma_s6000_runtime_dataout;
+//		else
+//			channel = params->dma_in;
+//
+//		has_xrun = params->check_xrun(runtime->cpu_dai);
+//
+//		if (!channel)
+//			continue;
+//
+//		if (unlikely(has_xrun & (1 << i)) && substream->runtime
+//				&& snd_pcm_running(substream)) {
+//			dev_dbg(pcm->dev, "xrun\n");
+//			snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
+//			ret = IRQ_HANDLED;
+//		}
+//
+//		pending = s6dmac_int_sources(DMA_MASK_DMAC(channel),
+//				DMA_INDEX_CHNL(channel));
+//
+//		if (pending & 1) {
+//			ret = IRQ_HANDLED;
+//			if (likely(substream->runtime && snd_pcm_running(substream))) {
+//				snd_pcm_period_elapsed(substream);
+//				dev_dbg(pcm->dev, "period elapsed %x %x\n",
+//						s6dmac_cur_src(DMA_MASK_DMAC(channel),
+//								DMA_INDEX_CHNL(channel)),
+//						s6dmac_cur_dst(DMA_MASK_DMAC(channel),
+//								DMA_INDEX_CHNL(channel)));
+//				prtd = substrcopy_finisheam->runtime->private_data;
+//				spin_lock(&prtd->lock);
+//				s6000_pcm_enqueue_dma(substream);
+//				spin_unlock(&prtd->lock);
+//			}
+//		}
+//
+//		if (unlikely(pending & ~7)) {
+//		if (pending & (1 << 3))
+//		printk(KERN_WARNING
+//				"s6000-pcm: DMA %x Underflow\n",
+//				channel);
+//		if (pending & (1 << 4))
+//		printk(KERN_WARNING
+//				"s6000-pcm: DMA %x Overflow\n",
+//				channel);
+//		if (pending & 0x1e0)
+//		printk(KERN_WARNING
+//				"s6000-pcm: DMA %x Master Error "
+//				"(mask %x)\n",
+//				channel, pending >> 5);
+//
+//	}
+//}
+
+//return ret;
+}
+
+static int s6000_pcm_start(struct snd_pcm_substream *substream) {
+
+struct s6000_runtime_data *prtd = substream->runtime->private_data;
+struct snd_soc_pcm_runtime *soc_runtime = substream->private_data;
+struct s6000_pcm_dma_params *par;
+unsigned long flags;
+int srcinc;
+u32 dma;
+par = snd_soc_dai_get_dma_data(soc_runtime->cpu_dai, substream);
+
+//spin_lock_irqsave(&prtd->lock, flags);
+
+if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+	srcinc = 1;
+	dma = par->dma_out;
+} else {
+	srcinc = 0;
+	dma = par->dma_in;
+}
+
+//	s6dmac_enable_chan(DMA_MASK_DMAC(dma), DMA_INDEX_CHNL(dma),
+//			   1 /* priority 1 (0 is max) */,
+//			   0 /* peripheral requests w/o xfer length mode */,
+//			   srcinc /* source address increment */,
+//			   srcinc^1 /* destination address increment */,
+//			   0 /* chunksize 0 (skip impossible on this dma) */,
+//			   0 /* source skip after chunk (impossible) */,
+//			   0 /* destination skip after chunk (impossible) */,
+//			   4 /* 16 byte burst size */,
+//			   -1 /* don't conserve bandwidth */,
+//			   0 /* low watermark irq descriptor threshold */,
+//			   0 /* disable hardware timestamps */,
+//			   1 /* enable channel */);
+//			prtd->period = 0;
+//	s6000_pcm_enqueue_dma(substream);
+
+//spin_unlock_irqrestore(&prtd->lock, flags);
+
+return 0;
+}
+
+static int s6000_pcm_stop(struct snd_pcm_substream *substream) {
+	struct s6000_runtime_data *prtd = substream->runtime->private_data;
+	struct snd_soc_pcm_runtime *soc_runtime = substream->private_data;
+	unsigned long flags;
+	capture_substream = play_substream = 0;
+//	u32 channel;
+
+//	par = snd_soc_dai_get_dma_data(soc_runtime->cpu_dai, substream);
+//
+//	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+//		channel = par->dma_out;
+//	else
+//		channel = par->dma_in;
+//
+//	s6dmac_set_terminal_count(DMA_MASK_DMAC(channel),
+//				  DMA_INDEX_CHNL(channel), 0);
+//
+
+
+return 0;
+}
+
+static int s6000_pcm_trigger(struct snd_pcm_substream *substream, int cmd) {
+		struct snd_soc_pcm_runtime *soc_runtime = substream->private_data;
+		struct s6000_pcm_dma_params *par;
+		int ret;
+
+		par = snd_soc_dai_get_dma_data(soc_runtime->cpu_dai, substream);
+
+		ret = par->trigger(substream, cmd, 0);
+		if (ret < 0)
+			return ret;
+
+		switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			i2s_irq_enquen(substream->stream,0,0,1);
+			ret = s6000_pcm_start(substream);
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			ret = s6000_pcm_stop(substream);
+
+			break;
+		default:
+			ret = -EINVAL;
+		}
+		if (ret < 0)
+			return ret;
+
+		return par->trigger(substream, cmd, 1);
+}
+
+static int s6000_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	return 0;
+}
+
+
+static snd_pcm_uframes_t s6000_pcm_pointer(struct snd_pcm_substream *substream) {
+struct snd_pcm_runtime *runtime = substream->runtime;
+struct s6000_runtime_data *prtd = runtime->private_data;
+unsigned int offset;
+offset = bytes_to_frames(runtime, prtd->pos);
+if (unlikely(offset >= runtime->buffer_size))
+	offset = 0;
+return offset;
+}
+
+static int s6000_pcm_open(struct snd_pcm_substream *substream) {
+	struct snd_soc_pcm_runtime *soc_runtime = substream->private_data;
+	struct s6000_pcm_dma_params *par;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct s6000_runtime_data *prtd;
+	int ret;
+	par = snd_soc_dai_get_dma_data(soc_runtime->cpu_dai, substream);
+	snd_soc_set_runtime_hwparams(substream, &s6000_pcm_hardware);
+	ret = snd_pcm_hw_constraint_step(runtime, 0,
+	SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 16);
+	if (ret < 0)
+		return ret;
+	ret = snd_pcm_hw_constraint_step(runtime, 0,
+	SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 16);
+	if (ret < 0)
+		return ret;
+	ret = snd_pcm_hw_constraint_integer(runtime,
+	SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+		return ret;
+
+
+
+
+	//	if (par->same_rate) {
+	//		printk("s6000 pcm open 5.0\n");
+	//		int rate;
+	//		spin_lock(&par->lock); /* needed? */
+	//		rate = par->rate;
+	//		spin_unlock(&par->lock);
+	//		printk("s6000 pcm open 5.1\n");
+	//		if (rate != -1) {
+	//			ret = snd_pcm_hw_constraint_minmax(runtime,
+	//							SNDRV_PCM_HW_PARAM_RATE,
+	//							rate, rate);
+	//			printk("s6000 pcm open 5.2\n");
+	//			if (ret < 0)
+	//				return ret;
+	//		}
+	//	}
+	prtd = kzalloc(sizeof(struct s6000_runtime_data), GFP_KERNEL);
+	if (prtd == NULL)
+		return -ENOMEM;
+
+	spin_lock_init(&prtd->lock);
+	prtd->period = 0;
+	prtd->pos = 0;
+	runtime->private_data = prtd;
+	/*remember to judge capture or play stream*/
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		play_substream = substream;
+	}else {
+		capture_substream = substream;
+	}
+	//irq_emulation();
+	return 0;
+}
+
+static int s6000_pcm_close(struct snd_pcm_substream *substream) {
+	struct s6000_runtime_data *prtd = substream->runtime->private_data;
+	unsigned long flags;
+	spin_lock_irqsave(&prtd->lock, flags);
+		kfree(prtd);
+	spin_unlock_irqrestore(&prtd->lock, flags);
+return 0;
+}
+
+static int s6000_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *hw_params) {
+struct snd_soc_pcm_runtime *soc_runtime = substream->private_data;
+struct s6000_pcm_dma_params *par;
+int ret;
+ret = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
+if (ret < 0) {
+	printk(KERN_WARNING "s6000-pcm: allocation of memory failed\n");
+	return ret;
+}
+par = snd_soc_dai_get_dma_data(soc_runtime->cpu_dai, substream);
+
+	if (par->same_rate) {
+		spin_lock(&par->lock);
+		if (par->rate == -1 ||
+		    !(par->in_use & ~(1 << substream->stream))) {
+			par->rate = params_rate(hw_params);
+			par->in_use |= 1 << substream->stream;
+		} else if (params_rate(hw_params) != par->rate) {
+			snd_pcm_lib_free_pages(substream);
+			par->in_use &= ~(1 << substream->stream);
+			ret = -EBUSY;
+		}
+		spin_unlock(&par->lock);
+	}
+	return ret;
+}
+
+static int s6000_pcm_hw_free(struct snd_pcm_substream *substream) {
+	struct snd_soc_pcm_runtime *soc_runtime = substream->private_data;
+		struct s6000_pcm_dma_params *par =
+			snd_soc_dai_get_dma_data(soc_runtime->cpu_dai, substream);
+
+		spin_lock(&par->lock);
+		par->in_use &= ~(1 << substream->stream);
+		if (!par->in_use)
+			par->rate = -1;
+		spin_unlock(&par->lock);
+
+		return snd_pcm_lib_free_pages(substream);
+}
+int pxa2xx_pcm_mmap(struct snd_pcm_substream *substream,
+	struct vm_area_struct *vma) {
+struct snd_pcm_runtime *runtime = substream->runtime;
+return dma_mmap_writecombine(substream->pcm->card->dev, vma, runtime->dma_area,
+		runtime->dma_addr, runtime->dma_bytes);
+}
+int s6000_pcm_copy(struct snd_pcm_substream *substream, int channel,
+	snd_pcm_uframes_t pos, void __user *buf, snd_pcm_uframes_t count) {
+
+
+return 0;
+}
+static struct snd_pcm_ops s6000_pcm_ops = { .copy = s6000_pcm_copy, .open =
+	s6000_pcm_open, .close = s6000_pcm_close, .ioctl = snd_pcm_lib_ioctl,
+	.hw_params = s6000_pcm_hw_params, .hw_free = s6000_pcm_hw_free, .trigger =
+			s6000_pcm_trigger, .prepare = s6000_pcm_prepare, .pointer =
+			s6000_pcm_pointer,
+//	.mmap=pxa2xx_pcm_mmap,
+	};
+
+static void s6000_pcm_free(struct snd_pcm *pcm) {
+//	struct snd_soc_pcm_runtime *runtime = pcm->private_data;
+//	struct s6000_pcm_dma_params *params =
+//		snd_soc_dai_get_dma_data(runtime->cpu_dai, pcm->streams[0].substream);
+//
+//	free_irq(params->irq, pcm);
+//	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+static u64 s6000_pcm_dmamask = DMA_BIT_MASK(32);
+static int davinci_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream,
+	size_t size) {
+struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+struct snd_dma_buffer *buf = &substream->dma_buffer;
+
+buf->dev.type = SNDRV_DMA_TYPE_DEV;
+buf->dev.dev = pcm->card->dev;
+buf->private_data = NULL;
+buf->area = dma_alloc_writecombine(pcm->card->dev, size, &buf->addr,
+GFP_KERNEL);
+pr_debug("davinci_pcm: preallocate_dma_buffer: area=%p, addr=%p, "
+		"size=%d\n", (void *) buf->area, (void *) buf->addr, size);
+
+if (!buf->area)
+	return -ENOMEM;
+
+buf->bytes = size;
+return 0;
+}
+static u64 davinci_pcm_dmamask = 0xffffffff;
+
+static int s6000_pcm_new(struct snd_card *card, struct snd_soc_dai *dai,
+	struct snd_pcm *pcm) {
+struct snd_soc_pcm_runtime *runtime = pcm->private_data;
+struct s6000_pcm_dma_params *params;
+int res;
+int ret;
+
+#if 0
+if (dai->driver->playback.channels_min) {
+	ret = davinci_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK,
+			pcm_hardware_playback.buffer_bytes_max);
+	if (ret)
+	return ret;
+}
+
+if (dai->driver->capture.channels_min) {
+	ret = davinci_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE,
+			pcm_hardware_capture.buffer_bytes_max);
+	if (ret)
+	return ret;
+}
+#endif
+params = snd_soc_dai_get_dma_data(runtime->cpu_dai, pcm->streams[0].substream);
+if (!card->dev->dma_mask)
+	card->dev->dma_mask = &s6000_pcm_dmamask;
+if (!card->dev->coherent_dma_mask)
+	card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
+
+
+res = snd_pcm_lib_preallocate_pages_for_all(pcm,
+SNDRV_DMA_TYPE_DEV, card->dev,
+S6_PCM_PREALLOCATE_SIZE,
+S6_PCM_PREALLOCATE_MAX);
+if (res)
+printk(KERN_WARNING "s6000-pcm: preallocation failed\n");
+
+
+return 0;
+}
+
+static struct snd_soc_platform_driver s6000_soc_platform = { .ops =
+	&s6000_pcm_ops, .pcm_new = s6000_pcm_new, .pcm_free = s6000_pcm_free, };
+
+static int __devinit s6000_soc_platform_probe(struct platform_device *pdev)
+{
+void * dw;
+int err,irq;
+
+err = request_irq(9, s6000_pcm_irq, 0, "dw_dmac", dw);
+if (err) {
+
+	printk("pcm  dma interrput err \n");
+}
+return snd_soc_register_platform(&pdev->dev, &s6000_soc_platform);
+}
+
+static int __devexit s6000_soc_platform_remove(struct platform_device *pdev)
+{
+snd_soc_unregister_platform(&pdev->dev);
+return 0;
+}
+
+static struct platform_driver s6000_pcm_driver = { .driver = { .name =
+	"fh-pcm-audio", .owner = THIS_MODULE, },
+
+.probe = s6000_soc_platform_probe, .remove = __devexit_p(
+	s6000_soc_platform_remove), };
+
+static int __init snd_s6000_pcm_init(void)
+{
+
+	return platform_driver_register(&s6000_pcm_driver);
+}
+module_init(snd_s6000_pcm_init);
+
+static void __exit snd_s6000_pcm_exit(void)
+{
+	platform_driver_unregister(&s6000_pcm_driver);
+}
+module_exit(snd_s6000_pcm_exit);
+
+MODULE_AUTHOR("Daniel Gloeckner");
+MODULE_DESCRIPTION("Stretch s6000 family PCM DMA module");
+MODULE_LICENSE("GPL");
diff -uraN linux-3.0.8/sound/soc/dwc/fullhan-pcm.h linux-3.0.8-fh8632-V1.0_20180330/sound/soc/dwc/fullhan-pcm.h
--- linux-3.0.8/sound/soc/dwc/fullhan-pcm.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/sound/soc/dwc/fullhan-pcm.h	2021-07-13 23:40:38.318384044 +0300
@@ -0,0 +1,33 @@
+/*
+ * ALSA PCM interface for the Stretch s6000 family
+ *
+ * Author:      Daniel Gloeckner, <dg@emlix.com>
+ * Copyright:   (C) 2009 emlix GmbH <info@emlix.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _S6000_PCM_H
+#define _S6000_PCM_H
+
+struct snd_soc_dai;
+struct snd_pcm_substream;
+
+struct s6000_pcm_dma_params {
+	unsigned int (*check_xrun)(struct snd_soc_dai *cpu_dai);
+	int (*trigger)(struct snd_pcm_substream *substream, int cmd, int after);
+	dma_addr_t sif_in;
+	dma_addr_t sif_out;
+	u32 dma_in;
+	u32 dma_out;
+	int irq;
+	int same_rate;
+
+	spinlock_t lock;
+	int in_use;
+	int rate;
+};
+
+#endif
diff -uraN linux-3.0.8/sound/soc/dwc/Kconfig linux-3.0.8-fh8632-V1.0_20180330/sound/soc/dwc/Kconfig
--- linux-3.0.8/sound/soc/dwc/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/sound/soc/dwc/Kconfig	2021-07-13 23:40:38.318384044 +0300
@@ -0,0 +1,54 @@
+config SND_FULLHAN_SOC
+	tristate "SoC Audio for the FULLHAN System-on-Chip"
+	help
+	  Say Y or M if you want to add support for codecs attached to
+	  the ATMEL SSC interface. You will also need
+	  to select the audio interfaces to support below.
+
+config SND_FULLHAN_SOC_SSC
+	tristate
+	depends on SND_FULLHAN_SOC
+	help
+	  Say Y or M if you want to add support for codecs the
+	  ATMEL SSC interface. You will also needs to select the individual
+	  machine drivers to support below.
+
+config SND_FULLHAN_SOC_SAM9G20_WM8731
+	tristate "SoC Audio support for WM8731-based At91sam9g20 evaluation board"
+	depends on ATMEL_SSC && ARCH_AT91SAM9G20 && SND_ATMEL_SOC && \
+                   AT91_PROGRAMMABLE_CLOCKS
+	select SND_FULLHAN_SOC_SSC
+	select SND_SOC_WM8731
+	help
+	  Say Y if you want to add support for SoC audio on WM8731-based
+	  AT91sam9g20 evaluation board.
+
+config SND_FULLHAN_SOC_PLAYPAQ
+        tristate "SoC Audio support for PlayPaq with WM8510"
+        depends on SND_ATMEL_SOC && BOARD_PLAYPAQ && AT91_PROGRAMMABLE_CLOCKS
+        select SND_ATMEL_SOC_SSC
+        select SND_SOC_WM8510
+        help
+          Say Y or M here if you want to add support for SoC audio
+          on the LRS PlayPaq.
+config SND_FH_SOC_I2S
+	tristate
+	
+	
+config SND_FULLHAN_SOC_PLAYPAQ_SLAVE
+        bool "Run CODEC on PlayPaq in slave mode"
+        depends on SND_FULLHAN_SOC_PLAYPAQ
+        default n
+        help
+          Say Y if you want to run with the AT32 SSC generating the BCLK
+          and FRAME signals on the PlayPaq.  Unless you want to play
+          with the AT32 as the SSC master, you probably want to say N here,
+          as this will give you better sound quality.
+
+config SND_FULLHAN_SOC_FH
+	tristate "SoC Audio support for fullhan-81 board"
+	select SND_FULLHAN_SOC_SSC
+	select SND_SOC_FSH0LS029AA
+	select SND_FH_SOC_I2S
+	help
+	  Say Y here to support sound on fh81 board.
diff -uraN linux-3.0.8/sound/soc/dwc/Makefile linux-3.0.8-fh8632-V1.0_20180330/sound/soc/dwc/Makefile
--- linux-3.0.8/sound/soc/dwc/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/sound/soc/dwc/Makefile	2021-07-13 23:40:38.318384044 +0300
@@ -0,0 +1,20 @@
+# AT91 Platform Support
+snd-soc-fullhan-pcm-objs := fullhan-pcm.o
+#snd-soc-fullhan_ssc_dai-objs := fh_i2s_dai.o
+
+obj-$(CONFIG_SND_FULLHAN_SOC) += snd-soc-fullhan-pcm.o
+#obj-$(CONFIG_SND_FULLHAN_SOC_SSC) += snd-soc-fullhan_ssc_dai.o
+
+# AT91 Machine Support
+snd-soc-sam9g20-wm8731-objs := sam9g20_wm8731.o
+
+# AT32 Machine Support
+snd-soc-playpaq-objs := playpaq_wm8510.o
+snd-soc-fh-objs := fh.o dma.o
+obj-$(CONFIG_SND_FH_SOC_I2S) += snd-soc-fh-i2s.o
+snd-soc-fh-i2s-objs := fh_i2s.o
+
+
+obj-$(CONFIG_SND_FULLHAN_SOC_SAM9G20_WM8731) += snd-soc-sam9g20-wm8731.o
+obj-$(CONFIG_SND_FULLHAN_SOC_PLAYPAQ) += snd-soc-playpaq.o
+obj-$(CONFIG_SND_FULLHAN_SOC_FH) += snd-soc-fh.o
diff -uraN linux-3.0.8/tools/perf/Makefile linux-3.0.8-fh8632-V1.0_20180330/tools/perf/Makefile
--- linux-3.0.8/tools/perf/Makefile	2021-07-14 21:52:06.727144752 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/tools/perf/Makefile	2021-07-13 23:40:29.694330411 +0300
@@ -96,7 +96,7 @@
 endif
 
 CFLAGS = -fno-omit-frame-pointer -ggdb3 -Wall -Wextra -std=gnu99 -Werror $(CFLAGS_OPTIMIZE) -D_FORTIFY_SOURCE=2 $(EXTRA_WARNINGS) $(EXTRA_CFLAGS)
-EXTLIBS = -lpthread -lrt -lelf -lm
+EXTLIBS = -lpthread -lrt -lelf -lm	-lebl -lz -ldl
 ALL_CFLAGS = $(CFLAGS) -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64
 ALL_LDFLAGS = $(LDFLAGS)
 STRIP ?= strip
diff -uraN linux-3.0.8/tools/perf/util/probe-finder.c linux-3.0.8-fh8632-V1.0_20180330/tools/perf/util/probe-finder.c
--- linux-3.0.8/tools/perf/util/probe-finder.c	2021-07-14 21:52:06.779144902 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/tools/perf/util/probe-finder.c	2021-07-13 23:40:29.726330628 +0300
@@ -18,25 +18,14 @@
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  *
  */
-
+#include "util.h"
 #include <sys/utsname.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <stdio.h>
-#include <unistd.h>
 #include <getopt.h>
-#include <stdlib.h>
-#include <string.h>
-#include <stdarg.h>
-#include <ctype.h>
 #include <dwarf-regs.h>
 
 #include <linux/bitops.h>
 #include "event.h"
 #include "debug.h"
-#include "util.h"
 #include "symbol.h"
 #include "probe-finder.h"
 
diff -uraN linux-3.0.8/usr/rootfs.cpio.gz linux-3.0.8-fh8632-V1.0_20180330/usr/rootfs.cpio.gz
--- linux-3.0.8/usr/rootfs.cpio.gz	1970-01-01 03:00:00.000000000 +0300
+++ linux-3.0.8-fh8632-V1.0_20180330/usr/rootfs.cpio.gz	2021-07-13 23:40:37.622380051 +0300
@@ -0,0 +1,2598 @@
+ Z \]X`EWA!**$2,L\X>T@74v,ECw"&^@I`)q(wI *g0!wf87WU^UwldZdZ)2yVYWSS&?=8ioVdjkZ7#9m
+=ok=D&Iis9)A=nweizEK)maXOEM1Cqy+**Dyw
+tz&ZD3HU^KmB`PhQ:*4W*E3W*$!:UD :qQOIv|bf&nb6:	4[S^ad_SDoh`%V}*JTy X?e
+-H[X
+//( s
+CMLZAho$\</4jh@zQ3n: ?pjd:qyS$0gl=Rt"JI)E)Eo_O|j7yjO{OwO}o`XZUNWUbbU&5o;o{3tzUj/gt>_E9QQ]?=EBh	p/"\z~I2B^US=!V_ [D o_+W'0T?V>XEj3c;xDlC8PtcsQ/O#A@Z]Gx?e93g^R?~7L8y2fe8QeF`N1uWojl12JFaq<KW!C+U<QFWU9fPCE{hRAFhPO4 %=NViF!Y @+jR[D7zO~II"TQesij4:2SRSFciB\2O(+?gjG |{En|\]Z* @|S+ef]||Pt:IT12>A1*3*c|7zryFZj5 h,hGqjU	@AL3RUBwiGq"|wWoR_6/k2/k2+o-wx]TeW2g{Y(3dC^`)frXW^&>)YYeWoiezXQU>a4D7c)?f	S,3v-'D@EP^Pj(w_3JA3i7QZ_5@4>Pu@NIZA2`	_)G,e	YJ/Z ,v:nrbQKEJL\Muk7NWYu@~AQD/Qr<'jrS/Z XQZ^/Z ,}|%oe_@>wPwBQkN.7TC?!afq'@,.Q[R~S[2-{fQr_>s}-FQ7btIKW~v-$>xt}{hIv} (&m(.B=j@+:Pm{nwh=gB{"C2h@W=s74Fk:1j#H1EWH2@[PuL{P?<'k;F?}D{ta~OX]LFD6/})OZDP@=jyQRQ?c~YJ?"=7AvX3z@w?Z"{ztBYD[t%NEjd:N]@_g7LH=h3h5_o|t;?D&?<';Nvy_h2<?eoAgK}@US*>#_#?$?rcx0._3<"x.W<;8"o1"K5goK{"e*lN@x GZX^7 O?_:[P5NG@}3\1;,9<e:=EhS#='Cei~t#(M=K4MK/{tBK^+.~~;GA	ztK57SgH=k_3)#=HTxfuOi-Ere01s~Ab03
+0nG?I3>u~ oo>k"h$1C{`a?}
+1Lz5A+k`O;Ok>-bx1!ka_/*o`lfx?Fr%/,`8L\ :XoO;Pyo8t+Yp/^{aMs(?v1|A#S@^_ax
+nFJ7(_AtNp}t/,p`^_oa:odx?{_az_!o\Qyp31<9((:v/b@~Ce%V1<[~632pp/h/ )~0-z"/3f<P?z2O<B2A87{?%UM3(~003[w3?2|>aBDcRB
+:c/-/V9g73"Vxo.*=rSo"K`/fx3i};wuH/^6aZax90L3L9Grx_2poexm?B,/b8)N@*=k-;h_0}{AMiH{>:S%B-WPaB+t&Y8/{pdw4`CaxmazU?}~/R|ax=k'|a65Q/wz7H_^j?'W72|/	[5#}}<zazzA?yum=}#C7R,nez(2Ge.az0}?aw3\u/(# ]??M~kpT0|7/c)p?2|;y{oex7o~0|oax}@~77BAG~laj> {#}^}_anf<=,_p1p|=,1|_O?>:EP~ YWa{R6`1G4%@N,T=m:70IIH87j1#\G4?T>h9c/f~|	JC+m#^224C3c)m+mS[Dv3n$'pc.Jla mw	R'(p/w!/;10+tXN\t6K^eAIxM#n[Nd,EaxTCu4;pA.du.BIy66c]&JACUD'LXD,Pr%OeyGV2z(6'qF'Dn<cC`Z7n4$~f\R>K=F*a,#-p,XLPGH21RC.,4U"
+!KQR.4#o'z$_	$I@tPCQR$i|V#5.
+,@E=s2z"N-th	s4tP%}:*{V K{laj'PoeXR@.(		/>z{gI%TL9BF&Le[EfD!%"0 <##.IVA6De\Fel3&u{hWE0E(#JCUor1'b=,[Fg`[xa@y~'zQX;eqF'h.r,RgrTw/5hI~tx&R\
+2wTEQD?soycf
+6 -a	5|)V1l)$Z]PCWd$nEA2Q'HA?AeHg {[2bAV{dvdUlEtc)9M9tmn	("~R6RDk	+c<L2,A2t)
+F/dJ,5/WU"3Cme@\ BE IU=
+0B9Q,!U!d{IL`EI5fCK5<BcO.TSqx7a,"[RpG
+V.,yg!h|0,%XYBi(1(3nBX{o|^lH.5FRv6*U6BD@$ZZmTTTpSDD.{Cb33'9}><3{.s|#g^s41Qx-tv9J7{Hs(bb%;U2=xA6I]q>&cO9i~-)g9y&x*C VR|x%CyCD>|\O.0O:AW`~:|gP7?0A!'c~&ulf%yu|0 B1RLZa^_L"K0/K1Es0:E2t/ny<_A#+{0/;5"O#.5b_G#a<L$I1Pz?D~#9R?.M?3F$cI7cg~+uc6*g~Ds?_`/1gk0Wbe"|&D?0H&?ag>:N3^:G0gcyy5yub3O(auK0E~?2?"_g JD?g&y#u3b#E0_1j?G103;u3|ugO?Qw	)?CEZ?gKESE/QB+W117P|#&?-"u?"|"o3o3XocaoN;w`S7|'.?wE=?"g}hg3OPWZ)$l1;Eg!yua3\=cB.O1bF.13?F//1O`0*!b=XkMy!10z<7VYha>m Cf0>3ls<96|CgNe>!c~!2"i0?0D>!
+7DC2iQQLC2D1Q|!JkQo/0D(gnXe-|/VVKCfWyU^*vWbWU*tg]ir<U.sK]bWU.t\\W9UOP>+u\}r*ovk]5jWy*/v]YLWy<U*]2WU.v\BWUu\e|k]CWy*]ZWyU^*7]jWy<U*OwDWU.u]"WU.ps],W*?W|U*-fWyU^*vWbWU*tg]ir<U.sK]bWU.t\\W9UU>*prU^*u]UrUvg3]tWy\*Ot\RWU.r]W9Ur}]*r\vWU*wk\*WU^*W\Wy<U.w'er\*r*g>WWw\}r*ovk]5jWy*/v]YLWy<U*]2WU.v\BWUu\e|K\>WUnq7]WyUnp,Wy<U*Os]r\*Er\*YU>~5!WUnw[\zWyU^*r\r<U*p\rWy\*r\*,gp,	"T7[K^gdAX0cIO!?X%fthG9<bu$CY!q{Iew?~*B|##nDX>oM59+[4[BHu]5xlb]x\t/jmK,W{7<"6Bs!hwgk"}#!\>?BM9G^~{)}qbT_0i/8=%v}:bt6*X-bMu}Xx",/Vnxns[(_OApu:,lhni;-]o*h-12v#F*;}Q?lbp~#r49Jk^W'}f)iOa\}w>/N1nj=yaFCcXy?]>K2yqGT*wO[[G^OI+~zX_/P3t3E=!5x]byX9b]H$R<wvB(Gy(0vW 8\&s]ug1f~=@tpJbLSGy1/}!q|&5eyB1]k1y}qf\ga\D$la\&]cYrXi=cv!0\JHVVs>s-B++l##7Yw6YhpPWv^17se,~hc<Zh_5=W9zJ|edq,aWZg3vw5!jCz]B(BjRBj@j=<
+U	wE~E&]}T"KW(JVNd A2DPR= c
+8p]jrxS 6?u93<s.l<9/|+,|37@^XpxxeF\NKNGtv@Mmz+|?ub^qC'`L8}'SvVdEQ O!{^as>x8TL<h<@)IaL&(p.,q@Dior4wj~X<[#*|Jj2MXjE{S%wZ?\ur.;~IGN=2 [;o}o_ui~qkADO<i{^}vo\[}Of
+q?Mn5;xo6smkl*ea[Xe1d3vqsAX%oc0jl97S;ym}t9g &	+w
+w/y;Y9D7,n]n. tw^w`_,fQ(BQz=kE6kZM:)Hp!)=>Kf^l>nkS[5^Q:Y{q}8h#=G{QGoxMtp:$9vs\<$w1WS.^Izpon2#R{>i7zWp9s]Fa{R7N.EsM*u`C8Y*lo"U@}}^da;Sx8uj1|$a9^eJ\_^"N.1t	EvIy8|XPK_7.Hh	Y>as(i};/	.k\Oa+C=N:cRsBIA#Y'`={BBH"i3nHHo}H>'-|#SC<DU[0?7~
+4Is,l:RqclCh/~5voC;keXfG^D,x]jr^~@Dwu/wJXI5l1]t^R~=sE]c}bF!s=/'| N95[/A~2z9va!'Sr~.^Z$ppu>W/zj`"LXDKXWz}	G"zQC_,EM_i y{:`G8r}}WX<O^ o+<<bQ&c^I[q,#*M;n%O'}}^{w^qv]<<wyE^.S#q-]TJ$*yRw8=spBP<	\pd^C0d#l08`W7SPGuk~-xIF%x-o@yr@PR_r}k.fk[S;su{"gO<2<G_;0LcDJ})~LLB|KeYY@/]z.?b$Y[}g=\"=	<J"+PkOC"qPp]j8Z|C91,xH'8X2@BV~<mcvH@tz`6-G{C~yB *E8R.F4}QH3HHhNFir=j]c|pvA~$;\|,G GwOaP7+k;r?"W49 _igcOhqqmcxJ'>OW#!4?ThMBW[b)7H430[o|54szn[;8}^|6Ko5{$Nsm}O/r=?\jHbg?\20M;]U:qq-c+;[ l0Y:sc
+sX[8!}8
+mm^q[ c2,4Qq>l~NTKxK~3'1&//0c^>zZsO'~Q(b]Rfm*<x'?8rgscG~`yBt>!%I4jDNGf<Sx2L{%@.^/7W1E?[<kx9Wv |01IE.7r`u9i)sk;@{o1#+POmx&9{}r)8{HE;jZDQkwfa{%R]
+`?Y}wgoMug4sQ5|?pK|6e1@^_l/T[3^f!P.O'~#/
+cz Nn!fCZGR>
+\a`S(Br}?#'"!~J2$O)urN);:f?t_Y7FA_t0emXF37kg3t>1e*>5lKEMY"	CiFR_8%2p~AX")xs1lxV}h+1'FX(^d]oUF^}'l9@9I,y*p"hVo"/CpW'Sof Jp\K#^gK<gXpM<-Tw!1qS4+gXlR1f~4w|G<|u?'-^$CK=M&[7|pi|K&Q[j.Disn9?XKIg[ /Ey7oRKg'2x9J)h+$s_}='	+KK=:|u+,y#6zU!0G{Nnv-+R^_[vt	Uk<+p\o&[_Db2IP2ys);~~O^\)qF&4Xs1}/7q81"]3o>KnZz+.Xt|_,M,f+~yg<$EYm0AFd7cdJzH\O}=_|~q @{<S!_LR&MbgKwL3%[\,w{Z5,81-4#iI#0{/Cm8U3>qCv;hG $JwK=}gQ&kH?J$0LR&a40M|9x?AYhq_7J&Ha8.,@[km3p<UA@GBG:&]7<c&"})i1}|Z5RSpl)mhcYV| Z{;-{_)>ls5)"i~t1(90ng<R]r_F9xT?x?@59o#N79gy Szs]Qy/,=2t~97(?+r}	Yg8q~ZFITbc}KgHP.{69QL>-;bNI3j7{$I24nCA!6?P{x.L;aS;nt+wHK;0]16!m#,`oc!QQe9kOy}1m_c>$T:ym4(q|p	Z)}0Ba|<5*Sr:SQw%Yvg|t{3)x4OP5_ns.>6IU/'jo$%u>=gp61vhL>48jSI=qH<)\ngq8ZiDns3)&MpaK.j<k'jq%o_a5p|6bUxfmo$Ju`zYeFAy rZ7#4r g/<5o_:05zHy7Hxx>m6Fc9hcF}`bw?IvZ,<zOS't_,I=T31__fQ`/Y\:}Z>)DCQu2~c*F~GxtXN>An#_xQW1ctg}DwJn02-1 {T#<BWS@k@0@	~i9R3.R
+"!i>FrL+Y]s^_D?F.ED$@ysa#MZy/Gb+&b|(	7$|QxP?0/~LQh_2B!)_Knk@I04S)9V-i?s[Ye@^T<.'&r_q=`.Kpzxt<J<(oNF{.R9aMh~xqbs\k8c3}b< $,xuWT,KBI=.QR 9\es<M{>E|Wf%-#(z$MQR>:=%oq"O]my+r1O4gWc,F \CJ[-o'>Z>N!mP~qhK/=Yp=|M<rXQT"-~>75bhgE<}Na[-3cv!THZ	cC7XWq+Uv4b#0]hy6tW:{9@{{q(c+SrDU<=x[|pQ	W]qz	%BZLCg>u>=uZ\}0|8B"+ciow-jZ)\>5FH-H_LEZfa+R{^eGIwWoP^>4G92&Uq uk /Iuo{6Csy{K<Hkw@r
+`?Fw.@]P>2u!^8:nC6%!GdT^@\3Rha8}t)H |^?R?D\%'S"xLPg1<W01qi cmyI3*!YS.!Up9NZ1 hT|m+44H-nLh A5	eoLx;?P$53J4Qr:6\_wA[P	If#X cUVYm;pIB$l-h9{%x'?QE8cG8~I>BP);4	7a0d(>Vks7X1={-|
+=wB)P%;hj+t[y8&2yrp9?mgwgA%fulEi?.+<O>>X7mfDYV#h/fy/w%t>$3H^slc3Q}9CR9N=)+ip<\K)8EBtvKgCe;KC*y4Q5BTYc\G|gJx\nG?8g3c0k_/?XnNMV,y5-dgPYGXsD{s8@2pf!~Pz> aW]GN
+>z"'%1U%_Tv0fkP3Hl#JB.9{.>sq] cMA8,sH93]c_=uUO<;W{e. |IsHt:Rk7jQ7tDvd^ks&oT_uyW?"Y^+KffI_*_c? wv6/nf]Ozs>$)XN'C})o:RV>k-v&[b%KkD|hM2ui[ZF?1F^=<)WF%Az+K5qR5C5khK)=O4|tv$?A>')Y++sY)'I_+v9lOyyTw7cYxV7G\s4\pQDiG8j	W y$.e_%R68~[;K.4%I9pW<2D1wB[z#uV1)KVO:C.)Y9r
+HT[	k|8=(2)&TOx{4!g]+i-_9B;
+)E#$vchb\gl+K~X+KLJx4&Z)*_mOur.VPB@74(_v8.})i"*=J/=tM
+>cQ}#iRg;)YU /;E_nky!;?joQ<To?('s$mRg'0o5EX]T:v/xnxln2S{}z0m ]J
+2MXv5m"yq_xa1?{ZPRz I-Wr,w%s$l'<SbmMBsCC\f 6JcsW C?|`j"lh=dY]J	rF(]/m{I_0`QE>UO7^mJU:Tn_<1#|BWS)3}1)PA\\ejy0w>dU?$};{Rc;d=AO6R
+yiwu	}ieTdmOJ{$Ux77PeQC,L&!'0up(= QNl?c:<yXN5_xSC\&0*ky,[
+mo{ZmooH],{`]b{"q8PXRK0fG>A|3:pgsS&|erx"w"_B-}rc9cRN,,u>#I
+	8ZP]R)mj_k+c5^Cmcn>xZo-w!uj8?e<wy-M(Zh3?N*0s199Je4\<ia\8*ua}pH?/~{f(u0wv@[^W2FPpJ];p])!~<eO=GRs8}t_yI,.R9 %MHmwRw=:G{\N)tNpzq/mB
+.sh<I=K?A9}	j$q9K:Ipas:/[L}G5LISRf*];'\eW{`O)C/5f\XW2Z=(X%_GD{m+$N
+MuV1zgrnO*z<)_EKR96/5PYG5c.xJ+{iDwbG& X$s/kSA}88Ek-yP\<h>Yk9q~F:^rEAIQGw4E^r?m~pr}^rwzWbZh9%VBxqus-opNjeOPz)c]i_}VV_$fH]x)B;#	l&*iHkZ%]Gyw2-rre__fXj[}-O'<fUbOGu=\-AJ2 Q9HTwfQZ|q:Q{:G{BV]sRi:ch`c^E1\6b<W^i[u_fiNMVvK_B3qG;h+zi,i8 K:99NLv~KJe1~<Mn
+;>'KS+{+=X+)7LPW{~	]/Z\-xHsJzQyx7q=8r&fsJv7wxH\<Y iY!(w. OFO<u	+xBg'-?S-A/~	(F"]~~y% L[C*l{0NWuP{F kd&_!}!d0XeS{ra *m&9K0p,>k3x.|TW3ya 3IC.S&{Ky}h`o<DDRHJap-z>$t,);:c_0!O>a^i{$}Wz5=$ q/FO3.S]1N#A1%S 6I<,Sk>R~?9969iV9;Z^ge1^Sq|.NpXIb]q]GcoXQYC&iuy m8l{l`)=s`WiqU:VP, D=k}m0QZ&xP^7 +@~?j[OR=,]Z?;7>h$.e[PaZfhi'PSzit)ZEe\8k=cTobH-i$WiC+|u;J=M	/pT#t/m49fga
+4='EwA%	KWy~!YUl' _-4\kD\}H^`<f>\/W6//]o:!Rhm<*o$N$n<>j)Vu{Q|/9^vcc=@.?5m`)Q{,}U	G4nU_[gg;{=]AZ):(xp,24HY>c]Wm|Go[n'1f/6fzqu*3k2eU7tsj#aB0	6yW!s3K>>QYK@]VZ5=Vg:/2V?%o/
+lp{9"n8b  c1_3[L<}O{^K|c>>?W]voCzhM`tAI{D:,5c]>M4K|{3cI	SzCc#qtgG}t+8GiEA~CSZ]}{|=n^s |%/)5z`a}	(71V@sVs	|bc\8"7]2YP{vO[m.'sL*!oU|QJ}Nh)h^fgh=	e5m]\y&5a/}KNCCswY5||+u3OG	k88j&j{@tgJ>_GY\xspOJ4jNz{z.cJE %K}_?x)|sezD(ez.+#W/Ja:ka>+])i]!xA#\mz
+Rj.O1vJ~uts06*P'kE]/>,x@[;hhB{'}KnVubIuX[Lj0^w#R&r-"2r4"X(ux|fGH@{}/e!s,~02Yq$z1W'@w#-!~z0<?kl}v%1(Ga^hXD}6eg*=Wl3e|>M:vWW.~ovc9fJX/p^_cf?vf}2DNkJ9t2>XFx7:pa|68c\[EUnY,u[Gr)+Lbzv``|DApq/%>R<+cEG^}s*ux7~;nf+|8e?!(%iGKP&TpmL-CB}Luh+]&}Bi'FSIWI+xrE;,\bm3j>SGykW,peg4Odv.<?YnJg>k	2{bd?\\gyxv1H8Xg)i^li0xpp6mF-e{s5s/U7W=88er=bErih~K^un/P>Y'oZtHQP/v>G_s9Ne uP~007FsY)=@)S^&qz5[I]n M@"21n+5i=V4EblOi}?783wvSN*[@&6>eCWx2dev-mkBc%uqt'(oX.i_Yn><gG6aw2p`,{W]/%1LJ93>t"PJ"C0!^?_x/r5H~}=/ O RB|I>9"\z#,P'3>q(K;Ob9<SZ|k'!'x]Dh^A^]U!?cZ]WWB:zI8/U6ipHu9m2V(|$i$
+?;jWz0T#f&Ca8eofj s<Pxl5)D^:S!}kz2=!_m_' ~1uh/bOQ65v4)cTG<LL2&$)7ljMQd8[_1@Di=+5cI{tDYEQc*(%Af*EPx9/h t[~`7;}rG&
+n9mzIfZZ3>#wq_IVK%t[1H<0H7Jnn+}rE@l2?qRRO2v>cnO~ww VAviO\Kha^LuEWI7N`FC>}wx>$mEI|7'mcv^AK/:O@e]@'*-q^u/2[z!u3Li%N4JV>C)}NHrD^yjFGlrN~~sY{Yk:^
+/6V*t=D@^O\N=yOA^Pczs:KhTa^VOzYg*8qb?U=o~0:`jm_8X=KOm5Oi(w_K?SK	k~cPq(	Q]k(qW8	It; zMYfM`V-NN(gs4m
+lki!i>;\0T'Z)czz\_]R9Qre>yXP{]K:&=/qXj=,1m\IUJSdxj),v&P0Srb'S~|R=
+XCeN9e[SeyNv:=rQ>[)x/.BziM?tS@[
+3n~"\~/_ko~7e:D?72.m1AJmK>kRDyQJ]zO[&ZX",4Bv9gzbFCBsrOAWikwN[;hbGKycJ;(XTj<\/m3DEwlXD<Tro6IQ/T'BU~fcjGS))Ay,%LzUmDbI!zf{N{	za3_W-u7G',d|gy}z|M:/Sy4j1x2O}@R9>K:G%q6*=~17X<:S]<q.3]Wy.lcL6<B]r ^Pa[iu[7SM?T$uNb;ZD_+xV{OFbc8?Z7X}a]pZq["7YGn"Xgy9ckh^dXdW."&CG~q|c?T<l4=iC"lGS%"$MYjd_&XcNT|R6?=>P<|7jJJ{pex6EFlE"ukV~VVG1,cJ={cs(AmG.g}uHRXW"^X0u%yy%ux|~~>gg56GAq=}\wk=D} Q<^<Yw~h_n_I<iC}k*<451]SIiqK?
+=1Zu7H4tN@_N{D!UotT;O9Mq+Aw@rRvg'Mip@~.c'?Rq?06!GHyHCNA:mL$#1	y>;YLXbmVf}+K|sNb6vF`E]YT }*PYkzee_ +!'6sqUU+n}<6vPOI/p;W+RG|@);3	n2i!<w<9<BF,37Rn2QW`^NlqUwu?.Fo
+_q/q"ru(OX6u7O(j`
+5>s0fY!4S6b#KT6^<`lV)ZAB}/dHy1iQ{y\!%wiHSJ5~{St]Ux~wezix]xo[{%}}|2Mq
+oK(02e<O.3w3^L1c9Wu&&h2P!s3*FbJ e$P&o!=2R>HI	mV`7Xb,G6YYc[k|!"oA^|PZrn::b8pLc0
+|I}>s0wNk;W2Qt	?9|_iJ9 J]d;_UKPQh vIw9Fe}-6/{BC- p)hcFnr&kZ(c31~}u,FY-u7vZ-'\c7e;$r<F|7e;X}4Vc-E}clmXP]'p\Bl>\+c]3xg$m='S]w!@;Z>AX9H#B_#i!YiUHAZi'm@@:"I!+H'|6ca{xoN9EUbv)V}Z>*`O6^cGOu;o}{# ^}. mG_	h=fvjuL(|^Q9EeC#cug8.8)yzBTtcA}!o%m06>~1mvZer#9siW8OucYF*
+|S9'.\+so}/%qgel?e|PQH!MuW3PF?R[~c&?eNu;alh%J;(xOu[Kda\Wz?GcRU^/q83,S DA]/Te?dc? RD4*YQ3B@1}ip*~(i=V8=5Gt/wAK
+WFA:f1!bMfyO1rp/{YPMpoX_h(e[xn<r\VuB5c[k:]mGDyQ?R^'k=M6@+-}o_J5=]\o3Ss KNks+`\#$9t ?3A}yH133!L33>p}=iP~&g1F>E43hW|rp}m,5c_E>m_|HuHO {/^G9R.bHq9!+34@RrCd_pOlL]6&S:PB8)0)a9"vg!/|9R5kC:yVj{8r`}8(Y8r:WL3x}K,yrH!rV,unVqAVgjY|FY[3#qIQs9q^AEaylo'oLQ1/e?wy{uu#q6#hQs<\
+j?m#u$yRq\l[:7/mx?{'XQ;OC:9&\@t|*./+/RHiE&@$_.FZ;h@u8=s
+- /nFs(??2TySAm}Oe9#8ZWzMk	z_|Ec\ c<@2j|+bo)PC)9>l?esj-&C"MJ^|C9}CJ3N]RCc?E	RdY1|Daqy:_o6sC9<{P8q>hz.&[dg\Nj>Vt"R:@v^+ ZsxMx'>T6N, s(Y{w:)DJW^aR>wCOu9:V^QTz'sb99i9Yu%RaV%BAzy1uyW	nj
+?>NY'dV|sj?/+:}!\>?%!T`#I?j&1S:Lbxe7e	kbme7O?>L{'|P_dL}"duOu<<S>l2ntN ~=3:y3(BZan/r/"}Y[K|Ts_6;*dley4cu8v!{r
+P|sk[~6h}&s9^ec8A<W;G^>Oq~/U67]co--6Bmi;hu#InN<~DhqgZ6_m9m
+q>@0n?:vlmpKbqsV&UY' 6iq|<OpSf3xF%TDqx>E(K.dyq5y&UF/pY=c~+{cQN9.S>QHaIGFWB?}6^5I;]m j0Xm/T1J,'Wr{=2Wgv^=g_.Z()=*Xm[K?U_ _4a;eP8Xi{V]@92{uo5S+*x~x|0[ Q2<_T{io4Qwp-~U_IkDQ_*qxc~{}36Ogedtnf.K~^
+.6+Q(bY\!?@IXPrY`e<!SgCEvQ@Ktg#XyWX >.OTx^j-.uOQW8pV3rd%y xZSv's|@xH53EY<cX{A$-jOCe\+?Vq+L{~e|/|1'c.pZh">p|Ky }X{\;:8wvUY`.IHj \Yl`5;n(*vh.ESZ6Z<H$Oa>Ocg~g|"d{@c,LG[(
+0GfuIo'0|ri=<b0wQ4@;*mnB
+v"1N'\s pvk)Rku8fdY+=1~,~7u<gm$$EG6clKX}hh}_:%eYw@~_Q-s!Dge})}uc{gcO?1~;'jw|Rh{v#k82guLHQ'%WZ'%P,|I=desl]#9sPD*@<},cMJVQ{BH| 6 ]8n9kSv:6u#h~H,	k?NsVK
+p4h5;8L;OM(\[c4d{p*K	Q0Kx?|G}7NJ\_x/?v=n%qb2c[7feVvW7[%
++S3n;M~	k=X`?.wL6DNHw!E\uH+bH#5!CjFt6s+m226AToir5Av2Ym*4<1JG>npTjUW6+ivg?!}5q #YH)HYT.C
+#|kFg^Gz~%?=[6GvKAEls=(|/7ZgT/o>}? OS>cMakmgs=\gcZ/R<Tj<nm6Z9o=d{[\NB~a|x~Z1/prP|%'O`?gHY#x%Po[9]|c	XWO$&%'_Xsx?^)(y-S+=47~IMZoW~G:Whw	7Htng)p.W1BV'N_2yKPL8::h3FZ4i)?Has:XQXr$^*}mw7tV', kXJx#|~Y{+[.I*-Emm}m?\Nwv)76b[It`rf]UTQkUb<CREpGPl!GB),8Wh2(q}':gh_]}8N:$'67=+:=KdOQ8}IJ(3(a*s$^-kp= <pJ#cU7[s<Rq^s#=6JC iXv0{5h1Z~F?RgJ	3#Zyb:OT*O<kI]WQl>5:xrO,%Es|ET"~m/x	_]O`q/O^(cDlX"}!Z;vK" L\ziZT	#G/X;r:*4<:q|[?=W2P%N#>09
+[t}1s;'h;MJuUIkzx}T	(_+YisbXD}F,qgx\>g@YTa#4U9:3]*[$*{d7[Xo^g9kil.flZU:O_HXy0H99[sieW~6wH)r[hN<56<#3I{GN&0JgcwwqY:zZ>T50MD>r_#6%k a#Mpj2N|pM_S^UYk_m k7wC$Fzs@cwKmw_JmFcR2gYf6a
+{8&,e}xS&WcgJE[Cw%gxv*}jho#MB*v?{xW&yy<yF`H|m#}~XFHDZt &E#tfeoF$pAYRNq_Xcy~WYi3o;k"o7X?pB$6svxqLIU r)Pg>:wy[3
+DN%T4P~Wic{6cv*E?Ckf~/73|#JSy81P>-9U[O`ctA;#o=Z	;Tr_Uk{))Wgp}<1
+
+fXn<2/v)4?:wU[R*Ds<v_||Uycktp.skKz:#}2YG- +7RM;uv(s nw)lV5:I-q!0&3*je;])w[+|N_`:t%yC)62fc1T]
+c_ QH%5f*F+p3g$FcFE cjlv~'(|b;c1'4_HpQqXm@l(tuPtElo%Qu<%/<{q'c*t=gaMWbh0D&mSI;$h_RyPM|~9pyFQRs^7{q`KbGUrwAm?=>sYezm@??Y/_$|x;|foc-87?+1U=`63]0:[S(m|6M~g?r/{vi`w^)n1FD%
+~Z[8!G{Sey%}Ay ywr
+*?ugosYgW*aUcbIUh?161ib='8)i4e|=jQgJ	O6b~3	#wO#|@<tHe:7SL=%Sg3w8v3S,-{>O(f4_~;>Ceczf`;MmJ1~\KuqWDk/iIIu.Sq<=x3N:	{OkOmqZS{sP3-X5Y1+9zN3{4D7z4kf\3+b{+k2A;	];ThoxhoAoY[]Mpt0_L0NULy/)b8fFqHDe;0NsoS4kZ)&q6pQ#%7n+Q|K4S@Mphm$T{j<<o{o}Ors'j}A]=}nvyuryP1+LesM?Q.6wm3~hB	s'S~p2#pmIer4n0C8s%8\1[<4R9cg<mo\n;|s\StbgVo%cUF0ViqsrOflBwu(_\~BvgpvWoQKn-N0.9}2hK7U|f;jME|iwX3QH98i#eOyG #L>x7\7*O:h7VO2N{>G@/x``*Vv0323y`KY4H.QGG<:&V\RvK|Kt]x<V(y=x>b 2L9c||Zv=F`N^>7Ray=7ulCy%xENP:jhomZ[d#FnC>A9ZwY+v$]k)|buF"CZb=q|&x<&Jxt+O3#VXOa4A)mJFuXAiEj|iQ;vPaMc&8g;5m?3T?"\K#-Y4]!svk
+s6#l-,+|qpqB3'e5\	v*WFje2=)KCQ'9XJz0v2N{.`5Xxy,C,NLg<r@g;VLj,|x7' <|z],Iwv};cR,,8qXKU;PsYNq3|<;?7/-FY/,Se1qB#W|pp*cVhOw2%i*]H&l%}m.j--H4}5qjWi(xwO<M	=rg ^_ \@^]??{g|/X46M""7gX9lwb{^S@[[K,00izs_bN,-//>*4ha^a+P|]hc.=nF^E4CLKJ:p]QfyWzYV?I'..}6=57<#TcQ6PCQN*9 s^=)g[3g*`&XR7=6/$=cIZG*tq}"__BeH|yhgiD7SM-\\\\[+1_x	!'m(fpR)wQ6qk {TZo6?h)e@/PMPrFm{H16Eh|YICNT_EQ!mf3n"y.H1&~G(kQo\||iRE6e1/"]J/R>6Fx]ggX"5fnl6cmn=k3QR/xEum1?Mvn_v88D1m6'\-%\xU*RM/Oy-Gt-7Gvh#|_24=uxNwLY$IsF`l_<nrN[=c(7o?|>hY#1-?o\-tr1 q=0a%U	OQ<7?gu#1[pm]jAa7~n<`~U0i"x\S,2I/ <s-<sg)^f`MmS<#j}K1<|{k_~|kd *=h<w6ns=\}p.QuR6}	}7+*ZTQ9xnh/t9BeFG~/Z<w|O!-ewAM*wW-s?Mx$),c<m=]~gJs}-u>7XU4n}w~E{7;f@NUqfn#|{h{8jszbpIy?[H;&sxB/g#pLe #W..3Dvo<*k]`p)+!>*r}-{W6nA)Ob	J<K{y~-{uUxcq{&vbY.#M1-<ZSC.H`ESU6seOHt},=E}9@XG?P<p(RoOR |>Q/D*[L#su*_<6nzGpnEq;=w91_&&1xV
+t}55y-XeAW ;)"#eDn}vgCt}rl;Q?c!"@N"7kHZ?uB!e_>P#TIopn\<o\	!<OQ.<-n%q;feG"|FlO}>ids6mioZ
+Xg[E@t\>Ve>t\|
+1J[x."n{Hs?:MIf.W|uN7kRg?ZogHX
+aTK`J07Zqd<60A/m-_zla'hAW~
+}_'?TJ/_w-~1v=~-R'22j3G[?~ZMJFSHRKL=jW|87e+>:b6ck<KRJ4/gIk^uDQn_{?l<v0oC!.@AQ=ZUHK(K:<"'A9NgS|%r+vw`NSR%Lcp]fx<]eyv7~<EP--, F,SYO?vb(;tmzwDP8uX;J$SU.\B]zD<W"8IrN:3#]pf:vp<4</,5{T4/i'S
+X8qWi7kX~OS=M(KQQ1MKQC(*r@	!:fME]t<q Lt'Mc#\9,u|G.C-xg&y$5OMA]'C2NBs'_7qy~O%v|)}0D20X&h5Ye_c[2Nyo2zofkfv^2N`y!Ewg+D 4+p[SBSE%;B_,u7A+po:6q
+l{ Xaasy"7bWZ2^kPH+s-*,MTq+4De\EX|| mN]m=44o]QNfpm8uO.x&\+Tk/>;Mmet[Ns@ssaQAy_PMBJXheg[-*	;km'!1V##}6w$Ss,62TSm+[$+s	c6FSh6w	qJ2F4ifKK;VkY<5t6MIi4.A[c]wadOU[jq:&'F`s^)5HsM<$jwwz )r?[5j;8I,Wq|S_O_)8pi7nSbr8{q2q/L9_WS,x(1/%v>.GQSUL\|[_mT<3u7?s{1|HzQAVW2]hlm&%mo1{},Nmo6zZup{?^E{yo\K1b-J5?C8k{q`Ea"Zrgnv>0]cikz'I*!0*Xc6mv1J
+yI*C;d~6%5mKPH>VX>
+|s1m%l~L%'<OIr:_1Q4_aw*e-vW^v:<;?yyVIEo{h=u+`n:Um
+QoSUEs~[,T<O?c*[,!^{ZrB7$6gg,P9_9q=
+NGjgr}0yN__yU!EMhU~H.Re(-SwX-sJcLT2UlaW5||Q|7Z_|	8<W'S/ty8h
+?q?=:7mCGN,}+:'jo[/YIH:?w +_Ug0o1*w9SLcOpDM$S|[1nR^b'4a$,wc,UM<;qY,9HVc-7A#67NN}BL+5Hj}5/'G+R<y	hyo(7R6_:O)u!aOnL05};xc3\<Rn#?mhfIO&qw'Ms/Qz
+uSvMh CuWX"}]xRm=Ip;_68-qSxqhd;yrLnJx0&%DOS5Gm7RZ~d}O\kQJ3zCN|Cq^	"H86lG]?DN"!}H1$O!snEiRJ;<u%d(s@?&+GSV%Woq)5~Sx"dh9*WRo@-IQrRydHgm3[-vAU=e\aSK
+>m[x./eYv sEDd.0Rh2=cwR.;6<!rCOt2/\Y92f^<UZr^N	miKwH\8RIPi^!xz8wk{%CdO1'
+x1^VDA|6vFK\ubP7dUr*C?k}ukY9c]R9gc\/yEp'`|'}^;{s#Kb:k` Og4-J~4c0>4:QgnkFuit_|fpC ?l
+E_'u'h e%h;uT<V/t95nb_Xi.H?]JG[ ?)U*$c{8|gnSZJU*toaM#j,8`HuGcQ-yV6n^no>j'o#S?BB+v9]L>Mua/V2\iC-+i#`^q?l |I>TwXn]tf^70<*K<rV>5[nzK{#E39*nYbeR{E<{-RpBt_d!ixfls)C]Zy`>/r6gan2ZxpMXM_O\I
+.G p7FGK{<^I8[~r}SKP1rG,T}%1Fy /m_u
+7z[q	?n}Ow3qk*t*^>u>|Z	z0<,o4:h|&'2y{zl#EQtc-K*h1{PW1xP3%7s^A`)ay_)o~S6kl#e~X9sG/	i_eJ!zR6(4~B)q=ssvnV	sQ2>!#<}q{3=Z
+8gsgP.8kL7/hm4dsI_'7td*=]>)N&]Do2g}7sNUT_!Sfoli;z +'/z=%IhI~U'ph:%c8 GziHYooBmI2N>E_j?cx".z?Cl)G&9pJuI_(0m$-
+W7IDN7n63}x6^_aM,c(d5/xT>\EWpploVA'1SHtTMvQm#Vcc1jntX$*WG]m?`wrR?/ti4#7>e=/Jy1MWT8:06U7"b!+Yg_1pp. ODiM%UY{Z<xS}fgRgm~m],Z1Cs$lC?i`f3,mO%
+d7`V}F0#98~YT.x:LO\BCQ_9}i1;,xv<SBW .l-Us0&`J6F9*	`hg5GpUD$]4H<9H,N*)o]c.
+BN*tqC8xY3[wv0cK+H-sc+dK\mo\s:-IJb,]A^M5o/%yC_9~7$?<D]}^~xKWq^hx
+O9g^<~RT::J-i)N3>|Ag-7fH,2{i=F;e
+kg3Jh6=>y>kxC!4k~a!Ua\O1'F"	u}:oq9r^|<u5y_ <0:euOb+2NQ9c#d_GOlwq
+ s.Fgg@	^sMy_T?H]\ox<+i<4y	Y9r*csm2N<{N\hE/'DM
+g	ol^]c/A'')$eOW1g_('>IJgvH;>yFS.G5FF?
+xwDnOk}9IIv/ro6.Mc&.@?V|>F+t[N6.J"_NsxA"qz,BBE^4?wlT43V!{lf6Z{&M:cUY2 116=<[_r](Dy3(ByX5('PFZo`;C&:<k,kyf'FVqGbERg'VRcZfM!)mEBSCl7!E&Mo+wQH}8B 3ya&Fv
+v6Gm'8z*O\[	ogF2N(?=Hcc3YjoO>e	?0tyx{-!<F;k"?Q~Sq!AmJc1~_M{w9a1xsgxkskcG'>D)XO}ABOmze|qO:UWgAlEYh?!W1j+(#q.G"e._8}U=hE:&q&u&K	&|9(yF2J,1v>j@fbqR)sGgYk~chg:;jaOSt{goTt J3	xb}>#r{\&Eg2N^B8gM;B8Dp?9Km5aaxUt;/0k|gf?r.n_U(ggsA=]QkqMzLJ2<{~h}_JhpUd:gs86?]x!%:*M8g]'}'3~jVpjvTW&O^z	~X-wI7:z{`M~+52t\o:@Oa9w8Pk=6[Vuj9?rM+a7$%3-y%Q7Q4DX.D$sOgu]2KpN;O9HwwI-\K>Y$ ch{.&H=n
+1w^?Gw)mz]&	GFPw?}a,%s1@<>1d/TI7gH[j9q[YhK#q_<xex'9L~Sk_{^gK<}{6h0[~ovuV(_S4E$]fi"4UfyH['FO)8,R4Wl->]SMz0i4>mOh'%\fq/=/!|'hSp.0S^H7!Z>$"tgDlT_}%slI93-y6L/}r ?s3',qo`)q\#9t]HsWm6;;XjfS{<f{u{e!x/cr& hc]YW{}#Cxr=a|Va2.FQi-\y;Vg0$u3x"Kbl}2D~H#N<$=:x<R3wL<cP(,V<!I[g gnnM&503b@E]D]t]u	W]1U55!A1u`D/WN[47H/!=H+hsRknzgqb<;L=jQ2Xj[.Y?PH;1v614mp6%2KhYbV{+2-":L@{\3SAyEfu.oPEbAG]>Ux{P^~LQ3YLxNq;	IL~"|qNW&C4
+0}f$~47%fUG_an
+nL|F8$Cq(@]Q{&f'kPRF}c
+Kxydso'R<|WH!QOytl&_;7=nhOu+_hf^vq{?\+x+
+5t|5ys:>dY@wv7SgV-~DoLHO:=vjLq\A
+b<gpgR.M6[a}A9zpk0>k?_y(Tzs)ePkB~?,xOw;C9d`e>XhJ|xntCu?gttu8o~m5d8S0f{{SBJv=q;yF^y9mY2moM1hzWNQvv;gB}ftW`m5o=;=<O?9X=p]oqw#kDyy~qaTP-)+_5k*	sDh.o?|e!]6,)s_y](T]G]2/yGIvTK:lv|5aI[c8b7xU8y;Jw,w!?~#TLNWi.84R]j imyyKc678ZI2'n;5c%_qxySgZNuB-cK*Kx$~yW>Z`+{zsD;Xu^9~aTu.6SG^=-3C.0ZST]3y:/|bn|1Uu3{[kC_YVviNkUf'G=OhW[$s>rmV[o1 :qL4KVTZg@5q9!Z:Y7<;G<WpuA!e?nI	H^>lS*?c;_@Xqk-1'I__~aud_xwE<E_#=* }?kOH-1qS2>\lh2X oq/@[QN]x0<kfzCsk8le\&m}#a|{?vu+.*S0RSj84.XJo|.vx	o#Ycc?Ry6V&;Hs>@I8m_zIjg[)H<%t$f/$Q&c{:/_#d=M>}:@u$sx6Y7vI~zi*gva?;
+q3}t5;m'0f0o+WZ^:>FEK[,r#K-e)|K{}J.11ZU*+=A[t8uU*/Qk_.FPf|k=qy.04#rNw:_^m.[thYl7}zim}_b};.2b"%S([meJCXazzEy+5H0s})M$iOx<u~kW11)6>_zI:Q3Bv):#im}G$sOf3)A} .+-1Q#8}/uL-P#>/;1 {?xcG*`52UJ|^`^iyc;8|2{VClEabH3zo{LM	XRm?-~tRQ&$~E%o,/R*u_wcR/duoE7^T6R6JXRM5yvz^YiuR|zl$cRuVIE[oks5lI%;6bZ(>WA&w^ZlpZ2cq^[BfXeg~1=NWnJ?+))y6j	<V[O]F$XA;AUaxxNhK?n;FUm}<%pDkf97MwS\GjGzHHG4
+K;-oN{OCM,:w&3D	O'4^Cy&P|hu~Y~	X6"/l}=']B@08^"gU,H,T^,;q',}>0,B1_fI3~Tj:1b g]^,Nf]|]q|+1cGB:Gk=xFX,|V.3|%ucn~E
+g9:9Fm\4/OPG5"2E'=^seKUe(zXJ{Fg3V"XFI.JY.qN0pR?,cbvxi_8UQr^Yg_kg}VSS'*tN^m
+=`77<gvv|Ip%h`G3%BXS)Z>_ZztrVu3zFu#}N\ *8h}Q^!r<t/jk;[7Uk\ [&v7Z7m7oK8kMyN0HP#}E}~|WyPmZ:8Y{|x:lMG1L^)O wD7oicqJ)'8'j_ Hy0w=fgC{MpjQPsV_ t:5j-P]/o?r~++,{s`e%mqj+{58$'/<dv&)c"iyH.X]Zhm6/j_<)\h)_@_@^qy-lBhB;Kd|<KV`K3GW!i5Ywx6[2f'X%a#[mXZk+I=v,<8,?n=g\u#ykQsD/F-PoakOfj7}^Z\<CK{n qn17A^
+NSDS1KN|Aasd;(Fvb*LFo9'S]>jCq.u9n_rT&jgRv!h_<T[~1y=*(HHHoVy/F:H 1U<Y%=S	-h=qk/gKY<o>=v)/?6J?)GXWx~.g\cNx01s*j=eMiye=6f|k1aCK{A>d&ES_)fwcI2jONw~?!HP8AL:+I;}Asrlds0(/ACH&	))D!<o
+aww9!u^69[u}zWo@y2pUUWns]os]7eyk~9o.'U+?[	]5P,u# y7<^N%c^P 8KZoX!HCT47j92 ijbIc\AU`@H|N<:9q8yqn9@>:6YR^omA/tg~<6hkwni,1c,}y_oa1F[oiZ`MQQ\eN7kSQ1&w@V+2aSq}z!w8F9&KFc' L.\yO!-Y*\lb@|5*tM"\l= B3wZ@$z
+QFf$DyDKbx\Gm--	OledU@CG4s~6Wc4E{iAk8u'7pg%p4iFrKEn%S5bQvel}E<sKhvL?u
+Aq!/jv~@3?5Mc@no@m7'Suk!.sYq%qZjo7_OY#}v1T{-k+&zJ=({C6eh&/O6M=%Hz1S|s@	<fFz$&'c#MD m?k2N;2ug/xY?vo0lzgT~a1VXbxq$[qhq%&Ps{|nxo,'S}PRoiMN}M6w^+v=Z_rnER^(V,mS]mw8Hx4)^&Ffyc^Cku$CY<3u-uDxI]Ahw}#"}[i9mq36$/21NH.iHQJ^$UF;0Y/~KQu2S@1'}OS'zi2yfZPI]98=xu>"e;}TXao%v!'fJm J]Bk~v:K+z}{oH/sy;9s2!~5<E8#1>o^XyNkp#lYuS?<HyS}2ZzoZd-6R1S$c1xUq`s^@V\=wRbn*7s+~AZO<!]Azkjk+x{i3vv{"T8>sC2!AbK-REKuTRV-.j-h-Q@)J\rLL`EET~'>>mMmc:-7u=xsKhGDZuwYt?/}6}
+> fI%s.(vxGB21nBc'6 FE|*	,4Ut:e>1>3zj]E_,oSD2RiV]7"ug=S?wz5>s2R(46#M<*JLXKk#m&NS,i/,g=sWx~B/l:	sz3;02IdsZmxJp}{<XHB\c[>6L^#M`^;q1<s^y;~;YO\.==[x.C+q={f?vx?6s#:V^NX1Yx,cz)wx~nx7dggL0gqLe<>
+b3W('=|m]AALB -GX<|sWXIZ]4  s(I}}iOxKum.:<ZQW/~D10&e5zuqL6vm:\K9dO^meGj>hAP7J#W/Vb?!+X*,Vv6|W;\{?rMT\cJ"eaG`>~FfdZ^V4xv#SYmII~^$_e_TBnDcq9].xeChp:wA_KG%<a5?";/Xp6Aj2QV3FM1+QxQn+U}(?dn#[\1g2EbWr?~,3r=G)l*kUR'P&z{P1E_	yPbx7w[/g1;A'8bLKMYN\{~v`#s~$oVbqeL*O5(U7d-IJ9z1-)6Y]$yU!o9O>Q]1Y]U?YoPX%tUqZWiVk3bu"PN6<:/uw{Cl05oCu>]1n\i3Qih7Oef'8g=Jc-sqo	w	6&\PkCK>7n;h?`6hs^!zFdGi/iI>:kM?X~O:zk>w9][D$Q-kK\r
+j7	t"+hZ~BQfE?B[+^(=vEYw?6]oP|SEJp|%L>mOqD`#F3o^<=?Ve`.[}Hc[ygA:>,l[m0k3cnq>5W1? 7s:~\aYc]OV^ }knO{`2Lt_V99&>J)%o_*fSf=Z4 r\X:WpNG="\|xzSl4}8G];x'SmK:}QU9/oV]fYpb+QdAdX{<-+=w/x<LE}>os|]PwRXp_nq;>X%]/q49%Or`YYc?Gq@]C{oMZ|V3_qwW[_g+W%u{Q>2^ruxdOd0jU..[c1x8x_oGtmwc>0[^=gh"kGfGf'"vfbR+"&n=>_=lGc|4ehs{>0 fFF;kr'[(<Rj.*ss]::-^yyy=j/l5qHh/Vq.uotx[ks[Z&YfQuR|b9|[YV|E9PN!VOAw"(hx8 A2UQW 7j^hQ={]O:/)^zhx (:H<K@O!v
+ZXKxrC|3srY'
+V1'$AR\tGPluR.S2uRBS^ho=uw3#>ekGR;LoxHman,fb|:0G=,{yg4T\gV= v7kw'Cnw:5CTS23&4f<|3\xoM~s[,{%h{SqU\1u.qF5}/~xWQJ}e'x<
+8g5'y3b/=k%:Ka"jZykZb8]Kt }rjj.RK24ib|$'H.%i0srViuvdsvawa^Z9xgW{#{vD}{gF^9;0r;h5g'4D}$IaGmlMdcXof8wcc{">~ LAyNA	w8Amj5&':NfNPu&e<rw?-AKL:[nvS&C>=2$Yw<Z7#K0/rYn&O.n8Tt j{X=iav\S/)252$P.07='3"=_'e1R tu2/}b(fp%n%%bN%#Vc<:c$W}l*sy,
+_%O`<V2$gNL]28mYzlK`7b_gNW6,DsOn_t@/e>"uo6$?16)87+ A|$yeF.MWEhGya8i 1^r.QXC`]vLiYs8
+8)_$ly<er
+lF2	wRsvSTQJa^bGXI'y0gxIQcY$],d[Sw=1Cn6g<s^S<Z+xwkd;W>30Gj2(i<52N4;9L.c/WMY)k{-`;1RD:8:6&_`q|-A?7m1qu`}Uc(#bb>s&;w
+=BH?efs7eu,s9*b{F}sNi5vnf/i.]EeYnJ(	w RsmF[p^iwRm|S2?'p!O;pN~5\7jI|E!~~}:f|/-lc>g9~]m=6`wi?c\Ob`<wz}mV6k?'2O<L:58o3wTnw3F#6)ne"NCM>~=Qbe~yusCv}kj8J@c~)P2k|hmCM9yNG`58~@'j57KE,635yc	swd,\{G<I
+M#V=;6sH89sRkLoO]!d*~_ZHGy%nt1<aY(86'
+Kzx\!Og'in))e&w mhu+RX1yPJ&E?9Ns14nV,IN1f_xYc''PdUw^8CGPhsAgu6['^2G=NH\:WsQf+s.~sp!fHYhYn1!g|4g$c9x@0={c,hoZ.yee"'gY+b'*8Y~Dx4p#Mr;zB\c9>RVCzz2c(3,|ud~/gFg`72vrrkplyd-ku>*s>Y,K3G?|~\>r~~6qq'^~zx<twO4d>j8p]	(f/1C:"F'O=Awg:wOjf.fgMN,O0	K>`AkPx~R[p]Hk!ON=c,q;?3K(+U`iT:CNp:`'0u.YpbF+H-0V&d[iY-;%`HE}xo5W8"^Qo_gy:.e\x|}]~.b}gRN.L&ws8.ILm5<1Rvl_"IUYfp|B*~01k_2^\&@!sJR?_Tas'\7v;6-}%|o*x:eowo<^`q4'o}Y~XM"[$rkX#~GaH}e=#_kY:n}X.	qVu*CF<_}X'3]2&6qL,	
+)%IEe)]go5YG;B4vv^kdh22VKYH$XzI;6Ub]CesCDr*5W\:C[V)fe)^7\)*WFP0vI^YiAQd-q/e^H}wJlz}w*M#"	oF@o92F8.sWc2w:]QLK-KsoM RF!|Z|P/{zi|<(z<aI\t:*sos(?,[)_oOw$OuPzCZK\"L+!]-1cs/a8Zo}qxA-|kMO7i^\6i%>zc;9cXgx5VIEFI?*.6Jt!0 *i~~MS+7+oO3w{,U$(,Gyu&F>;<d;?/!{|~gI*2mR^c0,oUm45@<jTGmn.uZhsvirVJ>]+\m,}otWXGOzmxGRmy)/2jRA3k>.o	lOrX2,N-}va1\wZ c}WqO+[}
+w|r)Vm]iVQnkO8sCVY`Y4Aq7uF7YE.e"HAyg4lkZ<;?>D|H6 qo=veEoOHy'2GbMnHRw|IG,tn:C	36
+qaG#xj{3C.m<9)s.XM
+/ lPoT+
+?8YOa[cbOIoCb?O6t:Uw^6 8ty-un? l_"2y,=|s3O mhzW!GJ.lzl^}Q}uS[p	_?<&6/~1O,h
+69G3O|>uN/#Z%nXbmq
+g>S=u\ex-=;p8CCcFv}LYby@0.'yqSi[
+=dn}PWk\Y+lJ-6~otWFUZ^Lo~ru$9Q-YDPpEt|	x9bQ(!6{@l
+gb?(.f|nEbk{/3h~6k7v3szVxxt5Gl;_`#6Qk3%Neut4[QqD-nd;G<2k=F9~\l}Di4<y1Ze>nlnJkObL=u?yJQ}k;U[%i:2~+sM$Z<1<Y_|U[M~ZuCsuErk:/PW~	{m?$5N{2{91JQr{?dI{1bS1Bu;GeFskIxVmdh6;4-svx4sNF,an_E~~]tBBXawj>UO[7KEWuRM{)q/|()1S_|o|1<~7I|^1M/a{8ls|4hK\=&7z8+P+Ut/-IGF>YcM+?z5IWDcYMc\W<@2ro6Qp/dSRp69\goh]!
+zmck<!dDq!jok{IG](#euq#eF15Us&<!*-+&$|"Y=e<:Y~Cx;vw+x%e^~IPo@p|TbrBtC3&8i/X2Vy~2d9eU&7}aSilqL}gq^w9-Ft)MFxXm"'t'5KYEg)_	$FM:T6klGZ:?x3F 9buy9$5|iqA3QC3d^.:} : G^d*;8W#G?Zc)/PU>f
+s.qSok|qQA/N|~Ol6ts>cj3bfHP56e7%6$6KY@I
+,r>@|woKGH7-\q]y<tFAq=O>/zx8&.AKSg:!wo">MZ+heQ'f{/<c7k}K_pX4r^g?d/wvks;>_2S_6TM-GMC+-3 b`zk7L>Y7:vAXk{;nr:i~,%w$fEeqoVNtTlb(>O-]w3q"vsh05f[1go^WY(c0x8XiQJ_RtA#/c,0nJ.<[y8!_"N!W
+N07O}jXo k]Tr\q,y&bNF?E}?0m9wst<XZz9 ou>0d}s~!q|n	YSc72S<Q"Flm75*=ayCKr\)>_ijCy_Oro215x:i`2_?x(At"nrO3cTYESM%n!IyR(7'<u-'^20oR,6Np-Uq28b9-+QvK,1,M9W6{9\AKcJQs@]&DfG^#& -,u#(wU0J95%/[_U'D,Rr_{KwN~qol5_b6GRT<)cjOz}4(?^n=Rr*}I6rwxglo^7d+=1nb`(9oo={X#Osu8)Krv	j*7`.T^1dbJ<c=rKqg,)O>Kg{k HNC?s_EubK<adF<PoHBFB?%JIQntl"sgy#N^rk{xRqw]:P|Cxt>dyCYtO7iEvTR,Al{U?kcN6:"U+eb	PhV*7'\g8/ _Dp<v/_V'TR4UZunQm[s=POk_mb;y*YWn{o[Uc[381:--l|yQFyU=!%/y' _mB;,7=#cI._~| =:a8Z&/Kc1 Bb>8?g'IhDa~PM[/~TfZ-#}4[.c.,y$/ZKzs4r`_dw)9PHY&b>{)mu^L,ns](8z?wZ=bb5;7|Pv.`>ap
+` {ZZ:YC@_=@&-^69X^S OB
+#9ogTd}]Qta=ic]~8eP+\aA=z\<^2OMi:~x}`J?V&RPvO?+#u(n"%<%h_K/?o>z2~B!3>W}_7A?I{M.+)rGvnF~
+*Bxvbk<']g~;\m '*7jp0f7T^*yzS!k~1
+aT[?ac4+&=yWy`?!_;vX=><A{ka,o,N8%;/[ z-;GK.8U{ow2./KecQrzLZ#-=I#0:g]?Q^#$==:7TE2%Tx<G;u^RG}gST=!PK?do)5k7}kBQ>~eS~~>/V8rXM%l~#1Z'OvQg~CscN/5lgx@(5~[{7	 y[4c'{vP(Kv'~Z$!o$/4i7M/I`-3so1>*A$h]unQ>;vG16r;6H9GaHJoOV4l7"G:(K]?Nk0VwQFxrqt>w|_8C]gl}'&;:L[d_'\9Elco_ew>TU4O["G}do|l/1RybkU]0=&tb\C1~v,I;BP1oC#Y7d+'SV8zB.!nEVc:.qDcM2|!c}Qlk,"zp|sk;i#R2NcK*?s1o(3^36f93.,z\O>=Ci{>1fD\/uYB#/ZK	_-PcWY[Hs?jigGz_g2--zex>{/%>r/VWwO><0=QQ
+kS< 69mk?nAe>OEpggI;S]k 1IsNX>^}NDH^}#hzE}X|xY/_vE"I2
+}az,86}Pb
+IR."_G:>Gr\jN$.`*8 m5jS~HO'suQ.wDWMD8?i
+wVoIiK{4!meEX7"1,Ws0aL1	wyc#yryY nj&wBfx1;zDbp.Oc>'9Umwg~5Zb@NVE*\5&_SyYl#27y@uVfx2?A_XMBt%m7LY3gL,l,/VIryUl2>'cxC0M@i{u`{MUbAk&c_gzOs}4>W=:Xi}_<KhCE?.705SN4zzu11|JK{,AO{vbyl'K	oQyg:U{v0txN*psuclC;g_\[/:U{$F8a/t*a3ci'h-]!k
+va{^{tvi~lcdlbSl#b|8~*`:zSl[K~pq?Y=Skby333_xt1fo	E9:h^=rotw6cOmuEFvBA#p-k,OP{B\;y8GYWp<wW{G+8/1"}#p=:!p`Px}J_[wh'8>59}W(29qP7h1H;l%e=Ba;)v'bII>X6(3$?:*+H%7}^`[2Y}l?*U%?q\8l'b;	)avbM~m2JTE<pXKUN.9pHt~9t9_~-9qocdi/k/)|':XF|MgMi7k`^z}vtW3FGPPZ^MAoWZk,)y*:M;yK|O$-!VdNVKkpl">.g<G(rh7e)Gy%{4jwh?q_.E[BQg~O`y8t.G~>^r};qKK<_bw}qq4
+yr}sIk6?3NuFMc_!-Xt3P!5\G{~pd{w}gi~3vW}NsNhGSo$NiK;PB8i!,*?O^2s7;`<(\!d#v-<'xIw@&`OGF<:KK,8"K+Xan2G:	+CA^LPP!teY>'>A,NXQwEU<y6f5it=~Ox-Lh9--G) )~g+tqm|1lUeW>R&qy9M)1'4Hs-Vqkt 'CE~iR4gT~ 48r>|z`sktm	HcJY;D8+9]b`^fo+zoj87Z`_kY^%g2e-}[pu~U'no6TUmn;}!o;A9Wp^ ?v,1* |kdQi5^Za^(OU9E-]*	
+ gW"wK3xTf/`	`&HQmmRr^i5_ Y5=Ut\|sm.s~	eBg2`/*:R^/>\b- T u] WmYmbLg\|XN,#:PYyG[.4N|trmw3bf=BpI.4
+Y+ik F*_K%561]R#l7g`$pii`![9WPEzFUl-9PJFGI*rxWHbj&
+4?>;
+-jg%<b{K'^ij	p'jY')Z!BBoHqr6"mi;"55UYD4V2*EY}AqbI_
+73eU1nx-x}`Bq%v>u=e<"_!,i`}ym?FxUbOE>GDsWh$$!3<V	j2-)<-=}~AWyONB03GCv![c<8yf?;O>]G8h#1'j|}Qvwu]k{XWiB5I^Z}'-'=>VjY	):)B:Y^bjH[MahMD||YJIBo@K^ECd)rWHs(`0vMg-y5==lO9bvwTKoD	eaUfMwsHs~^G5M"+DZ	`!Xq;]qL|d1?b4OLU*~^1?q3|<8Kz
+w8_ %yJK~5[=';Qy0>XKwr+F,3uCT;>7 vz$a5yZ#+8|~>af
+_M>({-e	43wTw/nXujO`&x<FrMr{37>-o?==XzwgQw1hgN&}JK[Ol&hsz{X5r'%OP[EZ}~YsCn.2J{A4ciK6oX+k*xd!?6i-cx#P~w2C%e_#7E5LuOAh'8On?B|Eb> |fO*!Mx>3cy4MTEWtXNEFi)Wva>QM<_S~XH\n)y~E#FG;_!\> xa^(p-FmyKO|g6?&I,7bOj~}@m-SIYcowg?=o8o/R|$x+>o/`|Y4xSz_q vi;+.{aplOAy?=t0y(/1uF}f)^]nX9H:?RvCNQ#ZbK"AdmyxH%zk)ltG)9;c@*Q@utwdSH} R_rcnlMn7P{Y4NeR|1w	]Ks}F]9 O-f/k3m{<KjeHe"25a@:Z#3xGxT1C|FbK?U):`b~y~ >eXW?A>=2CYn5Kt-?gH<(s'\jG]GzrP1X3@;>;-X=?K2n5=C; R^9o>Xs._Ts
+m\#keJq1Pn>_!c{|~t~z\}cA?=@Q|9K`z^!T^[Dm-Iwau.xf#~(NVnhC73]4 (yY%MHy0%bGH>KGTw4fO^8R.HdYHlMRb<'>Tr=sHXqn lw47JSjQr_IJF[tA[QQp'|6X-0ZhyW?w%OO2X"%dVg>/NCLs1>O;8`m'^N0zeG#^ 9oldw@_
+9&>?/!DOZC/L>(|+q?z8U~TZz;'smjzE<k{<N/^y2M{\	;Nc*_^rnl|;8[_\c-n3f5hi,sXebe]Xo#b!b_&"x8,oyG(k48gj#;Lc3z}pU:EP0,V./26FKq6wzH^g3&'RS*|#:9KLQFO@Zwm<Nj4Xjx>n%gz:9]h>3cO4St]jYs*ys^uI59O@z?^G]`m<[hI[kIXBWp27{D]-%5CrI3f(H')/5KAtgH?6f.]H"[7~t3_~'4ci7]S$^g@g*;7=EF[X*_f|>3>]ZeNVB_h"OK4O1;-=LuTt']Y6>E,(n;DO[0w,^~xeZ+ -HxDO3c||di|0;hx#rohdESl*3ce)=|;3onn*sw)'{><~kW+qk`97:CGRc-6L^NmCM,g~~oW!O:`Gvw IqHKT1mw~k$_0:i|}Hf}'xvqtl/55[yc7; 2=O'C^Or5w)8'`K*s!W$r v`<b718~OB*qV+T`|K+MnQRbQ
+RGbS-S-c
+N(fec{sYb#S@a#.m84a>C/dx#~Q;"')zT.b;2{KO0;fJn/7K<8OQu c3'yO<s^n&cA0ku=/lq>OfuXFW.
+XtZ
+((N)gO
+cd=b9^D)z~k6RD+&>%7h$W[I7aDKn6m vw`sw86"MK$F3S7#9_Et:44uUG@>J;!Ex2GbS4GPsn yk}TwbKL+HR5oVR#xE^iEY]Xr/=~'}rT>`.E|V~!X=.uWa1
+-lAbJu$KVmBc,ilk>EoR-
+Y?rCV6FlHb%Gnx
+2{p}svSK=97W{~P/!xJl%+j&WL<Pda\w"}Sx8=w+mb21G)feR =M}-?>^>-:K$Q9-w>wo#)5qeIe6,JyXtSB_5Pnl >(w7F'Cr~G`-bnM6*IlYe>vU+|I"9LI4gbr> k-|+(:.C5qgCIV ,SR6.u3r{K5U<c)+Y_FnZfR7i:.]U-&TRJ,#;)j;;EWg>+tmC3U&*R>[aXA&r!KX=c
+{wCNl/5WuF!C6mQ2/Ci(+D|*5/iZp(K&(;kL).9gtzk1qQ~'&^&
+ij>Eo\ sPl-2Wb4/98 \]wQ>iIVHfTos91^<YrW#&&E1E~(#5e~+|QJ;w,EK4O[tu8"S4G#^o?cq'?6v@|hu|:H<\77N	Nj
+
+BEO c~HF}t2>Vsw`hks
+KOb6}`dA}snX^Y.6F{$.yJm"~9c5jcqBr-)*)#Ny>OO1-__raJ-4m3S\'$tv}}^soM>m2Kis6c$CkZN4R/{gwHO&Q?~/*`^=z<#{6.I9mo<28g|9w|9b{bkgSu;u 9.?n>Dbo|W(>s]$bv^F^)=,jc]y9tks'h],O8
+)'hVwdXb(`3$*1un>CMz!`j_S<so'OyrOi85.a\ops/|wmjw"]`b Ej#U3/UNgoBcI#![_(f)_0 >67},>x~OLE^?}oJ%zCxa/Z*vpYJ}>'p/v{YIS'M.l`0 -">Qn-"6,zEuh3n|/1XSC[MIF%?E$I3t}\>Q>YkGg4~M~u~I7a[Br@3Az~jd\$&v:n3oZs%c=c,STiEWvf]8N$mKh8s	*x	$,u/ej?R	N/q01-i/<85
+goK[`?*Mn*0~6nO!O^]qkSr~%f&o^!U{ocO2U-kqx9\SMnQtNONf27
+B+moY/k=2T&Q[hy(&k.	j=Mvi92>p%WxR_(yK*D_#{'vi<53Y/lT-V~G[/0GH,Eew,66XwZ2Dc0`kG<j:9DG%az+l-|)S`KaOX))G^]!b%0yWF?jqw	ktw,~KN^+]<,!_;"
+D.ewjneU1J*?lwV,mb/LsNyP.6?)v=#fz^k'kf]jTI+z)}
+wSD|gt[%&~|3r9w|3GutK[ila)uKx*_L; Bi0:1;S_"-mC:aawxC#HevevZyH,!3;CT,My9GuWcW1V-U\
+~d}l@R}k_,%,(Nnp^SGE)-xA6}?lTVh\e.; Wz}&ekbn
+>Y$:(O9Iu uW?
+9SqvOdh8mP"Mi;}|#+HPvjn:A:#(M/+d]m.;\5u[&~8^.y[1F?npGTbSN{`M<x2b?~qXe02nYE#zx7[F3/`YV1:yq~/W6>xD>~mkff-W_R JOs;b-<+zU7E|_t%q@H=Q^f)3/s'.zTq7\^#2E@)P(M2%zRf	M[dM}ky^Kk2^M1Dl'('h+6rEW^P<-b	+cnGLvG%WS{e=.|rw=M~2XOGYl+(yx?$I==C=+EY.vqOm3RD17 .q
+Wh9F8/+Y(~t#v\0}c{*6m=efHy+&f6EKs8^`$QFRCwq5^SbQNV0@]}[#c]bxoiGHs>l;^dso[JGXL9/6)}yNGZLs9w^GO#Qju[yY~5ImO?{-uoL
+6,|I)3ZJmE{XTX7%e9RKQbyCJ?OQkc'$}* -TF wyx@1rT@p?g'
+Srw/cv&=Szz7]ol^|.y! rC/di3h0kI?~H ;Ttxno-Pj9J68,< .V	z}|}WgdbCJ+6~eI:kSo9%F~kHG*Ps^9xyQl3G}tVl;Jd?.|lA#qm&b->h3"Wm$}%V<5T&F8k[!;:~yWqY6	9a*MOlsgt2'GFx:0=vDgsROgJm3$f1x/Q[{D]G7]b>19wNinL -Cw4|Uog7Uc\D[g+e6B	~vKhHKCB?vgm~3x\}_cH{LiJk"e=~<;"lgjm!UGw|c"~G[%{[Lb%8@9%f<`5IwWgIfES
+5qvYc8_~=`<^`]YPwB M>MN[.egK2n5;lIve|:Mrb)~3qjhw=9&|gN4u.;K`*,cf6:1cDOI*QNv[=;YUK7:t|\]o=;4v:e~+t'ifwYcot+]3m ?cpRrycIm#j_,L]fkG>+Y}~	GiW*GW
+x<!e#M{~oOS:3xoYi3gL$l1,=ma.[Nljs&I~)722rms+5O#iuc'~ZNA W{J;|N3[\(.<YV8#;mSEq2o2=xN}b.oo?f*=I,5kO[+j#{H)z?*Q,T}=q\u~dp<*qc[:BuH_K{SXf)NWLkq<Er)yoVb'_uv=%Z_I6~GJ+XGynG7G1Y5/z;T%5bH/Z)6$&)j*_}Mt0_5v:98oH;@la~3[rk<Y><woX1?tL<_zuN'1E3??PzqslLfNh3vDn6wE/bosBzfh[jkW^RH\-uK}:606va<No`_wc<ITss$jx(1	L}{<v/	"}]7hc,n9_0H0%7>x~>i~^[G%bM9/aK8MTo\Gq=eLr	xJr}a#yMv$sSU/'	\qjYV/-^GuQ#Zv! cn9]rvrjOOyBub!_7cn|T|5<@SIwQ;bDgt|3XeWg*s|<idg{K!_8@~Y $vyc}`Mm9/!Ft3b]qShPn](iSmK]2 )pee][h:q)Wbdoy{xFoc.
+g&=73BP(sUTdC38~gcO}?2&#k!vQ!_qo*n;&iqXE;Q:~:1D^y:)F}'#5ib>g5u7O|ifKl+=b0(Sx g568mVnq|} {[QGVCFXI:9I<%Qi[=mVM{zf=~|8#7d*9Lt/h^w^&-U5:zm92kuJ|\oZ^%V/9l9OU5 W_+6Bt*a~ F@]wbkL|,3yK`l@lt>.+bgQ
+9^&>/YRL L2!W*di0_
+y WNn2
+bLu.bqjt74&~'>pZw>Nc@#@7y6>Ag&_GK.BwoJ'Zg-=,eT ?ib<zGoi>Q/`IsOu</X^E[/E&E^/-n-8L1/waaF19(>Hu%9?ixX	NJpYsV4{~/5-n-%|snnmu[r(?26%>PCH$?C?u1hx#|7WZ\eRMYo	0>;9fo)?2	kk_ i:RG>bcrCiD)i7c?2?C@1[~<y{m>P=\dRG1Ph_gP$Fc.WQz6F\l4\}}U^e|<v")1d'M(>^->5ss!n(kHEVw7}lr`{6XkTx9GpZ5HaErX{(B}Tp);t}*W u_-M7X*.90G%jNc'q}7sG'Mn5Cmp~.{O!{5z-u9RjYn/ 6k?Bv4mI,YGY)+j.4P\4s:9{#I7@>(R/(u&,El#K%[?"Q^x*'[Qch:Ql9wH>;E8F]~a^n4srj<{;'K/M#Kgb[S0lh!6eK}/2*YCovafi{As7J>#6r$b?$4`u|.23tEEove7|cLB7hm9XD4`JOtIg~K}>hfU	;5OH+[?^Anz|=XECVggzh6eC}yqhbmN2,@eq!9OJ9<O?ksp/ksSI&3xP-a*jr?i)ElcKo?),MWP=o(8N45)we[CT[^Nx9y|yB{7~m%UA;nxe5.l:
+:?rttncW|]k&m[J}h_GY-vqkW1] E6iB]g;>KD.H2mo?@D)uv6Do*|Qq'?o0nVSykx`PY6'q5k5}MLqrf8:?6^{kGZd,#b//V=rM~zBrK}'0={v)-%k>Lx}:O$R>_eZJeagUYn/bK{)7DO\krR W~x#0c=|>4zE?i_Gb_|M<x?S.yJ&j+R\~X@}e|z0b[XlR
+.OJ@ft+N<	uS5q|90&?KyF!/Z>pL^>lV	g>~p-1g_GrnR1$'	tO+htj.:o]6zb-ny8y}]?NOL'>;!3ufDYn0,S %w?K?[]	}(?l]g/E?O{	d7c<p~(xS3s;'81 d*^}0OvQ0Ab~19Kkc_eZJgh})f_Y*n&8]bLs%SA_{c&KN/$6>.#J_XCOqgH-m o`GR!6:iD|HbJH`m'&*nf;u^FI`v|OcV87yBj4UP5X\>I}H} vU{;|Y/N6i~*0wCr
+;K{yU">nWNgYGH|<^VieG|z<v;/%R7mk= 1fl3/UX=}k#4cOkNIO|J
+]O4X8{n`(5kFj-Sp,svZl2X}Ni?W$er<WK9+WSY/r%9+#o-n>KH?W
+:ZT[\ItOPLo&^:yZR%]S{nou86}GuOVe_+T/s3[|^wg'y 4`xjtj"';W4^T}XzES4B]vSu:{~z1gNOdo3@'M]EG7RmD>n<dg{$x-bw[d1Yb4xu?8IXs90#?=Nc=!L:Mu(Z9vs(s=uf;2TieoRBS>7FH 7o<m&e4Bkk|Vu!cJmd;Mm?{ gjt.xH{hS>~r1m]O-O"m2~M:Vcn0:6{	kgtL<x~#3t;Av`z_0@{eU8_\ywu?G#2o+i>oX5b:}p(XyZu)g)SwZr 4|6|b`mao??!I~I|;wD7i~*w1y!tT{w3>8vbmX-`\cwY'ck\aueGbuR?"c,
+<7s]B@4/t0x<OegqRL"AF922vhO4?_W>:k9bs~a+3fyx}3^Eu&^?iPqy1ba7\<5cKi6X|\q8>8Q)d.@N&?WS]R#
+!FLC2NhytBCw<*_-GGKByB;&J\%I3vBo~C}i9W.dnYRm.c4fxG5Y7 vk/:S`JHs2o8 p}lvi7x;&EXKEAB/WIF=,0%1;i-E+>}E}{Bxi%(k	w#}=#l`WzZkN?bpk? Ko!FK]~c]IY7="u_<ZrE+%>;a=pwb]x*TX	~8#7 u&WzOyH-.	J;h||^8mBN=M>[swjd9GvK>*UwXd?'G*Xw>3g_S~CTR_bZM-[AM"~uedl+[Xd<?Cu'Kf?xa/m\vj^hL AZ:t"i8fn[kw,;R$z^(t/j2g2Y_x7^c;\c_ f1!Na1*l`{
+^v!U[_/ID0zFFccMHV0jG4(e K:>4yW *<D.zZqC/|nOGZ"v*OK9Kx~r.X`b9);i{!NR+1<
+w[G$epX:s8+wJS=o&
+:Pq>F-	~+|\_Q<b]=yHb/~xlW*%" yQQo!:Xk+xq~R%mBPKAs+HPm?G
+}gY&%6]h&-!y7}AyvXWcrscVMq'toFin&v/ao[HCc=[ZbnWw;&q_$/s&>zV/Al3	Nh.mC^Rt5S*0~S*PeG}0}mGR=y)}7AEd "5c.5m}v.Gopv4s{r~1<bWI|<^`R7${.XGy=rrwM;31CFtY6i#NZrM]wmnp|`NMk\-wco?x	LCxhp/yyvWE#M-?
+LwV'so#NexA2,>B.}1-E|Zl(KzoE4_5":t<S eC-Rb{0c,aE\3[-wlt*sl'<zK!|=\6H{u9N{'_0dh;=S8<#zS"m=B%}x._5xMNh m{P%l)lax8qm_`nvw=qaO<?m>BPl5*|I~Y,;lRB3gO'iw!.[jb+G61.qbuH*F/Y)ZMLl5-J=RvX?iWNs6O8[w;E%UWtk;9}0||TRYeAky-IdrkYX9*"\ I~ro^9[&2	dmO9mo{?VLP|K/H\q2[<rB[gbuY,tz]}H%A{6fg3YeNc"u+^+Nz=,
+U*'er$!+p=qtK{<i]=}o%EJA||gY_p\?K[1qfiq,X?Y0`k}eO(Vm)bou^%Xx]etqyn]F10x\\/p^ii6K9Lp>
+{1Du3cOTan J>L[$,Sji1vq}+'U<H}{Y{-3Ml2[rmC>'yIWVKw'~kE8G^UUa22~iPjK?P= tE|kfX-gTT}zF|[g"yt.WD3wer5fo[e.D|%j/H|gVIRcO7)o?6=9?Zyg"	xcUdQ9d9I!Wi@~T2 ^=C|[&6_*8	]BRJ\m5Qo0eF7^Mcy~_r]p.7v5nMS&UPlXR_4Es4?`{GfRQ"U<<devt>-yURyT/^YfMb]O(lwku]7C9O7pd3s62S|D(BkGZ1VWkG*g5m%	oc}lrEgP^?3%0_LnMkGw/C%l'_OQs5xqPZgBq~kOCKNb4W<?.J/uEnH@|32`W$y,}yeh[L,{b}q>_qi;wM\2qyO3$s?HI?)FS{dm`U+*6,JOE3>xfu~I0v.$s'`y.+O.|C>{%bg<i:d4Og{~Y\MIWigoLZ:G>K_
+YPn=Fn,J@=`a%R,H|BE5gwZG>=:2,1?~'_M?$*hx`D"#<6g9k"q*S'[B=wlc3c^eI!I@"FOnW
+u
+l||h!q,z8iNdT#G,J!;IpwvTYI9&w d
+qouV/aEwN_hX2VtaqK3eMef,)#yk!m|pXVo=G,(Wc[/DH?LE;n!.G68h ENXw}361FYn]fN7).B0n^j;kMuNL\9`]$tEu&E&G]G|ybwa~jA264V8.}c4OdTRZVr,?C=k|~V=|!yPk+6@>Fu18&}dl<qo4D++]/#m~=fuPeBbGb9ja;2!-giJ<-J,+G!;0|"+Oo	/1Y{a D/Puefb'9oKZrFz8iu\<DF7\G\quW:bYY>?>ucsb*_T8O0FgEC`5L}Hs#ot{gn#qlqrn='jsQWOB_z.	<arhK`tA8/D;Mu4{8^x<V\"j__\6<FDNe(lW?Bb+~S/	K{d|g,{<
+^~QB^QnEBByK6I{/P_rG[Q+.4<x~|Anza%FfgfV^
+m	Y36\xxV3U]t8%.c{s8jkmvwGK3Xe[[:~]`HqD_:{/sDYbKKlC}_C\eYKwS/#O$>CZ _^cXXv:H[su2GGpWwZYX33$7"Iyf>q=7tb'ZAV[7d-;q556:9ug>%_)>W7cW@Oz4\%}8A3vi2W}y`gU>v=-;3^oHwa>'QG\JPMx.z{7k@<X"n_ M'u!;;#e)+B'0Kf,Ks	T>RsSBxxB4q0i*(g6b89)2)Hm/fr~Ls'}\U0L}=32>xGb
+yfv&|[Aw\o|k%.O9%`i1^*hmp}H{ll1{r)M3omb0%1`VM_?sf;2xl&)2S8G|3%U]T=	c#Yck_^OzKycRqq7[:2G=#~rrK6D?>XA/:Rc9X*p]fk/yL;c.^>nW>P}${/6y
+lb@{s.FcwZqW?5'y$/oFuJ>	Y
+Ywu<4WUbN>x|A5yx/>|Zy~hB.%B=Ve0SM&
+vWWch33-bIp+/siKAu>ctz.<zZ~r_n~S3^35uy`ZO::u/ u:gum`ai$m9L5X!olMyfsSi~r^VF6o3hx#/E5oY[MK3C,axs]lz"V]2Y%4&Y{G*VE{Rw'$.cEum_s,]nFmW{HTPs'e~a\ZUW_\A2XNQPA}Gw(J^Ua!~ vlc+j#\X!SxdA5yR].UJN.O ZHq.OS1k47W[vV
+|0|xi'p-`G;5]c?2M.]h;9%nOZ_QLw>?<mwX=W%4GhY%z30b*[>9vn|*\{Sfgxk4!`MaG3NbTK`[JmhHxgY{\:Pn;EeoccT|o#	bFFu-K=L{vW-<Oan)x2C}P6]c&rWJ=2_tFd}Wd.*#>T0WUH.#oGg<+o~(/f}W!9|?J>_&V!~]E]a3';n9BE]Y1aYC)J[ZK,S`152oN	tow9K^c8ZC*{SR<C?519o7dZ?aQar?ha>-x?%MPLD/8}/C-vu`_e^i~wY?mR9>_KU>}e^(
+vk+wW%Myo]>7oocU_AknXzKGV_YBEuXWWbx_u;[{T*3gO#ckd0W{F4BB]kv#"x%V,}\Cg4g1NR2v}'7F(c&@O^0;5RUUi\^dt5r#Wmq9/_uP .kaDZx'|fdA\g@DG zNvtkamBX@3Ltx?\5g-.\\j+m=^H}U
+lLLFy[xnXx)^3?[:Qd4L[lid<GYF"|iya+3+[&?q??{%qum:edb~,u@pY]+qM/tV>7|kSt<r7}NJ6C+>X_3/*erU2N{(E=q7xm5mccFjIXF,,w3e;8\Ot%G!@d~:hKI@^uO3i[3#|E61S}_+5O_$}g(#tG]b2Phkdsv1y${7R>^-\KiWs=#JeQ/>9`]H;GZ.w"T.r&O/Bp_h+oXz@c*vo!7aFqJ6Y9e\,/c,c ?|?6OEYdTcI^+]Iwnn!hOu[X@I"mX!,sxqkbsg8mto]%:nQO+	8[\F]nWJb}a#hrB*dvbA\.6W,CIh{>_uRj!W~I_F?W3:mdY0 T(6=H>c`b|I_1>D0zW>!]>rRD&eCgOW(*Xf2w%NY=K=:-qWn5r6Seo}9:x9bgL|SWemO.^%RW0}!G?!k"xKz=:0k+q-{/`wCO-ElC5b>C])kP*Mbv6a%#>Olu3 h8g92EoH:9nkvXP%8D[[sk [I="akY[CIg@CKlQ/F<m4nThd['9i|gM^tqc`lPb}]gy8ICXK7V<(Xo]y?-]xK0*Vq%#;zzBP3V_$f{RG<&36"[eB+hv0aS7RB9C 7V?Xv04l+jSs\ynG<jC*3&
+|"AnO$<}8q{^f)44~%_ORehmU:+BZTdoa_4G=iN|D;/,{51wq@_c1XX\~4GB`=n8}-}r[.Ne[>flx<;mkZ)pGcD}w?=v3z[$OP^X9_4*1cl%?/u[@jS9J[~CC'fi5/}c$}1b'.c)EiNq7"#%qK|.`hcMh+<{Qo_=Wz>3cz.z~_Zb[8Yq*%O|x+TH-^5#&c}SC!nK(OJSw DO?AquPS6vAB{aUykq3Oh<k<?Req&)xOK=`bbv7\(O8t/.~,tE~ tw^[{{Yc^>F$+w3_N kQ&u[G`J}]X_},[[sZ_~sni,ihFuw f*cHxPwW%B93b=6sw`_LQt f|Q!KN_pJQOe{L3ct::j__x:cb
+|\_\9<]N^,mTj&gqu.|"txyO
+pNuzMv[*yf6ZoVs^2`<Mvv%:O=7WQ0
+SQo57sn|fjFrLe.'?sW|*9i>e},Mg:3TqO1?ugyr|nz>~	Q,C>sN|qsOyl+i'C<&la{j#so86ndu3">=msm9q.%>m\tIV8F"FkMu2wco]|{}gquwcS}K=,g; M^v-Gi%7FKc}{[YhZ.MBy;-W\-vEvN({.6Y:4Cn%y2t5&2>)/s%m
+DVj7f{{r;>Vs1_RmE5?(c@[I/+nreK4nFK
+5b
+8/NGHi:Nz*mAE38C%}/|,
+ZKQ6i=6/ea=d7j/ZS>1D>}Pl\ Z<?v|tV%9":YILC*GI[+C[fg@l{_6z3R*~B+7yjEg7/Bv1lCnj~G=k=%7~1:ic|EKRbE;~l$mTG~AzgWa0]v\ucO2 }rO0ng
+=\s]k<U11TDUyYf;M8n
+%qsc8kkrx4SK:5U Kz?Xc-tisab4,e5w&gUimO9! evrk|t9n}:??^}	>?/(.{>0s;$6|?`=y?`U1N|K~%HnF17N77([RELy^C?.Wob<|!_y<Xg}a6YT}SqVCV!?~|1 ' r>s`>$3\,)-1}29O*-b+=Wnq7Z~vl3E=Z%rr)AyW0l7sv}B{J+~-WOP{%**izf.d[6\a2;s3flF(Ojv'jlQ9;-%yg4g?9Koio}WJ%:.XQBD\~>/YLF<b!:V6B{b9.p=WyzB366>Yb{@uE%~hq5G^6rY)k-kZ]?=i|6N^-|C'7&-g|f!FV\\%b[#&~scg*vx{X0&~~{P}b=}>s%`?XS$=eWt_';'~X?:(m0dma	
+l p#;z8UM<E<Zmg &Qv?Lc`uf'f'<`gR,w1d'W;gfM9kKIkq[Zt}Wu&:&:}\k6'n,4#J_X{`8&1os;S6+ |$XlC'cSa%ro\D+`>_U5[qf6Vze)1m)pt ^61"]Vc%v}Ug0myMWXCBS%M#u#}r1?YYF_p[}Z0sl`<$1pZ=[v} n3?={9YK.0uJ5Snd}{4ufnp7s8G	DvX<)UWceik-_Db&*+B|GsL,mC?^{8&>+&r8t.gK+{/$OX;};-lJ>_7..-O^(kL;"%Cg/zJ3nF}X'Z|71N+|5bSx9r(3m(H])5c_s1VwBwWpGIF=u%V}@;}w?k,!Xz%z,9f~c[9
+,b>cp}_Gvs#79?6,0M{]w}I7gO7`A6)tF<X{dc_o/wr9Y;O7].J8"/>O}&4xy7}v d7[P-&W*}^\F2WoD[x0)ua67?{Y+(9u:&jPg:' Grzm$}OW_}V!&3>)%^T"qs]w5V+/s+X&)(6Vs5^2~xLvG>V8x//O(zNL6Q 1?"77\EH[&m?xfiV%kq]!*S7x3v2Qi_m}u8r6e;tb57rg9r+kz><9uje'/_R~y
+&m\YtgSA9L>K.t+}oX	kQv6chZFY3E9xaGkN<x/.dL,/}xV-?Cwbp {/[?%z:3][&6eG3r^l}`&lK=lC~ulC`66am'cl?	Yb[WIPi?`Ork8l08ceL;f:'W}\B_V)S67lx)qW>9kQc`I< ;OhohvKk5qYafNkFE>IuTW%A4goG6(8{/W?oQ?4^x':qX>JH{qC--a7.QbwgI?^a.L1l^~[amUC,Nk?U^M'FGBfyk6Z<;6xiS"/C81~XSPkYMiwt~WmuV}Z0<^Ue55.{]m9*)~<}+)9s<TV?$0,6IxvuXv >
+co+HSK3f xeIwUV,>_eyRMV;'gWb>1sm?RjS>[	@w5$(!nJS)_\-&.5-Ah_	bpw\0tL;p}Ll7S!Xn7C|9?_O0<#}F|#;]dtV
+ )_.W;3q\K^Pep<&y[}#w"Fsr-< o9O>=_|l$nk?xY1XAU)}N:tcf|=`)6zi7qUhs=fsaf^7s[o$9[E<28m*[/10|q:DA4e@d%C>|fH.tbJvkE^rI/v}aiEDwsbYfl-qjrSDJzPmZrvr9M	93_*&}<K0bpmMlWOe786E5p!|Gw=cX%GN42yV/1XuW6MofoT[/U=	c0;H#E~R/Qr{C}_cT#4mwXwXw/9Dm ?z\[O6>$_`=GXkc72z
+!R/J_>%UO_3!}*C}cr3a"
+Dt.o{R6'78Yy xBf7J5FHpq a8(q
+b5xXKk%K'/xTf_g3M>^cTQ*\{U >7^o(kDsF11d`#
+u1O[D-T-YBs]].3oao>7+mwFdxYML;`l:wFW_c)Ui	U<tuO-c+K=6{-Z"vjyb/vv;Gk^~X8:OWX;=!`hlt}[vl0WPNywS~8t'Z4>"qztN :6h&jGFV
+[)?(F?J<Sgas1h3pw1fa8_i? y-HFcH+wcZ})oE
+{1k4GWmA_g)F\7<^10->9{o:c<DE5&zF<{Bhzyt/}}UZNp":?{|T6 ?kX9A1"FpRT-JiK HM3VmnFAkX]32Hh~D}Jf|XGlt4ResSTGe+NC?YzGn~.\B1_2R.78g_y~.|<Y!-#W+F>S%#Nb
+C1Ji<(k0"_vgf:Y(+ia?7B&:6wKk-1fTjg53k)F9W;rKP>Nc+\)WyaWA^v	Hw[z+D4
+!%~~{H{3k<4hC/#5(A3[sh%X`6r:$Nc<_\k$c,v2.,r2X5\s1q.]kN;S%+oz_V7_-p:Zr70n)(g1z!j0n(bO!8:s>j`n7P'>=iArbWIx0oa~LvLv4Nl?1o~a6~F;r}6LBKl+*]|C:MCoSP)N5t\"s>cP}|E(0j/xFYJ9:Fx&;"]y{G~uP>e>By{?y1}~YC~~iTz<CgSEYa?twqq]}o78&f~/$88;wAc_xO!y&G
+qSE76C,^2c~" brbcB-y})_K$T~t\P5}^$PEs1&^8Z~31G30"u;'DTTMCIgTA:]!cg-e<{3n'M^$'*wnA	ar4(_
+|?!dX"G1m:'_?q)):`e%}
+O[B>7w2+X)YLN ?L2zL#DR>kAp={KlB>'>M6F0\]sB%kxVB^OzL|jD^48+zZ2VSo;
+."dS$c"W*Z6*72E"7$^F
+le[G{TF?V/23#Ol^ ]z~j\M[#F22	}%.usLfRz|84_eQ||Rf[~z=yuw/#)5/$N'Dd\'[L'Iim(nd%3,/C6$7:~#`<>3r^};%ss:wiUo1]Ft/9;$Zrsv'!]~t&q^3&5=-b<ujb{j'w((]sWw:[R2eu6&6[[[NgD}TsX~0Y.ROc^AyK<Gz/aq5W/Ui1b[]
+R\p-k?fA&sU#6y	;g+	^d!mYe]
+R\p-kZV1uw'6[EJU2kX+y3}J-SW}v_zm0e-]m:oyUN[ea*\\;qi\{q7{/#$_g<Gso]#?}=3cw5o! 7cfu6KJ-tWb)}V)\+q5JZWW:J{sur%K)~eC.<]X=xN{9oq7oL
+|8+UI]cBbJc-Dc0_E2H_ChUo:WKU&>X%E<HS/Ijs!b^|Ic&OW-agC+,~m[eo~Gp^	S&~ I>"]JG
+BO{dUiA72?zUb+O/6_elB #qg|Q	v=~u^?,?g^Rc9Qx8=chZHg;Spn<}WUOd3s6#~w_5o,Ll>+O:*>(?nQhOO<CYI_$tt?}  ~NMG;Fur9OUah/ia/4[[i^Sf9o$kEqwM	w~!%2V}K|9u3JngfOwZN3Xoh<{$X(k@Anizg|ZBuD.cQ!M/<9uowmv JS$Ote'w%=K^G#_aE{,uw<}"#Wy@5-=9?/U?oU^Hwv?qc;>NXuTFK\'-;&_3$t!-sKf
+}F]V{vp{~b`<0C6K}[sXj{W|=+)'|h}'yC#OU?LGnalZtnW0gVwf3y~y]GiNGB1V9G_EeG:_Cv~z={gu7'n}i%Ezo^KdQ k-=iR/fGG19bL O`}pOEK/zOPliWRO(>T}&(r~<K> i>|x/s10o8Hu/3s{Wy$Ps}{+q,Du[E~yZw6x:-^Z Izoz>Mm:T)AO|V
+YmY7()~T4R$>oOT#l,\}qp2ro`(MkauBgHEj8.UD5FW~>h5UhiE#+ju'e!=o:S%^mK[86eYK46-<K)D=xW4.!Je>^q1G2-~Yh,%u:;_9~_~+)0sNW5Rs0Ogo5=}_2WnZawQw{{1T(qfIXu3W-yl^Q~aa7,*d,1^&]m7@<W-L7qtb~mOH=2G^1VhWXWr#5Y3toe2Osi4
+=u3]mOB	]Kd[nPnd|ow
+bEf9P~A9=B+vioTuX7D\qkqGt58w8Rue%)/U1zX1:79Ea>'"&et`=e{m`2[GWThbWi/>z|q2Fw+$2!|yY%a/RZ*c>){n=QZ'xK99F8t4^pWXbSyvn>7;64WMPP926]M| (?"#qF?
+Wj8=vvO6R/4	}mK}^u|{i0giQkk4-~wh-zoW5h{A9	^"923;4vU5mCF [
+}l5>!XOgIu!ibcqq>nwBv7^SH y]J^i/	J4'V)7.>5Ko^N&u-[f1W6]9s_tS`t/1h_wEU%qHOVW".|fDV.1Vfm~-Q%EXp:W%s;6o~wj*W	Q\W+ -[,RS>^{a0vf)`{rV33u;I#MEz=H&SZQ6Z0p&c$2m;i7=I375xmg&-vUSu[tB}p3b=&nb'6nT*Y%Q_xZ67{3qck&4)elHUZnyVmkzKOX]]XE)}FDjU4fM~Uv}1/,aL*W>*tn5}2^%}cw_>~/8^l;a|eqs[rW%F&mR1S7%k$V<cEl@&3:33mY6`u% e+91|1o{7P}\i7a#ov^Vp9PR_n_\14\7ic+Qlwo,(G%:&,ix=*~kbh~}[V2#f0b=X/a*hW02	GqQ%
+4p~rT[9,my_W:}^66nvB#H]eymQiel%q].VsvG1.	3fdC
+2?e<W?MJj\U8b?v_Z|kvKa'YxCo6cqwUq]%6Oi1T&rxK_1&b}T~ikm6gQKqKWjR)ul.~~Yhc/8$m5e}A1^xz1}fM;|cYfJ[sa;	S+>Q_dt/c&S	,Wxyk~U59t!*R&|zZ6g?75rd3f3K/r3]cM1m^f5rYM59(8r]X1VW]%	o?3~y9#WIkm5Nm5Gf{'[E\-mfr=4xfyGnmEFfSCI`O_
+}v!]%:=!_%3P|QHhp.YT TQH~d}6Tz9x?8G'^hl	&A[]wv/][\Tl-\G4+3xL9/(	-@ ejK$)b|'>o)~7_1_6kw]1HWJ|hm-/mNA[)N55ZVHwdC!qCg8eC^\gw!{-S'xt;F)ixCdM2/;Q2nEnHAZ9q'sLV}Vr_d1e~/hDGY|=D&8/c2q.:-su{g4/<|6~{~SM>]av^x	K~)-%xjkH:>pgVf2VmZGFc~LAB={4#}	#a/E,v"[.kJh9/(ow$3	~?khp.=pll.{BX'U|
+u!n)uU9e'N:Wl/1pP~IC0.~#M~upYi]P8ax:a'p\oMgpO?sO:LuCQx<-}T+g3gx}ZlP-{'G_(5mQ+{pN#L	4oz].xiq>W3!r>lMB~@\d-.Df}<!la:L[zw(c^:sM`+3kzf=/D_cpJvy933^Y8`^]~Z!Tktowoy*E3VWmzZ6o%`56>xQ\jxaECiCA~p}Xk}8*4q)Sx5!\OzjKx
+\z9:V1RG3dix<MQ.N781m$Z%W9U]tz8zM)>"_/<zn{j!#DOg.Vojs{.#T`sAcN{`_v8hxr?-?WZ#=#OMj+?[@|i;2kgw'x^?,9zqkZsGxEhoJ%K{KWl?EaHW"}9Ub#s`lS%*f|9qKyyBqN	73AzY^8q(CS[^oczV9LW&ZelswgR?d_c1'y]s5o^8P:W2s#~k@UR~0`po^v)'-7/475Nu'Ofkwm`mW/r:Ij3}rfqxl5%By4W_"As vD-(dB<EV+eAforZsC<I	(s:,7eNe{_8_dS	> 2y-Ky|^tR'/MS*;|1? /Y00A7_q i?o__*~wq}QcM#>;R-_!Li4)&8yg
+#)G093y0$L1t6lD-p,JhCq]1bOzCsXIr1e?-#	t1m->+-mx1la9N%(66$?^9\Z=EYdidqE/lk0gO
+nxEyZu6Ho{T`H\ne&"QXNH=Te_icnE4{zZV7DC=G?*spmCMv{~7x-	
+o*3Y4n:6{hVokx#|v!8:qh>sN VCY<\{_VvPpdx+Ia6=6KKc-}Y{iI&UtQ7LSM0.BsM:]K/+vV ~l1x2'6N<}=d#}=2lsM_}l4e`nMvd-]&N|z2+v~{|O|h5fEh&=,yBgUW'm:M	c0	M&4uX4u|rT{[X5#
+KyV_# 1K:Wl|"mHEGTHb~HA(tm`W`~k^A0G)a!pyXyXyy#-G?}Gvvoblk;Kl2t_>>:ZH2}Qz<s_Rz\3_u?!oxAR0%n:roO>iHYWHigZehttb}snrngtjOTlrRv<1/LjRB,Dz*:7hIpTVF26QS>g;yeMP"f*hUvh7ifwC(!4dl^Y<;IlGY[b0\G|25zM{cZX7]8{^Zc+g6<[26<
+YS`4Ke?1iH=2<NQfc9O X'm=>sn<D|Q>lyEaKqmkZ1S|^I9j)ufk5C<-/c>71pGKm9.UICr_U;o$vU7?Fq}+U&8^bOs`T[eOBXkEy_4,nEXp6]beH'{=+g*G;Sj1NgiO{egl8&4~8zSkfN#	}tv/"}1?lWbxRXavq"}f=CA+.:|prSvNE5g3eE~v;92`G0LXq;)!k!%mu>#Wkl^UIm=_(*:[A,-j6.AF8)~Xc;^m(g6m%zyF$P]_r>k\Lc=Zr=^:rncVo[kUm:oA;m{G%1j[zC:9zbf|sp
+gzN[6T*zC8'/+9/'~i\Xcr<\_8s+q[<KUjQo96EKgb({7[r1uUtow$^Z99
+}}R=A:>NZp-3]]lIHz.k~}}si#>?.)nf*1{WvRR9n4"bZpGKR_ImCgpo[V9mB{{ SxZoynv/ke3/t-6X-<n5?5	Q=)$F@3|nc^l?2a{SS%a_<hhm"vHwWxzpM83gcQk*}fZKu#+vu;dMS!Ggm
+5^#eYl~k}oovMoG~8#=c=0P}&g"Fo=WHZP\YkIYs!%"O0CkULzs~,S^/gwjuRl [4\f-g>^'<cnd.eSZeNcwk2e1U~mcJ0/~n~9,7c6lgO"SH13GJ=>\{_e|}uNo-N<H_MlO'm
+J$ri8H-{Lon8	7/,k>}U@qL+f^yyr;:?x/O#{{ImFmH]A=C}}niLvLZmTZYg"Q=cawwa}zr{w/#K9lcJ0c?sl3XXMC=+:HWj/b/h4q.O1vLQU)<MIHq5qT	ai9SY.}Ej[PI&Toa_c]46~gW/T),*9ymVYGn/Vp\VaS~1hmA,Oba$TDUA<ATENo1NY+9+i'xPw>cowP!;q)og|~^.t1rDz=1{#SHofcqaNQ=H-ghcvQO
+4m16oiQnKF\79?Rm
+Bli[MUO}+F|fH<wvw/\wVosN0K}SKi].@_&Ts+z#Tuh4&s9W~hc0:}uol\qArR^*Lvg
+`
+zvn+sbh.{0x(yk<v$flowR@F\D}^~u?IAhs[-YwNA+g{p6>^X`9-,1Ok<^RKAgG/x0r.$OHw}UdOsxWAanZN3xWg'>`H932;p9<ON<jt^F}e#/m_+uhy+?!?!%Xr/F>Tu(buVYVnj^xHziH[pn>5*]}w}w{8!*WLmz{A)	@>y/iZFT+ay>5i(/_`&31b&G&n@A<#>*?_@3.p]>"^:tzpxd4#YOs:KD_v#?:-~f8~K_TG_R[n90\>569/l}2O<h~	q#D;JiuWOiBLHz[}ce%Z`|$lG\x3p6rGKHQ2Njw8}qGMAWp\'	ruhw:A8vo$hw}\9J|qs_7_[}*?>CW}l|0x=
+r_ "eX;K]_<B} qRuw@7+{w2V&;to{U`lqu];u`j1^}p.'*\`>.rY=4cs$ctD;x{_;ozVG%t=.j%O""OM=G[ eqT{U1?pq1%<R}1"n9NJ^!}=3'N]D<KW]yjtb5Y>\IFbq_g\B5SydOBYBy^g<uA6mo_?g7xN;s7sy*&h=.cOcu22(xsJ{szYm'vHxL7Iw)!"P=/+iM:Y~GYmM7G||`esSL9l:I<NQf$E)k\5jYX:7
+jF{* NU87nq(n[zAfyQ]o:Ev,7yL}r)r	U}-xdL46!#N`6:.qor'-~^Iqi5adJvfa4h-B?Voa5mZ/Kkq}DvzwzXG{npc.FCU9g|?t$rq>!2j]bKx#}qKxGiJ,CFF[=5mLZY#&Ix ,BAo5me2jDK0BY1E3} 3axVlIq~1_|*]~LHLMKl^#gL#njrJXGlr|@>i5.LX3ej8~\q<}.2]5/XI;?zga/]M^31gO$}Vje&rszSpYI-I|`Nn^Zyy76LvD4Yb0[3}82?XoJO>%({o,{-GYFHda~0Dt*?ejYW\/!ic?t.1xb3+}6gp?#;cuyv}{R~S!v,-OwZ
+f\7:ip}-
+cL)i}s:q@u-\#D`;hguXgb{(#83kW9%`k'4!}1$C<9J,P({EWh{_Kb$$]E"F{/C'#X,b2^O.3!Aw6fD]/IT1^oZoBa\P2a6~_bx{<s>GEIybH/GQ*#K "~&'|]
+xVH)~o_DmYs}f`>-CmlM
+qmb{Mz!{;k	Kv%9gxTf.O^_?71NJ%,vyVb\#xW9=g'^~h'kg*|-ilzm3]4mZw!5:oZwm~b|j=S0{<zSj<m<PL?V3Gg}gVIs\4rCto,S.6$VU&&
+1&cozq|G<_$glpGaf J`5Xd+4w4e%A:\,$3(qKNx}Mzrjw4Gk1v#d{9X^ohgt,+G^}SCs4^7C` ~@E9!E1{g!_aKlmE4<lgO;SWoL,Rk.Zx5ft_XyGXm{!vV"{j&-~-,X?I93*A\G%qSYbz.n
+IKB$2"n|7(_|T[m*,x(gR//'e/tRuL>zhaM,'vl[y(m[P7agE	uE:&R.*]#P3k9e8|zi&{'}{meoNzlPkiAi:"dO6+Pg:{t]9$vgr<	vV#c0jV;7>"7_H->!},slq<o<n%x|S["WSQ.nMw^|:\7[*v
+ mIlrvJEi72""w.5v7Y+X7\}\8yW1XZ<W<-%aoDvG<2:G_/i7+G~}ntO)$-{lQB_K8i9)]7!5-=47x{qB]]nIaO|Ve]m`js)WE{yQgm3#{lOkdc4wu)elmd0pr\m{T5:;tc5leFyh04cO,
+Wm8;Rf;MubB0q^x9k0vGgUzddg<2/P]gW>eYU_jYRKm1INHdJYO[0/b:BIrNm5!]x nH39?RcW~N=N\hdS?G5/U{
+Zj$r^{i>wg7fcM@9"*8f<bK)b3*I 9}w5&;z\PW"7,gXP%bCmg9v537a|d5}0F`8DI&-zIO:ok.'Ybcc{y	65YmcJ?o/1q~Wz'Le?q;t@"3R&6Jnjg\8c0#g~C37a{"
+/7<qOf_f~3:0]nKS?,u,Vw;V6fCblz[]h!dvyGe_ 8cd_:.{';5Y|J<YiKbSyj1-<y(/ot/2_.VS.Q\cG	>Ou&GjCA7[x|KI_K}JXm}[6n,c0#]t|w'#SDIlbSck?!E(xK1')[PE}6pKsO,c7iq:'"u7&^c~{~,=Y./6$~HYc MXS~}up)rnMq5_od8W_?e5)30UBC(w~}ORI]BuWrYns6f[Wg[qeZ.FYWqg5`Mc"J;~yz~gW.^m#Ckqeb%r5MIE0^zR/ 1c#N>)0gkw#{2)z~uAxe^~FXfBnL&_-orGxiov_l5.-/~%{1pI}]0V.A)h/OGgfC{eg{S&~<{.zoi^Sjt9ie]d?=.{KQVr<C:={F9YYMwUGA&fn">f~^{?x|z?cbQfoe]+BY&*Nhkg{MY"1[<_D'sdw&0G8',Zh"	cRn>E|k9))hf=;s_yG?y~1$:\D\Hkn9$,cXQ/FG&'fNd7-/+VEZWE	Gqc	^Qc=$hW'hPy'W8Uuz3XB,g~	kKJss{/b'd)OKPLq7cuwqjhxaHK!e=#
+y
+iHOF]"V9/3--G%[<bBJ[!"mCO`X>}CqFF}Eb*o|{auM}<UB==|3	j8'EKcV#37Gv07U07Ny:{XBc3.fl%XC3]~=. {}y=+k*:
+3;S5LCIyOZh6(;(wMhe5G{;5;Rt&5gCg-q=mwzmh za.|pK/{bBXg_]3<i^*_;>c1:_?oM9<dl("u[=mg\.uX7/F!=o23/}kso}HY&=RgP=[m}2ilZvrRmXo?;'==>_}d)KydN4yM82<$F+{-lZEV' 'R!GR}c1\lz}C=OzK}uW\.VZ<+sud=b]m|yLoNRK8Vw{rpn4~TmQww.w{`E9[J_-|l[rT*
+HcX>9x2UA]cL'NpfdWF_FOk{#!yfhq._8ZofZv<VjKMIuQ iO7>>p=?>ySJ.1V)^cimqq	TRc'_
+3~$b7O1"xC7_B})xfjb,/4:>~R3~So&+~xM]MN^&L	7MwI3Ri;iZrcTi=N`0..ds'4pgOb5-rN;%-^DU23NPlM'/$nFUX'wl9hSf_s.vy2x|-<E]ES:SG2eZur5l}
+%H<+S55$-zZmM8&mQm)~BnE(o.smLYtNT[v|/fKX/bNa 5"	m3#Rd_>l~%OE|+u#Fnb\>6{SK}~W17EO&
+^nf-yp^gGjl/m_&xgi6\U^|<>rO}c5ti'!G5>+_lPh6!73Fb{4+`mu&C!`Lg2vV /iE=AkLY:Rc|tkLu8yVB2%Nao:9~{=v<+W>+21y>iq@E^RVzmaL&NB0.pQ;%7&2pN]aGnl2v|uY;8*i7rl4^b86tv;d[n1E5L#wg=g(>W/x#q1f^1'Ca9Joa<C-J>\[KWItpEYbSN|^-w9jS=:6hZK&;<G;[P^qg=D=9}pO^j5PC:d2gy}Sn!hu=e&yFbR5!&~'E5AgV~ qny,$=>;2~OV93]Zmo>BWgyP*9n.Fc*8FOs:+ll5a{ywj_T+?BB'C{
+FtHLm;"{ivq~%p<A|>D
+<}.!KuqKulSF'1QdX+dqc^6<#80AL{4{smW$viMn:+Ina#t<(P2KXqE8:Zoq2iS.Fiav;.4.C_)>}
+ws#T6V2o}(!*HiJj8+^/(?^P3_Qy_N;17f|&!iu"CU"]4&vkrcUX+iwk%4~+pi_kq78e<c)k11N?3+R|`/q:?Wa}j+.cTU`?
+>@j]wio}.en=8Rr {\g+2/Y1#Qj>A{hZk#L%	;]]k\,(j5IUxC@8*E9Ur6r?QNxH9a9.i,=H|!ewr8'(RKe/y~?2sh(8%|s}So7i>Iy5,yvQiG]r//Bjhgu,q;:z>?@-	).r~AGn/?MM~gRxumq.-	_#Ay	zfV~#>S}gvbYScwk/I#4P8$y"wxu<cFAGiUaIOAL~q.wLu}X/)n~=l>lR^\[wA<^@OgA]vHo9/JSgPN<E=$O(v_3xHYsLrBF7{)|H/m-tX1od +l	'2SCn}6)6o|ffuI!qLS>CVC|szqtRamWb=0Ok{S_gs
+@~A&eUczM)'f EA7\t[1Cv }K]!B H.}mY_O%|O#nWK6a7kh{]~kllJ5b<31"uYkwA\4b\l\$i'v1xv!}P&/&}I9[iw%G4 L,*JD_mx
+'scDri}M+i:HM>-~B+x'7!xW+WB]t>L|OPWk[Nb~EU
+{Nl[npK.|
+Yz[uEwQO5q^ho;
+ JmG5h[-_3![:)\	09`-x-yfncDdtSs8a?3&>7u#	".%T4WQ6..P+ocjrK~QgGndOGN:&FbugyoE=vfoR|$1e?S/*K6Oz0$M~H.6Dc9B9A<
+wcO+R}E$>;7cpV}"\>]B<9ft(f9!#c=B_=U} q<5@sb4kM7C!#>rCch'g50,wS[
+<ur4NxF[("`Bc"EL9`bJfJ<;HPU#N	>v~nrTC'w).yRda}aF9Rvy>[-30W)m8
+]|r?G[a:c"uc5KcQ}Y-w`4dpKJF`>Y3,r(%6yaQI]! w>5im"u}=h_1.O6m{\F2#t;2^-'F9\K{#>bZ?}1gN\?-R?7?^R//C,'&{"<$snGsHcyfC3TSoW<c/GWYd8r/EJn3r W|:Nze58/f;Mce.nsO2jkbg9*}	%C.Dn9mj:."2?=|W0O6:mIC !mw3
+(~QsD#~Q)S5~Mgo{L6u[B=?gaq/yML+GiwH{XV3%(g@#9s{(	?{y|},:rw-u [Oe_6b*O5s_jE%wERncptu\qmI_?Tms]E40i>y?NGusK.9:r
+Q9J?CC]H,-Q;eu-xbT /{2s>w&}^/?Ov!fuC!~[qfH<
+sU??Wm9u
+.[yv&{|'!+j4&whf	u/wQ((wu%R=hY<A]\yhe~	Yz]
+V5y$=*q{*t}6le9?lS8[|C[?[]o3
+2Mg+pV%mj(O>j%>c>*/|R16Y-^5iqWZzvkoro$1n2O\qpw4O/"C4}uCL<(4Wn$\=*o1ye\LKLxCtNCJp<)8oCmo9_fhehV[6wJo7S\z:+8>`<c;V=cb"I?MjY\t3,cmt #OeCA=3H%u:qI,cq`-jqzT_?_Poo4-(qpT{w.dqj_-O!^TS50G34D|WS^O>([b,
+nh?9t>hH=c"D^:mR7y!_0yhE^:sa6 ]}PxLxfi9AyQ/,*=%}b}N]u<W)S%~U*X;&}]:4-s|bTsnlu3Ggh?J#?~Tg%rSGoe&x:!jBQ?>p.%5.`y3-N?kF7]ekaCw\Cpl_
+1fO{(b[}w?:[pW:|`WH.EK=w%xWXB,"D])gbr*iTbv[[:y`jO`n|)*4>x,>!uEc|GQd=cO5`%feV%9]mHVK=:t|FM9;q8nB>qh#A=_H]E0ND=KmMcCbNq:~1o-[D\]>y%<C_]S"m6'oze9wV{u^Jb>mx:
++Ypn!\9CK3!9P<H!N[]su| wBb_i;=U e[yS~Cq' WN*r_4_k;%w~6N?} KyYAns}Ola2G$./tC_%.{[^<c,k?k<q/8if!N6kc;5SPr_?jhy]\M:x\<wb}Wm\1@A<@n/q/x$lblMutMI@]yp>:6c;sk_*>i}[pzG3<Us:fO1Em+6:WC.*.k}4/g-mDba~1p!+v;Dzx-Y>zmJ]B$m,w{F68_byJlpK%`;fCa^k"FgQ'b{o?O{]`sc.yS7Yk3>e.{4a08S'Z$9v1{m6~([4~_i6u!7HOgEudfO~9+g8tPrkQ1?gw}!'uGYwC}/am}Yv3<>Y<FI\+sKD&,~VSMdv@\-~OJOQ^oAgr1'fMU`bivo
+ly[j@5d>'Fq.\uMyWOsO@y{5u8wi<EJt9f`ye~mc3w|+'d';u7C|kZYfb&L$[e:cFo?TlbdJbDp&r\(QE+y?S.!MZrKV	eEs\gOwzDWH3hAgb4g|*	'vi(?"OBrQYj p4~pm2_9J\?z5SCl-%5yoi=z ?uM;eS})x~Jm0&ctO[49*"M>"kk3>Xv)4.'>1.oqPh?.z{3'l(/=\zX\8Nqi2T
+}KKE y6yZ1Cq2Sm5J{t0}ZF Rg[K+,~QCi}qf7@%z!D/1-6']cgk|8T)i%%L:.7vPoU)N1HEOliiUnYMA9=[\o$eY[E2-#9sPZw:K*!e=47>x4(>(1y{ON)?3uUfo^/Ih<J",-d>_:I`oF}fIOIe3}r=}o3T)zJ l>~Sh3wwOS5uo?gQ9C.R:u;!2~{hS\~eg*d?OBtj,^QkS_"AQ6C5&8B3y=GS3aS km
+O<gxfLt%E$yi]kaqO-/D	E>z-jN^K\TY:rD@K `u2tyq++|zN\\&0Pb:W/0lJl%yH+vTw(Tlt]Y(,+WMGmoJ{L~,^pWJU*6	72hc#>n[cw4bD{Qhi)eU[E=gYyF5"X\nXS66\js+]'^H\Ykqw0pM2}qYI\	`N0v~YLEc-TI>pKy;GaKD5vLo~5oQNwhHtbfs7pf%ni*(XyfWRW'e'?3Ika&Dy}/(d#kL:-8~<:[]M3u@{#~7]]tmu;9y252u:u-dsw*#1&YL$;{NpCU8~w?wMagr	X'#ub}!_3]U'	Zt;dr);Gt~jiKktAV_VNLU2<>GtO#}M,u<FH,Ubv=R<2Xv?I:<cAu,u;M`L~.[nG6b~p7x7MJ8Xs.mULzDOynu~+jwS(MS]Pznd^LVbixx[5X~#]#{BTa&tB\TtdW((/$|p2)l(^^	hzRH&^QG2yLiw1#}S'-c\cdR,mgWP.0 Xx?=6uEMjc5X'7M~}Jy{mTWqn/7s}n_}]i?8-~sb&l-1`b-uq""Icn6+K: }$0,H?EZ:KwI#.N)1q!r.h6/H3LM
+7=}u{XL+k'F_Nl:b6&}EK-7., 1qv~.{$\vtq'rEq/(g9{N|;ej6bT@5Don?je|65\vk wQRw{AIXL4)\x73^f-{
+NkF_k:qmrM.P[XgiU0xq-v:]W{O):]# /,nK~~hDE+vdy*lz?@0?;c`r !u6f'/#N?T/wUB&v=vOIho|8sE5{YwWF4v}r.bc=Q@WO'}hD/N/,OvkCVzTCIcca3MbCJl=bc;]#f
+ eFb|sV&TTKanH>cC9=Z2&`_2sCq6Awp)&1F>{9z<qCYqxz}P8mNyGpB$ddz*1T?
+>U?0KQ6--rD8,Eld0=n%v&u1[MW^42u'wnJr:U[>:"z6zMvgGIi{Y1{9x?Z(b;Jt7j9F;`xwC&r7ROPytIg@Amu>11
+,i/>5fhc~_Fd1s1wy9|exLrsJoY/$cB dY]?lxkU5m9HAQ.E{dLn^G[4u6QvH?gu?qwBE?9 s\2Qu,+#K}MR|sJl8~JiH-igz17'"G1vw]?`&sbi{7F^hVG,Gm+tUVc/h9A(>a:*q,z=4?C*cS+a5MsCtl4QU7n8YJj<w&k/Uk(/t]"F^Z'+\b|:@J)d;cn}k9S?Sv&`n[zo"UJJsc:{cC}F'[K\W
+/Y2']q)_J^!yV|"Oe%{+IEfJc.c 3Rl5uy]:&F\TsH[TKNY'e\BQqUbcx"cws7}[2L}C	d g}^Z\|XG'RJ(7a5^*Erc}Zr]6QF2yWPt.-Oe! 1~s|<z>W0W*s{x	_=9"[ i/8C9_Yc|r|x=.7MqGod"i41>B{6O^.rv<W<Dx>]qbjk,RXvv&?l=(ekqD?cp0>DG+F%X7}HtzkQXTn7Ceoi V%xzz7hc_qOoK7&}X$K$Z)<@691w'*M%{k]o cIS7M<fi4$M 9s4?VRab0D<]VrG\|tJGiY~i.e4li9&4C|yH]-#E%-,-e1oV.{}/z|m4?w\)mm~8^&ukeynd\2]'q/wm-wqr^ G^coankiu5 ]"L:3Gqv+*	i$x^pyJX3CMS#R`]r.8[R=m>$}cOxL^IuN>/hC}+#Y
+z["u^a2\_2N*3Jr,7~'|JV;*ZVe_W$eBvsYh'`UQ;Ubl
+.>z%	g9zVNL}b^4v]moWaOVMkF+F[8z;hNGQav;|j>%sN7Nbzd`EY7DGxKX*yAXdCmY~L;sQ^xuX{b8gE@g:y{COfj87G'9[Mwf'[3	8i**gy7jr,P?D"?<{d(CN<Y'1A%p~EJl>s/)!|ywk{~K<h78^xs_8<-;Wq^<'Rw1[i	V$V.m7rUl)r4kj}|25Lqpc[RO/|K2Tru_,YqF&fIKbr]g`sPQaqQ0)G;4odAE[Cgcx:6nui8O&6Yb$}#1/k<eG8ZKkj}}~ihEEe*]sTG}q/*2Or-oDd\g_/g~v8(C J^SM'DnGq9('_xt_{+tkED!9/t,Ghp}3+g^S ?'3JE@jgI1vkVq=Ct|-FogB3<+(?*ezsK>@z2,|bF5>"rOJe(kGWZaFz^oAvC9%<jD3z]#fX
+e:gz_L4:>emdnq}&3O.RON;{_o}>@@wPv>l
+A/>y^~$):u^Y=p*#[rwW-f-V{\c'#JZ4c</f=;oDlwic-|O5spnuot=MY"[7//fNC
+lu|^%NNOfN6h#\f/o4mpf[_-](y<~VI"cc]MGucU2cKY(R}zL2!*j"7!|99{Rm&g7`\zq]bOECTzxU<0$BW?*6[}/w#xWbTmr~ }M0K611{=(I[]<Iv%5NSF53kWjy/H7h#;EJ1`_
+y,bt?8K3w&^O4qv[Hc&RtK="z-=n+E=*Zw.1<'9a`L6{X7/o-gOJHg {P{/R/|._m/?,_OW?Wk&ic_G=WJ~{#gm<#y+enS;4t?`N<e9W^\p>[{hQeg1CR&f-mo6;#V\zU~}gCt;3=x8gO<G5R;>6rZcsKs-J)C=6!1Gh r>qq)uHisXpn[-tzN0c~7h	 "XI}?ULcTCXxvU#~*"wU(p[eg@nkYY
+}ac|SnSf}?s'aR_ijD/|8])5&*mr+(7c2O>)v:w+~iw/rej|!<;$xiv>N"]EVnj-X.>uv+NQnCkt0wWkq1;zei/xZ/6^Ve|Ie^__;&9_b7p[	{qO3k[`X'?9[ :>9JX|f<G:Kl;8l@mW?u&'`/-Hy"1|jFb5^Qh (gjf!k|K[C0;A}'+z;{Z]/zi=6/N_~dTr(<qg2SNC{3ZT/4+cq>,Acmb{~LHU}J{A3/ky0}`|oo$f({tNu1ff{%]dP|"uXp<ai64=OO{7ZW}%b7%,h8UDMCTc0sG#;C	^P/%@Sih;~+;\8-\-r|un SRO9-&kV&KL G}YmWsgZniuO`wY ]Qvhi>1T{a}JjD*$x3xX_GI0OYMl%#t>6zunfO-g_&ooG[c=?RK;{ S~oF.xz.+}KRxuoz;Spq,ZM:
+&bZQ&Y^-8N	G~cO_.m}2@adguw~FKj_>;lIzaqB[R}u(\S K-AblJ9n>`j;w`4~BWk',C)w2wz%yW]-8iYZ*N(?Vb<A~m=P..$gby~6vkn`'0C]{z\X]E|G}q,#+#?1m"]X} Yf1ge?~3Rcq1FBaUe/#NQ_?ocKJ&zB9qYc}DgTE0zg,{qExAAu>Dp`o3g_SYW|5^a`AOcx]%=uJtEK6n_q9o43s0	-'6o't#&|Hfm.R ^8>{x"c4@wp_Rju=8SlDc HG1J27d~f@ E/ZM?C"xnz>Ea.)UGp1 f nUdHXop(yL24GA8gZvL[MhHj7M#NqZbK:J
+VXw t	daN	v*]co@'U_9l~<p%/yxz^?LCZnJSXU&&EQ=,'>,3*cM}4fRk$c#O<Z/Ftz}m>E'$V~>JX%=i6v gN63A1n<`<GyQKyJ3hX#g{y3l7Lyw\|t;Vm
+N&Q.w'rLR[GC?f@S38)z@~HdA}k!}oKF_k>tI(#Et#hidEOEEyy9JJw;$"/{WDZ}Q>u{a0Q?_+cu~DF(_G+w6[
+c%cK&?!/b,]EWw5qbb#~<VRT37_-8l nu8S71}Dp&g4sJs#
+Y$q_%pL!E%wf~,aa0YixD&3aC~(~?\o%v4u=m1X8xq2
+DxmW[5TP71g9?*[n[d*=Hkq OM}'79o+JCAC[4P~ aAorC?,er.c?}Znrc	g}>pK]XwA_Yx^	=0ld&PFhN[V-2}mvkL\dU>1J,FxM4cQ$z]?;n0'p=}ihwmR*i>L*r~qI>2V"[?dWto4c'~+9g>U~?!v2iVCt|!OhO?X:v<T.#h_
+Um|,1obXm t+yeAOxqC?p~J	PhwZ<w@#H(!q>K^'vZx{wr[BqwVo5W8*	>275dYqWw|&Q:}.ap<;
+o8Sj{Gbg,!<*1Ju]Sr[N>,Uo.%k}%c;,Zwo;MqL	rm/anJV^/o<+1~uE<u	8wK*7x{	bd<s.<SO[pT?IJy_#6Je|{u})68f*GNBNNjr(8?\)?Z2I~:}ahl*v&~=d	^*>CU*@e@7OabIG>smN{|"gokG}G/T4oc_T|6UrGy|!"ez-}w3&ufYlG[VFOTN%hj=DW*7JjoVsk0q<@K6;dx4x $E~y39OK["E_S{5i)%/N}+1Q:Pg[8du!-{DrrOdqzKu==qy}v~V{`O'=L1}<I0?%;~'[/{"W5_~/3Gd*uzet^M_l>b`(zu03&U&FLFGT+;3YRg^$Af{w%?Nn3.SbaO4FX1_[}*bH[UnzX])ky39{j>xg#WjP<5OxUNOSFcsb~G??fVj}f-8Yf=VvG:={NUc+P_Xpx+r`HS$W?I/<r#Fe- /V9m<k;rq=Ld{IFusk::C-;;X"uF5]"kE?3+G \c3{E|D\i}v4M8OI$\P6b?q/~7vsZtG%_L_ a;37>cS?Cwm4w\ou}We\4mgZ,8-h#h-~Uh4M3u>bwIl}kAlieB
+cWPf}X%q.EMXld,ob~?.zqSvuLyM6(mIk6EAjgbWX5l>wl?l7	Aw08O y{*6gz:VLg-,fj9E>Gj<'V$k8!,tq13S~\uG"Bn+M`,z;7v}f"c eIz(n%2Cpe)8H>'9_;q&mzsF4:nsz?Fll#^OjUg]g56#B#X+LgK	%1[=+iS/W[@7U]};Z{q
+k)gW~@?t_:#Mk\w=:}~b}-|VX`1[9UQG]v>k]0>N]EZr*cGwtec+\pikCU]m#f@[=#3#,>@P5iwE-]1qPb#T+smutKncU+a/(}I-T{|kv;0e`<{l<~h;a?,Mz+h7{\s{nAU2oq_8ogSW~q	9h?2G'Iagbc7lw?}z	dE=:&W}EW>si\hlIBSQZc|Y%_6fxN=-8k<o66e-^'\c~,5FMCF]}Bwfh380.I>~i6^FWb9c$Z*K1e\3~_er<98\vnm	!M~:Cdw/j^u	#7V&RVBkm1-*j\g\jSI=wu$sCZm=8"%Y~a98|-'y1v?Mt;@EU09QO_e0^SGRqF-onb8yw[f3qlywKRet;J> 6_9];:l~AsuuH!I3#<rkX){Q-	?(|v$Q;nI	2\Y;{I6?XD]8wQb(= 6QBYN	-D9BgdT$4y
+vGMauT+	}fk)n&2ghr$giCj`jts6}@^mO{5WiyUh}d,(ZsoX3kcte	o-sFXD'yDxG6mTzH'qE.9gP,9$QNrm4qZA=||# D)k&Mub2Bcq^0`)q9^EHt]y}swTb$u-/moWQRY38ViWKUO`?Spy%9RRP:Sh1/JyHx~U)z_vOQ~j"Kh]s
+.~&}X]dMLu^.4g1i+9&$|ru65Xc;]o_(#]X7:k}(\^e;r<+6v,M
+0cj`V2{uA	9uxpysSWbjH9r<^~7RG@Fn<i=5.>m>n:/q_a\LZ|'"]]^1K|@[}okNco96%
+{$o	
+PNb8	z[[r2\efB	C.5chs=8g$v1XgyJ!* 4iGNKw?_nVCU^!W^9U|er+2"W
+k
+])!'/7A6?f?^E'gVYvVJ]%iFU[1}:v66b{!XC6z?LS|L"M%8qTp&>;F}Xc~sP}j~?MgqiBgwG_t@UdqM	UO:UU_>"4o:pJA,'QfDj2BnIJUbNT2ngp=RMl|GP(?$DZklyZ[b|_&m[hTT4t'&GUTx&<_Vjq~hTL?>p9A9Om@P,9ho8fYCKiO9=6q^.} &=cVcb'm/ez?`8OoYK4iKU)WkmcG'nq[9AF'yIX\y~AIq_ML;vc<L!^(p9R<#TNaV'\F7O'/b\,sm9@
+c>um~]	B7t[]D_i<-E{(ST~J}~O}-\c;9p#Yg>bFmm1&#2GF rv+97B>m`|st3_??Y5+9#OQvg#WY9we_Nh=r|l+5q'">$~]qgs
+a['q5'8dxG$#?2?<`.18c2vn2N_D'}f
+C+B!O28;&1:_Vi,zmi dMbOibA ``\01!qg#2?:/g	C7LpxQ7?)P;/~]$z=4s$45N][y$dgN
+0A]z`aliQnv`AYls<[w4&c%>\awF,naZwJIg$6F4[Je:4	4-&Km^nMN~Ut[Nsv=,>;Qw~lG^I[+^GOH>'{_j~9gq4sno<McX2]Py
+J N"1Q0Ul7y=+J6kb#h+WM+.Q?p(+F_/Eit?S}`_,->Z#~gtAblZNnU{]-bYa90WE9)Zr:~tw8WB?u|5~3K|)a|k-?Fi'jqoL~
+#u_v q{Z<st[;dVp_e0iHwZX.NLM(&C]mCo=m<OIH'e?61:;<k{XMurV+l5^y*bm^8 -Wf(^4 ~yy8Wo|1trM<m~?4PF:e}i1G2qO/PV3iU7^_/&!/S+7?3g?tGnR#w9g+`-ER/_!_z,2OI?Xu3QTgA;F1Qckv0e}PbViy~ib}ixmO/RR}}#iYyBXz<7CcJiqwkr'}y|WKgwcY@}b$m>0i,j~_v}dGmMknOGUabXmb-clJ<L>z%\C^1^r\Xq}N:nRc3'/hW}BM};zo>qwysDblaoOS|C{?V3yD#lSx!J3~4Qo3go1AsN+Gab2y<qAz{DS=qWTi1c-G>z;5|+2h"aq=zd>/q- _\lrB9*tx#^~>uq	BnB2!wl{M#[azf66qldXmb&iK?')3	rs?,%+1#]Q`p4Fiu5M"EZbry_(h=7tOvN~ib['[cGJh#i6+6hIr!s^BSr3KK2vT?1"m-]6gw13Dn.Ns~;rED?}u5h6la
+]3AZJ~m7Y(DAgS6KCVQwutqXm6We{s4mZmK+u,tbOT~ly9#k+"YnynJ<dl'OD=WvO9w-M=] Zd'kDcnk+wMt:+_St,Wt>9+$KbNU[&IW1tGuVfLqZ?Y=}m+0't<#nUjm 6sNs?h{5a]7x=0kM'nN'X-87'1,b^9Q|YT{o?p<<KN,C6&S%H7+sy%8aNQT|l20RG{73F:}R'%7r+7n2KgM'1oxkY0qP.VmDg`M8|'G
+'q?^<C)29y1iZe5I/X++~`^.-gm8,76vndZ=l5~f56vgQ1s~K="o@F;/y|nm8[)Yg1BQ#v+}A\8]^)/x\UkRGWbZW-Bk5t;\dBT7T$6(R	Ie$\ZHFAeUq][{vojZkmL[~L?zr/s@#&.Xg'VsW`j\_y/QA$.w\G1pqnYh ^+86TEm7
+.$X.cno+>I+2qA<)a<w?khDbX4WhSHZ@7#}H$&i_P4zN9Qo}[
+n	j;yF[>X5:];}).$u-GldO=>Y!O>n	Co'-.+84BIho @]NhF^b'4Sj>q aLt8C_ZFu|f8-5?oo3]5B~=cH+`[){hW>6
+oOM1rr[c7eW]*<bs]$O[Ox|sGS~c6_5 TjW$o]hJh[9Lu_S5.]l;RG}PwdypsS8) 00/c m$}4Z`B7ui?GYh}fP'$F}{8s??`g@=<Tlpfm m&Wf}nSrrI4omsSUn<zX3O]mpgJij=!4R1Y#zn<e7>95g}G}@}9e}oA]m*v7zo#?w7+-w'2QK N)~,yS0}fM|Y&4Oq'&GNqmjs fO7Qq.wOm(z"y}06u#-/Q'~'1s.}vpQKp<>33e/,O{ge:ToO4L'18.yRz~^
+CISH!Ku_}Io`Bx?ZtG^?M9!D#}Au`~l_)F[<?1i1N`:)e:yy=DKB/3Qt%Rr	sXo8g]B28;~k\@#+#<|<;(>/RgmF_JM
+OVy~ck_5S5{m{Q=r~4?wc27)}R	h-0s.S`/x]8WiX@RGC9=6Zl$mu{Dio=Cdx&E^/Ks^T2)q-p}
+tW.??/C5 34I'hi=L]$#	I0GI~oM[yI[|Sy u_`]w9!bYYa/gM	8_%6|GXuiG+'iegnywxbz[zkDu)]6r}ai
+pto#,M~p&<j;5Ib]{|v&o m:|}\__Dc+K1v^[R#{d,a^4j,!:yF{S88$}	qU	24Gxuj%H([#}_fz0h}>mtd^EM9I(!^'?3v7']V_q5J8o$X\Bs]-kyHGB%})b@y9Oe|G{M~wbe..1*27eFEgjk:EfP1=I9oJ@>`m~:}$.}Gdq$7FxaHG]*3&/qy!k^y.2<n)[S_q{(!YEacMim.)/ o]?+r>{uO}3.P3qq>9>whqbO=x:V/[phim.naKPu||W{L8WnE}!ggmi8mu;yok]!	Ij9M|0xF9AouO}<O4(I\ivcxb{&
+9~bqcJ=vep^)X=$'n)*+6~|GkGL~z,eY_Tuu'fOU'W7{4I74I9z2|LlP~[7<Mh]?kxa_>>pA=W)3"
+py4e>GG'LK%DOd1>7x0%}	$4o"7rex>h'(vEu8E/&jW'=
+2Fb}iOhDjS`3^_:g>2nmo<%]`~O*;]e~!L&_~,(8Bl"Z/a|J=-tncn&hET
+y^|hWb<V;Kbxis>N[!?I\9*qN~7Zyo`i(#	H|Tdn][F\=Kz5m)d7sB]	Uav+ _YA%o+TGx'8|Gx5++FGplJAe]b&4	I~f;f<c|1q2/Y9+.Zq|9?ZGT-Mqo]}gM18|e0?#`2?9.-P Yz%W\s)j6~wXCAO7]2Y291>9~sCD!~QE|}a\;ju*N,QN5up<39X7$zXGS&s2>1s=585SPu|=$qRp|7NwM9{*BgY%a
+4+>8e9/|s1v} OivqYcCD${_jW>0M_ 28{r:\1gri)6IGcQi>CR^'KgV>q#~eyz	Q=K]C'ci="|omQw'q<$kq'v+u(wikwTGcae)OCDqvva(/]XV<R|E^o	{x yQ<~Z.Dlg0186@pQyp3()rk#}D{gw<]gWTKDc|b'RW*MZ _g$i9k/m2a]IGNnK71]VxxT[=wp	g oz8`JxOGnaek#fs.P{gXgoz>oD_D"\&HzA/a\CzY_	aVL9ogu8?fcQa+q,Yq+Bck_dR,1~k|x:~NRH0I}%>/vYgVPw&O1;op'ri,}</\Mn7D*{c7&t^oFjSu	cmi9Qc`uh_WX7p'9k"Oq{h+4\J>y|5OeEKYS8C'{;M?):=!n:6Z~nyst!L>O%hc?@g`GKi:wc}sv>NY|!:C:tY5Xo_3D{7):e_jv:3KwXNNQXznk=(YSxmd4iFeq_6D!eaoVg/O+-z$"3vFa&A"F~//|bCy[b[l2$MfDpq3t%e|Sl,ix)zA3~8Mysq/gGoI^~OQ 
+hhGX%6|]66s}x%>-:!K.>{;1[fs~_iiX:M	wW]+q,k5y%}_4q4E7<u EfkOs	{Q@;hK'X77s7#6=c}M*n1Ow$c$}=,|IYJ9EILBK|E}[K=@yH[a9C.K<cK`q{RqM3sYP%g<3L[9ah#d}32M37z|Oi?Iy~`[ru/p@kTh.>/p#ZK&6t7@S9oO8"pAjrcBWXs@w@M|M+x}2>f=8]O|*dyX|+'479.`@3Deg53I , -![Y	<H>+0cj)i$|MyxUJSN^Wb+mxk/9K1&!/EJe>4<cZr?=csus=LEa?8ek=p	0Kh_v?nk.1tI<wg"@rh,tkV10 <oznqw5J&L1=\kt)-c^\7[3amc5BRIRO~\=>wK(Q]!L	]'70k~9a*o%n5G8Ab>[Jd='d^#	_)6q*T\L\]zxwc6s5-)1:O)}}sX*g&r3NOI2/Qp/PFt6F'}^nCs%cOSEw5i],z'***~<[S^J(cul%=Hs3qs<j^.Ou%	xA#R-.v!*:*>8ys8xA^@<}kQhAz3V`]>xVz<!M@g7*`EYs,ML&~d%g#=U:y.S6\W7~A}@'}:`Ovqrmoboh_I+s3i?G#)zum.oU/	ToN"59zqCcO=$Q+5I:~O'}W~9 7_TJX5kc<wj=u0b|] =51;0S2xgZ/>|'MefsCm@wpmt;;)"{{0$?=|#c8IdrcQ6J<g6}0k^h*hjNg[^vpn/$SH}jAM0?3u'7 I{{iOV|V|.h><>pW:]|'\nKT}18~c0A3ws0G>1`I|0i	_ree?M0)|<]t;y1wE@sje	yn5{6?0tEgTg<&@Y
+6	9f{<adz8ahwvs?7?,SrTbf`~B}eq8nVy/ksM<m[M^ZA3\oXi?n/q4i+<wfKKN_J./XOg#xG
+H^{g0|3|.=u`2:0w |dKxMKyhlZ}yOpmz.ofK|f"9l%(3c\A=;xh6d#Jt2\~#z8>j&sI0k}t?}zW~:8*I'eQ)OqD~b3P?sT~.Hb*2t>	da{WW&QNy(GTt*.~B})]P.2V">(6	w/C~_&l+Rgh39IM6c?-kh[>/MGy+1ZK9679D^]]~/~MM~e \O"zS$WJy$/=e8&+Pm{)KZ=$`N
+2> mug_7
+zV&\^u-OM#s%iM=DF^<"m/F:_w?C*v7<'JGHsgK'rn5<^K(>&/:.N^cwEBPM*e{qASmG!D}vjPOn(i;8o~"^0%Dy]q.J|1z\WL}xQyWA"6gB:km`|qW>P
+tK8re]x~	Tbi0r{J2k}bPP29TC$bM&/'oO^	-}:>?z[J3^ 7WNh~tNR^)'1)t{8mq)1s1_omO=.HxIKwo| O,k_7}.I
+0^rlz\ZAujm] 0_,UOb]^rIG?zAM^?~dSG]O?d1nN$cw"mNQR</N=:18;)7w ?v_F7,cs6i5}u^y]>&h6YoB2+olEq`|`]3zx)Ru}G^VAC65p5?/Ai>'++2w/b-OwQrT =(vs*n<S_i33Uio}KI8hs_Wu@T`FJUz'#s]!zprsv`G=nKqFSgI;3m//v<[x_%t.L%+qQ.~AG_%)B	#sB{1[=?w|5muo?Zs]oQx8.t1.,\S]1cudJ6,-~1vt%vu2257m0g,Vd@QkM<\as&y4O24d.pNkBto*pfPm5|	u h;u_6\rK}e2qC)6#mu,)n}WceKmi/5/5z^*A?_4>0T+.#Jgvv.i[VbH-kI$Yi}PZ]lV]XH/MeMOD`.Du	ILc'[NL2%SgO-w<|x@lUQgxe9:^1^#[J
+$s#aejJH+Yk:2g-92[DlzS,VQB:7ucJ&ds|%{zGggIm9oG8t|}5h<e>45FBmFH:v~{oEg}9826bk}kw==ii!}?4D'v5bcw?*xinz.gWg|uP|OxltEi?_x@N nJIyWN+a4\[/UgHfOAiFotuVP7a-/3#0pZ6]*e|%0 u9X<a\To|+VH<u[ W^*_JU]>-~95<tI<w)g;p eHXu-NGp)FY~#zx;`1C2x0
+<M}{{43h~xVa{Nhtyw}uzW*xS<Al{P~+}|4eIg
+`qm	nug5bL3/R= r(z$wo'<Fc,tt:Yt+9_>}H,zg#X-cB034hhL&O4mzF6f]y0c;kd}Q,W6t/'.:z\s/?s194	;gu`aD/'.$u7O(R+R
+pKUU3ElcSE6}^U$mCuA#S!WnO]wEi` pL>:vKeS"""1kyJnJL
+:I^HmgES_+}0.t1O:c^c2'-PS6m%Tz(sIU'j
+q9	}^j?*Ti;12y/ >w^q]VJeL%==|c):tL.DWsSzI"?*<vD8pD5)-g8|8Eq.)?iW?A%;k+L96o&x%<Gf@;;vZm>R{<k4-J#tp7K2KC`ohmw'E}YIy"~m|Uxkz1lp/=L>K}Yl-R{XT]ukXS+>*_&_(rOpq(aoBYJ3~sG="rOQcYn^mtZ)7qcS</)o-p}+oEB\r&31y+Yjnt+?nFXJ<{pH`Q'?C}n9no]F=;;[dE[i;oNk<COcH:iWq!;qU	ba|cA:K7+`L+45qS.9`25]&qO~`+e}X_)m&7xeo3r,y/Z\l<D?	<,>.g)$Cx|9cOSLSn%uPx#f}FGtx&>`C'W=%xu$OHc2NEIlM%a<aJKmK
+|y6{!UNMy%f,O0R?E|x'`dbsMI"{O8=: ;c}p&&3[&uP7p`\w:ehQ]3t^sbvX2~	{Mc]W9h^b<Ov>N:4t7eEzOyZdGRpO>mu,s/
+M1|35'Iw01xNP["W
+uaM{mrg%n&5c/Q*.XO%{o91}aOy{7;uU`)7K<xNBg"M'hIhmlL;oNxCM	MW>zXH"){_4g)cQs;0c:2Yz(9":to0Z	7%sK &PXN_kLsr2~C!JIYCVbe &$5>\~w<wg4cLB\+wmq??AXMZ/5V>>q
+1K	Gb_8|qV%|~rxpg) ` ;&t'*}&4cd^}QS`?	+	N\slJ@2Wb]@W81S>IUc,0&pPZh9+rVX4]%O-UK]w-uGR}h0b2I_GAS'Z$m<	ec89 :^qJG3OJ}WW>/Hc|M#]IxqScieRy=>u_xtDsq\~F~Zd:;K.l>Q	R(pm|{X&B73Ffq/#&^1caex}J9G{
+WxRssN;(k]:ib)4(gypw 86Fu}:yD^oR5 tqvDf|v\nyvd_b
+^lxUNwgr.V~1"PSp6Wm`D![ENXmCZVZdp6<!+eDi"swV9W2eMJ[YGWn
+WSpB7}P9-6dS.2t>h4A2/+lqM+/'Wsc/ % p)M2,3'?#%h>3'96{mI~t(%qYO{;"1unu/rWJ;1	*U"S;,|<7OjYka=	kc[S+&GtIl{ap4#OPINu'C!UCxor}U38>m
+'7QNc.>"P.$ nu!]xTw(MxW.H-x>]wWm5K'K;/6 ~y/z#_:bOm.$]AZ-}{h)qq(umswz;.o/c\B_r@x.%YOY_tU~<d&uM	}^n)oa-o>~VUgu/}sVxc ":{lAO+=,=AP{3`w"t[w_L*GO|g,yMfe6IKzIgG]g?n/
+ioK6g["Oz^}o0l3?u{BNntL0gO/:ykrlPYD9v!?S[JkUS%b/1B,#O(yq7agm-l[{;{AG:>I'TeUw#6<~E-zk-eB5U'OGww jI]t,Ko]e&?h\!;g-WY/)`ZxuL-;2m_ZRO<cWRSq1V(Qzec"VjJ*w@>l@e|[pS[.x$~?v5"$l 11;"}90w< { uN7\MRNN_au)Zjvu@71Ico0;Yx9:[f86XG~a$s\>S6	W~X:'?n@1#mN)ee8}KZ/EYhNReGM\:f~7YG_bZg%=Sc~v%)_	GSrvqo2_ar"~,>?d'b_>b=.Xm~W0g6r{S|O;gOsfEI!t
+iP3*xH>G\$cW\DK mcpCp#_kcOxJ7[RlBIA>CIBsB7'DKC9 8~$~#%7bIli;\'N(9&	 42^3_bm&lH:c^g]hGG*B5Sx4m"1BWh:SefE|7b$x+`9bLeILT(~>;Jr;A#uj3Na
+Qw?M|sZv]L_B$/>	)0}siZ:W8gn5D]X?qYd3lJ+u6a>-VFkSggPzi_>qf~YV1]pM;4{Kq>kDr<c	AipT0^SjcSQ-5	[nx|S/X1f_s'3s
+6n&WSF\fG%k~&:1Y^`|]CqAopGd78M<I>G?/
+sC"TZ2~y<YHPD+KLd.;LyEy(SeP7e+UAna?
+C-t5G70hbSt'4}yE7u'tPO{C;OU2gtH$;Bor72.0P'_<s:'vQZdyVq22Y3\Pj|z;XvW<h0UsN.DUQ0-EQ5Ss~Sf44WQX$<X _`W~	_98#qT8bX/<I}A<C_*{4mg^;Ju0~y}x6K|;7ulMaSW8Gg}@cKFrv|/(y{t\=AP#'h'XRKRnn6{E|FRrO=e_iK(589in`{	}FPEr^/k3<bsm#^KH[vW`}m] '2a u"ml bKq]1+5a'}S+9INeqc|*Lq9iG3A}k!)?<gc|SGSt1ge|.=9B})6\O>79:~ y^GB;yyq:U/SWPNJON1_`?	u*+?qQY73G|`b_yNwr2yx_icPwB4RSsL'4%f\4/'5W(hC^Y0^:?6/MjqW3{$Wlq>omgftW)oRVIf,uA|v5m.6rkZ*pmu=g=tf}4=/y+-oW96@?>6x>J,"<CI\8[m_d^WnI<&)~U~Pz|sYg0iWSewrzj)'KE(-|mM|7Q(_podUwPG6]c{z$X%ej_y8oG^o3V*eXqI<M"al}@}?qsVaXsE.]IYUD+\xvOy3z\<B$N5/>0}ES<=8y>,7b6|/$tN==y_C_.~7tl{i/ypwu#jZy~QyRoqeWZox>w.D1f
+O^x-?==+9z{gJ8S]j?#HC_+5%o)N~#<}oxq9n~#/\Wd,?,w\*x+~x/<[_}^|UOkQg=rM3A
+*:R9y`=y"]{RosblxF8_}33xt	ok?LOW[{XAu+( tl'xi/^P5VG	/p3u+I['puO\{hw,!;<|AjIY3y.8Q
+:3+,[/|qG^:z	i_r H"_X;.y$?-_ZNW_VJ^hI_
+GGC3k24M\q#{,{Xs^ +~hI3!|ZB _}|Yq"Oj(4JtwX\->&e`U{?b|{$+u?W@.s	^?k^f]f7y/])e`pn.C;>WVmoe7}P+P
+m~5>bB%8GsM8\9w]K,di\o4>#}96vj}Ji0Fp(G|
+_R{QFWk	RO2&&q
+"i'oVx<gYEhkYwd|= 6et,'otx]ff92TUr8LM:ALL=Ooq~9Y,3RV|c$&+kiO?71i#O>!ufs?}k/3^oz|~w=nSSF}z3o=uXd?L^#p uc{!Pw7<V|%-q['{g,Wt/q]`~]	>[@?\/'a(K>I@65m6El7G\SSf~Qp Y?vhy3IQL}::\3.I*}[p._k=M;\7wk>ye	ESZ 2!~A([ug~6x75}\!o@B#lrVyy2G>FE8grif%"hOxjgG~gqIb_Gp%+($_mF}$_J@>Xs3h'~jPgiB7>MoDNo
+R_t*+\N<
+_y8egtDx/h#skHGtp)kcm_)"m\:5eL
+yI
+qfw/AxcqaiK	pbH`?R$9Oq"5<PM5.B(_rKDfg$ePFs.6}m<yJ{{4{QO_c/o}MA~S4r^M )t`E95/BYWm7N3?+	o|Xxu_Iz}SqGLH~tZwX@>kN)S+OH[c:sS;=/]f^FFOOm^P},A1DO./3m6mi&7
+|Gin[SgS/e2N?>cEYW}xM?U1g{E:v2!Ggk>YOk{a|^uZK{7jJi
+L#;u|@"Sv\@Ix%cEgv#7x}#}&?0sOxZ:_sTw6Ouln!vnO"sq_ve|_1S;31}6~-1y5m;>SkLQJ*+>.OUrg!/5{ ~~!W(#M\On9E]J\);t'm
+hut1SO'g/ESoRe<[@?1eSu,@U|Bhch&gGD
+U<BZ-b@4g?5,>hD+/q5-'^G:=7O~znOQew2.p{]xx5-oZv|01SQ#gfB	-w:q*/L
+ua ?sZ40^fXx&.{o^Y[Z'~vDTo;WSy|IwHa4NweibJJ}&3Goq563c-Yb5OMOwXNlf!z5:9`(vpk+,[$_d"oN|fF|ZL&u`/lJT|t>O7J9ghKtS#G|^~iw\]klf4(~;942QO|&-~_
+1;6q:QsGj>7{v9s?|HO?|[GS">x'rj'x668"mh<z47ctas1uL>,5<=S=%'=]SiPw!UzRq!\CBQO)gXW/x` xV@p ^'<D.O =-'O&c2?$a8{j*;<Z'24}BF?.@&OYxmvb]rYp?RRn3Wu")7r9348.z9c9`OLZR<_eyH	OFM(C=dD7^#o<Lm[NC>Obd{c7D=^z@O+(+zq.r?@#_s	Sf	\/A,zm+V0P&0xyt//2^!mNmZoX2-v\bVGe< }vH_p+2ognfIXy:8lG'c\S{|r'xvzl<{y|qO,Sa]sk^>Zvg|m`;7|imG?Xb>c-UK4}6]t1S7 &O.DOC_s(:&/td_gu$Q.`WyJP R/e_)N+P~DW9H#C<J<+|:{_u$K|M}OgO91\&bQX3Z~v[{Ol5~fHqthH"~f#/z}kt<5-;wI\!Mu}7u@>LN]y5V28lv6G	gs.{k0M8/q/{lmO+S&k5<6eno9?=%$v#Rx8tez1kfN=I9w*We_ 6S4G7>7ikzN.
+j-NNeb[cF|A~Ae[q;gLq<U/<uOX];X-coe 9K@'&2!S;Y(MyAGx7dUy.>Ny5y6]DgpNG[<;jg[SF*?jWb~&8}Vb|599_zUG?]{ fd~K~e;#oL+_qvxXtH]:r[n\5p:pa+o9`*cMl5"%fM#hT$j9kPz]LMZ@OuAo
+0?Ga`%ExN^?^;]wN+Y6q~-{_^)6vKkMu3o yi/D3>#O7r1zJ?[boNXqkflm?K t]Y)# )@~gO}q@hO29_'J:c:&RwG;Fq_#Kzd-`dnZ	b_	CqSB35~Oh7%AW8>8g, HMF5m3	J:kWr_s2j37Al=q=3p',A;dIu}G+Jq}Sq}"e-E~=Ew]~u1eXq]'e|Q4?8x5XeP"27v<CtY~..bWrOM'M_\'{a0\J]JjZ;9h_r6|~I>5K)Sw'q8A~\p}2c8?d.R?_i}'67W>,r0.kEo,>*<{;+o;uH	'7pyY6YyY:>=>6[
+bjxNtc\Fwv"Ob;K}o7gx1feZI$.C>sCdue9i54,\<3X67nGzqjtO!:9Y>'$iW5m.yQc7g-O;:rL|M9bnHZKF<Y/[[)t~Y);ss3}E1Huvs8??X,`XSz,sLCpk?~w2m<Yv,cLy*xgZeQgt\v9}z23^yjof,+kN#xq>y:4r>gfWF.Ly_Yt{|(4~Yws\Ovkg^yXK}ytJw>eKtL{_y'4g)q1g9FO>oasUob)jkN=M-{{%ca_e_/2VGkLR1\$)\nNiY/FK=xZMzk0^0]7C]~h+97yTY>o$z*)3_zf^~3>ig/]vZ%m_|%wqwzl&Q&$Mz+oEO]_e'!:qa-Wf^|\5Cg2o]=*d;Y9Kg.7[8C+w|uaatZFc~:#7*7|E/6F}:6rIud#}W(N#GM-ytc3!>}Cuoq=4yqnt.??#FqiX/5cU=cSs3qp=$W>|M{mc0 r>/e96qf{/pm_xpeU {3+IM=&	\9vBul@C|'	%=H}E'u5^1e5}/9M|(2!=g.xFy$A/~\O-'.+'^g-!-cDm_3M-Ry*WiJ^@yXbu]!c!}rE=lvkG]p7p~}f>1u|]y'rv+,>8:^h[oajsfW|F;jcTx;~wwEapE3uhcxkS)W'fm/Rm-#sG?SgRsz]c=3=F/^LX*vMsz80OWq7B#;z(%f>8Gu\`WbAnOp '.Ur5?c{F?s]GFY!voFW;Pr~H>Nj.m4~WJtL$t2K$I5@)7E\i|0!ROT6:b9wc7E6\,!/`aJ>flQv-.mfs#-s}pvmYmkNDwmfeJ3nqm<n6_m?{6Nm<>s-{{S{Ry<pC\_sSBFn|LN`z88kRcS@;{Vno	~D"a
+34i&?NZ0R[]=0>{S<|{t:[vL=Rt.]'T&s>3r=c'=T'qv+p[!~`s0.*f6F?_ N3RWpr}P%GS-Zv]9fML8!"lP	b/k#s|T:~i3	7yl7uGxY>.:u\CC#XLcn;r]#3ea{GVON{}um36Odg2{VwF0@K?]#[#acRG'K/:4idXgMmKBC7r1WTboJ11}I$+S24-\#[iRMfpe 	r.m me'H.Tv{{|YiV1|/32cicod3'k5toyX&XRvB\@YBg]>MXrsR(/4BS8&H``R]WxG<O-xG<sOYu@91rgts9}O2Ve%zo@a|]pSW4rHu<x?\.xn|
+GpEtvPjz
+HAU0hM a|p[4]M@e/*8d2ivzi|`7&MTbJ"HeF=:	:5iORWd.7plFh3m@u`v,|o3@~-XO{o)Qy	|~g>(]%|6/8Wz{w:'zJLU'GaGU>
+\]%KC=%!/J-.&Ls.+\9^S$qz=,0}c[2[rrL|wa< `UF{y	qLC\50@PwP91D_me|p!}5uTpOZHr1!cj9/>0xa
+R)3
+'1{oB|0dPg;_H>1MM#K{tqk_J9jB'foE\=++s|07'';{_"[.Cw}_ /cI
+u@NOl?~:0Oey_Lve]<
+'
+Sg.`18!v&Ec]+R'm?8<]#Le*!_89>o'z^NpraN;	mM8xeFo#JP\9 [,,'x[g5<9Than^@Rs1~f63F3Fw}nPV4PSrB8>pIpu'b]1#R.1Sy+o )S&h2=~BPAp}|g~nf}.3ehwe=>ynF]ks^=&_|9Q4(?vh{	x45Jf9Gsv-~f8P5.]+:,r@^.rWr2`?|'8%I:=nwd&>'>E7Zw{;pjo&5~$?%Wr{>}RZ}/ uu={#"%5ks98pgFEtfg<2D=(3y3agO'
+l\EYtld?Xss7wgl	lTc6	o;36	fY7(l{~<U>V:g~o)_9>#|:qHHs7H(6qO7s?
+?ehA>b-||b@QikcGu.|T1<<>SIp;4|_+,K5[CbUuFc^rKcrT$
+llqX;+(7BJ=?/O $GH~})$C
+*vqw0KbPN6Nv48;`|>sI3R=iHgypIv,?oM~I
+>_fkCvnz g:L'gB}i}xr/Qa3V0?7xH3=h7>:3djjy/`we,>J1rHgX7o71n&= 7?LKwf?0ckLr89Ybc%Gn9ebNAG_Nx$I=nEY3%x=mi{@||P_kv#`-_zNcew]\L"?wy
+L:T6-aYc1{1`$<S+J,PHcuFW5d|C[\ei?PPO9Ej>Wd`Q5(&L\1F2z/^Sc(?G+^k|M$MZb >#x1bGKM'}eYzTnxut>=XO{u@++} 
+P>u@8'7x`'->V{UDy;H~ 0@5^X&9\,o;$Uaf\F[ds+vF]OZd(q@m8;L}4}+c|R7Pk^}R~*4giT8?#!<`uE7=1Nd'3'o[Jl,.'F-=I7&<
+]Qs$hb.Pddc9BO8zY#>YZWO7} mM?(y>c{Nx_<$g}'^#}{4uAiX({:<O~|1{1o~NS"sx291g9I23N_8"E__QocsE$+u!,)6^2>Yw>8qflJCK{m~oM*kW[M={Np^Bg^Lr:mC5@Kfp=>w9hrl~362_!5(<U06~YckV><Tz7c7(g0Zy?zD ~[q=t,	.R5iKLM1dlsezOk|cKo'8@
+E
+2N/}&0n$x^Ul[Zhuch	x[M_rc>+BKxuh2OK88J-G:_S{)=gAtNIUbkYOP:ub9/\+;Wpu=x3$i_7r#X/?	H@Ip+x@|M,kP!F:r)Ov}{*S+xk6_/	rs6}Xz'&nHf9K\q3x?x>ONp\CZ>W:D;D/1+svP$K~B}<C3M0zSw\u|o]^%QXstO}>V{5\i.|U*qQ6Km?mrwY_sWujq]k[q\o6e$PiJpZa\fB;c^\_?vF{q}=.T}ykC	g|+h+|iQ>i)- VSU	wP5>1ZcJMm~iEZ>`WOz&'%T.+w9:L~2%YqLI&0}H'w1)'n[aE1<[5G#op">1JvaN.vmyu|A#C/e{8wG~!1KOceFo6v3KD61t'^D\408<-00n\Skp[.:c>4!(i7KN\8}G	.uK,Oj{@aF-9gc%'{5cai`^-\.\c]5{o'tQP)w97h/ef|3t0ccl-o-.>"/9N )S4.kx5A/>::<3amW7I1K($aynOIl8gO
+2OCC)qMoL\k >NYQK.p]NUjnd]gKyNykG^KUv={j(w[Ks|)Y9+..-B	QqGMRrCQg^Ur-WY0.:>#fxwS
+3BGw%cb'K%./{X*zRu/K_W0_61q1=R?q=do0?_]wlAPk>}K&j]9*gi2OO}-_$q{q3w~}OV}OR64z s6RMz}gmV+=`kw'$\KW\]\qW*u*%.u&FqU3b=,tVA%? nX}M[/i'|Fow2.|e5qI'a$mW+p3mu~^uWfqM5|\q]k9?e';]G?Ic>y<sZ1DJ}	tVI~1oi<vwjo7x
+~_5e~}u}y h ~s^n3y;w3:u']<id'K_[s{? 7Lp"x.*3n.I\U6b>nZ
+]x+WpMu>)l\3qH c]]x&zp=k-ug;%~ophKvKqKz=#.5:O=o7\n7G~"_.^uu4}M.Uw6T#]\~',5{D#lsc<>{0E~{?ouR/~.
+h+^x[W6:T.:SW~{Y^U9*W-B;5ZE(T[gj\W/p}q)\gqB\N\p}Q\_]\?S\qz'k.+p-\\> '\)d%]wpwvzcX$xGUf{6`8;rI(IWn[5oXV_[[C}Hsw]&;LSvm5~vW=}VW_+:_3,ZIr.WerZ2dI'J_R1e:L.sgjiQMpW"Wj\j?yOkY.uq#|Qp@pyw\.iz?KM>>b}YVt*W1ae"Wa1ip^k(33(	Hg/PFp+ Wu\p)vM(Pn\
+5+@=be}*Pw/=@1*@E
+~17zm3?yOZ.
+sIfU%]K	jVbU.fZSW-X/MP#K> poT*^QSo*m&Z5Zh}ZfV[Uf}ZgY/Xa.'kw-"f*ml.U`X?Z{G5wzIeu!BP<o|QLd.@g>EVxSG yt\u>6G	Z#`Y{,e-cYVU\6U]nTjv:|a;]caZ{_]vksdo7jEJmU\jkgl]-i[c=|]-)^,)+eX^^UZ]dWDZwv[G#RW5EZczY+v,DX[g{]!nhk:dD;M+MuL%2|mm(xs1K|t2[lK)fw?#1u7M>	Z;PDu[suvXEag
+kvDZuN9L1+d1 V}R\m]{g-m;6wHS#VWE~GNQS`jYUj+j;@(hW.i["m<,&#;TCms,c[TCGt[hg?qg]s[vPM?1	cm(n:5o3Ugb1bw4 EVFh{:[2*UPNv7a :?hH{[CTtgjlmkP-ioDFlq5G"Q%M?#,`z:08Wg]hNzNVTUn
+ZvK1Rnhz{Gms'sn>5\PPGzb|v[/un.^pp5 (OugW_mo.[ePVmb/XUcvhU3%]W/[_mI{c7Uamo"evUe-IFE0
+mH Gjmm-vC{[L/Zj"R|mGrXG=-~zmE"0SIHmv]&29fwnk-	?ek[srCuWUUt")PY+W,^j]mpYYQqS~}H,=MvHm3IX<i{`%Lj;bMz5x_Mao4e}k.*i4UVWVbu%NES,
+niag3\<`6b$F/Pw'tvjkho.oE#;[Ya/no+^dBe[IsS-(#E6dZ*\YIjmK%cgY6.bdb-8i0ef"@}lv&fm<&5p`!N=3@:OPa^R?,s6U1 ,tf-~mMoHR\X4oYz~EEq/^z_zKE-8OM[cs7:qE"@pnhm3A3XPFgqAs'iip)u 	S>	6>vdCkskJ>>(&O:TM[JeHrfB<.I92hJ+Gwm D/=A$h)wOzkYo9\EvV]X[sv }![qO+)Y.[__VK.ueG~'@R^}tG,A	83[kx/V\Sip+W38,-/?"%%:kVlJZc[AL2|nW8ld6s"KV/Zm/r>iXL@#|-=Tk[HB-TUX^7;[*#v0y;#Md#jX1=`b*|:oFmB}_ :P+JH)9Pf#t4kF]$!v#0NHCx $	x4 :"h4pv.p1h0F~lU9tjjn"`Fsr\\;-bkdYypf)8!<R?H\w0WC#.d1#oze[otZ~ R4NoN,kx*ed0/@L~`l>V1hXl;HSNmj hak D6E1V_UgNAN|"  r i#(i~|m[9iLYc
+4r!5D(uUbGZw4rxh%n_Gv>+{^d>VK+(||tq 9O`Y	[3`e*9%og3[n_jB..WUc.f$k[q$hs.tiw!NRy%pla)33Ys;{,[8Q}9LSFgd1>L-[hblA&<Ee:ZrYkA|5B&pd9D"i|F@cl;Weq-D:jd`VUW-/[uW^[])?d5 ar3ZMhu _5;:e7xw %Nmo;XR@zzkH	wc=;9Dj'}ikt #/[]\1l09#sH4` _5)mH[*QIUQk+*W]-x*sk,er\.y;m3SCo#%&^1lvmjs'?FA:G3~9 Mc{Gmu`'09e599b"Z HSS$+tMFl'12.Y6	>u-O@DL8`c$9~-/@rsm}=Pw^mR8&!9@HjUT3yAx=M*l!^AO8$u6
+Yo'dB-@wzIhjak4PZH	`sPpUDkNi(mf$2<X3M1]c:#8`|T'"-MmI'M:7v5G|ef5gpFGQs-HF,teo=p&(%B "i@oP
+-BT$K^v%Cp-mkXj1Dq[B/5h$P?g
+j.
+LZMG0iNw]E&QWaIV2dCMTo(n!jKqjfjPe8To] bswC0?#Xx`6o8OupT?[KKg14VkEM;p-}'?QAV\hm )AWw|N+KG}\flYxOBqWVOLT:yO43 ou,{2JD3&{}w9xaB,ZJk:R*Bt-iw&\);;nBKLOqUQ*c.lkj)g;)M>$uwT?WH5-iQAb#t]_EcM;::G>ijXZY:p\K8(]:|Y\/br0
+wSc5iSk64:?d.E}eQ?Ie9nIFYi~aUx "p|vh4{1#q@WLH xMLHBT/3/"0/F#x.-R;f>q|jIcjTk>jnk|gkwENmEH1"%@4czi4Ed$@IQ|CQ `DWv}0OKm8ckD(#Z*4uD;R}]mN.Q86.	{}@:[,!@pn)[]%]lq?q3oG^c+-D>F[D[Mn5mZa	K6`1;#l)ao^Jaz,vYD0X'NVkG`-[}u^]+>w9'@.c6E#sFUk!Jk/o9JZ` urK%F.difmm	O4Ps;b[Ea1L$j`iu6kBe)1#|6muZB}:"D,5Q>Q`<h`f,ueKEKrJ{CaYKc,#b{#VyLoX3P>SHAV8
+2@" -p:/O\*
+_VyOk+Rhv+REHg)Dsz8JIn1Y/]#-rP.lAU(O@$(YevY DSR`bdfDMgdhBf'u6g'E:[WT_"C6oaFy`Zv[lv))9okwD>4m#2$Y:[X\E z)6JViNjoi[%{~pt4@Q.#]VC>"XiH*Rmii;j!">Pfu6&wPd]aso \O%_?0,s/]+law(OJ}"6U{g#@_)>jL*e6iNEg4T8q{Y*<`4hjQ7i RHyF"0&"-U'L(5~uuu =PgEmmSU6X7[<FGY<VUk|":3M6Y.jXN2-7#yad'DQQ5<Zatt{h@p8M+AdZ_Y,p*cRFN.gmvg]>+zNFhU^.-~dVFyG$M,^^82WT,pT_ew&#F2ve\;"9A	/A0KuUN:|B-Q|GZ<iAwv)^yJaadX.gi	kPh;kDGlCS{LF;bRqruM%8*a;wDS]$Y\Se9BHm{sR\A_5Z}l%Zqdzi-.EsbJ37,Xc'T5?a=l ^z+lM
+afmLY67d	%6ZLx8DvFotH%qTz=4Vrw_-m4PnzN)LN		VUpsJtX7Gyb;ve=*vTCy$|A@Mk^w`:;sOv`JiVWV_avI=(`zax9,'#UZ)6YhM$lMk==9	,!I^{d[dlG.EX@HqCQXomk-6ets5Qqtsc65L1vN5U@cZTDP;|(IlF|Vdiu8zf=O,_['-Yj~IPMkf83/c#lz/[HO.Ek["mm;IVYvME#GZwuGAyk6o5iG~uq9P_uc /5Q&djksf0Zv/\7kpo"'MNSR7[vd
+$FDMZ}uA?ij]Qi1MeYTD6~V|ZuZ-'h|%sbf0DF}+-6<Jt"'Pf>5kH~8I$ZK-}e^eDu97>jDZf-IC7jBOWE;v[\[x:"a?u}5<|45{fySqH#r\h{N.n>x;H]D'(B:8n<:@/Y-:U][6 55nIi+4'Z)dGvaE1-c{GSdgRVQEtG}FC&aki*~CqZc9[WFv2lKXZV+Eih~AKeA]sU&V%-/Fz`<ao]K0@h'[iimG]qac8GM\_51WM~fxVNo8dfSN[8L$12>R*yW $mr94i":5Kx[>Q|6+Tv.nl,[ep'OQqq4Q~i\1(`ZMdyG\vuM ^KZC;`1fQX/vV!;Y!hEh5.6AnjX5s!Fc%s.^d[P6Ywn2;8)lmjRe2bhfihVj\m;}zo|H_.S"D7"D,!V*_@sOm$&(h#Ud Mz3=^+4gdwi^N-
+(X7.&H	oU"LchDOVgjLYM
+pu5>D-}ke)i"G[HFPb$R	uFtxLq,Y$Y+]ti0zI=GIKUVf\<Rne\~ (Z  bMHhh(IRd]^TNu	]E6fl!!lQFhokTB5m9[@'0Bjj/ff}9`.+jIDM*lZ_A=-fv,LoF
+([ePo5mhBm,hl|qvbnVdiZXbSh~fw8.|n6$aXDfY
+aOs7B;J|l"{`EAdqi6a:VCM40{VlIpbUCxw[MsXF6Jf6^*ZOCJ	e~fnd\%+[Z^QLHs*^@XUOhyJZbMe*_j5U4@caE6YfUkiliJ	#33[}jU$"oGjaY1M!BgI{#"=uJH@G\WaEufVW_m|<0OWWZ joi5{A+s`Y0x0GZm~[Q'TKw
+.Wm*+Uls`J!Yin"Nf8JHI,zf	e;*^8FYRO=j2aj_^($U\=k	b}+VR?+q%A}hFNjGgU@Bikzt#/QfbO5W7V iV;6Wl5~DIWtHX1*[TXvSZ@([m##a9E8F;DmT\edm=hT/=AM5^c"bm66r^K9FD:L-/6 ]p#(8;vp*7.GFnjE_sVss'*TV1uTjcN)KGYa_aAf[X[>+bcWItt2TX4w,,6RJdRtiV@cFuJM)J(E{'|jry[u*\/>^]VKW8o_VVVVXnJ+&I*],Y=ZT1f::(Y0rNE^1gVgjW|JzJ|<,meeRK"S@Ra)l/D0eHhm[U;g_gJh4-E 4dxDNw=`_\zj}iCRE-4ih2JT5A|qf	_[@CbTH[nlj!6^&"Itp+-\\^r0;-YZcG&Dz`<
+>Zo06j"Q%IKrJ	o wN|X:\Xm^vM]UY%U\FKm*A:RTjsE~\WqSuK?I3(@URuesV,*gi5Xjj^wjo#,Yrxe	.To(fXG~C1iE@OL6VO_fEu H-YTjdUv)&zRV8:y)iVPclA*Dt~p~5*es}y@9U,4jUaal([.e8xRJg9UZ|
+d+0Obymm%k7XmUUU6|
+]zUkV/Jf5WZ^QUVZaU
+U#jP2JMjuIU7:mA[f:R*phk6p1sZ;w_nXV4&&F"(GjIO,Jcm\ejF	Sc5Wg-/sa(^gy1fN-7;:#]>:WG&#~]{:ut(LQU4zwiyv/l{EJ f i5/
+)s8f+Pt
+Lv}%nR+r]kZ-[_YVrUYv
+`bUoUYyK86;/.)sIP.K	 7e_h(E7?VVaK)7R<d8'8wI?Z0F-S@gAWb#a}eFl*[Q]~ZkQUU~
+:j=Tu+{N4<FqQx'=.|9Fr{N%<s8iJJ-d*G|
+3,&1b,$lB8'vKSZj9w./)X(]uv\\.V+v,tEKX\\SQe~ ?*Rh7W;8fwQuLnm8UN[T%-GG![FBqhw
+J#JYNKF/F:4U]OJ@Z*=L{NVsX-t_+28e:wL!K';%e!^cL UZ`L2ynQ~B<dZj^c;?6kyX!<~ f/"Q>,RuH6
+(6,Ukt(h{|`"!#C34:K2X`h@s3{7+#uy?bYO%Kd03b/?p)&$ UV
+#"c!EBK+(+Wl&w?)lISH@z7U}o&_9gg9wQ3p\FT5u	c\33Ab2;+[KU,UZN~~=<f
+UJ_YV-V\-o+U($4|-f-26~#2/n!kP:VLC\PRq`;gpp.C ,2Ysj%%UURkl(w45-.^4~.3^8vip t]L+6kCHqW|!=2GLEaC6f&EY_
+>QgMhKQViwjA9"4revWuhV0Y1C`u9973Xv/5dY/]#kVR84Vm1N*YA&YVV:E}U:(Z4Z!>[Ul82Y1EV"^7o)xXJK*tUtyich_U*+][aD\`KyQ=U--~ZE*w<]{
+8^f$A\#J{=q|c;lX@bU* lf]XvsHrbK57t ZiMJ<3}}f4PdtwKl7ZkG*'tE|l}XvK~q"Ve-FG9(J2^Sv9Ty:6:ZN-e-`VRFuLYQj#)uYJ7"!enFac)LD(U5RHYkT[FGQU[3@TQ]b04U0V3em3U%4gyG=jov]i/-HlvvV m:g~/~bsPC1f\N"&ei$EEi,SU:rF3*(4=r[4X7&~Q1-?)I)'2
+\g4+g0%-,Z2EUS1"$qyb F:q:%q&D[<HoUm{CZ][0Nx25gUtD4%iA\4L46@Rz6<(5 CI	hZ-2-B,$,%.00L/.YNE(&_]*7ySe_~4pjy&r`RZg&>|XWsSnU03U{"ZnE59(%q&I/<>N?O'ec
+6#\7U2PU[B=_8rk(i"LY`Z(V HZ{]-#PuFe9IPXUV_%oH~5r}`Rc~(!UzK8M-=4lbi-DR"ZSkwjO_i5Ki1 -d sZ=n^YMf72\9FK&DRk9@?C9tiWZY]luKr
+Xwgwrs-7(gu{{|Q|X=x?Ts+v4Gc;Tk.XsUlgm	(v4fh i\xb	4P r:+#R^x#6hmE>Mmv%6"Nb),%b^~%}1Jq2,TU%NR0`jivc}gP8K}VbnV: ~G<="N@]7k.ZAjj,!#i_FD_:,#ncDS(Z%/Yi>F"DTp-((niHOWr8C_llpy.2[i,3ikYQTbD	YP^@^DGr}7K<Hi1wxX=b8@}Kvf #ESN)J9DVI="R^R(RTEERE"uGRv]G>!W4c9
+6DNK-I xE+q~"KCh5f[oJUXri(;tcZ*[Dn$[e]L>'SG@/8[`hx-X[,&I*F%/$C4N2&yQQ^0$D^+_"UTwsK,66FU<1 [$:XiY4r\>U&#eYbSs}7A?FdS83'}_fuc,']BoHe!C`q%`R:CXtz GXw[Qr/m|-~<H~$3~RUN]n|WP5Y+SIRuC nPtz&V=mz+@/]S6+"~`L{>93I(lnR0]R~-SNnoACxQ
+XQh\%o.?:eo2,'?l~sBf^_ZNI0}TY)AS%Z!BFW#RlJzb1.mv9k)-AJjg@./VLzO[9GQ@Io UL8A
+c'&d}i{_" HsSDe\3lt_i~8|/q8|=giWA?vn?g2
+^EU/a h##MU~cpja)|%kV
+Ew;<!,j}Y- :!?5bu%GX/J|mQ15Xv=xk~SG)2x$7{QfFwd0gi Uwr0;|c"r~\hxUP|0X.Guy|EZYI
++*3_D*HzIx7%ka6CUI*]_#e[g"eXQXvssvdaQsMs5s*Rr.g7Hj/!e Z~ I(TNlK!iB)'^ENU,Q[/ 5J8e<<^ycmR%BR])2+AYBYrBR%kY6$JK"Zf1!jil9I&#VUYX4F~irU:kR@6t4_4nX,-2zPf2 Hv$-1W#D06c\	diC4e*@HR9Y8j@h8x5R=}1NF|:#Z,% /HHC(;,LjTD	`L0x? gnpy } i>p 8y 1 <G>uhmv;}}=5]k!CA^iNR8Jc^||/Wn   ad=# G r?10/| }n`gtt@Wfc@[[~LjL_@H&-*g{c$pgsga/rC:qu
+ a0naX}8G0Df0T2p `x>p0X}&OA	h?c#BB%bZ$K6Yh2wZRCMly1S$wVf"8we{]4`)e"P[U,LIJ\.fJ,/V>$!0JXIXVlZVJU-kU, dmRu%@{e\COY_j
+CBKr2zI0!eEC>5[
+'@%Hw3_m|^ml4[hiGDP@l4JX(~FS}	V!hoFuZhbsDZ&$,:	ULTnK~BLy<iLs*xr8$<3
+h4i7T<lcZ@XEn.#dc4< 6}kJBb:zE[#96'-C_doSlD)W$ELg	t}+;gu=UjuG@5xo EgJW_+R'xNv}4 i*e=5S#R^);=X*MM-!d2'/Rf)X	^'ffkpIha
+ws\BMK!w.Ev%FRzEmATmMMJ@3<5j78t$XXr
+Udf*L}}KWUlKKo|9; m%dJR`cY{q-)]/K)"\S:I9];zY-;b1r;#Sr*7FyGrn?"ZFSdKR5G.`M;8*mm^guoN3$;,[M	BM
+&<X:~@9MF!#-'Z9`)dLx@(
+WER;3N&|.Q)^"/MZK)J"7seX]dhd):"f^	fL$t2y98)f%sB@TmD>K#ZH7lQ Pa{IV,<%lwGh;R)6me a2]naAV{Ink6zqeTZmA\>O8l
+VtUJZ#O"&B[m{#gt	UR)A4Mrw)lA!|U+6U x4ZULUP0jtz9l*7jz9o
+d>~lNp' +#]\x0hfU'A}Fr_=WG$Xd;lrF7v>l.ohB_lf3LS43i'lMg^D b]`cTJDtlH`ov[T
+#t)+UFg\xB2@.x+.qcqqiz{dAQ%S(Zp{ $KSGSf6u<Ui$9En*/>gC03gQ^,2ADqk#t~v,41g$x]yt%%sXym	{}7zdq06I{grqcwqgA6b;(b-YyRRr[Y\"WL&1%}f)1E}9p+|_>x/:I4K\ Q\ig"KzM_VBi4V/83'wS8!ZA>FrTg	y>%>z?`Kj)]'IdQlzcrac~	qx1b&fQ)RqWk;;ZI(<mHtEeB"2,JvPs^!\Hkb]'a\>Kd*JG
+LHc)5%% 	in@kxWw,6}a5L;B.Hp% biM|4 rAgCp8=0 L7C`8XYB %G4hfaEH.M
+T$/WJ_D
+oO&E@<pu~I2-T sw.4D2V6ZUkhUVHHFfe|[b[;ZHBY( c	%-Ss.A0c$r	<<8XD?zx`9niHY5',=)%,m 'oAf,-"pdC=OB7|{S$~~\t:X}`$>i~h7$KA`pg'bolH<)4&%
+/b:*[!#&\J	:\o`M]$ lu"	&$E6Mc \z)IBw;SHyky;y5V(	b9fx2#k[BNRuGVL$f!	&BUtuc7][PpTAa]4J&lwB1!a!+e0VlzH')bRE.R2+A5AA:Q#e V%95-~ydl#*_d ,U8 1r2$"eJ&3+)FEuCuSU2 .r,"@P#~zd!0hhRi)">SHo>`-\_!)5R+KN,-Re]7:{#M_h9zYgR4;6&*rzz=XEwkGYna *-PV@L*XZ
+\d26^px,I69($|@	-qHO(I2w<{:9
+sK'JgX}s]`mB211E0x</
+}S|gpCRL3hLCsQv7d`IBI/@rZ8I9HnHPL <kT|7, u	p}h<:I]]==={-G[{{@6thxiPL>H</+P$8]|RMieM$>imf*Xjm}-L
+xHaq bth>$+*`dT"O!8>?WhSqA	U8(S?Xi`TRHF	7>~BY2`;y*><ddd1-%!Y4JHPiCxM%z5Lm;]w=?W;s+SJUZ455))4$tZysYnKc}3%mrDMH5d"U]TLWsN:R#'XdK=/rJ#idY)3O[./jq`^`8esB8T)#eUU1h-mL)*BJ_t	7h?z3`<<$.iT(mAU	'_!UFJb'rkIILpdta5_SsO^OH/Pj"BsaXt $>Q7Y0mH=^JEG '_4gYL`
+V_)g15CMbe$!]^yxcQ4F9hL7z!k]!dn[,%qZ{}GX8zvaA(0kOc%s4	$K1	j_VkEYPk]4$NS'~U 4	.A <T9S5<i5k\+b8ia1<wZ4 c>J[kh(MM!	KvhP@f%B{
+P:@@ `$R#@P'KU,f5cYs6JY|e`aAV`Lt
+o]dqG#=huoB<HiS2IqaY0iVNV')1
+8+&Da8c $RTJZIq#jn 35GQ3>t%_0/?O$ZGt-17
+i[5I;&]ImC=e,mdhAW0h*V,,Ay]d3tMQ;$eJaR9< 8tbN:^-U0#M
+WI9|lB,k&-'.x0xG$<duI{ilw<4.op,e	:Bb^z6qa5"=S"\CP>{y6,lC`+D,0k`6\sMg
+f`0suHWf|&>Gn:z~AN]i?nthqBsZM
+Y	1Ib1IA>VX 5hz{s#`"l
+^H YIE)'MqGXp:gK	fyIg9\9Kojg:	q!Xfy"wd(\X"4^XEpX?l !.e{uXn ICo[i7LS^mnpp=5} =a1mo;vmBmmh3'Cmmvf[`x-Wm7d.%v
+;u	Jo.1NV vbK]%Vjj Z
+R^H%Xc[{AIB}ttL
+t2Rt2Z]+n[#u~f+=.FnRtwmnw0Ta;na["^l ~JD$l&+JHUt*W)UEULg	p/IK+RjNSI=u&h0w
+2cN^&+	PXe=@~KS$p8!LXq";m}N6%z~KD6F($F0}<8y&f
+qRN|=wbaeVnjLP[~&.Q(Ccu\=6I*\WN07\&EB	{>bO:'|gMV	
+K]p8;CY BFy6&t1J=|hLug
+a`aU8.	Y]5[
+'
+KyvPW
+$*#t*+JMqU#rBP2L#[I'l'pNfem*2\zi{Mfz	S"q{2YV@EBZa'TA7WfaaKOA%bp.1)O*!2<[Czbh}eG%`+K}7^6E,MHq(0 /Ng~yv8f6DK9M9(f~?c9N
+iy"m b+X<m_"K^PR+TL0#GAOXgx9yN>D&&6`8DO;?08d3g&/?ykO?w~0cI5r0OsSf'k,\<2ET"]cT'QRjGKF"S	d#biu9_s&
+r)_m6Zv"70'JD}c3aFqEac
+&W'^|Rs}*A J,kHFT,xX*P0n`U~RoC56sCz7'ISV4-ccXd[W^~l+-b/k?_ck?[>Y>_.Bx?zH_2<0r}8!H(W,oM&KE>' q6.egXa)Hb_*M[\ObsDniTzMY->!6 m!vyl,-zY`d<'9cb"@$c8^g9Nd.1OL=>=!wb8J]K|K\.VxTi4\K	z y)$Q"AwH9:%Qu,Q[:l;BJ\	ApAC9Np+jZV.#*4B*^eI@Ud1D0i4r:;Sa7.Cdp8cDmn.edv#'Q%V]yOW|C2&{&4Y_Gj/z1r_{~OxLk'>OkKp/p	<$";i^KxD;@O^?zx}~/EO|];nzo|L?r\xxywJnw^o$T'<]p/xx ?&o{=2C|_x ?./>>x-u.[[[[90$hMtnq]|M:A3ECWwx@{P{CA{v`GEmUHVN|Q+9$	`P|)Q,6!_?daJ	fl[$vz1>o1ply@:GcCGcPG1ta&i?Nax415~<{e<^>&*4f|hl;\y2\;#	FDy'}a}a?Gn<5^5y8x|;.=-^+;|Q%oM#~C	!K]2{1p}?Kxb:w}~@"w1.-o>/qj&T1v7r
+FGFc#FB$=:e:zp=,~ %Lucw9kkw)IV#;Teb.6Oxw)].TdmGRZK7\9o.]i }hlc'Z+Yvg(Fy&O5{<$md|,vz7S_2O?qQiO9|\n9esjGI@:d]:W pDN53D,N-fbq~uou~3vr]Gq
+ Mk}Cwj<~:cD:/'+P q9-5| = ]2'*<olqg/q~vBeLl?F:_a?L{
+>=cq?y	B'0N,`s<_3#'B~c{1{6V+~[{cZ\?c8E a^ +;atF}/#^x'<kSN/`yG^::?GsLc]GU|;yt?&'+7?i}MoXacB2?qyF[W^9[itdx1x;0y5C	cx35|i~@S+x`&{1}]oXgaBW6<?1s?~/{#(N/oGw?|_KX}d_3v
+ecf0bf$eD(*RRRNyF?u<g|3q-	.|$(7+]-6K j'9Bvpw
+.GgJ\7{]@p9G\KoW%y+G]}p+u&9NkOi%L|^cn?Sw&?#kW|YZCSq/2Iw$.iu[9lq7;I_|?k!Mg#778"})_p }#qe#0u~I8/V$mi-~-,:SMOO lw7CO s
+1=Ozu"_w:3){	NO?E/|h.g=H=9-&yH ol{|?h5cr]'sO#;y>'K,wO3e-G!_Kq~oK'	_&>:[}|}B?\XB/.'<g5~/uK|ibo!9k'ShQoaf6qc0;Z<"3.!1~^kJW%8s3
+{0,$w7sDs/j<$\2,_4WeKe? -K}?+f<_{|5J_#2{HaaX<l-m IfS~?!2X%|rwi?-"-S_ow ke!oiM{f{kvmc9M?q].O;mLx9J>|[F]Kc50uV6!#jY-8niy_g\?| 0OY	Y>N"<d&yd.~VB,$Ok&7:;`ahKkq-N><VkIZYE2FZgUSOZZ~FumEhiN|!\G'v|Cz*/mO&n=ww([B	W#zryh:&&i;-n:Q^M,'-XV gIkMx=~ppOr[,rp[C
+.|AO|8M?R.W<Fi3-nZ)qS9Ks	w[yWeK\-G1]F=^".=`#_uw7ipgpUn`i"]i<qK%+EKuT`Xl{O1byiI{35_}YV[S=Ig"jao}n9:|yp1Op_X@qwZzC|+XH_8[nAik&;(|2uDNG	/#Oi?#['>[;Pg9zK7-M=d#$ePwU2?j	H+2cmPXgeI?{rR/|{;pkkxu\b&yO;.g%;5N}aE
+2_oqG66aw[>Ql&#q}v<;6Ty_M+I]*	'?!#n#Cv>Vq~7O
+r'; KR,W]W2xW VCvpvIqonWf{-/RQf~%0{w+5Wp<M|mo=zInBzG2gTTwW(IGO-Z_];N	UI=;zxn~goi^wmW0|~+}mMql}J&
+#qmk~`mGwo59sci_^PnM7S_R8fZb^$o'2t\FYof!nE@+C\Wo7MRuOs!=k}IT_|TWUpOWP72W2OWSL`i_>?QY]%cT'~*~YFw^_-puqCpEq{qQf[*cEWwjp>mpZ:~[3O=Zxl-;[
+ewNzM\NR7O}otG>a
+>fq4?Hx8~~eajm&H.9p5'On8F8Z#niy/fG7|9/IeUr37nw]5gGMYVL]TQkmw]x=t~O++o=o~e!}w1?v"VvNo{Yeg_qq+<|l^FQ5~
+JsQ-wjN_C?3iaY]\w#=t'=n]2E|?|sI/p{p{*msH,!y-A({=#qq	w)l|hGrYJ#n~]vqEDj'EOZeEVD7J{?>ir%}:L=Yqv,s~@T2%s4K}ZjG7I;v^HlvBq<sv5Nn_w_ ?Uz/J^8'kQ,a{?K|L\kvx,fjMS-<G_'&nu8QmJ5\KH[mppq7A(+X'K3"o|GYObq&y[<36%\;_Y{{;u=L*i,sLpe
+RO.:qgn}Vgr&W?4x0`q-K]d^dmwFwl_O. /G] <:Z{QpNxcF7!/X{	m|D\5f?ig1.je/qkl93=u#j[9q?RI?#|nVQ0k,j(_fsB=DC-$r]&#nYsi}-hq)_" ~mMLQa5)\}<XNp;NkW??w:?w5kAwn=/u7\}w?{'n s+bf=#O-7mC7vb5Nt;9CgrnIay2y8)oigNHgHaX./yS'[9pQCI[|C,/N~a|m7r9e/{K;E+v?t&y';[80FOu.wr;_HH\u[o\+n|B{]E=;.2[ubi~wM}qmv'`tGZKpS)p8RW|g4yP4vhg	~5erZ$"SWUWPf&;RfK_@.,p,U#-h&kli,y7(~mqJ$<^v?s_?Y{k[y"|Wy+S"D_9g!:quNJYy} ,.l!y[d,xt:\#}=/E`7%FE|o][}[w|}-",/is<u5wM_vGet;>~-mr~qH|KioH'B}\i2kb_GA.K{X[M+ahc9[cem?QJ|}kq~!3Q_CZ#T\[[IkEu{Xjoe(W-G[MW/7	s>JOr%-m"cm.mlW^q	;yib|{%C!(nqM__>rK(|I\	gl^3ym9nILZ]5]+=1w2q/'|%oI~j%3]T|
+|['$}ep_-|r4Wi%]\i3nYkfmi#nI=Ho@W<W n>ae+>p.mt++Z3iim#.\BRGkKI.|DuYA
+yrq}&QcMX<YnYV#"m9>N|AS&-n"E2yvIweVfummw)!r	#+WvE|/#pyC'pAH;im(1q,%<>$/|G=U46v5wKR)w{?5-j^=merw{ic*qQ1Vsw}K1-2//s;RoCy+V&!$!~waW{	Xk[m6|O0N}<5/cm-|S &Y/?wH;n[dm-#yV';fp}=@=a|w9>2y` ~)r{{)M\6kI\e3,.P<N#Xgou0O=;_Z[v6xqu<<V/`n
+r]Mca}*_'E?@\wf&{>6,=||cmvm<[?<-q7la~W-H[un-L{<%_Ot*ec:vaq2.#__f />wpI{u$.~/qq&}!a"J=D+~}x{[g]XO\;fiS`abm+XsnjL+:R$m7^wbeBnYz<>e9Ot||e[oA6yD=S2{wVLuC}vK
+{"3'~5}Uvf$.Vw7.e=7i=v	?}ji1[_'Sg[{uDU+~[)K'^9{Qi|BQNZA8[Yypy!\M8iOSfMk6pvS`r;	V!q_v8om-mu\'{a<E".Z9ow"VV_5'#4}mi_"ow<8]g"-)pC+k2o}ne){4.N Xoa| m&]W+QjXful<A.{gp'#5OK[E1@}(;oQw+
+iY]#}yq!=?{(q)K-wLpE]2FZm0o83!\\['	q-F1|o<,uCzH!Gxw,MV 'z ys~<`]O+[GF9Wg q;?E>'z(ymENz/t+oouwiw2IF\Ib+sN3XeiOli+jdrKRx+S[Zc(7vbA^#Vf/i{twoL\z=KWNtnM+O:Pn6+"%Y8s-g1nv
+;l]'qG[4n=J!?w7{vq{Hb|gNK?P_{{GwgI(xr0mC]{w~kna<,;ut'nqc->L}l>I>[J!,dne_^.{{!+g6{ k~veF3)_pw&UzKS%p`;~sK\U5w5uo`}qrln^Av% xc0Xk0MfBCyy]c	ul.mx:Ds1@_1g?|NyVnq7f"pqsl.s<{^oT:q}
+u/9*3p;@57V PQ}nyU7-nz!;zL1xFg0|9*zMg!L;
+}'5z{xL0y\GiLsy,n~6+\DG	pf#9k-)U=s{sbG+O dww -oS7/n9 sj='{Tg:HzoY|qgq_~]r^c7kErn<EV^Yk&OsY\E
+T/Z
+)-oDa\7wpBwU=<=f"<&4qHuHd?P|~e;(q\*|/3w[;! A_N#CY9wl%E;B;lo;?=f	
+ov-1 c"8%/zjBOo1QJGPy-<0g^-zM!Nmneulwl}E_XA!]L(188qlRu5uk1k{fsI2E*[}siGDoo]%Y_[~s?Bypa?ey2_7>1.4+g0n? x/+^J8/)o^bo^$v}?B=9er!~_&W6<Eo=A;6}/xs_G|Cs4[JYkQN0IR'Arq1}c?ezs~z_;{7Oo#oxLruiLWgKR~/mA^o}xx.1?	YoznVz1nx5R!?+M5CB_ y;3:f	Uz^516l~/Bi[*>V2]>RBvG7CpyI_o^;;,yLDO JFAoHA+fgY.O><6HQ(AN-t{Ns;"Dw)_U|<:R|:|p/g3D-K{[h/C>/ }>?UyBr^l\:ub1X>7J^mW |z^|WfPT-]ob'P39uf~<Wx)n^zU8>.E[F4O_xEsn*G5?C_7.rC[6*d5?-f+}wJl]WcC_Xf#KLC	W<O9{Gv|Ks;J(5/0#~1SE?9~QWY\_N /_}+Od~#j	|2xos?BXUIPyhMwl]7Ek{2f2wyP[UK#>#_?KxzUcYS$cz'["UAB/ySe`M3A~*$kwKo	;<DR<nl>Kkw"URWt(+>xa1F6w} &+|O3[EWW$G?B~#+lp.5J,ai7 ?|oQZ (B;WGhF>@>,Tp}0VY7#KlW`}3^ A~|~FWT)~Kc|\%['AO~}q'oNk+WP)AQ<c1.E4"Z`}hO}0		P_T:Tfn,3%>j^9y/+X +x. T5OcwlN^Rj0tC	>|C]?Z\Ni$l"kUE[ =+5k@L, de"eKMBp^'<QyH@_WKW!C1s;|66c}x:1|- 1
+ QM{J?(_
+LO,%xY5>{'B>XnL}0?~]-+YNy7!G'1wwO |=;'&T\BG h&"<WOa?e-D?lj~{KL[=F# o
+~SX{{qA[6zXwsg9~ gf=Oz7zSCK
+u:'C#M=Bmx5y{SOX _~'6 TVs}gMeioW3?zy[WWv(zp}>pKA=>(f.9g3q~:C[i ?vF~BK4&yLB_/8~=ks[~^PyE3AYSC<0/v&yG}f36A.X
+9mxv|)$}gsDbL\>?e`As;lV[G~}D+Y3{|A/c>S };QW_?
+_.Gg?pJ>y&KE|?x<66t.57ja>s'Myz*|Kxk_1zg}W/3?yL!~~S;b+D{y7OkaXVw?%><CIB /	r-[~uA&}+4Kv~Y#mw4QW{J3 ]1[';U{m>/
+zM>3zb'6#A	J}]g9'&^F}3&Q^rO/ce~vUB-~)(\b /~/_:1Q|Me=_,5+Ivj'|`WN{ahm}=9D*;O%lsiY+4M x,wBdT69~<?_F	~U).M/zW- zxYG~}pTo1?9gmi-J~'xL 9k?#f>/<fNPwc_El'weSP`"gWl_KB%<%lp<j;Cg:{ury.3w?M
+(W3RPq /<[6O?;?c_G~~wX#i}GWq9oy5>X})-_~vN=ScVx)wy/_.&;Z]yxXOa=+x#/<3ErSv5M~}*W+,W-f=o937q/(Rer~|.&G{B+6)Ysd A~}"E"mo}4/a?oY~"T^`0-=ViEl"	<SxM+1KK:j?ge_>c</|"n$}v81^vsfs;00uui_QkY>v},<LE9/{}|
+9?2J7o/\7yla_[Oyg+)f?9>G9wbOvUR8&sGm<R3mgo
+kB8PhI~u<1}s?*|ac(B{uu5q~YB0c.YQ>]up=UEzOE^K's"Hf2=y>}j?I byx	cd>N{B{EoowW3EZ RI'{[O{z9:<c&V5G}k>f*(7o_;r})OTo{H'w#?FHu"A|D
+?Vw|?Gd?-i *"7Z03O	}1
+>K?_/G+g
+>	3#|~|<S7Ee=^Vi'	zO+>!9)_bq+WU3g{L""t	M|dXNX+o/:? ^P1"bSODA *!9/515f	j oE9d<*H/J]6AbxT@=smm O<m"y3/R:[=@Z?ku-\nI&Zq[} K: 1 'G!_/K<lrzi!3w{L_c9}U^b{Yj?41RTDx_o=_^?8YsWi^/AW[%{d?ap@z%	>U B/l_It_D{x>x?	=IEj3NcN<%?8oV9Lqc3.w4-Po g9BIVq^}oy`={t)54yK:_~?W#Jz8V>zv&(IP_sX"{;'~?1};!;fdscb}8V__?c":~a8"zQBg	=oT1gQe?B?q*{iRvUcr#cMk\}yLk3|Iiw^	=$lasb\'gf7Mzy!}:5o)3XYun1yV}do]D
+O%E"m?"n.-+DSy{RL^rfz!"_=6e{GVyrZ-#A>YCJ}~q1zzPAIdQ<QwE6J_~G{Ge>3K%YC	KiL}|A&~5>j}_.|ExDSXZSXheaYGW-<O7`?A}nz\ |r'bgj.S\S[G<]Q]stvo^*'?|JuuSWyo-ickzL~b)03x^3E>Oo$r~Zy}J>;'>%Oj|{>>NV@l`Sj}b*"By|~?SWxr,eul9g77??}Bk}j?2_{=&9Ocr/wD~k~?r~O{Keh7w}_~g?)C=RWWgu~O_+f/G> |>39Tyq3<d"Opk~B+/|Cm>T]5M_o}|DLNs_V|-=oGpz(*q>~}
+3^,YAz?)eJ\XW6RW)OC{U^pj% }'_TzOU5_7c^E>Y/h>)xOE?yj^~Vu/ek.~ Jw7C=iy+]k(HZ|/*"YG=[`^/_E{1bbxy,WKurT ~T|z`q!~$-h{ F	|CVVUSMy5i;>=>DaPx)fS}FNTp3~f,fuO+5WJ-]	4j(A>NPlCQU/{Lrb ~7UZ<0QQ$jq%:a!OC6xoKo!o13C7Mm+|"sDDmgU^S!<WlLo0mDWSK/[~=,#5=Pd>Hr0=lp#BF{L_rE&LRW>G?Iy7lKRw<Wo+/g?rlW]9JoW>g=+o}"UzB^9G_!=B}-Ek*AtjixEB?-pxE*]^3ze+c'h_??z~Mu|UioO?bO%#o,y9wt`4q[gGT[#_F[kTjr@O'J_8ds&"y!~^m=]`u SU}
+a*B?kP]l;22=zeJ[c
+~REAU7Wo:XG\hwl;"*TkukY4e]R?KSK(5P$>"vI$Q}#:2fC~Kq{q{+c9	qS{n<f]O3S[Ksc:x7epI~tTB>Vk{M[SQBB?^=wt?>SF"M#OAZhyZ<~X |W#e{B#l%WW9_0w}os| l4cX+beE'A]&m+
+/YQBr+_V)_oi_IzLv~FS$_/?<d@U J%o|hg| l9Ae[pU}DC;LYwH}_!_Wj*{YoEE!3k6-0_=,oL#IQ1UK=fY{ioo;Tz\
+ ON~M	U{=xt{l|NVI\)5}>s~D\Qz*=~g eo%7_
+e0
+z_k5+<f:/=Q@R'U :6`]}7N}bq^8sbm~YwoLc}}gG}~{UE'
+^!{od}~{k5}~{83rr(qY8|~	*Y7dC y<Eb~3T7~
+|\'zUEloOD?eWsG-|v0}{)pBp$/+J~[rswv'_|!v a}*/@G<fLg?APAoMLb*
+>Vv^F8lxf!
+(s1/\ac'H~~x`b{Tk75/'v;
+F1&?-C,O}<:u)"z'j y#_xwGTd|]}$LgW@gxTQJE}6~o  YG> zA"r_ls	5~9f5  hi~z`yo.~Re /AFBDVkf+D~W1S=>)-y_	=6|RC*a/M*XI#7j>yJ>{f3WB}Oo LxQ.@VA)j~_zP
+Y_/E'~gO>zpx*5Ao~r7<RSgU u3c'G^Y}b/1-y7iW	{O{"Sc
+#JBNx@;R("3Un)<~9~Sox}R{/|cf J><&'T8{VZ't+yMxz@/UBS"]IG~}#	
+!.
+}y}'+D<7\"_|E^[&}juSkO!Kv[	{GV*,677){eo)M\1cD|{xj5Nc>WW/|*S^ ]TSaq"_`*yYM`Oj|PT?jIT1M/}:&u: ?j@
+'B"^ &}<Jtv~@}@u=G ?zvX/q,LCkW5N^{9_zkwGSn)YG3uK_6o*{w
+BPq]A_(o^kF{{L/}!!]s.^Q?Rkx)S~k=fbuE|5=	s=n!0K{Reua2fz=2U+xO!o'-f[YmO#5AA(z|}c)2E`?VVxz	k}H?XGk'H8`=\e=}9=~CnQ~dLRC%f"ND*zZO1 ./Ly+y/yLZ9??}!!\y6}/?U=1=d9=3>60\733H>81f9~oy=q!Tz16\osW}>}6k.I-G~&T}>_zuSWO5_otdK~#?=%^*b	|>?=cVN4*&.C>Om[%S^5AQ}Ww&B%}	`=`~#TM2%vO`zvUstp/HwZGz_z~{}6 o!)1GG'gK{oPiA~{G2?m<zb*{y;>JoFlz+iokS:|hc:"(Do1:ASz^|/SO?~0.S7o,CKl$7';g0<f5BoxsG%D>}X?U~$gJ5/Rv5uj9=L{BKyMI5},@>2}7oO@Y_|8}w_#=NgT}OY1uS,rz1Oe~{Y?eOf}geM\yoI)|Tw/o.AA*m-Z{d~;yo+}<yO#D%?|D}+T]EO/kv9z]s~XI5WJ}7<-pO.%$1k'?'Tu>oC.ee?bGU_G?SJj[u}I'{S?#|0~:A<fOVcDeY5aCU_y{%Gu~1z]q<(p ?>L\Y7jJaW	TyTj^VD)XZk9Yk{CKO~Xa8?0G*=?Mj}R|e~{{,wte713u${1J_AshL:c9awzOyb8|jb?pV/w]{}x~~'fz/iMvzkg68|"_WwJP7&kx_Ay~!h 
+#!w ;
+)d}|CYBW^uCUUAC<JW^_[)~7I>/iyMb/xN9OKOt/_-?PS~wCo`har"iF~Qe~({wEJ:c|}/u/jrs?_lLbkxR!d!)z[&[~? <!uPN]k~+"ba'1E}E?1g(?=g"N' f>^2@s>2ZUC7fD9b}cEA/:|-R9jJ>|B+~+Q@_(DD_4f7~F!YE"&t>W0&iG;~H}>US~Z>AO)L<fW WWd~KbZ+I&eO_?*{H9,(z!;u4a1M&n{xHzNy$>''yYA |"oLeLA+ikg|6gGF$^["=G!3_{JyrQ	1K_@uQY~c_eC*l$uqmj4tK9k;^i!*^ ( '+LU1q\%~|){OC-Td"'"(7JxMBR{~\Ey-c}z=dYM}1V']w!.l(MqgWw=d*>]gU
+~E<'P6>70uKj{2eQo Z~<}mW}#Yaz;#=2eORz6}}$6s<|Tm8|*M!OY!p1|__/9?	~|Q~PW[o{ ~Rd"^+isQ5CW~E/;5OUz)~c~RWSn~x@\E13V~HlVVb<3A>#>_s
+gWy=l}|_rh:~4W	"6_L/<J>=$~yJ+zc
+>(Yv+U
++>|dL%% 5>rp{	!Y'#=F;Q}@7^,_;wpwVf~ypOCjLB3d2^@{/H}&~^qLk-+R~//gB6%=N|L1M>U7"_E{ET6Xyn9?smo0__^3^pIk/'}/Hx
+|OLq{e!wSiI}9-z:_M{
+ he?hO~.5?_zW?Q
+`f0)X3 -~x"OUgLIU~j4+{N?=z*\<9ngrc:
+%~)oCc)~}oBSx5/A{'WGE_ngJyUgl*A!ud?5_
+O|'{ir]M\Ca|C)WBseE9}T-Y
+n'[y?@_{W-_#EW[?S%u|-xIi?peod1}Qb9	}Dm+@E@gy,{f!~K?-_It}nm.ij3uA% /Yz8E(y*}Eeo1kR3Sg3bO@wz~-?NzSP	t?_G~(F)RYMy7)v%_&_%|U3/mD5>@Y_{O	T}dQivyLXpCsT_>#w"'}xFLxef=e>~~ @?|[KzT1q*UGOc9|}TUXfxLRrr~1)kyYM=7&}&N#|}SzL}g"='w^V	ZS;\LI/_yp41/<oxD/-<^(
+m1mFoN&?- 7i3e/m/f1f_W<O\{U"&~n=f:2)"){W{\#}{R~kV0J\5}	Syf_Z~/'x5Jkj;F<z~@,*>6~ehcNj{N^g7!/&3~^d!{{+*{'*d!ugS	>~yzuP[}/&
+.@f>"zX"(&W}x[Wrm^v$mLH=~3Q@.WL&^}i_A${M?CLbkl(n|t7+#|XW3^<,gA@B?Ez9J3D-z~XTA}b/T	=y$"$?<eEZ)x ch{)]/
+Sy>G/>1.(y
+z!Ys|[)k3&~STO_1-ox\:`|K\%6/nl=42?&FD]1_r^?x-(Og;W/b	< \Cw	{\YIVaEOxX = o#eo[c4PV{ye<?_#?xWyRy6"QsO9(JySS} *9HY^~oy7A{car_ru?I~{!1+7>)~oA~FYCc}Wxy*<!s#:N}TbP_|=QqK_D2c;zRMd/m7~xeoD;xVcJW|HJx~f9?r~|PS|5V/!^yc7^G 0faO($4I>+Q"hX'yqe}{\aj!x!^?Ob7zH{<\wVwT'W ^[Y^j}?Tq{k{ZcTrKSTz`= ^?I{T91%mc<D3 U_/gTs=?&<\SiW_AJ?/B}Wo9bLE/66WH_JGP#]'K-*wrTR$!f\F~ zVH0?Jp/ro1S'EO>+sz?*^SgOq%%:OPwen%pYV{LP/Gd:~6>gg3a=`=i_>/}G}wi%~6&b3KJ}x>1]g{uH?V?134];=SGd9YWWx+W?~>C?%+}zh"|?%
+},'GoO;)?}4y]wgE~Q0gE>?Z
+CV.mz-[}A	|a ^M3xD!Jg~I^~2zSS2op2JAo~7xQk#w:<Y}5Rj!OB%w{cN(\oLKMQ1T=D1o+|*e
+73utY{_	C =cg_	h-=PW'39	zpBUA/Lkd~W?+zaB~SE?|?%4*F'B?v0
+[p|xLC@?;yR:^1^*\+hz3UzsGPh@{<z7^^~\}?9qx~W<~c<"O?eG?' S[q'T{mCN#GT&{
+^"/_Vmo=4_pz?.hy^rOL,@?r\Ll_o:Zw^62wyeOkY_d>^Kge?<?'c6+=|aN?=*]}
+B#8N/SO}7~/W ^@=/|yE<mY2r9J=?XdnNm[{Tgx:$/UwwE.Ts{liO|z'eujc([x9y|sub}KkT* vE"MA^YF:\y7"Ei>xYadcpv}k$7,+]d{T_wgU9Gq* }d/@/>DlRf~o/~Mk>]sSo6
+<E*KJho~R,I"^)wUBZfo@[C=o~pV]xLw^A~})CCjK2fsA~f'pz/$?
+?z8P/(}pCX=z#ym=!Te'~VdL)%?Cy_)bO/ W+|sPG(x}qi|+<|S\Denq?cSF::~pGU>V2(yz3=4	1'c>zG~{A|EHG*xS?%U;vF>e~oGIc^TE~7zL/[1}K~c'q(;N,YG{5ALqJ?Doo%!W,Wr==X_!jaWSEO/(y7#b_|rCRAQ+J_;gk>^@~f+z1m+@ei~G4?|}#]}	h{MRgvyn?X!=3cJ+sEx3}?<~S]Nii:i?U^=&jyoZ?~ZiSHCeg==M^[Z"k(^2J<:ABD1?Q3<
++| ?zxe[N/	|Rdq=/}r3,mod5_~S+XmF}5#o(x?}lFu2_%cE~Qw>v]jnM"xv9B7=?uM~.g?WFHzrd{T'f=^?{gsu|F$9Iu~R,X{/""|\g/t#>}KOu9xq3 #dOA{{y5 1o?!HP^4r>Ou??iO8*<Vo}6SW~@*Hmn_Q>{~y>Aj6qZWKzMG|C=b#5eB	Y~ruez_klW{o~7T%-oP?NQXy{nYC/?!{?>vPR ][K32<=j<2<3zWCoA_yPT}Tf}){sP^3;U1wd78.E/Ac~WSI_B{[}zbA_4p1yes{E}62~7
+XB.Ay-5y?4M`/i -/9
+{_1:_Y4,c/
+9}xW|'jvly{~yi/!BI_.y~oG
+.1m`?+}{~30ZuS)5~F==mos|D?KWgU|oj~D{S/'QG7UiJw+^~DwzM<fn4E%(=AxT~:9O)'Y!WO6`=ZAI yDPYw&Po{'{ggm~-@z?/jF8"gA>}~X\{}ao1x+U13eC}}M<_m[Xztw{UXdy{L* dA-%Ntc..E*R!k/|eoVC?{'zM%?m}~U?=G/o,yH|W7\ukLg=~AQ5` ko~2O$?Oa*>?\>~,Go1ZiS^@;%go1+|hT YLm7W+r{L"1{
+yUw}}pB7 ZyO/~1gZ[>G_#>m
+"&RlVNk&95?u#h99YM6D+TLO+z;e7{<fE^k[+U;0r?|	]E_3E?4/P.zD!cvOkI(Jj=r;9"MB~ uFk9E1}SKS?axwQkm/@%H5q_~nEX[b|1p/Yy~_S+>?}>`iy^zVWa~
+3^#<Y>
+	I wB {o!F_rUa}^W5lz22
+>E^/>)f1R'ihW
+>~ z. ?e.kSEH1Ku?/_a(z11ku3 ^r^Wo0R@Zsd{$?1}Y_LcOT?~(~O`%Qp6.Xye/TS0*BnM*(4dw?V
+r:*
+GQ3r#@}%Q=_\}wr^v|#{I 1Y|^~*+Cx{s5Us!|)Fn\^Ftk{RW~wh'ed?' Ggu9xOgS?4lo%Y)w@|Ko>}xBh)zRD.kQ/M\1+>VLj9uelkz~f=@{&e?4P7|GK{
+WSu~tQ}WitM\:Lzt28st_B~aMD)xh<Go#mj~k>@^ssrC#\8Xb;O`DgP_~]9",IGnaA<iOfsXrOs/y5Eea5sb?'c>/_y@Icmr1SayXO!9^TP!/(co R9/V[?x-Ev	WLQ	p{~}Nm^pynAP|%r[RY}(Q~g|47k}[_2:u?"]cCwq*wS@gU*[`2Q[Z1ABWum(a#U}nD.j7\q\SY<&>[!f/Bmz^~c?1$IoL =zg?H}=8a~?zv?SOnI=g61o"Q^|WS|C%@S7>KytNHy}SJq~S&BoTy9w3ggRS1=v<Y,c62#_P5c."of LV-E~^Ahn(?<LOo_Y5?_7K xtc^Xgc=G<?l!K}?S_GrjVY_>JgLi\B_~?6[XgWW_?|~w
+Q?xL[>[nY*Nd:P4KZ"{1cfi@7AG\~\ow/qmU}WW."19/@QwFQc{Tf3gTy$}b6}k~3T[blW%)'^iJ;kJ5knS7eTd1{~j+[oyER_2gio~R[-ja)96l:Oz|.iXL.y}h9zDG38at<	i)SbG'$O">V;M3&>_B	q)&Gx#?26>9-!)MH4uIRG&;`$;Qms:Wzpa1)q1C%O;l=*MFzS3m8ULK~)0 >-2cD;P.=SZ:C>;-?F<Z`$]^:	tN6%er<>?2,-~d4U?5,etII;CGS
+Uw9M'%](^)-OXIKPBjMHg)La~vQTZddjOMKIN"M!_(KdLHLHKp15>ex;A7w2;'6{I?@S$	bq|HshFNiubcV-:zH4K"k%E'K)<:ulqQjQ;W	:b;d,Y	vQ<>+0c8iU'cK5(6$fdF?JaPSixF?&6>ZN~1*!R7k@;D
+m%pi<L
+m,<ppMEF%lp3Y;WW]ctwYM>*{P=__TCC_,V;4['X<s
+:_
+Q2e_,-#e
+3GjHD#g|~%Zh
+'oB#
+1jBSCuRX(n-$ew':vfrIfER+$CIUE+-Zt%RJl|q2kV*$?:P(SY;EbiCL
+q>:>%%)zaFB'Hx#6yV3	(I)_e2["U&C#;B;SjL'%1Ai|KUl$Z>6RKH4,16-e+p14M
+O^;2&.<7raREG+j?*K.?"cevbb_A&{z)G>,-	d`T/e&#;.5&%m#s1?=,P'%~x|JjZ1&OqzNiS[g6eeZt%!GI~$;q: l_iy(vQ\m4v9<)i-#ys':vDTYW6qj~_CL*g	bAmqc+E?B?[w8)~/5	y[NE< DcPAaibb"Jf;=''o?!NX"FB#Z%EHCL[c1h#"c]VsIoi'6vRwOtEQ@Zd%Ccp)iy5(G#-Cz[G<B2vECO%K^;}cx[Tsmok[o#0}`IQCuIEPv7C  S @TkHN;q1Qk3pbo[b,Z=m5&dP]% JKvfdj'Y-=xXsw366jU'TwL=%$#e28tIB:g38y`Lf	q	2m<=;8lHf	RbTpFFCw/)BV+FCBPDt<2$&1&V=St[L1VVXQnfdl6>rU  "r@'Wiy2mC!yo {~:,>16Dw(q-6Kqi1AdL.St}L=En^JbRvL[@#=SnH|jjH;Mm!]uhWW`U5rHw8g?q
+SRxb1B`[o5K
+t^BC^_V=_i\|jlJcS[tN-)@HpD8+I5l5*SNKse0mq%t*zKF"jZccR2^?jYl[LJc~ioHH[EWz8e[N-$$"%?Kj1~9}C<5]l&$$eOkaPr>Z)>R[3Y	,%0-c"S%%wA
+ZIw( UUKI{=:>@U=c~omB7mYagn#TP[@52R"edoI1'KNwi[t3$d~p(V,^][U%!RIDDG6$>1MWt[^%IHW:!wZ tE'Xf6T
+tt`?1B{+h[]?(**&,;{gw-1I()/DBB%T|QQQQQQ_K<s|&=s<suc]7ruD"jyCwd%<u[;	D<s=S ue=j,Rm|%ZaanhBmtAx
+TL'SNZ	
+B2>>W`VR:vUUrA.*GU,+_o>N	nXFv6_.9Fx^nQ}bm-6kcNrsiWkf,Pa,tMnIWZ_fo5I6*teHCC%yX,5\|-uINoIt`!7oL7(g\I+Dj-qZb/.M+WFt2N+j1|G$9o(uOJn`wo~jc./7nL'-Y]V%K]y{Zwrwkqxa<%^``h[dTy~_60xFF|s;wo?<?BlT^$|9n,6XJ]aU[|,JlM9X5Fw5VQ5kmas4/fy^Oqs~i}OVe!%LmFAi&,;@W,Ft6_Ht`
+kZ8<.Tl9]3&3f]'gJ >2} @9lm9ks6"1Nb@a-./6fb/r|I{)slj$hLK+u9rk.m84QNU@}n<mi5N'mpiNC<a^. vf\Q:QmkS&H216e)MCmkSP216ehSH216e)MsmiSXA6)M mJjSX66M)FF66)mM mJkSL&i"H&i@&i"X&iP&iP&iP&Li"6Mi6Mh6MhD6Mk6UM`mhSHT6UjMUcmjSTajMUsmhSHT6UlM m*kS@FTr6lMeCm*kSPTMe#m*kS@FT6r6lMcmiS%X*T1J6UbMcmjSX*T1JmiS\*T16UbM3mkS>H76)MyCmkSP76hSH76)Mysmi6Mid6Mh6Mkd6Mj6Mj6Mj6MI#m4Im4ImIsm46Mm*iS!X
+T06`MCm*jS!6`Mm*iS@
+T06MkT6Mk6MiT6Mh6Mk6Mk6MjTm2)sm2)#m2 m2)3mkS-HjT36M5CmkSPjT36hSHjT36M5smi6i|6h6k|6j6j6j6y#m7ym7ymysm7qcm`m7q#m m7qcm7qcm7qSmMF4nM4nM4M4nMYcmiS6X5l6e)kMYcmjSX5lmiS\56e)kMY3mkS.Hr36)M9CmkSPr36hSHr36)M9sm#'BeJ=(|[KrS6vN*4{z$o\?3*w`	vhm.W]@:q%SNJg+LT`FPB	7)($=rr=P^:o ==kx# ['m\aXT
+Dqy&VTnTGy(0Jg&Zwpg:TgI;6)
+(Q#RiOVfq^ :}.D3UVg3Oz?j.f.Dz{6i^hr%X%T%44ym-ZzG5P^5PgTj]Uk:8mnM4+1H>|`-n?K&l=l:BUvp[-sCqVO]hrdN:zZTUfK~YQvzlJUjS=f;nhj{\	6%4cBq,]hu`duRuO/8@p>kHl|jm o5ZB/t~6.O*uFRS(lMM4t/Z"y,yL0nx{=0]BcG-+UV3[l;Gzb)_u^8M.tx7UgC/	|#E9~Npf}.K6K:.~\M^w';x8\{(aG*;C:Hn<u:s]Ib#r*8qu*3\)SGLn.N^tiyh
+}<=Xe7s'k#G'	IG*1TE&7b=qVY	l<csT??f}*-MYzkkgKDi)cBGF%>b?6{Ga;#5ow~!~!&>!= Dtc9%}.fs<1=}ui;<F[=Kz.ov=UWRltGImz_M<|U<=&w@XdMCANSud1"Jw&klt$>o4=F2Y<n$f]C#:~DxPtos$+r1B;s$m<mY$9oDw;6v/]CN0^EXOCX+UmjeVYnTi2]&qvweD.J)Aig1ffrU6 o]fp	4H4u
+zHB.m	eld&7.31||Wz)ugxV'^S?V5IB:!5CVqVqV[Y&L;0W*aX|Sgkzo`u(8>A(Hijbl9BWp\!s-aah]*]K6qBm<oi3inZEh70-ToYcv\*g-;'PA&V9R")Hy	+6<RgY,"rc=~qxS.E`'T\M*&jML*$#o.Z<]sF%T_PtE&cI"SS|9U,])0&W y3w>];};f>sM&#bbB#tR0e|po}<61o!(m[M/?[R	6ZD|tVKlotEx,ImFb\	]oL+-1/f&zxmH j
+/Kt!L~*IoD2G7)D&SFAK6G\GQ>|26YU_M&owK[`"_oSO}Hq*5e4?dTilhI8	AgWI_v< !^!?yv!ZT6lGD\;Til{nK!nx5t>YW+obZo(U&8|655[\}|,xu+;kSXqv}=baea-+mzz3Js20fQ}0=q6GBMFUAEo[|wM~-+4aaf>J7`>ibKu"paZ7K*l)h8v<E6Q"lg4]Ldlnb^]	dIzj#!c$D{~sI+l`Ch&u\g=prs*52mS{;GF&[xiyr%/@Q5NJ~R~\c2ss?KnZ_LYSq\H&rLTW0V?	eWnk&\'^Mjrm^MuAM_:B^XqKJmHD@x
+Sf'?$m c|gz.dfoNXdDIF3< i41hLo6$g FF}M^;q <4Qe)QKTC[mxxZt`njw#Axo={s[=k	h>ploY5b+75_uK_SHSf5o|~H~DrR!#[4Nauk$(rn23F*3hjKB@yLR4^f#L./~DO\jA0dC;4`ch;tY\;]x<l\]l]|}1>SbjaOP
+mJ&	|PBz?|BfF~l1mUf}o+/|aK ~#.=Q~a[8]D~:k5U<RC1'l!Jav@!fCH\GWt1GL	f9LC=r^zZDo3"C{HV!ek<\B;BQ.W-\B;55\!z
+Wrv
+R<ir6km2\B;Uy+WqyDcef5YgFG{P6WmYmp',V26e!pyeflq:e`kk%`hMhNv0;QpZy,%k$$]Vx3qMS?ofg^CN&;c9;ci33&;B3;??LN>LN63N!gi73WaMYO
+
+tfmuNx
+[\Q-Q{3^<Rm$9$aT=ui0_B-Q|fcA!FRruO}nb]92FAUcuTMo1	{:$k=m.[*Dn!mTHYliP~G}&'i<w>&gs<
+,O:DqS\Ot~o|L<?5V,'\*\.U"ND<\	N^n3M6f)Zq'Y\Yh5(]C%;TC%M;TC%;TC%;TC%Cud*Fp;H)[WO($4)ib"cNRPm6pUn8bfrNKdw9/{q2zXln:=><.P.1MF6Zi;)qC\6o7g=qY,9,Y{>q8w5%eNY	7MCXSu[v.&+nTzll&7g@1mb-fm1Y14vLzyLj)zk"c[<%yjbfchmQ$gkalX]0HH%H&j,Xi[zbCOQ1vlK
+9<S`ag\sZ|>o_yM bQCP=cumSX(p/A2Rz&g7R5?]!nty)A#UlWrY cW=qKimz ^.X-=-	;'y,xMf(PNp"D^nsMw<?~jc\*?soyfeKv8\j.]e}@}$>_Ay 8|2M$]+m+
+MSoYhq6rcX*s~"cp*|kK1K)WS3OU-%F6@8snkHmGEk.SG1#d:X}=KQbjXl/N,F~.4l+wWuEk6WsQjQ_.?yGe-kP,_v9N[G-^PI632vsk"k[]D\^ZeVYZ;G]rmG#{Yx<is^r~j{m[;:iu15p?wKu=fh_)M~VQ@:Jnu.{Lg+lW9wXsb]"sygw_MsmZV6m\C'`7f<CCJGJ~p/t~zJe>N?0(-	P`r	&%9?bXt_BF$wsQ|?OKk Bdlb	70Tz.{Sumjj%h[)ZeqW4J/:`,igva<<akO=|upel>C i>]x[|jEwf+,YAx^4G'^Osvpi>]?k>1Ue=z$d`w|eKO[ww"xEhm|f~[|[3?P3O/Mikj,rwWm77*eZk?-[;&3NwcPj!">9Y&tlu\4g|qC3Z/wy"w}_!1/D)P!0KXd)kK\R.0iM-qN~M5Y5YKjlVIujCsN+_NC9a[&	aSr%5]vmZqB3r`.mj-%m?mg2QyyL+iu96*d4k8P+g	2&7x`CLG_$F.#&DIJ'>D!B#xk\mmv!0_O\:;DS@P]eOwEIY~-6,kI'Z8a	N	Np"-kA'Z8/xrcDqaKoEP\j.?SM$_ o&UErb~nE747~X(lO}si@U0	ZCvOruG#ck#l-c56I~EloZF[ aT4X/.lD [z+Omww{co2[iB3tD](*Wb
+W!/cq=/ lV:j#]KWYEv.^xb8;v	Rnwy6tmmA7l?+jt~8[$jjjl#buqnx1%qq+Xh~k;\h3>^-OPq.7cUdSE^6\PghfgRvUYUyL)DfYK{;y_VTKyeZ/b7+hF<?7
+7n.OS`fUkpH/u|qD{E45@:D:>6?{lDwm|{o+&eFsm|[5-_/>uR#{u
+(mZe^._xt1_w5#E5"[_?j1ZYat>A0{Vl^Blo%]?pVnC:tU!,#:tg~U73|fo):^FE{H2LdCJ*WJ<fMyx\*k]{UO*g%E.T\{ P9!mkgC?-g1P!mP!mP%]	%"')<uS|(r(BqfPf\Fn4d5\`n:>g*m-w3sGfx>ivsD0u6]W3_YW.ZH%2*2jlUi5
+VhoUn*~3is<.fD+D<O'l|EbHXxhwi,qO(z{*604	:iY+rJjc@?kM;[/Uya&<L`]}.}Uo%(%\	DJE;x_muJ`8?mq,Xt=4>	;l7by6-[C3\X\o4Dj$*US3G[Iyv,&k{Zj<:vDpX
+[7mC{8]}$"(pt.3H'9j;p>6`}6P5d1\zrgmRl)eP==H7}{bWOI={6=BtPA== .wO7-ypSOXYxLKbh*JGVq7Ddbf`maCFL9c9i?y(,6-m0a=-r`YfYF.5\^;zjPgv5q_X,?wn-w!VkiTy
+QTBE42"lrxnyR_$*$W!6_3EC7c).])Jhj#ek@C3le_z_)g-P!ik7H;;V#aH<jO}*m.9?2!7>B$/WTIcF+ W:W1\K,[v.JEIE`b6i_	\)pyL4y^="h7[2`D'?"h#6A^#smEIE`K0"xF#VF	AA	*Hb1(*vl*G-zO^}_	^mKMWn(T3R}.[?_/q/Q?k/HC_%78#_oxu0|C>Phfj*]K9$2R:7pkc
+m&4p87RlJm '\s-Xweu o*+oj"c4csd<M]gzeF\V}~WA!\z~_iQnx`]zqkJg=yV97v)\VJjI^`]4]c5WQ8"xW;bv??q^kgM)x044z"df?%u{ZY7~44S>>Wq'UV	
+VLb>YYYLe{(_?IA5
+9R)i^zd/152
+?0Ui w` raJq>yRH7-\s,'/M4zF=U
+Zf]lS9=n/IsN8yhCthCzCY]
+^1=Yq7k9j]Sl7tgzt$jD5jX
+er2hvRn)tfs?[{4v|K.v\<;F64g><iTV[xb7S}p*?.nK33mk]c\'RZy'k_>l<P.3lfn<t^uO2y4J4_D+rz:C':t`8[O/I/+9~0ND3*E+SMpyCM*KwyJtiJwyJvaJvd!:TC%=:jjC>B ILlWXg%L(Kc}+BRVemQlWX6psGc9J^=;fo{_R2q.yO+39}y<]({?\bn6[kdUv#p`1yAOUaFf^1	[$1OsP]/Bc?"J_ Rq2_dCLuR#77ojCLFO,t1
+(O;;Ck"4857s>!uG"=!L"*VIkX8aCKOl*;m}W>X,;LLFUpCOyMT9bQGU9z,3)O}D:?yNtE'	!@{6S0wvulNiNZ+&	/AGx\<h]	\+w/t6oy>Gu>\c\*?soy)$A)KfY:$sf 8|{
+M$3rWk-by;1T.{	>RiYZ/mZ/m\~L<ifFb:|4r8CQb15~=KEklk^D%`kb1_lY*\e7/&}~~Mtv{5\`_\V-xG\#q3W(+u}my	fkSj3.\=\V[UZ;uT\yki*4^i+-&OuC*l9!M9J;"F!Brjt!t6Nu[s]Epy6TkzKmeKemLjuo}14}&}m&`~Fe\{;gtu]EBI&%LK4s~#jwDs[xYl#>E]#>'uJH{>`nSd+1GLQ'0l.3\g?o|eMtp|lwb}[>VkM=|pUC{ i>O]k	|fP<_U{Sh}r/uQ'k|*|C>Dh{+H@cCT7v\{6f~f~{ERxRxvh^UKrMhv0Yl76l?^ 4~9=Y]*LWbu=1c}.l)Mn}],dq(|bX{RS_^N0iM-qN~M5Y5YKjlVI.eO;0vmY#^[CFlYqZ?=Y^q} l4Ot8_>wOwC>#oW:e]/K_b=b~K&z6[?yg)6zb`Q]d=O([_c%F>LM=l,p/o`_'LZ8	NpNxp"A-l_'Z8av'5vj;{&b eK]sc\eEif1*|L3k2Cg`*k~wI`FH~#ydQlmXT7imo/H4z9Ru4CWmcVZ'?zZ
+ydj^	[6-'HWcm9G}}@'gg$2
+r>g<aZm!.w|q_o"c;
+g0w3MhW
+5yi8+Bi.c0!0PW;s_`vQEmrDpmn\9ST<2`&K)l*k"Xz0D.31&5L2pYaWm4mFu
+4{D	:P(h#~ Nl+PL!o	|qUR0zWoIEo8}9yI!/T"	Ph 7`&Wx[Lx]jcR@-57i5~S/QQI%Y@\>+@<X10~a.oh/V
+^ rLcak(6ac1[o"EZj-&>iF^O%P`{[5`2NAL@n01~>R#uvHkjK=hQa$YC(MX-wa3TcpiVkBk_a/@3
+Ri\656S)Vy_dET1f6>3q[nf*1gC
+jnzjFuNMvvsu*]~b{TF|aXrZyir=Jx>rq=m
+SGGcs@!UJWIg2T8 ~TJ=/PLY,rTCv<?mLS|q#=BY5/f**| v**sc(EX*
+(XR9?/G_EU*fT(H&
+
+j%|_/s/eeNR&_JsNo/9LL\joghOm'K6o7I@:wX}QU>>.YWfRl",ql tqH#IT-een[v:CO.8X`uyX%;b	x |}8FZkp$6P-dK.X3]sV4Kmd`[~ye[-T-$l<!a{$XqV|cZ:-nC} PV1Ounrx-4ENUk]S> +8P(<">6]Eu	^plIPu!{/o-V\t*WJeF+9g8M&fye*;wqK9RL#r\%Hq'b}l5%\R54OyjJF]aB+|"\Kj= xx,NT<3GvF}b'e2*2r .
+mRU+Dz:[^PRlHh<~:5/9.!O]4U~|04!7m4qK[g{{wGRA`ct,,#JM5yHj;2zK,{K{XWJrNz[7[MwsSAveERM aT]"iqwX<oHZOUI; ~DNx*HZO5)jEOI; ~*"iqwX<oWY$-TI; ~"iqwX<OfDS;,
+gaT]c"iqwX<oH
+4k
+?Plz&JyZ/yaMYk]eOS0MMy>YfqroMLd#1m}Xpzi8.s}BN4wA-1xLnA52Uu9sMU]?:E=f&@) ,D?WUJ+pjx3nqmS
+VPx395YBq^+$^+zKBz0h}7xOG-Lp!a0k$=f!\S[R1lS\]|iXpc8#iqp:`naGBO?X*QxuD/SOIdsSf+|F4Ol^Z]!?6r	iu Wr%yHouZA,hw8\.g#Wnr~vZOz_/ LN_|~_.DBFJt):I0&$gyK5b27v*f2eRm/MjfCcy~e(gjqG=5_kkfu_cjJmo;QE[rH+Y{w:dFLF2rvGX]2qNb6w_98>ZXCWM;5pYC>/f9{5ZeQ#WO?]^e%b\VkqZ$F--iSk_Yvj.eb-&|MKn55SKBXuAfLqW<M/4}Ez14^'N+54/
+s9{D|W=_0:[c^`VkbUZm	e{;5w8Sl?49p}*^umP59yo>jqh!9u$Z1]"~G$m^okaGfxgnZ7FV]9$&om~_v}bioZGxz|t}ajn1oDMEkj&\=t1jU1I/S%%i9_O-k{u&6IKvY#w[2LS+fq7#F"&#DQ>1tQ_wLmG#m^C-4[mckkoM,7Tc]*/{	;_f[;To2?`&sFd>d|Rdd\Od`iM"s&9=6["MK"s&C6P2_@C9"2>Dwoxv|QYI7y6^77{r/=~x^f$k!Q1q	I)iY9yE%e5Mm=a|Tqpp0!np1-aaIX^^^^Fz
+;pBXWW
+
+CmQ^aV8!kCcSsKk[{^)pppppP8$&!f&<$<,<&<.<%<-<'</$,&./Hk	pppTO8!,	kC#c+k[{BzaIX+!-\%\-\#\+\''/MIznGpA88&$"*&!-\r
++p8+)fq0r
+=!nN=-G{kC-%_6npTIiGA#a,V~9)Ys^),	+sOK{	W		;}$k?xIxYxKxO#Npp&<(<*<-(&+\RAnp0+s[Q)pHUM[Gg+~LAUC[WX^^>/IC_8!	
+O//	/
+
+Eqapppppppp0!	
+	ww}pBXaMxP <$<,<"<*<&<.<!<)<%<-<+<'</ ($,"*&.!)%-#+'/| c_\BRJZFVxO7oUoS",	/
+oSS7w3U&[O(
+
+w
+	
+OO	/
+p}R0>BZN8$&<9'/	
+U_ZN8$&*!-'pHM <+.yiE}Diq{Wg$^$Gzw
+/]fM1>xBxYxZqp	gCxMx3qZJhEq?IjBEq-q3T(&fVQl7]{B*gnw[F?8w(="ie^qUyp8kyOQ	tbWAp(BQ?=t|s
+Gu	;tCx<@x
+|Yn	O[j7aymtWx\M=t_xj=^o6O+{)?Mk8k+US\	MW5p`jk/5pcT)L7)N%Nkwq+<P
+WWoo)WK5E2w#Oq	aEx\xJxVx[/(5!	99q/
+WW	
+'w+jpC-<=)N)^/(^^^sFg%3f]
+~.K<t^=yGEG_oW<ztgx#~9K.JWu5lb`^{Wzpo;V:.ZOqpBxv~$*J?3wQ|^W}aKp,\wppoa?
+`7VmEG<kl'W#l?M'ItM<G9p3(vGWytk3/-?NPpt\{sNn}M| i-3	<@txtnr\}_
+m?s57A?Kf7s<3p/-p?s+{:{{
+g]Cxni9w1FQ_Q-qp1c9y/1:p3p.?K{:;o)^/o]@YG}3[R'-?pPxdn;QjJqbExX:+r9[AQmH</)^)J;|w&K%xwLvNqXx>b	kDGi\xIqwp
+'R'	gOqm/)^}Rp!'>Sd	=x?I1q%O
+~p-)(WPXR<	)c2(^*)yR4 W	o/[6E.w\ <+<=%o	O*n(A/SWe+RVR|R,o`;%xuL1Q?xvJzIqIH/N)SQ,+^R]R%ZR5-XW4xI.(w13H<7g_}5Gn:
+w0>Z;xI3'n[Nm{ggXE[(3l=x~FOy^E37T8xrIq=xyF7FWh]Ct~lp{fSg	i?BV>Jqp{Ow*x%FC_Ox5sN:(<*Q\S	?X@<\59b	ujN6 oq;xxZ-9#s1S<1xI3r'OzhZ0U\)W(&<;xIxxF|FH]t,x(xi\YuXZpNiE?i9/Ax<O+)W2xxlim9)#wCE54V<S<8xcZqKQ:gsS7oC;sGN+@MrM+CA'cj/ h%E!e}xkKJq9jV<;`#}Ypg/*^(U
+/Gi"xWP!x!*eorU7eofo*{'-d^.wV>[S\-| ruZ.5;h-8_y.x?'xf{
+|4JiW(+#Kh|2*_`;DQ<(*([vL*^t"x%x	:U{tV
+vnVf=sYpBV&/Y[pRVO(^Jqp8Fk<7x~5l_qP9xqv:)!'b d'E0nM{ ,	~b1;*jm/b<k>[X2#_\_Q*A0K?q >~aV8!,K&<(\
+	wwG+''9AppppppX8*+'?/E9_IN:=< E=t	%<m_W~vU^~	no3xO7xi=M(hfB1~KB63xu9xw:{4,>'Oc].n}`'Czp,xh\CTQ^:n:$' #?F(a{ypIv[^y=W<w}W<kyp9F^<%
+N:WfS7+^oh^?j^2:WOWm]^USypOt^p'#_O(VEuAY`{O(x	X.Cw.=^dq|&B4}|h%|qV/5WxMQv G}Jjs+c|v#=Lw0NeA_^	Kc ~]/q_CgG+]!<:Zx
+1hA<U~?q'ctet_x!V=v=x7uClttI]10Ctn:F	VQjA7C]t
+W#/*x=~SOW/C</vx}!C1!g;m&QvmmE3w>g+.-<.(E(LAk ?U^Zh_>:5{x_$}y7u3Dk<.YxY788ha2#<#)k-0Bq?M	a?[(#Bko%ACNpsUZ!'y^UN|h$O~uREjx]?n+l[1bz:xJ37&wgoCx>JtxF/{xnxU:N{i'+'<b+<o<^*-`{Tx=|M'G<spy}t	}t|]' ?Mt||?=~.B+}>(m`vX>|+?ct|5p1N=<x|7w#~syt|+QBA>x~2ZJY_vj:bEqiEq-AeVp&bU<I%np#p|gjQQsg/<FYc<>:_CGQ:-<RE03Ou1:9pgyJ7]|i:G0~1}?`"J7Gym+?[fV;y\UoYp2Z3Hh8g#p*b?oru*;G2k_]W-\kn	;y;btG8p]tO|vp>YQob|sV}}6x<COr;Q#u*iAa.Wx7q~pn"</>DcN=Cd@*_x	Az:~cA_q@x>MO4Cg5wVs7yp7@]/fSGxn-?m_=0x= 8kW~L=nS|k&#Q*uJa\O5q:.<8J30k:z _Y._|3AZ	b jc9E1v-;[z>.?Y`{ki~hg^ICgy:	<j0E'}1Z=x[)O+F.w?xi{u(fWW\3g <8*3g)0ug/!+ab^QwZ3~<~b~dY{pf{4}3w+
+loyFpSk?A/n m?2pV<wl]x<~:
+7"te
+<[O+^78!x_V7-`Vby^p&)&;{%pAIG8$!/,	
+/
+oE1\{Ty|U8!<*</)TL
+W'oHw_"cqKs=- +O/u=tGx,=c rEPB~I=E8.oh7d?p
+"#r?t
+gx.GWO	;Jz x^a]o'^<>>Z'\fHq/T/q[tPX/BrOs';m%OxyFw~z ~1Bgd;x<x1Q:
+;'_KQ!<wv9gtv}ap%[7;2y F{x\xuy^;i\O?M<h	^GOSCYO~7_+x]W<>o]2PnOq8Go':`|;`X$^`,Uq}OtMxvpuelY8ZV;h?A;t^:h;<xJ;h|n'wayt|A'I:XbNZ']/}A'  qwv+.~~7x~E+w*'hx_B_-_w6_hol6B%p!B5+vo]nYF8:iSG, +p.nfn7 z4oklOy0`_VY_ui<YEi<Q~?4v8v>7F5Xu<yTs?8]t|-8zNqVN8-N	<#</alZ#:`?{-lkz.Cty^z&tKw?z)ze{|1+x>h|OmOV7h;>$y]
+;pOd?(rty	-[et|cQB/h9
+yh5 Z~'Q 7|-uo$%!:O4D%
+X,!Z ?Ht<Lt|/>^?=xONy4/Dz<qKy^-/@|^!oOu1e= `tP\AyWv
+[xopC;h
+W|~g%Ay	|mm	|=]<O;h7t(8_;xSly>y~,3Tg; 4s3n:t| N'::lAovst^]k_uux ;W>utdI(`lW+I;i9NZ	Uvj|Y'_:)W]>I[mNtpv{;i|['`,wRt8I)ltR~wunsb;|/9:(x:8x{ T'vct<I6IuE^%O;
+l7I/-ON	#Q?wm_;N_nA]DbvwQ.c|n_BlEkod{f^'hVoc|qm_vl/+^]4
+`7u~p. _E5]TvQE5]tEpo#`.:NvqpN]t|NEw<Eg?E_xSG
+.
+~o:E7v-s]tEwt=w#nCwun//r=?n/qr]c#\m _7Fh\Q#\;F(,BwD {d;`;\p#~7	lG"t|} G8x.NF2Xp&BW]GG;E.t" #D(~4B-?Gh%/Dh5x9BkZQpq~aFH7i,n WuS|q7
+n nZ n:vpK7_Mvqn:	S4n:uY0Mn:8Dp``n
+n~n	[vmx=	~{gx}	~y}+vSB7NiWnZnZ~i o7MCWi`W( {+(u,y~Kj^(DR|y F(_#(c(pNS({tstp.JQ>t(]k{t( F&QmDsQB x=(EE)^R?x%J
+BV(<JkQZR(!v;?en>?n0Q'F{h?e1 9Fe1*U1:hCbt|uQ8[ct
+|[Nbt|2Fbt"X%]/FWct|&F]1	-hn?;?{ct<GbeQQ?x>F1Z~&F+*h5G1ZZ1ZQ!K1~9F[6Av]qF44
+>?N{i2NoS\	q*/S	|y*8A0p NW08(-Nq:	{tS8q:,X9p*N8] gt|:Net<8]Oq	bn8g=qosX'!'?8x!Noi9x1N+i%8?oi;qZnx%Ni8m8moiEnov>}={h|N*{Z `z(:[{=tC=t|Cg}=t|GzNeU=t|_]'z&=t`O{.=tk=?Cq=^g{hZ	Z^zh-w=C	_zhRzh
+R/m{iszi|^//zi\KYzi^*/^k{p{0{(zNoS{48KgYt7;?]:bu5jxRU<yj ]:wAPf$N['M7*o9Vu`F@]e)Aa5wuhih?}^g~yOf/u}~Y]44?4?~kuK_jK[~h>f/~k_4K54OEs~q4/gb4%_B)%5/eZ_"}l_/|/1~CU5_seu$52y+)wG']IkN2v%.WWJ^=kCJQqW]Y+_w)T5wg\i\9+u+<EW_vW\ii>YSW\YsW]YrIW.k+ywE6Gb47WB2]W]W5W\h]JTx/W\khn10KsFf5o6|=?k$y93|5F3OsH^F5w)h&<HQFi1R5#k~HYF4T4yJSFY#4?mFNkCF5ih~sl'Fh2|Yoik~HGY#]U15\g#5@iDG#|9#!)#aU#i$=#5_0l|HL;4t29$
+MIi=	HZ39$yg@wd/$+kj@5wyo@H`qai?n;J.Ow:oRU[/A$p8`;.[pnuW
+\Kp.y8gSpNq8GCxppn-	7:\p.%<pN)8	'8p!<xpn-	7:\p.%<pN)8	'8p!<}pU\pY8pQ8l`}pU\pY8pQ8l`}pU\pY8pQ8l`}pU\pY8pQ8l`\B>pn*\p	.8,p
+N	8(p6^@>pn*\p	.8,p
+N	8(p6}pU\pY8pQ8l`.[pnuW
+\Kp.y8gSpNq8GCx}pU\pY8pQ8l`gpnM\+p.E 3pNI8#pv?pnM\+p.E 3pNI8#pvk?pnM\+p.E 3pNI8#pv pn-	7:\p.%<pN)8	'8p!pm7\kpespi8'cpa87]&p"\p8$p8`;}pU\pY8pQ8l`Tw6p5
+W2\p98g4p18
+G0.[pnuW
+\Kp.y8gSpNq8GCxQ>pn*\p	.8,p
+N	8(p6o??pnM\+p.E 3pNI8#pvGpn-	7:\p.%<pN)8	'8p!pm7\kpespi8'cpa87]&p"\p8$p8`;}pU\pY8993w|^kEOOq\5m=B;^4smg~hBtHnkw{sl{3zcBgF}MdD_~G9c|*O?ia}ao79v:3cK#z,Y{Z~cg4sdIf~qgvwKcMpf_09R]o{7?]3>cw6k0f#cz-,c>9:9}p{&_o;gb8dT7f0!vc0+};0j7j@jV,@ts=sfm7^gk>b6dxv6=<whmw.y{}3Fk{g>l[1;:c20n3G\}5R}WqegJl='Dn91{u:<9vK{3WO$9a=n[?svWtN/;_jM);?;WlK^%W;?O{?</yo>v{l;/qf^[c=i?oE[eHn366]~Y~kk;o;/I{:c:84U{#]7tZY/y#J{;>}da`aC"%[O0[0cK:Mzkf}SM<+[e~s4=hCw3ieN
+:V&9eG5#==uvZ
+<[lgvl=5~ck\tnZ|}5}?`s>]M?h>4jwh^<>&.3_m~>L{|hg467Fm|o>,su;WYGV:>YnOWk@>fL;Ws]t}4^{z,:E6y7sg-gcncsv*9+oSa5|WTk}FsjF//~n}F[cc[m':\=>}|E4wz^Fcru}~Tso7;>^Oms7,7-^^-y{7+Y6o^^mx^x__&Jq%75uoqMw89}M69s'vsVN~:7!Inzc+{HP#exGzA[V>zfhFuDKFoY`iU>v>`^]Xzzl:?5nql^_t-?u)zs;f<iLub>M?jqt<ypfkvL&1rBRbEEK?*-hhhi5R~$3m!	Z~j;VU[gfr2!E@{ayng3goZkS;>r
+KEPCN]{vi|8+p`wa~m^^wE/;5-NTo;Mfj!uP%}Q1}O3vhB}ZEz[UEz>p-3I[>%_Z;po#f(^}j~:BZd&%[8Zq1~Anp@nCA;|<bW>32O}Xa^Yw3r!?$zX.hf<3_ rXfCz/63|38hix >y![ ukfl&f
+YN.4m6wi1#fkz;tXhK{J0zr`,Hbdi5$x|'/whG%6])C\!GCw3l.~z"lwv$VM^wDb-uOR_hq]PlRM8'ZIL:$~}nL5i-}EE,Eu)W_,/!9acl`LFW/
+]J/@^7q
+#Z=gY 2>?s+[Z0W$HuBZ,-`}34^|s'"l\[oF!.z`6Kd64rCdxi17|~:!34-hV?co6zEM+0VgQP_@;}9L*l31Zoy-/-hCi
+n mmIn msPj"NCU~7z*t\W39)vwH<gq7,J75d#}?}8&cyc}_jc21`L:12x1=&}GQOmfL>mLv@xc2\f+~BS7tX&$?8Vsc4j!*}31&o\- l39}xHgS24mRc0=.ps=~sj}cuN>oI
+JMJ8WCN]&|xW)F0q[[4*oyc45 _32'!bQ>X"H6scrs|C$'V0%"zw[N'm;d0W)X_okK.mi} }XI[%]i,;?sshCSAeeW#qPAkgK"j|YgWY.EM._O3n?6"w-}5]ED{~G{kw#h o&`wo3Ycy@S.Na4ghf%[ ;4o!Cg6L$?t&6sq'Rm|N*hcDO*jKjb"]T#_^hgzfk*D)Zqxa.5"p@n4	;9ODL`#ctY)%pA[u*1o )7"*r|lU%p1-p^.>!?RegjO /["E<=G5v+:OB[;r}Llc1u9]3Z1?HgD=(S0;{'|(-G}:>jFn9- cb_JSrur+\eJL'm!92+6]6O2#Kh-+ V+rju=VI;m[;Woy5>b  `^9cc;gS0I?xq3B&K9VZ^[nxu~g~	)XEs>F_;qSR
+OT+,7Dk=_ea#"w9yi\u\,4>@0*^VXr\=;voR7OA9B1r<"!N+5;R(hYZVJ0>/&WttZ!}g~K[:6O-O
+>>iH''n}Pj!htvI^ge\z|KjCD[[W.5&]WMa9ga#'on+Fnnci*Kk_}r1p{odL'^0 ?$!>XNnZ<	z7QFNdoS;XR>jU)|qc7GSMNEffC1gD
+nJeUv<~kMPRZFp]sg<kv~$GZ@UhVZq"'"r~+ M
+mx-X#J>[$v>R)lG`JZQ,cT^ m%*<E}{v /KdFq}wTb?>qF~R_L7 ]V%`Ww$hF9`=d^t0_tmkX)_
+gb&AAk>l_I:a
+mo+-8&iS	\o^iP;;/lw2WJ~+"%.~bBQ%ifZt;?[~AH+b,zOUe8zR-e\(7%=>X_=c-.o{cxxg'[/(+b!8*diHX2mRdU1
+9'Ssjrm.\V#mwO3GxL:uQIG4{/.sGsisz.'A[9Bj,w]b~>? >1V~eZ%c~`LF]jR'.~Rr!i[5L~lKs%c[n5m9=i[n+m;6mYm9gmi3gpLlKf[s-ja[jQVzLA{B~o+w*j[nPa,f)#m0k3%;{V=FM<"vQ6Nd{Y#I
+L0gV2cuag][ey'^h]tW%ziwuCRb~i=p?s?tROXqMev'9+p$=Z>{Vp'!ScAk,X h|4a}wIhwf4]:0d=Ey9q?k1P/\[X>I+Mk4(hu~"sZP&in{C"Z>o%E[-dO5f!NPeb]\*eWu]Vz-9B5q"!V5\xG:-WE1y_o% OG+^<.(Zh
+Zizy}\hBclz\(imK7
+W%^\wr}+Yg]Hx}m;~;O:YU%,^;%:x,^D
+p$ok1EotEXfE-6>c W]zAzX-([jb!o`OmWI[UtU&uZ&\[y5[@kVPijtM;oyQ`z0xuf[<NS9	ezxqJznc#D'KxrZu!i+e~scR'hb-mcX/^kY]p^2P7L+mi<..d.Gm(Ek'%F\-K}`~QS~Z85_QS/%r|\b>W*a;=rl6>YlP2rsuw5{Hu\w~uF;xi/g~CWS&[W$/!&|\={qgpV# 8?TW|woq%gi*
+vdpOApoPWctk[\c93Be}&wr]ebl)pDC=3kz`PV6[_G2<')0]k~s=m]Gp9klY#q}D\&Kdx0q=p-3419Q)Puy1]y3?|S 6J2FqEq_z#`5)Fq+eb%j'{-	A\Q||}5+D^v V!pA\z{Y'h#^c(G{UxuiKsKDI6Y:|EYF\{<^WmpTM:U{3b.Kwk>{?W5#qK$6&1v2C"tnMXx.I%XCZG^GynSg-Ri.nL0o9V<FU3GgI^G)^QnsnKKxK>>zoS{&orrcLif^Xn}L'G;>QXpCcjS!fwy35EC(H%k;\/Zv;^Ng_==~zVQ4<vd{O~\>1<=@F]g7+=slg&U;3zigg|:fAvae-`gf&%|ocwcb9	snFkMGbrv:s{ CQmFmt[Ir}{Gr~*=bOfZ%6cA1`ei=h{R#b\-VSQi!h{E$aQO'n$F}Ym\w;k_>\~s71$c> G#A)rgktRgw*6lC6sdsT%l~-*lnTymrd[+#sdS#?(Wf0d3'G6lQ,N_a7lN=;MJo>ioe&MHJ6<ysH%\@.S(!z%~/\3W.);[.]6tn)0~{&ml|'#3"!^cV!s!?%2KJ.B.3\BU\.Pra>r9&D\#g %Z.9r2Ab8ro\JmrpGryGF.?6HJG.\({h93h{=xd.S\Jsh{WcU%7R=z~z~|^X	<-]'3l zr5g<oCt <K'%) OM6xWOS}r4'y')boqiV?`&'asB'wJz>:_= &>	~&Zl`^4%?xm,==|OAxz$!i;&4O.w4OC={]y]8Y{Dpk!C{9)v#(nso:JwiW6Ht\s<x_sg26k.sZb53Z7dT5jx$1+</U#Ap~N,uz+k3?CU/568Iu9~
+9%rw*;%e^X9)>*MCGE\94y[#hJMEC 4hR]G]?XgF6~Zkg6%ix:WQ)]T|vgyaa)>pT\rIBXzh=CU:
+r8+Ac z?HMz1Iz(zm;=^[,2lu<>1E^9GqV7q8G3t}_g7)x[O>wR_(;V"tou=P1&nQcs?\1^Jrl,B#gg4YcQ00BbV^86lQpAGXy>JE;2QXq;W&K.7_;5?Wo,c[|3| <+D?uyTI:?&)WmnmjmAypts8n]c/kuU5Zx1^u{&B}k;s3|9c2mN#t\!s(v<1<N7LK?S|Z=M6^;<v>oy<;'] Ob0e;Agb[Gu[Z[EY$K5AJs9v57DS<u#5_g0u-VhQex{vAs5ygOQaHscrvlxEu (lB|n9gW[d^=w;cUL4"x)RLoguzbxEf'+`@I5RnLu>\tYgS%PsoquOJ,.M\K<YG-ZnB6EJD>W*B%}!_Z\=T_C(zVW!b{Yg9VXaY)Qk]!tB|?lz]gm0O_'0r`<Z<y y+gqxqo{-`L/Wjb007xTF-ZOE<<WRA?lkay#dQ7_ gF>	ouwyKeW&~IFV>ZV}`mg:2#ss<4Gc\DI.8iQnC8vsf]SswO$*y.&*y>n^z85S4zSo=
+x|p?	uf|.R>r|x\uk\YOdb}>kENgXu9gC<g}S7vm'i!9X2wor{]rLpOgKL5Wgp}kbJxz 9WQ{}R7M8y*O{MUk=	kz V$Zej7w?=ny7wM`^v sag%h77H+V&<gXD~39!s89qiNv#'8Z/|%e9g8*;
+xfws{x^g(8fnQz4sWE}m$j6yr6}iNm?j]+oi 9pIr\hNT>WY"/n^?*{\x7Ae|b.{|Gwlgch>Ol{&gts_|uK2o*|mNlw^8l=gxw~5_l~g"f`/={> nuFd_eDjqc,k@;0X_zmYre^h{:v5}nbe|nsI9/{p~	+ >-<#\#'
+0F<:j,t(9?}v-Wt}c9p|kuN,ggPVlw*Y~X}i.zSk&Bg!F	6u[U|}G$}=\3^W]y{CI[~	9xMryW_=}|6g|U}L/~3>X1]@<#uM-|K_g~T|5iu-B'C=z$.o}osdIZpykQg:-^;ugjM;ti84-:Nf}@'{2LT|3GO&ky gN.=oYyb
+Sg>O]sx+Gs}_o69HLsN[sMYuj-3{rhhzHtqOF*"tq|va>g:)}W'?uq ?p|6X
+ v0XG!zV4Y=S3G}C(ps!kfoSqK[Fx'E;jR8P86z@c^4TokkM'h6n~<}d$vR}d;x[e5`jlv(|>j3PmmWF>/}y#m2}M`oW5}-9l2 }@nI>l.R]C<-7k ^}F)C/_W\}6N@Dj1]YC-&zv(|m&Z}h|Rm6|mz	vs6|!v(|?6a[<dW__'~5[z~jfkUJ<j%}{fKa}69 };!=8}}{lUoV6@F_ZCUe+QM<}FvkK1kP_4X%"w	i$c(LL?0)owh&Qb+pm_GY2\tj7'+zo{O]z%_K+v=}[?S<w=i==<NQ&g g<_^~~y/;,BLR1XU['kzP3UG^t?k|?ro9Fsu:q\%n~2!8ssjM`DMt</AZYAqVM6>h;xOFu~)iLcq8'3x~g>~#k:"K ?=a?vJ{}WjS) S=^eM_K( 8jRO0'Q*=w,[~^h
+
+())x)
+FbZkMnsLfwXyuLYZu3!US(jz<Un\o?
+jtcX5e;^5BM?]}tTE@N#5*j3(c48{X'Dq7Yq EJ3gr,A	Qt@AE$UKwdv\X_WuV{\3G%'M+?KK]_hiVL7,hOhi%cw\qpmJUQJB 7 Nh@T0h(/ t"oo_ZZVER/	C9rXP^){_/Gt9sT6,~WL*k[zuTFU~$2WedsWqUW*#-XgU	YFYXSeGxe^Q j#hWc,PjUczr=o.{~ss#wmGcz.^"@b- "tGT&F:mNPMuGGW'Qu\uuK;YriK;rmMhP6]U	/v7smV@O2/lLGK^2QqwCquQq
+q"*n;\z~k!{].4/qW\mQU|)~d;h\uLQ{]C2u =*Dm=Yu?j-UqYo5+:Q{]/v/5w;:w<U)NtE6il#9VH{H^}9|-}k_@Q( Vt~T/ o9_=~s"nnBqLxU'8qB9s3'h h.I;lEP|=/=}fCp{"<sLIr1bsEDMR?^?U& 5Qhk{VW,={1[GhFdJEx)#wJ*>;n?Y1;:s'Ir8R5V	H?pu- OkAq8Ztz->flo|Zc6Z6Zn^^&^Zu\x-Yyv&C@5 ?)	LKZ31iqS;Q]h^)Gn/}>Trk#:v.#/W2ja;&wR-qijUyn~'O}f	~?6J/in*fm<WOs^,<'{,?(<,mGV/|(|[[~_A;QNVy[wg2J?A}mRygi>\.uWG2oG~b=+w~:p,G[}!AoQGD/79q/;Gsv~I^j<<v ,5iTQw_M_,!|yT5C.yo|RxG d}7vWQS/(R%nq:$y)d{m'	G|QdR]#|x#O!}Ry?t&^Z.-fPjC6'gi'|g(?9C7e?`{1PG?D
+K/gtik_xH{~Yx3)u_r~~a67W{si s?tj/z0k]vH>QS-vy5PVxp}JrrIswQ?;2+6'6?6ja+yIcAhwSV*GoSnyV
+=F7DjZ]>3=mR>\1@:Ul^D::2i-tA'}c/Q{xB'\O3|s8bTC=s}M~]F]2`_r=pm;Ex]YnY7Q\2Z~Su$$5"E?l Xm/#N;oG5}="rm8gS.MRN}O_w=(QplOZ@~Gz'i}EgmJMPyEs?]$?K-ycG$?NQo&^\[]$/7(^~q ctat,}}vI}|2=Jbq e'.y=;0dNw
+|Uj}P:H[O2 !^;dvwv'7|KyvIW:>y9ZCd.rgHb]]z3eD/@xO2+
+ nQE%o,Wy~Kv;D;ke}uPBi7\-|rf]m}kb={	yoKwq3F,[rZ*e0u)p!<QQ z{Q%= H?HLx Ltff  sW K  `AP~ 66 -<[<}z{Oz.
+|~f\Lj<HP'GiE'"P;]R'^J5 <jsa[|F+:RL.-B7fEw"+Cm}<vj{g"nyY7F<Sg>'F9_&e]!~0@?!`aY
+^,]Oo
+ !AIv4<z{cj1us$u\gp,	tMtMA wJ*Qu*ioa^,2Le|YG ?
+p   0YI34
+4F?s`)08M#MM4R@Sh*M4RT
+JAS)h*>Mbi:E[t?-~[t gfi^bgN'/ch$'1N0HAsX"u0	zy8Scj,Z^sLK~)2HfJ,'+SUfE?e?e?e?{oooooozO?kV6+2A#.?"Y/ Mte"D?1/y|)_|)_JDLT_xiSbi6]_oh4b4bTAS1h*M4bTj42L4}MCX"yJ5	qz'iNX/B64Q)!Kva+(}xQEf8ws{H&S_DH$YzmRa8iR$|*_[^{W"a2]K:mUh#7 |>~	s#lFFB=M]~Asba.Ai%jYjZxMk@	$h^Hw[!N7o>0#>@=."3|0/k>,i,-|!}'g6c!m+w-G?[S4w6Mk%V{"D|;5m>{X0yyoK/+V7]f$h-m(~b-67&kuseUelY/Zf]|ideCYh:95:2h-^<t<t@kz28Pf=j-(ZfeAk7eFk,xidiM2K#m-zS0z1ZfM]fe2Vk2Me2kA@22/O6Y4|FfdV%eD-plwAV[39v}w3vg9e9x]-r4^I7QWz{d"1994%wNaI%QYNcZa''hG{CO-AxaSwkuvWVzX->	:
+	-uC};i;I
+}g<mc{
+W;Ad,5x(Qe>d*TfEQs(c,Iw_PZBD^O&|diy+2]Q-/dz?/.q_j{{{gK+hvR-%NP{!g`boa{cz=p/(66mi3I1O<v=3;d['c{HzMmwz=i^sT|\%5:7KA{Lrz]$&3~XU=qS!|kw9{g}i;<6]zwKz:~~1t
+qG5}Zy!YF]VGBw+$KMD:?	x'm7Hg/lz):;tWC3BEc6yc]jFZwdv'}C{v!I/D*ABCZVu"y>[5J/@a0~*r6Dmyv>#r!xTI;RNC2w]oX6:S8eBD7zSwY[SQSe_LOScsOF}=Oc}JPw|N4&$HIfwIa~[hgmB%.#qno*#Q+}:\Kny:~1n'
+~u.B?N@=c3-33j48Scq({L8/8'`G
+bL.;iCwP-
+>8M8w)6:;Hm)&nS8H?!W'#ZTWg1hZ^z9sy&LiH_<1wQb4%8SM8C8k`XWc]&V+M88/2M8N	XkY<#cPpyN	h[`>sR5<h>`	1wo:?L1H+G>'i0|Gq'w*3VrLeMP8	maR0TAm~%muN;_><If`+|)
+>M[U+VX]?mXRAVQ $$!$1A.L&\n]k5yoGf?Lw}3)M\B1WK;ym}>1'|_}1\s[k9<sX_1w5#s"9GPA9#9^;cSjd;:3mg|7Htf33Vwf33x;q]!_WvUg+v?q?;#<.l3J8v%3(og<;,zs/1mgKvn;?D3;e<+[<;rNW;skgy]43/mg|#1ogvvF/;y8`h;igwgv;HJt8S:;-y'ig3?3$"aGcJ$N+`[Pz:4)xnJw6twN	3D<m3Hk?s?<E]'+C;ger>$-m|ooq0)~vgo>VfaDeO?	]]yiPf~^zkq&jws6{~(oW7<D<?Y#o@[|Y~7'DX&u4`0oIg,|m*3j68u6lqZU%fh#~O8T+ ~)>|iJAN;p(2L{.I&'x]PTZZ&x";,#MW'Ic0Gz^]u-`tj?EG<:"6R!#%}o^a7{yWh	1kVg{5_$OE<S-;M7,]Ozu}$05%o*.If<F(2
+arXJ-V$e!/\xrGfP9.s^[]FDY//Dg.:;XW=xr?`zd7~l)7=pG}:D.;Xo:ygUe_"]
+atNoRGlzitKRmngd#OZjZ/h%iih[uG{S/{F=]XuS75k_zo[o;:s[,eS.KccP>^kl?7e	]N^h{|SHY.KYvWNhSeU;Fdv}ND8/cw<[372'>szzq<m|,4xkIiNYhBEk1:J"iPZ?E.^eo),41Kw6$Z,.BkVJcZW_`^mCy3Sr{E}L'2v9|UffY:&tX,e;Gi9&O4sMy<:yy.%Mr UV.]'{0>j>7GyF r<F{(sY%x^Y4KOa,6\"FcF2EECz?65bnbG|mel[/0G0x	+>YeCy/8U7HD=yo[93ndLMz3SK:(rX';V*@YHs%D!.;
+iVoN[w17
+D8/HB2X]t++SHcI69|d}D!zzP	ia!/&VjyL~[4QhPUTiATs==oY|<~@SU~JS tz*T;@_u~KziF$ d+>BT}DQ?JO5d_F6w^YWIY@&Y+i77%LqM*;x]}~O'`
+Y(m
+?]x%W%\O#F?5F)iW!k,x"4x7O,$l~gLDcG-a LJqgrmqc&a>_mwy5)m#`Xf&'"u,;Xy-^kr`cy,aI6feVrKy,GwX,.,1lmX>DeLL3SAIqV351B5m5o3.q\jm$`V'V'#Im[plN]:.l$`{mcglM	;
+`dQ%,Cif?{mn5K; xf!WLVc%s=ru]Vb0u^_gH:ixX;U/1~QJ03<,m&7ec?fHm7rdc}^l)\%s37!Oc%~aWs`&']f?awvX1?l (1uA:2OJ<f{(kZyM6,Xt_ohXgy3D/O'`OXYAW-]L6}	si5[Z-6tl }!EW4We{r'~8?vlOQlenIN6Hs){.){*Cdn3_0>`jXPbK=/#<PSfj`Jv<7Ke{t\K~o$LQ7!JCf_8#ODJw4=ZloBO&!QS;F]'8{#U=~+g7Nd~_~oWO0obe>TacM%B8DQ$N nE?wkER+J<]/@#};gyB d9rT.O nr`{0O K<Nfe$J;(/sm|UYXSzt#(bm?XWR=ZLi+7b$(QCD3dgz
+8>4GlZ4v
+ug]$CXkM5>alAdI!8d	d3u]O*DAI:bw`!5KZ,cnZmds{mAf2c{Kq!/ID~2ZV7{)&K>=8(!g,oqSl2l|!3uZz>QU4}>KinK}|l?.3sIO[nud.Ks7}~,3j5b7lj{ms{Zs7AkiQJ&{oqLYD3wGx\N:]_X;QNsbwm<>cvqkPsydg~NQ59Ygm;*k"`5u	Sk:;y li)D#brk.zK\E<qL>@(?
+D~mt8N?)yW6#pl$Gx042
+&;b46Ls`1VIO6V{zJzoH.E5zfg*lvU,[wd-m\lEjBB
+zfY@3:4.a
+zl|SH=1'bm4p8uU\XX\<<6Imib76vZPlb6!c)]]X/C(
+"KF=lbm$3#Z,adv?4k-~>Tom6;xe|Sl3dp6=~k
+[% EmXmHQ<3pG??5	9z]YBv~GDVL;(K.B77}f@,ARz?N.1B)geDK	InzLnzQ3&kS`-q8$V3Z,#<Sm#[TG<~ea5=_W| ,	s=)W,SE#KYJ8#@Z\ST$e,wp9,l'WY6|z+bU><Kx}X.$>ZPaY*{+$%P+Vk<L7c=cE*P1z3+D[YH}Ah;e^#%S.8A8<)y2L<L'#37tmKQEhx@+e{;oh}\Ao0NmtL@	|f6w~22ig1xI)/0^EP9E^#c?2"[\U!Q]yT1c!$J<D-.y,8?{$J""]^'pnOm3 e$2x_+{a6o$U?E|KXOo	<I6y9^&b`z9IG=V4;h/$dgS"q.OkWh7nb>W#VxQ)C,e{?`-=\113@J'f.aaoW/J3*F OqFmaOnjVOw|3 t9-IDbKS2noN3GT
+zV qnI?utz./?66vA@evTKi*>gNm01K(a|5;/g{m8?+q0>:16q0/qWUu$3bt6EWFu ~bhfl$KpDUkvI
+U!97sG g>=y2ed, 2. dq^/  c~s22~|e4cT2?*dg"4>s2}gi4kcteD^4t<44aRv n ~( p<,_-RcVX?66<+kcA[e4Cl,0Ho?\YLB~=eK9-$T%+d",:W['|Qw%}J|B2NB}wX9>9fk0.h?fHW"B
+H(2me>xJ\Gng*QR,r}]T>L8jA7ZT;,,Hme#$+oTf]C?en>946G6%TBW&64(lPzejG
+7o`xv>7^
+
+JyMllt6ulovz-Vwr)-W\g62ckE9 ,'LsD8yzO8^.la	/z>R8?l]~$1qT-sC>ZTFs=Pw Oa>q|yM,
+F(wGF%~B5$}cHs8Q:tZL:8utNIU.6	:]TVQ|v9g tu50RU
+H1cnFgXc_\iLIziG4Wa-ry\"c_X\BtM*Js;rt
+)'x/+[)(3rKi}q_v^S]s^i@\:Qz/7;r![k6u[[Sx}];6W;!Ns7(7znu(9d|z@uS~Ng6b\jJjmU~fe\!NYvMT&K-mIr-G>aCb}6TQPIJNp1,O9X{C?}$oU$zgul&*MA~<L`aUIQA|Ce=_;$I
+dC|W*{Zx{:Ek+]{98_ :=XP6_SwSV}jVxya&y~2ez/}ff(SL>Q&LK/w2M%{+cbkowO;7fP[(B[%ridy|=JM1LXVAZd=Mvq#b,= 6AH% ;;hX96L1*,3*Mjw"v88ZEgIXK$Shb`|rEXU&1-MsVg?qjD+0~@eY n`{ e4s R">A1|ni8QrI;juuGc^b)l<mm:9kS_=[?=1sn&</c7],:fW2zy_X+,_K|uIwH:	*W.C.ePZ[mm6Pgsi$66{Q:GJ_IpWjViF|ycmMr!|YzF9*Y=3rvg&ceb.P=4$>Vt}O99?s2O7  	La33Oz&)+/|wd#8*9Gz_"sp9j`APYc(577/Mo<_{{Rk77Hs|(SY6~0/a\Q$n*|mup3}r}]A+,oKRuQ?_kh-[^ iVMRN/av"_FNAqo3;|Mi7>;vpI7EGxNC>D?foGRVo	s!=WK~4x&oPz8=$E;eU 8 0\G`vC'P>~[^YJ#]ZL8*JyL}*]E~>Ckc{!]Un1!EB3q\6a/+8qmg*e|Q'yz>i:C#"%8FZ||~6v>k
+!>jt]evj{.[o;6quSMO`|lhg85_(W9e$[.7J1
++L|!
+ :|+
+Y}@rvu@@X4>a}	{?:FZf#{zG{:MQmd>MGT|Dh5G>gKx#*G;G(|_|?G#FrS	Guq=GM[12nox7<7'oy6sCTC&!Pc{sI$9:V_,9stk\tAvk+lP}?-"{k=aHI|3-C9-1#Cb{sZlpdgkc4#/S(j8QzR{ :B~=/l={jJbybyr9q#+eQ5C:ch{T4uoi12RxE_49G9.Gw71D1rs65wE-uD{sH<Gr-CG1qt0G^k,QQ	eoQ#TUqv>}X/!H6{. Rgs=lB/>~bA1Dsu8h2x0SDzC| ekE\8[AOn)|MrXnG{bcjbtU{d3fuMjk[|aez16r)PP9>QD=N8YWii}G;yo>'n$\kc}6_aU{P	81fb"_8_9>[.<!e\c(ojR=Qw
+e<zgcW	.N`{VKjl?k9s83cw<	>x"<bEe77{G>GLgx~ygrn ,xbH?&oI82^~H"}PnPzrp?VJsAA>Cy8_g591yxcs[vr1$b1HBM'l!/wWcc\$5"<|$e;,$|c]%&I~$ALI`	LqIJ$0$ZIsLrItdxcR[*v42lux'H#OC#u#?4:<5q9%g:yZX'=yEEB"cR,oa,rW|)'x[7N t%Th=
+G/0W8kOE 
+>K	1CK&{Ki
+ds]Q&8;(=q&Nspt<}W=w,8XO]cWJM/2;S-cI9hq=q~_XyWt3wgHdtQ:j9?Nf3t[|1y]~8(&=?-J7c]yw
+DDgl2Sd,#	fjs^ yMxpeTW/;{J!_4~}}q{BJ2g{kX]dH2w:7hz]tSgz?	_f&ilI0mAw/de)B3~ wTs!qnx{IHYd5woRYnIrg{#q`J["LjKB{k(s8NE/D{vquyj;"'w&t<4qvqI!c?v	_&TM@~5YB!K	_9q^kro?`{(#cCBW~y&q6q-;d_,$svqq>q/h{A^RB/EUf^awg)]\2+YIrg{MLYgrX7&DKx U<DOx*8O<D1Y.	^n`)w>7M	(bui8Y[b:6vM}^ }1dks|H@W9].]^]Et'!~OKAtgo:'!Sq>GRs>q}ljv9@m>C;;T<wh=nqO[tOc:DFyN6gmi,6&'/eTOYpFhn%O,ZWm	nKjdtj=NjnHsu\7N%&:^5"\]
+;[HmyZ5Mkidr$l;gZ"ggHR{"[zDv6H2nuWg+Ov<];5?vI{#	?k$Md'Nk?[A691s,/G{Ma	o:NnH=:9wt<{mMtk6/o:3|`tnxQmcpbSX	v lRN~NU'Zus/t~Gkst:7zvs=k6zwQv!663~3s 8 2>}Q6tFN+u`qyv:^6e\Qts{nw?$u:U8#&^[+@lp6kl6V*bn:eMpnK3/7v7fpL)p3gG,NpU?Md6zmF?!{yE1wfJ*wyG3[#d$6v/h=o^eo,v.q$"7DcB`lz;uT.CW<^}%Eop|z3K:^qoVcvo{[EcTP{him;nvSvmtJ[r`#JlM/FH6e$3>uu"n3[#C{/$w2YZb$Wbm6g{ZWv	^q.$pZmnumjShI%_mnvHjv|N{-L`upPnslm{sI>=e{uf{]4l?6fO6mfAG6m8W<J32.Oop}j{wy^>Wi)b
+lbl |fz1=C&2Npr89JoV~du&>	?\rWJ:S7h;o1{}3:3pSs8N& j|U)-d=uay	y(?<S	x2g'(*Fdy_ly.Vdsb81)>G=2h^:y_
+<~)
+f-^7}`<^yN&"6,_XZ].-r3wK\e)So|m`o $BS}.|7ZWk~&)K.&I")*6|lw~|g
+M\}6cNo 1\>H6NwSj5P(XzJO</zTJs
+-sZ4|ewEk6(6s (6c$ ;5K][b9`G+x^9 wq/oG>W*@'kS;4?5Q,lo7WG?<C9h*w\`lec8.2:9KswA2bbb)qjP@c2rK,v5A{[~~pTR;6T~(_nhdpzVv^>q{F+|-:w6KGrAsay$S f<ls(O],.c(j!oQQ+abC],u*BYnVCC?C?d?{T^_oj5)Ar[:oj5v.`&6>3Tw]1]<q7;w~,PYzXz|lwOd^cCcTE3vx 4V+
+LF}X8f]K;^iYgx3FQ:"}cq]?cF-+<{gW+}=001/G\YNfg6AUSXL;9@6 J6xln G#y~mLao%k<kzG:S[w_cEg)~m%Subz;bxgzOlU?3@}oV4PFmZ
+tqEbh#%FJdvep2;7m--Q3@6cmXA>XDc}0[u@PfAg,j/u(NQ~?
+:-h0cOm5;%17,zx;bsQ|w'bru=ch\O.|ms~D_{CfYt\shNlL 4LD!-Wo(7 p-6vv2o[vr`;\[[zbn`w[qLOC[aCnnl[6C~lUqp6#*\=Owx-NSUHxwz,v,Q
+egYvbVM<DnAggr*Amc>_4kev.h=s8qgeXn=\?v;<'iDF?!/g!S{^^|<8aN@:x'n?FF3w*UE)U]gweGwIb	f3N6L|c)>h<{-Ur}"1X\]w>.yLgt^b9ocn"./'@DnO]GiThR_.U(oC69)swy#\]M!M79h8_AnJ60(=usN]xXwJsl7_#in,Ikm.s^q\Ym3WpQ?(|~t1E2}FeRrq>y=7_dqgpsbv'=/W~Tg`\^{"NkqfQFZ||4`B6k:TZONh2ag
+?/W?EUe0nX>g_i|Dmy4aLHZX9	X(c*<ir\*6BjOQMcfsK#Vp*3y[ mA{$x?/q-:u@5,cw{Rl=<NaVFMbH=pIp#I*[!xp\Mm<k==KCX= NOLC=)UbwUkuu_@*Il`Ik#FL@+RX%|>\%Dhsyo$M'[xkH\W%B]N.H|mf$IG!/.dv^HC!)@` <P6+y-4lioE W yS~G]+|.&s}m0No2c"o~nc$Nxh3}'}N]	e~EL&kGqKCuF {b
+)D6lZ1*cQ2oE0yZ1~8Cl=Z?4Q>gz%/~;bY.8L_>MLS@L
+7ZT`<!d<NZMT^d^c}qRo_.Cc#b]1pDx| [.6Nw4wSIl|iylpQvH0[PM|9'C1_F,eL uF@L:}{$A[c| L|>u^.bzxI=6KK6	Hi4'< O6hIFsfk=q>5#; 	;^	YQ0bFX&3y>!|e/P#7C4]Aory<,]ctC0c((y%w}ljc>f
+1Z5x!iGH)<Kx~x:><'._|HU,^l?]IFI0#LsC.Uo mo$}o!|R])`u
+/;Bf 8n`	0%c	r
+q*ef}Jt{V9Id_ H5;4pKk"[t&<>vf`BhkWD^Jp5OAwv^*_bq:Ev(^?<c~/	}7)I|E0d3~-Rk\!>t^	 >lpQZzQ%Vm'7ylwa]-h-U&qpp*|$}0WO#/i2^gQ{%	?!S<Ld)haI?/+<MO`01?;ag|^'+I+s3:5d7Bf~? \FtJ?N&~	YI]b~."?s2B-9W5QagC	,Bq~Z"~~.04~\'7$???G,|Si_k%?e-AQO!	Yfgsmb~fag[es$}35zg>T4/g6(9 [8=m<C[ZU#:,uX\+L;suq9`
+_K6Bm0zsmWbwSm
+akQz{\o[7UUf~*%wFzs32?+,	zh3ngX5tFES?c<LpraxURSF;>kk<<0Gy(?Zms._)Qz}rS5\7o=o[%}Yohk]Z#_\;>pDQ}Tm/<[X^ `;j}TU>*yQ]>Q.`N@~.O}TKG8Q%o$|+ZGWkB<U>|$I2Pm
+m86`5`7AB80T>7&/ J0L%'	"/G<YBk'V&G}/V'G$#[+&x>#7CW=	:kWch;(mJ+z0UN{N
+{\+-$r_r_BZ$	\E/>_GrLEP7L#	oD:fr	&7`G	wQ[>UUCTT:;g	_QW17C=>[yN^*+<=Uid~%uUOF< %
+K FGUdY&dp+*(*. 1,;%!t	HqGGkp ~n0~MU/?"3gS[_eH_}.vI]N&/o-63}.4&;}"}~2L9h_k/Y=$owBwZa(;}~HD9Gp$Loy,h`vry?4<y0?l;8}4>Wg%,@!k@MhN&}of@s>4LHOI}6FLN8#}YN9Ha, &,Yj%4}kY8Dmv6Ke$&%o6WC|+0-.H0qC/7i?ce}_(E.n\>tg|?C3>13V~F=3jOAs^WuMn&uO	5Q{V]&f{VSk\+m\?mc{2IX"l=@ [/t /R}GYthzzV}lg>mm)]n|!bHBaTFjbn(uB@:Q[^s?qzz9d6OMx6RPwL'W7G,XAI.M!ewz#$x6-Mw;4o	>O)[5kk+nt+e@3Qs\za-|6MsYh}\fo]qE29}7G0}>j#}oQ ]yy}>r4];Sa~{&rAsokyH|y	o?z%Z/5~<.Nb
+e`vE7ctg_}4{q_XA_,s3}Xm	9|d`+%BiH	aQ&$P>e=gR+ e2u1o$W@xw)i}T}t<d!smN&_>@XM)pj56ttXj|/w;7tNBe5[5D/#O#@x}[(6Z&Zo=!=jx<Qb%t^-auW;	wh:]hQEi$c7Sybl"P__iqq>keby<0hk3!~7A#om{4k6MVv5
+6f~\D:oAyuGUno#]Ipo) .20BI`(ag(1m:~\b|:#G9_xp=Pnj=a4_#>	1gzh}1^"e*H/tl$m0_mt<zy9>+z{$EtO}L"ueYb
+U\':yL'go 2eky;X8jMOJvUC>k>.1mL2_MZ-d =%Gz)G_^jy`~r5zC_"z :x_^:oyGy/%{	{[Nu| l`EFy3!(/+l.Lno}`sM3%}W@gN$kNm?\c~v wl1@dtt=^y@uLn 7QZ~'iZ97+zYywsh&yYz9/-.KtCjqn ?]7d2A8A2efN:U=\A^6%r- 3 3e[.3 32&5xL^n) /R"M,OMv405%%;7qyd!NAv>/"hn5v=33~gSJy-bJn/@8a+^&cI<~f!}cmoi^~dc&q >2f1_^uK\nxokHlr'w'Nz)|c:~h	,*|"s7TC69h6 C7=m;a+!Q=F]E6OMO?>`;(vt3PoLIE?9!HVa2_oB 
+/a~a''Gm{_(soYv,v(`YFqy~2T}>*0fCig#W=~c]ltl{$]K	rrn6;ywtvLv(2P*Cn7/<1F`gT_ta\*NrbuNzKe(gfG2'][NJ*?_b'G?+9o_:030~?:o8y6I89Y%Iz>q	Zqlrm=wL+y9Wis\#08X7/8;%c7S1Lx*	lMh2!\D 0a.2CzOo22TtWCx2N@,Ak gpp_8bs7rx/!!Cx nJ(<yyA9
+v,v`f2)0L|+5j!AX a1%!4@X^!f D ( @x.!Da'CRCzMv
+XrGb]oA9SuYjs!Uz;yl(S"ON y}kQ}ea-	:heN.v:_[HUWX'}+:YZ/+LswZzs.x>t3zZ(dvn+lo7	_]2*>*Fjc'cN/]{c	WY	Q}w@%j.{M'  ^GXc(-:n|;qCqM@s<suk@3d7uDD.V~$?sUB{N{3'wlHxs	+XkIgwtG(8C=1<rLlfy<~}I@
+/Dp_B"z<X<aP4EY41}#(W %xMs|E[ODiUu ?Z/"} IE*}V#@gVJiK/?##^N<YFlgkx3yE7l^
+2
+o*{<
+q_:wR1*>LHwW4o#6UH_*@:&!G>*/Xg,9!,x<qC=Vv$ '/@S	
+{SoCN"9u4]U?
+Cp)MBZVR?R*KK&{>\RcX07I?!}wG3wfHfH_!&C:e1}Rwg'J`wCAVpox/ ;/w`})uNy(LD0
+0U-l;`n7`L{0J6yh. 3!Ohp``y<#ms<.	 \0'		0W}\0+p0&Y,s	0r0^r.k]
+`\aF,K^;&ra?`M``{W~kn"vb}3y [\Gx)Vb}(l/._a`w62Y
+}%V52p;n!oIgF9=0w!?H"7{L`O9mq;^m6UQu>~:9(+K=\<sznzYbzV,B&t7}Q>|;Dyt_)M1p>s}Hz6~7wq.6R=nYeo(J9	LCap{0o
+p]O)Q6.{/nu:|L8krVSGoG/a8ym -%:3QD=L+YVh|+z$sRvlGV3tjg2tvq:Q!qW}u;\KyDz_xwk cE!.~;ka#"Ba<<S6_ <5KH/x`{It*agVz{+.KP!/PR@l` ko
+om0kMu*nk<#;>7q"p~<}y8y~" ^x9HM%<b8U^5Jl}	*P^+x*2'l|fYu\>#\lWXu9wIjl+_Sv*Vq{t] #
+h'&Dh|"az
+(_Xt%+/V5bs
+A	:n<\,)}Jw1a0I1k/WA%wQO^s$9%4-!!.1?\5wh]:Hgag	\qbicI:y^g;]q.Lj!w! 6_sXJLG}C}k8w}a>*i]Q+tJ*Q-N+VqtyjD>3+0
+jrlA>dw=$4?sssy9wys8>_<!BR3|`<\<@~<Suxzl`<x;Z |#<gv`qg lMHR;[ XQT)$)i|<#fis
+h2+K_RA)L ;A!}YuPb.p =gmOcZW1	Lr ~-g2u)$Z!L2W%>&}
+$@+>=L?'[@5>KX;12]|{L{)M?7<]|LOIxgcYyzBOAq? i~K%??LZSnNR_C^&-)DK1iOA$g$_Mmm]08M8jioh#c-s[9[ioyf-:\D?:]t	d-e_ {\!{V9gu#{RS0__Sl3eidtBnjiAzKoIH-R@wEY6Y)OaDK4LkaB0vlQ+{x Evv)y#-h^O`nopecG^`|~ey]m-_h{GGHh3'mco+~>l;wG#^UGx6&7l!.nV q -Gn/T  Dv,MoHnu,&{Q=fAUg+#zBI=7D9Ire@azLy+RvyvCi}'*pah}7MiYG5:.K.Mq%tD&[p"-K%&%rZ/KK6g?[DZi.p@rDiq|.?O-V&}7y[#q=M&4ED6*]GZy]=uW=by}%Rb,Y7~k3>@)Fn6N4iM~ns3rprP)yx~[<w<:}9;c$p81>p`XxIp|Gs5-Q?({[s&#{%?GM4	og_?RM6+_kVo9~O},$8|5qS%	'8^8#\j7|%=195CSiYGL9C\A.?JZ:\tAR4N:tNJ
+NArzjOH/1|OAseOXX2q0L6`6-zP`l00FG&Aaeab2`.uBh<Gb1b16`8(1xtN> 0P{#?nv}I|a%5iH*diPP~s;Y67Iw?}w	;jypgg\oPn%&'Ds4Mhi2<=:mus-Qfl~!?co<%tJ}uQ{d>Q6'S"ljg"{,>g!bHm<)rNN?3EJd2iPIgQ{})%Kc+y=TD4m7nRi:2pr>&'Kd1^zsR(6"#h&h I6Y%,|P9<}6v1u{Z]zYZ]R*]pC9h]Qf|sN"IUIsE69tmM_vFp-bg;S(?=no@YW>r>I	Y\_pNqlm)(9(e3bq^S/D;['x~e+0gy-c[
+^DW2BOT~ l7_D.)p	 ?*V?\1gx1*Ip gW$i:;~syBV;o0z|{S(-;>-3iAlZ"i.Gv;<4?8wKpshs0o
+M
+l2dU}yLmd-]J},mWA'0+8+On>cC9E}o]C{cyS}&|n5g<k1M7=g'5`7#_bljZZi3/~LPRC,\GW)2q7[:[=&FiOv~MW*l9$q4uZ?D\ f?s KQV$w4c7Rwg3hZ WldCx#m,U66QIHtei0wWNPf >;*?y/{v+8W~x.U/nG_8xKd=-Xy5sg'/&[;'8KwpR<vM9 W	N)Xsm<;akv@-BiQO,>*s-'war
+?:8 *'VB{;xpkpppN;%q8c8\n*~E<sp'p}	wpns"k%H{O63?x9<T5w"/O!b)8EtoSq%ss$Y$P)?<O!^z	38td,n`a	]_0a%:VvKS@'o71M<
+C ;? I_#yRwDhOmj74\+>:E6ZLF|xtqT6fF^@PQY.B}8raIH'H:QTC{EXOk
+$3JghaM3a&'#HLHuB'D]95Lg66]:%H:oK&tR=k{Pa?pxM}+'J9quqIXP~r.10<~m]@Wni8;|]9Hm{E8f6&'Y<A=],^u>=
+lJ;/ >KnY/wf9;!2U4/\-"#>L>-;Y.}M~Ow>LY1nS6My3yqPE(rD5qe4"+"dDhNq>'D]<:KtFxCeztqP:(?45o#*M?:eL6}g[U~&"w
+a7	WwrZ#|%s8 tkYMmC{%u
+AaK/a,Td9xonigb\yi/DwiQBs@~U`|R0?^?$#6K=g F%li]{i}x|~o ]6(e$Co()e'e3d#O-Z~2mBX@?n_)C)V@FqN3r2=-rd?xd.e8s<1V8oNmu]6qYbY!G]as=('Lf!;:gw?KEY<)QsU]*|a5xV9)4.
+9*Y9xG{k.y}.d;EJ>m='{#b
+cS/jvW
+<f+fkw1n:~<t26q6xLoX0~tO#h>s4dlJc1 .qb; kU.?vp*caVf|v`2c2c22l?G+
+eJm*qW{h9{F]c^HlUY{asK};K(j>Wd>l{`Nrx|15^67v5W(c SxqXdV`V|1`szb=}Fg\wlO=]dXbgZ^ExUq~y(/O&-zyXVS>,=W_&?kId8uH?._~|g;sow!${NWu5Q_l*;ZbTd}5E8RoNu:IK6q^nQmy>Iem9[vm&k.4euxh<B}Zj*:}un>xo~t,N&,COE.9Ov'"uPC4fbE#Oe`de7+ngkF|jL6*[1ZPs
+Muy)?gOdJ 5#h$t?bUBVC+dmfo#Vls?,HkfD6vFUVBme."h.L00J!{u?K{<#.*t@t$4&uGDM
+QK8LCF^AD[36/*(t <LkK8lFNZ/.9?m9Q_muYO1]>s%Oaa#>kg#b_I2*<~-\	4k W5Vv4H9$L^hq]m=Ir
+Fe=4D]vyH mGNf|~y~1~,^$$hk&n7y-yloJlOfEcgT2;cG1mjp5l&	All%j&dv*I}u">}ZCn-ri)?-$;sd*?S/B~:&;j:+*sN(H?+|C"i	$sbj.	N`8r62F,^xhZ3>Fl?,N4wY@:lFq`sxCPO1g7Y=lNNq\)fY,;[KLT<dRXQ]D:aKul^uat?)QC$w\INgP1j:` .`WO.?:,y3>mT8aT8>lx)+e>?`kT~[dM2Z,&Kb}a<EvnR?HP=alb}s7?]Ql`!d@w\E}~v#5Fz|ox,[[E-a{vM-nIEW'_	mm<mksy S[}>6?45mdf!>]H3{`9foFq*Z\7);?m;c3N>H1|9t-9",E|3%oH+T'gSS[1rilYByr[tb|/G)=Git
+_[1wD.}<$m"Ipto)Q'r.)z{wN,NK2Hb7)Cy!=>v';^eP7~gCP7I+=ink7hh)bSm:6{>B)X+?d&S&3hkGpn8Y3|/~&dF2j1\\en18osAvr//}
+*Yj|b_]VWl4|y8>J bLba"=0f35sTH-y)m\jGWk9Y,n=|~njM[u(]x
+{dnNpK[V^<M~nm8Vqa'e[:$sMfnml;70euzN[(c&no[=ms-[kW2s`2Ney>e/81s1p~4bdn~ _\I&^N+Nu$>_9o~c:Ub=xYAfh7=
+u+cEwFiBQ7ssR==SV:dfR~?;sYq2_h<tR60n!{1nC><F/ek^c>^7t,~iPTd !k2|$cE7.%">=/q.z5myZxK4\<fT"Fncv)A7/H&E,eqLK['*>OZleWnK8p94|$ex.'c]cT`9 cix0kwt:c <bs,c[cMF`X#5)Tuo</E/i1x{AsVOy48>|u	\0~l=.hg$/O)E>'~^r+(7S}V!o[~cQt?Nr3tM9~[&Bd4\H"OIrfQw,]cGzDJeug-q-.R|J|T'Jk6MaTJ`kjd>.a~7gH~S|4/F#.\l}{q[E;[8d\^lg1Ny1AAtUYyJ?<<`ZMos;s8L-{XldsJ[vtP]T?? wf>Atvc(|T5MQWbF[8z3u	:tsKiz}a<]|&JepPZ^Uv1.l7Nv|;##g>cU*|212clEr{49;c,=<\MKYhQ7S~[v%My+j#;~lHc"MCC	5)-=e.oi=0?s$cEVY15<6Ep@at#>}0:Iz q.|^9fQk$g/1O$Wd`|5/ 1	Am,73c2gJ@V=`Io3@\V89@:szSQz@7Hlzx~4q>^mt1RdB<;dR;Z?3F:SfqmI%lPNI}B??w8e:x!:D=D&tC1U#*\	M\G\e7Q.:4<\C'#[?:{UZD@	z"@j#Oos=1'Ty$0bmN)k;pA'[ksq7be5}?1wH2U}/;l:4AsY~w] D|[bb|:;h'}F_P^smX	S'\h/G2%%w!,F'wLB.:Xk3Awi?ry$w5wyY_x}\KF	E/<gQ		V8raHu"sXizdmR_({Cu+jMK]9-6C
+,Yi^{8L}D/D,D/p0Z(kW=y@<feJO+IT%w&X>oig?l6or&mLIxZX;,.E{0~m\Z!#%jq[/H,Y<%k[KWah98':>xHr[:}_+A7avn'3q"OUlEv<w<>__<vFykory>y<K8Zr}ry<<^ryaq9y|!?/Z/	&cI4M|x:_k8wOg_\:g$?`!aW6+R8+812?W99Byxx[RMf9i2QLYGq8vLga^Xha&NcRVoG5t<3w2q>b>k/|\SyXn'12:2oF_ebd03##v1HEaMS+(+sEsCFC#r\Q9c)qb}Kl,]Y9:4~6&s4!Gh(G)l+8G?G3pT2h1q(G8"e+o1QK*t6.cL\8Zsu)t']3Y3Ee3aWp:lc(kJ(s)r|pV3^EA4R1xXCy~&:`(KP>0rgKG33QX;C(W3Y)XXjM7!>fsfCBZfa*_6]Mp165<^v,]MjZ3H+2A_lK*Y:u83wya]TH66c7R|Q AG7uQ?Au;*jGBTO06]fk&>Y\p$g2RF> wsxs/IO8Fg][~]\K1_q<,JP}>G@\ |WoHZ i	91zX)h>q,z ctgWwcjNM#k\@$/{-cn4? WITm8Z7Vu'2J1kR|M}}}s
+iCv)l+tt:|d1*[zv6Q4}#=;IaymYNtW~E|~^<CsLKkEOW"N6Qo=tStSnlAK6pb!1B;/F'y;ka
+	uq<yD(6A^z"nYKNi40R,Qz5pn]c6<+2iEW<Gmy6kybrFyyzD~jx=Tu?cNw}O&|7PN1`-TQfF=m?]i@%ksXDzEU{Acf>~^SO\{Z=-K~	f!]"s,-&#?*\S J~cf1=oO7cfO~CI"b+rF\J;?`bXg N{Nw?t{.bO-kwHKYrg6_%_hyE~h7`gy Q&ooM*,7{-UP{([oIqk/p8l.2w<H]!kx}]?4V}-"-x^)kv'F4+a6Y4,6~>d+vG\GU\F\dI@qg l&TJcQ5
+DTISkl'ZU!AR6@(j97w{wo {s9s!wj9*6=UR&=8 +\
+pXkyLA[>A]8Yr,a^q0F17)#~O#\t.;r)uA+x$;Xy;{J:)}=Q	kS[G'k<1[P{u.<ci/hd x(|/[e>aHc%7s{!cAvvAA=1z4`\uO>:2q%q=XE`I2&G`WXci[_Z9{r4KeB=P_!/(h7ny3^Rw2{lP?Do~Qd;0M*;awW}mcnkVh[wvZe6[;CZ!kv+nnUj.vKk~n-
+vvnO+ne!kvkGn2[/jAv*Q1vk,nen	i!BGN[n-Xk0(72[5|[6Z7A_n
+ ydC?IF3V\-|?2jAN/y%3C1l^p:Ir&b;B4'7{'m'3iq&QfB[{b9 Ts{Ask,y\T;IrcjC45|Od?o0|`.TGfP_i\%2Es{G:7<y}f9/x';/cSR*f!  Udx0{}3J>]A>|?H?ag_yX~1YL$N*s{mRw}Pj7o*J<i&r:)6k=fksv Gt4"Y:sl$G/*9o6C?2:::::DrlRG(A8^@_9+tEHht4F=w0DVosAlnA|r%_=DZJX-gKb$'Hx^<As_A=}IBvkA?ov[\}+a>!+XN%&1>FM	N1{8?b41S:Ixp'N7|FwaG$3#vosr>QrL<V<</;"/x;j+{NUb>~{9'0?2*M{0=s	JU[&ph,~#|oQe<(b[R{WMztjtt>+::DgFztb1HH+_GkzTG1h=CVhm0<B2w;VBvtc:zZ=0TK6W67])FA.Rzu"=#JT(VHVNe&(m/m?Pn]m'^Hm?Tm{m/z495y7~no7;Iv~L;S
+_G}NHE:Zu.Z'h$ZtiBDo_PK7r}X<4su?/(}HG}[&mOBm.ujV]wo- {>X%o;^7|`|z?Fkt7E"\ }FK/G,oI+_5:2Lz61u2:6Plv3BdV/7&\,#O*cY4u$y*^N: \Kj;~#]]7'cmi_k
+=i>^5Q;hS<\yRqKkjOZSXSmpj[+s-$4\
+ [p\H2cf1j@3'}(o,:Q,-w&1Zm(lfD2C\Xigfx=Y/<hVRR8[n6>{|wu(}ny_\OsexKw_^wPuBFXjy{zXl|/qe|$sE<1)wZ6)a>%["&GoNBWIx}b|urF69bY>OX~o/-b68k}xbi]Z<1B~[[zK.A2R?-|h$MIn`|)P7=kz GL	cgIr:,U}!9q9|i[)jf>_9$s|Z>BL1|/j;~~+x<SdJQ'u~6M+c1$,y>K<NRh/t-Iwp=z$<>D=}/K:P;UNgzLb1lTyT!>\|$v0	n0	gl	_
+1Gdv.1\%|[AG|^|Xgs DTm
++rD;%mj= ?dgjH62:H2FcT=H
+G>Fh5{x([T*Tj<C?{1B}%-cAFI6SJ66w:;c+~r^GM_R4V~{[1Khk4;cCG)YXVL?om?o]~/4w[~,?+ E*!QTo_e}bIzxbxG>\aqn<'sqvjg%*'7 o/.|W}g2'`ts+M]2kKw	xMxgfhhRx[3H_it<g_y,%#p;")%Ny+S8z?RU=J P{IVZb6gx#QXnQhNFVVd&}2`@=Rk,kQdk2Z^l|.zW#elAX c|dl/R(cgX cy>sXLGnSav#"kc}oxelEEmg{M,Nlk6yilw7uE]nO|qH{-y}AsBCZ}=k($F6Nr/x<?Ju-"veDs|ZGL,#
+ix7q:K\nDe`IEw(iGwQ61/%au-];]jaN5cC}8[<
+mAZ?{p|w=~Y@JKl\IWG>>70"VVCP;c0OVAy]2barxj+p/>V-bu(O;ghXcbN,GWVGU&X'vF8[+>9!?:01?>v!bww9v`<N]iPE@!Bc2v,X9D,2js_!`0a	Va5	!X,4V`rqaD8m7(/t	4g8N_Oh8L5|k8!41= fN8cMpZ@8=fCS5d{En:>\<ZEL&W8^&UMx,`fsb-v{QQU~("<|9Jgp@8S5Yeu/SvwV43Qv][xX#+D8\<kFq~ni~nP>^K
+{C9_G Cq}yU}-LOekRR{&l8On9{RsgF/f'8?wPxzPr^3eu7v~ H]s]jNu`(1c1`(	x0j?OkN<;'3tx3Z-Up!|4Sq^#Lq<tAm>us>w^wsxOX/Zh$kS\NYv>C|$>s=wg~T;p*o=!/u"?o}Z_p"zS|$3}13y*\F3-nh?;d"oyq	t	ft>sO+%}U<^ggrm/"Vxv  >Qv}k<Vy$Y^s^.+G/Jm=hs|Yv}&|67xwM.5H|vSVXLX-4(*`].P1V34W{gjX]-`ug\i~ihzAyo&XupV`:clZqnt][lXl+j&E`7{ v5NLDjL-3 2KX4(/:J3*&/8_{<s=d&C\#yN8 _|-,p1l,c=(~|s2-)"N{$O	8-!0qi	N?' X	^Ddx}5-8NLi<<j'::&x!nVf%5;KShAkL;*;GN~9)6l>W~jqh3=xG^56F2fD&g3Ik`H042s-s<|ff>?2c=`83g~Dva{a;gRM;q|fu9afiqO{xu^M:'8\
+3I9B/cgv:)%<rOU]y(Tgy+]I1(a"LE ihl)lY8;^'P>3Rj$]j$i	N{}Oq}s=#ed5Yq.??OIk@N5#TOZ\+a=,YD7;/{*6zU,(e^NxL1Pkq`YYscg>:q2@m~v
+FN*~=^Ie^C
+!A^g${kO68p6bCVx4Hz\EY{}~1<r 7fE.K
+N_@#q{Cr*gAe\mW?0\4yV gR~C'Ds3U@'q+">.V=fsLxz=lp~<?7D.|!,rhKJ-~f<S`rB2X~n'q^'998b=_sr>}a97=_z4f=>sz [(=tt;d,X>u0{]0Dn;>c'C$C905[n(P\CrJHUba+rzM#gs4m`q^>@rz<WO0Vfn8~dgQ{qHs98.Xgqsq!-.*wu'-;_9th16YlD@aCM3$;r!r/z^un@0>$?"cwOJ|w4eumPZ^.Co:P
+~_>bx1ay1be{X+b*jyAyw!s7'cDmre9Hix:\b<mLfwD5Km+f>"m*VAyJyvV6"ZVeSV6srs2q3Xg#rtrq+gcz37P~~j7-Jgvdho/b_e q]nujv:R~dc~YXbl&X_njKV7ZXzQ*V+
+cnzEq^i+ugsQ"v0PbLmzdw],ud)^^W"0'2;$wxa2D;|OJugNut}5w#r}C)Gw}1jL(o*s2ta3aRy(q1'CdZ$5~-Z	{Ck qXlH[$A2?9c=cBfsoR)d4^l<{/\gCGe0ldDyE~eZa4>*fFt.zv]h-g_FK/6?R\7DW{tqtNez]S;$q*K1Fv!)17'otwvl*ktk0~_Bc=||W MxAzo)4L.t&
+hY]oMfyl;bOe-e6=*=	1_<nEx/FyX:6`fkD9..inkY%1Y`k_mCs'&? ]x{Yox2V$u!@Kyk5NA}Gu3k${=&;EUst~&>X-m++6x6*m{OUQvo(k;g[X"Zya;VOX^na8jr6XjU_C~z5|=An ;^0r_CN|_l6FDllc;KO\0;IRYX`cs7]:Qq0_.|$?,d~'9+>Lm:Qko~|6r/o~Ak`3'E~oH<fc=2:)Y=%=7GE{PF!YC@?W'c^&1Y`^{i,2Z#1
+jiD=3l"6px,xjhic+I	kP;6|vnw{{"b7Y7f^*^9;Qp%6<7`S07$G`~><_*ylw]lphw#)m;Kr}s-9&;= exLGPRyOMD.l~lP9`o[A:3zkx a}8<^&AHok91JS~sG|7]$bw]-y{wX	c}
+wHc-q58yDvsX3IX{?z$%316o-
++FK6wBHV v}eF1)Tu"3T{u39:;} ru_kd{dm/Nl?])e{!IQkm<3[o+45_
+mY@ekwmU35<m_{G,2b~1*<m%&mMmc|M$&e|+bo7/:/fn!{+kXT=uTrin77:l"61kU.sB3)x?hw)7MoSN
+m_OoS|Q6)NLkSL/*sGv3pfT%D%L}yL_Lq"s&s|W=wIwP?3{so_Q/7`Su=WS_=nk{RYc\[a'?4>zNnG;%oL "
+@~py(mZW:5z M^k<kZSZo?:1Q~
+eb5o}<ZoB{zTK9e)u`:O#w{bb}/W__gw99/>]^/*qKgR{vOv<te}${w:e/wC;4R\~M*_ovSRo|u)z+ZJ)z3*M7H:p}mNRq)];_Jka^%r_!nG,]
+k2dEg<l]9l8./3 ^S)k"+}r>G_H*[|%:{'Gg|?tB[53c/c>LO\gKm.XEco3UwQ>uA~u>#bk<6-uHm"zX;Ks-f\9	lVCmM~(eYe~U4& ?SuiNctEMff`	|SEwg8g#=+y,!5L.J |L*9U_y[ks\t~o8b3zSp3qqWri9+9*f|E4}7g?7sC-g3o=w/k|1O
+P7IT<gl	-6t/KsT"ODljW,/zXLsY"ZYgmY]9J=?@N*ejkD2z}p"8#|3h.DqsXODm>gvmO3f>er.wz2tORe/&OGaT!WT}<G"3**$x1[-caK[??8WMsY&*eV22|O[.Y&ta!0q[X5cr~=,<}C>KVV <A`7333'Yp{NJ.Y:|/h;8E}x s?EsC+~Y"_AVjoU3c)GsL}"9C22GoMr#$k>'Xs7ml~>6+h:|=bn^`7/cMuO+P%(K/vUdgNeF6f'sF}miw~^3O<z~(oPpyOaD~B*n\;[w8z2k7zLs/RwlIigx(Wg' r'^G3-12a?ST*4/sz
+WO/qB?a|xc%	"s-W;Hg}.9l2cNr;+_	wXQX?ENC!gOc2;Fu.vyETs Q/nP	ub	fc[9*Gc6`uhebl2+g8\]<63%uo_k|cDU?b>Df16bAzf!^>xq>QD. ]o~ylu5ltmvW!b3fw0_C?4
+^vx<XFeR>[ncf).K@{~\<:y9F=~7xrbO7MB2Ve~`1+?D= sE#{Xy-%_L|vseqs$>B\J\=(e}lp.JdoL2L9}f[}wkrk]v_jkRo>\ZVdT=|L9Gz%N[9fXr6~/whq|+L=#	YwqUY3ZpyV,!YcPlnf12vD0$C&]G",X:5wBeMLgqa`h\4-5d;V28t}{~{|?<E>h	s}>l2P
+t(o?[oo4LLr@
+"lWm5+!+'Fi*ba~sms>D2OaphmWMa^?jI~x}d|f1[2oM;V];wk|C/t]Ctnx[|A|Qnjc	HL;/vk91S^M mJ-~u'1WOzumznqe."Aaq=DV!@XICx5tvg*9wO}?zjLA;;U#a%DhlYs~Tc2^fDS^)/0^d>;f4LWRJr\
+~0s-1{GCeo^oZ_#{\5&IOm~I3N=}ae-P~ l]*2WKGnqP0/Ul8;!Qm(j?sG"2^;6w+6ySt]N:MgDwn6*c*Fh=FLDr*~t_C.0/O sj0T<[l0)y3u)"w&
+Zmc_DEH	$`s!}]*^~C=-:Qi]nq	5LGV\Nc-%oW<	_MZTg)>'9+yl>lIYecwT<^|>|5-"MN?$lov+e[T]:_= 'pw(RZ~C{oa;hS}rnlmI<1Wu@[;ba-:p_MS\;,C_n:.U2/?C{tdoH@O9,dCZtr-
+K0Lr#qY=|5L=EYDz\dVEO||xM&Q:<H3Ftp=@^2JNcWB~1nk}k%
+:Gxg0>>>?1QS<3~cWo5IN(ykqWE57;1~gJ43zG\rr7@6uIH?z'UzG0<Nlp+bs!la^5$xcV-a?NQ?UfX;hf]N>sm>pYywP=~[pzss>0vo-0m%-:!_>>5W
+rq}$k9L2#V28Ob][L]$qE\wlq"OrYC.8>&B2O[2u=Q'yMU*6@s2>wIB=WCOAtfl@[c',}K;9CiIex72`;}EC_{&:`dV}:>{1V=X93`9C4|p^D_5k} lYk.th"<[i)=l[&P49R<17o
+^um7;|jV?v9~qO*EEl? bpmn+nCt{s>{^y'P%>C64qoWEqgGo%Z5gb{f_f|y7L]W<5	BO<?;3*kN{Z%N=Q9e}J'~3-lCeZJV3A[W|_=^u_4W~?<K;O5)];P@wM;@CZ#<s%z<8d;0NV+nN7f8>(_N<M,ScWD`<<?j2'_ O^eHOjeXE~t>^FoF9+GF#vfm=e$ 	W;1<Ns;L<}~Fsu5=Q/Wh=BwfOIHX+X/f	^+wz,uSb9m@B\7ox	Z5xso>u]jO&Sg	[p.'Xg^UsM8W	g?={du%[-F|qsSnE'I|Ts%OM6=XR_F34VP9OOJMPy,1k {;?GgWn&<x'M`	:^x-lrpgP(_9QN0B/a.3\_{B@[GjnA:xm|-KjzM|3OoEH7H`@*`#3NR?{Nx[VQvDAm=F-[I_&?uo=gw%}{z;swnC}(kop2QBQlDEU*bn6D>d&x.N9[^&q(lt||kL+;U[Dz8zs7_fu~/nP<76GxnW<oV6{RBedxr0>_Sik7;e$;ot%Du6JmjP:;Uuz>W'z_/|0:EJOdk\dtymzlnkqrv.^v|]p#ij>]C*h]=[W[CsZ.oN"k5PJ\3yL0cIFf`e9@@	,W[Dmu}5:ty_<ScGl(~x{8'w07.9^A{yXPvIFvw rxH\1Y]%W-[1CC769HWau#f+T]FEHB\_9zj%-NaF-'F!-!GX{FQld]tuw~!'#krWn!?@?-iU,7_LmP_+Nejt,Z}V{dw qHln*=g,JN(ny)-#}lk|)-_kKHIJXu$UN_g)n,~c5~ >7V ~
+ig+}C.@R?8>>E3|I3oGrElq{Z)p8=<YBRKJ7mSkMvKD^p.6$vbF<dIK_DgVM#rn_zyj]skoG#XodM'j>6d^_=v:	zFpER>aw4:jdP]REOLYkZhk_7~"]dEo]d"oq3uzUPvr9slI!O_U|F+W|x?gY!OccZcI.p}l}8cS1\h?9hlvi+>RW{Y_<Q~r)n&&3F+R>)~T|oo!XYEmiN.l-H={~gs@yJ9(<-<+z2z0FHgDg:__JOI4g=kYGOfz6BO+==gt6I.z:<EAzYz]n6r+HBxLvuW^>=?_;s{ct"@Bs)BN~[?r:'O)?[855:%'$/9::xoRhR'n`;/f8pPA4pq	Az0v] }v&'d>7:w>P##_XU{h{~AN,^2A/qmDK=CO"	&<AwO_C_d!hm}@C?CCG
+@zZ<22
+T<GIF=ZeQ<Z>?8=OpG=V{~znpwmw8ll,>bX3}ky(	;uY+N!W@x%|mQ/;p#(|8Fu"
+o^-O@'yW^G:C''MySA;0Ozv?`wdg'oqK.bqm6"3|hK?kof"8G
+(6+rq/c1QWb_Tw)_%GRw)'oGWKDwH)[))}^iKG\%k[%#^r>;I:C!}e{>/G'#9^]ZorGz
+nbIsga9?Ay7	_o	A
+d08g\	f{8wEUdxkcajEy7}vBD,]p&u\yz?l7V/^/=f(|r:f(7x(t--#Yx{h17ghQMzCDv0x-A'^5exYqo`zf0`Rcr0ZfanV6i1*LcXE~4rm!epVDw}0B/ZfS_"k>2O1}0a~eb0Y["`c.9+lf_(~(e]]5_[#>q1|Gjm=t`;j/~=j%`w7tlA4"Al!hnmj><MB yqwA8
+Sb7wfimgfnf	w|;wfv1SfUEG}3Te33Rc_:H8DS>y}]F XF22gb)?tvW]Mc=obc}uv	}N_4u'=)h=-?gh5]ol%5ri#A33>CZb#v7EEC^I90AF"w1V4Rf0%{O 1{2z5ECRXBgB#
+1"]{e^
+D/-N:*<,Wj,{,^rKhLzr}eyWgeU}neBm9>xyNgbB>@>3/5i8#	<](W[n]s"&k0qwb~G}DWgk[v}Ol(7-bSK7
+_<uv=uu7b9gl<uL=sKL<O%gbo+)(k>~s/cl(:mlSM??	v\k:em"mk$zAgCBZ&g}n?OF
+:-[p%<Y\x O3L0;<Wx~-wPx%Hx8gs,L[ oz.'gxxs=? TgY
+< gA?<w@6#UY3^>%/Vg xB!WE{xQaT^*t o@?
+<kVa?%7G0UwFEku\bLJG*RKc:hq<]d4*0/1(g;Fo\;r}Y)U2f+U
+}X
+?WcUR2XJw]K*!|Vp?Pe?GB?U>hU7C-gE#5}YW}e_.}?VP_Wg3~<'sxm=r=9)K<IbmvT{Dlw6~+kq
+VcsWesYT~{[UtT*]r |2nbOR=[\]j{~(;X>}+sUZ/Ggc;eX	3a}lFjLcu9#l9`T,0/ot\'-aK}1.AXKy.k`i*`f/_n<fql"G}oKzPVs5>"=f6Ke=U-ro
+WDd9'W-xE(^G/%& S!G]E%s"lao
+=>.cFwLwo]o9]#lyF6GgIM}T6`>Q:\M>s&m,(gqU-,oJ^#R}N>W9Ao	j--yx*}\H?x*!_zb
+:iz]BU=f,	^?SW$e.^Tw#oPHk^	K?Q8VUC.>f]?fh<GCy.B yh/?i$c.{ipAmyRX)o[TjD66m<R_Hp>*cR8,o
+6poS^,R}9mHy
+6CR~*`yx"Tkm?6pcs<6J
+6p^6pc6pz`= S8*-Xb-wjAi?jl;M=MScGdzduV&!g%#x~gg@\<<]<p}Go<W#4ps,r.,WX8100x]iq`zbmXj,0XEaXaXhZ`W.,+,_r.w0]+Eb&>'I*EKZ6)?qom23	=M[>+G2V5 Z';<{k$|_G<<NS{IC'I[9}^%MTeb>wD,&1_/?1XhQDy~/xgLY{n +<9?hZkUs(ZehAs~CoA+7Eq1,7{h{A+:4b\q]vx.cxOqsD6tXH\+?B!IgX_9+|'EUth'"jfP}I{b#s/u"PND~}?vv/10oR>-T_
+r*y^y#TJuF!Z}W_<0<s&|X/=XM4r=?gz;[q>X._8pns1co\+L_U%Or[F<Z}hoS}8w)~,8sog+ieR~cq?uUU9,9s2PsJO8XsNL @*;oue22dyU`yY_Fj(6,*lYUVsS5-Ogxf3_3$5XNkQlpfl4A}rkjW4'2}Vm7[-q;,ImM{|hz.Wvu:Ch>)|>k!3hEab}8v
+<&1fi|/VG)>yjPDGu1MalUkdBnE#K^b'o9eE[MH_>]G	n'V]VXq~47$38^ +Qi|dcN36Xbw6>68xO1(
+8\=VB=)k\`y8a|ukCHYQ^2mw{w'}\o7<FjI[U}|xo|W)k	8I2x2s?3sQel?oBjP:o>Sehx(v
+imC{eg^I;?yb0S72<kH!GzHA Z}iwF'[Ho"A{HGu~
+#H!=g HHs^B.EJ@kb)_bh>\;pJ\pyc/qMJ={.OR]SM,-7^^7}^t\)a^EAoSf z1g<+v0E8G0Oy.$u`#Nb7i|^2/,?~gxW}A-e<%3+6v>]9W><.S!xb~:$oc?0H~rZ3jrw8ptuwL?kt4UW(@S|(1GyS,BW%rm:AD[lvyci1.FGwKujl')YedyVEeB>Wuud+,\`AWF`m{Zl,zUcW~U,g<\E;:)#{,[js*wkU[=x__QXLNV\SV8H\vS9Fury	g1'g:pF+U}=|gw.<gTa2]~6<`_m'd-B;-^sA)6!wP-`[=l:aAz9qe_|7qWHxT-8A]D%Bi'O@Q~Qv_vO1~e]j;{!X+uE]1n;
+=^L|1.ixy@2Wf"t@}}NyH[mUM[leruA:g=VMyaj0.1.e0j#xGA/~:`48"V'E< .7<#zv1irS')ZG(Eg+{:alRy0nO7Z:~LCb]n]ug)}o(k>+y^o;^]Q48=$]	CXc)dW4i`QyW,H2*><)O;Pkug&rKV7q?OR}mh%6[}q\OX*\s#v_8^;?h+;(_<lZCgz=Bq#m<7%|OV/)"}j<lQ?N5)XZF?~~{0GU3#J7Z6um;^zh/\NR8e>>'wa3E9E;v	`,a,5DNj7$	`+3T;cR_1;}k563 |w:95tBkJzWqLah`+rh(.Fq|MS3/>l>5qXM4/eZ<$;Lx39F.GGYy_d2`$)"QSEb+]kDmG(;Pz%qw])T//	ZU$|;H_<^kCcv&lKQchWb<*jRfe>1^tHD-X!j*NOEa{#'$\nEmRV:f$1S=GQe{2-PgPq,\YIe?{fe([6-legD?Kj	g|(" &5wC>y3?_<Ync8"~Jfv};&?ul_Q6YJi<8I}R'.}K2IL@}wWN}/.w[N}W>%{OKi$;?{d}[j62`&VE}oeT$Ge~wdT<,l_<5CU~S~O)oveWG<ysFN#yq{l9=O?DIO/fNY<,~.)tgax="f	l| ]R,/dD#/`y'KqIWdswp4ojZf+dZ)el/dGA avq9#PFo*79w=j03[M!x}gu_0w5>T*Iv;_d5+SqMU`4y197>(sYJM#[y+ON>zTRvq3wuXTW2ngaVL]`gu{	<?q$xc{ gZ|2.T![9nSyv?>~%q~Gy
+q.z9-K+qt`EU[N'-l2VP& 7'AxhV*e?Gfe:c-/`8<x6y( /6yiKG^yA{e)3mEBfr<Bnk!&$d"D\S#	6M 6
+98O~Z\P3\p~n>.,~vLEc]yd}".+^Lar%a~KoUXB?eCgH*~ik&Ls9&URs
+2wH\R'nBr+S<mc
+[U;w]8A8ELc7ZkPNszyp>\.Rrgi3s848y\<X<\`i\gM"xqPYQg>~:C ~/IiWv]5%N8tIkR6B(3
+s7*6xEtB/I6/eAZ;_,u9#926'lskms(ls	sHE6o#^435dk^H)y}{Xfa4QfTz[f9VN);>O~w`Zghm8x\sL/u7x:ynV}wGkj:'o&{^E
+Jj=|^j1-
+cOqkoDn6L!53uC}W;up(O\|qOi3,<If;=XQxOrFk~ s'5wV-f=bT/<Iod83h7\sUgkL{gqtIAkk]Gl>9V^E8	yEp'UTOrPs)\F!3AVYwsY{V1 )wU8Ggf5<<!X<8g>}ZS:Hb1>q$gbbJ)K,&eV(NV~	Ury2_{xO={gT>|z'0
+q9GReIKsKMH.}Ja.
+.-O6:3\B37R
+s[r{WKIRl.W4Kl.a&^sK?*Qs&.=KR0FRs\\ZK?sgsi;Kbw>3.zLp1;}`3r_$bN=.8(2J&gvy"4'i$[pmD6-X ^`;kU0X'J SgN85e3ZJBG4!WT?1_:=gM7_uV6VV]PK//7ZWk1es]J2^3w,'E7v]AHQ8u|^,I}-Un4[mLg1m8)szh)RZ)F7_5wy[{I"s)| yc>t|`9-Q0j']?an[/k5.Gh* d3Nn|e/AVouMVdU:-t
+b_@,YMcEU[WC_vo;L1t1!5tq=;xYq9K^}8|^Z~dIGj)uIpagQ(/%G,m[L*n:7k9|	e	8-S)r}Zo*K d3|~yLZyp[kxc1XBFy<]fs?d7=\usw3U{;dBNNK"}3j]+fjtlw&G6="^/Gc=!.s,(
+?u#|[pAnevxg8[E,oM63===+?:(0GLdsW~Ff=lB._>N)T'Z[2dP^WpOnG%cnFOH._J/7gah'//EF2rlmhR)h'4_AsXuE^y)R3d[3l{{X=JKs]ej*u6ciL_ (5vr<ZKsAuGm:8|o,FEMN3%'{mt5d~~]l.?f>NI]Y:H'z@rqZ]]@	]?-t)u'\]@y }KRBuKaftGtG.I]PDdosLdYu:g~4:Jz~w}I%ju683#(?%M0lC.'Qb'J}
+=@K!DMO|SEGu(g'Xbn4)IWl!+.qdtEt.7eMWFjJp]R	d?9;:(*sS <kb]#1ZEcU<;+"	,?&5!6B}k?I9O
+(0OtcA%HX@_Hn/OWid=V@>xWSQEa#5UEVu|Q~Wdps][)^T!]HcenY@nl7<4%%1Scz6~: s`_$[U4j;7/4}-^NT-k[z[Zh~pNeK%,$h,hphx(y,E~m"mcX/V/C}Cs!*EJ3#w
+NK[gO-F>.2k6#`:*?JG2".00r8Kj(_:A<T{|w!8k0[A01n\;- g"~r/g^mt8AOb}=Q};Gpr EzSx*rbu&{gd1yNb$cj`H&{_]&_Lv%F2y9qLE'\&l*OL`N,{1yaV3?6Ggrt(_2y@~&_1 |`~&?<kq?	%pd$?2>|u9![$'>2mGFc`:w3KVK4_oaMc`~`JN'J^xm0-f8:|b7\l+%I8<.^b-_q./S1plaWNof337|bT~F~|J0@~F[#'FrYZrd8?'%'{f4hpg5p'ooiZi!dipK#
+_KeK;lFrYicigaF*,:$Xz,pF,!L@Ks}}`)z.vWUu#g_:?a_cIX&Z'Ys`OJHIf>[CS?3?$d}C1K>|6<]yZK"y:vQ%xZ>9!'Xk<uEHpY
+P6 "VNQ{|5(aW{5[%[52'Wsj'IUooT1{x&IRq#$|868W*0S|O5y\~OQ~stq.6c$nb?p>!"Vv3wGcl!68RL\G|G0H}eG#'/EG^C
+?{-iU5Lcv(@:~[d%,D{ >[><sgXS]zV/kOpNIHE>tn$b1Oz'l=hh%
+nS'/I}C58G4ys/9:~P}CA|R	.K|V-/]2u:I?G;7~G<e23AO:f&&G~yqRfcJ2|.wjhQ=:=)az%:=cfsz{%eqVvQUYGBtLDJGXR22Ca?B-FAH.NXwJFwyA'!$$u~I@H{w}/U|~En74Z+oK57cm{{x[ohn~HnhaR=%m66qxI>0RUFm7I{2-mH9J^9ew&7z7r>YYA"
+<z%}x~'ls2|^]W,a%c8phh6`\PC'k7N=Xcpy/7^?fIOqXz&{<$q{2|Qxppcoem3#{kmU8bC`)[6.'o91	^X[xO@meMs#!r&\o~@U(fC	k Y!X|(Q<Fuf/ 8)o\tq?<y.1ov<8sTm]y
+|t=9A? \O]Il]gmD9Q>Zer;}=Oc'"x`S Rq_c{%7YX|I<{ ]gRuu{5=>{ 'SIT:;]S{Y{T!K'Q|v-U^WW$6"c*yS'*`^622>Um:3B?.zSy=J>#p9]{R7lX|rT}UMG.|_`WB)[7vR]j!3eQ|^&(~wa>c8;W%vmyy|N}JGb}/?3_YW:m"Ya0=m*c~{{P>|j>Kvy>4N@`oeze/:,6
+{zdk=Ux">H:6b;K H6Sy"S^>%~\r/}.
+KB_|OrqcNIn}|T`?&}y>O_?gU{.jgll<+
+g:	MxpgkrYY
+6).)xC(]ZlYl<RpuuBP<k O8lp&u@6y<<{\<I#8.rxvcg%g?<~k\slx5)Y,qu);*O~n3vKg;Ql:`xo	-b[Bs4mkl\Yk?~54\ ;m6nm7d['/k[dpCE6;u+\}Jc9pkpl\:FsZIabXNc/jO`}soWg5T~i+*	=Kc4
+|%FFHs&|]TUY<sD|HnqiK"11e`OAiQn!wdu6J<+HW0u<:5l]-j[,Wxc4ZR&XZF'O<?L~'yLLseRc8(}B^IgM-o'=a}=Zk\asJG>J>.l_;Scz9fF36G)?7s/}U^9rhu
+u>:$J}GsuVJn?srR>#/hvVhTI9r"3U?k-.:/]tN8rYkM&YHk\4+]4u4txHhThl|Wcw;KoFF5nCkw<oc9SgiWv*;2Veq4C>~j`S{_Ga|OY;o KinBx!A9%F^YvuP)Oo0!]isU*WCl&= 1y' ks9|8t`T.G$c~*{
+%7>yDR#wo{fu\:~/
+<RdWFe-]s|-;/^wudlpEW+tpz*S'4:u>SaE>R 91y;i9.N2stTlq@h~M-6.Z8}}Z\&	V-s-LO
+7m`3`FQBE/(.zgf]yREosb[GRM~ ]^v-|>z<c[khlC\`y_9x\'D?u^4lx^mM=Svu:k;gm"\:.(t.:;(:_n<5Nhp?RXzU}CE^J5<9<yjWc|:]>`;9x)]7SWxY._Y+ufL?
+-Sof}|RU~9H{(v#XD9T6t	ebC(S+erhZzzi?|V{,/Ub4X-,_/%},PzGg*zW5=Z=FR_xQ{Do8D;'Z3b>]E)64Siv=#>xVY	}@zR_t@}{d =fgnmg|){y:|}Uo@jyGP[=}|47JvtkuGMv".{;6tN7z1$x7TW_mW3|PQU7I=]O%Y:;jdz6:U6x__yp yrUNe|3+$r.aY/F/^}ks}m~q*+&F:nZeh!/4
+<ymN} u`^cD1Vf=d+y?}77],rRo~S	4LH.?t'n_zu>MNn;E	CR|9{9K_9n=aW#'Zi8.Q5=nmb8O4zCt@j_=~uNC6R~6sgb7S=5tx=|*[%(#Kx)S>wyo?6=m%^!n}qcg7[;0/9xi<e #`av;fWn#2rw1r?iz}(g
+{8*y
+zI<]y6P<R<-o>*`7|7
+]M	/-a-X|Vvv|>%Fu#Z 6y?X&?kMW)-ykd3V~#76[v[NTW{hvm!6^pE]ENtu13<5IeG}x:A| ?&3!b^y	8RXgT
+m@8eY<z8d/kMfk"5$ *^eFsxaN2OX<;xpb_l%
+qT}Yx'6^jO`>g#Q^&s^tz_'(glXGu`d^Le2&9&rsPf]\p]x+c9]-.q\P~7X} ;*3M]$fOwGS;"&VE_mEq FS9~<0@6@)f
+Bop/%I+"8%vl;>Y<8>dqczy>(&Xg9z'=ZAZ+A.(`OyK45W`?ZS~SL4?z9/wFKfN^*'Mw[QA#<#xC`	YM/uWH'Z
+Bx!A2!Vod[dR2F2klb}&?tm_~4L9-|:[Nv;/Saz3SdEP=cy0Swvv	a#4S%\yM~ly{Ynr3"-K#"/N/ D
+2!Lory!2`"g/,2_?t'c5k<1@{,nmGj5OE?j^:AaC}ad3l	6'#wbbVx;oP[c;zEmxj v'OhyUWd }R&`l+g5Q\B1!c}@x-_l=>}	l|uL5j}.+|3l'vbYwDn4q7l|wK
+$kUCPWhz
+h>y6q$|I ]">lz0F<D<bOu`-suZ7}N?e0qEKQ7ZO:3{MOA*7Wt3kSqi[nn:2V{+il.8c9uDZ<]fL5Hlu'K:amkTO|	po%]gxO75)b 3\mhnnQ/9~qKS~4d5tL5!@c|njOmuCGq'>Gcr{ACeZ=jO?Zj:}vW{:MrQZV|
+ob,}
+^,m[|6rayX_?W+25#^VcOs789fWv|Mm|e8,QG.<#>IIwcXCX])zE`N1$U-|Y3f}":&OV{Ui'x"j6z|UZC[8?{Uu_&d&sjtS Pv-u+920	5 Y%f<1XFB]B%c-Zs}H5|{~+q<oYC;NeoZ'k0o+whk<>*t8Aq6H;;|vVk{z.iqm^+&o@KsoB|{/J }Uc1;~:225bE3:Gd(@AU06*SmjOEZ5]b,O2)u{qi%XRw7P.5}{)iB^%lB#7u/0XoGGMVA>}Xz{g@wfy2xoweiv\7EJ:u}nzBM{f9sgX-?-T
+z1V-0o*i0u/*_FdPm*+w|hU|Cr}ht$_%'|UgzDat_gZ Igc{oQ{gWWq{O|}$Qb,	} t7/4)?XK_RDSI@y,-WY-GW&!2vMhhW4)Sv>8;Q%;0dMq4}8W^HQ~o}Y4Wum:lRvmLyCrT{ok&zT9!U9BAeb]-iPOOy^Qr5F;(W}?ho\lfwmmm76l7I!RY+0.>7`wW}/>]5w,}'/YqZX0aRwM!k2|!'@E}MW8Ui~hV(} mIZ.`{o]wnu%}_\>[>rsM?e;&wS~|P}po5>e/--7s}n}#?I$6p~!NcHIT}EPg	H zp6"UuTgh98jKjY7azk=s{mf1FoFc9kcXX#1
+t?Tg
+}Sfuek:~m [jgnf{O~`h{Aq?VaNk R\w =6i2fYXOj{|l|%%fSHJ]b)^S#KKCFVC;wDkP<imR"W}xoQ3a<i)c>0S2Z6v6]!2FgE,V^@W`}{;Orb\ycMNLq"Cqe=T8brLHb*[rE]Nh6W#;wo\e.pFg+c+^>!6aOO>6<mr}"o8=~y5y?gUp#VY=W8	~~~o$m+,JIi6bm1L:1{XJ.J$\7,{;?jQh<<#t6ZoiUYFi[ccI!!S0P5
+Iu;e=%b&{ycZM(//cwkJ|kY"jw:S..u:z;yef 21q,Sy&K6)F)5_e=V,+J@ |$losjP{9xQN]Q;Pgga 	xx;Uv*R8s^)pK2b*cgq_{v/{jYo~`9Srd]s,SNX"eb~K~>uCs%1SuX 1>(_	|vD=06823,7f-QAwO6hu.7x(O ?y'q?=oqz{{*[MI]`MCo)RyzE2lBGHp,c uGn*=-b{UNNG]F=%7}M~+g!]2 &{?R//c6?]vgzZ,18;:touf p:SNkO|V){irA+/SsssH>A#v^$}=fyW_fEx:4/U4%I4R4.I++)inS4I>nE$?rxihJ5^Is9{h>hhT4%zeNhoP=SRT'$.P}h_hg$|oA\3?J<n0[/9}e	@X n|@!(J :Voer]@||]dP7EIk}SZDPm#obdeLO-~sLM#x_pz*ak#t_ImCR 1 SmJW]dWdH`sr73e4J%}(TtOOFM~%6}+U,ynKveL6NvU}Sn mr!T#<Kj8inU4V4Jy`iS4('LR4$<=F93hNR4*t]?Fx8iOUWOV/?x>H(z1HUCE_^izWYb~a<Oc^xWK:%Y 7+6KMgRwxO<-ev%y%p)rSW }rSN>)Y;6.tl)\.nv"	fduL9YFA/SB)+F)ZvG>n\ymf@^'l2I|BC[Q* S ~t@%`&   5`L3k\X
+h 4 K/@+`#``3^}G:F=624cD2D~"s>dz6>LW! #ez&[>f0]&"2=Hg6LOAq<Lez2Hdg!r.x.CL"=e+3-Wx.U_\\?_=3F[=AzfLT6p>p<x6p	p .	\\	\< <x2
+`?x:p9p%pLR f&an6]A?f5~"<w,sae	,Qe<{xvy)~oH"a|!l?lka67jas'lnZu^;{<zIT{K &V-mN\;Mmv@p
+ ejj@+o  mq]ggg@CClxi<_	> \L  JO wf < x0,<Xx let7$3:v<socM~GZ$B;]HWvZM/[|Sql|]FlD\?O}g_~~{:M/3K?t&q~6P3h7W?Wwt<oueoSV9ykD|<:gyf<fqYuyfM-YkFw]<3{qBGMd:4/{	h;_ zL@:&=hwKJbK!-;
+?wy]ol1	~iSDm1gZ$ja;#V6i!gsOM<=T|_g|5TVe}*ensdY5:"c]]%ES~ka(M!x^$c2F6T{	3Rb"n3W+T1ni]EsMj#s2{|6]ui3H2o;+=gyx1:)}OY.wB{7=A1X&9m<K;43"NqZ}mko_aOf3/`K$nm%41->ir/Mvf{vZ~O|w+Fl>\=	?m6tX{d1VlHAO)&<yMq7Z~!L6/30l1Y4U[>?[CX$9'%-fP=x"mu+T8yU2M<$}(>; 55I<'lc#?F;oZoON0H[:U[R>CNy'&O*g[&GN8UYV?=@9(g`_9_RB|]rs)UTr.9 8a3CccKk/T"[9(Di,ucFL=CzgwxC.?!e3[knv+^k{7Fo|b<K&?s $=5Ko<[K=UmijO	wy'w^|b
+t7/>O/`<}77}}DVN[TlnUyPyi[IOQ"V&,E`<` yC(m<kUsj+O;e!_byC'3#Ucm}fN`$Q4H@EB$ 6dL&|xiRR2hVjZ{XQEk[VT$0I{a3^k>v<3*4h}HCMF><-6Lg=\n-E5p}ndQ75}z*CaA[U+3mzQKZ&(v@J=Z4k9iONU2xqnew3ms9	yre`a_`T o;-D
+g=vrGsMOYx+J{]>jle$Rv]sxkzxoy	M-l!lZL[yN]s=lHLTH]jS| XvBR{mpwF|'W_=={Vg;7\edC#qv
+Gkz@}Z'@`wwo[![.oXwPv]m
+/S?=DC @=gq;h\69A}#Su!rGY!hev/Ew<SiwNaW[7W]R*bhi1i,I`21	O\&~}<y z|G~ z3NO mJ/.#?{_6kr <D?0DCvJ],W1"4Rc\i4 )8Ng#KgxoU7uS\67[6&S@X;kTy(lx32;RIxxs)liy^g=s}{; 1|wQ,{Oe<MUrH	=*]O}<-yCC{)Bi!p/|koK\mg=mG=\D]S};u5ZOIL65z#xW-1010{[0K*xuOq[$e8!|\'p5Wm}[/^fxF6XPo{il	^]vrP[<O9(q_Pzhfh}d5?G{^imv z2X9*zD^:D	DsUl=|NY;7ke/[<OS?+'*f{J CxCHF-^vqKY1V=I
+^1h+=Wyw!jW)?`jte)1S3li6ei1^IQ#HdM8+aN?"<\APAU+_opr_.~I A[A"|CBFOWAlFWjD:Kx#!")44(}
+GN|ge{gEX=ML}r8)<Yt"JM{H4/:dd<Ks=Y.{~txs-d?g+lyO]9lcm<w{9?,,3Ml<
+5T>\(D}C9aY8J,fzM/G_CHn|~|%sm{scCtgD+!j5J'Sso=[w]kZpc}_v6a1tgx?q[nQ9/-[|AQ[LOd ;2M S_U[k->|W7y)T(=~=?}x3En4wQ*i|YUrco$_H'~5h4ytGEV=s6N[)-Qf|O:{E4
+sZZkp9
+w"_4.Jb,	y
+iX7ldu:onFu8+	9xt}Cdw4c4D5nXeX7zyuap<o]ua;s"uFx) BWANOdDkbfq-
+Q}3D%Xq&yAX{[=%|-mBWs2qfhK4~m9[`ItoZg}  rMf)6`o}-se{Toj7c|MDt\rq(ahM^BesRazNy:b_-G=a6BGy_Oc>f"PZmY!4=miTQ<3[RCULr[Dif(`!#z;FyFk[or9ZyBiGtye6w<:;)O[U3N+!id9)^* g)#XCk ,>iL;<?<7> 9=sunV(:"GMy@wl3
+3Oe'<Tgs]2Rk~>@*fB`rC>D0~~aB>*G!KtavVE8a0WGWGsWm@I7yxXix<#K{2+Zo@?d^}L;xkkm&x1+l+#m|PvYpeZ3f<`54ryoyv|v6\[;~<h(_I 7`2LM	DEa4#("ztAJmO,ow\Ax".	'{u>dm(e|PVy_){y
+%{<bKLGl?R#X{iO3&K.NcC:;Y&:eF|q-+M1=_,g	xD4h46@yK3w^0zg<.=7?gQCR<C##iEZL[G6fXtcwOq%j.?s9*t/MyYz]Fy{oLRykoUg}?9t<+ly*o2{5,9?IqoU-e*
+>gD#q'~z)1%T<8WK
+"HN/8$^B]SB/<)x\h::Cliu3+:bX4~><FS#WmP?2.}c?,+i6<\>
+>M(hc0hcl`)zU;I^'tPl3;LUgOugYO&vW6&_2GS2m;[-}ch~ ~vr0,-b}d}KrO~
+{ut/wu	#/-K'lSjCI'mPck=oL	U7U?2YU\U'33^Hs/|=yr0xwfsg5	zI&#_8-9KMjvk9 qfFda(,.:S3S?? G]?)8
+^!I]4ICyM<lyJ(wL[\cG+myN#tW]x.oOw-wd{K[Bhl^z&f?x)<U[*OwO[?T^_Z"`;=~MQ{mZ 
+*?E(krXKi}RYYxMOWm%6]kv@xO[kQ2i^={c2@Q#ujxm-MGS/^WL5.xXQu~i7*	z3u	xI#\Ku^26G]aA}.hK<mM/[d`8nRyOw|?C|mr <'xa>xO/Ch}<<UwkEffTtX.]YG@n@`xk>2"xt7n8)vmQM't7v{TTyF(Gg_"uHRcOw,]"kL1QE5N=y}mZw6X{KSQj=Qs7WXo s:_vB` sfQ>:c=Y.*w,|V~@>?j\u>eQ +M%RUtQAAoQ{qi7wAt'%olf3QU'mpQy:o9n4:}n~;.SF-[{$J#wpfR4y:!!
+=tsET77D=FkyOfD,%G|3Fa{"ox+gOl;+9kkEUOXm=Uc8gH2G-`8_dng_a>#w^uv*f{+??{<_p;NNuMiH#kFaPg3n',/[RA^5#{2N/PE2oxG][+	jX$ W+esu@a?~NS|]>u_>>V>F5+,uG_F{eOCk"=Fq>u6U}"v
+oF?pdu]aW0w8z{?0h<BS1r 5adH843${mqGqU|^~(~>XKZOl;{x"I'o}Ts{kRn(>#6Ku'H:eOanq!|8pYa:	\wyLkgJG\YFBNH}Hcxk`2GGVW	5NgJP,mF8M'!TQ}vv/y-GP\i|{GY`Z}55}g!Lb#:2AZ6aVUxfTbzCVoo-N-=pPZ.h^CD?L<6W&=>:kss!nqZ2~=.V?	 :(`J"&uf^Dgo0v>]$|`{P2g^|mlg|nOq{g9U!3MvNEZ	.9(!.aOEMLs,6zYR2W>Jn|Gq)uXmb=#:DHs,qy$d<4bZISj.jW=e8Bqnyv=VDy}Hx{xmoxCXG>wyde0Ui\s}~>m?X6aQL?LG1e^xc{J&aNDy]y|ogua=0'-h/:=4g5d4r)~2 w}X%&S12M	nR^3=0tp:e*8-)&BzR0AP|M:[40N*[}5uGSPpR^Z6YmPo5=6`07;Q v@pRs*./ld|]u?]U
+5?4 	g1u.yg5P^[uh.F=-l-;SS9g:Q^>=m[wH=Q?:$[*'=1 \-g
+Y	xxBx	iqWDAfh1P2^6WEVo:h4Cw<9*Ow_<,;~Gt`yNs:Iy;4!\}`s`,P	lKM7Zssr8%2~U7`srDkWcn|	g}P^/K[%VurM\uTk^	mVT})l
+[H|\6Vv&uw!@l~Ba?<y~w	lROk>~N*{N9_O$7A}_t7=a{(9`_#w}Jz096d=P[Rx?AW[Wo. y4m"NM&Sz	$mh'\qaUz3N*;.}%7dDe=_0
+O<Shj3Kr%psemlbB6E)?t..A.u;gBEEh!<j}xe7v0Z_YGZBl{C
+oa@=J1'n6LWjRPEM)A7z`vz!g!j'xBuUQ+|``o#7Bt
+loOewE}+Rq6>+LgorLpEc;K|MC4d{AZ4:}72mI2bn9h3
+oS`T@Y0WLawXWaKOS}L*7
+#_L|#Z
+g|4"s>1Gn!kNeX`(i5L^G:9@|@2!VtXwy\n$l#^ag2il4JsZN-*ZNxayFy1mL1mp.i+%NVt8YGp!V6u7.9YxSF~]\KX3NM@Qg7G6G]y`[/y1^%F$}z-\>nw.Pg;X=~37pOXRnd&	m'proSJWQM?%H!5
+o?+V2ZgKt6:45-2+)-41x>@4Gz/S?QZmalcD3mAAHGB`Z{)RDo {<P,$G7k4vw&w%!%gAn&7Xr'w&("7\!)$7|'q|%
+#h\;9].%YN;do&9Z`DJ4a~r@o18X`y[,YEByEo[dy[ m#kMqaduw81oU,os*h=m?y2ViLcs87YWN_K{S?hGt+;spa7%
+{./S9sv:?Eh7iHg527D]QwrD<7:a'0^kxJW)y)17>tQg6v4 :pN_k/gOJ4La5sCC4+B>%D<	8)Y:0sF$+N'Agu|J<dDK~=hNi,w<p{xXwW_VakaA^4VP{zl,}Zcahw9URoIH?W_!`S9`-el@2e8_,U*?hzeC	cOuO#oQ;ni#zB]?f|\XTcwDQk(L?X-GL7/+;EJf!|_1jtx^KsLd`,\-nw%3G(E66&<!#RyPk*%r!mak	"Tuq!M[mFm8n;'t%^5qcNu|$U:FN*r_k3	]9`'3c}",Xf?gExN`2QFZw38+&E#VuJ~1]1lO no_k'(~>cO}^6/5omeZ|ipLoBTQ\/JUHOKtn6}PPK:VvIcOoahr(8rT_R%*2L:^K8lPK+f_W;E[g8l~i]bk'9/y]w}U-7i)]4.hO}bwxBR}Gq_6E[_Hh==m<q&S`OKliM	ZVmBi{1=XO;{N5NeoEjBu:;{*E@7VL[+_;`mM=vkc62l{XDWZu6gr.+aACalc|f)N]Q|a+g0 Jyr2Kq!GNrw V{~Kmr)I{lN.%7?xVIk!i^B0hwJ^6k$lK;|KiI'OjFl?mf;Xw[9XQ4/tr?s4y#riSfp#?w?n2kBiXceN-zsVmZ6f`w	O!
+~RKpkz(cZw,2-j]2qV'x}i:qb7%m6GHVGV=p	f8*x{:9<~76N a>M*Y}.NZL\.>/,f3-,Kz/JD91v5#1v:)1ld]MQeSd7E VCBp&x>,	a[4l+0 0Esa)	F_mp}K=@)m'gk]u@>P_Oh/7D<Myp>XG@;3L_#[}yDW<r|m[?Og9>Yklbp4Povs7>m?d>H A#m3Z'=Uadl|hdl|C7g[Q*	@7(bHiS^|Lo,e}6q?Q5`w3(m_cQWK*2^|c4MG0N~{Ip3VI3C?h=iV<,[3!
+,_+nhMsH
+4gjbML~QypND7A={*w&Mmliz1N+-LPT!]M?=R]JH&"6Il#Er	1rp6|sU+X|nKzg(!ay>WEBM4WzP?O#8g?xJShP
+bRJsU8P9%byj*fJ?!nXc1u|R91Xh-z	l1q^6V2egLD*-xNxo2^/Vxw^PQ4/BYVoYyM=s<i+4_=\6yG+Zq3\td**O(,IzMM2'3.Zk#P/p*hq8(i	jL21qxmpE)R[\-/w-6ZRn	oXqV!g:7#>)a@
+.>"41M?t3w0!3|YaM!X(l%Ej]of'^[7`ut$O1T"1i=~Y056LPh}~w_5aY~cyk8[Wy?Mcu^vIvNZ]X;+p4[#Y"=L7yLu_&klVIm{Ten**U<)z{e8{S+	,	'Hw+{yxzELy2kv.P\/;bTzQMw`YB3y>|/G}[wlv!x.>uyGloDfsHun>[8&od-Z /dCHPQ0JkjFR($C<CJS<x&?SJqS
+Tg62/iSX/#cEW3R4h.b>^`TwgAc'@Wz ZnZ]oI~vIER-8e)}(Ik+h>]VHj3lqDwNm)m75+}pC_[:k^[Q~t }?D-?=onTy]Zz{mM| E]T*:maOQXy0.f)(Y;DwBaijn[-!
+/msq1^wWF])oUqnh$<;oQ3OM"J\yg+<7C+9a?taW^Q'
+KhzC5=^a9mh.,=8=HudK|e,[T}Q}hVg+2\T'vlQ2!QRPwz`Sz'v-6G @Qmx|&nbws{7	hi rSFiG88.[{,}(83:DRcitRWSS!{#~rM+x<n*lehE#;U;~}l?ys ATzXX7G@Ci74} 9#|
+NA~+lr%	BfKt_!*cn:0eb]\'ah-EI?v.gK9}qOa#Q!Y$VH[%q(%^ {dPjs3#eJB5F+jo[btLOx8~p&`Sj\G}:_vxz96k8:Q|j;u*e~o~TaUUC]g+rTz*le_yj`I{R2-g%7@M%%/F>S(TRh=KYo%ay.ul5Kz	Z uL86t]}IVDrKfxPk}(muCGY&a. ]\AF)	VK	Y~KWB~6L 19p?`bT){dyblE/c} xY@!mf|XeEh?:+to1.4/,s&[Yw{
+O)p_(	afUlOh={Bq\_/uD kDQp73h_G	7KxjYO)8^`W=YC'yi3LV|fP"	N|&O]^BEXoNJKB}qf0q~N&#cD"=	HMR4r$9foh	]%X5vm	=%Um|
+wg*Xq%}9&{ 5oIcsr?<&w`E?m3@)2
+;5A31l"fFv@`zAb`d&	ma1:+#}a/m[T(]m}c^w;ZR;:';ZD{G)|Fx71%rojL5:q-rMG WSD>51y"]ugJ`w4P;$J~OZ3<Ds){yHq)=hu'/Q]lXuS"'~wy
+:-oZT28qW(-czl?.F1i4?Pq{q3rK*>IEFCe[NFM&An,qoPI{;5_& 6wp<o|wHK_-J.Bh{ 8wy7FYXIj:p4V6rx\bgF=o!C)69](dp2]-0p<P_zG}Gq?q.xAU]q%cVWJ(TNURuS,QU!W (|9so{
+fK/W{\ibCC[XgFV'/FysP)yJ9wO-1cwQ4I+jR<UeqFWC5ZYq a}|JUV[\]G];UVPJh$G-TPj*|Uk[A5bHYVkkjka2N"KMLh5h_YYy
+%!UAMgk*#+UXx^bJ	!1q82bAc))?O.JOm<8J{bHe_,+([.-Q!yEC\1
+h\2$`[0f2xqykjkl"Xn`xqUP&r0eR;F#x=10TA6U=^iZT]_F#X7hFEuT1^j}u4UX(5U-}s1d`04Tv H*5wgUjbox3T/*PiQZL{N+<7'mF9/ujKk*W]WU)/f\jWWR!#o6TW
+_)K-b1VYy}SjjFUuU d[pCpQG'*JS`U/_MmuM_)#p._] *EHe6Y\CP`?BL5~_a~eE|*+Zr~DHR+;L}_U1QM>6u&W*F5sFu)QM4u52!4|}A*X&:Ab),AMHNum9<Y	yNJ
+,=*v*Jk$.%2}}!X5$eLQ[ )m]qbP:w+9K@ LZ,zkjWE	uXiuV#YxKJ4\'bR/Ue4j1Ut!B
+U'xI.DKF14w5 J_UKnu^[WU?gW#>41jiSEBBV# z1p4L q4Ap!Fio1\P&;k._k$i,qy_YX(lT<)S%A T7/lTYP)Tei7VAr=&G*#]JrrC%7u'w3q&drwA+|[H>r6Ln;9!rP	AnM#GAn3}JFbr$Sb&E{BFn6tQz	Or/
+}oXOB_x( _ii.z_AWq1!*hN\Km!7Q@wI>@1&SxT|!>.1YNiwR&D^3=L4[&kb*M,}\^M;2bXCz!~|S3)|bNf]<IC3Iy5E|0c_q"dO-.>^-V=3^#>.!<@\Z.>NHmx]"L!Q~wU+\qJS\loxjE_C:U9H=+g7+Y&njbO_W5u<,NB,<G+h_-i/IG\~V/5;~qgOvV/Yl]st{;?^2|)~c<+4dz|_O3[
+	ykl}C_5`ji{w/W]Z|y]A?j-~)'_to^_1L4z'uej
+K3CW}ndG;iy?OZp/TT	 6jXL@%6 >WQ/$J9F-htB29uQ{NDiu7#8jq#zPW/_OSN~h\WWOq~4{*vl}^_"BmG.W[g_h}0CJ	"WOTjMkyQl>`J~jJ_x>(`1k1	`&  K)wL-fS?/&+@ ]P$&#~f7mFU"!T&	IoYMI&|OM]L]I'')gB)	E&Sk5G;*XUV/(}TQvWw9"5n*o>~:f`=R$&& %V`qB*_! $f	0fO%3fi*H*A?|AH6KJ1-|#nu2"G#8XN^\zdLW]m2UZib&]EwZ4/WA!qY#-((82B!5Qk>&,(s}G)rv?M)G7G@}_v{,\^=/]q[/WmSY,:%fHj-;fLi-tRt].2Vt"C^7!KIcL2CL +.GyT,(&jP3	@6r+|tq*1
+5eZK;Jy=o"cxS!x'C|UgU:^}S	&V/md;6#$Rb,\#'S%G[@a+JeaUl-7g%a+ ?
+UMxMbV5*`d|a9^.z{.6WNXkV1hG3uq"nWra9*?Fu2fd(Ci]8.t|I;'a7=9&d 6&V\}uK"ULBKd=sbgBjk+T%lLi%`G,j[Os/to^{q{qg(29{qg+\pVe~^'ws/tN$q|^|88{q9s	Jw3
+zqm}qm}1B p+7`M#V#ne'rbAE9bA/P~" 9(+	+Q-g8+Nl4yQ6f
+QENlM?[C9N*PA[X}LWb_$w*8$j+U_J[*lcPa/T6nFN
+_Ewii8c8Vc8c~&+\T*fUSTlY
+jSW\H4H Uj(^{jJxBV_*KuPq]]dDP((2P#'r!&>5o<
+/rO	ldqi^'	-SO o4Ez]ERqWY7bQ6._Mo)_*_] aVF+c1H-K+<hR
+Xye7OTh<IAB9MjqEU%'JtKgU^kke#o<HNT;/~v2-#T2_x>TxNY"K7e.%R)S{7Bx+y7HK;Vxk	yo9!>he{
+o)-/XS	<B )wN3a$?+a<e]WjT7Rri}8O!U,ui<{x@]XTQ`yuAk_z.TV@ .rha,W5\zno>spEe1N\paUjKF|jq5.-.s1sC5hZGGXTM"rUW	y}3rBbVQ."bk+7ybD1h~nKPcZGhT-0w%%Zt#+^YSs!/Z<cQWY)kXDw6XKVr*$'mT2;P TVFj/)CTdl\;%*:+i#%E]GEIb=PFmyu%;1,kUo+"g(](ri"D,q8Qe~^5J);[|}W}b8 (*bq~DeP,,5XX).*/Eb|b8Q]--B1lT aDV-b8Q3Cr,>Q{ikWIR8n9+\bi/SuY(eX>)C$U\Pq%E35%KO(<Y^M[f- (M-5[Bx{oDOPGvI'5QCsR
+ip eM5fJB#w3|gdi
+XzrugD_T3Ov^n;kkzv7>SmN5izCa4:ui6gj\5O~
+H#\[\FG6FH|+qQ&CYM@'sL!>a$lOmIX9"@}	&	+IV$l\}KaI<I:7v&h>t-MM8ENAB]pr8>~!s2p<Y{dsXptP^rp]*<?YTWoD6<4N8gbteOjb5qX.T. HsaPOvs{osk_glys3'r
+%	[NeY"q?mX~$a	0t~xX}?'N>vM!(1<=V(w5q&*meq\v9o'w^(F,dyj0ci.0buKK:/ vE6y;SL{pj>Y[FD4I).HyIG?yS+*yss{:&xom/K/?4}Mjmbi{	uka"MaM|{CotD89CceS)9NqFt}.>]?[QQkJg@;[H-N=8iS':M#|g
+pks|mR[B>
+ec|B})wzV*qoXZ.gV/(_r7s%5n7BfmC{e"JymCqx#;>{w~"9OiQ{4>3ZhMk~f)M?9vNgUw3ElNo|S?C/}]/g<K ?Oea77[ool4~S?O{ ?>nY.B?ez2A'nD	-`b%Z4OaM{KEAZki8N79Ng?W^=H)zs%'S)u=CRS?y'\IK4{9?dC.JEPo}Wo~<FF=}}~t_x\Q<+!kWdz$_q-@_v Ktx9&]%4:sg\.B<wZ.i-zGoC#]ZMMn^g-rih'	$)IXU.iN$$I1xJ=(E.uWE\YqiT0ck.ae$pp^}cmq!}y6Id2-1]I	y'a^V4O6r:\`AJk1:6|*vRd;-EQH3XbiMoKb|- TugiLV)r&M,T1bRL'*!Ykbeo8.^-y2`p^f$Dsankka4vX\*+1rSQghD6`C['+c.ZN-8o&O9kh-}u[7H7Y`MgkJ+IrFG9MwS|+MWIMqHsE}M9_LLfn:du/7&owscqX>/IVq&>MqH_g6qMCai#(6$5@lu
+O1@`Z%K,duC7/^>c>tv|U^q3RLWOQ6ac,')/6bwc6Xxw]cbB6(\ROk,&5v=g9#u=/=zN~N>}9|9=w~N3=8v2 wE"u.Sg*9&m]\#3Igv.x.cx?'IuV0B#^^\Dx$RMnd
+;^ \D6k8 j\b(^}Rw#.>}>UoCM*2J3zNs5!)pAfZZF,JuUv7K<Ew~g'h!@;f)3w9qMskzGY\ _\Cm<V<mkDrEkLvZ*T_BA8i5KI-_U4:+]A &M$Mh9e'Hg^93u?\`[d\,$NI*_.'JC7r]inNIMTJq;Tqg08((9NIwiTMQ%j1 3hPAFMU[It~{o%2]7"wwLYDa+YYPe11bs S|:n@u]33N8	r:+\G@g#:wA|>qs/\>*;,pJ:pu|sp:?Nz Y#t :>Sl:.@gC0Ns :\l:c\'lg0DL?80mr`bY<,x,J"-H/mv?5U8w<SA-9m-j"mYELI6u>,;'$%9g,&fWV)fn>~rb[T*-Yd:+IKe"E~r\^Xhnmz1d{_\;gUu%aq[ip9T*VRO?JIp}-HEU+	[p	p!p3n|_Pk_#MLiiiiii#=ii3aK	\@!w rqx$
+<Q)E)YS`L ~\je"EkN<(TRB?;QfSG#]mrtuI;0cv2A|dmFpkq
+8VZ~<\_HKSx&IK.,(3(=rHHk]Mg7>b9pKf7NNp9lVpvj, \|k 0&gu[ebCX[F)KQ
+6/i	)fz>RTI.ClY)O}+aH^;uH,)[mUx#=L',"<;+R<pT&r8qYmt:I
+Ete|^s1m1dK<$_`uz{vWl6;"fl4i2	pp6n[<D4=3zfj\]S-+`63+	|gD8$\haWQ.y{upvAW}n%{=bv&_p-%k#V5fc|T,|Qpfe\=&}[O61yxg>~~0nV|3><3hcbx..YSWS#;IC;#FdK?{wq!}3\4r=WL_na5_5{]~?s>\$?.+jY,jksbV&(zU-xblZr	y7fzXj:^}k~Ls]fe
+r=}n}to[G6s7=\g/qP`o{7ou_?7}7|~0?o<4vqx6~Swdndjyqdnn.v=]:vm'pBZfH>Qp H}evR7-7=DQem30}ytd?<y<=qSF*v066mdlX_l<ny6}tl:sq&<nGo.5OnAqBl<_rw[WI_8q>suwu?m'zg#N_#svn?0~/ab3p~,p
+_yO	]}G>st+>s-tm+*R}\r6k4o0i7\-qup3?k;kN_~536_zSNzPfCw GW=?Ngj{.pv\BSGV?duMu=C#&l66gWxPp\J.nNM	8s8U>*H[6#>=#-#-#-b7/<nB!vbEynU60fb \T(<VJ*aRJ%ET=L=88:W#VoW3fXpkeMk{l17)(sT(~_R\nq}	}G[2c V\k#NX_^'rI/U~isB}{`6v;fyvsayv*VT`yRyJt()<{:VJ\<qgG0y |XaT=12Ptg-9\I
+uly>B;6q$	6ntmqfkVc\\TOg`mh{x_BE83p6o9{)UwruuKu
+H=}]6qyvD6,[U;&^un\%ecccm,:c[%9.i-:<}G\>utl6e@{^Xf]{{m*}.WJ./V\BE\HpnXIrW'Wpkws}c^/~ikdtt|}VrFeW[|8"Vey}L5axw <*gzj*zEUx9A*;3'yN)TmEe!Y@'l>s<mTUeXvP{JmgZ=Ipe4X[l4v8z7JuC|f>!pqswA	M+y.-< m]&yhiX<2N)mNlu.iG0f2i2}p/TY1}3vU1wXCF`x^>I2S$N1oHv=JamQ,[g1LJOxI 3&DwH<Wh\`l\9O7:A;C2;{zQ64`t6Q}Rq%| p?
+I "P/,y_vT_~|{ G o\2`:D>oh9}/~{#-q7tWJ}%@?OP9	55X nay_vwGWh44:lh#q@`p*~;7k#~9I547 ~; |XMS~E@,RC p.]o0 #H},e^#jhs-WoSO#-
+8-	
+YC[,=61
+Ax>h^H^[l{i.symc|k8q~0>0 c4g-w_]GUUOmp	0 *5`Dq	`0X.H]e>%9?lhpoP.~y?Y'g 0
+8n@>E+  E ;`T}E~gt]~Li2UO@+8rBr'/khc.I'/"7wT6qHZmpjz|Pg?Z W5a&3	'3qo{~f!=!C}478`0	8	C[t]:IW4W@7`ppW-  V FY2%7_'^qNrv7Myx;<oX z->2` h2-14'8t]cn#z3 ;"yppdA\..pQA<z0
+ 3U@nC ,V^>C^76<} ]Z6ohy$`>I X=&\ '>g3C;G|3'=u'y2zA	pO<$.g<H.r$KIVO2G&4/(Wr\r$;B$C$<e2aJW?C~qJ/tYg)_p%y>C38/>t
+^xr`5w/x/^1T#>+FTx*22eo`_<W^40'+4?";QDx./sxLFd5:WHK}8/_zN`-.8/|<)y4_sugK  \0#@Dq)
+| \G?p +I]& <	.}G0 8-op?7V"acC O|\Y(087K+FE_TiZl*
+B
+iX+V:C_qcWD'STtiVTlc3	<<M}_}{=}{
+>`z1@#t&s;=`!x[AK0np}?0^Y]<_]</_e*r?n{#k_6&n0}nx.i?Mz[x~[l>pl~M>c;W\2}B>#?z}o@?
+[\6HYmD84r#`\>Id;w`>868qIn@rEX.{v~cuqGZcY`X`0xov`O}G>v	I(hgS sX~)G`F?`5 z{P+	{.pzkxjXQ#e7FD?@Wp>zN9w&>;X;#a~3QY4\px_/QFYsX;n9BP\`2t@3yMY	&pewz{l{'d'pp?_!Of=d's4q$8@#t)\MO;$4w3!L3Y,+t# ~{v_YG[j]4#Cil?*u]:W}}:{Klj<X Ns37N>]R7|_(zK]/z1zS6uprKd2!{emKRx%0`Xv(~g?N7sK9<FZs_y-7@|d]Niz/;)"&M
+.3N`cm9`
+kt6vp9,;`rjzU%]wjsm{~g	`(n`+.pn(y<Xh knw`~b]=x[z~D<k@?4wf]q` q`A/} n=[oA~P~6pz4/f(~w#g?^0~E`/X+OP	icq!X=Z*0[j-z1?XyHW~4;^|&|gcq8^"vS}L3w`?8E>w&AM`060L;-/w=%X@|`+Xv>G|&{'HF>*t
+qJQF`Pe]O>4,uf35zt KW:tlc{mp~WX{8.wqyL.o9Gq2}#4*
+8@lc
+8}O8u/a<Fualy`1g	Vs9FXy?DX}G8gO`=@/1n{(8pD$1G9&0y5Tb=9	qC&i\?sYd=^z>8,W6^AoI }6#`/yR=,~rI=_4/\45^Pd>MWg}l?vl'-<qB7^(Bw9_LN a~jKFDM.l..f]@oA];`o`wK>zA]W#`2tgh8Vz0>{%W0b`!y45k`8m~X[A?+
+8^v Ln[L>uK}`2tE/`6 _Nhe9'7`WK_m	w5?wKe\rzv)sH.uw)Zko~VRcBbUK}X[>aUl?,28w'Y8aZptJU!r{Uuu:SNa"8>Mr=!r$/9_2*_d~r7s~Ynq[]zH+nPx/,Mr<ncp8oo;&Zj9_jx|.]C..]wqj}Fn'a#^d~nm&C_G y1r7YKf}=rvCv-?x|~R!5&}"h^j!1q,Eq'	WRnCs	e+uKP2{MUv'>zl w>!6&nS]OeK3W;?ka?>(oV[~cv9yo@kry?I
+,O<mymya_sL[t:Ytx
+LUcz'#`8in44g8>3O3l7vu//2ixEWx~sT?h-r<`=xC~q|	oL<N.oyCOzV.:}C=`8?`_]0}FM"s 8{<{@g?CtnGA0??v;>[wAy0s]_+q};P<l]cQA[T$iNfssZik5H/-`.l8bN=czoq3>{dPrnz^b=s]lT9
+*cX2t;>|O{ #`	d`5M*W*{iF"HWo~1:W~wctAo^zF`5A4^	VAO:F0^v-`~A9vS `2?X&#	+F`t:~:AtnpsV >6	%4%6I6Xo`8B}I.}yPO_zdis~kze_l_Vs~jqz&F=2j\r:5\i[t-kY/i@&S?T~7*c?58?lan
+:uW}#eA_Ay*ox=OAyanw3aprv'q?\[\l#oU7t+wRip}6r'v9_\zCkONuwr~lfg]Ag6k|r|b]RMrmc\m]-RJne?n7sez5q?Q/I#-l#vy/`b4y _A?hl`O00	%`>h>y?g~xz&gxxX?78q^>/>r	qnOr}\k/NgzhgvG}uZr_{3={Nr{>#<^>qh/rM/}%NWy/n__.g{UW>5y^v:7\=>:69q}f]sG{_C|3q$}t@8!z%`=_xv}$z;Yl@ 9gr~G<udi~HvcQ?=|u=1-K?`-\`O{	k|J|9QK_87vkkjGjV4"{VZxV7kisa1Dm:tNQ'tgD.F$C2 m
+XsV
+R)TB7##D<H?<08$yJkJ	Czt;gHGHGH# MEM~kT;D]~BK,JX"]G!}]'-C}t9yUqp!et]!$9Hdk(b1q9S&t*
+y]"}_!'[.Q29T~#	}BwCNkU6!YU^71	>6a?tCH?IU3Q"UH?*Tz;Q?_._s0o]6rF5OU'#v3?!gUi*qRNS#xHUG!}tyH}~8Nekl/HA!"iC4Z\f!!^W%$'<"UY)dLigCed\F 2}1x6t1P_mWVC+}|
+-$#-nkP"P@`w_}c(D]HC=dF:zWX]e]+HbAL(7|D6=hGW+$Q6%hd_R"_	IA!yrD.6C3"W[,h"S+-bEAj!U&p9`q>*q9z3jS|pp6VNiJa(9z^\[zG'Y'n+HubmL?/m;?lkZ/;PSw5~=}27;Y~(.0M4kGh_I+=~^+k;O,}1{moUT#;o`v9O>`}M<`Hbsd,Vx!]~RS6q8v=:9]/lz/<V~{D#|qqt@z!CzcMq^zn^{:^=ro>%b|Lu|gUkO:wU9?H:s^[?N',uvlF]1<~SvSv	v+i}|X'~~{^=;fo	O}V^<v}[zE:9qej$W{Uk@gtoE+wU7+c| nv2*w4k41V_$(wMb9
+g 1T-ZIV~#Q2nxysi[Vwx9>~tY;AgFLLLLLL%rrr[}WDoTmH-^mRDJ">2`dDITp~2[['Fp_N\z c\u^_oC2tfV^{dMv-\Q4_?5vy6;# Iv9Qc96x\'-S\caxz)J_o}_]_&HyVCt@(?CRudU 51b1RDE w@~92:FAn<
+y^bJ?B#n<rQ/=&F qY9c!AN9r&$U-@ vH721"e9H1/^/49)m8h<'h\`H.+-*3+Vz.(tbCjJ)&-ghY$"9m53tMllmfyQ5YRYRp-)%E%"r*B([ZQYZ^R`W)j"uXPPTn)rEW\lj*b-)X^Q5**qPb4D.F*@V#re"|*k(r8*JqX+rF{fMG,m{,iKD66X}&o+D}M}fLBcvMDm|CLs}&hTv9o$\}trJeGI<*O? 7*>i_;B^:9Dj. 6$/JeWHvE&	PoEOP^~BD?317RoE*%Lbvu1a1>FO5blh]=[Ff,vt-]:kXafBHv7o*/{(VfW`gLRKiYq-JHa+uA%K.\lj:-l8J*ET9rn9gHAz`Yl2(($k]`9sP_}p.Hl"IOL9QYZ0`~%le=UY3JBn,	aT_XsqyMd)DF2]taP(W[$o%rCT^][$]u]4!,,eis!V	Y\9/6b}A_nks3{h/ywW%kXCg=x?|9)71r.{owWG,}kqwyQ;7+]d3}!H/0}f_V@XyZXpnUAZ]~R0_/?>z_}qX/Saia+a"L1,9a
+o+V~11 #^|>
+s|BC/<g('A=YnF}	O^;Nk8V17aU@QwfbX458$e~:6(!_UG:#r-4&I'J>~+Q?cy/#'mS'k.#,>juAYt:QP`(+/9.OeVl('N,ZEe6j kUQJQY^^Vj(PB!N-VGQ18[%ou6E!/T!TZm*pYX3XE2,kM,x%G%VVXxXS6A	N*c?f T2(Ja5(2^W8PeEqqoeERFQLR5J2ZYQYyjAV.dDRiD[KZ!^QZX.*KV(,(!5m0CW&"Y*MVJIOicyyJdTXWV:{s,%Ee*
+
+UV`.*}7]P 52
+G6$;x4[5,KMZ"^xG62H&"f"-DqD=^!GNA^IEMCKG^O# f|L<gIx#B"61)}gj}[mF~M;b_1E`(=Jt*J^UEnRUzUVvCU:_UsT,U:C6t*JqVi"=Jt?zAa`qO=;:~\d;kAa^svz3nW4.<=V4/wcqatgDlS;|-@LN,y;Iu=b`|q%qPYK06QxvV*w/!6l[Q9hPqG]QhKr5l,48Hi|oyRl3Pq8[G8cV~f4p&tly:3wg.:h4&e|^qKC=/oqE!_0;<?S|Q([Jeg9|<[kAqQHb2nlORN{A:34<;OF<H6;1}8bg_`Z=_Os1}W=Gmm=	7-L};0&<;TX3p|_7>^z5e6oNB?G6bdn%7h>.~l|;FGA-AOAx||~'[]4>n803c-V0ofn6jS_.ZlE_1l=wq\|5407=hh	gW)'Q~y+c81H':iXb6l?2'hh>&!Qx'n#||	":;|`Te~!y?EXi!2LmLG<qM{!M}h|Z{F1nDwaQU_{6(=hdhz6*y)K4-,5_x%9yI*3+-J223; Y5y<Z{wYUJWs"87Ask9K+J<i8zi*K})?oB|OvNe>VJk%?
+k}7Q~Tx-y9+
+}ZS<4o7rE Izi,xdBMtSO\3B9^T%AB`zZbq<SSdJzP}?~a$CC;siN7v`m+u?Ihdk,\{ZL\Q,!iMR0'Ig\}Q6z]u4f-B>1v"|O2j^R2A0d^-2F%t*(q)\fJc0C?tW8-skHB.>7oV'_zp?~cneCcL}/kyj/bvb&gW_Ci_BAG\NYr~8ZZTEeAYz^CXCPA\:?$oLH#"/=}D5Q"* [,lWc/uR*isdtW9&KSqV+t<}[>xN[`z_4k*&6=_yVCm*WK2{B+85^j`g[yA[#v*{L*8c{J`5s59N:Uqz>=Z[}-uXGqmK)YE:+9h_= }*^[|&wFG.,ZJf"V;f4+6-rw]=aJ,:SZa#?uT8$ho.o!x}	$+4V^xVFqz?QP]Y*US=1uc]:_[-Xf;g2Zw6zgS#+8WB8F`ZdwH6RzNw@TZh,.>ON[eHLX_CTFT7?<"^~@].A_%(~^P`R`_X@JW2v	e1Dt]B|D/]Gs^YIztOid\8~B5nq=;WTV?	*j6Bvq^x}E.mFxwR[3LU}|J5gB	.'=C	'3OC#l--&1|.<qAwF?Jw3vz)>pHBnIl??Y[RCwe$w0-ws]n5&\krM5&\krsU7EFdFc^=nvpfawoenpv~[3c:7#K6r&N;9[.r1S !-X#\oz7Dw`<ge4	]mdGcug`/F)`?rm6z/}Gp{6NxN?`4M=mvIGMxVoD`LWHpL223e4okhEMV{/ 6Y|F6F)i}{^Qjs?vt^s;@vegEc3!81lYjvK}c0,zpkC2^O?L6ugn3??2^CG%FaL;X+1_8vB-t~|]$"Z([c-ve&F=ivV%!f;g){RQyB|PZMMhir=]3t!-CqGTT7Yfgj4%5!V!JL)S;	,qB?$TM<=5wG#YrM_),R,~FJrv"Z)K_{Cb$A!	*WT"iRz>whRGDnc0k.k"_A>&mr#oJ]Qfq7;)}v;sc	wYO[S\[Mw&Y[/^^nX,f,*+dl%&W.)Qo[q4YK
+s"0j%fS{E^~)o'dY>4	v%%0,Y6(&F;T*KTX=$"ehrVLPG3r7EiGSY\EKITY='	ef9t<=:6|$RfiKEeEk9,1q}F+gRX_f9$9G6[\jM23f96Er]J14#zK)If8}`^ <J3qk^N%'MY&:5ER=QB+'n+4-1MxU*sHld11A*<_u>3SZ"F%)e3]JAD9DZW(=m_vHnLcZiKdOEKvL:jLiG[i[]2/ScF #?eO`zFv{#A:.eQr\Z'3O<S, <n!X,gqIi^1H1xl yCv|5t=Lo A0>3wnNgOqdNgNo~NbT .Uc?*%_wVo_Z.+=21iN3<l@gzHkX:}8Am:D@;p=y}m/w< L0< v	4Qp,<}BP&0NSxx*t03(,\AXdH_-tq
+A	^
+AX@zd1o4s<Em_+Eu&x|K!3\sC!'<|?y/ 
+t&AI ~y"K<\y(LSHo`0yXdGAi5lQ\M yZGCFnbC[OdCmaSA_.629!q&}`mq Gyx?1CI<n2T.fr!\ h3,u`(kx,&<<}.RP^>r?mwAPap5'O#  TUOyC?# o<\o> E0HG@
+ \2\*d?t 	tnfDdOoqco d;sNe3r8I6Y`4c(+0?	<<-D.lts 6 ,1Y
+2xj5`!::	@16<[ <n/
+<M.Rw ap?8|g8 i 
+_\7~	}$%'J9@sp~;<zB&p{te
+!o=- A'2;x\ \: `(`$cA6q`xMSjO9)0k`;!|.\`E`5_Z`C>67d(k3xv`'x	=\5\Ou ;RapAe;)%pTx/g!w+A
+&&PVjY6uZCvm)Wjyj<o/*{c]UeT#t]Pd'.xSjVg]uGj:*eOG_M:UBi6}XwLX!M|GZ2nx>=t?N:o|8C>{Y<6_7JF H6*&djXRYZ[a,,E:
+(&$*~>iYU~j*++-\rGP,T~s^_5{=sl9P4"3/i)M |at}ogmI9}2=G}bIzvuE76'w[,<hccu9]N<xYO	.
+;oqm	O~PrqB6?{sG]!O&|K+"_z%y|Sz{.lgK/'X}VkY	VzOlr"jWI?Nz3y}4zVrYx{>kgCn+#r?/?"S]x,/^^.Nq@6;pMp/yc9y#N=aBrG`p7>^*
+?Q8'?&{EK{7/]=etUp!y>>57z8o}sP?knWw;2uP-do.n~?wy,mGpo_z56~o5GxW[|,=O}m}?UsK_~;\Ke;U$4N#um.tm9g}?yg_-{}WG`;;*
+]u%dN\/V|+f$58:FMnCyBoJ\sUnMz7{+G]t<Y[I"64>5?=;(7`_l{W|H\W9ftcpin~S=#IGN.66U/=51>?o99	_9me(wC`f,x6Yn_Xw/hO*,HWa!oR_mS3*vV5Em|%3~$En[*\{e~a>^x/q'b;Hj)3{+qQ+Z_pZ;uE}y]g<wkoOL?{my),pw:~)iDsSn{si
+iZ?WgYg^<tA:{o|R9v_.K;]81}ok2?}AB.M:~adC>?z_{v6y_;rIvU3\g[G{zM=q_GgNS9v![{$dyL?>}fGk6;?=L{hnzh)k^}EvkIU*	m9xEeCG5jvyG'.~
+]m?,{PcusWx2u[[AgOeeo\0_7hsrS,t~Z:ue$%DXRmcF`_Tszp_4zVDVG|y;a<m	Suj_+g-+);&.N<om)N'~M~g^f~\In[7*{D]Q+6E?{~?Q*M_(Wb&}g;]=9|o{c5/fY`MavEvp[~%of}04s{UEy!?t,5e}_r_wkxh	mk+6,XsY_[=+e|]CC/]2n{*?TT[U7d]o\d/-uKp\UyG8(c(czv'jUoxdJBRKk^v=nkozlY;!n~d^:!uI8|tA
+_"<[g+
+rcwq9?}{
+}tz
+k<>jw~p=a6{Tf{Q5Mp#_=|<vOE}9^W/,JT4gSc.nx\~T[=[,nymfw9SU7q\WuE?/MgY7.iw~y{YXn:?>:x;:pG}|w-?\xdWrwLx|cUO]ogB{Q~cq.>\UkUY~WhUf9';@'Ws?`ucpfK]~xt<?FGF^Si!0c_p8;6~jE>l^U~eSE~i!z=1>oA%p*?]UcacVvo9NCV{VMp<^,t'zN~nuKWco~61FpA]p#q]'L:Ak.<M}Nm+?qc|^+zw`ctC%Igd3#{r,qo&~/?e}~>XN;VyCspy!s8aNK_0rw*SZzgz}^~\Q}yj7y
+?w~,E^;>(w>g,kx<_tNZ}!$%,p sM)/=5xdi/>_xroMO6;s9ERwBW&<>g}]?5n_Copif};#[#o/	Mho]ey_[R rlNo=tw]S?wQ%h-|b>vyGu.'K l/:=:sp>k?2.{	~XxdZdO/3~[ImNthtaP;BC<Vw<.c+"g|7MY6wdSVDrn|psvK^Wyc]z$zZghn?GooX%~wim=7%v|S3Q{V;oE/wO/y{
+h)wT>]wkmO.x$IrV`n-u=gQoM.}O':>o'Yo?.o1
+OO3vvQvAs:td
+z;%cP[O~xP=W_
+KlO;{xSGKV'|pO=j3>w;|\==,ny!W\0yv_>?OgAAIwFqUE{6~~)o}Sbm9~U|V^F:rv5klnEl[10{\quO~
+9y6g;soNZO/[\}1*=+#nypl-e_hsE\[_W~;_qxf[s,jx|ECc!3!oxHU<nN<dwzWSv$'jw[{gaVU_2h><q>C~law~|uC{o.>g
+W_R|SJ;M};rlK\ftV/>-g6/&|`o/u]+uXY=)=W?4%Ev||>v~)\G[bQ~>wGx*|rzO?AEQ)}j% +cAow:v]9glYw9%l~yT3Eym{5u;ueyWmI]FX}$N/G~$:c_fnNE3:%logw,,#<ssc{Q/%CW]iSN}xp_.?/+j;}%*/)vf&&D1$4}[rwZ7^!Qwj@>`<&<>Zt;uk0	:WNF.Qh_y;KW|z0I"Dw#P&h[^@{A[oMvCrB;uvWYa~-uxU)nGtomZ})?cKPgSQ5p{v4I>G[>?g/Dagv5[y<Z/8Qg7I=?zP \4}QY)~ ah?m4Q |# -;bZ-:CB?9W1W,w&|X:!Q<Q|70Gu \\E(gn<J$ZFZGGDD]oc|2qw5BOI}:ZF0y1g2~oDXnK;P>mzAh;_kH*/>=Jx6%6R_;+5|x{-W\+s5h>?xgnx/G[cJSy{T|^~kymwQ<_~B4i?z%~;o0LCzZy]bG	_+?Gk[6X1_2al/I?-OOA;^j/}
+oj?=MOu NkdzN(0=^zRxc%2!&^eD}i>aeS|>6?B7Q(>JS{~D>Ho,zQ-7pb~ GvT	;yzCTa$O?Iy0mTAMg.z;x*+ UNwTiUB-iu(ko[=_<oNc*g`>j)8bZ*gt~@O_Kj3_>CO6kKA_4__Q[??|~\Q?j/B}'%{kQwk):d>#W~ w>LEOXA'y}|W?3d|`=qCo@u7[gst'vr ?
+!>%H <'^mw[F7xO/n/@*y't$1@/t/e;u<-ejwd9?`[uUL_/>_U>Z<u/B4lo0OWy YeOB}Dww0|
+|#wWX0V+S_N/OC!yihOoO|)DP "/c:>>W%I~4s?:V;}! =W+G|<?5C?%!<~Q(OJkzg;XNZ2>u>}srL,?y<oom21:>/"ey&	UWreu;>EB?AAXl_5k}2M_tT^7L_mB=K}lG{6;C|k) 8b@x"Owjcd\mh2!j;>+1>^T^y<S;7D|!0?Lk4Dn|cOx;=)N\ghY|,w!S/;?jJ{v+{aIc>W*uVoFwQMRyHPyQ%3WT^%O~m|F)n'3Zd+Y(x-T7B	|(Q_Sx+o<Q!T{/\q_
+TWO [:Byb'')j'CIas<B%?4Q<+((L-?a<F,c27&W,Q.?"'5ZJAl<$FtdZnjVt<__-P=R1+!>,]m
+FI~A@oEa<'Ex ~
+?}J{*dztQ8}*OWNq}Do(ak''onA~1(@7eci m&&)}IJcT;x `_}k~ K1>{{(o^. ~Q_Q-i=3yi`n5Cy~W&mg\LoIeyl_$Oqt?rAW@dt m9n!/u{h/+yXM~U|)(GFgCaF\tD~,_^>`yCG52=4|&"=b<,i]G?6*I \bw>Da{N)>0F{Q/`*AN|h_|OSYx\m#[rq~r<';r{Otm|+*k?M/+j?=y	WDwAA{qwMe~ ?	/ib/?\ko|u%$l-x}JOD~BJMeTw!Y~{O*;&H<tL W~{/#dR~<a2?G>&I__CgEt=o(g^',DwR o|J3AORyo|@hdyGw=G'k?h\lO^Gg/> ua[zL(S6"'kO;RywS+<}xE;gR~P*O2Y>\9w?|e~;v@<$XYauM	W'{`/5whGC,oG%_2ov*v_)^
+]{ g	q~Y!- x=-	p]/?W]Sgha~5d^V=KD_=zB'QO{c{/3jz`veGs[A;%Z@o^9;M;?vw<~+U//A>|sNJTlK_Gd|:/~,-j|J{)1BLbiyoD~]^/77YEZI,a_#]d{_TV=5~!!pYn==e{[K#>D7O@>SOF~.w^
+DGcQl?Nezd}%	4G +e^!o~:+FZjv}UOx?gy$o<WoLSOwbVM@[/wEmi}A Sd%,0G66_|udT$of*&^FevMO$;H>E nOy>FyH 1~/cW(gB YR
+T#B<a: <bCexLt?M_h}Mg7}(.?v,}F8{L]|\P<#DCh^/
+Z7_Stqx}}A6_WJ02~
+$O2GzYP/SO+e	?K<~@NC ^j2[5_|6h1^E:YNCL?
+t_d
+ObOo[Mg3@vN"_
+Gyd?.?[1El !Ro:k__I0Jgh*"E=9)A.t%)g_tY<Go	i~~1S5B/$?hcY;/sZ*Gb ?c>|P]exne~5,CP
+=aWuA%X^XF05{V#2|+pB'e~Mz kk\Y&e?6;
+mG;(AX*}L> koa2*f#/IAe	WgCOP`W ]TLE$;Kn6b?Ucg&_A#+B|zyg7RO}N?HP{/h__Vw*%3kZ-eP<2?U+`"M;4:G_<mdxOfgQ
+zI!xk5}@&2=n;G?!xU$<WZ|/k(\9tM{2#7)__d.fk?QWe=ryWB9Rw,^^7dy?oOw#b>1}Y4Ggr}?|:,BlOw@jnvhWy~5^0_eph^!mol(do%[L{d~] ~!XGw8zMX(>3O_9[U_?j'o}/x3a]d[U4^|P;;wb<)NDFX|PkacEc)(=>j;$:?JA/#y}6MWCuY^VW
+A'G@zzWi}#/|J4s1{G}B~`R^$Xr+ ]ao{iN inc)g/o]D{Mgel~3+d8/Ev?*;&MYs$hO!#Y,YY^aWdzUjI^OT+;}cohN=:;00Wp$,^;=]^!=G8VKU&Z_*/
+z[^<Ag~6Ovn.YniOh&;NyP~t-d{N_|0Oh+$kro ~$i}D^!2}Kyzo1Cw(~@3ow@
+NCD6>]L?:dzyT_@}qGY7?:5;#]M NBqk/Zbb<N+}J[?<?w=uC? lLt_+A/lj&_I?VcKlO@@t	|7>/3/"aZ9[?<(e>:/Zv%GG*p};8d0e'e|A S2x}
+}.
+^zV(>CTCAF+,F-! E)dX>! y|]_/ot_'{p;?'B>U7!'jV>oRt>,~zI,])>S7k`La]$C?[y>p>A}e>dV3^z>@~U=
+>F;gs{ }d.S-t>~#P{w@*w#?&rYZKH.o!e2?8xWc_y<C"E >tbS7v__MFyvET^zDC?%	M~,'OakGxdl.'~;T|p!mlk#C`:?B;cc)EP@tz2<S{d{G@7k@} fAm$e2~k.G0w/FDVKWl!^=BwF"%}&',n?H";qfIEK-/l-z;|cht^/D^O~iozj?!_QZ/><Ki 2%{Wmh^Y_4,tY?^<FThRQ[?c$^A=M|1{+4^	]'TnW;}Kt?~w{)S K}Ed6MEv
+4v<-(o@7n
+I{T><M^_h}Y+E]eVZQuRw>qdzAJ9e?A*:o+:Y_ T$=_h?Pe3#'IeB)6?{ez BS1^C(+s^PN>A3_7CB^>+%P~\-MtYW4cG';:Db?.c1
+]hV~-swaxZ
+_$zm>,(oM)o3KY! <>F0q!G$ K0?9:S&$Wi>(EbAGe}/Eaw0
+q/QV;xM_ | ny=!W&~~fl=$fJ''FT\JMMrC<LO(R	'7@_ l)go%F3 DDl	GgB101'@/w* _,gs? \ [=7>$*-'ntbEdq
+IV+C?
+y-oPX+o>z6RAexc|w>/K!??5wM~Z?Met/q?Z^>]l??oc<cH"eegAacM3],.l/4 pxNOH JzD&wEP\Qot ~Ver+~S|/=
+/(g/*GT=Hv<n?~?B>\XYh_~oe/qKQW GPI(KbsAO('%24 1>q=ExSy]ozs_ya
+h!d~;~[dQcY~AHv@hXvk?mbu2dO6^[7A;4>&.<.!D?9Dq^De~X@"=L.'^>~Pv7,#v bg*;eN#Jb"_:~%W^]zjS(g<Z8iQh \UM%Eyc~D)QYxU)'=$@0b>]00Mw~V?1UA:!/cZRr~FN6^KNLo:%5- 3NJMMU|hV5)5ij>&$[Tdr
+B)ddOLWy)BF%57L1;!-)eVF^j
+Rsh~92sRRrv%dJJm$>Q2IxY9R7}(G^j~h&qJ>- a|vaFvJ}OM&<:ti,!;{!@qB@$@
+3r7-9;?3! NN '%'QTlajJZfA^d!% H{ <c		Yygc<jBJjfj>,' 3UH)R-9@l9Q\|aa=mIKS2r)@<_fx7';YHiyJaZxbdjqZu6;?Ph}&
+ 
+rsS$ /Sr2yOX1@ytZnN%sT1<[$$(/banFNnFAIO,
+P9b(]FvF49is]Ho#}%a|3"0q{'H(`IA,y3/S!dC!k!TY320_//R4,9.YD,y^dd/V$NLMl2@|S	@67
+K(K$MNdXR;+&`UL%K!F_bX">7(
+dR-Ih$*>&S
+z}gC,Ja K`}bRgM!%&H449KRnRe\*7ApTR^n.iNFj"RSxP<>G7Mzox<<>S:&2vwn'A<N"Cf>4h==$g%3RR! @P VWdIKC,%<1*~H,AJlEKL@CkBAVNAv>
+XT1H="d$nfxbD@E&vR~>x)s)33#Oz)?fb6@F0F@Aq"jR(>I^LR$-p<drI"K.b%=	!1(z$u^fN!.#M-h y
+y>[853	GyB~&$kcIMJ$+J).JhG).iOgnrfjRv%d[U i43X$ICK%&I(bdr1ff*R&
+@!N4oh028*LO{lrrrASsZ>_fP5-5!M1]R &%#rfLN(Oe<	/s20,I4";09 }j/!I LwF`$ Y>e
+rEq*;!?5.j-x-j/rQJo
+3Ogt6)3xB6 M2bs,$	bMO	#;Jjdv>X(S#4ilKr*"CHI'>bI2bu''s0Sz
+f_n!t)_
+H5!0)sLc&OFE@@NyCrEZ;
+ W$;=xs<(dsRHBg2_RXr@wx,7yyPTeV3UL23&i:db/esD&k= .dfLKS0>OK'=6'>b&_'>cM{|Ql)ioHO|XR
+A1%kjnfj690}f/U_f)J|`7&|r{
+%F\(qBJ,Pb7.q%\(B/K.y25|6Vdx%f*MIma!iL'%H{DR(eO-bXA^}H	#8>SL-z<#{3Z
+fms"xAfKaJ!n<uq	y)9lB2xe%m6MJ*wssD71*Lfshx"aTBz 
+\!N-HAPrd*f1NO)o	SU<-'6 iB2XWw9}P<qAJMGN.,)A	ez~qKZ4
+$rOLu}E9FkfA9"JyV4	<B)*497H$)l&y/P .&.&JK4	7r5^S\(GQ*Y8@LP$F+SC	G((_^70QfR5n2&)9&XSN3X"X=/L@"DTH6s<Q2ZsXznvNH'<]6/6^h^*K3
+ E%0+h^^LK';"!L'LvTa[eZ"%p#@RElXTC.sI?igfDW [Rc> *1 X3RI:Q<-k59&^ uQ `ZY	T&_r)R"ak	iYI3RIxY.0#Bsx}M3)I , L6A2'\Dd2LyRB&J!`T ddgn!.	Sr,IYyT`>4Y3!'2ET0gH]<gXj!^'[XQF=&3jZ5%@r?Mk4uDri a!{1iIp=d#&0 LIJ$s%	I/H|>+)3#=SABF.}d LrWMHJcRP-;BE?@T&Q,=UD:<oZ2-N:jZ#w2}uLs+Bv-b[,@d{H(<TRAiR~RL)d}A)V<0b6PZzP@v4EN6M#. P&'UW/1LF* yAL
+x%lHl?XNhKOGUGe	wg9q^+#qN~8QYn,`qXdRnnIbI_2~}<y=RCnjrXB{4+-/	!45;$jL7OHdz/,I-#'y`FqRMpN~;FK/xy7_V
+i*!TOMRAbhh-OPBiJ@IE!]280?GQI/I sdY??">YP'e>gXK$&#N	I*()AS{gf'=>F
+^9K4XF8vQN )#!6shc~f[>AhED?u(MJNQ$4TL^_AQy]I&Ju_BswWy $z@-f)rsqbea^B",IyH'cj{$o<$ax&%;=Dp(AYO*_I>XBs8$FxZ?8(HgyLKI4i9`37
+co3zRRSR$+Fs, K\JnRLDA ELqj,S!s,$c.Eo
+[Y3X:}V)/BPq&K!.IVhM(g	.
+E/?#L,&&jm^93 d	Jo-p-LChh_K#bB
+oM5MY; !dJ?dkS9LI!e)0L,3M*\iB!O,!k*@ReA3yM0SJ ~)mK4+x4&dOed3d&^>9$FTIEtZ4%IH&FgqQOL @J'& '@|'HzTFk2L )=[BzNkU4e@
+K%l2T"W*
+SQ$r{Kn	fM:Df45M7Aj?\UZf}4NV^V!))Ct)c%1i>ysdf$i![3X=k(x7}|4pYh';-Yz:kTtiY-k=3MY-yf&Rh.)%5;w\fZ$97fgp545$ T_psI<7y)7O|iF!hr'L:v6^Xi\QV&JZMFHL%w^No[1qm>'$&{!`/t>1yx[yxv^a5(O<y"^
+<0z0<40<y8<4pGp4<$0)<La&-<l<jy[x;yyh>V0<<Za=/
+P:P00Q<apG0<La&yXky[xyX<<ZaQ<a<p6KxXrVyx[yx<<z^^<0yha	xXJVpW_>y<jqh0!33*_C#X-pFHJ0QHg PZIF`pFP#LA#SMAR(K-SZ0pVRJ(0a |(S%A`p6ja4JI?Tn
+t/<%ja/s>
+j
+S\#T+?sp
+/j+QhYKB0)M%){%(Tk:Fa.!>
+K>
+c&})<0
+xL!XOepBFB`1t= ZAGKj!BQO`FBN!Kx`VE\M!uh=mK<uR]?w{Jsxx(Igyxx6*sYx)sVP<U<W+*]g1:iZc\ZRGx.lsm54@A
+0BNGcQ2Txt
+^l k9uF
+am;7F6M.0M8|.3i55P`&NkN74&zW:bsK424uZ?23xA26~N0cDHi_2:
+O}yMPEK]N!}kiwDr**V_^H,m?HMdmd:kG]S{|KZa*\zzM,uvB :4zi{S7-.R:aKJE[ei}w;>R~[K.7AHDI=e]x}[YSzv;uB'JR/uh%.NW	X!8'] O}N8Ksd
+*C8gdsj,b{u~<*9KCC$)|7X]@5p5\6(+Z@~7Oc\YCB~CPTGY845E^x`EdcY}C?lSL%.prNkn<8U/,gxw74"|wZS[1?#RXAt%Z-R[C'q\]WNBJ7`f-i Lt#MNK 	n("S(qLf}q%J*xyAy7^_QkK=L@AgE83 )3]C1</B-Em":6`	
+y|9c96
+41myn`s9TXp.sU1ky:AK	d(0pF5'Soy%l !.:x6HTx]!HN0Q.-p&Tsb `uP[#w.x?~*/uJnSSHo;C4s(Bg/t	c084r~sHk,R!TFqZ	F>aCh.s}7~yt:+>46(eD3ukT@NM}vKvG8i[|^/ZC/osW)9Yg`c|&#[1_=Uygq44p(`m}o@u	Bp}kEuSuV la-yL*o$ 	Dw1ctAgx?Gy:6DuAZuOA'>s1oo~G/AsN0v.#9c)'AS,P& _':i] -n(M2}X\B{UYKwEz/S%)z'`;8]?$}460RVXX?!K0 6_ 6J}(r!Ll&mkVF#yN6!{A[S\m%C[90^g}a,cuUL[!.TgM,elng!hk2,*',VxsopoY"#,`V3m|:uLonhd^D:^W5QT	sd%F92uL][iXk%oyZAb s\K>#o<dsoVG-P	MOt
+-l-Bm|<Zj!RI$sxgLp+>oo-wvj<Vg[B}blKrdEy@vG~ElX?s*=zw%.@kt9a%]I~#"=sCko~+c1Nw5{+yi!o<g+y[kHBTibZ^gAn:d_r^l?\w:6o)ClG!_{(UQq('@T~S~5l_!4O=F?Zy_5oZ<mBBhkG<l__;oKeF4q[i'gZ`RtV6SPh.V|_g#o%#n_L~|} Dd'rV7'bfWhE
+WSqYs,Q[#Es %0[8z8yL 3o,$7nC*pkLLDnGhB|HGjfIgs
+@9z*OKlT(zy=SRZW6Z<Tu/zG'c~$SZo~5#d>P8ws6$RhL__8mW|69/u 3GV0]q=e"LSP&5~a]oAeL*dSqn{!}w&6-[G:dfqd*6D[l7vu
+2]"4J%}`u
+\ e# qLohLamuN ;Fh3>pa,0[nhttqiE<v`F\ Y)dW{J'95L=&TE~s -nP
+\:VV+7tso6SZ[Slw{ _d!EzX[y&M[WS[	]j+CM%.zh,[<<E)96_	D'S{l!jVxW*[M`kjOlB#eQIm
+_e|}>wk:@+yC[I1AyG[wE+^n\_4X+oOyT$Y)e3[{}|WmIyh%F=N>4YW]-+y-D|}u@`Uu
+%7p/\,-]]l(O'p|W<ZsO<)<-?o%o?E[G0[P&D_B*f3$t{%.Zk4Coqbc`?~n`l ]1EkvOcxS\e kx|tf:^V9"HWxt)smEN|a	"N-~x+y+Zsw
+?{1{:ci 	U)u<ALOtm*j!wqlJ?P8:cZ[_j-5[{[yy>4~}[{8}}bx
+[MmkT6
+yGJ/5FE9w8cE~!p{53f}[>J5-#tc[|[mM= ''Q^Cl0Sk_m|6DGx,Ni}\#	\GF a(fm{Nm!Z>G#CsS2fZYB+=n!4q7.6>7k5o]'}s\<q-
+>VXfsF?mXQFXFq]@c\[B$<jW dU-I"_%IJhZvK/6^-A fkv<*-hzJef|^q':Sm*qDwu"i4#M44C&@WW|=`*=|qHe^UCR}{x}~>A8`j^XC(Kp66p{7Z'7{h#D1w50$.J#4f"1ybvS=	WVf-x!n6xGl\{R1o45vnjKD8nVX6J'7J	l^LFW|Ftx?Khd7Qi-2.SG+Ty
+`W	Y$]*\'5vJoak.7'Z-;)~Z$_#b-(uzb%_q>?s?nq?'4>Os<8Gzq}2yX<	mNTT
+lt87/a~IWQO.[z%JiOqk?FyIsZGm%.vw|k?-[kEB+A>iguu/k2.D(bvw{?	h>-:X pgY+>aT:_oN2?+/!agRTic=[qO<z+<no8b;noEO3{YlK3QnMo!"7JU\Nk {im(tMPi%^|qu}+mB[G< J-=@~Fc\|nA5|o:TMgP	K	F#F|yu$OVtiG@K}$l?ho"=dJ87^jTe\B$MuCephD{L%}#j].?g?-0m+!{5
+:8.ok^jTwi]_e_m7_oQE	s8&kZ6<Vlig r+sa}3foNEK7v*dl=[2y0?)Wh| okM'H)tRQf!yICEX|
+,[EI;w'M)DxfUh]BlV6buAk<E qJqf Sk7oV/};
+nJ-yo%m+yw}bGZiyxVh!hwP+ac}c~,0\^@Zuk%oiyxBI<ou+y7Zj%-k%gycx#l!ob[;y^5y4dWOkg2<?x{k+sR>v+N5W?Yi#ou*,gaZU]K$+<~.]w{Gc
+;K#%dt Sf&3r;Mu?QVD^k@J{:7n06RyENkXfCxv #L(|u*erWv0O6Pa{2PlK^k-Nlma<Vvh!{^'k!(<T)y8/[ysZ72Lp+T3xesvEs:[gN LB:wJR}tf+{WVk-m}ISiyM[{^FYd|L3h_a()DK^v:Z*i[}]{q[@]T`Wx7n!I{5yOsK6Z3<R,</C_<_V`^'}-Wh![fCD{]{=xq;Wl*#C|@~[`u|(sZ[?Q'{ "fp@_I_L]Tcyol)"~n,hFQG'`gQP]\meM<:rr{=5Z~p^S-AL-u"?5;Ho<dl9|@Ls9;t #np{$_WE4>C O&6&~>&})MT:I?&VjeMaF+[A[z
+*i&/JL+yZ7<omkyOywdym<Vj!o
+[oyy|O1j!~*LnJkU8?w4Vy<*H{k3R_YseZ7TyW5#Pa{a(k54ZJSUKQ>[P+h2^#vKA~ese$7mQ}z;}/uQ.#GR[0^jah!Qk\,+=AOhS'%.##+=c#6qG8wGGRW	%GZBZ#e,%'L~m[?urV]3~st~ d|MrwJdkBmK:+ %>v[Kh-4h]8Z+>menofwkm\VH2Sl-4F!CI=ZG5d{;K>V{g,fAP?Bg3:WID}8g8C=s7j!^=j$5|bgOqgkmP0:j(L\[
+/rmhR!4W	_v&;v}*2DI{[G5\m#/RJcvJ{;:>1\M_DbnmTH:xjL.*i]{&%s"nZoiA59hR|Feah|P}=D,}OC.2GF7fD:|!;?5S7^_&3Z}JOC6CXuhG4K(kFT #1\`4>_/,?/DsFU}ERnPwF[ustH44s.LjkdV80,[JX][OX%VZyeWO7L<I0M:/7tIVthu&zB_#Awa9;6EX/k|4^/wog+q{=[duV-s(|WhFgy7yJg4/iDr=^XH\wk9g9]|p-_It\&e/0La>Dx+?[BtQ9>8<G?ulq0nPO:)Vz4|x5g6=(>
+[-I$+ceSA|<4I-ElT?leJEov2w0i0R']OxDg}Cqeytw |]['b!\6y^Ki?gc}E<\Cg~VZwSm#%g50/c.x7MVz.aZ_Y6;F64P}4o:H/lek4gjI9GS1<+K%cQ75cJ/yX'J@p]cL,}{`Y 9NZ<<;/!``6[(#u5wjm=iIk4%[;~l4w1Zh4 EB7U-I{d3~hhLRnNTjFt~KmH?-CCO2$Oy+<	-h"M8<+, ~W,p"'~E,6
+k'wQZ[S_#'}"]|O=\%Z+z=$'9q^_4gU|~+jD|sOq_c5c\D{bT;%*kBKv!M|etF_h:0iNOXS"6qawDNYJhi)6MihNC-!a^!W:dQ5Nx/K(RZ`.kn!5.iLBBtaYpLtau.Ws3]T#.Z<]wN w}<3">5?/3UK	WhOnUm!.C[HQ||Lst7e">k(xc~b0p4+RqL3Xd6:	|&r_h-`yB	@>:8 _LGg'*+<&kQ?Xva{5GdCc@:	7`[<g~Mgu]D)X'
+uA7gX l<\W]1^*~B=KGpN0c-Y&<"^?wA# ]7C ^p<M|)_Ms|'](A}h&Dw?}{:|3). 0i&cxhcHa"~9B]>I" |j^ZWVT>%5$:~"9cV	hL+k;ke8
+]?vn8U{	udOw<@#o(I! jOOe8n iOS?&~iE#:rN4rnA_[* Oc,cIr`B`~2	/_!#XNh[UM`	d,,'m,|w^q",%8D|Jusf&=f$Zgl7wMK+^9Ct8+T[Q\_'umxyiawgR~?=QqO_<}%GmQ+Lf
+,4$]a3/Gr`v~/W"&}[AYjgqy[g60kaFZnWeEqdc[@U}.{Ei2]tQ>A
+\-p#NkGDiW	d	
+lo`\)GdZ^m?Nv5i3=Q*!B_@oP~NS]xGEF+wvu;8C=0(45m}h{PGJP?}~6I{t>lx`:2ZA|{MU?U_^z22=2" Fkd7vwCUF:t[0=8=;av?qc\^1*PI<[S1qVKcYD]m:gn/Md{Q"+:wO>RGlL&"nP_z#N}pc;lGuk"|B~.VMxC~_YoXjv[;6jVR>xBkgT&/!"]m`x*5{"]sX`iTj:VeXOmmkVE5sJkE8s;3$\0SK4<F|2h86,?!q[t~28FXt&2rvFCv
++h-Eg >jT6e}ZJkiknf= !n;+T-H#~#j!-1z.qCg#>:Uyz|Q_2
+UFXB~7<W'\r{4R9i{>=2f9Gi?[.l;.}C~"toBOt]~wHAoR(v^2*~J;p@hM];Xu`Q/!B*z9EpGL*aQ]ubF(!+igk5:AivP*WriFQ2fB@sQmX$`1jA<Y?3J{:_`]FHIB':dssaj%Cw]-c}*kh,9{F8@q5ZnM57hWxH&|k2 YO?[m!WlTo<lhlvp\&Cl`.K<T.|yIvh+tktAF0{6CWD={PQYQE|yA56u}+^	O5h,=8k.}E*a>*NG}P^:G/B#1F$|$DgC)qy
+-tM.:]E?n$oG.q!hq>"@#Y:"b_*c#Mcd%<	Gy_g4S[$oF4'L:D2d]+{q2h/z)j3p+}3yZ^3:;nphP'h2ERK?-W'8,"n;HS_&ziAW-vz:fWS0B?G#4/:ot2iL#t=Fzzah(`\ |lsFa!=3V,,P<t{w4mhWLgu_6hm/u@Nln\a+L2z==ZMFH~*`[?:Cf48EC#7gBs"y!Y8y6%E8M<fMi!\StVH1=}1 "\cn"OnjHY cyLE[G`9lt9\jYI|u#pfK"m{Hcdz9S?%	k"x,#1"EG6wGM}v{nF)EVL>sbQdF\o`w+S9x.D4IC|#Xz!GjOqR)KNHF;_A]w 94U7A8x'-9}(D59%	:A$G"-dd2Fsto (O3o&{emC}329ad2#Y>Vc)dwBv-afdw7_^K>WQ^e	+-_&}4Xvew?!&%?YueMd/eSLvXOeN,(j^v/?|u]])_/oe/OzE\vrsyd;Xv .Oq,WmPvegD}3~jYv={{._r.{{e}te=
+o;c{kLV9E"=5/neN,&AnYvggrw)Gg#$^1uS~A!@]6av:n=;$(mB+j%&J(dCJ	m+=')s{6g 4.8Jcwm<Jk|C{R/}dc?#TVimU5tOOAH/.dE^%-J1I$xvo*hui!lY8RL/HUK$gT:ak+%O*P6H/Co01~oYKjSt!:|,y3;'!_)"s]{vttOr|W7l	`o:w`z&oc!D;K\Y>-A<"38xyK-	'R[hO, H!hLvW"^Z?u	FzzG-Yl^c>Cqk^@Evt_<+%Hp	3bFTEuw|a+c\qSL~&Uah;xM/i=zo!uX' 9,hXg(*}Y]U|y: q oi\aP};4Wuy-9K_,ViOP`%@qIX)x9
+=r1x}Gy a2?#bC01l=q7;	Rk3@/C|F?`v6/ KDo'<&/$B.!xX9|_*{1beZ4&~$Lt.	*	~9nt7dL![g{%^PT\TroQ.lQ3f~I[`~36"qZg?'	[DnD"v`d
+97w i
+'MT\R@5yI!|9yxG%z6?1hp/	mxC*Qs@e{782l\$Q2[4J6~Q%.G>aT\Bj}r>+}ZmL1,PJ}6^&A0&&z[RkP}vZW
+'gN:&G%_547Wz]]*|{.7kZ<kx]UzC1k``)>A66 7n4\[VyVCt'%.'Jr;@R&g:JIG/"Ur0gI@[U`LTYG Uen?6	V./$9&Hz4S4:pW][#MivYt5kw-~Y<il<8fj`!q%S&@0ZK2]1`a94\Fz1zp"jD[n1rsx8]o&/?&$U	o+=)5vci9Fs!BglyFlT5S_p<;'N:-;^!RpB|~;t6 $ux],]=ti!}*^4Z|l|}xDsfcu^>o,^(6/7#_nuF.rz(w($9K ku#e(wh$S:-tzB\e9]o>iOJr"4rzJ!rzUr5Bc9I3qGnfIv+U"&wp	\Nnpi?6?TGw29-P-hN_0<?~DSy\*U*!K/`/mx,]},M>/E~,X 8k,KccY:q:tL_4dLMC	,Mcl?$KzWpT5q9]Zi*OGi#LL~6olHg)eLfLd%wwK.2G^$Swh,S7#g_emG&Sqwt)oO7#SLLgLeh.SK&SG+dR6E2Gec1#S./eS6Or5M\2MdisZ/d-MdM\64#S/e6+MdXns?[6#Soi"SGn,S2eh,S?L:;_<Xv ]=yLm8@kWe%4qc7[e~-lEc	_'~\n!L2[ Os845gurrt*GyYn!*CjsOF[j+MlY{hFBB{=G:CnD&;Tl?0^QmTB;vD>QBWRU\A}x}7PfnjN_|vO!mO_zOi%A_Wue/j	aUBCXj:Gp`IyoE{o}y33:W~>-|tBw
+pT&TKw^sF42q*	BtvQ <3h!Pu$)zS754<5J@~ dNd5xeoQq-l?9o<o4tFuuf!l%IY1Vx'}yBaQ
+]t~=KQ	KD|])WHv
+i'zcgt0[o,}yhr*safu-;S;q9|Y_'x6|os7``-3xtfmb9jv{`vs;wwq#H_Kromc;0${dDA7*QH*s!eIo
+|W8^(#zE$>o?'5*UN$kg43pGi'mT>t5gp[PKB{GAN>"H?<Wn9Y|#wto)>|x1Ngt#>|hGgc"Y4c~9E/WuNwU!<iO)d>#cz^]\|l|,:@K:C"#Y!;5&qsJQzs'xrUtD/<vFsDy&8qO1=FQ&s's't	dp= MIrRIw#SEX^'ggy%\uw'HtM"0^t/d*X{/'7K50'zl1Wd1z_2nX#IV/ zz|thFg?qP9HN;C`r&9]MKe<%g !9q.O#y&kt'Oa_7rjp1b8C}PV-zHZ_	7ge?_/gFms#ys:QZB3[,wWz~%{va\3IF2)CUE!BxYh'jLxc]ek~{u$rrh2:6]"DrSjmo~=anx'R_&r[$uoQ$>~]f:YGg<($t|a~^RHC'PV8b9,/(??zHvM:RfvN2eZ]*_f}3XdS fU"]3HO2C~E``e~K>)@[E9Ze!3;0<>i7[h<j<_]hteJdm_c{][c<)g:h,~P7(>G/01NZp>h&e9/"bwAaO]	G xSjaO{_!k@?@K{	u5jqtR
+l+=t:x|3eQ h%Ao?Mml+x06l~k>`{.4_k/`r/sP sWc=82u>SKCj:~f->[4qzO;tJvfbo1tg]ZZo/T7VMx0gXH_,O:fuE::ws!%Ig42
+\|w6 y(mg|P10`u2\\vgz_#|1]gfj+6n|W
+uLCczi*\ZA|{7sg,n6gh#N&m/~(:GVb[]N=`Ks{W')qY8v~taNaG0 BGk]gm;He#:VIg`%eo]3so<
+|fxWz|=
+D!-08%r{cab9[c<@~UteQpF9tf2Zz,VIOr:gmtIGb|aF-?Go\>]";fgkjg&=`zYvl;zG]3G95_Vk';z/eZyv:oS]UA_=Y1n)x]yh$xB0{2?sz1@'YPxR
+X'3}z_3J, >H4FL?E$h3ZIW={#kAw1t~/{!D?eF-E0j!'0kR*1x2dO } Xk?l$AA%@m'2V2C5UZ!y	x~OI1WzVdUd'IeAKaAx|+0z"|q!/vM^^:'=Z?x#aBWkqvO%.M@~Qk%^M|Oz_Z.zo.u}>&iVA/>aO1nX7[`ZpZbyv8!y;X!vxB6YU~ \c.~{y;N5,`hxG39<33QNg!!qQw3Qnh7=1O%*/xfy0Dg`53X!yX2-lQ;5o:$-geX^IG:%>g`_GwF/!n4+H~L<P_	~t$m64;t7/*O[4A~Ig&NjUemK\}#bA xBA=' i;x7iPgp.:gHw=Kc[YCgvsZ}'%g:GAIxg:;Jkf4}|pZ`kTIhS%_x%9%>}zE~M	xQ`L;->WO?8|3sch"i.:	1;l0!CD:kuk<C	qCE=%=&x PW^ E4_H1>i6t</>G.F>A3Y]$i]E%HD~w]L.5{"lL&1c<V2Y}t/AjA6yuH<B
+7>NcR7V`:gk!gp}EU}$$=e&v2DzB';q%^831G,^oc-kVJmby}]iMl=z^a+gWzYp.u8_A2,vmE2UO"3!#jL"{B|(yF`yz`HjkwV;[:~-w=;MmewT7CZmx6}4E+\jtO{#C{FvT< v}*:6Pgz|jsQJ0pw.m&.%-Ef}}>{Y}f-.#uBqX/,Y9=p6Ct#F"hN/|||Kw-&Y6!o8Gz0vZXmbb3
+L$-:G`}Ys89>}cgDRw]>E#(oqtK$hF|'y7 <-S"~OGNO	387cw>&WDwnQ{VEinCq[qFHhFq8ed{6fcj`k=\VZ6E_[!PqTNJO!c27F_DtFb~Gg_	rM_UL=Z`XJR	 F3zz'l%v>A {R{w:Jvb}!,%e !zNZm-9iHg,sos$>>G/?FgXN2"!']>ZKBW|7VhyCA1x%}O2yc[n^)7a{DN_Y|1oEqLUL(VG%TEyeTK\	b4v/	ewj:mK\6mJJgV.>oAhL;^66HgCvkwd~6ch1[(B758`:o1akpioq|/|}+:m#5k|T>~4FNtj	:jxu,9HhO1~-4B5_hx>k4_D$z{!RHge'X\O.~g>6H'~vt:au;>=oYkOc4`/@9@~].`}@K|]F5>P9'Hk$q4G4_ P\7{Nb,fE`,ccy|S?|C+u#x6xV0`L=:W}>7}v=_uz~G]$}Q4}K2DSAKT&&b5;v3ztO{w6M Yf <@!y|@4'+
+a D:IPH&hcs c<y$Og|/}L<40}IsGc~twi!{AF<\j!=k|_o!VUF;/Cvt$ojy| gx*kxtC]^G6(|/[}W~wY'`E? n   SUxY7M$q%Zj/F6\w#=')|l:!rs"S.gh4EgZmsG%"
+Z?9`Ca(@~X# c<yg4n8lt"v>x":k/<4Ol:':o!t.ZgukVt$9< PXZ?u$Kg:)EKg>cgw:7
+b<c%~.;w`/=U=D>skTFU@#xa=HHqE{[i5S`` LMhf27~Us21  r?DIh~k(%z+dhtedm#]@t#o9=oLd$`c~C&~t06#In_uV* (?1<Fcc,n4FFhx8}oCu{Z?;e<coAkD_i]{TKilM[tT0]=nG0c~_&If.	'6jpUO%xLtN%qG[6O=Ohh{=j^^ WTe6i~}jK~mg|\RY\f}&"6-2_?Gc/qyOQC}]am_~h=Jg=-0EbL 7C1iJ~tHvmg>Rc*}shMD)\8pxo=stMttx?O<[	I67wAw7{w=b]K Yp>hzeW7H|F>i%y{*>IAp^o|9boo:o<e"Oa=;~-*_}O
+Sk(Co}]"?J{&I'/M6"y8!><$D1|65xX_GVR_C]EB~|r,pMe2X"_!`Y3+#Lp5
+R@KlO6\1unL_;Xx+kwY
+mG1@HD7^C$Hfp[f.{,a{5)[{Hu-
+W[N{/@Bz]it<hfhD.OXX9{{,"(}}w:](7]I#K@W;)n6~+'zP>)RP~)/4@r%rHNEm'?/j8ompzM[kX&L 'C_8`A 0|87	/6Sx\\6xq4kv^gGV2^4v=~j V<AP?*pT r[/pO(c>"}=U-fHW1]W|,ihLmDf/k~,zKciA8?>gR"-<k&SWaVAOP>#qOx>9FD2yfBG8O/h{,G>g4iP""@h:7(W2y6}P3C:@poiC$I/A>Lgrk-<kIfy+{CB$(Hm&!qB9MCEV]'K*p"Nssfci(
+x<rbSox:zu,AhZ;OT	~'u.}:97z?K`\$|";?3_pLLsYnpX$VAvW9iaj'tIr'm*{n+aMC[6s-~mwG#%ra3CS{ClVF44nO&M#|>}O^0I~/;{;n/#qJ-|s4acH>'s;_<vS_dGMO~_MJa|W#T~	O6){"f_ ~{F~8Bxm?yEmJ{]4.Y"'t#ny^eR^}wE0Idt<X6x"O"t4#!}{YLm^c@2;=v_7{IwYGu/3_QW(gBO D#br(pgo On0}=3{s*Ba#?
+?XBY!5e2C"/<q9?S
+n<N$mCsr=Vxh$`~cm9ynyRW3<C?3squ/NElD{*1F-qc@sy&h#voppBv!8+m^.aoS:_EFsx
+}4LyffN=yxwNSA6~:5!<Z,So\ts*-oBSlN)12YY~a8Rdxv.=T5hBZ9O6l:M~giymdd=?^cJQ4acT7]}>+shWb~bg3| I/X}n8(.GHQuUX0y;EyzOfl A|:++<kW.Jd3xo97[z*7 XOJrw!2d;23#{/%X3
+}nz[6o'J	<eq~0+^;9c/*nn8u\87zsaO8w	e8+[[yqsyGs9}qnaucO50$DY&6a\5F^o&1kOTk^3I~(o3ng9)O>HztW{2xV.x8vG]&rCZMK;^<a-3<#KR:}J:7k9\*U}b\;8g~W%Oe|S!,uxn{2e70na20u5O?G;taclg*-wvww>O;NOM<*%Oj_+IGad%ow2`	tzJiey}wte#pU]32qEH_0&sFSN?=//L[\e7HTw\;'~p8Kp13dXpuA>o/0-V%
+O>F#l?BM?zV{?HI2?;:{wwOwtNt2Fo> r%S<em2W%W3=,=]#uzi]: SYW4ktG'3|zE)[[
+u>z;*MJsF5&}ucv?$IIN:AzID-40	9e%OGgKYGLkY|OssA<7HE\c4>Ws>>s.>[q?cAy_nhoL^=,HE!l,mc+;3mZtGP{qwx+;'o+4b'=aN"is)OJN&w6V._g\g #y5ycq9e*i]p7c[Oa1qB[P-nl:NtyJpc3"r1e-<}|eCPCg-8<%lw1.,la(u3i~~5r+2olo`dk^{8LG;.out8s%/?589|Gg7
+sBoMG8.A#OyJUS7c@skCXgJCY}U_EF"]C1f\(vIcww"Gor*,w-8Rim Z^vM8yj`<+wHyi=-nY6_NM.&<zMb#/x}Y[@K$^\N{e{Bv{\~3j?FUkZvW~ 3
+l'/}~Iv>g1>I3aP#.v}|4,wQaM[b~'|I/No.^b\5->X1?r^fN_zf~U{c|%[\}5GXz^/qL'5q/gx=$hk@{+[yF5xq]xm{^lL}FvObcv]hMh) ,D._tf=*y;i^0E{>|pn/m?c]	s.$'a;cR TC}m`kd=gV,E{YYq* ]{rSZ=JE	d9#P/A;H)~wOzZ#2y?2|4_$r 	C1y$Kn\S]
+' m]b,E{4$"e~=%V<pype\weJ~00O^_XP}U0$JH]X~>pKg hvf^Vcj1pmmw8r/FBYS=T{sb[v@]ln8{)j3?<cWB(y>^BcyaT(*L.8w\{2'GUb-@rG_#:/rQX,(pAh$!
+/v{p$}C-_'VEX4#$>VO\xAm-]>N:|hG-h^mLkFxj0K6_P?|Yo<83|?9\Q||C?YTs8:^M ~v	:-Ue)hR\|Ook"n-je3Nv@m%5R>sh<G?e:`o7w<u</L{adA~B+X_<&.JGUzO*r2+_=<B9t9 3H:s -(-5pX:'7I[$}y}jXn'#1oo2^WJuxw`n
+'4l>\uj~1vKC\S|\5e'}>Cc5l.Z12cQr0}%Qx{9]$*S#b;&|M[2?pxlb1q/9U'=+v/rvWmudN>Yk3YN3e7kxzG?_|N(s/"kGjUr`	yehML-GRlmJL!<>sWlk{4=P(;iqz	s}I7/oJGpc]1%66/ kbO?45+^}o\'Yx1Gjsa}i_g4]&*e2Yv*@Ia%Fe:8nE2O^1]Z<YLgYGbCO&'\yUE5"M^Iu,V^Uq*34|]ZNp<!kp/qrnO1<ga0xK{!y<o[sD]30%c^'\#{[7w'{2jXOSGn}r?/*8[jh3**i6aSOK_/4u.*FZ($ fh]%Y:Rd8^&5R	|La6sn$s$s|8:?{Uz)g|Zkwr)RH$30K:Z"Gw1O5g48wU5R]+>kDZ[O~}V[U;	794
+,yyD
+>]&rLtjzB~uF4	X+4`nSa\Fa5-RZht3u|<1AXmOUy'6~<	w7on?q#4 ]H[mr.~ewp^iRpG}s!\1u+Bayy*Z<r%qY>=ZZ|k3kBsmL@Ci%Y6<GT_arS^]$>dNa\mV:b^ulqG<b =fe+:#69<{QyVQqciB	?!ma4sa;nlc*|2Vr1?eoM_TuDXkc	!#HnyY7AMyH9]^fhojzyu_:OV\#82OXt,c-=]e3{)Waga8KY]Jr6\Wlb
+Op^m&Kz'h9 \k7<Q{g=& ?.M(tu8G3zV=^R7?"_es+sk<
+xDE:-#KXo9,0?jOJY;n3^FaAG"8dGp-.q	2Lg_FC>r^N?${g;H#7gExb!/Wsi#uFyFl9Xu.>k*<:_7yOHM["qk(gs,x|,;Ii=6w~{3Z0~S1eEJ1F`w&|1Fy+~sU0dN{1?o:xey #\3ew>o?<zOhqAX3tXwEVy{6|Tu"[vg'=&	tw4vcoT_M!;k{WOKo|ndw
+L3!3<i'S{]1l\<;f9cgE>[IKp^E69Gx'}p~Tez F]km4qwKrnt96Swu=G4Iw{NDnDFsC{g Ef.$9hWc7'hy4ekA~1$,y__/|!Y;$XO7'>xK\0|0V3=~@MUWy*uI)s;*ua6>;}Fo-nY>%p\#VJ<8Sk.N+]|cXnuA<0	3n"lgnqna1 d_]49Hd,|]^bs2n%X@xjeEvxN?C=eI8y0X[EG?8]+xCDu4exl1f"/I2DMi'#:dVc<y#xh~Am)K#\.2L.K6xyN4T:ts?Z&L%#}n:*W1,V2<19I$|v-GJ29K$"p-!71^"|:LnjO5\AVNvKa8{?|%erC9(+35[[@oK7->G7!lH+~wk1<29WXRGy&w+cryJnd-5g{.sO6\3ud]~~xWw<b.ZY?zoSu9x@qg2t%;}{,QI<gh3OZJF>o:W:*ZeuzMm^m6nxtsETQJ'.3H1|l=%b]okG|ky#]ncJ^}0FrY.<5-N}}]aR#n:G >x4kZ1?X!yCs<tnL:e`2KA~PX
+y(h_dGo-d|r_rg}'>Y6?Ib%t}M%0&MZcpVEd[GC wK|k#vZE~Nk-<s9u{|<V2|uP=6!=$Mn^~o2^|G}Zc4|aJ8$_ZjodfE?o9(%e-i|P!JaevSgUj O1+a/!yagm18\w- tlo/xd-
+x}+#/D[O3Iy>FMj?eG%y0g&`2<+QZ:p7p3l%#zdgQ94/s;|L7kpKHWZ>[gUug?Ox,zcit>:+u>>>SSq=wo5IMshj]:N:RU|?o'$/JaB?~43O@=txG"yvIB:._a<anFKruV$>9R1f~tx~g:uNwxQh4x}qqn1ebQs{9elZveO>yW||kzk>T<'o[a;C1|yj|\eBfmQ.is]v=1vMc)|h,XT\:3K2>s>3g>)|n=w7w7N+7^7nq=u7V=Fw{_fol}~doeoL[X,|{k~rIp_P@Wc/;(9|Vn;}f-
+7oO}	mv8x|T|})0O	(P>=14N&_=Z1ZEgtt:Y8p3ooq/2aTant^=,4sUG||f)_Q&HBh)2t4M6t!I-GsN#Bwx7i;M;M,?tNStg%%dh\2Lwa1t^@w:7)FL:]ve=rc6tg;xFNxQ]z;=jc/1+!g:DP.Gvohv==hJ}>W~nlr/w+}wrr^9^=sW~^Y7Jw+]s^ym+u+FW2UWO{{e+'T(
+"ux>knF^^%CpZw^F5jJ{=E]Ro5zvSK6L&?_YTu"UX$2l{18qR?f$m"kgIm\gpMwhkcX`  3Z~#up. nk	B)SL(L!zyS9Z
+lwKoap]%]<k=ka.j 8SbT;c[Ym:5vJ'f'?kFw8_$u(Xn3[pd;4IzS}$qogdkCg*h>.J<ak_49M}[Gpl5qFFD]K1gY']]:q:A^{=%J9o2'tR+IK^<<o/*C\KTf%u>$PNTGIxA3h-zqQ<k t#-d[6C'GkVbSGXFw;+I>}`Ui%_}\V\g]RGmsjCmK9f26ht
+6h*uo/"+:zyp{,)p^\;p[V|]=~$\}n	'<s_ei[@bp>L]=Bzio/3/'JW|z>UnT}hsQmSM}lu.OtictE=8stohY#zP>KuA9B/4HExz45PhOYN>q:lpoal\W^^[/8C^N1he}~g.=_~wXo7N+?7ws{IxF]=}{{w:{54#XbSl`N*U*]6ec$@G~]Ob90NmcMhz+KT>l6|I
+O+a<wwV:29es2s9%_$|'=\Nhir^h6Mi;gt<3$Co<}kZ8/Tv''}NM0j%-%&p|#vkd2vpp\r&]6IchsH#n.y\N!w!7lmzy'T~x^k		QZ-q33'
+Gqop{}bmg|v<[g5/F{I9>AaKan.u?|/?|cVjV|;+Ed;Kenow4I_idjcr7Dcxq69XPYNw>Xar6wK#himS>Hkp7{#J?g\z#VOO{M^TL5wea5[;]+-6CRr^o%>{@MW&>k5*0/ro^dFi^ts>@h1B?){*MbOfa6shw:dZ|F{?rTQ<-u+o:''h\.sS>{74{SN*a"3v+|z5*N]:F>TS]t2grGJXZ8MH|3^g-6th?><A7cOt,1&yQV~QqoCgy+iq>v^v~:^J<{kAGt`ngC?_wSo^:ehxc0Q''_@>,imo>	.s?Bw.GgccM^a]Z}Q|}A~`2_ %mR*u/>w/(Z=6O8'kO[:uW	;"iWL,-jq5x]~K}xub;9wwclB8\k]	ZAJ\!~?
+V*&NSg859aLyS_#Ret#_q]jL)|Q2Gsbg^zp'G=RXz9U?K*M{<8/xygO:Y/Rh8d-@UYr#e}K \|IfXf0S=um9 {$;),\nC`w:!Hf#g?Nsd?0:jt2b]K8,7zjWR-0{e7hWms^1I>pKyZhgS
+)VNcsu&h'/z\S0VkSG:NIkLNRiB;)dxxu\Ri_|:$skC Q86#5SBmuq;}y1@uu9+CBr^5wf)4{sjB,W~%aaH\FS)Ui.U?oLz'![3TG^r{m*vC3g|C\!qjd]`^1v<O8U	:wu8[LglylIgmh'd`y'a3c;I<'v~Z
+<''Gvh.}T!?3pq$_L]E=k.g3ykInfmntbwA?73Zj~x8wm.!>3~s8b7uhY)"eS^wy&.T 1MDOQxNbRtK-z'nY39y
+?X:}Yv>I_]KyLl$gX$i`T)s9uR;1j!>FqS4.?c\? :YfY$'frG]nj2xn
+|
+gg_~
+OzS,uLZvSCFAkC+UtcGV>w)_mVHBT4[?9V;tx+C\O8^v%Mc xc>{hG?UD'%HDIue^fZDL?Y&%i%Qb8fz)iIk={f~3g=:UzC%[QN49'maH{
+!K&/(:P86O99./P.w!oOW2 ?b:`a&E9Gk?5QVMLspInc:.wEy~'o3 Ygax._Gzq~8&|M5gy[XGM}y*M^qz<2TqfQ{=*~.\Ms-K(2sL+a=r9$1G|{^5^tGk?hhw93r,Wp[xbG[XmifB@t>[!l6s.'qNqvWlS=2x8	~sN%{\C#Ax3EXjK'h3r?p_=2<9vua.uAvggxhk y;ri|i|4>Q&_V>lM#|kav+	ORixs?=6.>VC]vo<iZwOyzYk/OgxWPGVT_9{8UE)s^i?JC\y#:N.>|1+0$j:^_-I~2]u-YF~~29n|GZ=f/Y1Fk tKQVyowy=*O+/hKT~bAvWGGvDowM%`q<z$}Zr/g(cFY-ZW~xb:F+SNgP[@;~~z)_*Qrus(KOu7Y)$|DgpPnOS0'R/*w>c=&;WSuL=R}}Zsn>"r}dZw}A44Oc_A>&(2RL<".E`%'bbCRF>ZT[<i3Dkl>Z9YaPF}fL)>o_inwtpFAQIu@]TO	r/VB|sq+&h+HLxy*TI$nSot5]'q&/_qh|R5IvW1qXDl7+pQqjk&VrnXR{C(ve'|[*WZj<;zLYexK}@nbw]p_=|M^Vagwjw7yz1uZoUOX24&<<xY4gKF%q~_~MfiIY/5#
+sm3x': SrX0U16~~?T}$?	6snS3Ip1gc9(_zg<j8=up~9=:S*loKy0:)M=<N>XVI	.f)FB}pd<C
+>oC&:1jPTxeE'kv*/-xN_Womuw^5ja54EjGkHZ?\'R2~_?/sk0i#qd{z,M-kg}Jt7<qq?'adQK>{=DmCPgpx r{f ^
+X!M]#P*:;Z\.4NJ[tk:O/^nxXU:'b?+hTH\oz0Y9ii/@<Fgb=ZpnF]=XRxyp6fIWoW>	tL]}gB|~Sr//)h'jH> 1>ggvj \,|bH~|sTy-X}h}'*@\EbRv:tDmKqh<_0/q%&7q}=*e1c<LpJ(n[R=C1v+hgnQU5D]4Mw^tm):^L7<3ife~]cLo}gb\TxL[UK9==5zw?>$J" a^z
+2(?sWWfZu~35tGMZ~$Z]xiK-9v:R+cwVkNRsi_ZZjKH'qM/U	SIt(#z- CV!1
+!c<&]4mmn;%mCWq	E$L;B$4c\~3(b'hN$!cmQgwZcZu<H]A`Gf
+Sq	xq~JE:>m)XO`F.4:.
+~f8?JmwEfz8IHvSgFW&[ME?3DA7;V|ZhM!2?oR,%Vg{GOKgx6GxJxhdd+MjF<_KhpQ,l>Y|]^`:wJ>eOhV[M|><a7Li&2SNTGZ``Rs*Wr}2{*,pF)P MR>\RKeq\qW=1L.14}MwS Ka'ZVtEh!On1]0qhp|mqvVcY[=X	[E|I@$+euHz=n	}Ev<nc.9tUq8Yxsbxy~;g^e%QUA^0c\Oqx2x:gsE>Hgku:AMQmbSmxpLU%^6t. )NHranI|{!u%W$:f?v24=_VV	C _nq6ND,,U=TAsP2O6fJ^'%<w[s:gsyCO;cfetY' - vjSc1c=~#p>a_'>wceHo>N={#_G&xt.%O'tx_N efXd}1#i;Y`.bC<4jL1~]9t uV*DRey<\4xVLXF>?QqY]JeHTS|E:<RxO-,O>ecB0XyA;au;%8[uw-b[wDwzHSNw>awo?=EB|{i3Bp^{MVmA:[im5a-AXCuflQu.
+xL1\)7_8/yiWUw[
+53oJZ:?IVzQlru$j)1G1@)9)"E[z7m~{7OY[GJ Op6v<8k6/gWuNn({Kw"~lv85Bp-A*uJ{BTZ{sW6liD|I\dbgnS[~<H1y'@r
+")/G#1T9<u}m
+$t:jwDfO^tTG*J.A-'w
+YszWo71>-SxW\g:]+:1zM=:<kVi6$wboa)&/32>T*uu(E&&&D~
+=L1q,O&TBOMO|JFRgX%5 "cbopK3J?i2Oa!ctCN>_LF];~[^ wm\4 UUgg0T<Gy?eL/=%wFF\2f\/9R2ts'}UEIMc25s`
+`7oG`Xg2aM(/=1]~y~|hO` ,)IZ96paY>v?fsyx#hgRlv;_`NWVK<m	407&UgOG/[)Tjt5ICo'aIGy-9Bl$r')h'6?w`5>JBG2.;qpo9~&S>8G;z6
+GEyq%G/tXsc^^2>ZgsR3<87Jy;#O]jn<x&~xJbt:fn m:o9!7G0Y<Y;mxk?r|h'G*+f/w}^'ZQM/:vVxG/sFi
+}T
+.x?U*}qK mXjobLkF3.zTB%-Uc~2zmb}&m{6[jWSJ<}vnFK(}&%T+&l??JboAc3T&\R* ;q*{<mM(7f!<x{IQ*%O<=+MT+gr.uJgA>vG\x'H>8GKmC{Z1<C?lv1Z<<sWFQ57FN5{rO_DCQ+yAkdv'k$nk#B/KjZNxRS0,M?ig /wr#">v Ob~,b#`!S2!FiMrudwYx}g[jyVOuk%qFx%W ~<k%Cng{y~n6O-cSE4||m$	176z}eRub8vrBh2h_HaeUx_>vx9Ibwu
+g]yu{V9'/~7'~@<|&M=+'{zur|5<"WSk00=Q	$|B1j<'z'xM&w4gf-qni^`jslC`7M2ui>)65x.}sMOM?n0k<Ox4<k%&]e`c23UoWhc/:#>27.qr^;C6{agsqhmq|Nk]=)$mp.PN\W/xO\\/T;:b`^Su8o5T\PU*ho'IS7h}$Lu5oK'_06B+5J:OAmr2MZN=jm0NK^=QyR*Yx+d~Sn2DtM9Fm'"59fbN:0yaiNz]H>uur?0vm4#io|]K2DfL#}BK_bq{Vy9|_ocu!GK8Y|4|+Cb|l-97*z}
+9+1y9OLJ}t~aio&\;tws:__15Jhy)#c={|8C'n4h8QlMTBssZ]=+4Lz>	n.L:"34(dY;C1YCL|i3Z /=:Ylfwy	GDMp[k7-nQjo'=o!LcZ*]{M#U:g[Le!g?%=q!4dI Owd$vZf
+EBwAG-=+w1.qYu-Wu]xZW1[-U'#IK?L	wZi|cY)yg7\j[<hs`Sy:6JRS`\n`Bm,%!}#1cku,o70xUMt\afMoyW+WM5sg<M_IZOGGbl\A	Vp\4A~B?*hcu818%uil=t<eu&?xj;87v3;g6$Jq{(K ufO~P
+> :J859}]BH8d1wUmxnM"m,'69@MD*G~Pkz@K=1R?2$uZp.B9~9O;1a'hz:@<S'O6kx6tWV+G=|OKI1uwc<(3c4ujs^lR]w(e+=]:y8,{:Ua<Sh Dc>XYy	:B}wk9Joa(kTNWJ^>]j4mnv#%fQ$V,^tM;xN+|]/w9PW0m}2g}mUU}Z'uV{
+yw?UC/QL|T._\`A^{7A^K!~;J|%2Vuj%T"7ll&\W/mh#c/CY|z%`5Ee(}t+_)xfzk9j4dw	 o-~&N3<=3zk2@ AU^R	gl_jXuN8h*3v3Z
+cMn<Obi:&ydG>ez}j8s+MK<&27.ZOM/s&R&K>Se5Nc]$CkH&2O/S*>/71E[YbHskK}x_S]ho_<&lI&%yWO)'\OHrJD]L 36&>uRk1$k'saMO/cZq;ISWj'.}5fGtq1MI`*9FYx}o8Ko}8MOt%ZY4*e2tY`m?OY?>d|ibfqLz/Z@]6s/VsT6ucf)b&/=|ZumJ^T=4qJ*KYZ|giMh@aZH~|RgChd}gk%N}		5_r3F9fO`m?gyS@w\ja0pQn8Fxo1m|CCIMf:Un=f	,c&g}d67NsS%9tLr{NzC<LC 7ii9yPxeJCU&o1%3/FpGxW{:D]Yv/'(=yw9-^^y=eq~y-0z:gH>f%+V6haVVOl>0~y1qL;+lxBboo~	xoL|kP?4g>6|sD[OPy5O,]!Bq[NyBB*!).mNQ'FRI#)^vgGwH"SQlp]h)3'	XGX8S|L[Z;V8/54~u>jpU_vX]_bk[juJRuXU=>'tAcdoi7%#TGHrq|@_imctSl	a0g~wfO$vhGg,,[O/	3i/52y6X=;]l|g{q^FAwY7l9CwSR{rV>Q-z~#qxkR+Zg&&&[zoAXlmwza*KO?DX,Ug*}an*zaX	fJQ3=;sx}I{lskYnv*D+^'Ja}ZU<i=r&KO5ZN0pe SvG]H"vL2>;q>4yxzF*1-/i{*ZlC"|(]l1NL hO0OBf`z=]o
+E:s]cGt0#kxt_t]GhXnhehi;v){1{6e&Ym]`m6g.F;EfN61g y+T9{rO>Vmh<
+AfhM_Xu(]|Ng0*=aEub1-EpL>hs}}gUvF/
+~-,R1gAB[[ua=`a's?obiic}.&#@_*V)+xaRY90s<"t1%~8F%}r<(B	}ug_azmHke
+ND5g%!{Eq+Da"2Wzh$we$"_g<3!5Ls':E~7@	S[YVOq>g'|.wO	~s.HCp!6v=E^>\VC:zX>*DrVbYi!
+GH|';"gYxn9oSOd7I:<E)(SS#1h:A9B+#-$4gng:e<g /Wr@}M]=ydQ>|)6;A>T+s57m/[j,yhiI;x+8q}h7MdG|12Z<CiZ?<2]OGtW:bci;9K2hq?\gp3_18g^mEu@/I_OK_93OJvxcL[*	8qFo<B/S<-m/Vm36N 2C'M;vE1`%m^*}_>R:&YHF s`1[[>|/pn4csKd`&1VDx:OOMdH1cPLt}>k@Ym-gtf~bk3p
+3<Vw/ '6smw4]?a%?8'H[u!m_?g*u/>uv6>3kPG1&X/X.c@_<7]GY|b||2LAT*K[e}(!/N0V"o:Wp'i}#G0.?y1'OFN!c.M9^x#yi^F-g>m	%mK'rJf8GXtLd,;z"1D<y3f7ZsC*m<\Of?kmw=KnD;g%7\[GD8j;CDpF XV_/t[4X-:^FR)J Bosxzj61AR\[;?ksto6tTN)It,l!w5l;?zZt]6g8.OSz:cNM/~g?3}`&S}m^/b{`x37._K};=m:p|K
+bX/`a~H%u_sX'x%{{fi%	S m|_Lxv,8c#X$ixiibV<:49%WvfGbOzw/F>BumPo*J?`>g<Z-Zf_*zcVi`8SFNyNB4khUe+UKg2W$|zjdoNqFV3kbU\JKd9+/<.Uje$n6/Cg%.G]69[1^jpoor[ioM*I,7lYDV>Fc!f~3ToY?:YD,r^Poz)|+rB&,_~t w#nD@K&<zJ^(yymWS? Uu5<s'03RF#S:Y	=~r/G8b.u#<xmzK9J/'$%7_~[{z?_tRihgH^xaP0kDglhyYezFqy1vOR"}5n	oMf].
+W`m{4m?7&.~_fH`\[ qY9x;o#5r`7R#GJus5Wyj,l&Lppj*1OFs74gm~A[l#x=frp8*5g72aH;X7Q7~*e;>~Ghr:=]1wr_DEy0q|BiU.R yikM;mpnunx^	96,3>G^C&~ws~D=h|z&dL8'+Q~1:<+:xF[=K-/J^O4u._2yfa?b}Y+Vgm7TG bp"g}?(;=6LsG|;pp;	A;&<cwtn@\}x#3Xbr`
+E(=+O!G&;A{;oy}gmGot_6cg<U=ymg8[0l{,Ss.?(9`{ZHCm(b|>73gtkM/sW[*(w5UN-#G!0Zp.EB'O7#uX?v%2;xnZ1n88X|2kz:{z1K|8Riqo68	3kc- zlz3+|?}?wu?HE~:1Icy#N6gN?iAx}#jb.sCz;cb H;OieaXGS.VYXH,)RJN8;~&J'_
+gIQq/mj-y~=g88&sy_A 'N9PK1YRI1LNc,+FN% ?q3Hh7C?c]wb;sk`9'Io5uJV/-sOJ;:YgA8qoQ/;q 1~E/!IoWm2phmgKg6IFkQo;aQ8eOl9;;uNZ3?Md?K^2ysG=XZ=&{
+SsouMV&~>3?Zh_lq9oLGaLnPMG16P]ckcJ1}je}~e2_n/M7%M&$;+.JC@S[whk[1-ba^lt:zHm9^,mG/a^%3ix- ;h39-/CD?=f9<O#TQvr1Pq\$L>3@~eF&yHvB[O{pRy=:+Z%zodWas9ldkDus}sa~0>Z~O5k6b*fI,cj|vb`n#<_lV`rw9\2..L.cp^}iaBp2*SAnNg>q::'V/PKkYS9.JVU^|cuP,P6gb|I:u{5q/1~~Owt ke:>iuo3WLG{-]7Q]Uq78[?PmJ&jeVlyot=g:o/<iTm/}:i=;3:o1W:5-*G:;Ahk:p}0zHoyv7kwzf2{?8ogjFv<s9;%l\2
+uk]]oJWvG<k>c]~]yte#t%^mo]+]yb\y]{>qhcM+HWf]JW;]y's^@b|T<{O<Gc39#1'_4k[UXK'4i]aZUM8&R/M{MYEWXv{yww:WWEzeqBEYy8olXF5)YcunVkPpG)058nu~nvxBe
+llw7i<mkz}e}"WG>{cR	\MY0Ngh\q&~zr5:bq'X[*~?W\2Wm)?V/`c26uhOg"_>hP"nbLK52(sp~b
+ra5R+:An3^9fST}v+n9WM@
+sWzk^+Zd:amSGD=@|%r\cF6 Toh+;ALsnIro^6xSM5+F!P#|fj3el3SiS^ztG><x"j:sa{,:ZoGZY.Sl`<~D%Gp-7Zt&dJsXO<o/_=dI@i[$ts\NXokF#<TjF C:g{U/}C7?)r'@m}&0_pf?>K|@ta7!]=Y7*p -]65''1Q*~{I_t2}/v4MO#>V	Mqrzo,zod}4XQ1X+!7~5YW:.cau[A?/e0e+vwOAp9Be #5+O80_)#h\`y&WCG?R+}(|+.O^oWx<gfM3
+{)Qb\X)}rt#b
+5O85J<:P:s1:AGAH<t7<yN{N]y(goqD[bN-![.w _nG&abH=VLjt?| >~w:[qz	1}l @CE_9,}gmd~]
+vyronG*~XxOi,f53wEhq,_Z:p5<8AsrgySn*:W<r+{+j:h:vqc;FXocU z [LN
+tm	2#9=U ;Lr	~|BOuvc.6t@#~RIn`zsdV5{*
+u+>kqT:_bD_4|rZH?f45R-aclWYI~8D$/0n7dHod8E[!k+_~j3'_&kL/fjU3kXv[!]7zbtsL1qWLka-?<6g2a#{<7Pt(y1~]I0h0}xER0{$&_|M6}&:(jW41N#meqkf^bcM/:DMVKqK.^o7'WN,9Ty9K1\hRcztK-][p*nW@Sv7ZuK_
+n*dW52D>H~LKMS?QS[~z5gy=Vl|4z_z,>5z4e+q=*cO _|vwFv^;^#^|vg'kAc,$}J^2k,tlq@yoa|+u\x~GY{y;`r!I[<19~uxKVkU1VL&2Dc|]B3m\Og
+5a>VLaWkzY}r:|yPa]|z?v#vgtou9;wh|x9sq>e;KAKA:\fleS_73rcr|?5h?K})X:@vc2^E0FNuFGwL_>[NF_[Zalc W%vdV6P0Fpo3Myr3C_qW</L_P#cvnAG>\09;=3Fj@9Z/c<esC:#+CHc~~y>W-x8_qiO7tw~)0;T]Ichmx:7tU$]J4o(^58qn\Y"sJR^nx37mmqbJ=AwmzpSiM^t2q9i30qV:|%.2O-q?)TvGkVycsa60 |9?sZnsOwG:Es'-|8yA2R}/es}`l]*>$g	k.39lkLw~ <
+Uq@&{!_ukjl]~# mu)}m=7;ZJ|QNdp\I7dEz}nusAEw 1shk%c3\n:SfD/?9AJ2}{(c?*m%)sm+qWJJG1-o<$n[XbQKCI*4ztGkZq}qQaDKIBd|O7,~<r`^>1U_5(cLiRJg8Q9 ~E~xq"f/V	]kW-7q9[cF{e-9qw>h%ItyasD";U/hcK%\WRG*(n/ec`}:&fWVb+h\'t+7NIj .\RKglR`\mS"39t	0s;;~!m:N]?0.?l|_\>- W>SA,tg,jwa`phFO>yc_uel?V-*:v$55j
+tw1?|f6)v1eni_T"yCmgwocZ2ic>ddc6I<61Nq_M	n`]m"{{_?]n	u#q9s<7>k6<o>etd!5j/C/L=WoqC'uVKvB{nKev@?0g?6p$=]<5Q';25E?E&'>sJ$5#2rDO_35s[>c*~d|)]rD(M@kL4Z*>bv/pG7y#g:#H{skwYjs!cbmgMW6](2yy&YzU!9=r7R9	U_q/DC^2Z=$'W1GtyekUT\!?4t:h}_Up1o+3{$z6}d-\DD.TU]4<W4<,|oh)fW?E5AWin;`_.19Lu ,>&jg~UctXp6=2>~V~~?:C?X*H>t\8o	;-61V'l.1Qzwa};xnsi%`Ue
+/5F94=::Z~wM1x'>
+U+ v_zgj&I_iMa@?jncV~a{MVA#2p+n)]tGkQg.xc==]nez5MjvL=.
+quD>4|EBCsBs-m4kwQsW:`!5,V8xvSm20}<':k!f~d2Bc4T$2+p/xSU2&gr0<[E<o/+(\Tfl^<r~$>pL	h2u1`!\o;!Y\mg1g,iC=Es}bLGow{-kn{!MYv_Yvz}w4Zi_$V'TC_Uj/:oj=_=^YF.	1O.g(@h'~Gc-kW"nwDuc38*&t}!	h+3H<KURi1z;:^{{el|O\/VcYSx{pBmPo/ev\fAtWkE4#K|^/9WnN|cC[7oFxlZb7Q=:VZ
+Lb=\yoCsAyQn[c
+=?7\s:=:$OWGx4`-W;:L.=[j^iwX7UP|~I*ZN3
+nyE298dmF9"C>d-^WNga25;OopZ/9ahg9i?\MeyqGrvuG]<L)e~7{X|mGbO$eWL; N`;}QYNK4uG)zZU!+uJQ2Pxd=kq7V EM_ggrcq9WD&t<xFQOfW7--ty{OB}9,;-zt.<7kv_-_7Uq!ZinQS"Wz~cYE,!p/z^d;q.<9|`q}}7a_,w`3;jn]ef3x/,o!5p:N\w9wl<s2k1k7q]r^)%/g^8T)n7}u3x5}lA'+uxw0621aqn~N{v0eN91GR=XkLt/ aNY1j\S_
+f;%nXW]%>YcK6Z|su?/S%@'NZ;^` 3G'G<@y%l[/[ws>/[^u/N/s39	{>WzXUCB9 jZg-$t5bc2R!EjTwf.}djHGWPf
+<!\o58;5Mg[oVt>dwTwI.?p2GO}Uym#_s+zHN,g_=40h;%{;Z9}z;O>LyiwXea*Lsii9v||Q!, ,5/d[5J$WN>&o|2#
+Ov9>g)|sM^C{8?>rx/z}5"S:>M"f
+Z|?	z.n9rOLl?~<vJ;ONls/'2uV-y0>|.v=]6G#SpjSf}:YTA*p 9Uj{frz8wE~y1yf/Uh/8V6mZ\E]IS?72	|4/GXEuv!TKgnR~x:sX)-?Svp|~kZxS;HG8WLz+)03L0prT/dm!W?y&<7"@>|gHC@W%	q9}U;fq6#Sm=ZLuW\ThR~vpr[nn>+I8Q0qz]}U("o@>KSsCb.mb=?PO+<p1cO-Vew5Sd,d4`\byoc0A>6v~
+U!c|<XmI'^W~mev~2T+jqa}w!.>~uq{<yJ4ht!Me}6iN{	D=J?5'/K{Z2+hg~ `Q^2V_vvgH22iAcOgNe=6/v]i,1")3
+Zyn4{KbHMRW	ZAM]cH^zjB%x*%gx%9r/3{Z~J5ee<OPr|"C6%'WXbi]du}/klSrfSRzTcNN}t`7(/m:m%Dy63Aook_m-f}V<[YIuy)84ts`q	gC}\1ub{B|q"dZ3	3M61'SoG]?nQW8_g}Gt"?Y8dx3ejkm7<-xc(bU5:EOsw9/LU::o=^UyO
+f:_T^[x[pZt|KXIF8{Y7w=wO0d*sa.+*N*9%Df8?hQ7mf5KbeBMky_L8$7uy}P7b;A14+K} pgxo,; 5X}55g&8c|An.pi:7RDYxk=ke qB#sXSWb11wunsN?7L5y(s3C`)5hK3>D9fC;<k5QMH %zpO*z2+F5_\
+	rh[|:K1CWI3?lBf^1tf
+S[ZjX]Xnr9L1|So0c2wb!]kpe\v4t2iomrf|I9+xi9s/ ^N:`7K	wxXLLS#BV*o&;y58Ci:?e,v^d;jcumw'mDr<}VO=Gx3a"7GmAC>0>H6=PE{Z5:}YA^);juwyxu9 Lum0K{JxWL.H)OJe9VP76b	[<.N:FG7+:ZYIurQ;q]sW)sxOrsL8?i+1r;1s?"~G u
+1n`qF3b 8*7{~~y8swA<A1{O9^alcD>SJ\i=6mBeHXb!-]NhvOy8/=e@UYGq:IlUtTZK:u9sYs(N?F&9(R[;CiGqp$dfl	Gd:K3`,XG/a>rtAa$eO&1DP9o	/t6R\HzneGM?@.K=Efik/KTCUv,6+1.
+;oL=!ag+]OJOy\[`+b<[j|xk1OR_s~TSGLK9\E*k\{oUSxI?ZiO9{ckt}!4q:Y<>@&^cq9c$>{E6~mt^9 0fj<q.JqqW%
+/y>%u|9"M&zW+aOl44os?rg>ql-Nv|<&E>u[jH{T5`
+[sR~?SjKEzT=h\r/{oo?wIr4u+n#h$?*f_Ys)guvxb%Q%!W,c9UX#~>hW>_s,'s5')gYixBNc_w]\bNn%h^Ml_}On6[&mB9g{%$~0Syx/O5\#,0nm2<@m_ymT
+seq:v	o\2y8~;erNzrp5mTk|->`A?iaP<_:[O7K	wcrG=
+^1?I<Oy	>?s|9GPibllmI,hop(_Z.y 7ch-O8m&13S_Wh_M~|r]'`K9)G>YSuHUn0g]zM5wmWA+C]I$|{T?'FDgug/^g&`o]0r4!/=wPx9't,<EsFLhntX[/1a*KEW= xve(gQ{|2sr7j
+D?||oyo6aI'urin59Ij	88Y<scQWhB0d?<AxnrvJ|9@h{nzJ}b{w-J?W;{c N?mm/yNe,-i81Q 6237iF?/Vo6mCKS_4qi_bf WX_+T50KZ_D/&Wkf<a<F/'1du{%E)q>>_B-mmTFvu?'LCoL2cmicX:xKJ}k]Cng}_>cHd;Ni4lg7q2NULZ[&w3KC['j<#ZLT>i5=lF?l-p6oZkXZpS=7vLa_'d.Y=lgKb{Y~x~><kos]695_O?=Bx'sK+2?mT%BxL}'-q~Ei?_I3I]wwliL1^<2xFxu8VV8$9
+UY5sn:'\{);M{p?:mtzw$&87w/{AC#	q7VNi#]K?s%~W<9zzq\3:L'30MX;Odk#!-[wd	,`3c}ZsB:KXozO xb~Z"rH|i7{wubfzq/QXwF,cZ}2pu\L}2u|&}%Ef)sq#o)F]ms+_Bc;,Jje;=Wyo@iy>Qke;vUW94\-3k
++} *(kj$~=}ZsA#*;7FNA!S1/yx^P_*c
+xEW262cR	P^Ug69M\On3?^Qd<E>lzLf,{/n1n]xf(>_9_2E1VxEC3F&}RyCfLPq\|w*22xWtMv5Pzwf0_Pq`>aa[@SXGUs.f\ -\goue\%8~ST[ji#;/\jyg9?t0#ga>/HMvj|"fs 3^#km&W/u:?~U%
+QOys{I=c6F&yjX"nTswiB[MJPhc>%wc#sS _y{7,!?{iwsg(lN<{N/q^;!3^-X_|{Oe{p/u~aaCroSox7e9P{mD>r:SAoKio]`w6Ue[ekm'}&}e.tVrY 2wvAN4fc5	'm\^%>xnEs1 j>c0`~1K=*lL;\9|VXKw-mMD8?q/C~TsIwOtogiunXkA ~3&-Q\<)g*/xp[=_*uR~ v&<{Os39B"8`qR0cGxLt8MXkL8~SO=>s8E[XQ:OEWK{rZk\r?Y3uy>${5?u"K/uW?7/wD>{+D&t|+JnTo Tn>jBwmn,49?tTK9Pophr&<{M]sS#9LE':?a{S/eHC>PpLn?f?`YNuY=cNgYvoO#8"M=eLw>&9=@sDtBw>qcY=>['u=Z<_)!{|{(7S:~}J#r	zgc C!.d^LswP3EteDf^.8;$&!|oQ*p>d<^e*ckQ9bZ9oI{cN5wslo+%zwSu1C%~]dN>~OwG,k,kvg6lr:8MZk9	keol2x?5Z]NJZe1Z~CG|-'Z6_2_2_&-,G_Fz?WhkZ~	i{-0CJL`2_B\~h}/MK]a3yb%._k
+pwr2G~fpd5tk}kp'TH^B='#70OfF5
+7opBH.d2KPA{knY ;?b;/c/?f`c;#qG|^L{>g~?xNl=3_<sG`AFH@fEM{} NM)\/v?NT:p[#%L*f*(n{oYhOGby7=oK:t#ZVx[^F?b>/K=tm\~>A"f0;hOG_AxVU3I?>'m?k[06c|ut*93'3e@-2u$TFc'P<v"y5"<;1
+c;c'T&u8N-eer]q/^5F)wE9 "	.rCK}Dy8&:E^c}AAm:WJO>);P!'u^UCAKY|@M^|K8r|WQMN:g;eZ291j;pjbff'rWd;M{c$V?ekH}v-t!bhD[Ga;yi/[Pe0f6sw+gx?&zLak{[:o*68kc.wM_V ec1?c1R{	Oj1Z@<fRK[/NMN"Ng!_rKU9vKD#L*/*DpKCsMz?loo{v6$K=<7w; BLdn3s5_b>Ea}|oj4Q%gw]"17n|_SeHm
+{I-p49*,y={G&}dH+A<H|p+?j (Q_m2Kq.2q*wM>{R6g)\\,<|!\+/;?Eo:x&UPE?s{Fr`o:<OYD}S!s<_w#>/_pOEGsPm|nZ%l0;0oKxzG~%k0}R\\=c[_92v3*72%f>P/D";f</hW]$JhSfl=7T_*%K4^r41jM^A	rXsE-?Hph$1899tf.OV=?+e_5	rn`(g}/4{a`wDHl*s2e9WS.J_nfK\E0]R[ux[TYv]5y9
+@x^R/85'_Lu+o~Ux}78%R;ml;~<@uOUD*Z>kExx_Q*X*iwu}WP}M:ppxl ;`?!b~_lM<VO1s>'>QEKnQg#jhL6"c3fn'yJny$59EF~yG</,_KVtS+X#fX25/zMCTk0Z~mn[wN6Z/{qn`B9"We~0Myp6Kb.66[?{'^eiqL_1-1Ax/
+|O`@`o{W "17uJ9r3?zn`4*M'V`u{duueuXf%G4gy[/O\ysr8pvEppLD_<<<Ozf/}<aWO	>C~\*7w[%t^'w?9.2x5~7gl'se&4LWCjK;w.xv7C|10VE-9	Z3$GJ(yJV]~;+N|VyEVJ`r53l=C1~fKO46K"1I\XmU++Zh93_d\>gRGh.{n,c"?J{e]FT3an%kVu{~{H?$Mm~%k_t?N*6"kYU9GO>R-}p;2\UoG1j<]3H,BfY')(t$d	3 oy{u.Iytu2pi;njcj~0t]XO<Xt}yl<zN[Ts#Z7_]f<q,8#}?L9198[s%~1!'E-]p6Q~yipox6G"9/_FzV\Uu&3v{kq5&*L\%x\U?5t6)4n ``)TMbV=G<=Nsk)	Wjm(ERb
+V,R\D=3&4yIh+?<<3uy_~L=?I	mr1puEI.|]+Y$8*2#>V%P~QAR!)yG$/!V8V<+Y!i3k?MjV	ZN8J5R#s\KV9]Y~~6#uc6]Srb\.Ay?-k=x~Y4H1=ZsmIw(uM\)8}:'<S11=JMaA{q*z;	vU4kl9Od+{=oHguQF:!jHE7OwLl	v#">D5v~YgTWGi^0r7	lXcZ! 7y"WZUnT6yqdl;E>\Lewp90OllYzE9{7#G>NJVR`/g$acMo/%lp97	p?j4{he9?.-{Ke/*7(+^Zk,j)k5gOSG48qC$k}Ws "2=R-`rQ%28Mj~XH4?a<m`q>b%9TfO,lbzq=3u,LA{E= $C{|DiZgIVfS]_p&W7~2G0Cu<~h5x`L1&LDq"9+O	
+]es)R+EjB4i!	U$[B:4cfs^qpa2o}+o2p:@[a{A2VP(3!7]7{Um
+;,<k[{VrQ\Z^\"lAF	Yqg3V0@hP5|o|=5zQA`p/P(Y|,c^!%&!iygfkg'6%=}Vz8iL8:6p	Yr?kk/{+f<5}-A_Mks3lp18:x/}Gl*bU~C44|'1o2`84vCs-d$>o|}~Vw^2K;!-3`0lx1p.M.9E3G-M"=2r=k }ND;0picwx_XKp" Kf}=bSsH]~?&s\.Qemy|_u\;Wj	h)1R\W>m1mQ8\TD;y&NY3xwA.s8?2A/K\,c?\uG_!bL=_oyPZ,-&V'VUj"A|YSy_}|1]7qDYkI\H\%+ume`X9n6LsY8E?n~}
+os-hJkOcF{7Yh\!nIb<o?*Xs+K+o:<oj 2q8qt9#&qko\R/8
+ArG_Z~sytXFp?zjY{_:ZZ\SzCXXght46vc9;n|pn;iu7glgB?6bA_|CAycM?9tDj9EFs6D)nPhZ,5?GYv}QGrM#X~G1os^Gu1w^61nofmD},q+fS}O:A@Ysg$4|} 7\x~L*,<1}.TUN)1^!ud$.0`V=ks|Hy\rLR]-^ekk	g|_y2#>S+<|r#<#DWqKY,'e26a/ Knmy/sAoxN/yK]?Ml&|NH^"r!{K	9wEL|qZbuCcg^T: {(Uqwq 7SYa!YS3
+},tOqn6,95<~+U#m;0?[	Qs m
+#=f
+Bs6E_.KbkOrcM4W?UO{Br'56>@YQVLi:WS]cy{R9F/.LI36=o2Ls~>5$&<Rqi P_A:hDOWL|\9kO(<]9s:?";/7^@I%:l[yVs2]",|>Mh|<Sus:=9 s ~u|y{r=(E8c&+=`yd^Fidrm"q_\^z7qu7u'tMA]dz+_c/WK^:qOoXAU++cntFd{+4@1yP2O796QA0|Po<3I|aqN9`?1'xL 1,5&gA8?+bw#f?KD&7#8WjdZG1	v:T :-x8?uqR9Uu3ky0}(V'5^>Hd'sPdSy=^/uRi=%AGdky_v#/gBQ>=#bS:$jsj"itAN]Wnz,qXf=J'mE-/uZ~CPi}lx0<(o%<3n620*|U)ORYCzI^oxE}0$tE:kj:MX5[]?4grj"iv@rvJk*k]{Ud$sFE5%1pS`"rC&D'%xr4MB1z0c2xuq$<8,x3SZdpMNTu=a~(:gKi<-Jsc\#i;23DCg9sj?^y {}|g/_%
+K
+a5?D$%_:B;luL\!k[FkA-|35/v:y6$y0W#%} G	7PpeWY5d
+'p>3.}|]' Kt'zK.;ecnv0gMUm33t"w^vV{sc#xf<y|yBO<jWR~S+~2_  LWd:2FqMY-nuNbwTy?]gXHqn2EJw"w<;cGP5G{-j<K6<zY5^gD[qJV}!	'HjCuh,9_WKgzw9[_/5n)],6twi]&awCVGj~\j2.>?wE"(wYr
+%o x~NcWHzy|_rmvGbmp&D]^%WsbO0v-{zfn6[m-{kG
+gR9*W,O$yv8O>qkr?Y$z_k+x0_lR%=DVMOclq?ps|B<%{wY)
+\}2AsIQmju).@d9;)yCnzYTG|lZo16|Lw(uq6?4i`>)Y+zVp0E
+\mjyN~TVYkvYOXhCgyV$'`6{$|vSk	g`ZDa\'D=	cwcNi9#D[r	k#vjlWHa=F<h>+Fwkq8vd63 >t1 u>>8ujd}x<IaOnpBkFml]f<w 5[aq<!WI;JYxsZFj`vr:u4mB'Fl$^9]/>iw!ej7Q!YMWfCntv)W7)32sod:+=VyNp?Xl<Q@:Tg->y?a{|W%|Mz+z\yJ|l~Z9=s/K>*|c=x|:wkh+5Fr=cZeUxkr)g.Kd>>,-og9%Y/eUnY]>?H;N,:Z~+/os =l&}qdGNRHRf(A4X%~1+u}Nr.r5`08+g%rIyZsnm!LKwIu>kAJ59:\AC-qoq3OZ_5kB4t}23_	m8lUmt\Gc'~
+v C&~Wu&Ed1enC:=ALKmI:/F/ueQ)jYLMsxYtF{01Ne2@kq-})FykWavd"<kk//Oy&28N#9y~v_,b}l}yzu<;Kh.N-F#X	XUFjqD3#7_DUH|oQ'Hk]c$)yv+QG3}_=!)5R961'_V(S1;yh\j=i||zx#z^CG5t~+E|8]	NetK5G|ot;h$DW5s@m8qQics|x:@[|)V*1dtrWK]}K==[8G	KUNW>7{ ^T&U(/Z#~zxOrpp/6QZ3=(Sp,@: N.` !K*+zMYO WlhMC<g/>Q=kG_K$>f1dzM}%BMMO^M$8cMA>ywZwx;eh4;C_rZnvHnf0&a/}S-:^_SP]=$q-]1eMu+AG -C-oNG#FfS2s+ZT8 -.F}|DF4R'qZZ_r>rZ)4=#UK&s~UF>_<\>DEmtO2Pody)wJtN>&EVpsd|Q%W{|y?eGg`rer>F9Ao0r~	\-#(r>e{kYsoov9GrK8wc!h6|'V}C.vI=Db7\+<C^re.M6%F>,5gK>$6]K#vk,|v(k#y<K~g">NkKMrtn`O%|s0tfw5OO[ 2hk< 0$2&8=Ql`Som12:toH.bVK^?X+N{ <|/=y'?YR1+wS;4E%}eCC~`l,sX:u6Cy9? k'O/en6~ v/)'#$Y8!{3mg6>#Q/Do1_pw[T?py9O_8wj<>cdxTj=Ai+FG}EIGC[Zb[S;qS0S^wGYv\_}I}Y&B9o{b'}U#u<_]vgPAea]3%JnRjU.p1MoI9~;qCw5<6m^Ly\mMPm?cqVqvW+?<r975,9p=x5qall?znqjaLGnJKL+}7~PZ<.d%}7r[5+u1>#9GyY=?OUg>	^y)MZ5h|1}pb6G@>zABJs/}n&D?3hIl7yV)/k?AE]/Z.2=s!X;7Cbyxx;'M^LjOqGq ~hf[2zzk+XYq*k6{_5i9Ms=>0YEG9~l?,C63osGmnSAz{i.^N,NgcFC^$li'n{7`*r\\O9]=o31ypRmA?Stk=5&O{_YD=%n(UDW cvGSy+~QF?V(wifFFgzQz V>o}"inOi9s|y{now8H8IcosmTmfGHbs0nLjvsuV{S+=o!s:dk-9]e}ZK^"smZ,z#kb|W|wmSo&}~1_n*yP?M?kUK;^Ac{1+Ql#:`/*`1G"i!P>#q35s^T!~pqSW`D}WP59:\u/r=Mn+tO|T.iueUjT5y{tk=^M]]wIK+w/~z<c!IZfm.uJ5't9Ujp[|?DOGwW!{B9LaOqFW
+pW Z	:6twS
+Q}%ezh^ArQwtb~i9[	QIz.xkvu6x3$-c$!T1gHBfYp"aYyl{bWr`pZvX1 vkufr3Zy
+JY%~A}vu-hgtVc<xaPZmF:
+cmNjNLREysDi4VV%^>b\w'jXO2'v*\5#g38}nU"5Y
+~84y6aN>Q9k*|-gm: 1k	?72j?5_eJm^i^OOerg
+>k^i,}1R7|C|f$Hmh=G*<+vz|CU y^b/?@| ^8c5-!][q{8w0XQI/H<(]st01{noht&CGK0/m8ye[3=2I^&C]w|e`5,}%qS}gdle8X8b6\/y58m-L&Yy42?5(6ggn'K<Ap!e,Y;o"y`k1)YRVlwOnEg`mW9cfZf;{"li/.u4lYtO-Eu"2/55T(l$i\>^(,O
+34c\[!,(jBMo&^]%_~W8YNuTqs,_#&O|uBB/}m-@>@9|Mld^!4t9&zxFqX~319NTKl2w9X9GKSe%6YW+r&e|ku=e7+{<?d7~%QM(JR|>8W*jo\.j~5<Sy/Q1{|<ZpE^:+Ys}ma`x#VC`#p#M?}69|LA,uh>|s.>s>Cwwyn&=b91\h;cs$8 nJw}9w[c#szmk.cl/eYZ~~ '?&q:l'I=*~/) v_zHYYO[s J\>}8W88 Jcr>]*8=ML7|\noWbni@"=a\:HI' #;rkx<PF=nr[rDU$]!*tl\{56;k!C9	}P!nFok|Sr*;O&/k?i7Vj81?j#g`<Sz5|< e\M14F7#<ao9v$/#6fE|mEc]nDyD&||0M?nZ6|#*S7Pw|u6kNyanr>O|	c>1&>q3w?7.2yfeFW]k\bxopb?N+~ 1gk{ypcz;ur-*ya^R8T/5q7v>(*7/1Qk6J"/Yg;Vv_Y9O`vm/Qr-u>6"\}L#Y{s,c_z\OF~`\et	+|:#3PVW@n5?:_GH|yMD60KK(CITOn:0:(dX]LxSf(J|!WRFUtT@L}5:uVRrPwEWmWbG<k,o*}0	uy$~h'}0iW1_vS9uJYDkX/Z?CYlwPF,y|%oZ,;!2RJ\k<z6CNG-BU(73C[xw|Oxwgd,v}D{~'CZ?-AV	\/~~C<)4>y<O?}GnARejuXO?1<G1SY[=
+I}FP:amwc3>6W9mYy.>agr;r>5Kg8sxOJb#9kuGY<iq8*3rW!K2F9q_{'@Mc"d7{S	\U_9S81VnXf^5`^yE_/O45M&<f]C>ay|?HVFJXjSy"mo/+9BSs8wEuF>W]G6P/N\rXy .GY+~=z6vf8=Ft5|s|X#fWZ5SM5qG\5fPsw.#_&ap(_Jl^~nvroX<>:dN,jqV-v#(|c5:Ao*)Zrs$Foy3B~1aYs{`E?~9a/kV^>HhkqE{[W!5\\?WWyCqke$
+GJ }6	:	iawDjo4Kl$;G.~+:V-r<'?^QWL__^jHa>8|l;3na	LL1E3Jp93:3'y1OEL33Y>Vgwx)~mfs}y~L2:=>St2fJ5wIifyyFio+a?`aXV-F|sA|Rwc%=UG<?j36-eram<-|vPW.\jM^78w1T[]y.Ov;qx\8V|nJ}6GWPM{;YSX{9oriLA
+|(sIF'\3-jL~5J?YTP|T?|
+;'[f>:>m5}p06I&;(y},NxF#d2<Jta(xmWcVWr-pW{.yvo	dt2u@^C.3.$<;y0+gls5Ju[	tndmwPtv<x~w?wE{|W- 4+"!>t-Ws t{y&Kh+<;5I%&m	S~:CQ05?~3wsUR!({V.a|^kr |6zM'zq kq]y^[8)f5IS!g3V0?Rz^T`Bnac)u:^knJyJGEONu7$auJP38yFOYy{{C%K,~jIj5tO
+=4<vAgmnGy U9x4x3 +# 14/s3l]c|(KRh3}LvgXIu}71^qt>x{M~wg\"4?kD?C;D|)&{o Fc_uS| i/j&{,of0=lm an+Sep 5z5r=c]y3cwI?{E>*10oyL-rG&Zh
+}l|omh$uG:z]]wS.u\V oT'!3:hb~u6Y92y;i h	N>_;vK|_I%8s"{	qbzr\72x2oG|H/4~ytyr?}7[e,!<{/oiv|x-^5Z?xk!Bu$kJh=WJC)|j5(pJ8IwQG<K&(cEP}3z~uU_/~TW#;r?;TjtUGU{WQWU{4]*jV]jo+!]UOycz,>Za>K#>$yC!p>)D~9#GFc`I#'}!Ny>:$0oHPMc68{ge3|v;%y~+?>c<Wlgmwl~O?8OwA6Bfkq5c1q	o;slQ6mekLz6szcKszcwZ$% d^h%F|_1ALumfw]TG_<s ^?R]MNC[ri'C9x&W$z%B-:PUo_bt	]D6/uh
+|ne7Pw5>+G?.4:uZRtfPFY8<<sq.y	#72z<LwAN%<^E=s7%~c|Mkom _5\DTb>Fr.P^;^>:jD%9lr[6=!kc?$o_}r1	1GrT.?kF9MAHz^}-R{pxPI{s_b]k{`W[*Fwcs;vuyf[7n]ANXMtpnW63z}').gbi{d\<'$R#q,g[xfs3#ozQ;~>/zQ\[|
+8Q58 hQ?G]i_9y-/-6Rgx8"L);S#d*W8F/Py??KY1n~y&J>-Z?H<#/LaNi595!~Qucp[-c^5
+>w:T2?x;l^zRn2oy<o
+'^kbG?`3MzR=;CjE~T5In3kuMLmpz(A>w*}18m%c+c^8&;k&s)dLm6-l F]`|aqQ>YU|yfyy.6vwc&w\p|\~^&ian:PGMN&m>Ik5e:M<~?(hZ-T7<q80?YF_>>bmifus;c^~nsKKws3G2mG+H;47s,&U<mn>jOc{h_H4wy)n/:&\wgbL{3vJ<anmQRkX~o5K;&]ir0p_RMJ|\v8{JtG@7Gk(8Ckg=itV2n>ygQ4sG'=!IWalH.\LWM;w?Y[b7RkUu.qG$#  ,)!7z 1U?=XC*"ga=~z_VSR.>sMZpf|0O9bS5>OOb'{Go3Sv>l|>e)O
+BA!me6o0|l{G4N@&O~ GYC8?*<}g|-Qj]1v8}G:QuDiA{o3K^2X"WclM1nKJu&H*MjkUVXqJ`IXd4,HI?,	Y9L2GI	sb2\pp<j<4g7+k?F^y7^My^k'inV{\mEqmye&q(Gei(fr*SfV)_uI.G]u:lw{91F2&Y{'.+de/"JpsIEfy]`iEq}CQZJ w;~Nw7	TYen&^[*L"4!>^!myX]^%Uwjq hp80jv-Rwu)3qIg^wgc|3{V#=^Pk3F97yu?MQw,c]A
+V8gWOgo~Nz.#F W-6Wr5tw?bu]}.rB9r{h'd)Fs[ &WU)2|<pS(ey=%%5,qna|@U~za5jXho[z^Quw|_W.&1}Q^)W539}]]ku]9<~Uq`M)W{9n5+Gig6l"NdjKB?R_C<83'lz}Yy AzGTs*!M?[``t`+W~.vp8GnD9*&]9\2uY[kuN{F;zhr\#7|'zWs9D.(wPZ^Sui4sa35wOI}5tNq.3B'9z;?P(l!jb>6_m1CxCM1i^#%<zteKubOfb?X[f?p|a(u6GwNi?~;c0qSyn 5m=d{Y}aY[1n\Han_ NFVE1nO9~j!OrW^+P:6-f2|/\OZ2z1}x!y Nx1GK kC}xwY24oj{5x<<HR9[Cc"=89_{9~_20MlH9QjF&b ^2>n#CNIV];6hPj1]3#N_"ow~UK2T#6y$ "Smsgm_<<ZP<u*=wuHaD:tQb[}KI-k@sioy+%*twVe]LUf1b~p"=G'g~mZ?=vvvXUQI%mlryl`*tf\4'RLK-OeUj2<|o>em.u8&OQ{p|"m>_e_[sCb=&__NYZ}cQs.r~?|R_~;]-c2yBfMu#m/1_R(<C>;q[u%o|:
+V?q{k2Q,sKB1#Sjcv1Kl'&hFOOfP~=Yd{=1 {oCk`mNz39Pcr.6A7+{=-S;mdI^==`tYs4~whe;2_G:gc$bxqM?]<WrgziI~;~9Wwk{Sgvh=GDG:3g]q\o+]+M|s:WO/x:4y995up=yXon%dXs9@_Ql6NE'*8NYehwd/&WP|&56L0Pb#}h6=&qFgC|%W5}.)YU/y 7V<1iVGJgmr^o/ruJhDS]HsaN(~+uL>oNS~CH:o'3lYe/~#Y'Uw.g<Qd--\ag3n[+O%5]ovz"tE~.pAgqmDm=WRBR.bMyHUWuEJ0hYz^a<zhn.|{%mf/*~PXu;m&>bR;:rmC[XOm5}wRhWISO
+-2n^r9.\Ar::
+!_>YDO$]Lr(C+>efgw4>/LOW(i|Gl;cxGjLl92dw16L>hktv/Z[{j%TgS{kv;.s)O^Ur===^6`o,,'.4J<ZZzo)A'6k:};i#8liS{cv6%M&|:3Uy<~QY\}gpK5s'_S(|
+>Ou"fy=>R=G@_
+6Vz>%K6m: ZDll]j^7gG:U*^WBZ	kmEo&>t7WI$SsihHW5Nj0
+|^Cg)'Y-Bo_J=9UKU}83hzW"L,OH:v-PAX0g?D?*5mY}t89wwoOu>1]^}zW0y}ugAw?Oy17<:R9iY <!O9t*u)&K*]4glN~w4CG4oii	;{=kuu}9!igtLr\|7\gE9s=HLs#8_xF{2)TI]s"{16jDk <B?#%hE9T/?-O,Sl7M1|?B #QJ|G7	]S&ws"t'vR	odC4G5&/]EM|".|S-9	-m<>~eb^u?>+]z=[uf3KcY&gvRcZXy8n
+vz<	tdRx&UJ;xzx&8mg`Ucm5n-cwsw&Y&aG xohqD[x1a2l=]bk~tM.{=Z1XoJ3xYQsD~Rkj>SOmlK8eoaOzN/2{vK^QuEKLJZ-wi*gzIG{m	l_o_?a`:a.pbpkfNu%zO+_]&3Y=4=2yigx?9kUsUk1?t>4p|4m1!{#zRQS:(KsfVkQm.Z{u%ccL,P7`|3,s|]5+Jl832D|nUIIk{]/-%meE;\{J|\16C?o? "Hc}PpdcRgcR|_Cz!b:7!o,6%xm;a9]hoqXo[e8"BE_N?oOFTmP`~#3Ny`.gL`Id6A$WmRa	e;\a_cte	\?1bME}HW !EH,S\d9#zhks'znr:)xbM)D`n$.}{Wf_VV|}m}!Z#GXjAEj]kyqn8%<h[,;E ]#k9tyOD=C8}k@|pcOc~gcx7;1JTlS);12#sQGLjhzqwz:7~e`h4g>[YuGTjg]Ek_I<ILUWPGor7:Vy&zBd|
+ss/
+[M;s 6n7.aDjt~J?{YL71g>
+;c/G;cb,5cHHP/' 
+cKM|]Og<._v7lCm2Oij}Dd R(<[^[wL7
+v^Q3>U(<9Ko/16!fbWmtg%`lm1>qLec']W3+zFmb_{0H;9C6gp}9E=p{x_u*wEdpc}xnN+wWfLDs3]2]n5wMkpMjh?r
+ieeVQ~ _~Vu9=m37\q/>;2q]FX`L|kG_6htn_x)uuN=6{e[Ocyhax=d|'v733>,f'1>=cXF;~_VRu'z<Ot)i:/B[oc&*n/:Ghnp'u>\{Ba7q.	iPt4qY#5J|{iU\ i%t{ |+3yXptE^QV) ]5,_bFw-3u\yKo6s:!vh>y~Wmsi|GfYc!18 M+wM]KjDnSsOW.}C.jj87`#KiF{~kdN[wWDDomuCrX`FrWbz0FL_8p-hp,zVzJVV%6n>:2Fr	h lse{E?z}||/5?ydv y_k*sgm.uS&^-';r1*S(%?jjh~Kg3ltY)0LY}_DSmR-}[|%&,u?c2G)v9+#iR^znr&9o
+e`ej3D/<vJewy"Cc[^'9'WL3zv|tU]u1]XPxtn	~<BkNt{JEMv{'iXGGr|c,vCw	V$G{?kIA|B*hk=paTGy7Z	#IY
+2YnX-Cc{<>eQuo>mkr1i8',;sDne&;e=hC0*30j0<_3"~OY-Q~*p_$X=cOyqm"zj7mX:6rCwM>h3X&rV-:$e	9 2-8_6x?M5VjCO<%Na}`7i5P(5UnYt>p:*N:yJ,hJ5Zo]3T'^>qa8	VtMrDo<A}&9)%Gx{h>;d3oV+r;6YKlJyLgnZSpn)jhwu73'8B.-5sEXFs=^IuIT|uIEjVOsbt.9J-V2~}#jZT3%G_qwmV3idt.c[,"}il*wwy$fIbF#%=S:k#074yQmV[=mmPMtzp|?5DNUcG)'k+8n=z_c+!_Aj:ukCPN#(#J`K_}n8%zHA`@MV:jatu<_s[Mq\OyC`$7:&lx`zMx'p1>ho9Iptc?<>r~-Ed2 qZ4Qw$s|
+<b7w|^M#5U]Q;Y)* G[BoghKX,m~0H=gBqL=8;/8\O<.&g},6y'7_of_7\g/}]:?`*G1{#Nq6zV2WL|<un|XeZ~>kan8G[Bsf-(	o9DLzA5}y>n9ve~}x&Ox #/+k~r:#u6O1e:1|t&7Aj1}O[ c/EKbioxb hGX?wpwq[ce:l,O]?W(7^0/gi~X?l(yd%x./rZ9?nutD7UH3P6+z]5s?>34(Aepqtx+9`{yNsWlbfsi_+YBcWoAG#_}ZNhVhxj+s?vU-lC29n}uCAs(ah]Ufbs4L']kj[=z|7dw#oO+;X>`9GX~UMUuX"C8K\}[|kL0<gHgHl3`#jjn"/:iIIL }t:>cFunxd@d<(&HCvsT%	E~G|,m7=ts\%Z_6RewtGz	3:tcH;&*@#,[Qz/.:/3YoO4nnXG4y/sWH([fx.=Km^1
+{6kaZ4ZCS]t;A^r :cL]s2=zb1c^q`M<',k1-y [?FAIn/oWGHt:I?_rlEvK>zc; ^m#oo2'*/Z%yonEb8V1O2NPg+o<%Eu:7Jx1H[h&w"HLBa~-'9Ns}s$N~{\rw*/#{]^x}1=QI:`%.4f?w1"5F{cqS0%u\RV8	.}c:^6]z}NO2L<iej^l7xqL>-e>)7[rG3X%9XnB}w=laIHU_FzNtF_%{HY1}$4}">=ptIvF&:$N,ik:<Ou-+o 2%m
+owVbZ5^#-#;4Xi1/hTk394gn!'uw%c6yg'96z	'0<_gFL|E0|Mh"`Ne: 5Ht'Wq<SBkeU"zW[DKUQ[X[3Ua>56&i8I~7K"a{w~KX{#DY4|:>4g"h .,;\ZNgnKrPl"Us#97xN7p{gEWXU^eR[n?uyqqzG_jnSXC4g380m.RYvo.{?8<a }Nkkq}>&}fzsR{wZEfJ?5`u|7{2M6~['Y,gC=h{Jpgu*%fye>Ju7sh3z;{j;?%(xH;ow5Nv]kL/>KV}u~4;oOv}G}ucI_v:(k,dlG$tNZ+-+G~mnO_wnD]>%AC:9OYcu?^dzwl5xw]t}"yXs}~u3ESIxc-"Oa\7<3I_'4u]1>96`{^;#H}:zG]kd;2{O72;s^dq%ql8',\`+40Vj
+K$|.u~H:,_:blCs1a?v)g\}7_XrG(.(_l5=v[aZ*!>b|=is+g
+6AaVL|1U|m[Z.yF{>x7do^7N;Fh~5;qm_dzEAt;0?m44:Q3Z6g8 z5[MzkJuDq(oI[kgzHH_y6|o9o~ng>l[.b"J=KlUW^yj11!Ewhubg	yn#@5QW5<oG~N~G~=t LsUui_o?3}(}C<W!.5y|i
+k%}JqG5};sOleZ}1O<13b:lLuHMXrZ0&en16Zt#=a_}F|$>q+u~&!=h+#dI"<?r5tC]i~ySI-y0S]1Z8qDSOR&k*y',"Krhc%{Sy4~Q3Y#*349'Q?1x[.e})3OXfD5sP~3<e3iQnj"/'Gx^XX?>Q')F|t\b*r/O]kE!>569>=>1UU|H&NGp/R~`Mw*
+2l',O908Ih-_t$|~!]>cM|`Z`D{{x73SEw~jLupzp4^W~T:MRnu;-su6	{TsK|;%k0u}Uo*`^5K}Y3.YC^:k6xY-/^+]&1auVx(F1?sSm`Rk2h(c \@Ld_Vp<2{dzv558^Eyg|Na<^i^{#:/VXk=mKW%|DsESRs>R}9qHm8&8Z#Kv,dGosn*219
+6rN
+SO;d#|W}'.[M[xSk:)ueL[i~j f<:1^{ sj3*r=`J$d.mWNg+9G?sh<sHn=jLe.ei7^=t))L:8umw)"miv1IO5}h!*bjy_iucnsv*}bs?Z[9{ub"70.hWV,e#gjcz<Lqnv}FD<_>\br0<\l3]#d_FeI\#6>&`N#PJ^O
+~R\V"$2;xT/*m,'hCVNdcGlk7?HZup1gY[e3+n<t3rs5he$7YPX[LJ^3+sbLG@ry5N/wr[)|aG'	#WG(;FvL0J-p	klh	]<<'Ny=>.4<J\} \wp*Aa; +yDQo6	6<PM2<gZu{z'RT1g
+&9c3L#ul^kd^5O<J
+Cy?qq1i/gZ58	um7:a}?b]d_6nRvo$^M<?9Q{5[Bhx/l_ q%uw<}D2}
+*IY^O*Zs8yaybBCA Uj0F}5>]j<d\gu$ydr=q(P!U(/!bmA7B}Ww/%p(X6#_=1,@Xux3ofsO1FnK\O4s>.vwx/vxuVWJ|Z-rph,o
+qalhg$?mh(`W$:aoXHX~^9ZrkjO?-IO\pn)O8 odm3g@nAS#c<;+9SvRb;L@syZ-JZoWI[ 	8t{^t6'lc85ZXf6S,L7D;'h_~@m:*!}fp]jX30Hj!D;&~2Ke\,"jZc<\:h- _J<+q]_8a82&JVu13n.|u : z^A^9txC{u]+7F^Tw"b.v3X*;5g?<L3q_O.W2#;k:.O^`6gnH{<$?YN~9/v;ZGB(w106:3G;xNH~=+]yT{;	8QqW_R5ih^by~BiLqhbf8~aeioi^f>w9I2WF!S)O[	Zyc+uagAo\2mq$5Nw*O5
+*y Ki:IL.r<WuNcBe*{/Ems+N\)=C|]B61$gHY@f#zLrS/IY7&sPWekq7u^|0djJ('VIgVcw	kau%r>7N~",X t?Qg`YV`:aMB_l1=iyg#m%0Aky?kcaX>hx8w|:}xs.O+hk?Io6<q8]cu>FCNG1["]tq>~AN{4}.:Gwf]YBz"=G]K:R!I[	Y,xCDnV/Wkv"%#vyL^)^x=tMoAymz]kk5w{+hhvH].Dz$e.4tHz0&QVz`E3qNJhi ceJo"]6o`\)l VvSfhk|@(NH})eQ_5?i~,_<}.:Lc|{0c0};ttEZt.96]>: )69IZe.)\iq%FkhGF~tqX#|jeCssj~#FUm^Zh xuzk\7K7>sx[ea{Qqd!m>MiLCFO|6qd&`%Od?oKh4AfJ])#~}t9R4y{q8~]U4Bw4?u_Yv*4ahcz;1*2f0|	0|,`ijA0i7f<h1,So(>>'#EwA 
+Z~ZVi;fQ}dA\CL5y$cDh-_w/xakR5wq/5e mM|Ou0^:8IWHOXtM.Y{+ n8oF<mV?u7r{+4ou}gYUAGFx0bpud.WbF#_#mGzKol|g
+F|T[F99s+]QHWPp{q:7QP 	Y	ytyX:E=[;+1r3nT|]"%wcv3ZB5-1~@FxA|_'{dGWa/?#?kBfjP&k3[DR>K~ Q
+K,%"!	c-<)<G(bH;-n0k{d1g~~NF<-3c"C~f59nB4Xm6?1Hy[]XxN/iI[S'\z+i3}}<GTOh86#Oh:.YC_%a904
+}3n0#..m5v5s,8!?SihSyCTwHg'Lusz;1~/JbE{dfdI<p*8Z*o3>cB3;/(S=7KSJ|o`%z&} =)38iC'V#;Wahx?I~@~qy;+[rpi?*[~+K rn:p
+?%m*r:s5N,-^z	i*os<IO%gvqwBdR{Ze{eVZe6sc_+N5=kqG=X3WL\+ss1=77iac_-4_:Y+5]c{d=VmO,4YsCB?:Y`6!|2q@|.`StISy0r*6i{$aHi2O1Omlo}M9^@6]k	e>eN1GLmr^-;AU:Z7	B.;@fbAx3A%VA ?oe_":?}P$=y	cRR:g/c??oC_0A f<>//<MeL
+pyj/)OlE?0(yS13Y?m[-:89;H{UF;xq|+ 27+szco:.LfZ2yLWO#PgCs[(5di~|?c/zu08Iie_pDt|hR#9%@f,'cQ@U7'{H{`n'1N}^ =	j^TWeZ6fX?o458<'o	c}wJ{>
+z81>w"\up^:ynnfrn.#}+"k|hK@4{jq'=y	yLs'O g\`Ic!4<7ms'w(aj+Ox6TOoA?H*7xsV7z#Yk-)]=r?KH~;=9"6@PhK5<K^?|&8N}K8{MzX4+{a:|\J:=SyB$ L V]xJ9G9&EBu#C0/OS;k{>kuFyjd1V'vy+Jqc'^c gqMqmP-gX?07e%;3mcmcj21N]86	~EL=hb[.2
+:WaYGn1,6<jz_)nlv0o1.ZxSn7|MZZ>\2DZL"/l
+l|n$EmxfB96s SjKI6;H^kT&R^UE1Vrh+ ?{%?Jj8\XjhV\w[Oe,Xlj~uBw8e'zUUv66X& SNs:<`O-R:6szXB6q!Wj_*k5W
+|-B!k}<TSukI|^-b^>!jgSoi'K?6uRo4cerA7^^7I[M~o:$^w0fsl
+l+?+"3kH26c]J17w$zL3X}]]hkw!ejZ0onBNV]'gly,M!9Al"8q
+s1*KUnd~{N7'=Va~y=(!	|.~M@N'z<{51]FqSgpQW;^m:	xTY $\-rQ@yN*za|q0rDm<NXj}2gVk+Ekbl{4?+GA5t|*9f_c1Fdlqg;|c<Z3, 0>}eNY3NF	u^=J|M\vR&rswO0We.!zTr]5;+$6z|3fd	J@1a_6 dTgrP,0b|PjC q~lZtUBC~!M^cz(k~ZIFuGp%=/3vf\G,qrmA6 'xs`_fl(/F1oj7fx~KoM'm\^5I[5^._mZgMYl6)NKd8ZiZq>k\=gM&V	3XrKs|yJ$UF5WgIjg^i:?>?XG9,qOOng9UbsJt:Sh4eO
+9,*dmK2<q89w6*4\Uuv;|KGW05uY\/ RXozr(yJ$v#8ZX(Wi.wJzL/}u`npbSD3^d.GhxRLxsyc'vguE0, FAC$fZ]7xZOZ![+muK4W'v]O<OZA;||?CV[~LCuUkvr\O>W5I|.y33,fYZ< 6Nj!e[{5<8iw<~:sI5*k>r@2h<3\(7-1G8+wo\QB1qM,uX{eg=yrT{o{ xoO}IMq7y.,Oxt;uc-n <3F:5lo]k;g`7rUsss9f:km .1Nrc/LF1h<lKGl1p1p\}Gt~cKJXJ1mu8QVvm?K9]e?,AZcYNv_CsobKrSQ'|^51J1|tym8LJESq{yVb @aM12Cx&g8v~dcLpX6tICs$RO0Z]V!e&_ebp5Jw^T[,_y2JN+<Y1<.sOGUn9`$3_WWNKN5Gt~U@O-r^TbWydut:C0?R9m~V.g7HZ_(K8BK;)IRAr&sS>P}xN:P8#1/d=l:0VNIBL@-m:|imu*hEc8X)RGTw}2fi?%6^9t=0)E3};dNW:vl!Y5\0 #`'rG{wpz Da~6 s|A|GnR
+wc~[j "4f!%9 ~4<'mafU+bA6y&ddCo=z|Gwr|3}IC%71+_9O>puAfQ49w+	N~pmwEL6?G.eHN-9u]DnTo}H@:1Ht&'N-?K<p=w`	e#?UxcMxn33c ai:,9F72N8:;1R6<y.TBC
+cgMB?JD3_v*uJ(n^B@w<K\g_>4$5/}""v	L2;@_K^	D$fiiYCTSp^2}	w4MpoEUnZ	+sK/>%c%O(nI} 5zPO4}fpvU]|k"-Nx/=j]	p?}a'%zS"Ftu'p.o&O"z5
+gm	uw}c4?iB<'vxOb']^U_{|	m'{![LO{_LN6z0k%;3AM}fh{~sYP|C{-hP9{0{^G}YP))R)]fu]@C>RoWKTgpa/{TL4//A;KWr2zWIuj/Z||YE39oG? =2C,W>%ww?kI<x/K~MXlW;q7o?KjfC[}{5jjH}$6}!O4/T;zr(c-1AF]$j4/y"v]yo{<<CZ}\h`Lo3NG]>leNWX;{8Z
+kRsru]]^'>]{	9+_`_/:t<>.uhSr]]sL={n>w8|k8eg_;?_]:s3;l|yM{z&5WqN>%MB6R
+|7'\5:}gcI]X F>VG|tO+)]'`gz;a#<Ot'~>Ll,<_?:(6PSrZ?xn{R
+uRAjPw1lX\^n}th3]16]^-h2>uk_}9I-ciweF_Xy7\;sWCou;QAWF#b??::yw50P]K6ygwg^9}fecxxrHCdty'ty],9<YbV^ %-m0Xnu^o'(_	u;tWY5s$|ZXsdXI{Sxo}A9xjqv2yj53CW`,1*;4O4sjs5?sC	=diuO=
+;	\$~qeG	V};dsjm\sc_w6ewKb?f[q^]I/=A'?R{9qX>HpZE^L{:77 uOOUYL/E[t.SXk"U'Ouce5i};`YxtZ@Ulzg*ykl;`3<ONS:_ _t G
+'35}6r^R?2u:NvA{m>IJ,G7oKc1]1 %<[3^OKQLN<isFZ>r;{ 3{^&\jce/=4w=Pl?@K
+~x{kU(<1x}"/}uxc|ju}a,vkWkckju8n#;qFG&u&ou-QlM<6!_ziB.'<	&n\|z{&<>qibPbus=A<V#v Rv:m\RZ'b\<
+rBIxkath_U{i/#}a s>i1.J5&!<I]/@=z2^3gBSkak+q\&Op=$8y`k[5")]ij)%4g
+C%||+M4{5Dss:$z$(.~B)>oa]IlZml_Sz EX#7.n{E=Rdw\3RA?e+i6E^c\=M?dV#PW>{r4R
+2VM!s`|}:St}6xW&"$@m(\\ )A~Z)b,0X}+~SOK\QkUPjZ&Fe<R STrdQc}l_7n6F#!Mx0yT)Gj2vMvO+n9\oz#2cbrz'a,?Dh:w5KAwN&jv=v&/x9tO_(_k$fz&|}|vO
+~}q8g&xsJ,}H/ht={mYre|B'|P(~]!s{ht_9Dhoy-^[5+fln6z32sN5?WU;kDq)2JI]M=]^q~S[ym0UPJbZ(V7&L^W.a5;\r5)7sVInp,kN7c'L/4iqN~08uf%sA_dGRF]+N?g0FCN~|yJ=e^>v:6M&Hd;<O}nm=Y#a=W>2=gPEk_fhMz.xyZIZ\7"FTmLs OU; 3n#y#}eN.p+x{0h}#s,^B!}Me%[[yl(fiJ5KPMKn}~<]-s! Zb[D_Gj ?OiMb_(h{}M<lf-^vR3.%~b5^*fR?O3|w15H5gns	{@)c/(6?UEEw,T
+v`<5GZZB?|75&1[h{AxR|.8uhte|>w\}q,TJm)4}9}3}%VuB	Ek_WW4yuI_nHdBR{bp
+}N/\5`%WI\T8eskuN"?Wnhl+}u}]KX!V8sMD[qg[Yj;5QCp>qmg=<S_.,k"BaKM\3j}c]L-Rc]	JUnqTt`fvvc\=NwoubMg'yf O)=,~&_6hu}z<l3kE_7c}t>m?'!$@5J$O%)ijk;PG?H$~Se3Uv<
+n@~UhKSOyj'Vj?AKLlKv|k??ZM.sAM~[%{f&V|wF9>`|'m5S:ww1m__4~ [\=a.9"yp)GqOt>gAg>ns_jDsf{:/ZJm>jZ[.KO?d:44Oz|c3hMo^%^%o&U\'..(\>O^E><U~+J<(lF|i%:7>%oSMhi,29j:aAX@=[*7Z_yyvOyJt3RO|sLB~Gk3xMYW;q;W;7QxICAVk550m:]yc^zmf^&W},o|a{\jP~z~/p~Frwo?LGgn(m_kbW	Np_-e~%EbG#.9qk2Wo5:_I}m6pZk9@ay-G[u|?(kt&r|VqY=u"~K`kwa,Y{=k^:wox{FwEk._*G>0uIsu`k:t^j&2D=u=4vfo9<stx-<?j#zCKz<Op<g`g5>gs&GSAy91Sa>}[KSKS<%?`|2D<qlg({zguZkq+.<}E9J&%l#%k4/Ya|:]U^Jfh;s|oa>4l|^0>AWZ
+_eM
+-kp*#~0s~4O8NE;?q':=qYk7TiC!N[?p$aVZIM\5Ss;lI<5pmgrO4&<8c7+{:;UQ;{Z<U_oG#c>1 Z2Wc
+@BCBq]	WTbd"vv(dP*ssV'NqG8?+EG>u{A7#iV!$Di;3Q|l|vjfTl
+h={
+mbX;96QJ=V7|6s* c([-?E9m_^m
+?rYgx?4,KMdW8K}fQt;h{-aK/k3|0\Bs1@GA(GDujZ\g%3{E|zw\=h;bNKg%	2sXD=G#X6mHm0pn_'!iK| 1Ba3xa{lw'Icz|;HjOa6eW827'G[QGcigs;a,Ve')cm5g3I|?Noe\fy;8F;'k{"[xV73(NG:|)k}+XC~-i:gxm)Z2oYd?b\Ivy#}au>e^87:+d#9[;M}/f'8kzg+G8I{nAXQt%Ye%?A?_&WuS:]$E.cB'|'eZ;ogB[UCd8 	 I^W^J6_Fuqob??w?(??~Gy]x9<Hmt6>s6dQgpWF5ca`{X1{![)/1!s;Gcu{EqQ&Q{J<kd\PHW4a52s{1oc>uiG)`	#&?Q6;cw6S3h<Ang=9{./u=3;O=csNp{[qiqnw|`>ZQGX)iGX%}<;a.1o/_X|/ktio9N]5t$?SoG~x7Oy(o{osNny+|4d=H]e;Dni9_YZ_c2	LNcP>_^t}{@15%8f!Qe.6F$o\%vv:oL,3f,]+&i1v"l+5 j g3.|1u=^f~UP!5Z,1_%n9gZ\=,	=b;a[od]d\PG6})?O#Fae:oer&i5Fpf~gD&x};7v%rW:r_suZZsp e/;m_1JtIr!>o;m#>OI/}|fc$9#m"Lyt{~//4l:.OuxkS\ FFv:8mN|Ka;[ms
+*]7 -GqYg]?Q@]BPy)gO~TGI|Y91&(%bIh7y#lp>3+cQU*)4
+}=lg:5xwzw<ynNUqka{ykW|MSN<u*35bH6crli]1m&k@:pmT37G7,%:[}n:-<B&cLmI_+5;5t) OJSm9u:m)9<p/'X>q=wKQ	gzX	bRUV)70cUP\UvNZor^9g}V:70b[||qG!>kVSO\|#!
+gz5gZ#>3{O~#$h#gyoz'M4< |P`S]R@K*7bw6k5L9wtsx_oi>_5JhO_r-<ok8oi'YaF~M;lb>G]O-s,?}`TE8.Bp		 8H("BUR44E4j"b= 
+zpAf%D_e33~LkK%3_aLm!|FJL:KrG^3aZk
+m@i%"}W!	h 4$&zwsYBs/203?5S;_u1OS ~Nw|GxfImM:g7UR	\  XIa`GW4_$*^tFjO~,8:.^^AFh]1(KTIFe]!P^u"*md6~7lh(XA^u.i4
+*;|?1b7\L!C?s6#q6vs8d"JS^.*H"8+$G~	ApeZf?9sBJA}evF.k-l+(GR\Sl4; ^^D :Rx^].v.=nx[Dh$hxGPAS8^m-	%P2lA%/^ z|d _1:Qa<2q^m". PE)B{<4gVBnS#y_<y)e//;x4[e7x e' njoOk	6siQG|	e6W24|wRgI9vJ?FA3L?^aw-`aD^USPtv+n^?:r]s/MM\uEVH\3}|c9Y}oSE,YLCYuLF-.+o\cL}Gmz>*&
+TDyTJz0@p0-x~Y
+5P#0$7jN|71}Tp[_r%$:JRB\)9WJ*8*v'57XvV:@EGNTQaVTQOs\?^rQg0o
+Y>&(~s@ZDc=0]:eV-d"-><07Al>3<g: 42!nx5Fv;HrKH9l/RK@9x y({QS/OM=isE;7[<i*hK4v\{S3Ss;h/!H=QdFc)tC915uqh	4C+NgeO.~uhQR 26
+ 2K%)a lTrCW?el|1LaKaY*<Q	MM]Lq/B;@>JFM2yp:rwoJWA[zEBFH]t&B?RXe:zq%bps	-okx-{06<[qDJ&;kMw)<YOy8]rlxib0kGbb}kvUea(sLJtPpD,
+HM h<0Shp8r<y6lbL]UU/H7lMt#L'?E=sdv6uf*Z#]\ECFjg	!%g=FC:r|k|'mi7$r/;=3][^vV{eGBqCC_)~
+t(1}t%}uJ*VFm@Y`Nfw9sJa3}?K}.`} "y{> Bm:H!cD=&Qu./	u| #{p~c]xWGcd$0SxZrcQG**\
+Sfs3ZSZ*c1"]Pr5Ei['`MD85wXskA`|f<s0{,?5'f@,vi;730eA\9M~wM=.g7D-/4`IXd}ij'Aa;W$~uMhZ 1aj&s-m"3{#\d"dN%G9FTHE!m x)'"sI#2Z*Lc]yN<ic@Wunsu6z[;y4#RI~@zOd;K5a
+M~fUD*oG08< ? z)(3*G+[
+mXeq#MB0qXpq^P 2+cp2q	.r+s/yp<PFZC /Qk:TeV3]2Rs~ ],3 -SJ6G]H'{C8u,nD]u]uRexc0.*DrB<P;de_DcJ$a./ _rbmzPLExn?mmBh]O_PNt^gHR5e/m^Yg jm}&yAg2xBb<cQ:*l@A;-O)EEAAg,q:@Xbz@ctP8:[4]
+Q dw+:~X
+ 53<bUWWvJ~O
+\qb/sok_Y!l^PWo~H}|vaX.(75WWdb:V3PDFFSh|7)1HK M (GcxgG&HO  9`t3#rW;gzxfsy@cFW1 8sy 4bl4lmeX8\P6	H*AZq,.C A>qH5zqUmY_gpL<"(~4<si7Cwm:|eb,Alr=V;{qmW=|exyk}E||||_0EZ9As89p*ag"-mB6qM]7F<uisJVSn?h;lc?rk;%LG2)	u/AEl]{_xrUxC2w5M5C*--3ka}q0P'9ks{	z&	f[\+[%<	{-YtxmK%A= aHv>Fh}<sNkdQ6 hS{+[HC[
+lev~T:~Ulyll)]6.o<a'S/PYyfx~A1|h}.=CN7Bo}2z|S]d|'8p-1y{S?:}'4+ma<
+!{*7>E<f};|~5|;!	1c N=|utlUb2Q}WL:P[$=U:v83x6'Is%p(OOQ3nJEgJP~6C8w|
+p8>a4+9V?#q< o7 iF$#,&3P%~3:l1-Cw-
+Ea\RD^eocYs`[Lk0A<ya-^ d-(+ uR5^uf{cDHvwLy9(oZk/W2\m6rO)z56#<wCL:zRr^er"6o2{(kl%*S%$n-'8@^e0B!s/XY}A<,ux;w]yFx/+k~|PW6Nn@<m*s6w
+*o<)kC?v! <sDJ   M
+y:`i=1? :gRI%Bgwq6vp9]xV^T?g'*~q!04DL
+M2d)OJ{LVR}zPs.aFP A:]je,<q]C^4 YsqrA$cf^0|/C61k'=.SU?Du2([glGH7
+T ETOy~S]Lq3+v\MWf9q][ G3{0/:V6q-	_sa'r
+ADN-I<_PM\>d[lDouJP?fw2wO`[md<Pn	5<'{x<[eM9!~-<2YIK|mwS%npYe*_GFh+1F^0Lg .CP\3|cuPB	vAKAYUr=k]:\^|{5up]zlv-1{39\8#!1<	<W:R*K.x^F9R ~2&'zq-:HsT{=E0;y<AC=v-hDxw~!eYP59l\#x:K[Kqzxtsw5GmCQH405Nq9qVgC{C$2,+[.b2#OxC>8a+nPP6jyle;AU@Ox C5Z3sF%dIUE85D_\$nxh-?u
+4tZoE}?$^'3ha-'9cL)Ghw1 eJ\ 4WCrqLg.{s>Q"o^OHCt3li1(4DCCF}fA43l.5O}y@
+Y[q,F0x=eeVvkeL2JCrb-'@CmB|e}(3_1dl/1 \7gmwEuF`bb,(UYO>/dg0z`\!oe@YxqPl"s %i/\Wc= S	{^x=lO%x8=:I,:sC SVQ/|R%)eB_u7]7(}{y/Q0%.R@K6fK8NH^MorOyn7:
+5I1-d:7WBP}?jqgU}?g^"O@;etB:nj4WB>#d0Hfr!HU4&::FIX2'2s<=~3XsBEk0sEe+7U:X:vA>yv >m8N\EH>TPcOfy\[28w$	x
+2('0TW@>,Re!<zP4v@s@eq):#oH{vF+f@\Y_ >W1YC=5H9Skk/CYS+\{l|^<.N_/H"BrQ,m e2ApBl;m1oczwD+bZ6AS\^lZsCU3xK'W^D:&t>vfk/\H!M2-]q>3fsGTHB-xQ3W:3AHb\}.yfN*+c)0hR1zu3$mK5G(>E"z3:Nr3A7c' /x|W'*cr%`m,q0-#kKo_[Fe}ox[9u;O8R1("o;?}S1s5SJ^'9G:Q&c.Q+k"??l+>wsXu^M2[F>.pBO8olonqtP8]qx$aQQ\_u]p$5_ellt3{Y2\.WR}C3G9{Z8|kf;[$?kh<wd.1q:TTVZW9*9('Gd(D mj/q=6If)S M6wO4^9Cl
+t@<n(|?=$>Dgs;h.$U7-U2*&z;p&!>#	,edxh\OOX5/[0Q(=w4gf>`/&om&Q};eC2<NSO_pW'?;r}0v4&K^cx9t#c w9WAy~q+&1t(h)^qtG)@bG%0;q[uFVoBv1m!>^Jq+Fz(w]Y[/1(Jk[7$+ rB?
+)>l;+jK%F1<W~xzet.1ln<P;0ml @PGV<+vt3\c2v[Wle/JqIZPFl$aheN
+#V_c57~><,=(0o
+)eC@3Jl@sKQElyG([[>K}.b6}YN92%^Ar&}Odx /0<w,F\ag'1nuO_Bh+41`2{=tbps42H$aI<=29B_sl<J_p7vvmjs+[ekkVskzsk
+N,1DT_2|pE'W$ g8!gp~[e<N>No3f|wj~>vT%L!l wqqg8x\/KW4]8/sx\mN;h;H.#X=Up\&QLV0y'H@D8{tJ;
+4N7_G<Q.sb'ayo o94oxo/~t88&qoRM{	_%-A7.	9(c4MdAf[cFhA:}Hs02^S7C2spi4c}vhP&c<6g:)0,-sboP..\d$Uf0&oi$Z$\}"a.J.[v7>zn{%'>KNgB"Vx&s58pp39>-]eL^I<6f\3le2e9[w(c.GHD7F\`u.:
+sqCHZ>OLpr(pel5!z80Z/bmpuZxKG8f%k3,>v|DqCL>X`AlGWY2v0":-otQ]/_@<Nb/7:Uoiq],gqamK0:67&9I3tw?u-N3rx+?jo[;VNmvO$|]W#\:\Y;Ik}[OF ?]Ig=4"t,otsq5e%Am^)NNOt._;rmo}M-:;Q?L?C3g^ 2O. Ht?Y('<C_slL35[#=(vq8',igH9K6G;NNpM	(:>*<mpLf_?]UE~|b~{OcW XY^C
+oy/m0mrL <OqUuG[[/K/1}.@Q6$7U8W)#^7c8E)aOk6`06'?\[+$}l>$c492mCs/jy,5zc$7FxclK\uP/2eT{ZNM\SQLFBg]#3@Dup_	OB{]3'd]Ip?bd98{/5/Zs|WsPq-5B{#;iQ0Yqon;Us	P2$+,Y[q;~fDXP-xU%.{pg<Kr2s[2Q/7@#qj]?sS<G2hpomPq2;}QM-Y7V|x(k<{;2c~|9ajl=AcB%'2rk?"9*oyV{|jss_q)_&LcEPFf':\C?aq, ~%:yj0*[5(L_\d
+gvDr`gBY:/]#'fmcQ[tC3e&9&)~8099& yfg<v'c/9%`5wujuW,\._vp}C*O,<09;;?ce~b!h10yE2?,iH@C]od'v<4?xA"Q'?	x:lM
+x,o$Af}|-s';?y#?S^K>{uU^J!/8.Q=AO1/7*fHYzv/K ]w9W_qSU'y<n*ae65~O3+xF+C_[Sk}U]+A=7[{AHk1Z8~W9i4!``N`<86`u	5=b6V$Hut\@6^gaq8~f.a:9fBvU-y~#x4=OoYRvgvvY.5`_=Uul?;. C}Q'a+Xxun8{;C1:eGgs![3q6H3~wjd/[:N=;WI/sB 	 <-L<JOz!C;egz"Q;QAq )\{ @9re< }V,><rp`#n >gm'd\&C2fi0OAE;mmeB[VXE	qc}5i-, kDgqcM8mps$|s25k^dLf;z@.XAdh0(OE_5N7Y$U<s :KWI9[D5g_=-R#x
+>_{ x]q[%x+l\?.#~y9/r+FX\S27v:@;'\WD9EO< 6oN7T@[[QgqTSQ.aNpy2"myCZQL-CG#S-8_{11)r0^?D|D^Q@ G{T2#/pn=2gY4c0Ncb~:kn%gC^~k$g4vvbvnY0/Ebz=Hc1aemF[HcbP%u?+Dl07;FylNg)gb?~@>	<VcB82fOf?AbKGC4!~,/N`rcr_QKk|!E0]3x|>vN~a>}lAg3uLNn
+A>x1,$vniogybcx)+=zDF/G^wMpp<x	vPv$Bf(>s$K5()[:dy739O~$;XCel3X[DF&M_^y"g8cc3^c1PJcf:uJ6.-Sq9>x<W4Rs2@W>j
+q}|Bl;#FD}m? <b)E}d\{e4; :V\Mb)&6=C]EOWS3xluH
+3;=j+
+mXXa8]tQgZaPzL=ug|R[c^1}^s|=>-f	CHG(sO4ubWj?	w0Yy0]+)n >r1c^3o0B' <<n*8k`NDG=xNS(*'@X[+P~%	WkCN[-@5rxVytgmgQ/7c83\'q,x.qg8#kc
+[^[^8. E 11e(L9QC",(cs
+: 1
+=v(dk%r J	Nd<~ 4Rxnx	aw.b3l;Xf {Iad_Cy8C0Hs0-vqe>:;gs2q?t$ufgpmH?y _q]+osD6f_w1]Ry"7~(FXu!-PU82/b|n*^#++Crk{:$@zr4}+f#p}Oz_Is
+;@`>.#KsEC?HpOB{8A;q9}(y`e%4q(K*f}_c25wp=C3k!y}5#pbV-L#FQHX4</2vxVB:50"5[eV}G=muRN}hD;^0>t66>c;^6{:yN?>k#S4I[^V>[1lXu+%h~!W_kZYNw#%yV5S?Oou8<Vgg&dB>s-wn|mlQAEl/3$P|#Os$yr	8)0~?nhgyo"=7kJ*7toA%F7<c_[xc}JC < WDq @@_> z\	] N5<{@WT wPw
+@'{o@ } 4h -  #{< *7@
+A=6 +
+2y&F)Aqbv,  Ov??qDmNp>8c<1@g?hH0x [f:4 _Od, P 0 u0`7a P)_0` 5t?@? (+   pc?~pkb	 qq8Bk7;g^S2z8}qq25klH6@=8/ f=RFk8k8s o{Mh6)8Y9":wzT,_c~=/H|s|eWmX;k[?r|IP|F|	s-(p9&nY{9gq$aQ?.sz<ewQ:C[&f_9Pl{-qcYrlwcKl;{l{pY%LEt8l{goOl{g \\w6\cO1
+:K:HsVV,|IT=Q6K!=ru)77^kxnudu`+[6C|Y$]xN&^q"{71SB0#i8p7_Oe;c'H^qvvi
+ ~6yu-"k]M.a`6JQq.l%B"?kB6ot_xr.kY
+`Q 4	/B4[ }{N@'~X@[xc1\*.bp@O <#*12-l8 yeo#)
+yT/4COmu"=K{	#%1$*(&#::	~NPVV/8c1_9Sk ~.cC?)-OLK'	18!v9%.&caf?qFn]s}8}Sl-59q'`(kf!;*(t A:#>yhb>r!MADYuLN,y0?u4ig=,_2MHoy\`IfSLk u&	
+(4-&>%5iSeI':s&-b?9XvW!ER[RD1;$"v~n;Cj
+o;_Tc<kcfmLq@$p'm>w^t
+yY{0=1nR{wtp.-14V#1Y}u}%9H*sl},MV.QgLWfnxr<!]G] @e2n$<_R5a5/%?78E+3]s=X? xsi	vVcO3[p@;o(dgqY^JYNezxRx;11M]	LjQPW
+Wcyb-P6y;pKwk |=@ZNC}<N;,Gq/J5lcztK_oaP:0l,c,[mc"LfX@:|mgy!9*m8`.}g+pn s;gl1=4!zL{4!3w0Z"#tIu?
+)djfUypM	mq<7?NS`tPg=iwLcn$&m/hw}s'A~V}-l_Hp!a(M(DeFE#m/O3o-$2%+-Qf$1 := c|v8AxePg*Y=:N{33uBqeD K6$Bk:w;
+W3l_l_,9 lu8r/yL!HN(kc:QO
+J}u:?wuc\V:N`7}Pw^-?Cw.mztJ3uVW0|&U]t|Ofp< }H}(m|3vl=AlM=oc\F~^$?r-Ya.y\#?9jgE#F~J#Zsm6#G%?l	X#?sj5:L	0&rSkZ8\s,}Z>mqs*OlX< xbA<x'xYiO?'-, a8A<]9O?'#,aVt\ "',jxZ3?,~=/x
+),	g~X<S^38\ /a|6,a=]k;=+G8qg|Xe7d;av)60ky~!_({8us3@'yA|UgZnDxri(g/U;zw 
+/.CrwWyoorPYe~0=Z{r,Ku-_=oKw(3xAGcCP<2N,	X6;+ipf?5cm-@zLvdg9d{-=%X \={	x r-by<(i<a'4Uxj5XL%)z_>QH xgQv]e:1LH%rM?L<4`@z<keP{1Q#!m&uRVyGm| iWD(V|tE?58@9(x9vE@3,L,o%Qwgp}58>mj(h!>93;d}A'_/$l\nk_n+;O=pW.4OF zD<7`k8yt^m$;-\h7Xy	A$L>9oy0r<k+gg?}\=z.tnQpkx
+Sl;S-tmE48olA<W
+yb{8@2hg]i1{pXoCS'JC/!vg*m1fq>"YS;p/  1Vyr66rc6'+J8;TgP|N<$aMs\SpEgn mlwU>GA1}L70]b:3;|jZqi((>vWGg@z4+2gH
+fX`<v%mHO:%~_l|_b|?~%~510w.e\.XK/l{2WH[>xxax/0]Ur."+hs!DhkP-x(pGCF|{w3'v%\/immwR @4vG)q<5BX|@s#w*
+9(].9X\@9u/Tc
+ws*gVS^^<tx-{PvlCC <_t$_#sR}O_`un'	}pS+d\UoC
+. 9|&H9!ul*w&@YAHm`z>XO]$	 M6>9x?~o~<}pzBLo{)	n@ww+Qs't{hmsLy5(j!#nYGL`40l/'9}qT BFUuuu\],M47eb_/P}X74x7x908\_C{ 56rL>sa3c9wsB*iq*e0+Qv?k6p7VTVAqS8]wT2F_~R~gv:_HKup;fXy(~Y~P}zt@sH xU:.{x:&e3<V"P&z]6ry?I7wcMk3mo)s7w7wfko)sU_M
+n
+\pSpJ;W4E7/?MKqr)jsK40]trhyP.
+C"aJ~/1'J/fD7}cGA:uoMy<f'QawSp+pSp1]pSpZ+pSpZ.o)sur77wjwMpSp7;W4SpSp
+{7o;.7@+:QmU}E^1`T
+^0_. 5_po\4!:X.%'_<aB
+i{E] ]uqzseLstsY:$dQ@=L%-;K}S5iGWPFg"MEh(`/"XW[2W`u|d<0m O}wWrO+8by{~k
+ /C"V#	|tY4/9/[g?@\t38I#Qouj,(ahV~ePq6i	f_LizS}e}e1=1Oal`A\e~5,K,gw]Y5k745&bZ<.R!Q*oRHg7F]zk(GT3j|Bv1 mU2x# UkfWVnI&VV>HG9+N<my/7c^v$l:7@9\+_I;y?3K]XPgZ8Dh[(!mci.sXxw3>4/i_=	;;/je7|e XiZ]o$Ev?U6]3]LCP7DCZc7kX14B>e6Qe.a(M3OpfDlL8GMjC~nJ;E=(3Z6IFZw'Q{waG6oGu99~ACERCe@/bcqXx9UXccG=8F|]pgpaunjOpu'i9+Gulu\xqV\= PRWwg9W	pu?3\U#kVW}18n,pZp#k[jFhgign^78N?[}Cp?	bI]?7?o>Po"'R&d+)t)('#sbbb}d'%fO31D7!8 ~DL"Iujb`p6o0=KL81YIYYIY} o}{LMdN8^YY='B>}`<E6xd+,DLP`%L<`
+gCHi*XFeO{`Eym$$KPxbXPk	$)	,*}ML!	^&<EdWVGn9C"2? 3_<6)qBWjGbc!|s:{]	&9v5eb{~NpzzL,)OgAHI?x>#9)%{
+ g/.55c$4.@78va=g%$RHd	YJ +"#	fl%wmKH<yD;,9kv<QN'irA,wN<U\N"O]r7y||]Av9ryS-\<O#(o3r?y_Y "[mUGC\y'r<B.G29$Qs;A&8vt"$TW*:8(g1RXi4NVtI;HtP"I#QJ%qH#USi"K.=OFK4B%9)RT_HqRC)^j$5HN)AJJIRLj..ZJFj+vR{)UJ:HNRgrtU&])uRKJzK}RO/JUNYM&rgUU/a!I{C,N ` O]7y="yLJ'']S3nYhRyW~E>%/ (Ac|XBRJer@.A\!8N>j?^Jp~'.a|j*a>V:>rpt|Sg?8p|w9#q?9
+r|M-9IL=HNPg7;? U""{+dyF^'o7[myG'C9@%O{%I	rr	#%mA;A3i6>B46e}ttBo1t %4<?mIb5f~Cd6iKIzf}Y3d~;AfN@{f{2(5_@At:Hy}=X:&@}RR)>X'PW9tz,:lx;P+4x?@[?6n&Pw&#68qf4.l<\y4?Mon0Lh	z7V6P:/#C<|(} FN}@0_Hy4qEobB&,jm(TzLz[Yd"WB.\K'mK^'fcN1}Ohz=?5zI1wCR5Co=bL
+>e0.c9"~noB;Yh[B5?	'o|~g_Ju"ufI`kj?v#~[h$/QPhd
+ T->_tUSa}EVP:*|i`a4"0(ua640i8#a>-e0^\~AwG~5T	<D$+J2JIQZ+mKiWR4QtV.W(U1JOV(}_T)2Dm_8[ gqL|/bJ\-qxI,nwDx7}NA!aQ1D|\|B|R%>%>->#____K=^q:}QlL/44?q\ #,$I)i]KW%N^lKn89G@->y$M"K<"ydc&K|u5&g&OHIY$OM.yZtzG]:e8hN@/P~mI@w&Gq2MZ>PlfiC2x'gqz9^D '!@/3z_|ABL	=!po4<[UO&%xb	$`]+vunuv{]aG1zX{{='MId{3{s{eV{k{{[jOwwww_nb7{3W=!aQ1q Jp3RTMXCQqDDFE`5C$wG|1iB5MLJjE(o*5!mvOU%)hU;t.Wtvew
+!|}f?`WyB/\(aF$hXB\^[>sB('egOz3frrB/fl3w7_p3e^[
+-^trRbem=
+_<w5kX~;7m5-]JjM	lqo}g"z_(GjFZ<vJLf3}^Ie=>`|{H(>$o@#>2_A@W34Fnz6_'/o||_G;S?ov'y_O>__*h'y=ravIK 	h
+8O<}Y;J`:??}~/Vo=O?r~?J8|M[Jv}ajuY,Z~^.5"KBg|w=xrwK/sUO9PU_$T_afuYklxLxIuCz+VkV!E[X((7w#w0|,<
+	Et&EER?!w?zgywy'OziLw6|+X?'<j/g!6x'X}>39|G/cGX`/0W2}fwNBeq{,\N`)?cphcx|v}/'2?3<]wb^;O<I\r=yC,y|SB
+!N>s/VctFX9[w>eKbj~^6X0>RoachGO/oj8/Zy'j/02IOfyxO^z^wz!c>!07<uc|aTcy /,Pyoy|Sf#G:sXC&{{PxJE~+1EHU}!/o#UBkG_3=i!/=\Pc/P|~faS?l~#<Oa1{Bd~ea=ChpX*^$4xD
+pz3j! 2xP#&}B<7? *?f6
+e(#!mO8k}9at68AY#3Kc~3g^31@"zpdn}H55N2<)EbiR&yF E + D#</>@{rEO[n]{~m77k(LdNShPGcIzAft',U]Ml=--.5JIdI#^)6u,?^v- G1{snCZ^o_ZoB>1
+r%)+VpyMDcoHe#	=9y|d/tl#K[8BRG%]y_wa672*gEn1<33+;]WtG7-%B_DN:q$F,{O	3E(QF
+o-QFI-\u,0.TE:+.F6Ul!FFcW+L?>>>GW~k(jk+}2WmgP6S"bPDH6j4>odS#1Fs5dV`Y~>|,=5c<loTR\1Z!{.Zv=z	j6z~iS3
+v%ZT/YGw9/,UKcC@#Bq] Y!woOK~X\Xmoj[-,Xk k\5B\8FR#v[<eFcW/XI,UX$Oemy,Ljnv2p*6cRod5[ffVC]|4pVy8]fzfWfkLgRhW#7lz/0kc9FY|}Kw TZ"d6/qNZoi5Z[Z4y
+b!4};.%yj)Vd45$|Yqi;vx+;:9WHSHd^oBmUvzB."5j:r}&\QF5JbY,lo^|2_-c
+=V}m~#U 1>7/2C-uex3U_e:k\=%j/B${p0_qYb_.4a7<b&>3C`3B{I	qQ}JOH1!NB 7jAnbpipFSg@G44c^jUH98}.lS#69bPU|HZ
+<fsjtP_0-,{]5
+s/<$ t`3dWUYxf!g~'Y#&3_@}]{?O~p.PY]rr?i{-c%/Zd$<Fj[C^|pysx7/3XJ $$LMnRxD RBlqP 4@FFDGH1!";2"2!212)2=:QoBDgRBDBdBBBb"IHv42)qbbviIII	III=$MHn,;NG=#zFLgt.'{9>#FTd:!bB	YYx0f+zvDvlG.gg>z]n"4;~<h:k.IU\@X<uAbZjNNLt4kt_H&M<yr-rQ&		%7oRs]Nml6_=joxA1#vdbmSl+=N'qNl4e-2~W?.Ow`<D=U5 ^Wd'yOS>/7UT/Vxx47w.{gw9?7q6leOl5!+x,++?e/"LgZ$6%.H~Q"j~SjL%C{cx/	 >,<>2ew;Nz$~lYaV',U!l]qJ&^
+0P:rQ+PN2kBZ^HH{wj ._.Wt=z =I^W"6a5s,shv2*2_.B]'g)6m(<Z$:i78O1kq5yx>m"6]]IT@Y{)S+#Q]^Po)qm	)J$ygilo %<[<{	h>R:t h5/@+pr<h,wKs3`^> xA{_i}>_?Kg]d?{f*s	L%vp
+^Ibj[  y W<39vSG=!>>xC \JZC,`;I'h mH
+ >"
+(ORGZ'<NGZp*l{ u$1Iy`YL5>|jz(fP2v@ q^d'M&8>u3:2l\|5aOu=wA7'\OLHMMz'AB =M!&&%oOM u3t3'NqO{@dc"]uILCgMj$6}LLK0L~S=llAHl<11_00)Q
+&*5jojcb*GWU5)FFCn%G+RkIrt[apB~K~i]kA,vG,!*w`;gcB\(\~>__neV#"tq-r|$	>+y&H;12nx:yPpa_u/rcsvYc90NXq"X||:3~-e@/xR"5.G_L_ATc\Lc=7:HoA/48o4!iRr@Ji2A$	Hp;^u<t6^R-UbeZnbSj\Pl-gt5c"BB;2*2
+c?}bB
+b	9jXcCbCye5n5ck3=&LL6)AlV{F)Szot6W	F^Ylgo6k6hXLkx&6Ml^O<	zbM	O$5k^Ez;QP%0 .1:We-'XyUa]bM,M*@kX`"lc7CA:ga6:S%uUm<CBWw8F qk[}*.[/5H!f,fyqV~vz
+<';u1X
+_+XrJ|D3V
+5yxJEPNnWv2<(Wq"n0ejvv0cy7p"p2QO[N=$dH	Tc@j5Of6_A5$BhEY%eU%A	^k,Z-jVZ/^GZR
+dEn44!MnN.#}lf`,!d c- 8v[IfIYJV@4~dLn!kTa'EvDhHYGguw{?P"GAvAdAn'v5F%'D(40_I?U#+Y/T/fYU5Gu h{q
+FXc1qD_4t1y%l\g#s(d:dK NaB%qBrLLIH%B7\C	6a$y@K!O	B6#L#w#Fp3J<rBXDV3R)l%MI4!.rqN'$iV#H?LipP<KR0z?=FDz$n9afBl04f
++*Yq,zf|%A8Qp<i`r"l|Hz2?YlC	PWjbmbF'L*NhL3Tb	Svn:
+D4y0j}VjNPE21WHWpF~t/xx{QR-#O)|9=x7t.g
+ Z{:Ro*T|~&\Zk>K.F'"J[z))~VzV&*ExXMSkG54yFgJX?dpW&u3&rs4~S-]M3OO3Tjo@"8(ULrRBz~ /fI7E-u;`K3fo3'b\VS_Z18gC\3.5up99(RBPUC.Q4z>hmHi#6S56I46izmI`STzFt&@s,:;HoM{zi.Et1]Bet9-+Jz-jz>fnwmGtN }>DGc>N{}>M9<}H_/RW>*}No.}O#zO!)~TK2DAdAT&B]!DB-B@
+B#Dp
+	BTHfBspRh%6@vB{!UH:NBgrpUIw-z
+tG+d a0H,\%x!Pa0\!F	8appp)L&
+,a-L
+	app#fs<F&a@YE
+"apUxHxDxL(v	O	O	pH\8,|!|%*cqpZIYEU8+!*WDUDh1fbc1Yl&[%S4EB*^)vb1C kk-W|\,.~{ts^Gkh7_iH< //q{xF<++E"QCc*ZG3=ZRPKj4A(MR4E*]'MK3i4OQIE*I$tt]!+'= =(=$=,="=*=&HKOHOJgsKRG+"^^^KHJI'!S3sT.QB:&}-NHHJ'Si'gdv#H9Jczr}9Vn xLn.>r_y<H,_%5y<ISity<S^A--BV6v+yr\ yL^.+rJ^-y|I,owd||]!+'/k|}k[;{ho/f R*()bS*%RR)X%NW)&SIP*-Trr%;w;LRF+cq5@ /F2_@VN<@eZOV4m4vvWnJi :UC W5tG5ZI't?gLg7;=Kh%6K|@X",	+apIxPxX#^>>>~('6FbsVl'v!Pq8\-Wqx8MY\hhZ}{bxLZQM]@+l}#q#Yli@x|@Z,m6JwJittSdYVdUd]VDv	rTNr/9C'y<T&G#Qr|RNAE>#WbQ]Q(eLr{S
+3W)#xE:BHECPUQH"iJH2[k}%i6m$F9y D'#MdA-w:L$dRSudNfzrNqbd\Bm #\>iSn:-R="&4D[)3\=>/k`y?aQos\GTD
+K?rG15=N')=`I?"vFU.nnn"a\hbaZX#aF	>naCWO_)< C03<"<Z[xRc'*Tli? 0Sc8m%P~L!XV8)|'SbXO/ukL&SLbx{Aff.~;-D{3f#(cNCzj1S f6M.g9\qxx8@/fPH\!^{k)OQ~L1T7{'oow)gaF6)m5\!ni6CgY=&R&NfMPUM]J%biTZ&-Uji>D rH#\Tq 7)TYT),5G&N BLn)SKn'S4Q$w/WWe;&`=&!GU7_\@uAoAUxIQi?49h9D#gS \@@Vm+oCwlk 71FQb<*U2	DeLV)T:e2]TWnPrYle2WW(7+([)JR,R+K2eRPV*w(*eFYS+&eElS|=verrrSy@yPyHyXyDyTyL)QWPTv)O)O+(gReWyEW>P>T>R(OCgaK+)\9JrLZ9PQUN*)O/W7wrNTJUAUIUEUQOVQj]Fjj@Sj#Du	jTMRfjszRm6j[SjAvR;]+j7JV{=^j[U3~ju:PVR=u:LPGu:NvU3	DuNV)T:u:]TWoPsYlu:WW7[UjZ.RK2uZPWw*uF]S&uEnS}=vuzzzS}@}P}H}X}D}T}L-QWPTwOOgRuW}EW?P?T?ROCg)!d(v/57'xJUW:
+;Aa\wvM`?C/sW7*
+"_{{hauD{ho#sQ8BR+L{}w;$U'y>'1N'F*Lz1<rxs.2|O[/*UpNS3?8qG;2v.#CxKAa+U;TVJwH]#k5w.w]_l?~MrW%rw	pmlhZ936Ye&=_^ l?<xyp;8v
+/?</pw1_];g?G_]v
+s{!s^x{*0R},[lv	.S.>wU;VzuO.__. < C  e dL 0	 P\" {#9 sT,PnXp+m xr 
+ 
+,X`r" + (X`Zu 6 l`f- [,P}`' <0# wnw8U7<eqjwq(wKgDyyK.Q^DyKD)5eq({DyK}]j%k]n%]i%[]m%;]w%RvJrv(G]D9%1.Qfwr%	.Qaw-K.Qcwr%.Q~`w#KD%.Q~8+o %D9K]]P @ d @LpV\%]  +]D  T[iSwkVsiZu:jZ
+MRZOh}_i46Dk#(m6FkWkhjm6I&kT:m6]<\hm.mnnk[mW|@+i%Rm\+Vh+;bmXiFNmYmi>nmCWO_=======hkOhOjgsKZGRGvHTL\;}}JkeZ@+hAVk'ooYwvZIYE;i..Ut]Vz]"HG1:\O87Mt'2IOezKmuNoiz#Y\_w1+[{zoW@}>X
+y!P}>\G1X}>^ZFV'Iz>YSit}>S^Ag9\}~~>__/ooozzH_/zB_Z}eAobowt~~]GXGq	I}[VN^AB=^Ho_@}POCgaK+\?z~LZ?OO/W7w~NZh,EjYX%DY-1zW}K%oidilibqZ,m%bimicikqYY[R-iNY.+,]-,WZ[^tKoKxdX3[XZY[x,C,C-517gts?iemcq r% &Z&Y9 22ree:0z r fYf[s.<-7 ,7[n,j~[
+,E  ,X`J; VX`z `V  `;{`' <0# Zqx>'v<43 xa7gjweqgXw3pgX^;:7i;qgX1ay3,weqgX>0a3,;r3,w;)~-_X|e[,K9| 3,G;R1vgX6qvgXN;qgXew$3,;raa9O;33,;rW ~8GB,a D 	@P T+w2 pg Qa  Z8 " "c h  @c& ND I    %@+ m.wnG?+v5T4 :t ]Wtp 	 7@    0`0U ! C0`5::::W[^kN D$ku5SSYY{uzp7BkY.....2rkuu%[WYW[{uuuu#nnnn]mVn=naz~p>`}ap?b}8>ie}4>k}<_h}{{XY_koXXg}X?~d= XY?g_XWV5h=jo;)'_}7zZi%6jkolM6M6@9Vf9W-e-x[#[c[p;m	D[S[mlm-l-mm.[;[{[*K}Jd4KkH&HH6JzC|p"rng	P's%`f/EBg	S /
+ OY
+!OA}] r/$(]Gn&mK{fEtNYr,K\`$.l@Ars s$.QPE(I$)eL_>S]=_>aG:JF;}	suCe+ek={{{IrlLqLv?~?/4~]&q1?unAyCao7Mpc?$GpLG<
+8[8>|ae?:b!RjkdUY5h!WsgsnL?k~;w*TTBgw*8:nN,{M_&^A#s(W+~U?ku=F,N Q:^}jn[>sun=J+]Zf=	,[
+WYT`Y}Bmd--,u%kJg#*@G`YZ;qW.6fp7Z>wTg\&=`@n,;uLZgQ}[{X$AOr>Mv>gOgLcLr)2V11/iq6-R_O_sk88x.-V<AdNx{qSGO3\888887sd|8~qq`G{I	Y?13"04@h)p'u{nYu0<:Fe +<Tp;;V`m'LfzWx+C~{xm8mI-mGWSo!?Wj;:z9\%j;zrv|[>:#6qu]]zjr^-v+Hpuu1NvW;=k\CRt~hwR/yg$>}>=oI-Bm6A(o|}+SmXswtb{!	|0NOa>QH>w:=(ZaIuIg5X@\Mrm'1NsmxZP.R]s<[Kl~P?;BzSF\;mPS\J#TPu\bq-FS:T
+"5g(
+,fmod~F~ttvPg#C\7"aE+:r{'.BNv+6^N@?8.z9.u\qq"q(((q![;.u\lp\w\u\r\p\,v\s\t\Lq\s\p\r\q\LD?:.z;.:.p\qqE}E]E-E5EEE""rr\q\88q{78.^p\<xqq1qbbbbb1qqqn.qJB<B:.9.r\|xqUT,4(E?dc!=78.::.Z9.8.v\$:.p\;.*;.b%y9qr\t\s\t\q\lw\lv\|q5KO9.9.8.f;.;.&:.F;.:.;.v&4+`iYCCC].#nR#w(y{h?FB+n<j3<Q?7^oGkc$9\O')r8Ti&U?e}"5Ek]35T?We88ceHv!6!Q^+.J\&5'A<!"#$=&|,{LF3Kilf+Y]/*@uHul?8!:bb!2lr,hEDVBnS.V*xJ(Y+t.J:xV&<bT:xN|yIkdc]@tAle.,^-uq62UYq,.^%:s/Kk{2z!K7!oAy}!6;}$kO_9syT__b+q1rbY^l8+o0iO!; ;J=QY| b1b)
+?jG'~.2KoQX_]yQ'q8]xnH?-pucD~;"Auw8("	{,h?,G(?!lH(ql,~My{L\7EkEVD`S'2l	$g)izQn@/dGy\yg}m}62mHEh)FZH#8,8&;!sP_:(!2IuAyl	Lk~unEyrvUo`D!w3B9'B
+P6/keufWP_(Lq^N0Kx_<(l;*(yU&L6>D>eIfO<>Q Q,(K[F0rk(z)J^(oK9VPZykQbj #/jr$6`1D3CEA;'cG5kEy5ZTPcP+*q,F/Vg/b!U U! qxHuHHMH-Hm:+!	zDH$
+r5!HcHfVjhiii 	r= 7Cn
+r; wCr? C<
+
+9s'78](
+<18Xy?!&]bdo]b_LiENc1Vb%&b+&yb/T1M-BEbZ,f%qT6s
+1O=)"U=%EFP=#UbzV,QRXZ+V@JOAO3EJ$UjxNWX/B	Z^/zxEm7k-Amow[=z';Q}(U}@}
+VCH}.>V_O&R|m\m_&E|7bk]lQ;VS|vmj>GT{.OV-}{_a:"cAV?#8~	
+IYWO8u>$O)_VBQR"6R:=e2s*s3~;f.Rv7Z.d
+{,z@'`r9'^.32B.b8C;UXC^ y*5!k k!/AA^^3aIf+d?r_D!~19/*%p#r_FK1~Y9rr#'GYdy9(\:$:e]9d^%2!}YUN\x?=d59e#:z[SY!, e=YH&.",&JYB&,%[,#hYDa@Pkd"+U2Vl]4E/dz=)k,%u
+OmSg'\'t:	]WToD/jJi2yzemcgyX`9\\+7DTJdf+--7Y+2
+6 N
+m*+=fy
+WW~n't;J;5t'iwG5ugYK_j=(uJ}{WUy{uy}v_ZO3](gInAS}(gW7AP?$~X^vX?*_WJc\V\Tnxwq!;-[>8=
+^oekB/OLs!SZ4tkB@/k0d	d)dd9	
+ OC<YyN(n[ nYDGy*@}	=15J>,GUmr*r<g	.4Xg&;q,rp| b&k'fc;>Sqo`VlX_0"o!i_Z_[6,2Ky!NeFGs~y3\8dDxor1d	DxCK A'Ih%)dZW>z$w57  oB	
+}!A>|ShA6AW6CklQFzUV|sm:_s;t^S=In]|=^CW6t_5t1.n:.iR(wuisDA.qTc:]cP&r']Z!N
+h~)]/ik*(#*MFxoa4T7@94	Z(WLmsdFSd2W&d1uao'z&I}MaQQFGN\erQ~H1L^2idkP/iLijfi\Y0MKWGI2MidDv(oeM{c:S3MyseWtB9d:zTbxUUs#	*vn1a{k[Len+;`.k`k#{}`~0 x,<G1}7Q611yOmfoaza1>h;Q6}1~qx	yuSd9sqTK>u
+g\Wop}NyA\q}Yu>hl;;gg11=w%CL=g!a=rv6o,a*{D!kQhrF9#Ga0$l2F6QMcDa430FaW7[f@7KmEFE&L<SzBdm .6,R,AYlf)`#=a{_re	y s_9}sHhyikvs
+dH"0Of#oTad~!S4yYKcl+|dfXKscGxs|VYs~]^}ck0SIE>ys?Uf2_pKh1q7y/9*c5s]3t9ylg^YtpvgeH;/jfo:||O*rk#So*F^{"<.`#01|ri~kx_{=UZv-O_#?3q5
+rF|i.7v[s]&l.:	%UF-Ooq7|'}~}*m<4/c?;Ow}$_m5osv3s_{?@vLU7|yf[Bn3xNwC1~	fvW`7HA|>{Fc#/#YH$vvxng?zEMMd@Z#~=F}^swPfEJ3y;/y?~}` U?|t*'Mk.CfaFp<l}gc>qB?`#q%z_0?Tw2'Hev6]ocfF06=hl6zl'qvt_"#z1Oa6?>QPGF/<O=!F1FgT?O/rgwJq|o?.)]<{_~py77-ep+1d
+3Mp5{_kDN29&W87yL5&_nh
+2WBp)wbh)aJ7SszSx	dx)dJ)'oSLTf//{x	%Dp &&!%#' $"&!Fc^	@} AW"V&}UqxbubWzu2{]uEE%%ee#%`}NbvbTZ?	A?,%#' $"&!F?	YaYc#%d%f#)~KMGS~'F0
+EEGM;x4BWEbBb]Jl_9b.],y%O	W	JNWjQc8+l?x++kfBAZvZe20,c6mWE=>711xNy+_Q\|V[0.o%YAXci%YA?Ux`jBTq.g}<? sU5~W3!Y&w-k^	l!&Idb
+>*FkM[[[[;;#v&vI`_ey!@ITDC{^hO=.uiG{=^DiO=$hO=diO=ShO=*WQPo@!QoDPoLq:]m&7ZZ)MioJ{Sf79ioN{s[%-ioI{K[V5ioM{kv=ioO{{;w#iH{G:;SLV}[xA#.^/a[0o7]w#&[o#Nx'.{#O| !G{{{1?J(7>ia_}>4,@,'%#'HH01;cX?X~M(DGql?SOO>Dg${Y/g>@QD=B|`gCF|2=d{!(hN1},;~}}"7"1XGGG''# $>NMCGOL%. .$.!.#.'>A\A\I|4qq59/Q1I3gSKOWW">M\E\M|sO4[<ER4_>b'|sj?s%}A
+#~ ^?-o5Qg<9'f'&~>hy~?
+n<C?1?,_}A
+;#~ ^jw1s|FB08,BR/FS/AKR/EKS/C3%}mmivzA)6O`_5LdJC@A}~J6tE-miN"Z{')m]zz
+Ah#h8O>wPc8D4t,\"bRg2#N N$N!N#N' "%.".&.%>I|,Lo[L8880) `P ,iC}I\XR1u?JE\IoFR`_tlR7,9sy<>o3|S/B/b/z`q]RgG#1BRg?<lKp{RoL'.um;{kbowq8oY-yN_f}}?Y'9O%ud\ZmgIiO3)=mPrm-JWnZ[HO9qJm-Ie>7f-Z-Ei/J{Q^09xm}!b=E?&]_r\rdX(t8Q}3 _Y\L\F\c}9} Dk-?$O	5&"p|C8M&oq87q|8M&o(7fJC3o0J[+oa?VJ[vA#vI#]GHE?C{4=Vg2D`_r?4;1CJ3)p?yJY7Ke)x<L	APm"zwgHD FtE	8QO Qwl%?d%Av[dI?+%u)+5\.$&pIye\tP
+>t<gvWSElo#ZMK*oTyWSqWbU2/E9#y}}RU'8wnW9z*ujW3a|k_Z22x/c|_x}1x?3z3oyzo	T#xGv;2w'EHr.a9KXZZRClOkhaz|\S]TTu7NbUteGW?fz5l`\kq- uF8p^f8#8gpn8l|]LWNNxfYge,w6XN]u|%=az{]r>O.r>O.^r]w9.r]~pn:v;q'8N^~ z?we*.U88iz{k6yf,o0S%jqGpqwnY4tU (8Nn{>O+sT6p#nAQ6q'	W|K~[^f^9I$w9||d?O'3I,wNi;r9~i;r3Cxaz;YNd=;YN0700|x'q{YMUO7}q# nM8Cx1^q30nm8cwN^u<G6G(cxc[7'8oNpOpOBK<q,qK~-_K,K_/q~8*z;v{wqU=A/q	]Uwo^~YT88q7=x$?zcY~R6}q# ^[q+^xnmN8{q/,|x`x1<8~]q q""""""""""b.zM	?x7I*2=F*O?i?`o]jV:?]?Ou~u7w=t`W}0]/g:Siyfz##0}H_GUzNow{$~DOS~I.-
+[AZC6 US5d^(m+hTy[7G7sj:IHoOtMNAo9zF_I*}2}J_Go&EyGkz05&RH_7o'}/9Ob-+h&ht4MmgHIK5t^Kfz3BovwCi}/x^8{q/{=Pc|=l,C*O2vlvl ^Q(o2WP=MI7iO3>3dq;?^{3+Jq7*?%UU-]
+G>^kX,GU-'|1eWb9>+}S&Y7fqgqgqeqeqgqgqfqfYOY'>0=#8G,g{ 397{+EH*=7v	VVyuq5 (8N`b~*T~')5s>MhTr>3Tr~G{A!)Mp~,|S,pr[9Z9Z9[9[s+JqtguiX-m&h=P)[_2uv!cfj*drf2YRt3_?;<UQAG|?UgKV2mLmL(?#]|QU88~'y'y'y'y'y>q<.PmT|c9!ka?zUmak*kxuZ\8q=^x)>e8[p^V  nx%^8C8q7 u&Nanm?'B^u.zWo9&6(+EW8<t}~Y~OM6Ml,b[wQ<*~^^v-a7~Q[rV<p ppqcx&6l)>qp)KOmGz==_%~=V*S)u\uq=c? 68-laat]m?a&,%[iuJ%v-a7~!
+Au1l`)>]sr.:eSEy2}_A&6-<GqyJbY^t8l`8}wQ<*KW6)QOW;a&;p8#&_Y8'M^u.M~ljyJUm^kqq=Gq/!qqkZlbgq)<p;n1M	wNqp'0Wj:./6!>);^u8p6Mlb[Q<*a.@|C!Ppe+/~6Mi
+o+wnBSAm
+V8-t8k]m&,;pe/+t"v-a7~qp7*{j7fA\pG&6q
+'qwp'q]'paer/^M+AWb?aY^|6y8C8axl.rj&6qg(? 7iIKO?.}<A'OIJJMJ:{X#}g]q4c|/b]`GUYWd|4'Uu:?=uog/={dyUUT|}KS?JJz_cOJ'kr\*XwMv;Hbonod,"b"Uz}6{t}v{t[Sz}n=>}J>l?"}G'SOH-9EK##WGGe#2M-[;wY}RzPy,O8j4I4DQ'&9].gt/wCt9)iJNAZp3!p6J7:H/p.^\&Bz#k8Is6I79igtM.!uEaE;]cV
+7"c-
+?/8_Iv^q^!}y[sLz9.=t>~v>~|.JJ]2Z3F/uiC.(?i{X+i+XI+\IkfffffffffffN1;nMXuy|w9tWuUgFU\x	M1`)0X<axa90Q<0O(^"K`Xx)K/a0,WWRjV+^kaXx8'
+C U0Az&
+$@ m)dz"@ 0" 0 s0 0_|ef4B	%<',$",&L_@)`9V`%V`5`-`=6`#6`3`+`;v`'v`7`/5QS8]8WXRk^U;[xPGxL	{y(K");'|,\/FCJ 	P)@ uLY6:,@ 	0"4f`N`~`Q`i`EV`u`]6`c6`K`{v`W`o@pXNdNL|.RjFnv^a<)<'xQxM 
+ 	 	 _ ?
+,(Bj& @ %@ }
+0U1f``>``)`V`5``#6``;v`v`/ 0$N<..*n6!~#<!S<+I? o o|('C
+ 
+ b '@ T	P+@ 0I1S@xT!F?B'3nj5D#@c,}8`87kYFjQh|@0-`62_ C-`>>c='!=a`/"4pxs`1O6&B#x+EB<xkP~ qm{Oa2
+RF-O=1ImBi
+Ox~m/b~E
+G0,u[8qbcBNC
+
+t:+Ka!HuZ"Z5Yt5"w-) #q<^O0^EbnYL)rQ)3Wy,B,B?f|esz<HG
+T`S
+LxZiex)}(Xy a:(L2,HB<TKpeA)?w^JBut@ c-.+[q) .xc{b0S BRxxC0w!;sGa(0wN	;s'`0wNi;s`s0w.Esa
+]+0wusa:][0wn-swa.0w{ s`=G1({sObI='1s{saE1"^k{sa516{sc}1>>sbS}/0sa;}0,8Sq<qsE+\0W
+U`sMM5a	sMk\1vcs=\z0Abns071an907|san>E0"[sKan)-0V[s+bnE50[san=0	6&s`n+m0s;`n0vns`n}0A;sa~Ht ?p@@bLuG	G=_@kQC]P_4A$4MG@}r\J!@aldrpv2w'y!|Qo4C-_UE5B&Mse'cT\3Y:??hb_6vHHi(UGuQ3TCRB%PFJ5 J665(I8<zRTEGJ*(? ?hZ~2fh3^h vCh:v0h?F5M2@9DRG0i7d@LERkfnCGQCt%(WQ9T
+UCff"
+T+1kZUZ&frKnzW2/fJ_2"ifqN&8]9,Io?KUMRg"!(ZIYgX2lD6&i3>+vz[vsc<ax$N0}<}cs;O_/fegz+%NN_/o_]!Ymq&?^)a"Q"FAStI^ebLdcCgd({AUgj05ZLmS7Mft%
+vtwk29 >fL	``wDP}b@pTNQH;R">RJO(}zN,!/Kb!)DG2+i'I- =}JA$BIo{9yP%,@d2+Q%	1B2FrF<E0PFF9(')7eNv^D	a%lDa'e$O&Bh;iB#cakZ+U:yCZY[|erdi'[ yo&DeNuL	%R&/~
+d2HT2BzdSa*BeS>O`|tVjBCh1O3(3`L#dN2L$RPJJMi)Jd#9D."73	ETn(&'a2Ln:GUt"/O 
+D2//5Py|T~ U*D
+0BLaS)g
+NrY.L$EbDqQ(E&PET	$U*MQ6t;-=7bJ3eL9<S,M!Ed%2Y.K/&KeTerDyQDT&erTyUDUP
+jSTf0Ujk5ZdmYG'D&QM!RTGI52_u]EuztmUGPFT]Qh@4$&D=>i4b3ML}nD7lF6'[-Vdk+%MT)jNZRD39hI"ZmfLsif0mT-jOu:R6d[Dv&w:R;=Ht":]D;=tb:3]L;vvdgNl{Ev%tgHwT7;1!zM7;bz3}{>d_@${>t?/Gz awQ{A_Y!Pb1L!r$9A\F #4M!r"9C0F&)Tr9A$')Tb>1N- nE#hr.9O. YFzC25het	$\A$d` PO/XU;b-XM'V|r-\On 70M7$ _@?;hY.OW+[md5z3(fzS&	O_=u@j>3qd!jd y<L!!}^zO?|[:Ro)'	#q<N~KveO'S1*0*Vj<A}GNQ9$BtCiy<Gvc/??Dgv;z
+vT nR;NbqcW21xKXH`[7_FAxO[`"'`cqM!	~J&zMd*u8A<.=|B>%' 3_iIL%7#u?D]QN,$q[A,"@W@bq=gzFA=^P/9'%|GM'H]>P?R@-fHdIZ}^_.A?Ok|UnP[1|.}|k!@}tMclS/@	_MI6/^LU@%Pi;v^7OO:~V_aGr~MiF+R7X0A[Q~T|5JYP34dm'MAJG=Q=CxY&X}*QYE+&dfP|,yyZPUB5.QUEQ4BEPuF_7HQ$PK+<cBu9!-f[D#$4
+0B
+6 V&pU eQ /eWV~
+#O:>dp}5G/ +[uKU1TjwrnC}2gJHg-!(5j}K7[Ckr&-Oj<'.>|4I0C '3N\P%piKe.6K5/& Okw?{=!3aITv)d\L2wxNU1<m/d~3yh=3M03O_@x%L 3Aez
+f>_+Y%l6@OgJ0Fy"Sg,xE_wW&J\f_-o."5*JSq-b})/8OU:~O>]O%yg>BGYRV*fB|b00R,r
+V]_[y=`Y~(=2iuT7JI8)7A)8%7E8_/WePJ\bZBKiM4"ZN+hHiR2JWT+,z:F4L u44AN3i!L:HXkcMf=l
+gl16gIun bS(fej83)8sY:rIq;~ ]^r_$W2</_z^2~BZkM!|p9BiR dBLIe"L zL[h6.;tN#TQiTJC_P,dV2[|=erP18nNr\-:WSl.6-bl)[Vbln6/-fli,[VfU\vX^
+i~WpUV~D\-6^eWP
+/
+[*NZ"\QW+Jq2\Y_AbdqYL_Wg*Q1ff001se
+szVX=V-nVkET>f_h
+_]Wbl#	mbl'6edWd5l]>m6e-l[=ve&tSnEkm3ZL.sI?*JUP=%tj)<@%r;(C6C0E85r)#rnn(JtJ*rQ%H#ggCt:+Ns9pdW%l2o_Wd~-`1WDOV5d~i#GtAw8LtGn\'3*~tCsK\nQY"uzPin-b v;b	$v
+f`v(;fdv*;F'zp'\/$=;E&}^Toj 5DRj25HMfP3L?f 3c&33"fy>@(b41K#W?_uk}03gF0f,3Ld&1S4f8*s$~>1s*N%p:n!ZM9\j+5@L$&*4b:1I"fs<"}LO@COlm4uFPCjh;a	V6BA2t7H#xz"=EEtf&3a1Bf1Y,cV0+Utv&;x?+Bj.ZB-Q+Urj^:A'Ebb	+YBjh Vh[-fp-CWk6zCO78z*^IWMvz'GOK~8s9]bWk:v=nb7[6v5Yg60f+dv1{>f[K4FbBl%M\3nyG#o7sepFZ:<Oaa,GSe}4P5LmS[HoQI2PQbj+@QXz=Izhv1jjh;kv\n'kvb;bw{>v?{=b/=`{dR d.R*9b3G18-s9|b0gt-:^p>D'3Eg&}G?a=}D_owG'}=~bOg9<{hj#pO@8"%g2{FYE_]Hkuy|,ky8G%g_|}JG.et]Eut8 3zXuCJQ/WzG>P%y<e~g`1#}TPg#5akB?.E;xO!PN_gn07#$na?oQGt2+qv/j
+se11LWM=S@\A]u@PGT#%!xL<!Bi~'e~_Sw6yGF>cyPU?gs*A:'|I"-LS*D+&a	`TI`L"cb,%}EY(+}j(-E!^W5zw=>E$UB0K_o cQ3F#cfIs2!y&ci!*jI?4?:Go@;q+j(b;P=JA0aO^a?'>j RxEv7g<hW4AVH?00Gv}3@ABkka^IhZ
+2QY@
+,T$Y4y07q& VgslF+:h6*`4@N	_{ C|`w2	(l(	P9>B^RPQaghM,-QnmDro_/+/g*(^g~	
+'_~A}|__gWqmYk-_}|P`AdL6cs+u_}|^2+hw9,W+g&/U)n7Xl[&G\}O%)@sf?~'sq\GnOw[z_J_G6CKWAjY=NY"1J|px=:~/3rfNw})()5z&yoM&]r@X+aeHZ$6a6~\*$]
+bu-[2i~.Bp4k?C";M:@I?E#=zb.1XJ$6Z "dV279c?;u=N'cF0S60fAa3#`e3Ff/^;v<_Hx=u@mT#*O%`|+^ ngw~{WN~P.v=f='?~@?1}#`C>~u1XHRFNR'P1)~4"IVc.~8b'/S*ZMk"Mu4a; v(;Nbv.;H~g;wJ~
+uy1R}E.{*?yy/H&x[?7`kx6J+y?>[9=^%r&8;9 "\DZ:z2YgKss^E4.+gT^,8F8 ~x8=<{`^`7wyV:OFxDLO\34o{RZM%'Iaq6;2aP- l\.
+qEb\	W+U*qU\N.7
+sE\I4W+U*sUxU??\@`A|lA[-VfkuFl}.ls_O}=e~oF#B{vxe18jf`e"mVeEd"{{~!%t9&U?wQnD7	X"I?EIf^5SWWd{&;r{i^/gY.HoqY	+I._~L>%y'B!*}
+'_(x/T5WdcG'~^br3La(S)`j1uGyd}"6ab?dK[~w>Kj9,`F74BDJ$ju$~dDF"z`k-]G^|,Kk?~=)^oa+t+(~Gc	E<HO|d,3VGLG&S)Te3-6Lk	yY5I;{xd:N|=3/{;],|AOc;
+e$NvIgU_ue2BL8S)T`05L]>itrzR_;/}R='ph z0\m=_3?}qOn{' 4+7&;xOp01f3,b0+5:fXf"f3Jf-leQ~>cP{AR#(4CQuBQuCQ5B?q>j>ho4&"~{4w|9Sn==Sz
+;`g;&S3"y?'dKvWtE"	o1].c32.~Gs5XK~3I,Pxjj.Z4erz^Ez#LoW&4POJg^=uC#5^&`5`v1Cg.`flgv2as9;\~d.1x2{Aw=^z>!0}}cW~ECwGHw;Ho7t{4g;I)w#;7_^g=>Zsdu456#%='U&DOb1;o#Eg
+{doC1}~HG{^gaowo}^/W5:}wWGU6qxG9K!_S;=='}d=J 'oI\y(^"&Io&?\7[mN{%S#1=s_+_^2/'?K~CG1/1H!Ic_7;89qN)8k-sJNi9ya2#X%3Hd546"	#Db 1'@~BO?s;5G_a_H,kmAVg<~"IYEq-!@Q!TAEQ1TFev)'kI3k2@*A	H	Y%#JA~DaA1eC9P.CPuT4Z*S#-!2"3$@.F^CB(PVDQ^~^:=;=-OsH2>@?} ^5`VO;Q pA
+ou90V@O S@>@;5F0V<xYa`aT)30J-#N
+* #K40+Xc6 UDilr# ?zB4#;z`<WqYd[W#~G^;C@u{8u8O "D)@iEt }@QtM)_;%S $EV#0|AQEA>/6%/T+vHO&@[-Fm]LP{.[hTh5JEC;jN|gy?{^Bt%Qe,8AaDgKA1}{L&4<CD("4hDADb@%$&pX
+kg3d(dJFz	"/L&Z\FEr$5*~}Fh
+Y1h
+'M$GhDb9F#G$b`/&gbjMT#Z?Ol"NCLJD||@G+c0&XIz6BTDB$].-!q}aP%F~&yy`Im92L' 	PI9jFFPr=i"%:$InGF~n>4H3` _b97H<KDmR$AfQ!0" 6YGk5A?MFG [`i#D 
+"DA?zEPdLTDm@Es6l{	md!DT,;1u#NlJ$*%rTY/t+6;$2J#>>`',r2rAOr$Yd#b`$ r[l0eUCJr4A!PS:BQa<B'\E;mF t u#yjv;TJ'z-EK7X=ITQwRF,"uw0TXFJN${4r1JV4XIDyfn1Fh3\K0+-yg]~H"c6B*7e~nqL$@%C-B!E	thKl=LCYBd
+dryDF$'DAt(LdENDM0*O m0;/FG]h!~$r3lB Doj rIy"]{fed] _,mm7)As`Z#]| %:EH,N\B{hw~f.,tDg 
+u`Hx0 R@V!QWy]V"'QT}_{aW)z\x_u}G=	'T2I_____;`:h6:jcDind>F7EtT'SoG%5-4f;`=v_} ~5b2K!*D"Io(g+j4YZ4-i>qZ}|%eeeeeeeW{c}'`3q|&77T|ltnrov/y
+<Q	[Pzo7_:pMt- oKam+Q)Zlmyl'aF9IPm(Nurmglgm+_:6YLj)QJT'$'!IhHBAOTyKA(ID<Qb0oj-r]	1-zF ;F;E:G]5`hAnDupP/Ng*`!48>=op~}`<g}8F:G}`>`>b>~!X2K!t`
+2a7~
+{5^gT?%8:w@-s"4Posa,Nr>W7#;O|9Qs^cszyxa.	{iv'i@$
+0EyW
+I;{d('IbDI$I4I`TD(9NEl+iQG2V)B%EUmYUD!HoBlX<0*d8$.P%W2J
+f$eejj,+|mz*j+4]F;DZ%]\<#E-q^bZ\d4rh6~KcG+}lu`p_k%C >%=l:2bctSts*)!"m}c~g#	#a<?-#S9$Li;i#Fi43-i4FzmX|'z=9$dOH;O'IH<"y$~ ^w 9>~eye=7UC{`r_|d=,{{u>7]] @OnjCLi1&GDFWfth>pMKzy%49- Lj+o**:^Iv1'X8xc@O0;1gRBIfW\[dSCV6-%yk/DJ[Y=yG&~
+F%fmMRd{3#73+Br_8j>f>e=o`O.60vD*]\##H+#px  55PV:fQ9\p: oeUueT]jWK-)vJS	/(<J@iiNCIx>8T~H <Q=2)G(fo[)`SPc	3Y@	6CO[Wr_x"*j}dC$140mSdsdKdk$l
+R"nlzvDvFv	-]]sv ,@*)/	J,B,	z!JL"c%=;ZgddJAh<7cR\fIVrssS2)fssA+8KZ 
+xMA6K))% )u%u +RZ[_?B|~g#,-Szgb@AU3WZZ=5"]fMf\0.7J]aZ'gI|}ro.; wRxP#T|T.*^*}[{)PU> ~6!7 6J<1P$<sM k<Of)M<SZ-`+o I!j-qKa|pbI>1Ti2\S~L%hevSznHl	6,e JFp;"Xi% qN kRcEUU*q6u]zRs(6nJSn6S
+{.SyWS#}+hO85ScU[!=x,C'@<	T4t_O8mBw	'N`=m=	Y{:e~gB@FI2:!Ds3L&St24l$Ed	j;;|!&ic)v(b?. org":t4xe}xow]"X!/{5t:x#XhwXhoh{'Q?lqO<RPF'{;zi}ih0e3Zw`lhb`t<);it>d	uFyJJ H&! p^q\=F;YLa:u<.\ qtrFRw::7L"/K|Pad2w*>=xJj}]}}aP'
+	\uxg!l	nnlUTSz)dM1M.H\ASkJhJiJjJk(:*]!YER"<%,iYlEi93-WZn!Op`../M^t~#oGPq!W~&LV@2OP:Mr-%B>~R >^(y`kme4 M~i9a_T!oG5}HjCW7b)wIE=g5^TYRqIJS$|knmmnn$)g)jdkaKH80rmY@y%V\O-!j!V&mPnuOvkmM6R,S{l	61liW^VU#^^V6oe{V^z2K_eQpU4>t<xRS2(caEW=[r>]pk3;@YGGDWN R(O72Zc]9FEG6&Lamm=7YTV"m!L3=b|&.v9?hga?s}d}0{?zB,=J}'y	x_hXdXl*^b]*xen+~U,|u3Sbu.W	9'-I!lm
+mMeA5-=ZK'VKb\l0|-X 9sM-
+	j)>Yt5SjavJCL3}MN\Zfb}dx6NL	xxdJtr3uhZ8};w%WNctorr%O>\]H!u0gD[!*e<[^.e,i}s36!n~y>:g|!xg|TB'~/B8`~YUNXgtg
+szoXJ_x<07M 3 Ow{xzieyoo1.Ny/` ~e0L^zm$:.
+2?2>RWcn&bh_o%Je ]
+YXU)p/QeXV#0tn~A{8w jx{	qtK;_+W=-:wX{x?/0c\LS5pW~~~U^{jUb.o{;8K3YH=6>N'rSaZl_biKo
+JEEST[!"?<"7l?#cd/"?D3#9vQKzW,n%ooYcg:m-=woQN.(-nl|
+gx_xB1F`-L0z{460n4O";Gi0p,  X>/R2*a+Y	F*ZU555$:cma6/> Cr@J;p(P"2"~oD?=kPwg|:%lX6qb0tX$ ebb8W/5
+DFM$PB-A@a0&F[&N}DQ1a	,Kc<2<sMZpG@_[FLF	4RrXb{%NzK_RI>8iHP O42i`$04h,gf|/p!_9(u&_m zYPv_R^W6NX[K.+Ia|o93t )@Vt#eG?5bZ=P
+uEEG}:TjO7q4ueHPZusGv'[_-luPhhWeJO`+Y,F"n3]><22:F|(x*Bc078A[m)i- Um
+'[LMTe@-Y1R:+k2.^^3QuHu?{/{xM^3
+[+9nb+9)x)0:L~`hp86>7LWhqNwwC\%2aV({!s76:g@69q9I[\_]9R0<I(7Qwa8<N
+)w_6n&(*F)ZnPAku"`D5TW&!$z2F;	yCj%%m
+ CfuN[c4:L0
+:3W_We) 1Ns%HV]P667)v~}CcviNhsk3>gpBrV8%{[_'y8BM\~@0R hcPa:y010R"W 0J|ia\_O|!;Ba{*uGG..jwBOy.IlBz,l'--j9^W	w:**$M^'*j{07$^h4fJ7ef0ef Nh(x&XHShLK9S]/S=wl*ST_c 50!8<<"j8 c95*8:8F<qO,LFL<mJx/_e1Hgk/r.t/rzB#"fi3Ly$NvT."#FT#Yf-rrr*5/6NXXlx*}9sWz^3@_?X?majoL"R~(T<40g7%, jC2{X>LPnBDQ
+4/^II~f W Ls?-"-#uMUm^h|8	)VLc!i@5#<@_?L?\_j{~d~~,*
+b	U
+wQ]HwfC0p@(
+X8[YbN5R K!~VO{ ?>F}b\PSSRR0K8A)8G	 L^Jt%}jNb(&d8f Mv=YU0C#5>a+g9}aT1mLZri*`ey|q4+0WJV%*sUO
+z`Y"!#yl|blHO#U"UqX-P{k:Va2Y
+e$GA<zJl:wjtY7LM}
+_B*}=PiB42j5UKi#_4ZV{}Noz@) 9R5[nT1)utcafwi	)uS&	+ntSl* g7kjkR kj\>&nUZfVvNn^~A!n5P01D^F^z&qyR!A8C=h5&ABX?u`>Zme=5vjMRft4z JJC&^5]\R /k7]R"PD;Okj***<& G.jllbjnZlllahllarn06i2ORA]glMCQv!p!gGR_rUI3h+Xc@ptTwRvuk%v~
+E'#t4?ObOyF?Fb>-k\Zq{mI:+@Mwjf?n$ZZPsE+T*Jl{
+^>Hwt|4vJ).t!`|o)/s\o1@)P7=>uOGc$}AmC,n+e&cnS7{L;uqCRCj A{Oa IJ!-/d6A!QPwT=*w<d8`? dH],Qv J{!)CS61JOE7g48j!mPCf)nZv416563$c6O[JF4A G:s0U#.	j9UXk:0wZ;'txd5&ihl+RI_g12yeI32ION45i`c`56?OM]i  gff@jy|w3~)x[V\a,MZc4Xj oGRd{Kfx\$Nk$d){k7a<	>911c''}Jp*o033o!=I;^{f;v7xM:s3 x)Mwo`'j'k8W)iqpt~`?g9l\6zy8|gl:Rt1\2yvL1}.\DShFJ4*Fmx<]=#x4\C.`4$\57OvzT"=%->I**MTO^x{;&p4p@-I	wT4p"0K|2}`{s$Uw?ec4eX+_q?IeY).xYO_zBK!Wx+ ^_Wa
+$S+ml3mkl3SkmlvMfM>.vb3~F=hwwz/!Jm?euM[;8:2b!WI.*)Lye0i%N pFq502&}_1qQ'v#W0D.X}X@}CJ o_9UC`B;FOo$v:}Qg+`?8-&?
+g9P2*utHj`LXRNH:)u A > sJ)d-7%VK9J;8:^+tUs0g6gtS6P)Bsm(GEt%CKbPP>k"Nj^c:#2$Sz@q\qHaS|hgBkCYc^gqzh-2k4! .eWrvg\g`7TW_>e>dN!=`w"@
+4y~6nSIn:rg >IuJg;6PN^dxnNu|=gM''GgC_^>g:=$N9<2~;g(8)t0m&Iu1en1)'0=RkAN u?e	e%^BM@P$YtAd_~!B"&Hz}O# gi)E^J|9Oc/B/C*:.]ho}avA3c/L$:So	}wB{+n2l0s-rL;"&%:rL7"MEM_"
+@C>	W^? LJA?<=e;X[kbz#VZ@<HrkckknmSw ce;om355w\_]#{0.BX<Z!VgZob:{@l]S=(""D4HUo;Nikj72BI!{ZbQQD3"Q9WxD>V-=MWH; (xxWv?`gWeF3H999UwD6FCnU.UU^U>!0>UQ>OH^{
+?}f+Vr:gTTU?>3sG^@WZJ`	b|_w}3oH7s+4XnO=MQ]Jpd6LH~)x(j U`_mV;s/f;0''`	xL8>$8ghnA;M|\/?(=~PdPmpfCh$^>:S*d5@J^PT_C(IEI1a&Y*.'+*ZDv+0vnJdOJ869IVUqjmnjc6lD?E4,G|nQ8|B\4~@	ZKtA?_R$^R"q!`Y Y\E.\]xK fVNarabA*@^V2RJgO@A$g&*FH/L\*{ijI^${?CZW;`ns%'#pI@>&fg8]&>nIHb{~hlm08!9$a=c8Cc@S`3)9u9tz2	:8E,ER@ ,nIA[HQ^a_ ]_RaZ6ku"c",\D"{Y"i7%@+"rtu6$<B*6NtTu#Im2a-,rl(gbsD!o8LBEE!qH# w4V5?in+|!E8SU	IngIQtbADw{B+7r{+oyOxB..`5"-o,`
+\SHRl,K@@|SZr.Ap:ge]q_u_s\wnq-`ooC
+6,,>k*kX%_w~*ZqhV0+[!kIk O{_;::|y~fi,MHQ@bdnkvfMZ j(`UTqTu\lg^A5>W(;smqmCj=R S&B<)292%2ML\5M\2LZhI&\4%)S>N33ErV9sePtS[&T&Il0C+E+iwF	
+!dY:ZbR-vJo8(
+0FVDx0J$J<BPDjzRnE+q4+iv
+9B19Oa>JgP?r{7`4Pfr(UmY)SMeUjm	6M<HR$*|+utM`(O }1?
+=Fc@$:a^JRUZKJJKKB:++PeM0UVVf*5a#i8U0uj>g~Vsyy9[2c6{Sf%1`fa=
+`J1I5K9
+v42[NjL,B?\l\<|VA$\{yB ~po6?o`tPw^d8d:trn~Sp,)moooaoSv3aEnw{s-ja%A`W;D:LGbeD(1b"&t-(X&O|B>d=KCP%%qdUHZd+&5v!
+vv{?4kBmqckkLlcOp=T}i`2	,EohY`Yj[--+,U-,U,+-,--k,5-,CXG3]YGXf0/N9~O sO|wg`u/Z%iZ a	z
+RO,&o7x5OhY}nI'IEQ9>#2TCjbj>	m;*$,)ujI1SqM&)iG"Mc0$6D(9_G4CKDK
+3T}K[ nQGV2ybIRqvIm7C1a>?Q /gt*@L,6*1j!G\6zF&
+W+V;fN.IM(SDBlK* NJ:'#lVy'L@	cI	S;~;-oq.S'M1f[`j~Fmr#5frDmmqd@V
+h@i6kZA[n375YPcI&1i7lX3[Y-KmY-g	YTK`)KKiK9K%KYYZX[YX2"dkv:	b:Z;g3<o8.'$^Y!'xPo	BX~KD+ B6kvkkNZY:vJ:t~ -o2yt^mp]ohv]L_va?9U#=|VH5t c4erf5tQ|l
+N;	E^o6aj3`xITGvudS,3:N!([SnZIK#NvydE'u<)&5tV@NAv\.H%v`Jy|^|n->yQ
+	o0JEo('r<(/#O7!d
+#d!bL1Y$Co x2J3Fi3cf.&85b;y|1,?OHt^8I!Oad|Pfdi?Gh?0G<Kn"pkeiXXe%%fe%2ddIK ' 7)IW>H! 1(/$b<{sQ/s>Hw`}uwXUNmbVWMag+t?
+[gIA\Rm6r8g,WV^N9g8+!gBTgDn:R=^/O 0
+[bPREk <77x&|vR KV>_~~C>G}dMRB)EaRK`8%5%E1K)+R@~]@a41-5dN(X,-w-y)0'S,)-%)1pmgcEtuS<)>p]0R7!asBl	{sx7B.m%7 -qo9@!(Y  /7:696;Q[[;;!Gk.KB=POo8lt V	!x8t9h[)Coq(!3V -*T(XFTV8`y_\l8H(
+zkWPZ(5Ma~Ga4[pI9a	v>kBkcP/W	ijE_QZ75Ht;t,04s!AZQho@	{B-	}3KweMRr8#%' +rd!zQ9H9jeL!{$#'(:hl
+p(93+;xb<|?8+Wr;nd|*RYJAPTN "=POz|iUD'-Y54$94JM_Lk!Ip4yGswk h]YMUMSdw-|?*p%rhjr8k mg)/L,+Gq&S(P8*(nk2BYi)x+`jgQYhR2R2`C-#5gj.swX^?R.60"rzsz5|	*P".a{BqoP\sqM1*B~0Q<
+XZY+
+[(v) }+WNM)r]a[1N@{>v1Q.N|(ys9s;8C=o3m34Gee`/!--<`WB%!w-`)	m	1;"^R{vxUo3DGuta}/RbxN	WyKpY 7"~Op~L/I0^BX4\/ = -O! 82
+u;6Krs@(qBrX4.+X|E:KmPSS$a.B*M[ syQl^l~l!N/x	8,V<V_Y (U^^e!GSU"#2<Q":t1cN	KF o-)e 2/7>}*wEzg	$<5y+*-=E5FU TLT9JRUeW?IVKJVT(?6?q,.//{q~__A_!_agfQ~
+efAE@/],pK8K&/K.wUUy!*.-5:N")
+sE]\qO}3J1SU0Z}?LEZ,:t*og*-	R)NbgGaug}ncZ#[XX.vXQw
+CRr+tM6$R)ut
+)F=Yk.+++R 8l\,<@1>bR`.
+sHPB)aZ()Z&ulZ>S+A\9
+WY/>(npU[TU	8#mf%Bov~(c-rLuR.3	ae,.V+ ^14jA6WFlEEe*xYF2%9l%9mlc,l{yq_	a-+/}%jYwIWwJ!y s	oIRx.P[[[+x+zq0WXPwI%MT*3ee?r
+7d({Gq;r'kinrr/[~,r**D]lR2)\K&,Iao
+Y1P	%E% U9PReXr%aJ.,I. ClrBrGM20%Ru[0V!.;S1^*#
+USze}t|7ZWht}u|n**S5m e/OZJawT+IuI3Mn6$mL*k-W[(WT =S:]Z:4 T5W=dL/p/}~K/~,H|O(h)+TcuSusT]uusu{$t=u<E\`dX>pZE)u! R(WUUN(-
+$QE|J.JNvN(eAWTT{+*{b*>ByvV`OTUblGc%'J<GZ4DBVQe}\2@U4*+wuu8])'A*f\yJ]Yj ;Ok%,9y5<DV9YMxY!*&mUm_
+oYx96|V m	)
+PZa`^QOKH+\*
+]@@@u.mT5C@+vJvSsKgDdlG?Z@NliM%dLRUh	 )\vPM+6s-Omk\@@CyqU]P=P#PP3P[{3yfjjxNT-QC0V:lL{nMd5,k--,,-rrrrX5BB8FMOLX:z~KlDEhYD(q$WVTLl]OjzOLyeisquJi%m 9j^Vmpvq--ETUQ>zr=W}z)jjabM#WcZ5vb)W'^9WJb^;O}A fRQJ64JB#!U50$Hc>H $q*D %LI!%o0z ):mk-m& tjkkk72SLv+}8 $1U&kDGu_n+#S/5W0"#[g?V_O)xl7Ra/ ___
+!y#r}cA,)!7j[WWlR/>1?HN2H)O0W6	~;MMY[O++T[Bhe]*;hmmcm!O{(&I	}:VKh0j6kW6	777"PwP8:2:mmD;`TLuMkp-}^%WsMe)WUaTs-Zc[)''HjQJj6I3I4>'uHcT);&uJliI"[md;=Dv&]ndwE&}~d"bV[
+MbqSK& W*.4`q2rwEPoO2cmm!SCAEQh*/Yrr	#)Jgi*ZT^d2P@jMP^^Y"7-RI#d#<R8#ww-B[l-D6@JVZ;Sp:0Zc}nWC86GCgeX`xaDatd`(4[[}m@NV{5Ys>r?[m'Sc-Fr0y&,R]$=C<CSN2OxHQD;a^"	+Y-#q
+&f\Q~mjjjjiixG<x\Ki2CJGsGy.)7t<t7	shs]2&U)vC]F{>d0%1V!S%9U]NuKv{_u0mvtt(]ZWy;=<s3	]];dgy%XUH){xKQzz{y{{;XdLkW<TtxkOk7M$~^`';ooFB;Oi9C|doNa;7nOg^cppp0RSGgWww-3V YY7<_#}x=4+g-+2<!bh6i.Q44{GOvttt,--,C-C,,-,-
+|Bbr"0X6Y6ZX6[ZC.\yk?jE^>36p[q_m@5f4r2hE{ouo`LtuMxKw!}w_'=}|B_]A
+2\;<Wiu\wLaie-1K0":*LY>`sfK5#]33Ase3?z7wOus}d}A*=MYs`2M
+z^d~dA1(tR
+fJbdQdq!fn>YWG;?8?:sI`gR}jlZ@N)Y'Bf	-70+@Og{%_fVP3Bz~GIrXM/9vW&Yg8+4&g.oEF0yEq8$Qh`hw^xmO>wOHRq'M/u}MxkY@cBz``Pap`H`h`"]81T%* -C15qJb!NaKB
+i
+[^16z1xH	A@mIakX^<84,YKhZH.k%gO~['gr.TlxO/` w_L5o_BeW	{I{#R2fBleMG;UIAz,-i(0a	1WbB?o	?$	.jtkq0`~JHj&L [Wm-q
+uSvQ~Kl\Yt_
+=]@4$!Pr9nm|~jAaQq	pA{hzjK![ch/Ik oQ~r-WsoUQT!P p@ _AHC!0CnTSwAz#YJ?B4C4B4&hhfhh6=cpw/'VOv}Xu!80aP tylVza'	=<s6X7	5e[u(C&w,|nw]iPHM37Z4L784:BRtDh$`	B%DYeCcBc1w|P~(s?%Mv pPdQ#) hhPtm1HM9i~szFN)r@)yB* S:Tc24Ck'*77\5{Yn.Qho,	-[|3>k3`BF{ 
+F?W`Y	7U6.<>EjF?G:0y/l,+XC INvLqRihjx&&B<'+e}S@_RqH6-%?&V|Li}.v76 j}A}411}G}w@N]ueNiI8dm0GSM wEQX^.-e_nIW#%<Nvclgug
+1agL0{\can5Z0>0!0h7IQ&>NxYX AL{;	$j)^,*."+*WO3 	Mr&+/R.d+a
+S!LBmn|&fgI2g~I)H7IP'I
+]0nJC6il
+CPnhq3Fw-SOtiffqRj#kB"E;ho&MH&=if_?-5e42fC9y iS/PLNOWf32L`,sHB	v|MT$TZ
+Q:8(OU@J:J].I& wiMg~[sHT2V){0g&SF]^:Z[2KHKbYgV>2 `o,L:eV9s:N'5W[qQ%@_*|Y# fr.9O. r)\N Wr-@n$7-VrA$gByo;w:P]w]/2|7iu/u?u7}Gw<S<pQ?98Fi d=l7lE4CawxfkUYLVcqRGp"pxcLKRCP@fI50+ech_#7@71YJaX4-q[~Vx6ssEE7GsqP[Lo+n\e=^	3\8/uC)`]aq a>8'43qzdzhyB\#CBs~sR|\	9edEX~j#Y	KsRrUCK,Ia4>R-<eE\}uZyuPcuFhXw>zyJ|'VN2'm(d^ 0(RMLK0eit?e@]]	|  9L,nJ9kE^1$	R+\}(#<a#zyI&!!Wv7 ,OY	!#KJf.@j<O|}!7NPIPNW]'L|}	{@eBlMuE>-cRL'sJAg=~ gmRK%K?;B(IXqQPWvEgyXnpG}r"d5t:LX+hF;tkYZ8 l4hVv7C\Z/j'_YI~P
+rUd&HkHZhh	QJ=n%N(>uTGnsqC$>! 3[]},w
+5	kHGq:G~-	++5@nvquWP:zh^}V*aMxR+:VqWO ?1mmkW _iX^lkiW7`x [mx\RVCjMJ @Z)9krS)66hj#;:!a{a`7rGYUS*JYad Y&MVZ.qoh_hhm"=uCky+\3VH7NV7^ZM5Ll5{1x55lF/e`d%+o3p(H-HmtQHn<W735 WB],!]}dC.5_NkS-t4|LlV`tfM-h9>aww[nmR0cNqj{nH&mi].[hSDFuY|7JAEpaAjP	7l=z&,/n% F&_>K7}2}.S-`|};|-N&:DhpsjfHo55:-:=:#:ShY9mh)d xCnq6-0S<00=#3fohu'mY/ Oy~_%?'>.{<Ktr%B9
+qN,N$nUW mA[Nv vgv K-vPt	zrrkxvwwJ3
+=:XDy-pM<7Mkc}yBTTsUZm?+?u`I0VD !!$@d&D&!'1"
+=U}&$,~{N:V~=\ME[Pzu_0qgZ%@?decg^>W"Zhy%l#!3^bWN)sz@	U)7WsW#t[X[{]i:_<vl,8 ]i {/fD708[7oSqrVluf}maSGm ~|2Tv&Vh1tt{wI~Tp[36.{zkF?6m;tiIa6~vyW!~;v;X*F?#CXRYf#}K%v63-xd)mn[7~+w~/o-,_RTj{+}[8#4-Eh}0v~(|Ru]trlRo3V|@6xYvuxuSJ5Br}[.Y[6RfkCrZq%tB/Z:Ftf6R(;-<=;3.[6 ;.!{> !r!G1r ')r!g9r\ %r\![eWU%Kw|T+^Y+ux[wT
+yo{Xzo}W\`w^hw|Us)2ac~v>ZmK)eelNR*96j;Z+WQmdTt]mLjlv9ftjMwo[=6NB?NIN AC!t)NG}toT/`i@x-H]/]WsHQ=xG]rl}w#x{J=W|(~_+S;XEZ`{2{!xjqAu"oz+<wz/~}^r$TVw{STpBw&S){;[>pjqoK(qjh]oK4u{xf^}~{:k<wPauQ\p	~ ~^x8w|~wRY;:|]A2duXbwE9u.z9+As(;+UU\1bI~8V}sUgyQeWUgyLvNeo/_e6/}tgyj*5~e?=T6/BRJw J9b(t8uWCwz	^/!(:Jhmi3t<t.t>,}7[9mLg;tkN
+G"Z{
+o{]?yp,H0I=4Uq8^A?0<,AuOa#`\R_'\hN\ih9`%J)J+DJ';V6J*J'aK/xb7`&RBqV-K9x]q{>}NYIS> >|r	$w;r"w]r&wr!{=z,i{IO2e<ysQYqsezqhYeLeW?Q}Te#i6W S9rg*`S.]9pr[ 2KGT?<$UNURtT9sUWZBo2*3K(}=)N=ng(iC{n9N {@=c)K3=]jG,;=*+EHGWH]P`W.	WT=*8b=h[%dQ40#*+nWSm@?Vh;4g8vKw KP#.Pe8YfWvT_qU9xtqu6,wVg=(,^3 ~K;??VwY"v vYE"u
+ms4*K"JEk> L#m7
+rBK
+5Zo;?_[s^y3X>}bvs^y\|ppj  J\Jw?Wkzys_>fp<yl ^<#G9_`}.m;S(h6c>k-vBRP7ec+8e5u\\(wr5dX]bKj/W
+XW*_"\y#^:Zz4/UrU+%:trvq;bsK<P(QW`{Yr]*wC[]vR:e | .^mnPyfW}Ae7}o.Yd{\U_HJ/_dcBE R*]b_lQJ@Z7UnTyR`sswtr*\%u o;q\	$W+#W8u=_1zkvz,o.A,ru!os^le[.]^fmfAs;Y#UCuloaWCM[ &;U$(=W,eeoYx?us3.v/jU
+CgSd_;W{9]^R |\..F,%%6+i])|}HB*MWF1%mmasu;F=|]m;
+Ju~[=Ju/rZ|RK=vC}g7nAKKKG~]tzS>SuFUgYWur
+>:C6W>*f,!<AhNw}f9qZ]~!kyN|r*p`O|QY?<@_`=G~p! ]M_]z?]heJ-}02` yYs\#W|*9st4*_|+3
+_!TA[&O3}M=| ^xY]zIwW+S7,N 2V	p<B{A=H"uQn`4y+zUSgrT"R>VMqLn7qBn[-~~qoG8[nOy(oCh5XxlRK]z.Ojqy
+yznwMhQPo~E}?)Yr__}Oi5r/=~1STy*!pd;%_Ty*O*<Am)g?`-5vIB5+pP w$
+Ogs{pow{}p_9Gx}$h&LT8Vh7n/6\~/^[wpXc^Ecm:oSUeeN~*G:\cIEo=%oW=
+dKz'IWw|Y2w}y~]R/
+?+Hw+b? ^^H] k+We{~^vo~(;p#}VvhZ^=@v0{+6.m]j0syg{D 9	cyG'|'8]R\ml"R]IVBw*ofs}et`{FG#ZQBu<^g*B<g%bkg98;>|%\&SV_rKwBM.S-zn6 y_WC^B
+_*8ji_Yq@z-v;~ }r@>^ )3FVgea(t6nmT>n;g`.--WU[m*]'f%h?yCo:\|	(3=|0IAr0fuUp)#2`NA|1uXb?,G?/ZthaW`7<]~v#!o]qL;_:}zU ?RW^  `%8e,e>1FoTNW6Gb>dEb*LbuwDEH8Y}g`%WO--
+}beHC*}$}/gz_iN:rc=`R~$?,]wAss_7t,nTY_n5jYL/{~m	v\l\ h4EqY2+A.NXFFY~<HaU?&H"@$# 9YJFVWJd!Bf/2!H]Rt%I,iF&@*&+
+2#UH0G6iOWLd(Ib(HDR,&HK 'diKh3'YdNTBI;RL"I%GC602L%F$8G6 2$!$4%3j"A$T'kH_bO$id$d.EGd_NTd )I#DG#R?H%D_a"}c9wSqij(Z_|/C3D_77 @$N1/Kv
+
+9C'Kce)Re+%5U4v|8MGeko_Rw	 ]>[7N3	w^Y;VM&"EiR~)wb_k["VHH[{E!V[f.-L{tNYeUVHAN+R3+*8^}SaWP]Tr(|)O+yXHHBfj0Xvo$NWnc
+q7[r " 7((B#3).+!;(UF9Q~m~>_pU~eO=rZP|rg5JV^[>]#,P 'V'oM=LFselmbmZU;O*l/rY?1R|"yg_CNp/ &^XO3'59L(>6E:	JoRUhz
+X]y!]A3M 
+wOJc6bv\!T5I(}(}+hR-o!K
+'+Z.z
+B5fP'sYK0IfO wP+mcl@]NPGic c=LD)Z,+9]xDV4df(.A]fuGHw&m^s<QGmP/p?j-@yK[YAS}Ih$PrIIQQi<wx#)~2sh*UOXx@{?E#F
+G$#7X,o(GT/CiVVU=>	1^1[	Ibmy^4B3m7y/}/(Ta6FT$^9hK-?xZ(v0=h)pXW,A|Ii3(Wd>([3MPVU1"VlrVWV-c6p)~URiMrS!|\z{+v~dKa{USp-/.Yv!5apP82/dMZ.Yd)}2v^X#O>+"%gdi/+wxA>df9hf2tr&%Y_i"c.vCO}&Xep!>=\C=_-Pm{-)-+G:q]IQ[H(2_TurTY<7m5uD-?#>=(]l}w.hQ%`*maaO}W4qV^^Qm y'#"X(wB3VYEF+Y(UUAY+8Fj^@J\kbf
+2q0*uA!$X(Q92Q:ztgf+ ."6WK3Tu5` cCUee2PRjQ:rEl%J{C2	@I;Gk*W'E<wE[R'3\_EQ9NTUI{@3Do5	gesXyXmbH+kf*a#X>HAK^1Yg
+;t	tQ5l6p</VO++R|u_G zSPj;g 	#oyi##6r/\*~"s<Q;S#vP&.Tv*5GCfj}=[bK5`	_L@y/9.;
+I4&-=+
+>f 6YLk)
+G@2fP;4czT4%13T>Y}]\l z35
+!!.R?m#UQsWU_J*uE|TThIN8IDY{J!CEJjODmmpA -*dB%*OKGlN*J}dyNIrR?e58S}"~c<\_#ysE1A?6.`mDWX@KV'1{b-@!Y2Pj*6
+d>0z*j
+R\T`nm1X}*w!	>rw!	wJdW>3C^+sQ')	RjeM aUol6h>,H]hzmW"zj%>N3qnE}ih
+H}M 1U]J7K_@o3.\B0v;KS-&OSe46|Yyuq[J/u"CHO#GHv~I)W)>oV~Pu@'N
+}A8PLLD1ZP[
+My"uLz_v/`F3+INBGV""_#{}87emle"'	&]6MP'DQXPgpn01Z;m9j~eXgF03T=QfE}\>b+Ub[n< 2]EK&C}Q*\Y(^('kn{yZ	Y+<5z5}eE_GU@1e6^L'emCu!B\SoO<TW|&jkK)$VS!!cy/6~<Pu)#_(z`CPi2$["RRIOn,Y*|V(lPj6M/>'(_,xkfS]^MV }nZN	@a<F{7qxV!\%;&es-V(gER^T6gb ; ?_wTM2rb*\W<^E]BGjw [&z!2J- [,v.w_)5hn(aZ[|t'64I{CNwFW	4U7tA_PO=M!&V OO}<vpUQ?K}2wnNaB`*UuOd^4YbDO[h6S/@/S~=F%9#{7@eMzrC'
+yo1NZLP(?(Z+.fs~:$P<\i6q_Jme2de!~n2U)!g)g>#zc(~L:}c6qv+@>L`fdq?U]qTP*v`U+|VUiuw:mRSM]Tm=ZOTTUZHm6DzQn
+CST"UuU+Q*2${W} ?LiNPa}k)\(Z~=7YkyUR8EQ]UFf0BMO@{PAhIfSyFmTT& Y1zQ] 2;zm~&Z,)lq-4KAxego u4FrqZ<xP*++CIkw_jpUjU?!UI:JXEG&*v=0H44:P[NJ3Yw.\>9RtO]P_[8<$]+3$~%0XkGjG6D[I]Wq	[	;?l-R^YFc]VOz2r^iW:E^klw}l{y7}nU;A3}~bxl4UwUjIhELzPZG;HeMdMEI}(0_q}yDj'lgtJXI6RL}+Yed
+/
+Gq4[ Ivx|D y555eu4hSTeGE}Y_,(64:Z$*Z9QwR N?k.zOw|%|UucyQk]FmO;mD:qa;}
+aHVIxT+2>b_S#ZqU"~rI\`:WAuk:??+
+gXq<}CX/md2/>kmPScYwq"R>;-"PUtbMceZu#b*kktgT+K*=Uk7H;~bZo+EHVz(v\SB%%*P-s`Q-qCyGmj{~(o"ez_AL?i]H~>c10MsQ2USsU .lRzZb,^hynhQKxS-lCe@8AY:.S	4-0}T~6:mcmc~Bq<~@uu:O=ZXI}VL-8jtM&S3z-! sXj*m6hc4{5454P2ZoIZ]}-aS&&fSgou8qreMtWy+
+u"$m(PGh5D
+m=+HTtyG]d|JEx!S^i
+wX/A$3RN)4otj(3m
+V/po\9~LcS.ftPFCdNyVle*>Q4qj;WVkpNZeJ?='+QgB5%>e
+x>VH67UC#d>C5OvY]d9;rt&Ru?I|Zy*F8UBNfj8n [MP\/^ M{T#x|),M@mlvA~CkWYWY9P9OUyQD)STUmU]UTUkBv_e}W^YCVY.L^M ez}S\V _
+!v26~'L~~)(cJGhHJ^A(^H8?2+?d6eT
+QU.AuQo^q
+MwRV_'_c_&W_+ps6VFW+um>;e|2y.$]@&nx=LF*v'NeWE*M ,j)
+%7W8\DGyYBQUVjrT#UTv^ umu{u|eHQ[;jJE;.L5}8^z;H	M[NBBL7?9 _uSf~&Oo}*mm7yAW6Qf(G))o*?*"T/}f)Mi6G&vA _kLJzBzKc	Y_*N0=P &*r4D5^{zMs#h!RoEN`n+m%*q+gkE*Z\E5H5X8rf)c-oXdlNbO/&:$]qJU}IVWXES| h:i\qr%R5yI4Q>4_C(zZUk7z?Vn^>5!RQsdQ<[r*GjC|35LVs9rBnJYfl,WU/E%?QRu_L6I33#q,U}#m[^Wr)7Zz`c<n_!<x!h1)sNJRR<Q1XjT[oi<QTVy18AUx i6Ay, VI^U>n5p%{$cpd|(P/"*ej:TVf;Uj*[aXa;^|Q?3C/|~	O1TZR/Ut*z<	(eeI^Ult<4"6vQq=6=-|p'7J,Ll9m$Yv|<k&j M+*}o1P}x$R
+lFCa#b2A./+o*4b<0*:+3P_Q7#r-y*V9L=o9*((4qgw~ cV]+mf3 7I9J[^g cLK3B^'T&)4%TaYXM7t/FH,P
+r|JQB%TX^AR1H`hBH6V
+#^	Q!-z:e!isz8Pr_xUD>Q\1D\+*a97!7S9R
+=~Uk[zay/[WG9cT|o{^>}/|Ot(HWc?% 
+DH/AhP|d(!P~#p#Q#7"_#?
+5!Lh	#c|_kP8;!X&k5^-Wm|_.Wt}C}_,hnz4FnSPf7G}}ZboQXkmo[k&b~'PdS\w::N%@hl#rP\y(W>t/@?ow;t{=^O7v >k"~(G?G7F4i0EPg(3!ap,7H3
+crt"Q($,7	MI	dcrNtL/%O+Ac.Cya}C^#Ho YBB.F;/A`o)F; e(22r_WZCGDyV"UhUhUV8]tp_"|-_a:9hrnB7aMHf["c'k'ww!mM#E}!>o~,<xPa=10 #(QQ{q{G>'QXBg0}z&C,|PX.#eX2~r]XW~auwA0D}B9nPH6xwP{v#R ?(#yr?AO)<C#{W5{{^c,yE:~>`(G!t h(W+"N8c)<r.UDCQkk_[W1}1:%_P ]%ZEJ8JTuT*qU_`9Oim2ylPkG+L/[-g==Q-t)tPu4W&72Hs@ZB~fiQ)x#lG~++]19Gc**+<vpe5s5dWBJYR[RVuqz|+y{'+<xoU0]-(qx_u:qcX.It~W=u#\oM<z.X}(O !L`Ey.^!(OH-jQC{n@,FtG"H3Wdc%LhO#6)zu!4X8;&Q
+>JFj#:JA".].S/WCzP5,~`Mfha9S\gXC(@4n|2Hc	jb~<x+A 	H?99<r9B$hj-QH%[ajj	 v(g{QDu@; _KMB9N2OIaO,TKE>h3MmYNGF#;3I:ac~g]ut	ze=Pl]Q@%<.TfP3+\	wv@zXaDz\"Y^~{c>X//8A[`7 }paE0s8G |1D:#W9PwYjLX4+962|c%m`cl(G	h	(Wo"OXOXdzLv0STk*OvN8vnff3MMYz8Ul;g7'A>sP.7qn4a	, /@~Z!E!b].F/F9#YW0I?/EuS?avggg&L_P_0I~A^c1J+VDE_1.,[HF7w!~i2h9|%D{
+ LeVc6NhXO?erA{A:kkK_LPuKYuX~>i1{~en"Yzm
+~jh	Noo3`V[RPmXnvNw3THggh?B{Bwz~{z
+c5?~,@  A!q<p:#D0;|"Qc>Lc\yq;ax,s$b!;rNO=O?ffOBF~g1<nF<=^,
+G=."?>%d*Ip\rW5L_CL5"x\^-C]^v70sDz7Lh(m,'"QtA,sG:} =udQ,|$z~0I}v{z=zzr<[8?G{/P(,P^/#3(kQ&f@4"Q;{{1(]V}@sG~rxFKVj5Z
+-h'mA~"EsIL0+!7kC+rS![C*<.4<^]0_@`aHdt:u{d"1c@:Pnh{kOi@<ETK)VR*>j}A2dV/UdBk1{.j35XX&G4huL"`#6,&2kZ`+ev^1Cv K*A9{z@~+}I==)|J=bJD>f5VRXw,\
+Tl\
+[C)+Y'l,:8Pw!cAc5)zX P~'o	8fw9r>qYSMSK ;#sdPz00(jUwa*=]
+!I$t*q9WV
+@Jl|%vuzVF#{`0_z`; T
+hUA;UA}]=w3fj(OUW5fp/lO^)m|uz}/W@>pE|#~?!=?[\=tAG9h73_lCoGVz0	
+8EeCpV"8IL1,aA)M5Dh-a(ShHDd E[S0Sfi~;n04w
+r(G8		G=A6P4VF^OhanD"HG{ws(E\``hFDzGh3EG0	L=W1h|0	c/fS@5Ph`
+ {P)tq`G8&Bzk@([d~Qe5Q7h,w
+R:[z^=C9G7 o`$( J@{W]Oa=7^}E#WcHM	&M  Qxg<MzK@9OOH@}DoNPUKzVY9g[ tmn]I"jQ%SK%9(W+*/
+Dn7>{gTwmcmQHu\du.5}pF=w'Y:X!$7)b]47&h)\4Rj2SUbw*XWbFb;h'3e9nF?4C~NvIC9;b71#~t3~ o;6HCU4z]3nu/~]"1
+B21u'@L]#&Af	v/%2QL{?,M&IVCUdAZIf#Fc"^9X9h''+TiB5uP&sA<.Py#N_1P&?Cg7[7[7Dvh=ww|&OOz=)^hps	/ C~_WPQQT2k  *ku#$hXo>|^C@3C%0v
+|kC/dC,6tLagXT%ph
+4?fAS@i89u	?%iHH(WA {Vb44z	bc``Mh36fz! d4/nWOD?'#D;1o''!@	`?\#d=+7y4h,Kp+)	 )q^@{
+qJZr =T4c?RHcu(Df?@suO)Ad69s1Ub(3"Q07CrQw!e!o@E/
+E("+GEhEhEo,FdYl<KKw70~p~_{_|]Fu2gYvXq\#F2+@FY5$dU	_>7!{jwPQX~%9'i%g%J
+U^L>@XOgFxf?'k{m{j/t[~v@B=;$h= w]NoKpG[bA	<Vb#1#&LoMX/6]6#GlA93	@(~6a@1MwInsa;cMd >'(4:|;Q],M>|wvcn
+1ZFi'DL(>z 	=aHw?}A2c=@9H?v;2gE?ad>KrM5a5i$;kjQGQH(xTSG@'u_'NFLS?vzx
+xo}`XggB33[Q'WY8X=Meg>1C{Cgs(9?o>yy!r_.5q1<2P"]-5AK(LeHWU*o65#
+zH&u:H;xo@&fx "oB[HVF}o#hQ;w"oNF&]{H,Cr<!\'<4GhG>22YlCy?h'HIXjh$tW
+)y
+@e3#}MB6v|n~^\b5xv~X k&psozyEE{f|2{];LaF}kshA|zd1|Z>!OhOhO1X33u/:6mcA/F~v_Ck1W=_Wk>[LCciZDd%viaV+J_18q"qAX`j/2A_Qe"`L_u<.e	!"
+_4XX@\D1PQfD7->$Ur^vEU[e"KG'DEDi[!
+EX^5tQD,_I	*Q@*#DtAX}(Uv%{B	T>I2U!_5V@m8pPCLz]-!DkyZKAMw-z,    mWaqek+\B6
+6A[X0;6gwE;^,!R'B&F\	F?{R$v=_/2a}ad3hHtmPo2Cy{W{Sfiv@{(P*t@	_DTh++%R"}kIf)BJb 3Yd\JYazR&e R+[/R O7E)RdQfZ`(g40x)#:eEGSL@  2ew/Ae"B~8Dmrey]',S^? QWWAe~YmBWMU6 =GVc#vsD9?8r<@'XAttAn''$(/	xgF$P.]{rwXy{WV`|1@g[W@=*]nFgRWE8c8c}8K;:ZXE|EkU$T]DWX*T
+R}?";'0>#]dLK+_{H5'+jDHeN*ak>PYp<7.zncP9wUM|4Wb%+T
+vv(>2cx?wW8T!*@zao3&ozw<EV|)T*XUVAUBNG_6nB^_d}tUy&|3!<|=#Cy^.'*UQ**jo0}Gb5Rx/>o^X?^j9;5+t
+B{zEAj|Ko	oG&VE+zU'Dj(w&P6]ys>/WU=;7/:]C7mJF6l`Wzo;F8>atU:4TQA>>|"y&|E?Q'E_%C?- Z~Hv*Dk@t] HcG\c"\ !P 1P c?*lmG q\  ? % Kh f#@ C@x@`3, LBLj~ Kt |=^!B&!b&<0S_G?4Sq.$]8kX		0Cy)$,[(oO(BdPw $40b)-,8?b5`
+ra1L#z. bhj0F5S8g"H.zQFVd?o
+02{Z0&#|>h$D+zn`TGD2/tQ\4gb(1Z41bm{jx!c5D1Ov7:5tM4!1M1@SX1;$=#
+58!r7A;jfq~zXbbXSE9cH/tKwL	E;`.@9k wHIj$N()juo:F&8jsu\-XG+<VHiz#5cmcc]c-('7M~6sQ!R;V cR#ILhGWW'ubWpzb}Pvfzb]taGb[u4%uFI4$Hc IrmE
+mQ4M
+m(4MC|?j(Yx`p4D>\)Hl,609.|u^+A@wTS,1w\F1sc$$&(W,$
++d;?$rB<7rC@hxC3C+CL if\s.^Lx{= ?jspLh.iIYh1:ZqhOcZ
+B%+%_II^e0Mo3bxVmS;Bo|khgiN)pxh	M&j0p&)k`@.vB{!Qho|WViOIo'v(O;cb.GOorbvTlD%sk*%f2K$B8o IAbAFP$$CwC^L.;]:u@;v@t $Jd>tmLDR4OaI&?OR7Xtil 7pKR@)7&uBN T 1_Q?33N+	e~2hF1uu4\/0y.XIzJ~u:k4u
+GGfte5Sp:t' fN|	x'(4Ep:L/WtC!Yh:shhOrH:F..|~]@)wHubjj,.&a%2euQ$d	tg2MLRaY@%z
+L/ 'f1Y@)p]\.[
+BN(f7c~BjLl[wBNgP~JrI']\>2I9$P`WzwzF&G._s\7.O
+nBLc>=y! En;A
+n|w3_@w\
+nU Z8-8|b63FvjUlzrBKuj;3iz`;GO&}HOFYxO7pz.0^P6
+<]XoW'F}{c;zJmghlgLPY3 b}XQ}g
+/G!/Jl8>u6&9c\jDCYto_ABRzz`i&;(@n7U;Fs 10"<kXOAP@7@C#B]=C0a0itg5~Z``?,~4fU!@i!rnqjfna
+H~mfnaezo6EwEF
+?<4@?3*0@~MAkFb#_Uy?/[GD<7F	~><Bn7_ZHh`qYz?OG~/FI E2a2
+~-
+;nG<{qqqq4s&w 2;&p"8\gFckgh%2=SQcqxn76QYoU;,1^ L&	>>Q.x< ^7L$Od>;U	XIOdnN@,|aL;i8I6lIhIn&Ea@IQ$V~'SOda0U	r&~2T)kO2L#AAS6C:K4JLrVSPm@~&?M.f
+]55iy4sqqqqZO'3tLG>=^Yfr 02,0,5-BfObf3M4~0[#fFiV^!gfcfc2Bn.7?n{A9gDadKk+\_>h.<zr>	a\a8hu#,[-=^|o~AL%o0$YXhqZ:\aki.Y6c1kAt7\	9h1[-z[s	oVG%h%{%@	,]s@PQP\R3 LaK3K/",",?C~s/M/@Dd5-s+_e5#^Pe_i9pZiJ/7a<j:ht"h9
+~1_~~~V0J+N+}h_	r+4~h)[P~$+0b94~E{|M`""3wl- AP?GE=z=V
+!P
+Jo%=24l305VsrkUU U
+cUHU.WVJF{F
+k_h?oo`kn=GqHg-
+(e:4NX/l6
+'%3n4n1n5]>X O#&n3}1jC@gnD7bmV6[&~o+'-~!mq-[L-X?[XQ%t`{x
+X[p	r;.~{e{(F#dr;]nn8`%rn}w1_^
+tv`v	=NNfTNs>Drn!t}v! o!]Q5&=^~8Is{{=AA=@=6K=W'{uYhX~oEQNQQAxloGVpCa ?r{,u vpq-qDApX8"D{/e%y6#:>D~PC>IwK"Y{ vv?(w;A.f#@QqAGcqpqG_6
+=v9bxDCOp1c@icLG"18g'q?G cC!AIw;>Q'5_OXw
+i3gOFz|<N2iSV))i?fzN3{`i(L@N`k,w;?t3L
+8#wgsyp6Rtxq=0z%X2/Kys>AMk@(]we.~A`yQ$\K z\.]/1.KWK@`\e
+w]Wke}$pu9!@h+JWWBg0W}\Y'#`+Pw{]	U0({7-_{]e"*58 r-EG)	n%BwnqMk*sxxMr&Mp[#DI+({32s v-{2tvw{mR'A\wCG}y4D0wI=>+X?w]!Yvkxg~s]Ca^8hG}!(?D}HCOD?`7> 8>=$|(%C{=	'C!
+Gm;]{2Q(W)zPBntTYc 1}Ii3Ogb*@IdNxS'y=cTx&<^O&:e?YN&- gl2=9=gg<zisVb3/_>u_`;{>$1g%y!+Fx/{6K+5{8Ba3X/p@1z2 p1OoXd?0:Lo;?;=+o;3I\:~2w{{zC;k3'u{i}	UP&h_VX5|W	{HwU_b%?c!,}>#?
+#+?}^2+	13cc>#|<sR)~6`?%?/~62|~/[[x"pW"2b5Php-f,,b	y[ 0KPHH^B1	5`_plB=9_! 0#h0-:#9ey)I%)I#)DR@0I&I&2	Dd$%H" B"XV{iGTQKD-AiC4JD+AZ	HVV$% -iA%8b/A-kNJHffiFJIRJ$$ K2)q hMiBJiL%C5"NR!)'NRNi@fOK3T 3b
+(C*J1#.q"d$AJ.q(C
+,!%H.@
+pj	RT H	RxJ bTpj&p bT k$H.A7@ yX$>GFGbx_#"&d&NGqdhNG!ry44%)DAB)b@UJeihqg(D2VQ!Q
+jP
+jdT>QulPF!1HNl$\ F	2%p!A	2DJ$R%Qd CHL%`b I"1d  I,GX!5$ u I HM	AZ/!%H;MH ''AzB{bmA;KFJnd4 $4 $4 +h1bK B0 #	RV@ZX!%\\B 	O+ ]e Z@_ X+'$u-FD	GG%-F$	G$/TI 90i1bJ8$UVF|Y4)MF:BlQ&$HuIT'0 BI Hg,AH	EH,!A	RdJO)A<IDlI*$[T!9RdJO[t $W"Ir%H&"IN%;)"@dn&A2.A*0B nDzx^R+c,D\Ho	BH8I	RtOq&$3/@
+ T $H2Pt&%Hg2H'$Hy2Xt2X!N92D#C%*A0;DG2\84R),Iq[ 0Hd5aDHNd$Oi2VY	)EIRd"VTG2At$%- bLpJI$I,E@LpT:d<&!R(k	GKf"idI#&%\dQy#%9/eIS9YsOB)KFAN+KA/_*A8yRZbkSRfb\BRn)N1T5jNCzjTS+850Q85xvAO47m+:*cbLp097fSJRb\|JNySz&IMJQ/hJH5)1&b[N5h7XfZMYfpiXjS8:q,3=pjNk)5-9;19/N14[XjX\,=X+NAK85&z'Zq+87S3ZM63'( XiZzb:if8e'lk'jQ##ZvL;f @c7Hv2')Xi:L45HOMS#=/N|z>PS|3CIuwIJ\Kvb]	7LsfvIlP/zN&Uf~b<+LOCN`FYpNr2Oi
+	9	M$6mf<3 uI_'k~xX8u[u3Sb|\>a:&&P;?=1)=%M|A _^Af'6o=	d2L)1!jS|-8%sm"3r*%gnzFFz
+V?616U85K5K05mE	uFXA\|V\<qtk-_%c	%&z Zqcj8o/)Y`rE|~z4)hFySr3z1totSMJkV\=WSsnYVRr5?5,+ft}zf.Q^jji$~>xR#.'.&Dbs>-R9Xq$* +%?=;+xHBS^9fvtMKJ0x\W^{:p;_q3o{*/e	,-,-C,C-,-#,#-,-c,c-,-,-,?Y&[XZY[fXfZfYf[XZY[XZY[XZ~bYfYnYawU?-k,k-YY[6X6Z6Y6[XZY[vXvZvYv[XZY[XZY[XZY[NXNZNYN[XZY[.X.Z.Y.[XZY[nXnZnYn[XZY[XZY[XZY[^X^Z^Y^[XZY[>X>Z>Y>[XZ,z]z{Xw`O[>9m}U'(O Z>1g}$I zuqIyC[	=p0,\d87F=t(iiH$`=]_rJ~#?J&5d-#l"l#C}!r!G1r`8KH.
+JInKyH	yJyI^4#D>/m>i}d=o'Z|RtnDI	:_bik#:PGKmiA9ft5T Tk &efgJ	k<?3xVGSRi;w57/[={bbkUNz4lIf[lZ
+	#jD"?\
+o7d?Eu\+%*Sa-pQ|`Xo&*53K9nyI` *%z^'yO 2%sQfdgd$YqJB\S2\2$!&Y]R
+^i\sV4bRkvkE U)m"owNhHhv5gK1R~s\3p+e4(46"N.SIVYy{S  %y=RH&8-`LJQoH<WbiVf\SF6mqB$iNj`3i+$E;WN/ AvVB95SAIY5rM9@[U T1(%av(Wz:A'tN0=^{x^nPB1`	]>1-zh#9Dx#2Iw+E~YdIb[EQ\wtVxH%#TV06DbcUf[;X6|st!N.\eNlm)^!()CJ^&u(I# )IZ	Xd4rAW@A:cauZY&t.\*;93$UQ
+$?gNK#yh;,nI~L~_%2\mWS3K~]~{?=O'OxpC<|(2qnc=^g{)/QRWo*	S4KN8h{y[N9xG7FDEj4hw (TNZlw<tsD^k6n(q,+C1a-{5L%5M_&e_901nO]W{Ww]$]3p,r(Zd(i;Rxy)eER~P}ElmS|,60&X8zMKDsG@l-ORHd1Z#E4-P4p}$K+8)TgK'H'XsLtJ".DAcnRN'"sr C/y^NL`]ESl'~Y~0I!>08 #Oj7jGE## N	kL2SWZ-]0#S%Yw_iSCk_
+
+'()YuOyh/xT_Jh"QryF4z+&R~YiN$+)445w\]`}Bw,J
+GbsLdLedkQFujw-Fe
+fgxz`i^]kIj:,=g5-;fyWa)~^][^T*TpJ!;G>t}DaSQTi@:'-Dh`D/+GL)ygR#dJV(E,U?a\u/5OKtALHH"i3#L,yyr6Z1CzGxKcYVY\h5U#	umGz>]xZ+ kZz\SaqRCBX@)	BS](4F6)5.G)cA&]eIFvVGI$bR%Ry)9NVy. NNvnRnzFOnuHlRUWiuNSHTsV:2J]QRIBmr\zTLsP(07;/)[D Tk+D:Ih/MY=]sY2yYX?I9`()V=%S43iaNlTs]I>Y`qF{Y`. SNzP]rk
+r+"`blS1nP5LzRi+|oP&a"'AMs7sF"gfrvFz
+jS$`n:Uif,Il'pEs .Y}_7a)7;+2\;Hc'Ak,IItOC{v1b 7{tbt]Z`[m!k4 $zo%R23d-=;Qm	NE5'eRIIEMe(g#v^a##@qz[7=D:ms~.qRJZ);K";%&R))gn+>]LTlvffA3:CRsh=QMkC#4H"M6hNFAU9
+({5w;I`|UTJFz_g'CX6U^8jGBj<:q!:1ITYXvYZ:T3vubk2Si/@CRr>] Q2"hTxt>av$y<9v8('@c)j6\u#qH0UYa)EB$$#R<PZR&xPe&8+]KIklU8t#u otCiAVtAPZ0,t,IX\')\`%fwrAZtCxYs8jKdJf9~G5kR]iT^|fB+$C7^KGq%!Hov[>,	2Ej{xdc}>-`v*dPNGqd|*:zzHyLXg"ufU_#l5v->:Ic{jzA&[ %b{ M
+`m!C/CD]!d 53uu#aQarzlPj=HaO[xsG:L=ML0h@?FH06LlUPvTUe|40iEp
+ OMg*6n\zlX|6JdW~I tIip8Fy=
+PE/#1B3'~	;
+E9P48_X*Z2.8u'm=xkFzqIN%}D7MADz% J+*p^xbC$FQ!C"KD](*DaOiG4=QAQC8`HEpGp^bA"Jv][Q<k (,;%`jMqq	sa*\: L)$YZ	#M\[M$B]#pL-(Q)c0'I!Y*	])"zzrJ+)Q(>>Q}"}OD	 Sq}[fv	FaZr%Lg6f~OMcCmA -,Rq`H0y}g!vvn=	"	E'&ah$5!,A',Nj!.B/-,'xY2Ge`0,$pButju+JxI.:rfztobNC
+;@mi].d%t~N:tk R2s?:'G{/COnf{BrwnN
+;!@NJa?&=?|$R8E6XKFj0N`@yC!\jVh{YORa$XR
+Vl6qoF)>DOiIMIxjolXYm^>kZfayB	iMjl{^#iE12z0bzaS%j*[Y^v;%M'.?\$)Vj-(\=2G%Uer{#WM<R(f|6-q%Q9
+YSSsS`M] J^AaM,*fPX<
+DeM!&IF<G%ebU-FVv.EZHvyH'+WdSg>W8UAX}Fv,b5^"2B:$\ec:Evn)Y9Y/K ((-s
+GpJ #aoN9i>P$KIZsk[WG5+1kxUI:V|zA'o`#'7oZ2GQ<l3Qlv ed1	A
+KWPb7BX.'iiT=GP21y`$c~seN0Qj(\Sf8B!%HM0^[?*1,IN	HeW>5oUzHLFDp].M4<Z)pSTG12WK:W"dY/w{bQh	EzJ))=:@,0/
+QtWdtK ph33O}]*r|c.US"`S-$#$ 6k$KYbaL3A9%t0
+0} -m&}JQW9s!_:$XgN4#"]]<i*mdN{g
+MI"=|c: PgU
+TW@]QbE&[{:CLU[oMBt|bS;b^rn"f&HWj/P[bZ\2\<p'x@I'BiE@=obu"}^/ae/D\T5Okc+m)P\
+]\+Uvx>~n*
+oW<|u$2In,#~l87746%&WK#~ZMg
+Jmi\lapoJ2aMmu\mSBZzq8GPf[4=%#1_\gt3Y>>)c'H(+ZnuOW@3O']cODbPYw3xLwuM??dTXeMV)+-UbW!tm+Wm@z0 V0R3d@YZSn~W\>OT1Ki!5!-gKUst+WX3~g_P$`f-LU$T$W$#rp2 p<1i@82d@15&LHXH@w@4# ~_ |A+	@cTx_	,K| gERhHC8pllCQB$-Kd;ceEA$ <k\F$Bx`!|C;r/!4B? !}Cx~d6,k@8f3!!]6^CCdO%9@YOZ['0Y)lE38&\NZkyI.%K/=tCW^H
+R
+i?=,+k('' vn
+sh?nwE81iJH#C:o>sQerSt]`$|)>M3["p
+4tE"k*),rPDdaN4{Q@A"WC>o_5i 
++3%Gw\>qC12]iG})ak7Z51!5]5ekK*4\_u+@zO}PK{"F<W:[Sk`\0_ko?1'I7^eB85_R,
+\9PQjp)z5;QL|qq\;
+Xjz^JvAnRGs7C<	-IoyZ_
+IYz2cK0Y7[]fz($t$& (c7UfU`tm=O mf>=\v.UdjvWT<-=G)Iyf_\Yv2}D^9+_!\j^l9)HQzQ,JpnuKuF rds^~~	M_1}oojRK|s4.Er2osd_'6JL \	)?9/HBf2SuvE|VJv&{:IMO. 'dD&SDNqJu_JKY8\v1sfqqGR8CDB:gLS<:G9S"xtG:+E1-/gMayV"U"xJ~fHFo:ouWB%;JUEp,g3Bw+. TWb<k3J/Cx}EQ<:~Q~_~WEct<Ba+N{_V_Z~TbxkI
+J?DAjx;xa?;&^?#\qk$x<wxvkGj^wxowx.EF/ o6w<]u8]>.@?fM8LHa]] _^W\J@L;tP|3dn2YY')SSLbj2zu,dD}g?~M\bKkI*1}*q@kG"Ca>ePz4Y	jl )#HGK ( ?m82}tox'&wS~_*>@5"/)*MNd6yR;DGjWh#}S	6)%Q	]?w d3h/,jZr30/R}4g=_[Y65.ST^WCOtc2g8oOvrG|]lkh{	VDzr+pd!JOR*>ZJH"R'WOtIv'3:0m3tg}/Hz:c{"=Bt0NDE2Bz#1"d</"G"2LpF,8fc|yO77
+}K/#>DIW/&a1focwcBo8pgvKD)U"}G:a[wHc8O1sp&;~?O~'hKr8Uj0"aQtKBGyNX0VE^>:8 a0!uNasp80nM/6NbXp4}sVma;8IKGG8:8;3`4x+[oWogm(T6otWGkm]aocsO9aZ{OO{E&9[YEG}gU}WfUt\F94lpyIGZ[I\N+~h3`^ar],?}l2;?=|&~`?MeOV>@>^%po57GV,?w['?sN\>rp7#Wsm</uTUm}qWN)**,':"2w@(zS2@2rH1G>
+DE}.g?w^{X{aFzL|n'*?_iV|L)/qo~t[cLkW.y'{z^lG)?6s/=|}jFa&oN)/*]^>j{g{pSkJYM9=>;?ij6!q^-'".etxOZSR4!g;uwL|wW?yq\i%aa]GTuMVuowlt<xwW*'?z:_S	xs?o+/rufx8|Q~'zeT>tbk/ac}BFl>Gom)gw7v_riCXW=q#d?|e;b{{[mVl97x/4-~6VUk[k^O't{m&uX}QU/{>n.<}Ek#otRvw0yF6}|)ekm0<~'[xwP'unEE392;u:~z9ismvmd-n;yYA]dcg[BdQO<U^8=oq%`C'-H?y-y,;8Wn48zXJ}x#C+GK]rmg>wI_'SKGvryJ2pi3sb)kckgFS?Ph"}>8(^j7py/Glq^~_N~cb_2|$C}?=v\O1_v5~c1z>^(FD/2-FPY1m<[$*7_q).I}F&I/\4IoH$Fu}L*I}%}LD<JT*o7#RI_'Lo	3MIHT^ ;O?Mo_)G%;%{s;cIKRn=B*D'H-F	f#.]l/7-%	`E|aA9v\Gm(M*~6~4RzZDC({iX/m	F^;~g/Cm5L ";OY5O3[xMt=kcB%ttW|@){nH\&ue R*/sk}A@^CtwM#y=h3y?>^!+:X)~R~No!=Yq =z=4yNypB~3D&[d!sIu{<%[ gW~Ihgw*Ql?Y#En|;L\/Y7o!"1LOC9=54,Daoy-B!?g<mOjf}";K;S=o^d[>MDXV~?d~z
+NT)~_F3!45Ln!{iL).?WsKc|<,*|G/
+1RZ3N4~48;P$oa>~GE3H-{V(+"d(-uP_Swj~	jFX>$DW{9(TYki+T!^o])d'>KlRBfO%|X,=>
+u,!U?pAk$o^*P>&K|v~W&3_mxr|Ui+w8|S?yos97e%"^\cXQm1	VL%E.+QF{|~FH4g4O
+N7BF,/VG_nS?D@3 fNgB|Z_"k#|#QFT~7Qo>z__2^t$\#q!~!X>BsI%AKIU[*J9]C?FXvi=u~lz< =?L~Day;(V_&w YOq}GI\Qsv?B(W"B/z^]o77"
+#Q*o`,^toe _<G4\k-5c>~i>uLwDG+/Fo'qSohWq@|D/GW"4?-aSE}T(7Istyy?_@>/|_KViDuJ	2'xM KmwE[Hv
+Wy #TC#[BgJ\I(/uXz!]f"Jj{CAIi7!E/N/\'&a4j*O_O!Aa
+2a=a}/A9=Q
+LO)+E{EIW
+%!.NYXk3CI({#Eqbw*X~?qbKc3$^%o[l@\m0fQLK,(dWl.*`&TC-IfIVkm$()Xb+xPoN{>_Q`3,jo:Y.=DT?T=3{ln@7Z/Vv]`S.D0`f+i1[V~D*+n79ZrL=b4csZR^iC
+)8=nOIrQ'NP'Q;G+CHJm`HiW/]Y[mE+5ZWJC@2W!O+')GVd[C)BHyx|	Iej$/1,u]nS-RWHZm.ED#0i=(ES LEq?iT.j}{XKDBK3SRbmPU9$i	L1[|kf5`Q]Uo)N_u(wp}
+.:~a^&5cj_ghid4OP:3ZJVkS4%/H\G\*h!wUCqJ3kKDuzh%y,eLGG,92emufX`WP/w!qOlGl\Ol9S%-pEm:S #uKh+nVJAW_
+<X`1tTzp4 CCZryd{ZoisGr0:yzK	M#-HJI1*beFEk\qC%I<94Uo^fHYRlO%xtnI>-9<e.`RfCb`kW#3k#OtW|C<_2=R,Nmc$XB10xZCnIP4p$V=vOEgG|_
+YO
+Oqx`Yia.$8Ux5or!o'jF~p@U,uj
+[`ULr8)vDNJDI1~M?+Af~$_j\<E;2R]r97Y<")q.;n><q-oE^C<Iv9-*2[wEO4G<IJLm:Y5Ds0SR_q/\i50]gC:
+wGLUyun:EYo7b7=O:}b`nv&F`	f%p6c-	Ij=S@<As)3_!F+*RUG8a;I]	*|Pc36Jup$UO2g<\jjN(@(Axq8wzirN:%fRqfF;4&h"_{QQS~?5z(5|BkHli\8kZv}&v;c/2V4 +f:c#] Nf20knX/\^&21_`	\OrsIN:BA&
+0`cCMl<p
+cQ&4~%#M
+hb6`cNro2	|f+C%=@z"l%HAz>Hz#=CH?~#H?$M$ '&dw/xcy@kl cc~m.clc;d,X5lK C>I&V
+H >H/`0ES$>@~I~<M~GX7c>uexP 3@3`(c#h\q	Lbl<E
+|0#0#pcV#Iddcd(?N&r?p,N##''*mbgCd}=y|ve}U[ti=K>}&n~]x[g|Mx <	%s|Hx.v5qTJ:Oxe
+Xbj5hgzp)\&M29YedXiqc621%3{~-Qd
+83$h{?h[5zFhI7hz^k4zF/%4]4:)654k[}D4%>4Ijnwk&5zF\htF/vnF4'4k[}D4%>4Ijn'v2	 ,7};+NIy"Vx"3 }+}# 6Xnv+y@buine^0s+9Zt
+q[*Qs!NxWWT/,/wGNw ^I)O~Q	9P
+ly4w;^	1wJ#;?nFPI__g(mK[qp1':c.~#&#!Vdu1=Ezb/a6	_ed'_/<f{QJyFTR!ib33(EvP>	|n+uri/xid?*?zY./!( 	>
+E>@rmtpI&~KyvJBYgooS!F7>Z]Ww]rZLmJ<]ZeC]b7@),
+%0do\B-0==Av!n{#{SQ
+:.C^2yTQ_[SB7eXnVlc#.O)qquO ~GA(F?]X_SbyW"#\;#[x wO8 :LK~ excb#YQ6[hs;WH0?TqEC,fy>kou{vN	Uwa+b_#?-{sx_E~B%>6[/8{4[R[w+~:O+~Af"zktyM'v:GCG.e=,@m^1lU}@53BkGdOnlStJrk#nuX'.W^;E+q_8]2
+(`!Y!/c1c
+yyy8%c.ovK%M9x'xW1{O]C;x?lu_<;xExg}!lvzN]#q<4-ZMB3YO,^NYiC~W3W]'_-uhM Xs|	N\Cm9E9uM1IjQOU]VS!FOaN'Y/EmG5]:;t<,w;~+Y)Z[`+##1._M)m>a4"g;|3gvI3f|Z:;D"kwPRf?{Z2*F3_B'^=7Coba-LyCgYijiR56<nRyg#*}m{ITZ'U5<c)1I).(u%kF-0.}^$L.qwgLct_:)q^S_<'&t}M0bFjc!oV_wO=1n:$78/Sbq&;NTQ|@R?' C~ZigC|jzEPu3~	w9JC8uN|^43 m&h6!EP7XkV]4|l(>G:2OYv`Mx'YQg'ja_}Ikr">XO<";/6?,u!zD$Yp[n$+[\|bT'^5p| <z#BcF;Za3$~dpqW/Akqukw.**\%J8?C7f(g1e2M"!^ckf5;lbl2uOdUNq]:%#mb=w!AE8aB?{c
+>9+ymbCO"W)w4%s";}bvk>?54'dz=o
+>y|'kd:7k>y/B_\~!_U~#mZFg}KuZ3 9 T^`_+{`ORm[@sbXBj6P[lx^+XEz_bW~|d;0l+x{t=K,3:O_`OE/1 qj}gYnC^zT~z-JnDg<aO1-ALjp 2As>Cj]BCGcE?hT^<k$;;\z	}h zr8u	9B9|zk*?a&y|2g>,|wYR715>h2l^gF>Cl8'Z.5gN+PG10VWUZn3^^!N47-tRd'utI9T^7yw^}zddN{alwd{@9Ol;$sTII)g$M[:`^tUXw:yyUs3nUlOn}E_aSu8rx.0(h%9y<t`{MwS+};>0.kwCN_3yM:RAAROd9R{So78^a6c{Dp^vmnlwFXo80(gv&]q{=i"#kD,Cx3?}b:k
+Os:9/GK]Uffa<>BC'fNF@Qyz,{vzDV<QSTf*avAq<Q*`F<L#gv'/`r0~AoIRa.Z%'c,{:?~dU~VyrUf==<)[/y.S35gXuLgDEkx<3"{4#O-0u\jF}6 m
+.>[:$a`,yf=8~QdL-ZOs}\!V{'1|^SNG:|~7~^srWjk`/`k6k$urk\LIV3x
+5k{w>lyS^pxzv%<k<6:-6YEce,kG48c@>jo03;}>aE]}N7=1&OyMj2xgm:C5Tks- SjzF9Xjn!At7 vPwa/SX{%s3->yYq:jFgAiX~=;u6 cF'}T{&=>k)Sr)>wf
+,hWl|43(AyVh+.MY
+;AyH<_9n<_Lr}E-"gE4.`c]/INtg.6Z^zt>^kOf{`Kluf1KQ7+drm6'Ck>^	>JEr
+6vcVgIO0dbS8'nyms[o_e+T=4WOe]1r?\,vo@~@=b8xfs~gW^ii~jiE|V_`v5tt;N.~V=,wb@,k=.8[zlK-EV^k1z%[`wkKnCr^Y[}CrzVdHlg|^SATt'~}woLadrM1 	nRry)O8gkoC;:\oY>tGn;oOYs@Eof8mu	{:Ls|,3/0DUq?>wB9|3BsU4M\`?U8MW).<tR'?I9Yt:5q!eF,ps/'i3O9[+yHhYln/(6TG( Ny~xy5y|fsa>EwL=J1QaS(}TWZO9:S763oL~pv+,nyxbD5LUY/x&{\l<-"yu6+n?(cU~Q|v5W]S?F~zTG[A7&3Uz/5>s{QNa[Vog[`D~!irA!8WB86I2?{;Lv+-XIhnS9:'O;ni:xnsuW_$3	8~WZ!hA?v{zMgv/|EI75>fhzdE{~]RR/P4-2 Xmgs1'/]"?	\\}]Nde9[pa8=%LnBw DpN? S./9jkyyF4Lo0^pW2^m@(yqgz('k 7> dq V#^2nkC_6wl0-s8wT\\C1Ft ||v+ooQCqp4oCU'|K
+m+5$rH/\";}w*kk:v.oK_(O)[{otj+(\n_l]W<u)/9Fx6xdv;O&8Jjv1@F;xNaxw9re_rwB*q|;:{h2REx{}k6h8gOmu'@gNz4f&vp{+8d<?/2	d7N6F>nM6WIs)`sW9X^U.OYrRK{=1BWZh{v[wOU4FcNM72>7Cwq8XZ49Boj{ph5bb75z2m@`8Xnh4g\3uy3v_w1kJj{%r{WWw{&[83Oi/E(y%8Y-1Z|zkd(DcTyu:>*vcgLcn54l|F;=u!#lE6H<xd{pPq>bU?4{]k<-*kOw1w16wtxsa?W{aq~Xc}{UxM5XaTcgj/q_:^wOS5 qM3T>h[b$nf6`8~~j8lT|%6ii{(9l4J|8OF<JlbUv2OSdxTG]m+6 {{TK8KD_?plhZ=JrL{|iv.|b&i|qkX6$E>_,9c cE?aci$mR<HCqHlcy}+u7Wa:z^zT:oqijMg1pLAoP1/,u wORi|6l*s~\-_t^P* ,JltGB0'b(iMz: x626px3FWU,R?9e0-0zz>x^N=%^\ZkU
+:[S^ 0>q6Jk3,R,<[wnrG,nDA}a:=>o] -G-h{snhC8^Qe59sE'P^5adK<[b,4{pUF 63K47hDSdA'ok%,6t>+}[ER3/@~EOMk,]jZqZr#V}#bbc{=W<$_EUd,WQ>2nwHf?a]'mg193}IYVzkgp=m
+xhX^7|RZ{MM;refN|_<93|Owh;	D7u~%V-~#gBt}
+!yod*1<j3U(u2Y8L0P+Z>*D]"Zv8qmroJNN|YX5YLi=zVz2n<t>[p*fa'Sb< [hgbka\jy	Iq<>1:!?-nNLV/x#	+=:p`^/liPY3|9~mG[g[v:3h6'SV
+K'ZNx/_w.M&x'y1q/{<P;qGxTO	c.  @>K98cF.*9:k31dgu*\/c~S4>*m~\gJm[=M\xWnV '0bV@&H4e@pAaJ#JO;>?'S9O9{/ +xJ(LtS_26{aVqFR;a%?2|P	/keN#gVq <rlcO&x>0KQMrSse 9|N?Y_Gsj;/<33={Fz!a/TIih}ZlD$C/5}gAy`#!Cby9ouL<o".c*hRpLFvx=-I$a_z|dhZ?/*Pku!k{x3uA4/oH|~/s'LsCjN
+B$f
+YTN@Z86Hb;ormkDlR1
+P\`(h+[ku0JiKA{ub
+-Rl0g}6k:A3cK:[#$?~y"cE\1v-f'WI=J=yvCB0&Y/^M:^s VwAB$&ZC\C]L+L1jZY%f2tcO_D?eX	]uz^f.O@pV.OEWh#s!F,K}##'7g|_(c^.EOsE~G}|xw@ 0vismT	UnZLZza>V^0]& ]{dI+AV-.K_\.0CQlkid_1cR8z/[9^,pjO3>`Bz a=FZU|!v:{3z=uQB1uCm+{:m:d;6k1?D;}]-o1c]m(e+t^\<iO* */iyCtDz9Yu%oDNg!
+KV1t6hNuEUq'|:*)Yha'+{mVVCZ8S~6{.q
+)c$ i}xo>!fF{^68a7'II1"=J;b`x1kIcx;p(DRzz/mok,JYIz.wWovSyZD=VV/xG;}dWqf\2*QY"]oqq
+*?bzBqE]h"]-zQ#l>_E>O&$6/#Nr|Y}Va~,;8+=cMy<B(u.La"1Bt{X`LPqE~9~mhb]2R9cUfW)-nQxt9	b'>};~M/G-$1+}"n-hw\j`,E=^&9b5x^+e+EG;Ln7#cMn:C6D9i>C
+{k}&AY2VCr$^^PW0n`yNQy*bcW}5	J]l1(r3T,1Va06/a`FTg`xW~]]|})E;Hs9H.D}L}g
+8{y
+6o 7W#iK*qov1f8Yn<sFVo[ 3*|FBxHK8	7!C=.y@7]>2/emw.lk7SxQw lDo_M^ufBvq^^bvzg2[iaMrkoR<^[U(vi4&7/xc_xxGhS]/.g)}6R6':wc4xW<:;_3/Xw"M-7+Xxo_&X}!wFQ's%&3f8bq c	X9gYZYc].~\[3]}+drAOf	G8YXz9]bS|Wo=qA<;>a+WC6_)?4~19FcNzNh01}vkz dKM'q@;_ E1`Ik3+Fliy<Q/Ay$t~;dL/n>!alfLN="CaZ$7/!-%"s
+vtkIB[0c%tdrzr\m(-\mi\5I*Z}>{sO}]HjV8M]Nma?x%r<9 
+24e)$|A`#<C,ig{0c=k3Tm3}!@UdK:E$C>Dtgi$gNkc^T_8_;(.cSSk#[U=l7w^K?mNe,?8`B79m+'oQ[5Os/Os[K*;/6:9,-7XTsex7Z6Jy+R^)*g;qo7APDqJpq'/s!Lo2.|&{/qwz=Umol.R=_b-j#Fh/O%6
+[4v@YKcM3oCTpNKx"q	qGoWPtnK8Ju1NKFmF4!Lr"xC4Ns_Xn`[AGt27;OlM{}cz&"]J go<zw
+omjwUHtB'j_)w]W^tKy[`jzbzC@lQ+]b'.T7\O3NZ\	g6T[78>![su.BUvMX}&eoP{ZCf<s~.6t]2jtpiw|Z jv:yDOQ+wA#q/=S?n0I4LMz=&T/Qwvy"~1'Pnor8Rr__w&8fP{5;9{8CMC!Vg}:/O$D";<5~$q#xlgg{O9!zD7s?YxYr}!Yd7t>eM+NF>?qU6}J3^jyfb_vmyt5Ggjt>?oNY.yZGj*4>A
+}t.1`~?5H!GLfN&k|5e5To:_.9&#qjTY
+StzJcmPV*s5kJb*[pz5i<+[Pe'dXxWqLOYx66+faY$x
+&\YmcuSf|SH4+HsW<srw!yDRTpYt9}4nd;y>c5+,o_%zG:BV{*dgN4A8ud<x&p#{%Os /][>u=0YFM#@A*3H8_EZ,X2Q^Y(_`;KPA/0)ag-#LK[hK9uMgL?;H.Ng^yDt]8}vN}.f01~z=Q\nj/bX{M!JV	ui_X|uY+I vGR`# }/!>>I>y}?=B%b}(_'X"C4Mk/D/ED{.rrEmB?0{Z?  ^J6{sc2[,.([i|:(slD]j3]J7N wfyh)OQ
+p_u{Zq:Jps~1||~	K$2bP3cBP+k28MTs]W
++uRFqjz{Ow}tkU|#QfM]|<`H*8NqV#rj!J?Wg8Z$Rjm=QG PyarOQWqm(PouHNAEdO
+K
+<9sehv&zv`H_-kNmh/MN+2fMA)aKF'kKW'UlmR{L 20AWEJJR>:#cEs9D#a#!>A}#M)x4kkVE~~_0:m]1s\/B/\M{`<8p:I>!;(';cMbeL[KfH7dN:(t=O!2cgzj{)?@Wdz/F6p9z/!\-)3QN8~T[h9X+xkZ:e}1a}	r=TykirG0x< s=x0l'(>pX<ccM=vX/LH&Lq*K`^Lg#B4Pw(UQQHN%TcSd5+'=F8V;IhI?v`|sxnu#/s.'!xnq%zmO-7PF`YF>}9#v"11ucdN{E/'1^o*]>+c<|\CO=?uc#>}<,vX&'F~?9<$k<U\|FN1#DwQujw/5:b{9?`qLH3e.@urkBK2'$q}/mCQslI$=QCGe9}2d5)>Gf.2;-D9){vlRuml}#6L LW;/Ho>7=yrQe7L(~`aY|[/!}Cg&>fFs4CR	4_Tlhlm#._	~['(2"$xy$sM<@E7~PyI)ZSbk;(K|?OxQcG'[ntt<U)[4D<6r8AO5y$|WN4OOkOmg"WZgfm<M><Y[R>k bnxxd`-,O]2a0:00$u^/Wp},mm+LfUp]e2uA/TrP(^C?<+B8|Xs:~Bzpv.eno^:^
+L:.5}td6?x?sxdy|?7Su)K OLT{}GSM=Y4r4Nz1PnC\GqzbC{;*WSXQy/m1o$'9`aR|6q48srRpuplrXfXx?mm^WO" tGyHh/*]Sd6)Eo}/4T_f"W729WwkpVdu%z0EnXG](cZY^Bm[(FcRF|g29 3qzXw<*$U9(cd10YyL5l{?-Ps:?<$Oq $b2HMar]Oqt)C<y.wqh*8n~,/'8s8dlj<kg[yr2
+`uU`uyuB'V'mTiC{;'$;i>ybw >{]wCKsr?D_,xL5hk	.Hj}5__pMNs6s.]dn<u.u}8gT\[Nj0l2Nc^-;sy[:9OjOD4ut~rVv@6_a@obNVW#
+qEv(so).`E%[>F{b/b[8{)F'/,kkj-ar3S}7-l9ow2G#yby\[v8`n
+xNc~#>>_~Omg^FnZ;LQ:g_jg|QR[JD^>ye>>m^\]FK<mF#?8[jsQ mC7mV{'~g_ZSF&B}4kc`m/px)e~a	s	[tQfWe!p}}.'\F~y@?n>W>G\>.1aQ80@SuGj5dGV.j}9_ ``h_N5#D<N o=?Cu6i^ls>T=Tg.31}U\Uo-R^pdB1=:6FfQS4{d_d[<I9pH'rb<5cjG-cN[Bq/
+ 7yp;xY,6DXv%@|,Nu}a{pQLso) lJo+q]x0SHJuM6I%)>}~b]w1 c}uu0v{Y0f\(hCMq!
+c_I/,Dk6C\-C3Y {!n,4jfrldo0Fk=4sl'2D>I~&eJ ~08!%biWkX@t9xxfb<a<::x|)[x^8Xf	Jr~^f{8\I{cohr7K&fTMkzm, *w
+:$>|ai4%k}&0$zP@A@\@PFd:g&u F>-h}>^'	QOy>s;kk}Zk72&@uH);tf-:?73+G6>w5 2;-~VRw-u~r>CRX(>"fJNNuStz;K#[u[lq4n NL!;6]xPf^g8xu"`G?C_	<I09#qL4=MygjcM[[k~#;V,?;x|aCx38X_&mEp%U'lI5szaf<
+Ckv"QDd\;'oew_]~vgg1+qV'Pwzw;4,{Ky59[Pzv'z]Nf{;z{FKOLm>_7wH_mhs5s
+9t#4}k}6E9y2~s4-9
+mV7#|oq|DNP;o9;r4{2tF^u|v!uM vo
+j7zs_f,ynNyvBu M8fe2j_cu?Z!{YQeg2/y^qds2ow(v
+_u_2XErmv,xM8'UM>b6pgq^-*Mm,YImwXyXk{b_E;x4nr@NJX/q'b-Q_/VShWZ"^vX6;ilM-'w Nlfu'Rt3qwQyDaZ[v	=Xz=4\iS%uL;wz%unO_pp
+vqoM,wmw5zJESBe: {~&<A<}~Lv=c>r\]_5#erNa<y:q=jx_~3{q=>)[2j?DE;;"Avx7qa+4'7(<~c%wf=;21wN\yG.Br;63C=iji&`;33Aud7IW.^{/%<%/|S?};T~-O7=Dq|4GS-Exqroy1{a0[=<qrV<(Qbl,^GMO]nkw0D~N%lpRaM}Zw{]Y}z]\zxLq-&<Qz~_M-y~>PCB*+p+)[7+NYao?WH:{s)NnW;q'<*~cUUR'6i b
+<3{7
+>xNCm~#6*2PmLK2PmLC2PTR+n+%.
+ez1B2}4B6LwQ+n%GQ+n+E.
+
+ez!B6LwR+n+.
+2A2PM
+B6&Ba	179j!\>ht(F] S A=AsP"l;^l;cO\,s9xqHi} K'cwSp4[%[[4!/%?Nmm`-(",T5R45MTCO5'4GZDM;bJ*ASzyZapS6mRo$f&eRYj3cVZT]D)u|uiBPBSZA5.I `IJ]Pz0JHi
+W~Yhj5j4Ry,^Y_xty_^VU_V.jVi5G,/y.7i
+G$ 6Sy^u9p#9nffx%>9sx^c	3KNf[]p)Y8?#+Y2kpFJnOsZ$4ODM8{F3'A[hR9!ZIM,%%b[Tmc@cfh9^DBs=}}OP.Yd:xM3u=>v{Wo;3t*z_vHtK_'KO[KdffgQ"=x?G}ti~izYIg_CDzfJ4>W:)i"%3zwz_>C{P.}eApzPwRJ~HW# #"K!]o{FS	yGnGct#w%Z3s=pu)a*1
+sKl,ybaH^/lL6^"`Ocr Hl<P06S>.D>0I_ Ov{KY	C2[d:3%X,2{ujEyysY5`o
+3er)bg2Q9`rcrEYJn5hT*[Cj,b%&s%ds2 R>Z'<)"T'"Xy8)mc!Q|`Z"epv?`SZ"WPN*7RMxpK,VL@EC5%E_~V$s{+++mN&JX>t@N](=3~5NnCZ/Wnp%(UEY)s6gA3,p%M	\se#{t=#>}pg,p7gA`Vnpm<4(*{@pC!_8R1q)#Y.W?,#j\(+nUg(n\_oxU>Ux*j=WUzWUQ[Wqe+!2wbtY!~7#tKl\)p+|9+$;&Qiq9e^h:2O}_P8<E/X(an:nSA6_EJXM/Vq8f2qg|-{|'=_a]=]SFjp.`# |,?dok-7J~MC7lc/ly7|-Z[[yb{Soi{~~-OWt?vhTG#SoJl$X_d+o6?GBQzRc`$aj	56i-_Th-,Xg/%(3THo}YHX5B[0b,ObT6Jp5+MrT!5$#%5 OjM}H KjmS,29LOZQ\nl'FM,#X@Ut&@:IPT,QLXf-?n`jZp[)!i=?X"e|2n>yw`uOI7K?-NowIG}A6yO(|ZcED *|Z?4|b3g{:?4;=F>mtiw5>G;S!~)>ROLc`O|B@||b9<qzNs!G7Yj	h	XY,Kx%i	oSpZ(|qh8y)S{qt w@^t?B>F7~V/[X/\w{nV,zwT@fE!qyR+q)+wr]KiXO.;ok
+=={Q	eg,UCv&MnZOG={-7S
+[V9EBM7MLBk6@bjw4%|-:3*TZ<}RRW@s[kuCC[v+|?K4~^\\Wx
+x".]zi5x<M	/8Ufy*n[>S;=Km/ Vp2,8]xz1$)zNwRe;p6%\Fy1]@?!/;Cq#\5Qy}XWd:-?N\}bi:!\w!vybA^G|"z^nm5"[XL%1]R{\cSW,JrK=\{M^ _=&{j9N~h*vynIts!_AORucj|t)eS@Fu[Q2m%!9#{w6W6~]yH[q!	])e
++>R	BQt{]c|;	;_IQ7\iS>Aa'+]A^g^p d,qi;wRS(.R"X7)|Gv[`_O _ v5o do[Wzz^leq -"ThncI*2s^;pn>q;l.:Tev]fQp:Wzw67*-~OF8#6/hL}"B.u:p*c5S[$(	C(a?#[A[;pZtPF2wq;^8qv+|nQUnk9Owg^oB~pg+:? r{niF;2Oc;me^{uv?=GBf{T*q} y2rw8u"D>}Q>2wDa`|WoCx^:@
+Y~@7/>u !oWM-~`wU9aPn#	|sXP-}Hsy^9Wr}|z;x6u	9<x!WoWA sO'Wy{ga?I8z ~Qee<s_U[cu^RzVvCW$$Mr]|ak5<l#:Kd@/F ~p_wnF*sq=CQwBw>OdEUk 9;q/8}jUDS;	ur2J]Z?liM|(P.wV, xJ9dpoa[{p0uHf{[m/|m'nt-MW=*=;Z%K,q^=%Q'e5i;ixB5v[S%B{} o?#dqFMuhM~;3ONc|M^1<]yHQr\Uj ge] RiJf+u'=6:Sm?_y=vs"W?/~}<BcXl{	N>ImN)tQ?{3Mg.ak*] |/:::]}s7oO[fS?_3e4{R$=}n]}3A{vh_*~ B;*5%\AYU^u*m:=Lg<1"yDi, ].7p]a}iMz')uc9|Rw.:BD;`{8?S]?ezq~?YZ:t]p`J?<PmoPQCV}er~+Kh	28kA^uNXO::Q'Ot{v'rLp*Yx=. 6-gtN4|?+w)UCOYlD~v<Vy9`?|"._Zpmzqj<o'm&ams\OpPb,+? >
+^wF}OK&wxHI#(d
+ *_To1+Arf<	~u3gobx/)!ex?pVZ"V?XLhhNjlS8
+yf/UYvK?.YSjC<hRmJk*~jK9IuUj5Eb$[Z Z2#`5<r"~:D">9]Bn>Jn7r/w9CLW,BLms!w#_/rH|G|%QGC WQ3v_[gYQR9..)I-LRaa},e0|I
+slY*Qm2^dH$c23dPwpj-pV{o 7N_\da-fb\"S
+b(Gk?rq3ek5}F?6|$$e$]#UAbU.^RiD?&3$
+-&O\UEuYdcz?+4&Fd!^S.`syn).TpV%F.;V~<8L>{^!gbn}	Gn3?)\L9PH'alw;l'NNDao0g+(}VvL2Vd^n+F9.-2@? L*-qNSb+@oKa&Yo{\r?'	:g}[?.}LcG,LU3T!!l?&7OC~iJ__Y'[-1,!Wdb&%lHgB62#W9<~v=,p3l1A]2[|-}e7MsK@<K|KFK2K-qpvML+e[eW?I]In;2{>x~%W3_+`B^Cs%g&1!{}F*L\A>r8J7&WE9%!|R,'N]*)=l"J=((djA\|XUo(6>^H7xB*[~rH4-{mbO@fF@ox21,+wp"!;,b} ~3^.'/8xyfy=&jAE;EYDb1[_gm1r=WP|f1{kT>>"_w!3Z7k<6|O7.[Ryjp BqaC|#^B5/@:-A^Nw~Z`{T> jV]*@1c!Ew;<b+	e&mb.#z4Coqa%T~e'fy_HqZs?T^DR::EQ`$415N_nUO1@/MC5g~o"<D-2mrO,<*7<1acclw=\O=eE[Lz0'x3?:s~>c[V&APC-Vs}j	eEX)R)>e8=NYA5XA"|I|f!U^s~6lvDV=mm[?U_j'l'nom5C_GOS{HI;e<"R=?7:s~amIy\}s fC_Ml^>i^O_MFj L9-e?oT^~MCIZTS{Y)=#&~Pj[Pbm.g6|Mcq>C,1@X,o9'4{,J2s=X(3j_e~c<_\kly~~u}1N,V6}c+g,|?'o
+5|?\.oA~5<o7m?}b>_`5HN
+j	m}8P~o/mK"d:C`xC2</*XK,LVX.I6''#d{H#j H"D1OE?K8EB?M!Kg2D1EyEkRD5Gd<"Qk[&-fIv{~oh>z[X"7R&dS$0rZyV*P!1!d!iAe(7Rm!7BdHZ'CY<7NCWwnR!O!O!GnED dmCP yxX<ium9b% VH2!'Er8-TB\L>;b$7W4y8I7:lX"$-2\dRCd3idJHIx,b26%-a;b4 LP# Rw8`2A6`V&DN"&X*a1	{oAHY c-;9-]fj]I#$r	5;&v&9uZ _?h	Hi12w
+hk$&3-ZK )?ui`K\/7J%zkWid^r?!y?^[MkEWK]\t]3Gld>Z9N
+kLJb0CYK&Y@>W63[<ih.J5j}Tmh^m&_B4[T_do
+rWP/CJRI|?+s3%O<_	%x	jOr0NK2YQ|Z#f<kEbKYf-q\)"rx^?ENpv)6 JU]-p&e&	6-0	dA-um0fPWr0,0Lr0$_c	KlmMa4=&7/@>~?:sgIB2$B@ ,	aS4$lA[$X&	[$*Amk]0[qu3uwgU?^>9r|V*:3tsZAw+B{k6tb3PLMnOHtsAE8Fo=_7w^(N8B	B;MOst1_vtC{n3Ae=*D_w1otB{ z:G0>#DQL3a[~,C~l{}oy_iy/ZgY-->{kykyX,n{]X??~~[?oyo?jyokyXoY7Z
+"{}ym>27]nY-w7Hm<Vx<yHFs%FYv1.;myM!?I<+y41';>F/pf	F:iCVi"pY}SAjZ 'kc;~s`A8]xYy9iTcmOkm~9l=1lS7y!(cxjB9)n~Iui`i[	?5=x{6=[!wNwoi152bJ@nm+m|962,qh[5%|yw3Fg=B<gUx/txh>HC[\2|&d|x9cxQ?Amh[!k;&4O//<><"<xxgp]opQ~m	s%9
+Ki#,	Kr[Y;aI'Z ,gUXL;l0$%2e1	Krv4adN`	c%9?uiW %i$VaY2m,aL;aI_
+$nCX'KNXai.e[|mXY:@XgK>$Zui"%i',Ldv%i_NXsaK\4J2:M3yTmjoA.7RsB1d-GU|`m1Zm]O=x@*uQo9}ku~GhRZgQpC6-=l=CW<<g.wtCAt;n\Uq5zVM98y7;R\3:g6;hl@B;t: ;t-C=M{I/PxkmI3=/}.d2kB.TW O5W#:r@:|zoF=$\fu.|3y{6irluK#=>u&>;v2v6. u+Ox(:5)y8r!TK\ BVKoGcuYg/aLYD#j<wnL(;wTwv <@0uJONICZ0|/	%N
+"|y%65xc&BCpv4{8yjrA~#6P&"6/nL%S]bp2!8&9C%Sum6\BP]67#~sz8ms]OyczCYG=7=u@DH MPkv-Tle^a[YJ.9mWqe#?	gfDxo
+3e)O~{0`EwJs3kw4j141.59EAu4"UG	ULo/qB'C5;.IcqA|/=rO.nOnCf~Xd/bz >[[X'` 9&3n*iZQ<':Vk%z
+OsmZ :`A[@0ggO&hk&.OY1.<sya=0#\n+I.4im_[6?_96X8|<@o	G11)8S5^.D`r(|;w<Gq`\7'50iVA *eE7~]4JV6NsQ4hl|ttS	F(u!IAv1uMkGR9GR\nX^ouU?$?=xvN ~lF"0W0l6a=baa;V}mmCc4y\[Sn5cxQzp:=kp`8(o)'4 GK<Ag) A&YCkf}p<i!yfuw$oF=Z@ )5O{awBD9=A:C:tt?8(8~ zxYI!u5@'_NE54qyB1Wsv:ExF_9r=BwCtWm2uYf8/KCU=cBSuB0y:CNbe]/pM	;;f@9ao|yeY0A!C$3!k=`Wr= EM>UA0H'F;Nj&nzjn+5H6lm\scE#B{4=<ytbr~-6k)Y-\Ey1dlB].<B5#/<W{f\/R.o`yRG~sx~J{_AkVmvrV&}7e}o<hzFBC%C$mx^>l\&$.6{wcxrH@n\tc$_0v5e~g67F#>t_MP!AE-7)J1vRV$iE@,]_~#}CvAExHO]gE{9Te *e{^T1b?ByX}[nYg
+rd?I`-g(3I7p/>`%Uj$N+>>dx9O4AElny
+yS?wM_|{9Ikm_NUoYss[F}`<:oZs2X0;|%'vqkvFH~*|`m^.q$yo[0;{&g}wjw:qZPuM|,Dbk6l lMCvpAS'e,Aq?" \)a[J'xB/kua=Nuo=5]?N:t
+.?wKeuYHs^%Krpp2-p8u4A{_,4DM83e=\K[:/NehyzsbuySgb}=VXYG=X_[s}8A}zqc:[t)Soh;p>Gx;lk}G@K(e>6NlP</q6kh6!Sdo]	[wamF;*#>f\[5vKv;=]g?[wgbyh:iNOqnLJt<hCnF]I/yM_}<0|r6Sr@aM }_OW227]8dzM<*hS;^U7Sai_;!AY@/$\sw}&jcB+ThW,C=<nX{h#'5zUuv#}(yk35G==*?w}H6ie1/!&,<;~YU9sw+xLkGxDpN &Ol)D<wWZsH|ow:wdDPc'lWODw3`'p/iL(S<)hV('Di6?iigDOW	!w'OVy{<W?4Kcrnr9Yx2B]F
+t^}	*	>kvrej'ss;&[I;$>RUt~X7!y|ICs~q^mUO:K6Lz8_4U69'-4x_1#^6j01253~/W}j iaxLoO#Mi?v+;15k<_U/H4uH?a'9+w#c;LH{UWue:,}U[um3q=eStkPY/KzN8W_pp5clcZUk5h5g,|qZ2$3Uc'pq3wp35.m7-,Tjn >K|F6uz\*p^so6D?e	XE;?f2fYF.7^
+sK7o6]|&g:Lwc3=1{5LB6=7gcdU	U|o?4UG#cx&+_@1m&& 2<vIWN>7o=.>W`dlLG Eq%f^gqHY$|y</y%d^(xc.gf[k[#i\o)tb\%n*jw`ukG$n&7t?r}p#+U?a_.V~D3Xt_tcL3tctg3tdUykAha'C(qX d(E>Z`x@|}!^~2<wX&12X_GI/Qn7wt#~So#~o/C76<;(X3U(x:/&?.&'?
+_SGaMUNXe4+6Sac>*gSGq|8klsFNL;l^m>d>Y u5T?iOcjO?][O<d+Db1J?>?iYg9Re]j{(n{by88ze)@[<?&MPx0R=PV4e3*S6;W9HF,Wm|-lpkI&%W_1y7j3L#:\`xN]f;3%E^%y*yj	9=Azr0=JJY^%?,3: ,a*~|7yd&wQ;"o_=2?<E[y&6=OZ^y6a/clAYxb&50X?DiI7|%[z/CIY#qM0|;R;dR0l%=Rgo761~oF9d|bXMVU}GXc[hk-,G)' ~L:2}x.9|rqtI3'Mx#,|er3=@00:sm /
+Mttd <w4`lu{
+cLJ>;?I?3oCp@0^R]9>??[Nv#e/Nu["-A/Q/gA#\bI1#<f)(<5A[%5#gF	*6DMQtquA-<+oY#cw&L~)YvcpcyB}'gEgiWjN?56$/y/wV}mew4yegs$-xl=Dd+&]_/bs[#lUDq$5F9%;66NGH p)](q~:=C>/t</ 19(r8V0eN{xO4`_<
+=!
+K0bBp* *4zqj;yzS9v-|y	~NvRr7<x.o,0;
+"`oqbQi`< Naeow`4M"z36uoy2yqT<_O>^YLpo5UYQ=FYKWl	%rkvp7i	Unvds-} ?:`-"1M{_yh0RUiyf`[~g;xmVe|	Xw(7?X`vyk1h4qp 88E[G{6=u1hlvs8>]OQYw3M	&/2@ZT,5r+z1\Qh7;/[>~=4	qIWyklPVz*}8j/~\;t6< F^k%4umpjw_c]6|P 4"5RH$vskp:m,&#=BE hfIYpa~de1mmMb4A AzCmBg~nvPMgni8O)'nrKO%Ww:v4\K~/q_E*U!;oG,
+68wle1&UGax2|#=-}."I^dC:0b7)g[]mxfCi	Q	QE=	
+n$NZd5&-{.o4Pa9/yxW8U}6OAYqbI3&mYS[?3>BH-tnp/tJ3-Ckq3<n<Xex%7t=k&efxk	<fN\x&Vs1~:}\26rGv{ygd'{Gmd79d7=Zn3|n[OkZn:K96n?j-\A_'Mmn&=joX?oVZ~soh?j-Nq
+9Cmd;z_+MA\	&N,)o&@7fqX7F2Jth}~)94p?k3[Y7RWr e.h{GN[A[~uh-fe06c*{idV-Fkk?'^_(WD>@Jh+k	Zy*t9+Yn(^zVFkYuY+'Z6$|fXt>{5x9@Y	yu$oiv4k'os 6#kQ'7k:r!kVBcLKx G#@G*co?c~"2,*m@j{y;m-,2MqS?77c]1l3>%CFFlC~Z't0;}wxP%Gulm`{kv3rTy|7(O_S}IH?&ASkyU_,uoug>#-uc)+NT}]/ {-M&S@^@L[q  .I~+O%m3kJNh :hysaA79'PU5O`%\["i%?_:5+`/yM1&7&CMPzn"I+Y>koWtv+tp-si[7y.{	op.?hpj'N$p*.Fd:rLX\
+8u}j[vf=vN!z3Ghc-xk!?_PZLCP;8
+'y5.!/H\y2!0ovrN vOC xs*P{:=p88FQuK35L-j;O:euimzgy>cqKH#h?3<37& qE]j%,YcES>	yn'<'o>Ct}knq5HwK5m^
+nX9 u>z4o/Ex>c)6</EWp{SDzBSYog}(%9r?aaG6C-5Q\ySL
+_K@rVs9<syo	_ .p#J~^6\WOvvEo]GPw}C^ HOdpFpStTg,qz9']xx|<?s-{A:iw^h'\x|EhuvG(QN~}5ddr#v;AX$Ua]e/C]$<h,wLsKDnt:zkukCF4:`Et<$G>gigjgoK;}F:#m_ mF!{u.5ag$,[D8rU^ztJ>C}UfQ!Y&m2hT{K]!K0-NQiY/3fR8?3F4z7XokC}O.pI_,	%8wp)Dg&MIL<~KS|m1uC [9uvyv{G#:H((7(FxUXA]'gjr{[K::Q8j!kd"ftwB@C#a]9]Ga
+9+C6or]dg'h(G=HZwiW^
+]3i!{kx0a:Dq	~"VF79m+wE=T'94t'cbm(TX
+s#d{ {8E`$`p|C	S"L{;ke[BD~I%]t2=c4%n3@#uWi':O0(N'<>g})4-{:?_%:-/=OlH3jIN:do>l	yKxZ?)iaC/Hco}uy(zE]`=%HD[F]^scgn+AZB?R)I~k?E4'1.q`W
+hWJ"t#Yd$##cR@Z5kN:fpl3C,,a^ uL=4yjWr%[BqS8u-B{)bg#w8TR_<X_] 3,rcgiW&
+&^
+yd|Y?{q!qd8VWf5e.rW{%\YxK{_s/MAW34muug%*hpOinq)y.gk=Pn$HS wSEVnu8G"ls`y=H,-$i1?Na# #Kv myyvi?)B\-fr<2UF*_wa8qKDShOj]K<gOO8<5h?W_g^rL_pZS[Vs#MKUb*N[i*;MU\Bm9Nz/rg"FNc9ku\Ll;Ab\^>AHfe{ /{9v9ymiX3.@|MWD\xKN>9IuiN_4)i[*<xFuxlsxyOgU:'h<SO5mxs !<	Xyh_k@fX axs  vr|HfZ}G@Cq<[B/~:NX$vL[<#C[H($<u#ro
+4>>Recd[i	"vDQ'c26'{*D?;&)]O{+Hk}e9@=F0	^Sw	Bs+E}c/NO.~!S6BLR7(=ZAy<zii7rnO>ozIl.P&oK:.#>~}Ny`et5{f)}l# s+z0k]9;hiz8h))SvWeHwpXle'^Z=6DNbwx!!yPuk GG{L7yNyg C=5yU="MN~oS"kDY&_aF{N
+><qUAH4uuaOC^5v[dynE(g8i*7Teha~>YQ.eB7Q!8f4E8f=g_PC89D=/ERPqLi#5 #:yV6CH;Opg}([S%7yW1xfAtP'L}K:C?bC!9}{TxYxh<<U97q?!8o_ut	[t<7o,Cx _!{`4
+|
+SYoL[P:b	i[<	Oa)<"1Cgms\o
+s:Ks".ntsX8@g\.o8%B[Qihw7b/\ 8WdeCV	T\4#guFqA^eQsZ/`2h\qj<m9:u$BzP@9w#^ ~-ASa:_G<#<RsK S~2kSz~Kv@XB|3.i7>6s-!WE/yOP'Y|X1]lLjOh1A;*z>O#Vn	Kl@Tn<[uI5UolMWk]!Ly3>K-j)#{@Z]D;>+|]~0=ms%f/<ks i&:9OO.>J3zg~*zs!Mii	{tf*"d>*\e
+qKDmW$^
+;v|#K$:\8\n1e{6u	^X'q>k[t:}iL h4nBQZ'g#w;qvT<j{wl6;~s/'4F 1l| s {[K49k9u~|-}iE	~tm~omh0]?Q7K{t3{~0FugxdH.g4[atHNV{!ffYQt}f?6<mogOnfk6ouom3l8Uy{/MNR1wYvQ~>\2M ^
+BD)dby+t"
+}]v7=p!xy&de@n<]M/kZ<=iR[tx.yyA^`O..[X`%V,8_|-	zr<1zKsjOi4GugiXM\hEb7,]q[\z`
+,m/Zg.+w!<l>}8z%W^l=p"uL9lk-)v<T`263b,4,\xVXD&s<Pxc&Ue8O{sUNxc|Ll)/eE8FkScOf4|6og*%e"vIc-p;yLZ3O-[bG\=cRnvOsWiS	&K~|'G'.<)*iY'aHGw-?X#wG,HvTv"^9=CxYiy"FvKx-}y_7wwh^F=/wpq+r}OXs/ol].6pP\0+7{4zGuTuNZk |7e[+aVuGx|Kh$~[]=N<27'k0=O7M>2?h{inM;sZW+LZKi9 Mlk={*2q,o0 /54z%.^cs9DgoFCb6)ZRg8z|Obw|/MK)'R6<OY%O>xO6@O) agxbFyF:+LD^l){Rh4aYxTasK9xJ;y<,s0y5xr<meJ<7UxVQ7j{r)w}<7f<[oWy7e!)5|seGD/rc?Kfo_}Oy_O]<_<9k)oV^)ggJj]_o4?W.\o~enmK8p\}>yd~;<xnc=<tE!+lcZ-=oxEPouSrTONZm^7/fi)yf{uLH+sS.I+_/]Rn9M<j|>u'GK|x`:IJ=>/_CM^]4og8v~xNv\rW|~lLJ}m[WtIm^wg&=g).OT/oyQbcRk$+V.&%dmmOmlkMz!@?	]-?G?_#l%u-I+*id%oX?Q9^iB1 yMnDx_OBczw[xM(|z1&o4xHe_	H}'m*gQ"'_!\N{-9I"|t]K|N7V+~'_@`L+7&O[dt/A_[{[{I e}Yp .UT$08?FO}ZK}%5x/hw)oz??^B3[ZkL~^FMr:|y[,w~kL9F?8O>;-D9/O_U~RvoZc~rYYp@P*z0SOm&`@-}><[oN	3xpTLo^,9X6 ?aI[9pH,]l|/P{O(Mquw}OyC>[}2$/n,s=F#'ZdOo ]]?sM~.n*oU0Zw)7lTrY}&53!?fd>(T}3.^m/_o>t*1y;ey"e*U%W]{mb]JYj>y~)/_pSxH7l\E1o.,^"-yVV\+]!hpe&`,Y6K)si/RSs-Y%,Ye-+RN.Dl/4kd._p2\~ybrZi[L9c,Xx<csW1p r-f,/Ug%_F@]hvB	}/=m1"^({f}PvP=PBf-TPfa_c:
+fx]E%-4{jr2'-^-,s]b9so]H^k4	" B6~.tC
+N)A;It]0tA>9s?C$[#	1rJH]X?]iy?fyhywa&9W/dy!+[!mHmHxw/k.Wv/o,^)y0;XwW]`H&F79Ft4uoHow7*=.QM_x?_d?Hc$Vm07M(io+:{{1Q oKJzgH[.sb=	LFPbk:,c:G${,`h'br5N;I/4&.yIc,6Nu2Gy	;/:#S`8Yf;u24A>F~>%}MqFR:#jrC|u u_	3_l?pE[swgkK>(>3>\xQMWLng]0~v6hh}KG^?;^:\6c]\5=_oxCrL}v^vts806k6S;Bv$qL;oqCLO;=y8q*7q0#`>	%W&[71?hs7ELxa41{F3'6O5]!e/!>74|/I2=`q/3GNy~ikYeQLo"xWo;eoGxc.}\<mB8<XO b=H<q{9_qz& D5eMA=ea}$1;c<%[lqdE%d67R_bFC#ZUJwB!Tlf`r<<0[0F\:^ghxU1{`^Ic?^p#AGl*'jaal:K#P6hp
+7=_;7'sE![3a4w{HQq{qO,NM,>;{=xer/.xkAE9TWzK>W)LtryC_Vnr/RyvLtc'O^T su6<%{3_WEDb3}cF].NOK%Q4yy/i^u?-:Dzz+bdc'B/jh*x*Z6r[v>6YOx~H>@mP+(!iD;A:<xUCn+zT/_Lzn1b6;"pa5V*s]opp
+&LnmiB-k;~[YG_4Fh?iTzMM0lO@k\Dt}F,4tNn"[>g})L~PG*0^a37m}-jOnCk;`57zzKn/[	+m#
+
+[}#{NJ3IE!<C#uZ.]F?StGg
+qU)x"ky=7BuLU;hJx=6>!	b&&t`na<MqU\%hGI8cG'v.e (/_xOAM{9H<;I>o\F)7E;1Vx/KnlIB=EWE`l>^H_ e6/_76s#U?=o|xC5LK#oS2
+}pG}\3||zSw<yCG)Q|B#NN4w-\,V<N =>&m|1xH<Ca*SsB:wp2,|g*=q!OgB=q};bMyx&^{6_k;*=}}m;I''ES BZ,p>3ow_nyOd!o|;8KP{}G\z7eW=%Ny5s6L,5iY4y3}o3~LQj%f=4pD }DTkM#H;?2B%g?4\Fy8NLFip04Qf0a/-t1-nt(mm(QCp[@>K0z({
+:xu}p7K8<^!HVK~MgT8~+&tkq/eH.c~.lp*Rg`yn.8[OA<(iWyt;SA/:6^/Q~K|3GE%i(>a.9MgReX/dWQQ-*./2{O?&|anW	{Fs9yqXL!%SfLWA] D\+A4@6rfJQ) )'pfc1O;td,a[3"\d3	,#!O%iy{n2'$&drD&V$%'uZ\]-!t*zo2]6+Pg
+w qv<:9X3/V)*9`J/C8j68ysq5y+Zxv7OmS@z4	{eqM}Tk/863>lKw FN8e??s>dpaKCRdR-qKW86s\[pC}K	
+c_4:Kdw@YG6C!r:b<h[_q/v,tJ1wSt&YR2/8/QGinwBkUk>ry^dBg,}fbg2yY,_kggG?3i4MD?Wq9tG{LUe&ptW{z?'b|]D/=&R7B#Olc}!^moyitqyw/4;y
+tyKM()lo<{]mqnb<glr_l/8Zuh^|Lay#_y_{_h0C\X2rGsFrq5/90drN,^?7H=n%U W)dsu7[(m{ewG.'u4l(.zq5xG]4QvQdQ$P7%&'orfX}I7-&#('mI2$-Bo#IlG})a$FBIw?$H$rQ.S*:O/ (%2{C9(c=:9T(hy
+c.qSW>"pOA]S[R
+b)#$hB7p>b$acBG|d7:?Y):v;J9l\+.ed}
+VB_m7XxR$8;8cs1z!LXuQ4W_/ RJ6kv;){p:!uA[g	p[;-MskbU<-MY&8	U!)c^tr|Q;!suuw/|2pTV|9JgRw4|_|Wh.j*b)wQ|~86}zJa#gzb7?}Q.GG.-kk~}S7{y/o9p{5g=Vm]g'/cayvK1
+<{(xgv>W<NOST/}xW]Un\=3|p^=?jwxef'Vn.nnO"=~7V>blMk_(|wde(qv|SW==9KkM|nOUO<v'R6/*S+k
+glhV|1<;NM=B;6rkQ4*rK9#'r!WT?_RVr|68G1Ocq%C^^93p>).S}1,f=#nmxtWquC\2_I	{k	phLh'/-o?	uMS24x}*qlV%@F+/m+)HA[	H,NVi&)7QhWr,%An'}}4nv$8uSBY{6odG)/G\^2W.y<KO;C=Iajx,KQCMKn5 _G|9d^-F/??g{9Rx;{^Z[nE<2N;Y_D>wNk&&|yo d86(0n/V8{[5gcB9&<voQhZ8Z7<)m>Jw!&rppep}>M|"lYcxwF~Sn%yy
+Ko$^\.'m'qocFW%B* &V5WqUr}$k{Cq#?mE?xczZS!_{ioRctw7{J)]; K\96:dw;^	K%!q>4=)`635vS~/#YlkU/]8Di}qz~#;3As5?AYwsS\\wguYp{8gg{<A*Vq4K=VJgUpjC}k,DB{By`}ZPj6[<i?:Arqf4,mE3N/V5Sh#a|<\]xHeV=jlir^B<of0v!'?Zz=yr]b.^'9{BXb&mB5$2W5<C-&	rMh"{1nEh-rMz"iJ|KP0oTdSA_nW{Xlr~pMA;s4g?C-xwqn62|;S^7].)Ks.qB %}j^S%O}g'=8[~rcue0:}xf>:DG^8x&220T'~5+\[cH[8>$t~*S}x}wz]:8]g9+>r3)Fg9G&d5:mPe%qMN0.IJ4W&8cp^yi5g^~;bQqK_n~`D \\3D:1bGo/q>7Rqv|?Nw4` 1Ps\^X<FV*k iC6tGez@?_WHjo5T\"e4^n'-)B[+1rq?uH_EcUzYTE(
+M~8yX(&L9 qCwOg-3|1k9c[{3dA)<.!82Y7g9Cluqe(q#%]b<rR?pn2dig|rc
+KzoJB 1}KM9ZI~$2|2-#ct}~{aKuuY"|n.nSxtY4<7V_:_&i&?[MhUeGx;~V{ 7'r6kNO.3^;j8}9'CN\;sKUx#9_S--r=16~S\<Bf?$,um0]1]}1a23uy?!WbP7C+n==m Zt[UyJ+z+d>J$.qa+_$J6fFy-#ylD*7*xKh_c0cWJvs\K uZk,s/z}q\g\v xpX'muMHU^H}[WtVycK<JAOe A\Qsu\/a?6;8mg4535M6eX]dth7=Sq#sn=3%}GOh?qKYJo}^!#:&u[y.-'W}m_~Pu`Yzt']]+*otzwq.~bO=UnBTc_}R,F9`qtRh1^a;O["o%/v:_\b]YS
+:6)?hgH/{}v]?uv{EL_{#rO~#D-,{81Y2eGs1cPg>8~Sy,%sl],r Ne=ryH8/psU~nI_kX1uC?91@:rXOPjss+B~rsvjZ{oNo_TnUm{?*#~wT/Sm_!O{yi|U|Bu?ayxX%ghw-j|&PM?/1Fa|L9RpO[;9rxE=0)Q:,xZ(Cx/:6SPs7m2^{NR?s]tuuuRy7P};^[t-J}S]N{^<uuN{s"\~Q;[V8Yit[p^RpNs,AsCD/o/{:{%j:WL5'	UwRRO59>Kkt]'d25z$,c89C&-|#Onz`OWGe)}9SA>pe^+:?,<Yd=RX {E?7af1Vx'^w)[`ODv"]8'C^;f=Zw<xolK&w>$Sm~q#U&~.o;Wg5C\U#<q^n,7GMo~eKh-xnGwG/9EM(.C3:5H/<|W/hT[7[dyC1Z)x.8Sw_{Iim	jdyyEzG{Ed\$}[l1<RpoJ4p|U` # }poG7U!gs{LFLlh1?6$Jd3$hGhKhKZ<G{-VEl'YS|7qP#I`%)yI=cC1:[MA{[m } 3Og{..O!nC]pkC)udy8qemF9q	}	iZOddeX{yAG9x\(V__+nlu]4%-5BEyG. qWs<[2m;rjIEMYBlM3O/9GDcs7N9M=NT!yia[_q}<~{l?u%p$!,oN|Y#yiksIzih{o[AhfwO{&AuFblg/C*74oO_udQi'dG96IkA8iLj[T\Qg	s#CQ]HONNUJu8&D{G+g^l#o}5+5,4:yjN~yNUM0%uq%@59 OQAU6GHm}<&RJ7xO=6%O3nG?le:ndw8fIYndM6l%=GgVocF|R4|#UV3r"|sVvrH|NMM.S"#Jlh7KOd+kZzy?p%oo0f1uyxVUyu*'N f/yKO8p)	=(>]{}x0%t{y;^
+9b	e>/91x#i4~N=tKGUqi^|g<y1a=/2xv8c:y<j{\	U#zSvC2_IC8t3C&=gU(wQn lur-vl#cbbz/\>4Wl^iozW|E-_^[YW{O.v5%>*vymxQ}vF
+[99:4O~}5%R_}<;*.)]Y1jp2UQjA\<+k#J|y;~{Q/pBM@N*Vio2xvn31_}B&4j9|Nh>:<W6M[uOSk?b]Hytv_hxyXF^eCzb?lK\p>fZ|0.pil~^;m93?=CNsmJc8Kr"{FbU? lEw0?/H2mGpf?J>Fhby8$Kep~uSy%	/8?}}mflqVn~W]/\r?Px?|pRg^:(=/>\[oW9M{,6F}:xa#;qsdmeZ(jwyPy?;s#l
+0m}t<8otBf]9:c8'bt|(nHQh"y.ZCByO#|q<.Y/8SV4s<_R+oHS>D|}\U x7{Xs|9zoO
+$
+p)WE~9+CSB&sx:lK{y|#y_MjtB4_@{]I|a>s6M^T^]mC<N^J2iv8|HrGd;mLTy@mr{yWQ0mZYNfNK8/y^6U!hsibkp/;q.%i{;$1y;u7Kc9/]j_K_Ut1No<O<Qo]G<VFnYO xgK	=/{OSgl^w/-H\58?v<#L:Ixtiw<G0G6$mP_Z%1F7|{4j/u\Rvqz/dPQGP???GOe<:<&+@t4bg3|xiIBG#$^87VcA_]Y*G9GbG^$ &Snd#yGoGz?v6v}h=_qaW+mvu5j8&MqcR^ew~~\doKzFf=w-msJBxrg'L,s}bG[;8g!C[E$f(/p_?ufy0Qn2H<w>;Oc;?)<hamw">?RU^oOrOCa_,7
+K7ylicuz-WwgawnTxnDaNn,<?:~X*_^Ge,[*6z>zO=u^+fl_qnsT|S;&M	N4[W\sloQ39]}_9q42'b<QGCxzv=0eo]/O^}ak/_wp/*oo_Y^{ucBC?QyFrO]s?GeMuv/sgW{|xMWXK~7L2mvs};\'-;9Pc@[4W|&As>zFKo~b/l=)i@I)s$.dHxIazcI=:Ob'1>RG#4I f"h'8@/-f_Qp?8t!e>22E^Aa\?^Bw/*ys&J}%m^Y~keP_b_5Bw=LI:i):O}Stx,tx/`szpuGar^U{UZhBkoE]nC{P>e?r|}aZqnZWV!ju1=w/Vo_*^-ZEkv"Qs?d5Z!dBsPNm;kZFu3J9{^NYa	cF}TA'*fUkXF=9:uS[9@$/g\q>XfL{y{sCWG}oP5	{>u5@\Ib"Xcd25sA;2&W5cy}|vVAYM'L~;aOLn%O1B#qo#<i]:{K\sf*1jDn3y>$muv^gB	fY,isDIhKV$8s2{POOW-`itp}?}^(\7NO9zG&(;x,_}*htH[r%mT5Q5tA3;]!76`sMg{z~ksRWMEsORyG:z^3SF:n?[3Zl)Wib_FwakmH/;#bXQby/vqw_0N=hwnH1J5rwD\5Nx5RM5~k:6s4j3rS2.WlxK'HeYp)l_s<K]I'yV6 CTZ$7=V*?y!Y<{{ Ou5|6.ri\M8$-wP J13a1)M`h2#y?a;NuU!G]9ooOYg`9'yvX939F]=ylEzvMf1e/Gu~Nc{gkv t/jE QHAp#!j.Ag| N^P1Cli03Y <25]Mh_Y8]<>.q*x-;s]wYo]w<5ysO, 5ZhXwQR{BU_v,;Yrz^&mlZl&;y~x|xpmwlm=h0z-Fm]!FgE;n__'~A5j_Psqfkb9!'7C-4UR&rjn%c@vD)wGD;Ov0xc(}a^2mx<`g<W3!VylG,;.@d'mcp|1LQ|<g%TYQ|ybO#c?-e+(;#G_3u8OO |?-<yW[=w#2o&` 4q]];~*x|WG3V$&sx<(Q~|ahONwxIFT pRv4+ [q_-WbK:6 No Ujq8 >Ru.dL<o3#4gR7$^ S>-S~nkrZL>iMFZP#y<ty;@j>b)6H#^'Jq=lGrQ!HEf~F!U y;cq[nc9U-}V}	>V6[kwOaS1{yu}-ee&S96qoW]mh^jr~
+b:d`p-{TF;Bqkk.uazpF9{Im#<cqfr%GxCLue<i?ES~9kE.+PWY3({&d.JwbG}lCfy2):<5:mK4e=T\5nXdOl
+6m1F9>]M>j+ORJ!%KwqtHInKLRgxk 4hA60bzI}48uL#P7:6Pgxe}7v} G[lN+zC|nbxEDw:}N2,bM{Dy&D}#uy[<#QS{0I/U2dF.}7|=e]S|:;s6j]".%rk[/w5EO;-\k/vmZSw:y/V/S.G 5.	m qmx\!wKe"g/,=m}j
+i&_>O@Oxl{6Us,_FOgUYB5]XtU-Oo.{jy6u;$aQ*!	-0rLucMu?s~UAp\A|R[0z="J9*AiGDQ$x<=/H{R]sAMAJhX {x(0OteeoeeR6=rI.<yX:`E.Tfi,A2w2b}1g7CO:G.PRgsoi6:lL	e:K^yShz
+lJ;4s[yOQ(wl@iu-_gX}jo&e]YqvBEl*mr)f]t5uw5{os7l)]cclb.wZvH[aht6MrMuubVy)Gi(%
+610%CYimSN	XY[NK	6|be{zs7=M~~?c_y
+^g&LI!0JX<i7,s- b+_otRyUhb#eP9~iO~4>X'%	EOAZj <)zJl&l/	-:n>np(^zIwO{Ky?F$zo?S^v.n4#~H;{|v2}|7?!~B}>q_C}xG]P	Y6e0Q_7:N	u\7-e/Mx+qO?!~D;}?u8i/ AU6YeP=ptM?q~O6	u;`|?qBWLU
+1:!Djp	
+S/\{+BZsV8	Wm;GSUx2*=j
+w!\kxNRIWUx"v*p:^#\kxSqW*pW*pmW5!\kx*\ \kx$uoo	}A nvnSZGSs!^TK9Khbzp8rRS.>Oeqc:e^akxNV5WW!\kxvWTw*|8v*|^p:^Ez^ \kxvW*<]{]Bz^mSyW5pZp/wB1vd=0E7GIn7o<i!OPjZ`;=0z[|ihOlApII\: X"$]/_\7Q68Nw^V\+'OJ _>Pl6{5Sz]8vgl>wLe?*4mgNUt{w|vo\`[0_G#HUo^x)!h|g=?^xv<N5/~q{R+w-(FK+~+~g=kW"N1bk#+_6LL&}:LlVIy-"VH#x&qmk+"GSsc}>$*?%#~Ex!'~^M$t@md[|+^)z
+Q*QRc+o[kJrkUkC-|ex0v>}_KZQkah_52v_1tG/}i^+m/\xK_p}^\lW?4<'%-o2dS{)7=	[:ac7Mx2gb"OrT_EA}ZRcpBQpOyXQl.;l|OAhe.Zo:\5Y'hD[#C:l[g{W m&Xrye\1\Tb8+nt+,RR\/_VY&.^Z`y_vyjX![v"lKUV._<+~
+og>PmC=*.|<~S~#!~G ZK@K<RSyYnK;cjWn>'Z%("l5Fw|dXU&AAu^ScK;J,[[pk<T=b |yU{!^9\7#w(zsy+W;nS43}OXV>x8(o`qSkZ-|zcG=Km2!'[0_%|0H>1/}8|Tp\ry\wozy!i@OMw#ZZ;U{suM9/L#h;StK|m\xz'67Bpwx(6y(wr$13;^hmg<9O/|7&5_qis=uxz
+=n-?|{;_&_R#i5xGpveonm[}[Wt_(Ok7xV>I$/|_G}t~(}}7GxU/Z<tIJo#wU_1vT0oeq^mvyj?H~7Osl?]|?{cEC~MM2|.?7s\ga?QlEE@'h$OR1v2 QF'KrDYNr#ScU~c wGK,~X.0ac~(C}
+,{B_$] S2<=]Gmw2(x>+?+|6)1<7lbe#-v[My7NYOH6%`Uy/Q?oW?bu*}7`TX	w%KJ -Qg#|%uG~.ZW3Z-+"&X9}(,U^(/p5i>& ? A.~/
+>pz?J_IGMr+UQnl"~YfVZ~Y"UHo7xaIO Ool?^deK,g}*/[*+3s.Xr9K,Ypmse+eWJbK.dY-Y|X0mTZu/\ ?.^,/Y|s}9+_T~S|yf&m,+`k~	"ZmPK!__p/= H/?G*ffUYYKMpT-_`Z4b9*Z|Yy@%si=@M}	,XPx%*|:y-e;GIbQrtdeoP@J^peK|/~%b_,a(_Bseu1#,)[upJVE,oSW/X`yKhzGM*MX2fwZ1>	lV=[R.r\Qs7b>-Q-*MbYtY gB9sI~gzwGVYu[O{rrUmT}^/*rP}Gr+r(r?UZEgtvAHb`>Wq{xul		[;!qgAi0dVyg{D0h	ysO]mg{iG*d2-}"m=N f\MDr /CxvD\=twGD)H{^DuPlWq[{r^$Hf&jCBD*xN)gS,w hn.5m/r|y"0@?)+yg!G;Gl].i@sE>37wMhT7mMz=#fi)xwY-sv{z;GF6v4wgPk@u_HVg{
+PG/Sq@._yLu.nX~}6;NAz{pX_F
+PW[wEC2;mxvkbH<[Fx77=3}OK3gx>>bE'69m{o!NE y~{$@k!A!gW. wx;!A{] WC(#Nx^D}yO L'N9<G"},yh&1];nw;{E2V>${=/`<=1m23#|Dx5!IOLRk/E?TzH}MgP]gi5Mx<ykN0/P}<uNVZ15JL-qa:>}wQ>(::ZhP4zMYcjEaGfN2")8l':5n	i]{f7b[	s&jWDS63)L{ OIfyfSuNO 	`8.}?(-S-pki}gyY gGSwgW:Alvle{ofslln5&fJ;1	b\UyqV#vD.Rx_(=^g?M4i*Ucm|Il:#;NhBLu]@avVDyouG9m?)OS'kF$kvKu9N;O=+(No1M{w;#OI>}"*Kl/m:u?r>xStY( s5}eS$GZ;nWFxo0]In!c vw= +[CNRmuG`~/P%X|5DKFpzzh NE`@F~m.FS>kp6UImzXI1 }~{4BfaRgmev`/A]giSxG=2m$t`4V[OSg^9@vPiwhec_Kt4%))z<jwIZ$K9|hx-v+	#g:`B]o)+<ig
+\wb<;NyM=|{gcib*W#/qKz"oGZbE|<6o:WOl>AN(Uah
+=ejy\Nv9h/':w3i7t2{bWE<WG:#=eY+SS$O{*FVTGH{;V]97zW !LMZ@qR'ygRen:e3k??)m;nIh/]!p=udx%?VoKA7}zXJlw~'Fv,<O8MZ)
+hz=Tm1-q'26C.yc$({RvR@_woSgRH~mTP<xm
+mEzI6=Wh+"acx=^x=6O:[Z.R.+4co&bWH,W-E9(WMIvqR;#'eD)1Yl1r^&]VYI?XD0nP{>]ut25OYm5mI?lp!i
+Wx[-AIk~<AVJEe<hPE!cO%'KYIG,&Ks-Nr)a|v1_x5!6*Z6zI4_|Qr9H_lZ<$)#,||1>LqAE |=ui79RF{iA};~=m6(>xN\S:$!:#N)+a};t~k2ZcP^=@q=bw<~@M,Xz-.iki8KsZFM}a/FTS8D^^1L:* cOSG)m=kc!c|YY97:{j2nOuml7U3tzl9]~{lyxkI|;.}	<1md+=>z>;Y}X$,3TG%H]4OBjuX/e
+L9h
+1&qgWSmUWwyU9j:*>!m^^2{[tTp~p<FGrQo;-QMMrXbG[Koa#!=	iAG ?6rQH|<B8bi>_FnQEMhx;e?F %Fq(;h
+p"m#_IEwncnZN9?-'fT="?GywvX}Xoa]5_?t4b\|C9j3F/FY?..B^v26-V6"5Rrc	[I|Ok\81ZFa*s^}`p`zx_Z&GEisILwBw1v7vv5^GjDm(tp}'Vs:6nHNQ,af4zR-m3y5Q]cu0<X}*oT9fyRs&FvDv?DyyDRVuV=(N<^Ax8eq!VeOp\'cim	Gq@s{ZJk2z|2wS+<s9.]b4-s<awtEY])w9NvoJ0?iZ_?B!EVuvzL{#OXE^]26Iik|cVE}gE)7xy~YsZXc"EW(WsmHR6~9HM(m%?YEO]+6#-f;<n8wu$KCn\I"*m(p{nYXiYbI#IG$5>%y4e5i~1x)+s4sui@V\bYmKYZH,=qJ7)	:8xV&|}~LGzJviL#Y+'mC,&VUt3uGUN g]f\MA):<YFzM:eWa<QTFV@-e}[8g
+E12Iv,sdnC(3P?v?r_CxwWz \~3
+	vyGX7GnAY]"WDCI&WaWm=gRcL~&C,wLcz?]\N2;|BsL,KZgngsnk!p<h2sjml~IpK2O+6GttG|/?v&ERx=q$g;ewf}b'%vH<|Dw9lk# \#mj3WK.]7>RsHz YC2
+z|%2UO*VvM-)8=H\`{Q/=@,DA>
+YNofR~h$9JrGvK+;q>ynr*9ro!fGhdUOZ87nI@GM}\:{]MCFw!M,a?CO'syC)Q;Q5/_o~qk{nS:&srwg3nwDN` ]z.)m5);&hety%:mdp
++Nkk=PVMy` HtusS=q
+zR~!yW] utykIj{&l</&4&o5X@-6ni<9|i^sf'!RS?!f
+Yo;KH;sZ |ID&|=AxoT??}5ug~o1)OuE"O	RsW3Fd!L|s,CyxQtG
+8-S	V7n2wWd %933gW^.@r-ff-@n~n._}~b6?>+3 @n ((:*UZH$l].+:e]3:n|97Bss<9<-y=p4=/gks}rUqSNk.{=DvA=hZx{HwYo|}&GtRmB^)A_BW	:jRqWF)Rgt?.koE>DDxyY;
+{^&*&M{er-74u@o>Ik$UmZ;<sZ|ov}sZ{5*m5ZZg?39%py-yC/Tj'`T]o5?)zw3}iHB&<*)q9n	Cq .+9{c";L!c[M5_fu po8o
+Joz>2 N
+s[c*	G!yh-6[h~>@hN5.S>i"/0x83(}Atl0~}-S!*GW)sYV-g!;h,m1{6%0?Wv8o_=A7iNgU>b1I.\:geCk/Ff|r!-%TX?~rIlr/D7rV.4yh~?XKt%Ziv\*W}RL}Agm/8]k1O4?M.|#"M|h^PIuiuD4sQGhs.}`:h|25q7ODs,gi'a09"89&L
+ZkZ%:{Oqc&L~4'6=Q'q\uit{*8f
+chBVa0A'QXkS#=Md28ikR5qZm9o'2}mfunK[boNM8(OTPXG7MFzK!jb?T	EiXy&<[tri]FY!gCkr?ZCwJDnQ2?w/}3&N.Te_4}#Mlni@n\c/se=j]I5Fk`^FLv.YuUo2.U\fP^e|ukGut<ZEWTW'zeYLl=z/V(
+M7[.9(<hw.5P-!iVZowk2|_9rI7LFsq&_d1>1~G7[X7
+![g/Fdqw3FgS=~oPs8
+	I_lK[	ni9yK97aeOaXhSTe[&7hPo{}Sm;w|U7MT/{F]90#%Gh$|y+Ik|8b*Lf [gq3}fsb8.+:#KKQ9t"\snj7+1_O5|	YEZuzFk'u{qvH<$>nswuRGa.vum0Kc6XYpwb;]t8@"#HxxYE<Jrh]^GW.>LP;`)shXm;f]2hG{=h6`yu?c>nXMe9+p]8&)tT?nvS!yN9BI6"=}w{*Fyv c&dp6VNkXok\Xb}[JkvZ	94)(T{p)MH\g>
+3qYg9ox<%w	]r?A<6	}{	]|/cQ	=+Z99]o5ZE+nW?sA]T6jNlV>^17KQ(@S`i&6~>:B	?r}7c4@s,Yxy~te<1;!y@mX\_<cP|<`S9/x{|s1W^%AxO"DO>F]Bdo9\CvZEL9+Vb	\(.I@MFP~nd={tv
+n6O-iw*}L~C|Zon3FvD}b^;}N	OgP<1}hIJw	0I,'z!VfqGx~7>mfc<H<V||cQWc'U58w*M /y)_G{s?1~I2#1</]u}n>AT&9_k3&"{9=O[nzy(NE8>z>|?I`OYyHSmEa?oE~_{hB~eh7@n'o0esMs$_p&`py[z[99v!'KUT6%MIf4CM`M+h$H=;C`	=E:Mq~xw#zZ%z6<Mr!J;\Ke:i,/o=[6!4|'PBq-Etn%`/mq&R#T}nsO16Cb;zg"`<n*Ng;rT1m~8w1.:c^ovOJ|CMp9
+8?}+oUdR^%S'Y~'>ds{i'wi3r/{y;)QJ A&%P<}.u6Pz9%SNq)2q?~v|SgQ}aMD4uvWXS\t`g{uU_~5zoTh#i8w~M-#mX+n
+d/vTnZR]<ogNRLh\-O71}=,-Zh;L.lL.EILMI`w -l'Y+[z|??$0.[{<\xo&xwox5;@DVR5
+.4%3w(\1/AxM8sj6Q^k"]_]v*:N:nuMzyvw'c8K7JLo|tsGKWI@>E[RKB2"vuJ?IK-t=O|Cg5;xLKNL_)t0Gi5%D'J(h<Ha{.js?}fs>	x.>0?cB.nv~6f6e`8y,%aXYwRD<\w7aNxh\X,dgo0F~7,h~LN'\B]>X]hcg1Vq9S\lOf7=7eMAO#yhtZnWBs"=	i^s.G
+P+#:To+4:y]m/"ry3"+psF_<~M3z3Y*0K"[S~qP}U[[~	xXrsVh-/1K t{>~WhgO}{835Mpl.
+4Y}sgw=Mf[Zvz<~:eBAF^|/f-?1!,+vnf#/}@y;F?aZ~rk86vN7TF/QYq^9KA!O@6+	Zb=5}k_;~Os:~O\8Ns8CbANmar';K: K8k=B}+tU\.vJdrOL=K^m|:D;P)"J@ggzm0KU l]lusA[$bx[>k`Cym	%k]LY3D]l@oeE;sbG}tvHhz)N+SeU&FWcnv~3QwJgX{h2PRu/;/Z.6w;=v@wkq@	G;{:&}QdE.OT)t~YMf9da@aQ1Qa/@WaL|sW]ow$Ml =-<+ 2UX9^;	9?t}k3@vl| Nr>l3sh:iF3gR]H5sM@N! >CC3zSq~/>dZmZSHkr;xtN7xx'a|Px7W	?'G*u)>K)btaM;
+<3\0z9_kM_^cJ_{s<ih=a/]W?I[TU[[UWkU`jxu+Wk$=7l$5.Y>ajnvu7x2u.^[Trpz-pf.UTzjCV#.M[L={YTU`n6e=iAVkTa)	N^Af/_VzIi
+-^Qz015iua^3$Cju%ZxyMU} e&,^haQ4:\]Gf*5jKam95j+W-jXELLo\2N~%<lNj9jMT2
+&+~U8\
+zVw[?4{T;33+txY%mU=k4\We5W=eMis%X\:`mS;end='#-J#_nZ]Ow5U5+ySWvUMOuZuuU1<UO[A&xa!,v']1(S5XV\-ZVFyYH/c[6l60M[VS=aymXN"t_1}wzs/s	U5]]]]]]]]]]]]]~EW	O(?L5`5+	UWn8L`=61W`wr;G`YS!gj
+?p/#tN cX>0,$1 	A~0/5	\E;XEa0rHlL9
+_MCzL^mK@c}x3xY(.-Hx}'.l<;X~_\}Y}r4]	<r1>NX+U>O~iaphzY~'unDpewm]/,3.	gkvv?}O{;&]UZ"ru/^{Q;X#qv.^(s'?w7#*VH%n-,=HK_apN|!!}XRk0?X}x7w_Dd,_N+/V/GUcLAJ&vX%+tXpw+(X}KL,+J&\T^5uS%xAs2lX2nebeb=baNB|MeL,OlX2,]j&v05z5K5pWfb[>fbCbS3'fbW36?R3?S3gagbSkr|=y{f733c&=Xn=Tudb^,5L1wdbiXNJv#Ll#Lsdbvdb83Q4U|)55,p@M$qezW0mKEpmfjuR%p-s}SZps]0wYVT'2/w	\F\?0`B^xe?h.x)^]:e ,g8~'x9b&eei\~?{q:N&lK XoLV9ADfgH21
+.E44fJlK 1- >1G3QgYDMEfoRt~k
+~SJgN8}i12J-U d2|zZe>TD~4ejE)<`n1?nL)do5c88Hc~*Kyaegb`?YkK~eWk>8XE3=2jzciCoZ6<3Vf~:}u*[=1+|](c{3um}Y} Yt-}[9Z}cVUY>r9YcE=@YWgjjyeDUYK,
+fD/j=NSrVV-o"rh)3WQON1\Ru<\Z_KMmwS!Bn{b}H%;Kr[
+=+r6	.>q<3Qf>QI5Ua	oB}t[LZ
+Wgs;fJsqqw3U{? '"a#N>>KzGYmSMTLGAGd]`#,pt?lzc7N#7Oo3|iY_}4n_#\V6bIke.C=jV6-KBn^CU;fCc?1^EqoqQ)q+}{m}KvPI`Za
+6,-B\B[l7qoTt6]5=C|`'PcB6%h-vE;-Iuni3N60} =S~1Mwsw4v-daNac_+$RCN%tmo%P9(k=Fe7TO6c8#V</"<?K(Fp}nqTmtrP')).jRc=l@z<-\U>A;i'i'tcZ6pd>Ku:T. y]KisPrMQb,""7%)Ml*T>T^LvQ|r	:lg$PD<zm]\8*tfOg]'2*KMT}+k;>rOR"'BW]4Ht}SGpm
+yfo@_	7hUr|;.Vgi>xw&yD7KtJw&|u`3+'IcT@I8:/-Lw.)`7NCh|)&|zg3dFGeu-_(.w	/w{SFdU.z\ei"nt.<8wY:{Ch`g:v 07ho&"hid4m{$8)oHVoa:)m'/y#EtFj@1|L<u24$#Q
+LjNaki)9'3SPa`k)[[*P5IaC	>)=w`6nW@`b76q?:l:C\vjMMID*M-pk"ULU-]A>k*hO<x[o"Y-#qAkm>wo+q<mD' Fx2On3
+:}8iqm]9.;"q2\1osSF
+<uPh8n{^*1C-:N\i`-;0>i'6Jt8_RhA{T|*tvO~m0>;),fTbQ7%Tn&BbnqzL|upKU6__7:pswR1 Jog~KQH'tAniY96G9x-%e%
+Y-a{4qQw>|h=Ph}wb4>Tm0"&.)qKY+Nw\:|in7oHo4n'l?KgIkR^% tt"E^=VPv{ F!KyzW8Gwt9T?SXv1s|a9I(c9Kk6p>S?'%jjtQDx4q}`cYG|@7>DceKgOHtDC9h[I{KH5Q)S"i"E:vrF	 mPx@^PN|Gma<7|..]k6pSc_FKA FAN>t
+ch"w0zYqeSXO=po{s_**1 l&pI&w=c50s8B2PbAGH@D!Gg=q=Bk5?w^NB7O}xMEv =
+M.|f<oc'ZxHudVp+4>EI4ktST1Oe8Co{HcVBw ]t5G7CO0?oLl^d&G='SL}u2aWbrGG7>&=I{h:tVM*IW(G'&W*;@=`:LW<`p3d?<CG+`UvP2+11WiE\GC\4#jp/L}<B}}Rs?A]~f:t_&x ;{IC_nng{tZB3V|4m-i13A+GF`kQkKwwX93#:<JFtA*,EO|dpj"Gs{[w<G+l0O],S_;PT.}ea]o6liw`[c-~AZ=
+/Nnclb}*u+Sa~,B&*O(W	Bw
+	lpL0r	44&K(}	&Du ==@$AZwv?:~<}	(6+?p=guxF4'H}$Gh\3>@g Q&V]`gpS&3$z;K	<5G8D~;,'n>hdmJ.5=YL90i8l:1J_hb.;ppioCnKZpu'I5:"`)@L0(J{hK-85 <
+hc=sJU?5}=3{q8"N_)]D2\3|& | /v9=s|IpkA>>WMtrWP
+Gzq%MDNZP<V~Ux]A_4EqA^jSPWA	E+ c'hzyZ{T|_>
+_?&Jer%v
+c{k}6.!DPz)r`Gi'M	N5:?zc:9Wc*fp#Od]I4R8}Ruo}l[l}}Qiku1I[yK{Ox;.|fDph'N[O:_[cyu1B[h./91i+owsW+N_!O>/+KBF|>KB6z.
+Dz.
+]\7:[+ot+oe\7xz.
+m8z.
+KBF&\cS+Ew*Gh?6F%3vRin[71PSs=K3uFszenumSN>w}Y{_s>CpE5,]cXY'Z!*Q%bqV5s[z>Gs<oUPvuyq<fQ\0gn;=e1GlnQ9^J9sT[^yv;<sy6wvv}<%iq|xr3UsUzQN{<]69uQ>UyQr9v
+m>xn9~/=qQ~YGq;6ur|^PQ9CDrlN7U~q8\?%S]NzvFo<^r2wkR:<~=~K_=yRCT_.U<9T>FyC.;KQ*9>J:6{L04r hx~-c*38Q/Xxu~76>auuLu#V<V8gE:|su\
+rm7n]0q17+F#*tox7xc'C05g`STZDN;5T_uRk9v,1S=;yj?~rZ=~3],{H*nd~cWt}aW
+{Zx ]G_}NAo8z{\W[unZ?R[vd}+hwwW{G?~nVck9K5+FxMjTE7_<Gj6?I-=o3}o3s~?Gur`'oX.:iL 5LX(P,{&+!Ol,@NkR	xCLv];<|7e, T(_AxyCw{mb}v mg m3-=`;u5Q[::giZ|V=C3WldDcEM{Xl8Y@]m %#~L[fW%uPHJ)77[O(-\/74u8dIN6my_CK-ZP/OS
+;EdU'#s~1r5%S)FitX.tw#q2tc84oW%dy-$F:pFT8eHXn YyA}vb	C	%L.X!;v5^oIKo6b&#\_w
+;A?kg[nsmU{o<|%?kyq+|~aONoygLEA36~_MOk6<
+/ys=7ov(?#Mcz}p?|bO6JFK>(e}fv
+e_}i}Nq_Z(T`^I(7|~l?MpOZ:\\NVBn=;bygsN{i/py-= +
+s21X`&q)pq_~`$V{(paIKk>MuL]&Itdc
+_reKc_B:D=}_L2i{"+{>N0`k[yeZyAlvq+kj4
+LiU~pS_{ ,DGrsaVyCQ8(J.i5Hk:H\w>\ dy*=* U-Z	SS\FY^C7BxRSmkG^o=B,B=Xzkd](4&=jh/G_=Xd?.V,J|@<uD[5Yi^THEV]Z^V-_SR5W
+R_U[Qo3PR
+w8lUKQf]iIg'Qo%!f\Vv[l	vI,QzxUc}Vf[
+TX^>cn[>[ !.]ME-ntuIwtntgJwtC+y/JVKwtK7,>%nt.vJKNn^!}ItKt/E{Kk{KkGzh>yh8\7NOpi<pi> 7Ro;&Fp}i'{;i4,#eM|9%\Q?m CGz#//iFAC*no~#:su'S^RsQm't(Yt7'!' HxgCh.J|J_nJ,:p&o1/F~dZ-1I9~9=pWOpU-QPXt <7?nMw'\??}8vzl*=c^szMT\s!zemI!S9w~6.NaQGV9rB|iw_6'N hmXmC6>]o2h'\(!"oQe2[ v`?<<q(&/D}:
+/0\xsx~q,!Cn.m8h;{/s^kI!s`p]
+{5@ahxH/lE\N1ep}Y.ke5N/%9x#`g3dKqyd&<2Ao.O#Z52#={}2J<Ka$&'UNiQX^G?FvUFzX) 
+b<V00L8^Kn	q8ROaJd(ph\o
+7o*y7Ju&Qv;6=.|3"+Q4;+[9m@]!)?(fYhcE;j?2MY6V;R] /5g7Oo858_ZLNc)50KhR"h0*YF`9S@AOcSF$zw[D{t_^-|['&hMkq$i}.M?cDA#(X_'{ZT{e|[Z(humD+aMceiIv>w'#9 @CccyyW{[\=gWiYFiGb:-Q6rwN+ce:K*pc^R
+st0-5K^ei%TGM.i)EEt?},~/D])+Bwl2W2Q@2?Gh	h6@SRnyv9E>:h>=hwAE#?nW<y(yC y2v=J42	h/Q<;'I z+.*_V |x;p@t;~uP9`_e}4*
+S:BIu](P(qs^)S;"s A:b8Y5<D'hE[2|/'.{]>b|r+_D{eG4>3%`g4@M<J1_6^x#TB[e.H'2[O+$I0ei6ZnL)
+`d&vS7vcr=i2i=Qwe?cm{{{91^{<PJtk~g5^E|JO|CfvJ'Y&Y
+rx?{8.w}~\"`bxO1Gsgv0Ft>9i eca}'l6$kvDC4>ka>aO+gcZOzyG2/q4$Qm"VPK=C/(}5UXfl#gL^?frlMxO_XG$TaoM+xxV__;Fs=rc:CR<yStF$zr/8V,,~^{h}yU]/'/tf/Z	i4^A~t_aN'~Bnsrmg |L:E>y}f7\LY.=LPyo6ey_Q_SS5,r2?+G8X~wyl	Y~FG-B2~Y`a!:tev	N"m4&t-<U/z[_SvlK.'4]cb0f$/b=saix>ufEt%+9c_qm^.+5a[x3.kt^3&sa@,9?ul?5fL`Q_";qUkKs7Zx=n#YDcg^Fkq?R53e\a`-y|-+X'MWrC?j"C;:	4i;h^z8DPg72[sd>?0II6OZ8vmV7+ ]v(!e]%uCr&{!D2AU/HY"y@zN-ArItT=XM{\<o/i)KR?|jry,g&	`s#20l0 xs!q3Z>=2;C|n=T'`J6b:
+?vq)_e
+j_+j$xiSgyX:Cn_AdS1 S&7w~_J	C0(mS7o']f?LObRN+]*TZ72KZp<C4kz2U1e?T<X}V[9F[i:Yyh]{>ki>g9/8|9>g/e])+Ag\+sn	dkL\1!S&^MGgA,nwtZCW=E}g9d~CdlB_~^!8~c`2}~8a }l4Z/_S9B><b|Qs \Gz]{gsyt5r8S7Y%8	/UW&!UFQq
+6yT7q|#5uzZ)7+H)2}u2>B:C!}Sy]AC&@hVZll4ZS7W=K$Z.6'?_|pxG>Bv+V1<k~WE|1i``37Ar2k3V3MM3}dE[])y9&y?frf)m9u}@O _j?4f+'-|~& }[eSK],G*\n=sB|6rj1?t#/9p~cz91y3F{o9d\bZ&ni/#oP!tc=A2ZOq_4"T
+,=CZt<sRtsoH+==JV&K_UI<3|j*DTu1G~/evCLOm)YW~b7&_}RWE >ZaI7}^-qCJ\oj.]OVwC6~Eh#-c0e`TsOdo0FZ2\5,WF6yTty6qGJvU#s]ZxZk,|Ysx.<<*'h=uGn9chh|}\x`l~J^J9uY+ct+J>O@lO
+:~1U?Xk_=sp{\;|FWFv~q2Xga=;w;XyfA}sED%WR;]TX+.OG\wQ}+.Os{9sE2n_F\wQ}^jnP;]T(2jnnwS;]TpqsEu	}~=GV}rM,*7\,:TV_*-_,n{7lOD.Jd3Q
+ |^
+Ex$hTh\U=T4S8i#p>9B}"$(~r`8ZixttyQd8Y	_Q<X+RPxv|SACJ'3F*-C8(?	Y!-BM&~2]P|i.qclxab6\rzWx(oad1yKbQ);0S
+[@3M$	x p"v>udL'hmZ[ap@_g6|$gHiz^G>2g>zA+U}K=IU7^N)?T>MrU*SG*;4*T*L*Py  LJ?TPy?*?T6*}*ETVkZ5N*G|gP?P.-%Z8odEx=2i{|,qmp+(
+5Z!o)3yn(8pyh.}B+wy$:U.GBVfN-~*OH+\e	pE@Ih<0fSv	8Ge	y`Z%6i-m8Q|+uRm[[@h?J+]iv6/FnM1.2f`kK1lc6GqEm9ruqqmFFp}WxkmzTR/,OMc$eT4uX! F`F$1"b81#%tc"u8tCOv4pSH'b'VGj|!.jjk3YqFI"=hC~m$g:jv	hF4|Oyk@GM2IXq0}{uu8Q3J"a:,,V#*	nf*"&=WQ6`d2	OIw#z'qQ+H(lu]|7NNd&/Qk'1#Q&j|[1LhP-"b8q{8ib$peN$7w`#SSFQ 
+EqNDmx|5S,f2~jm^c:=$C8KB6B:K]^}$z"mN}3
+DO9>+)4'wstwtbt;>%cOW1O}1if4=JEl^1y.vukt/'l:%b{4S@YM9;xki@o!t*`_S5Km9]j"ZDk6lTZ-:hmFqd4?$R1 X!cd=DH)P<"dSH;Yk>mFmFc|/@,
+ )aBo!rrlJ1 *k%+ 	k)g1JCC_FY'G];<OF=`ThNA6Q$q9L9DD'~7tnjQ#<Sv7Y"+3-WfBoj$D!+"m:'3ip&:MfH7gLf)d*VSY-f^]WMg 1qs~i#I2x(F,91Slc|"ka-y
+LZo"DNs5&2XRNm-Qv"ecM_f MF?7;?
+x=)#M5=@m\$HkEm[4D(;jw[ZKZCvUebt*EUY`	X<o1ATK{eV"dj-i-B?NbxY1l>E
+O&x$cG:BH(n`Q[];hKJ;BYR%:]tF
+Z!V#}P`#V}gZFY'.{3<Eiw}N~IQK,F|}RK6zoR5t )w\oN$.#&l,<]cA5"+1\Z{Hj9| jD"3Cj6Mp(
+<<#uR'{7\L.Bx&Vs^c3skttA]u'}dC*Us89Q0ni=|Nh33Vgk7rL>gWFF;tMRb#\LPl8*QjqAN9 !_togB(NV,_CGL;}-kF&bN[( [7E'}$NN)FdU.@Eiu}rzfUbejLVf+9Yv{sp/pjHa	.HH8""32WNW/^E`_1Fwy	`!4s7*<-8`40:q|) ~X S2@p|@'w4,Dnu;(]z^ta4*W6G;Yy[/Aap p3,.8,yw'H
+7DBQJM@  '
+*Z,c!nE{Azqlb`5@hyH^]]5i(2g2BJ9[
+)mk&KKO %X@	&|8 e
+($;I>qsnYtmGk1udJ(M&Aq-C@(R	,htOv{gmW-VvrZBX!L[$0y
+eYL!SB:`l&{sk%a1vu=OlO4mo#}Q;0]c
+S+\tkTQ9#(uh%GM'T$nf]6wM?lB^rRZdTv@XQ8FL5dR[m<|OLinq(eB+@i:f$'|;) =P1VcO.t!Sb(xI+Z	4i9 ~Qa<.#,<E=YaC\s9Zb04bEnq MVA/oTyw UVaB1w:kkRL5Exsxe$ESJ>|Oao1~ro t3\lx}TqCI@g_O6QD9``:xU}K SXi<`p ew8r\oT*V&Zf%oF1W2  \B~!r@n]CzK>."H P,;nH@q3'.nwn&dpR"@8ZMhk 5d
+`a+\0Ci|Ax`UX+V+{JX@RftrCR?j!$N]C5q\wqecQXKaHq2^`5NC)(`AS- Gd7%G
+bCj[YGp6A.+[V460xB"S<*X8uyx@h
+L<C-Q(R3X#sT6	|#<*@'"gLV3h}7HIMUk& ()gm@(frzGR&X{D;h6{E= h?t3 Illm'O.L#a-Ibzd0P-'kBmJB(2SQX\M,x>#D.`po0Q%E1<JyVxsG?7 q42.s	XIxeX1j
+v}72D=d",k.yY6$>P*{O>#PVrNGZI|ACrI%HUAm)G^E;H\4r^QN=%(n[)jh.1,RRli5oJ!yuyvrqby9D^^a:*W<hj]{PbCk4B-d[Xp;"Cm	0*I{?dSE!';Jtdsl:FtEO77q# (
+maq^m&5fC6S5sQmhF]-l24ea,ia\Bf4-O%W($(yMdlR1'Nv0\cKW*;<yMP<}Nyi|l\e4^4,7v#LJ#}
+wEa0,Yk%vZgj#=w7vv}e%=BoX:KMPKOnXPA_YEJk|[C1B"9ro\D`5ky/M]og*lsN&{U-~
+!zDAL:I<Q>jgPohZOqh?8FtMJ)?:?i",/I1B@]>w biP^vUp;Ar}PQ_7[=g"}IuH5ym_\^d96^$ehT<??Dh SXhh2t)Y;!wE[D!hj~^~`}sEMw|^cw\0L<D !-.M&C
+vs#:!2xzxc3Buh?2]XYY{+[F7[M"9@GcJ^+(n26nHRKn\bHEr#=$TN;tqQm?8as	?@ B LCfX]*hHR!H6@A0Hlt-` hJDI'F7vpogE3?|eY6P$
+6wm,g	;[^ed~yo*a3AheKdJR[>k*:k
+;pNO?DBu`ImR"a-us}#u'gC	g'5BGN|jA9<wJ92~Z1d	c2o!HP2oNKxba>p	'`;Od^h.'yp
+PhY6J\PH5$"m/;	EbqG&RAE>zOnD9|ACERUy9JF/*D;x/36Mi.#i` `f04D?a{'zp`WIC&Eq\Rp+{sn	!Sp[\o2c  ?,Khep!$'[#^F*KH8e]/1*q>I)k^yRMyB4Y"CNYv+t+dt@d:$#7Pnj="A-U`LDOc%9EKMDi?C
+R1]$o}7bq?GqpMD`vR\V"m D@uPVG1AG~+%]qnv*8TI5^%KMki^xV4FV?6$O[wxIN.f EYOSgSdS0<m09^U{,Lb?wvDL  Kl{rt7Y	L58QK^ll5V[Y3rln=O_tf}S($mA B!qR`mru k',}d] ?L6SC@\BH#owenjvp
+0X-L/`kg
+&c*`n39>b<BE(\JDV]h3
+	aOl>T; zOv,L!p")+JRX@]K!USB2*DKOUKn$of"t4Ljj#-VMM4C,2oyc[vl*7+K)`VaWYMi\f%=a&s2dz^3C1*2
+U0+KaZyWZMjZT.hf_eHAxyjcCs@HVr"TV_Mkn+VWr>e2<|@1W+CL"ph}MMgU&IW`Y "$l*$
+%r\:f,e.s._DX]K3*"*J4^nqbj6[o#M+&l8 O112Df>'#dDbO\WJv{#I~TR](:!m;-)B/od0J+=]-*rmNxeD{f=P:["=&rgKROP1^"D86M?o?;ZL}YqM:z/0>G1Dn[aJ|eT{}@BN=!6v9 I<g0$y.kW,EH9 evOrcUfbed>6OeCN {+z-r'7?[l^&c;p,LN_kj"4mvVM'%hS9zV?c( fx EC^Ek &t>hbC;R&o8a7c}
+.r5YNA/'y7Wbm!RKKI=n}r~_qn\+"SNv6D1~wL;cqMJ}QJ:<#i.>-[)	xwONtvu6e):SY$yh@gE	/b.LwEoO:G}.~_e2x_~/mgAofJw!a^?_wA;~]9y@,	_||a|RyV).<{w3^)Ud~k>xSrU<Mxf}<<[SmQ?_H_;5Y|SC?_y[hx?&;~).=;m-? sa +WP(>c|@tUW"JR`S1ES>u%V
+|d}?O?TP	cJ\	J (od_9kB;JA*?	:?{_eq;oI%pjPE]Vl$l`%AZrbEbRe.o9(@?3ov@sy3<30a|ge^? `~0|E}a$Pxe?:)/bi_/"^\cO.&{aaoa>~qRvS_f Q1ba9{/fRqE,l.Ve O9RZLiTSN1gAMXpZ13$* q@,ee@)s
+>%gE?>Y	`1*	DH}j)BeSBfZT2By$sj.8W_ba!t*5#EHXT-3EpDf9|\6[[ jp(qTF]5xkQPmLR5.]WpY8%Mg)^?P|;KB}&#4x&I;LC&loI[>M41Ni&"0ib0GM41HcMa<&41Q)IIMLXhb^@ML@iy-441 7f9MLVB541aZG41	,mI&hmx{=']?'1$Zs$]?uN^ykxw7`>N
+2N^c;fhq^g-#\e<<C\lAf.0`{X#Fp'x1f[xo43^Nxs<)@@#[idV';ll>T~0d-gbJlp#|3@\ES:~8`lt|+G4]z@R#2MCW;"g'@6h|
+u/f)`V(>I_D;-qqhVgKxe=zIdx["UpWX:<|xI])E\,N8 Gl5fs[{!_{Ocv5>9f1mI/t]4LOba1L%v]0;f; a n<GNELe9F1pEmQNl`Xx#c'x2-q|/q_^vqXGFAO8Xt\ngTzq"7/A]O(|4|vZda?1
+n=NSes&*bOnfWN8x5h1;Vs c!V|qc}f~a37oc_hFl(f7yYBHq|a|bekqn6I3!F(D^rd-9)iWp69X/_2|t.whz*pK"?liA^"z.q=@x;Kig\g_w6D=V4&K{%sl}4G.^v
+c,F]Ci\8	(*y&[pcNscc#^%{,[EUTF{U
+5X@;x!57yF&pqp7pLl69PLES:ML.*_+W0E[ a?^G:[`\v3K,I|GucbJvvY>b95%1h3h_j{N_`oB_H=Z:noigh%Zpl/'O6`#xp2q fntD	<Y1[U4lc^86$($ M&yC+oCBg |Y\0oJS&Mbys/a)8PB['{j'?ygjI	qK:,sZ^x:_y;/@hC?s#=h@-c}][N +RoXAu7lK`utRR,O4jYla}1nJLnot"_NJI;528erX"o<f!L8l-i^U	9O_xEKI8@u_/f3=H*S|Pvf	73Th4^X4U_RAmG3TyEq}ie\r}T2T;q}_|wy`b[M[j\(N'dO:^iHGNTg		_3T.K5|lyO=6xFz|y>QXpXcilWgb,|2CkVO'c+}(|W|>%Vat?!$#oAnF_x/9Z!cNeo9!n)8^yi J/s1_G>zEAKo}>Hc]4_(S}9S9o9p=}ZO;=Ck\&2~5LxX~+:l4s8==c+(*< kZ{9hkc<0^cEKUL&NSQzSS>PM!VXob'm5_gRQQoCsXyRlU6_U.>PvCp[Apnm5$Wq.Mz)&nZ<wGs}5FUKzz8[;[rTziyS$r!9hw:7v!"GLpE`/D<6YW!l3l//O9k/SN[Wsv!m&?l+T$?A#4K"?(ot<rm	^m
+|+M&k~s9>.nc <nq^4w9wncavup9 k9 ^&1}>7
+ec6,n5hgiw80(w44:EcODkM.F
+|Q>VXW-mc=8.6bbyGSc2^WW;k"}U0
+kUr	`mY5QG^S,z@\Zhc!Pm(1~YN_8ei%LCZam	=a
+B}xOzB_e2C~.QuZW:W^Xuy88y7^Kv!<#"QFt>O?8_F}V]m;Mc0Ot!}U}[[w.b{A;W!|c$4m#rQk>+oH!Gy'{dok0G/qD`}o;ir^K~~9BG\|
+'mX(f.M3l49AWH{XA3 j_v|Qf98dc &X6nr{"oBTk#U5""!X.O&dy3z^8K>qIy0>~	o!K4&n8"Hux,<4=1]76A'Cv:]_s\dw)bJ;[yHH\u
+/e5>=.C|2m1c/ouwtzOut=F<~g78y\78[ujw]osi>N^;7?ph|$<m;?x<)*rt	oBm,`y`?{'~c~y-vgOo`q55h55hbY9Of6n(
+>d2gWN:593XWn/+GG >Br`U$N,/b9UC{SQl!9vi6Y7 H>7`#2`0o^^vTYq-Wk+Kr{ }_XG7wdsi_xbe[[X $BMmhG;U=kngd4Pw4Wy]Pl~a|VR'<9/%Y5U_gf28nF,D;Qy<_hymc]Y=e	W0\wi o? >.j+=1BgNK7|2yzs_nm;G,Pf,_>id9t<v<CQfwo?i[>zY,on`Z$O#B62TSGU24hO<g8MYg+8f\4={r]s~=- g;/p Ha?"f'x~N95h|h6?|tuvWr<:I~opw5/EyYTsem_u#.a6|8YG-;@?Lq\Pc }G4ppi0tF_puB_xW^*?McN;9!^ye#1|Wu@NOx)Y#;AM07fqwl.9Oc]~.*F>QzNg8Fj%zq<V0r1w{ZzZgih^u{+9qH{=mKsGOP{O<H_<=9Gy=}e0G"<9s/gkL_SB3-,k3dx*/F]c)#FTU.I@#_3N>1j|E*	QR|,+HK(AGeu_^Pr=pM`D#SE	
+Vz5N]=5BG``n4!WSteC.rP%?O>Z'XrDQnc p0B(q556g}U+ua"8u@Qy8YJ^v[Pr-7|aB_4^zTMu`te*wRw4*Quf+ig/%TQBA0J/).Bu1IbnB
+WsUIJT,SeW[YWn^
+R4S$z4k4ER!P}MhQ+&|*(RTi	YeQr3Wij5="O~EO=p)6Owz(t9j+j--O~>}'O~XPr}tP^~o=v~%= MGr0wCxe[8-
+>\qw_v(}>woBI	LtWCEse`Xi^[YOk95uuT%4	#G_="QYO3M"3k|i|ku^zUvAp#sl1RJU{YZ1I z?x#+\S6v=
+yN$=k9b<Gyj]w#qEJG%JBY2{yKwrI<M |/vg7^oxU1ec]i}*=UlkJ: `,CN7#}xo&=9o7nEWL2dZ2GNwP2G9Wu\C|Wwz{u^d(9&l#}}[am/z]JoK<3^`]pvjse<hE\WrTL<L7oS%G*eTP<W4|T<]uoC}|-HyJ+U)GYJ|\~^y(Oc.6)52z)P&|WeqP2r)k.&<OGyd~Hqd;&|=oao4k3`ba9i0_Jy+F?\ldb6,B3m>l~#6|{/07e?5}!+'>`'<E|a>1_HX9UJe=JD{DN(pSF,H"RELEmS2S3k"Pb_#DtS5%-_P-kwI'O$y=O$dS2IyJ&hyJ6<%+O&9dS2I$cA|xoQd|% _$dhWI+$`ARd+$g!lJf[xo43^nQ^l2raah!.63,]fW~~t/AfEX.SfM@.9f "3F=;Ov;3{p2=o_XevhJTFOLwi;=x[7r%??/F=aVg{$&TU].",)B\y[V'^ZSNluW7Pw*s},7 W \]:m']1{G/]$ra<<d%!1UNYfWFGcZfsw~Gt(_;e<,l;=&\,? _w,m1g eg of$ I.l]&c1{P3jtf>
+^98;[8;x?\N+]G:]OO)Ay+I4$1Nh?vT%o{PQ}q$V;im/cScPm+tkebMY+FBaFMtA=1=[;GfZ&a]@ydO~YgcZ7bcOp\ 7b}-nwmO#2vVzIF?=(r0\c> Oq/x%/#]mU5|P~T];Nb|],K>}"n)qW2.a~l-Q_hEVI0mp ng3Ec=<6~!v9'N5%<	mlNtqeK&_OPBrY{F>nTe5wAQ3[0&]r0a*!n7n,9|]^|j|%8~xyS]+azW*_[S-Oy5L] 17$6ZtD;_u_^sI8w|}R8r^e]Bi79g6:NMU9Sr +$^[?rR_=/"
+;1>ygP(s;quSZy+@u%ELZ(,GRCW->uE+85j-T%bhCQ\ o4u^(*G{+u&Ny35eT+9\ep}G&#gP>8}E;jSgP	Y)3]bu'gCwlw?b{_QosGFjWv6'gC=z=^Z)"u*=l? L;<Z2{!}!3gC\>y6~6D~b\<<fRclxl;lhWYc>yLEU_1U~ybeyL3c%.8/a,cuIuN0NuG}	{@	c#@^lw~j{q#3}}	L]	'N_B sKpu%1|uy8ru%|p6#gZtC$isnv
+h2k13,u'-MA]m4`-?:L,wSBXng]/Xu<Zu<:XN4aM	apx1[C_	]}MKi[Dozph`|R:x}ztx"7f[L:xgh_}|m)	_zp*zp8<Zu:*zthu:O<i@0:$L`t(ztSO:<`S5u2PEUah`n|/sfMls@jq:KD%FKYbS:K\^WuD!+QgKbD7xDn,QgJuvDn-Q(m%,qG:KYw3=%J%J`_:[L%lD-.Qg]%JXo@9rPxJ~oo]K~|fps(Uz*=JJAT9(*UzKqJ>&z30ca	k{xVl8nppgp'p8h8`7`>v(05=xo67ub~3vww.kv?ox_W[@z-zE?qS~
+b&CeSrv/DEkE"i|>pe)]yw}Wz12UfeVi0c6LWK=[-HNeM22+MO='Ba|<#6!<eZDd+sQQ/T_'ogJ+ik)yLNO|J*B-Wgk{S2	>u%|`PyYO;pve@E<P7yZW3g5&MY=og[I%(SgPGJOL3)LS|Uk"'gUh7T?S2ZV}eDNufxD)j$r=]u^0d4"4>\_*Qt)0Pci#-?Faiz1}zH'RI v7~f7o*}NzEGdy<=nKT8 
+qr;[_S&VuVz}.3g`~>dSv<&YgrR1CYoq!BEo?dxBY<#YAI!	_O0)u{yHqlnuJxe*!d'f2Ep3ZIYz.)}3=dF#N!}q(#Oy3R|.6sWNfSI/BQrXf+{'X7JR.5cfs3fIC[I9PwFCQvJ>ophoZmry{	iM'3QDye7i-rv=RO}3id)yPGiImf>S<1}`a}n<-!J[WQ|Yrxdgg?PF	%O?#yt;B9R*dlKouTrVqs#m(YM_ei7{eA4"6+\fC*llTI]orK[.^
+*>kP]3[}Z)R22}oq{o<?8a)*(j*[zxiR\6~"K>,(Z	 Q1l}w+7jxwRp<<B`aY>Q+T{4y?2\bt?+e*,`:m2\(q5<SL76z-v65|MXe~6CXOUk^Y[OWk}a;z-k_{fm/pZ},nZO6?yRi1L`6a%FF~RcY|-S7.`cV{L^.~H/i_|>'{e</r\j~^wzKo=<^RgO_TQqKwxo_}e5/5J^*Kz~E~RiK'8/b{*}l*.@xQqRMk<|KR|v<w=w~9*]{ ^R</5a ^K?/U>/=pRg9Kk?^<K:xQMCzAkT3URmP^*x{$/U[RIc8y^Uy'/UYVERa<`^"QK~w2TO(^#g
+`T2RT%gARYz/UY/3TpRYUKuby|R	?^*pE\
+^wK^^/B</
+w?^WX^*u`TR=-k@^UjCw`^*{'?v</bux2oy0woUj+r0*YQ_RK5jKK5;8/R74/2.B^I>yixv/~BC3jozTEY8>xf@OIg}y&M#MT(SY|/|TCMCzx/Kfyn9K%xR]}Ay^/My ^*WgKz:w/]]yr*`x~YWz0^T{xy*'rS`^TU8/.//U<!RoyR}Go/U[:JRKlER}IcKK534^{:}yP/.Z^[;=KHK530/Tnr#0/>^YRuu%^ynKuS\R|9StzKKwJW!%=2~ ^uy:Omg}S&f`^//UM?BKU!g3#0/zRRYTK5KB]o T1fR/sPxX~Q{G!xtlV/1EKW&&,OIXKT,4 W,X!ty?/fT	a3QDN5H''Tdrrme9^.)Q6LD"IAV3=WO0d!T!e% 3.D<dJ=DHzX)j*"_VE3+P3lJpmOVkJKC&NsOeAHt&Kq_I,z;a+}vA;jx-i3fg_sks{ULyZ)Ztin]Q0=P'
+?jj-4|Ha_ATicHHT p!8v}Q`jQ.Xb'U|v+tCNYEUH?|\+-7i!8Q	c8aU	&Bq;B`N'CY k4M8	c84{: &p-h1$FNN=O<$wpjYipJ,J./p
+7/~HrhNCXer=`8[+XhO(,Q1|#K_Wayv$Py|
+c.+,^%#T>eY+X9P9| _PY%\Pjt^h]\b} /XYn@Pq8/.Nu?mB:k>*@_v8p}A=2Un8K%cAQ2heKyXu}UDM8'%i'=5GxP]Q -s&n}7t&(=Cu|p`-^9a%U+PqlY^sp!B  &`as]i,w*[`cX{bMq00VfA+4e}?K4ix_Zb?zx:f4gpm=p[F_ong
+3}L> R17_Iio'ndz7I =+/ XRGrE@gdu3gLG3}*Wt`<1 5wMqo#RUatFV/Rx<SqL_KKd:-wZ
+OO3`39OQx93,W3-r5L>{< e6_F52v
+SY@z.,bW/h4wzK&~33Fz2~iL,kt%1rL@n'LA`aY?LKO3!
+~	{01u,1?>ot%1=d`g)?3/f?7A,~/9;P:GSL2>L(Q~~+6~? agBSx+t
+K$O.Lt)o-Ym30W^yy(Yy@=S0q7*U4)>g~n9EZY%<Jei)D}5
+69zYUETDn@b]XrJ
+dRKC< R4MeBM9=S|	*QG/1z*RWZIKpJ1'E}iS.JOKvW.J%^]baKFAK]4%Kc\4%M.8%qL$~L/sIx/._..gx xY.gxf3]x1-vISKCZ3pI<%qM+]>..o%Mk>pv$.s%qN]%M_sI\}.k'Z]7|O8|:4	tnO@JSAq7OpO(4?>cgP	>tY?lj%?~>?!>!?*jjt7/o_L'KR'~AN8TH?/@!29LgL&Oar,p&{rO333 15L36&[lfrd&'293<Lfrvgi&`q&ca&`>&70y7w2v&W2y=2dLbr:SD&3y&09Lbr8=|'||LLaL^L1d3T&'39L9m}}'gjs9S7_Yh_ a;]d#7-o+7"g	w
+5^Ei[p=,O=a3WK;F0i9Va)Sa|s1$-NFR=m/FJTGk)
+WKjD|]e2Fqq'mqN@';w&V6(,Ifa=Ya7m6+$x~QSum~bw1m"'kv q^c0(Gw<U5|*l2(a0Plw6)$j:*t	_7
+v1qveZG|q9*)Wo */]=SXbM3	e-*KwXjk-[Co'(F&96<vN,{l`UReWn3J`dkeLc	r`gpxujd|rcuUeQ]wN;-uo<Jk|%Bm2-[wEM4NF0LZW8{qR:s>L{u)gW9jFac*`GE/60V!e?99sDMEh+Z>Os!LGY=DV
+l3pRX
+7f[!'n3*iLGCim%j2%66uF+\yt8j_?9ZVZP'E}S;9Wb'S>St-jQ3;9O_;Xz15?7c
+NV`U9s*07k5%U9kXSb[`8_g:^p7/Ib'9.xQ[Ndv(\mx+fdJS|Po'L[;{|321m[zpMq=FGC-UNp<8uv)uJo:8P6]}3*l'[D/0Nv83E*g4KDyW6U%E]rA+"<$N1m{bq^b4]T-:'L]M^x=J_
+m)NS>i7m}{>bwVgFs#U1f7F;j  CA]>yLm1u#*~pb(p^qA?)^{2rw+lTp&/]Gi6(a*#pjI_OS+6:`Xbh]:&k:;:vw)8VQ>7jje`L`g:H,qn9{s1+;G'(0hoH i,U3pa/_g;hXn6PWJIr5__<Fqhn`C*-enSsl@rP]L2|Iq~N5)c;U)TU|G^p%0M3
++_v1L	2q}sY3.Zmt*NN>nx|2^rDmPdnOsq;w8gs# I /j UD &DECHeI6
+-=7K4(7)JO=V{REZTD@EKw?.Lfyygu<+:m_{'W1ti4#+`jzz6=~yQ|I?zSt?f?PKjs|+6ZP=%M]o9::7.hq\9^?D=G=;|;5YimeW;OE\S-`!]~+C=CyQOIo.fuSWuhlyD|[}[Qqk/Sr.U3kc5EC-2{Em 8-J?e}v~4PKQfh}V]h]9Yv$Y	)JMF?S+j5?fxOEC/)zK_6|	~Uk{waNL'>*OQhUTd0GPzQ>Rky }NBY{jxQ@N!=7JNLIk6?au*3;J[5qhC2<}tc=Uef.P 7'z{taDcg!}'TomBZgwBV":8'*=lM##t2C62<)kYZ<9sGz_9GOt7\Yo
+ZO#z7,SWV,E1;+gX]QS-yK]G^Yf95+jyYuB#ahC=(#9So>O_KpIq>/9WonHq
+YR"{OFa}
+u/`ciR/OoWd 5aUHN]_0#l{w1{!kf2/A8U	}+3n7ub5Bbc 8I9R-"ERKRLZG0"uh+lI%r& 1t	Mt]Y	zL_xmdaRS1'k6T+:ev7Aa31JJ-Z8?G[@}]pKxX=Agv gE=w#w#QVh^\K&'QO!	e>:~%r]0~B`RTo]|X}I]O8\|v:tyq]P4}v4A!_|R0>&EXzsGwY#`C2e'3sk4Xz(;v,"!gA'w2.xsX!!Um:yOU_C<uP4T\W k!Bq.78k]mo|7:"jh>_Gy>8V.|W_(\okzFq;7qU]=f;MAjgb~#mfZ33S!."6P:N~>X"I^p,j?ub/7|;|_Bo/'%78Y:00;a;`r`vg`&;2BA07Q<q^BLiq8Og/c"u1GS2V!#L~-8k,'_>0?L ra*oG:u o`yC0oq9!`w?^7(=sAWpRx|6CNau9[<qb<GO"a' I]>6{8%Nb|K\yC|E.f^i+sJw5Y#oA/vvQ1M~Q_7x"1bE?xOoho(]SMcQ|uXPk&[?[9UjJc{yuzuc$ MA>/"oC#utm[C)>'>X\kRQ28;n9"%ko3oo	O(qj!sVIy.;;:!/@.m,:WE|7[PuUcGIsu1pE{7wh:9<7Er|IF!|6yo)N:oUZs4|<sun{P9ht78:wL:{sv:5wF}pb;'6z?n5`trlw?W{Cq<#$=[}8 n'&5t\w|MR>3y-ww	og_6Y>`kkP#yTm~6[vh7NN[eUkB_{s=9|v54	|`?d|VGp$\OGexhyN2gtGqpRyRF=GZ-so:D'g)_<S10[-)^l9rt=a%F9-^D^CfgQ8Nx<Kt~1s MF6C(lO3N}I7dg)C:WmZtgOpI|.DqkIQkte[5d'pJ>{Y2lCRa,KTk"xv*)|^TlRwpM`j2?UKo=k)j``__c&uze<I'[K$kuM5I+FMy:utB%=oe?RKsnfWr,%q]R}oZTt\pC)y-Xf6'R&kMD7/T>W$m@z3S3P56|o:]NdG olzw6|	S?&fnBX;or]~.5(Jq~Oz/{{k3Mo	(<|Gh?Ac	SrMoqo}CzC|0iEd?{y%NY7??e<iw'q1,hYloNhL~kp..3]~j~~[e,^{I~K;T=;byauf;uNnu|@]!n[r:AK'/#m|t1lu1GPk*:<7M0i?C~rj8wIL#g< kpt/NIROtwzPovJX=a'0.8k}|t(YD{[57<]6v] |B~8"4}?_sv+BoO[CzF&=!HJY4TKR5?0/q	9u0_m~( LsB00\E[pI6k4Fh=^.}Z^ZoZ^-W\^<{3zcN^k^'uglGld|UuI <')IZ$^OB~$(G^kmIe{m<'Z?k-q^)~%lKl75YM~[HKjHqU:9lw5a=o-eHg#8"{}@X'{Gann79`L#>\TO;.Isg)[w)zoyj-6cUn++o=I6?sm@m=QK7!a?<
+~#oM	+#Q?tp<-E/y2e]0'>dmsPRHT%d_IRvO}b^<SF~ ={pU1x]R&n9$MG*(w;G|9'|NiT8h(SVPr;viN#Qj.k9O[eV[K"8{23b~Sw_>'nN1 sOZr6 [Im r'Ba$F}}go@e,)c!2MZk&JG=$Sof1yG:x5;&dE$,bG9k%mG5*t{'<\gU|hToV3=vZ&6[;K8INpx||M5!+%URyy pwK 4%7:L9V|7m42~2 Kb]`~s5Os(G>Ap >Z\_>Ru'#wd$]qpg5-a9S{D:{st_]G|qIf}	MH2<:KZ^#C>Vr_X%hgsM8Q_zi4~>D{)9*flet+L ^I#ar`a~8#`/OaaM=s~;wAA_c,eG}7j<zu>@\2{HHQx']]z&%W4`~;I5|AzV!_?kuI,m&2?Sw9<~#,tq9k\:as;ee36J^N>xJY-oQ#~	x}Vz?0-
+{M!h<_FECDb{igW?h a~{0q[%<1wPY\5b$inw1!@|;~3eM|GpIoq8}9/Gyx g5@)5d
+>RviSc]`Smky\Q(,d6b|I;ug|~.~%^3zWl^NX\y_(pl:yvW|cu?gzo!!m7.x->F-0Aim-6-[]]l}2L,gs[M~p-{|k|"/;a/08tW6+#|0w0[6qn6`Q~G[k~_/vrIGYO]8jo	2h?E(HCFQ1*7ED
+.H5glx>&]42gvH(uH9|bB[(yj	Z|j;cV7=(hQs?#@dF^b1m_m{d(^x?wOm~/7nW;9F5:Mpa&t}^WzgU<3]c3kZ9lg%{#Ewp!|e&u=j-8aa~U=]dC	~'Lu{;KOVJq1/e>8rv,P	:PW|<k7o)sn>v)oBo}C_3?|Oya[jF,J)a_cc~LV|>)v8F
+wXa#)qag13 q}k?/9k89zAS+Z-FeNJo5%7BiX"x[G}q]}|*YLjs<vrjZ7u.;w^Mb'
+TO)s~b; \38q/'u!q}"|gE}Ppy5@BLPsPo2n6q;dYQ"r#]:m	zMA9t="`y[
+n?6w]e76A~fv>rswUvvU}mD6rj6Htrd'j8jYBx
+[0*D_Lxvl_?<_@+/5^}O]#ncj<G-7<}ans#(eD[lC$pjO5dFg44sUKzcD'Zcc6(V1gbQ<Z9:o4}C_zZ_ }vfoH_eMO*BE;1}5A~<?#Q|s6"0{97foj],~_-+f`YB$n3O9~	$Q6)vShCuJ*Yf<{==^1>/EB8ot@dS#$|HFJa*)cnqF\T96r6<;3ahsM[>"[6@=+\k"-C9m7xr={@|s[}'^wik2F<CA=G|k~rzv?L0`oWtij<tSHxfC1zM&;zz~Flkb's:^<c{lsf!};?KTKrjm`J.{g:{Ry}b5otEk'HZgT;\zwUygo)1P+J<6T}uqJU>Jh4;c5c#XpsX	RP5vd>0^I>ZN>iV6AP979+y:}sLHTZpn=6)DJ
+RlpB%=-?FrJ	# wtUr,gW{.<hFgV<g$!+wNM5ti$=o+liViGA=Vy<S30g;se,cup}{m|OR$k>}Z*GQVWQ3C|;>,yR?^[v-Z/<g<I#'<oH-aLj/;kq=
+7`6	<z`5Ssh#K(9;}_+[m_k\wvQ>94CGhANu)vo ]b9I<J9|2Z?e\-#i=LiXoJ^wWE_(i%kZ~NTwO!}~."t{fO`&iObN<C<;&sck-0QQ[t^GkGhWk;M*vtE]](]aO)1"U:V)`H9gljgb~;9Q~@M+x&S0U&)YS
+s=. |h3	1$|sN*^;"9EWtYSXsBx%(~_l6*0!8P.K}y:ka[[
+G'75TP^\SXD;<	-8EWOPN3/l'd7NmIGxn`:3yXyiS= "4;4l'fe<6HpO sTh@	,EmL=O@~5wiL{=_kY(morn3Bxi(3:`?:C+:7RX'wN0/g`>?}^	IyeyS1..KOs9s)G26Y'FxVaS%k=JW7uep!H!#=Xe tm<V"<uM5lA[(L_lLre?=<??~uK+$#8Yf)ixW/)?5rjwj]/&c!O3N
+'K9?Wv&.sZs{;<r/i>g#?t;Xi^;^iZ2YH=Jp+#ZA{Sm Urm?p=J-jsC"{A~}
+v$`u]lLtYkNzO'i}DLwgGn]gD+=A703C=m=*Z}gGl{nZ^vhVB]0Y} pR/883suC]1?>&)T[bn?ula&i}Yvv~um/MD4^ayr0VG:W'._Xr$5;\q-:lJI, I'{Z_Co99H'?zYki8en.u?wIyzsy[X/1fY/,C?51y$KQ2&LXR,	f 8G{j&:Zlsz|~2wB"m.=d'G6+z$4Si1'|~S<?_=
+a;trZ4x%}v5:q!r<M}V>{mEYvgQ/\pH`~6fi>}mm4ok#aiJKKpLg[a|%v0w ]<)rV'>^80gr0>pu2J3_~KUY#e6/e?Fs!bi|X{p)Ca) gavfBEJ^qxMO(V	Az
+z	+S8`%u73EDO~>A>#EVcHu.g6yEIggkM7j?
+(y\(W_}SD9tN~Rcyaxiu(uhW"@[s|3%(X{vga+"BF/75:<O8@j+f%{Lo!)&%Z _q+%!eQbI&]hwd2{_n(cr9w$%j_'k(&B=xwH(z!qhi9eVwax7tu2a>}(Z>&<T{
+~MkNd;0OX9P$u pQ>4J:8ydk|]7.48^4c.c7O%K]kB,2aQ3^_[<C^{kM7	B8\GMGY}^x8`0Ce;ku9Fl\<u&e(;&Z-4l*hXe.G]t7pn6wGje=-?0j,('xn>oXS/Y2}eu4[z?,~gs4u@w^5YZ>9@t	4_Xz@h)B}1xH%gfJ+</f.0`a/q"DultTsu+UndOm=WSVNywqrwU];7]4y^Z)yv:uNkLaF[{c~Uys&C?5U?+r.4Na'a08k,a3sf8;#|50S'9)2r5|e(n?FoXk/FKne?K;(.'z1;^SYg,~A"2wJXZx#lKu'f97W25WezyWcIF!|}Ws5p-2-573yOupDGatw?QOwMsC	rM6X,6xFr[;r&;w99<Ap|IH'eRVr]R
+yDi_~5yDE@:2Q0})hgvn=\p"x(a!38<EmX3KDo)ac0[Nd_<5Jv-v`an	UGWwfC*W|FKGRkxyG88N{GrnX#Nc}:] |OF`Y+ZIDU:kVqb{>{@o2ZOg*uJ_G({z97++_/yt3x-	!.zy+B/2:N>(^t\y/84I}c	hpm[ZJNeI^%,HGuj0u@J'vQ5(e?~qNO	v14ao8
+s&Cu/s 6{WHW.L,px%G<{NY+q*q.ax=al@`ys| o%t#r {$aIJ|E]a*f>r7=Hquf7#gz0g3zPQ(]/u>*z|M\#~MS9>s|KWksgf|wrwvA?]v|F_mwWsoI9u~/$4cQAoAVYa)8;bY]o;H\rk5KU>q8Gc:dsNs_;;m@v!J+E}e?).m6lE+k/3.w]1.459._0gL;+,5><'/yy_7wB#B
+j9>!z1";0a(5 onfqzo N%~wG;;&4| BIekA^Plv>i`$D@C[K$E=rbp%ih{WN:A=w%)oW}dSw;a6"`suuH>R24((G)yeuu&3x5I}OXV7'%yXs.uZ`}^Dy/#'@='Z"oS}w7z7)~Q{[V@C;8>-e Q^2C^w=58N=r=FIUXWW:Tyg-syp/Dou2AZflRoC6C3Up:zb9GF7W=]Cx+7L%t7q$N	O?XnW}, V)M4
+/A|v}%{2Zwmpzp#-9q3:jGS<'%J=}^w/\oZ&}~cM	ufP@W!>$![Yu#Mz,^0??_azp<_u(+<;q00cEjoc>G```	LT5pO.P>([D?%G(kSSxwx">ykzo> <k!|1ELJ0aqqchOubS.vtF-R0v{?X:9pI2UL]eubCk9g+1v[
+~<Fl{qu[D/uBQ<`YtA!`>"x;z`_S^q$pSf1rm{Vj\,nX#$w6lusaGd~K.rY'u~]1j08/z]t!;!(&Nw#_a|#P^EByi(U^}^nA^9}eKn]tk|$9 \AJ8V82#leu]fSO~cMoTl8-R[r^B9!ce(:r-y$MKy#f_5uD4,/gJ?U o.5/b0y{QxX_Q}Ff;b5>F1v}yiNkeYCW^L=LI$lf]}~-!|b>[&2?H]+BSmY5%9I<mzQ:?JNi)P88m?P`BCX}h"syj%_o'a"TO	tL\;yn/=;QDW%C$6f4CR+j%1nFx=Zw\Ktwd5dBV)z_/Xv=p30'hP.u%~Q ',~g
+e2[4*#J/.6D_=~$L?!y(4Q_SiY a7`N]]&uS#^Fm)f<ja5jwc]TZtJ*y:w~F9Hg}b{GQ\ |j$q@Dz3IQh;e{G_P?pqlC^Y3z~	|R>L$_EL<*.=6P0_(|7 _onpoM54c/	wYlvt|RX17F-oS5^iQylRou{@W{=]WaZi\v;.TPj=.8G]~fedtDM;;#6^df9m5Ow&m)|t=
+-x{+Vs#y+} ,sjfV ;"7eoHSe!Y	iH3u]+|cL<eR_=]Gzw#y_rkVwg]J$~ioxO[[95k;|<Q8}eg|8Z?T:>>Itp|94 N`c!8>qsKd#n)x3>q} F#o$%!t{WnA|rVDG%N-oPs*ng|- |3#q=R13m6&#?nj^27")\k+`&>Hos_V!]&H^Da?]G")h\H_w&u(oyj}#o"%9kJqZ&H8c-;wN8`65]qTsnw78j3@+Mu|<a{_-xr	l(vcf|yJ92sMZK" #ru~)<8uM:<|0n-
+PgbW%R}lPf^#ZN5o)tELS$ZRmCj~<7,_E;}ZGG|<2u>y&ioWQtAXJvNtV#H>YxP|`|3o}W&U:dR^/.jGN}?yBA|Ukmvo(_3bY\zB^pXoQm&uZNu\H|;{bVG~^o6zkJ>]x=>fyT[P^{}$3]2+rJ?(jDzgok"P^?wXMdmx7IUu5s>}"TyO#,w]QwLq2g}qVV,>:BCY)3Sg}Z):{;*[c A4_Nf(F^
+D|/)wOo	[!:hE72[I4 ~5@fEk%=ap"}E#8^>oATwL_G4zsu;^wt~g[OUCCNo$E$~1h%?h$.yD=g<6W:NfMGiN@txg8>[bhWU^v<5f3lF[_*W9w]cJ?Q'%}:TdQiD/"ONnsP6KCi?j.62|~6osu}?;`}{ytuD-_}o{`iuM7['n\N|7=X3&#T]_3l9m5sala\F!uxW.p;[s<u@F,wk{7y/.l]G$]:w@xx+8;0X'?nK9%nuvWD~]{u[9DL:E<n
+"u.W
+G0<7`)RzIg`1p.0-TwzC}(;Dw3E{`e00?Y 0'a3lXSlEk1_K:W
+>@+R \_8kB2rL~<j;Pv$(iYY^5 Cjs-Aoj?i=\c0|(cj}M.4Yt,GLw=P<icW~7JYgZ}Kt%<6_q%U#/R3y|Y<j(i,L]{Z#8	_$[gxR8]T8Cx<!>]Vmdl+LZ/u{fd:f[Ll^52GqZ/?Q:,r|+6pIwglIj-1uZyE'2Nn]xcicJo08=:z>K)'A}=yIK0bnclz4^4GJm[]R7FI8{Kg;x>!_By/9Ot+1.du1)h|okPP%/}o}!Gb}]E/OTp!9m__=4E+A~9	JMj>%N1y?cCfQ__1G-"7zBX1u.CLQZI;&sk6t*z%afkv|=0bwjgXXW`0IT-l$D_DHd"s+"~OA?X'e6Dvm0o--OQGew-OI^$e^;IFd		OPOSwYqx,=Kx>"bfqh\F=5x>ei<GyeDu^a!@o7sa9dSL}s3"7K:yS hz|O~wJ[<gm']7d)!n<cu;.cb`kbJk 7va?pj+E<{pD96KZ~Y@]%svh]'$^Lw(?YTQ~M>llOpsuqf(vMuOq2zb^Gk'a._}G[Lp
+XPu^3qV?w=udgJNkoi(|Wm'o(Cgu}F(MrT3z)PDf@5r)yG ,co9F8HR
+o(aq6gQa<hzd{9C:x?AyO44RE~_F)FRg:+[tT$F7w#s|M_d";	CC'oX^GU3SOXo0*}%.%CF1.{]DEemySu#Nwttt:v/Nn)&q^_FSVh/cF:)K]zK-wvGNz{Oa/uzvrm-Rv[J\?k"J}CvLzuTy5D]x]-q[/sk+|Tjk)!La~[ox#xFw:=+CgZ%PJ'[upp0:WI\SZ WGbwp.tJ>)8Ner)g<T{]yUeeeKUb`UAUA8]8H
+TR_[f+]QF{X\\V\Y.4*eFbP2WJXS\hW?QeFyI(Y4O_eP.FGaL9VNwDEyT-qWeU8Y2{e veYUIJfT^dRwEd{Yu]QQ^a,q{nou\>.rWF~I;p[U[Dd8,^DzV&enoIqo&<Z})+]yK4M1.b;#raU
+WCwg%UWU2Q	[1sthk*JcU5s)Wdk.^ 3+qc}a~t<vs&>n~)SFKro~(yr24'=w3&O!R( `dM?waK]ZUeT7WwJ=Rw:rY9" kTZ	ot|xIY9J2AUq!tiYPdd+4IqZB9H(Vr|{b$]gVJL93s&8!os'Ryo{b.2/gD+)_hZbFP9f=L;23e!i9]2X[Q^L]q_fn<T7!wc<'wt8'1v=9r=Y8{>;usse9qz-,(UQZ\Y56z5[h(ptXL:5V'EI92NUK#\6$,Z+s,* 6bhv"DP0i]iABhb\i~1-1bB+c{aw`?<k4rT_H	tO^$rXv
+`)wC	TF[X^f^Yw#2D,2X^`U5
+\!9HYj\*.)1ZMEU`.Gp"]0
++FA;#4
+KZ*,;Y;Mw Ujk2SLnQT]&Iz%hU3r'4nYB/Ps7LVZ%%\fP-JMq$\\D"jc%3q{PCTHjka![y+*f&vsAnoAm,zK@1aIS'M=Q$Isu[r|#(NyMC7%z@f+Zga1nX%%yo<mL`9V*@'zWePd{1`lRpB//E*P8icecm"idx+ etPFRxI]If8J<d/Uzi@*WJ<,)*dxeEdBhPSD{I[G[
+~]|oyiq`ez>UW^z@B<*		=u9e
+ /rv)"wA>[9m;&dRobB/c-]##7D"T[20w~}w~}OOL^J{|y.B2%(p`TEF%Xu^nd93d%-.+t/7
+)XJb%)"c4u 
+D5%H9 *mcE3d,R=[K"lBmiebY\2Q<y#N%O`D;N-ND<ew])${_vPX`
+~i)2o<y1jQJ
+[Z^XAibv{fWAI~%E%KrYit<J/<g<y2d$,7J.(_R_j#j^. ;3,J&Abbw	GR<JeQy7OG*Uf]yS -\VUY"[r
+%4Hyu@(c`5sE,2\x`+OTHrN><z+Dk5&3o,( +8A?~bod[L8{Pgq ByTe~vB86yTIfcZ;{*<IbUT,Hct R}aOf-qu	-sd1{m4 #%\}VX	kb ,uN[1YW~`,&^%,eWvK; JuBa<2nh#PSOEBx`bI7eZ0FVxSgBQVUZ)<CU%^!'<lf]vK\CY97iS9 4OaR?-~[^Q	d-,9+B[*vE4B-tlJsMH-p/cyvy7+Q`;D%0#=3`w$b0/"DZQljL^%,^Tu8&=Q[Z4l*xF[CxHqPRX,rDmPRFiK@K I@i-Pj9	JJeUviU/wAbb ys)qWs9,i"c$yV
+
+%jCbNjasl;\)(*s~CZsiupp_WW* TrD*"%X\zrt%L(	%+W q/U4-a#N9gN=nzX*isfL8'WhYiI3gZ<3w9aBbM3@L=sn>3k5G`zh	4]D%ZS$]Yr	;2ViE!YIjP%U}O=F;;o.vRP^]MbDhq+H =t3+$'4*UaE7yHo"K0ikl"%H)@b.X)]6eT,[Q+E,\5..=)b+bP@b%1IBw7~Q]I$-Xt^=x!z
+Eq|SibW))FHEg:atw#=i]<tyrNC@dh_>v=<>m&O0H<cUC1\C\,2U%J.(_2`dcb@#X8q4.5*HrEM@)+ep+[n`;P^r5HSH]t-&I_X;
+*dbrd.s/xIofVj6U>&u<X,Tk?.y2aB>SaPi0
+v.*GatV0^.a[<Vufa>uUa'.
+G3/p5@m70]t1
+7xsm:CaxyBe>m;yu<K+b/on+.#![5kmGG=h,Xm[e<x^o7CT^{O*exl#Z5nICH<ige7X'*k~YrQq
+9%_TUbQVu/K0\Ce.R\u.yXQ{o|m]d]Fu<y5da.[}C)'9!^{q0j0 {A_v0aiDkX5K'q_}"U+s27h:`	441YV<,)P5]nvPt=a	3a$IqzU)h(8@}/V&-aln7}Oz`w60_!/p_F=K8s8d9]P}
+';WS|'E->$??g]6V]08G?_kO<_c[}Vk^$F#`9hwBQjO?9ool?d;Oa'&l?`VU~R?eOGfL^`WTDglaf/JTLE"
+*b(&W+ vZ<UV^AG]X\!0XFm:p<TG1,TU]f>$S2rBZ
+|6A<y\ES<UJUuV^^D%co0qgJ:d]l%jV<.aWtij&%]b@$_GghX|6 &`Bn@(QciRrJ}m T mL4 2hh?6h hMM+6X.m b]H6jm @z@^ Xi	ZM( 3_ov={3j_ir<>gsOm#6A{~csl{KlB{ksgY6h{as6wosG?}>asoOt[.z3a/xWbK;8@^aK}{Z)Qw~(/yHzs2QL3<mt zN"}nIoo%$2o5TX'!\"6Fmg?uQ>ZOr/5Nn	Oe^G%-ub6F6NcS)=]$(WmfVz,=[*7%k2\kU'[,}{&|73R(j_8#u7G zc?F2-]:@UHYH@Jez/R$yuoIzVF+Vs't"n+S	Ce']ve[ZRln_lz3aPb3iw`py_& i^[WXxa'>BJ|bh=(W?7rK(?G/*=|C:GqCe|KDMZ|csF:oC2k;95/+]4t<<FxCuD[lFL_Y]{E]kOsEF_ 8uIK& NE#\c`|;fR00U0CMH>a:.^?_xO?^s-'~/]I0zKu;.s:\As1\_wuAO5:_uA_umu\.AI/p+/:s/oA_~pzA:V{]gF}:W15|Xo{Fq7`opx>\=z\wi9C*;K}moD9z;buOKK
+l]+<
+>TRq57R
+Nm*G%R.I%TqMiK+lY#DP"mKgtNwXm(-5K#!C~V4Uh]R61r2PJV\{^RiTUHd#S=J$`3bRxJKJ\e	hCR16X>V*AK7\
+K](.eGh#rqA$L
+wAY/'D7Aojy4v}iT<mNr#$}D#uxnL~)?F+Um}kYw:K~qUCtVWnzut:?~N<&eNGfcr]VuvyL{O;1Nu\O~<]r{wu4?<&Fv7c/ lV<#9[cJo!xQ&i\[cJYo!xVOO[!^x1ccv-1^G.u()u!ZM2_Tqau)?f]V}mLN_*&(dqd8} J2K(GB/P.oi(7aOrK&fpD"VB'?S6-mmRPXQN=hxx+)y;4$dGokK?K2wK4k$whI'Gh?6eP9,GK!.3\(<b*.	 3Zd@#nJ~6:u%7o}qrs.PwR,#_F=2l~"c_Smq? 6=6AdsH]OT>Ap2mP6BO)jU?qSm+Owll[y#SsWhE2+mNoW-6	}6?e@'mA})CZ&ow#L|lF9A7l?6I4wLfy4OBmi< XnogSB~lGaIdem+aA[xg(%S'l~Vh/6!Lm;=ionZk-
+;5/{Gyam~ho]=6b#3?`'q6%GdSIaz KteeKK=BS-T4
+F{Tr7*v2lq!sEMwL**05Rh?K l,q3N!zT).	b<vag(./JseviZ,qm47b?!-UWeyZq'SKkAn+j+8wXnB[
+&vSx%
+A052!-N CJ<mLxa%{XV2N t+J&<7+YJ<Ena%>	}XgV2YLJ<E{XB~a%6JF/6ua%3_yXWV25lJ6|a%^G-vfbm>` M^ `h ~6im	z66Ahcs66Khc3q6a9N%?ml:NL3:K m_&<
+wEXIDL%QJ066>iY~8OLGJl=6.{W^.6wes6wjs'6w}l}>csGl6~i{eso756Jks6;l60;NSmD;K}>csGl6~i{eso756Jks6;l-r,hC; [&n\Mp|?&|{Hw o9AYx6T)K5nSc")).ssc5Se~om[o ^ov rmFsi*n6m	&	&/L:e==@lr&)&|]42]O[	LLWNm 6gby`6xwu~zH3H	#piYrXF5"qqsP}:(d{S;udr]dRG bkpfPs--qcZWRBmn	MwShj_03I\kZ.N&Urtl_06ca,ed:6U!!DX4jDEnn \ b	&	
+=r"xz<miiTTRr^EE~3^	pz7LZsgygyf&rVj]xG4x:'<$I^Q{k[5@|q%.f}#"puv}Z.o p'K$]	7Iz{W.0EIDq_~npTRkRG*5G'g4C\O|AjK|+B
+X5@>z^E
+Wo{v
+:.+D--Xo9cgP=\AXM{ikSdi)|AiGl1*|5.Qzf0mh<-m@^Uh$0<+n>C?'gPh'5]z.
+GOZo2i[Mm^n~b5~4ss~I{<!y?jX!x*LD	wnNOB9ik1j,qom4]zb}38uMu:J1Dq,)olr~c{:T:=a{D=vF:was{gyQ?BX6>nNe6LBgRG'=mnG"b|_YiLetyE_*nY vkOXbun5HViG@//'<K83ra@\.7>{bdYDOv`Y\zC>m{0+FDZ/<>>HzLm0h\"m zCV0  shO)w)}a3d?515>I~L//v?HSwO%~W:OL pLZCD$Ra]:,a<Eo|(}w~O	U6q :?PX| ^7+*!N N6"<^t|
+m/q|z<{c.p
+w!#p_M@a@QE>}=t^~1Wfm1zO.IWZ?C>Ex|j~|_[!mVm
+%1q5fJ](re{	XSB.o](1U8*G=5y%nKe{wKmP+tq1f/>fH+mYJ~['2?cttNVoWoM3)J<[x>:=eG!/N+>ISZZ3^_sB^2TAHi:s_mk>/&wq<]xCyxn7"gz2>"ZxwZ](9+3~mrrpQi7yuBh@a.i5(wP~F	K'-5wJ:2'pnONV2&j|qQx0#tgg<xJFu!#8G\{w3%O{sI$e-{(K2n_SMG?o(KE'54g( rZ>7HrXFcr?0~|;u=}t=H$i=yO~evg@P?>X;w=$xDriY^sZ7+wso3*}?c0*Pvb>yo..969\W]|M;)6|r.jNx$!vzv]|}k?YOaC$]9tFg:dm	6=V1y9<{\bFF,iI_AGSB"FZ]Y6=6	{o	|{-=s;MFR&PGpn;uTK~P1N:+
+wn Yl<+r_><
+-p."jyn.pnDi|y&])c,g_(1O=p/(=.!FA?fAz{&sC.6	;x6B
+q	@?}&D6IIk(H2nGW#0n
+m8,!m}K_wrR7asPyt{oo1Ah6y&k^KZ/{Y>/\#{ GB72"}OstS\n`P>|8YKIl\f)qBuwOa-hsbqg==/YN5V$tku)+3\[+vqIi?uh+x>}gXxOSF/[yTE}uZ?_tz_)@zr]3t&U+idW[CYImgy1`8;n"G-M_P
+{p,E.\Z$Qv&{0{8:Im4SDX4~t#vu hIoa?Ek>Y:	qyA^[u(Gox~@[^>gO)=R[( 4T_"YcuTSOsq]s^cHO|bNbNF}WY2(=v5vuf&CcI8i0RTt|)J73]Qy#}gmAgo=i-2rRF~psmAZg.D\n3}>[a_!-n}Oy
+rqp}QNsv7 ?`8e_:uXh>Hx[]Xf-,wLk1'8c'|xyp-=wnnDy:@ :ccpy+kRWgdBpmAwmc<r>/@^:"5uWgQ|]qw7WU}8i	xf|-fT ec.G1*t{~zq|?}<AazGZH]Suw<!~Ip8:F?QMiIu3JC^Wa=eO9i>=N?2d	~NGY-s-}:	8%qrNp4k\y	~~gVTu'lcNk#xh-p=ko9m\!X>Sr<+YV7o\77/7(i& LK\AZ!O?Tyly>_eS2Ch3T0<t$D/`Z$_j$GhXbLnuww7CFLwOLw&
+pmpGL'*X 0,>Whs>73j!\h1	P+h15e% W>Wk%sx}y>Mz.']In+ !</dPKYE}AeMwM,?"RpN>ikn<D0NSwE;eI#}}_ g ~%Cj[(hx/ ;ywI9HT]]{]"}Ob>-iboN2oa9x{95yS#EkKHX{l\W=Qc,G~#K)cv,6 +473:,{wmKD:2eB_|-]qkf]:4oYE8vo5T>@Q8<}6r6U:L+" 3B	yZIs
+uqN5\(.:pjAd*p9
+f[ 'FU}7ss?8/l67LfWx&VL:Gb:8?QC^3/.kC'
+u2u] 4q.;f'3C!y4^O$ go?8ee'gu1g4&Z@KZ1Jm[uy:HlYI9`ry}/Lo~)]2;Xsqdf3'[o2S\@U@3\[oh2A$R'6^LxY3a)Q`7d)Rr>3)WK3i|I/!ho<h%7*;70;2rxij+6SpCL?M(s8u.USagNLb>2^Y5nDkwC5P7Ia8QfNFC"7rMl:vE8MXwb:skuI{6i~9A>T5$,l
+<\!A<0OnJ]-WASg=	1eu&,qFziX n'ltvcior[0E\b#Q/#)B_K|vDkf aZFX\t-O8w0qa%yZCf+;;|O%UIT:hG<?_qQxa%g4`DOgjNrF=;D`b~<Lk+[-!a.cTjr(n>[%MVQ}lQ!5;oz9&Y#xu(!e{ByJutNGpPD|\(?<9ldC
+}oGQ6e\k}l=-iUl<i#QNYEe-1xyqol60<2yRs!eu=}^Q#fYG9c,=,oqwF;!G=
+>8w	l7^94$~$g	gDwl<L>`s x6ifYv;@mSm6G&dbC}RA Zklr:~'>#p&mO`!	1JPN<Ow8xZ?V_97[#IL&o0]o9HI ` (|K{IlF
+z  {7/n&_7mY	$8lqJZ63"$+nlAMOehmb0X/7s8!?nz}N%8kR@~C\\%.ngJo sLig<f5Jxfnz8qcnqquqPiMBGBwC6z[[]16 <+uHtwwJ9zV'_>ix=\g~$nlOG<{c3@{8@g)n`_HHw!-;V<	\>TX#=f8mpm^l0mU=|r+:.|->S{8%/tK^m+I[bi&JfKYU;5$<!/ZW%<mWB"Wz@hg_im%}zgj]e $x|A{II-!Qq8nlT6o5A+b{+ H6m~ngd\y%oy5Q>5wiBi0n~#/n=8eJ~?KX#%(=-RGq{F~o'*WCiSf>h@P:g1EHohS#Za)o#Fm{6tyT:lJa")R/{uPO[#|1Gq:_-yy5X#^c/RQz\z|+$|5<u<z#mHoVI9L/I/al7j. c"yhd_	WW
+n\\z
+?>=Ut''+G(8{Lu$4rdku z*y@Ve<\b}|smcI{miSqFOGO')hg"N j{$[}AL_ixVk!&6C?H$K39O#hisF^+5a<{Gj! 8&:"Z, sGYdQ<s=M<m]6;1v9^yED`u&E[oR<9-cNE:qL{Bv7sfnC_I9NMVNNZV--r&:9*<K
+*[)E95I6>Hub7zG6[4|8HK,))-'MR]lC6*mnrHh3RA)I0jImncSa{q2EiAj|5
+q1&i(d|!8C|a{_:^pjO?p]#5nx\SFEh<V#Oky01v7Yw4JDt:MK5m'7YH\y\'FEr[G#:eCVMCt>?YrvXja,d}vSr/VnhN_>)w/>]wuJ8z"{zG:M*o5n(qrQ~<jKI286oVr="X;g4{mv+nf_i9}Av^yN$p_m#Dqm;H$k\'>k<BduFjskbcn0_{CrM~2(8-c%x[J3z}'uP0OvoYW{6I}uz|Z'6{F3_i=Qzmy2{';M';Ne6YqHwy)e@<>m 6\v?p=(=OMQ<cN8A%OMOmLINX3>QbE +,s;	m"wdv%Y&|g o{'~|lZmoS9/67?Ywzg+n#y?[0b&@ rVNuZ=L('iyr{\J*8-cn6>7FxRuymn7_Esre:g=>/8b1~R9"mL<S7XOqo.@urm
+zR8.+]Y
+'k:nB
+|_=x.lI;~lrO~}28en5KF\2Nu@-
+xOXfi*>V}{>,)g|Om.9m! WG?V{=_^"h{~l'X+z<i{$}~5Mhmf;:r:'mk O6^ 5@5^}r2gc;8_{.kRg[6fk>[m6v>d^#sp?I{>V{+ q)j?6+7O Rg?::Jj\C~?vX`YyPm"|V6rO?Fus\bLe9(Kn.*nMxO#\<gTrKYe8\st!t~hF2X>S5Ed[OL8qzLO|T.]	\&:{txZe|P+w#SD;tXxQTcxf+jm=W-xD28^V&K>:C+y'rOY 4pR7R{B.c.$v&}7wb
+0#$E;{?RslF#+[;o :w$%*_D'/"k+>]Q{Hsqch9sz{iTmuGk&NCKHEy>50X_kSC}ymG-1[7sJ+8}(qEsl oLqfUipi]5 M5(l!&h9q:pxpvY+2iQ3KOP[\C ^Z?'egre\"Z%MN{q1Q<<>x!&mgVJ6ru(^u62V:k=azh__XR}	
+#e-1+v^ ]Xk_{9u`#pYE[8kc@{^E7p?9}GtI^'>T#A,"TU~\YP%-\y+%=p{^KH;Fy	]},Ws,r8]6<3x;xI;/&}c"%?<Nnz^Ziy&2{n9u/vmI~=1 M;N?(aCLC'O*8,v.[14/?<&PgsG:G:i_	Ajtr8yOy+|0s{  8PmbK_{I8?wW.Q
+9Xl/?i3O}\[76_PcY+iCUY`^a%i[IKqweigg4|G_2<U}vxGj8-0-~$n:}5[zlD/vxCx^S k-9cS=m3:Q'xVN:JG=!;=q'oYC ;uL G}j>S9DSq^a~QvMP:3m1cxT[c64>6@CD%s.fsytCx>3>aU526Y3dxGxH{D3NpDfxc{z&>D#N"|}'MP[+{u$L38:nx|"|m|hw#m.C1D{eMRgGw0~rnqbo]FxSh`ybgG p>$:#}#/L{AX!<Mr.auPj1LS6D6=!_tWz(;n;fqz_ZDgKMv|oh1j^0 m58xHCWUjOG'r[{&6`
+>\@R^$Ayd#Ic\X<iGDs%*"a;qEz,&&-t_Q~kj];sA{<5IhGP$y_zR SY+-;nB\_v9u.5t=LlPcI^+<)1?kQI~Tq3o<A?Mw+}/y2ZCQk5M>.BLsz6+>|\FeG:D=8%gnwT0:xK:uF9f3]z
+ct{LuZ5/Y$L=mI}r'B79_:>="~B.k&g-b]Ol.aDL\H4~5~ynfOFE4YGZ YoQX9/#mS+gy< {84k>zzk|_&uK"nOS{`w=J&\D 8ek8^Iv}{d3A4\$B=rJ1\lKg=`56Wq~A;H~@xPjXz6kj]V1!?HG^9c73Qz?w 90yM:%,|=Ar>a2<g#4rjn5Ay-T_8?R~(}Q_:%^~md_u6H(Vw/I!;q{2?@_~y	%@'J;r1\
+q^n%Y)<mv ^(cAWk3Y?wl8};?\[z ^1/v\P;;G>Pz<c##tw{IXk3-V5'
+/#2-danusK2Smq'Sr,^OL]Fnp1s~Xkc?lF}7a]H<'pw;Hl?^/}mv-K6j}R7">u/Ct$ofW+Mu0Yw,=8%*~,5s{'_pPg^
+|j#>@ Ol.VR}'h08&T:{m>`?v	{#w;j;m;#C|]+W?mO<?YS@?x'VM!#-y&o$p/6KQG]<I>CAPR\);F/RuL2}v~_yS}k"e,@Gh4>h>_j3z_	I{&u-n6#`V[8SuzgW.V,dZA5ynl|>Hc$ou*quIo<rjG>"d\(aDeNm1ipYDW5C>pb~7J{^yQY_W+7@^#	Y1\wC~74D{gMW+tc<vwu<XmA~Szbt(9nE;N[Rg~K2_0^y_I3N8=#/gg
+rPE^nk)' Lsz<I.Nv>[: s+9V&3kxIOIiMc8@:t{+bIQuX^@I|Mv8IKJyV5)}d.g>u|8NwL}r}wwSmGO2,[zf1Ol^lz-R/E p4?j/F)PiKs8_1<%@oYa=n G]A~Y6A:> <A]A;W g<' {R[`{ n;>mXb:>hs-'9>7_<&`1R)%-".mw:!}u.c>."sj)m-@lM|WhF~~R.9%n-~t3}r]H6*!G[uvD]ydqscwJ6Y:SRs;g4HkyN#gQb)mY}^O\>@A/GlOCz
+<qlK%	K)zM0z}f:QGo=6la5|!7|'YhovCP4Yki^n3,AA+p%a\
+3)HhEFiC{^A[L lk1/<rht0us	wl&:mr_Ii]r]Q51(:3s?tE9)G=h[XhDs62}dc/'iI-\W(R3Bi$<k:Z+NGYt_3B;"7HSc[I3&u"	@H;Q&}5	<[) oro$k %&'ElO"b&]]`?sFn{JYKb,Zk<`]uFyhZ\x&s=wvkMfNG)m,F&s& qg&Mf&h2#^6-S!4[<\xoy/o6w ZY>DB\[x+/&ZXp*u<}ySOV JMfo?!6|F~|15uO	iq_hbO8n1'{? 8air'X97(4.ED.(0t=Ca9&yQ?9:+:	^^>4}#Q*qQBu|IWn]P9~g:CL
+~gn	zw;Nzq9>XF6zA6YCUqgWs-a%;<P}Zvwx8/653;:[z|&/wXM;.!k?T,50OiGt.d@[lqG8R\8qu:<z0n#2S@|kb71'fxn6Urkx'tXz;=ln$9s-U]FZ{ :/	^,_EO5O_n} \y;C|#n#=PtZ-izE#HKGWg#]>U=u	F*k-]?CYo6k7~|wW'6KmF^S~cvosFEcGgpu;o^NWV ?:y#g~._[+7:[hMoioX+mD}i'L?GS3xTo$u'MfH{\?D\.@X9;x{W(A~CJw.=X1D\iH!;"Ph{XzU6"xgi>nUV.%>=s%~p{(;[C`,f97t{h+0qpRG6L6^tTI?*} A-QMhGS<$T>lv})s%72^H(`n;PywY5&)wSoA'|g_+NNQ8q8-8(=jiq<e>klJ?@GL^?)no]RWRyNC_yx4x
+xu8i]$q~<~BiN@_	M]qiW&U^JPRP4[f+lF|o1:6H:RFg?w'UHL,kCNakOm*|7N!`6>m?t}%[8}Xo83Q`]_'kakp}t~CIT~E>;tq2Fa<^{&Hk*:	z~ ]Pw;d:gE@xG]/@[Y	:{IHm~PS#?dA!wn|k+,#<r\b<\St_Sv^O{ZyZ;g\bMj]n2+{7nuppY=;pQ{y.wZ_98f6mwnINdOmm'{FX^cDX.r G,8SxGYiFy] K}RGRY0k-6zrbMu"m3Zl#BDzqR@=H62_rN"e iC\c0|rc=
+4h5f^W	#=r@Ylr&oZs6NFM&|wG_"JY.hdZS=rIX9<^<?F^t}q~R	Z7|mKt(].Rmro%W:Qb/jZ&m}[i>`d~EEgL-Wm t5{DEv8Z6)L{gl%{Cp<OZE'5epx};EWP['O/0!=I;	'=}^2<F,m'Qv@7OgCE>*CL'>v?R;vZz|c<S:\D^B\hx}'}2O!]APJ6_x;	Y)xGJpTaZEk G9t$rF^}eeW^O=8KHm,mWhoRG-G~}~9AXhp57oZL);&|pc6r`{Q;G"2DaigUD=WOv;y+>K@(a4V$rlD\P @T. s>E}is}3wGH'l[Cww?28{#)<) u	{87Qfx+6IOWg~'d-'{+OB{</sZx^yZjLw9B\wl2S T)nObMYJ6?}sxG=:_Y=B.4ZwHs?wswYe|~y:{z'V_ 7~Yy%Ekct8h}%Efs'RF%g_HgV^~PNbL+C]i:3GxtmS\Gcc|G <uxi(oucY7~$5w>+}iHN<oyQ^-<a>y~p[S?ob]x2	i#EsLJ$|k)t#-CN:+Isx~pO>,P\CDg0N8wG<wM89Ckjc!#y)#R X:O7'g!O'7[~JJ9J@9LaGS'+:J]K:~b+8<pJc:T[HwJPR6ljCk8dcL}wKw\YsKJ8x;|a$q,F}j]WUAP<S/B+yP=_Q}RgYxogsMq 1V=F/j184:`;SuCE]9^O9{Z3o>}TJ'yw$)Ov%2b4+_=p"0)H=)8N>%)F^rcBX9xS9*dL71SN>jlxUFuMaUMq_YMQSZb*+)6VnSXQ
+WW2\eJ*jt.YM5%2J-WU(4
+euulj1umT+eMaMVLgT,*4
++Hd#C.xgUUk
+4nd-Ymr5c/!|$ogYl[3^8X"VO1$3v>a	G/WW&j%W(uDaISk*V{:XX]Qy_vf$^L0)8 fTUVH]Z]xw4hx7N0}k
+WV[#{oa)[Qp7BDW=@p$9(c H!VUR^X
+ceUk #lMu>M# QP25?}P@nNTU5jJ%Mu5K}L%8RCas;day%Y%	qVSUVp.	2miIgXjd}MD*( (%%oU;Wa<kYqaHx/XSVM*fTk0tDO0}oU#pDaZyc/!
+9Kx+p]*.>+<|^S}OLnz
+ U}Uw5%U
+R X*!RT%iK+J]QYUR a^TURH0{FHSX8FU^RX/P;gYiXdJFuIUCRVYR#i*5_IzGR>0o3g_-,7?i.Ra#P5DX.1d	U|,]ZHvE~&XUv$\m=JNL1X~^+v \DG)HNKj3~2b_tzh)gY(O,'X\Ij]>[wJH&(.[!sd*/\X;lEg.3y>*RSQwN7."R pIePdyLCw~/E6,C1rQc+I+j6-({tH6M|wIMed%DPQ
+L#*-&LE@@_jDVxGkJUKiCBD9sP0rWVN&"}vQi,]j;3B2:@>T_"~$d%Uc+?(\SVnWV<nlB^RUAi-K+{FP4
+/Zv0Z^YRTqh2HA.VUy:^T&"*mFLTVM):)Lwa A}7o~}7o~I)Z>.ZR-\rH=h|J[+{WjmT_3o'-(.YoQMSLzXJcSuP )E5;5PE3TT=G"UHh3
+dS."Wahl;$|]VR-J_GT
+{Mz{EbUW[Ydv:u x/&&RcLVT^X4:fjS}GX)%Nj5@-uU+WyWU]UVF5JK3J1juX+eb<)+\0*)]4p
+DpU%5*Jf]Wj)&Gte3BAV5<C.sE,AQy|*,R+X*zHriM!mTde2"dT_i+sj]=*D)Y'5pM
+,JDD(=$
+IPxFh8	G6KM+(K
+l_\(.)+,]c){ 5%Ed6k@h,,YwD.1 3	KO-vLZrw`&2*i"gj;\A
+{tuP5]-.2nL-\_*+#k@E,+P^Zzr^F:M
+hnvrG^K_M D5+AUX!W52^c~L8z%_K?AGGdMw_]2RUda?uC&%B6XwoD}5n;h_x}+;+L/9wKpVO(|$e-?Ks@/)MT//p~W;T'aeJb-v@c6~uKX([ta` 	mPufUGD`^kU%b8\l0%l=(hGps?QX1S}-q3kn Hy,+Q_#]<PRrH?2AHtTRhZwdF,$!s|Fi!H %-|bFB CEE\:zEM",G!nyS^Ee [H0=LBx\`QGFQj@=YFk*/.*	eEVq`_4J{^9&N.NRTBB` e$ZE*QeU"#	Usr9DL0yW,t//rp]nP`jbUsmZW"6kB/
+/^.5v*C$K5)&<}%K%2KJNtqg)yu<p)Lb-$9n\^g"/zOY={1o+khLz^kdd,+IZU8WEU[-gLpC$3PFaI2Esu])!Q4LWKdUYv/JKEV
+L
+xI9,h/VA4Y%%Qq
+78=EU25eE"JdY}rxAVdo9^k#j/j|g:O*p|*qRy8NK8u:9A(n& #w#K{;g<x>BG:w.#!F{/oBf$/_:izGz}xr%\/me<pH!Rg~t:ed>H:_r~Axog?!~qxowBIo9&\;sVv3Ysf+/_WUH 3 -2dw'Ie"~dZ:r1l7~$V\>bK:*%^%mGxD)rxx)\6]4I2>8"UyrAB=>?G.!G%MNyL?	ER?iLVp7%3QwEj2Ar?&l~^.T_,d~RLq'"\)v)p]+"pF2suIzM4pypH[RS~]Rnwcp|dpd3w~+'O{ yRG^O<<UgH{7anUx_gF=A|wW#7q;2>F>p92/w|!nt$]<w;^CW{#pO8T<v}QH}%r|iw5Ss7 __
+^z^Mz 1|K5|W pr|?K9y~Gp9D17X8A<jap$Adw$|Ov|.z3gp"=MD~]OcodMX#p%
+1W3I5h(T0"*f0"EUUrc*vM4	X#*SQ25Pm5~]RSQA/=5l
+/+tms'$-,KF.*X%U0N+Y^YXQ	Vu\h`IpJD_SXV@} AMPWHfZL<8RVwMr, 0{7T!N6% VS%d-Q7v!"H+dk*`tTW{~B~!pr?K!Hx%1	f1>!(v	!C>O	4F	<d_4Oq|BhL'd>R'HOjc'L>!z =O=Ot>O9|B<>!h/|B+a1`B|Bh/'>1AX'DOz>19hB>!	v>!B>A|Bh}O	A	>}|b<'&	OL:|bODm>1yO	d#'1>1!|B >'&3"`|b'&/	|b|8+:n~?wr}3-{gW{;]V{w:w}xpTxsg"]=.{^x_x;K\|>ug8{xs;A{W{;]V{w:w:=m_c\<Vt8+A[	vy-'}\"Q/L<7Psb}R:tCh(^uyz,%f2"-k#g
+.O2}F7ypVLguOx:?+gh;LSw><y'i	}g	v|7t!F^|`]5ob-0q>u>r2y?Z'knc2hYZYRO*y
+R)hv~Rkbj;!
+y_,CG~W,*vH>LugL
+>>O:=SY*7k
+]<]sQ	^0L	Z;zkC8:`Iv(08kiNK[2@o_kVVy;gA[5,KK<O&7lz,9vy$EAai.R!&ZebCxYQ"xgO3n{z)Rj{W_g|| a^atHRRwk=j=+n>Z9'[,.F]-WoMVo]=e	-3o$<=j8;]1{o!V;yi)= (&nj!~!F6n3~<qopy%t(Y7j;Svy'"Qd5}D*Lm_YdC7`$	+L}-'?/}=Iz
+`qC<6_[]sc]O"IfQcm -.:e!<wOgGeD942[_P,s=!p!xtA#3yG3xf.X!QKzyw"nR~L>}vopvpvYkmCwo`409/w
+E(^z~9Pw7|?ti3yp+gO.Y(r8wsZe)ghA#O `gh'%w0@(5yqhPLuryB	XPxc|	`u;<tqf+>_E>6viJ.y6KIo5|rx)36qX^:9r2xf NW9JaN U8v^Oo4uz=EIs~9;2nw2)9;dxNyHyh)-}.t%^Tkz59+NyO_[c]
+_8u=7yu$H.?A99n;(p@rN8<J&lb{QFvy7nONVwA]h_4/.3{$X.IO3+ySTX0mk	c_v.:z::(s0eoY*P??x;\J	|$ya/NQG wy{{(Dm4ORuL`{Sx]>r'[v=vzU=~G-uh(<jGj,CAw}zvnzkuwH#*kzYcTnF<6(uw_|K;+8g2JK/+WisL/18Z
+x/i!N'\JFbW!i.~|{O~*1\r3z|?;<^X%s&ksc;oW-|`F3A&x<rW(o)iV0<eMM^[ RUf6;MFR&pp.?ur}S~YA5lyg2%O^7<Yv?oNt?_d\lsL{C_* |y 8Q6m<kLr%$YNhUm;[Aw{Q5>;A#HlaKy8uGmZ-,U)ru?ItlS*
+[n=!.h7 w.NpwzqL\pG3;y7%mui s|;g_}9>E9qcfc dP	(}ad-e&ry7Q`\"n-Pw?] ?;f_S(P0E}yDd~`d~c"O?@+ytpuw~mDW~%}x@vy.ygB5?gQqH\~F/ uSg#~6^I'>NKxjh#l7_+;~"-RYV]HxsUls#g?=,9DY>s/F(['X'[	"=@f<|`"vk. j*:_(:w9l.97\gKipSGdN_s@sb6\$pK\;PnE?7?F9c9]wq/d)Pui8kgp~	<:4V(] 6RTz#E	Jg(JNvjxXwK$ykq#q
+vKP/tionn?z	~*{`)f 3{-		:'5>ROO-O)1JF9Sves%1#iydpG+V(/v9`Qe]1qp-dg,[dy|chY}TW8y8xOjned__{>F;fGR&cnoboCf
+yB+w_(yUwW_3 L*o1~w1Y;\MnU(q;[3Ac9FcTe318GxoZ_ -=ZI'wM#q$\@|S&V tEKywH/zV$q7f	~NGYs-}:	8%qrNp4k\W%&m7R<0n6>FY|Yvn5|tbHNN_P=~}Ie}IQGI36y`Z
+TA,(TylZWsJfm'5w`P^yNzN?Q9	?p;B|	<o+?MG%n83%r ;qQ^;/wANR82bq]~7?~]J'J^5"4wW~.']$4|b"N/Qj%:!_p{g_`ProSx\;iEC}m"[9;H}/ise7K]rv=33NS4`ONzwf[?Wm0;i.S6QJB?QLmlXg<
+|\SI&{%|s(uM /_xs\?M3=<|
+}H$.@&R9@qM 1#?s/cv,kS+47CyW'P:<xm	u{;h[yx\FS++sKwMkC,sU:D.|E3;# \!y{@mH:/v:8'o:~l_6<3J fQ9 O%Yo(=q^l[^LfWxgm2fRZ{}m`qQ6OTQ?%SwY^e~tC7wvQ@JuhN-[Y{l|4:H@\k9/vr@YO33:63qHmLZ4m%m;LW-Aj$6J_uG{!gzK9oHG|u<wNFyOh63Z9gz
+
+hpzUChhmJ2A$R'6^LxY3a)Q`7d)Rr>3)WK3i|I/!&	hoh0uGl3{	%\9)o`>g6:_]ovZ<OlR@blOU:3qDx/U6l>Zey?m5)~#=78O[	I|^~Hd38=w6r4u\"\"nfu]f |gGPez.R;*+\!rRW|y{5FiBb`ng]=:1 `M"|Aa~O atG% 5ua~:UF^6=GRPg1gwN7 N>GaFaMYq]ln#,V~Ftv;8<-!JVks!*:[R?/t~n5~nJ; _:GL$NIsu_QQ:C=LIjohTra_sU;OWTQ'{ov@ndCj,wrFYQB<|o(.~wF8+waCe\c<i3l'O`.O}\O}oGQ6e\k}l=F9z9}ry|0[2?vik6[gl64RyR~p:by6>=fy Qf} L9gmj{}p	B<lO\+	^	h\_p]>}gDwl<L>`s x`<R6d9D`y+wmOu]/]5Jy}zr 9tEI;58q?7I8Q6GyO5o2	J!~?I=`Zxl?d]^m,N\f3*PY68(=y9p3i[JvOv3"bOBVK4iQ&v<p|N9KEqw5(X9I98v/]vZEvZ>%#<A,r+gMFIR/m N+F(\q6iMBGBwC6z[[]16 <+uHt@)ed*G'|?yJ-:g>bK"k(~$"2*|n3v1^eGVg)n`hmEw}5c5#6w7cjnN/tnM/B67-w9ms6RbY6;3-ya^sy|#Nag-j1ntsnGD62E^;!+;W+L!B<Nl+_L`o5x#)88e>9:
+1nVaarP+jMJ}Wm<Ns 8F~~n:0r]"Cz'V2Ta x{k4(O#MHtN8A7B\F>^_Dl)mku8Pa@I9"uhWpFC~o'*7PGOk;kLRBxPhS#Za)o#Fm~<
+zQxadNF0k/>A@E~}"exbg,]/4<8k|\I\`}|#{J|OvH=G=H~Mw>Py&#4g{k|o6"g?2g?'ek"2=eR>Y%!DzWxL:k=Cu.7
+,n	nuz`deHe 9~/IS4=p}nA@Oez25Q}}\K~XlF>>i/ Zzq mjPmtQ6:~>~8a	"yPP=V_1/.Wwki3TR9O#?%5U]^fw:}psmV28!l!8w@h[sk1?{vrG5.vX.W.gt>::E:MjV~xsZ>00|~W!/<"_5&$6:dE<p:kY?Tg90t,)+ATv~SE95I6w>Hub5&QuS7m$A
+_uYSXSZ{+g&)}OPT9yvu](>m=:Hkb$rt$G[P71i^\Oikhjb_#?Ki(d|!8C|a{_:^pj7e%{K/8FiEB71'T4Q$)"3G(K	cw%
+wQ [n-zwe	 k=_y yBuZFtdSi;>`$c~}OmZG>yVV;m1OmN_>SG}?m?LCAwuJ8H]g)_EU+%Nn<xujKIxyEJ90clAH}[-\-VKxZ}9l#bR/yI^o\"/r`!qO!Ym|=(Nmo	w,MfuRS)O>>Wa [[?V?|M<5Iw+uk[v5QO-;-1cyRQX	s>Tiux@2&NOkrOQx\Dls	/5,>J-OFYv:@{4p'll8o VAQv_bv!G8?"{~MQ<cN:mZhg}J6hcMwzE;E +,s;	m":8:JhA(O}G/N|?6)gE(X)?Qsj1WzO'k4<-f~x[<,${PNdo>n6+>?1V.cXw@G,OJ<t>"mL<S7Xro.@urm
+zR8.+]Y
+'k:nB
+|_=x.lI;{[>?O5uj$>;DQ&@QX$k!%HQV-~'J7@NUw>yuVei*~zWl+p%c \#69c=~1mCcFFj:l'X+z<i{(g~~~{4.g;:r:'mk O6^ 5@}m'vn@R2H,g^{.kRg[6fk>3m4&D;!Vc<DO}i2
+.xx\nJy0\I(	"]l'9@QGiS^k(DL=z\d9t}ySQz]uK4h^a{~\'pwn)xU-Iw<p{z%J]],.=OhI!Fl4)C=M}]m=1y2}<{'rNEx\O2oB=W:by<-VbEW\s]{G*[yvh8du`3aWb!rz_d
+gulq|l+rsn,}EQ%s 2IraekGJ/0(F^yfhAru&
+m hP6+6?_}T 5<\`=$v
+gsO8po'+:5p'Z#	9"&z\.G~QMqW?vn9S\K<C.e{. ycS7OL}gx98<nz@9v`y5O5Gcb_IeY[xRRmJO>}r6:D<GI\|x*].iIAe5%k88f@c^W%mK2-(^u6BY2mS^E=~o/K/,Y)y:Aa%<yvcd,k{	c5<u<o#Gx,q1n8R71.$kyjvqw"OxQ2] .3GoRk|dixgZoTv.i!`W}PS{C8qDTppG< WW?},Ws,r8]6r$&%$Rk"q"t;uZJ6Qw(}6nN9>}JX)29:a
+%Vk 2:# ic	G:G:i_	 q2:ez5y1?k<M_Y]	|r -\z_i},3I8?wWHs}nygc@Zu#lK 5f_*6T(\qq^a%i[iIKqwe]>Sy_vqAzx/>R(in]yBY4rLg#z!G]sn9(Qi8!p,B){H'm]Vv'oYC ;@'yL <'ihLOcwFQB=,<Ym(r6Sy2oiMv* oz-SxvK'yx;%Y@xd'{<_;>Yd;*wG<=u#8m5#c47!:u:<t@d%W>:|cvqk7pix_<Lg|6]j>;b6P6s?+.l:>:5xm7Ssv(2CN/EkOOtY3*(70<2I#}nc7)txhOP}'E$6oZm~?s4eCd]<~]iJH;aEtVtNn g|~^ZQiH=JiPs#r$~fLpWH5y1l7	qK{\u'C{wS[{5lg!}XPysuy+oP)U0]_v@7{g.hC-frk:NhGP$y_#~t :r^nqsPk[y]jz<(n
+z5t@'[?M?I~Tq3o<A?Mw+}/y2ZQw4R$K "Qhryo<iyYx{GLYW(tpQ9f%*h2&sCKm2	Su8fuR]wMW:uxOOH/B?g-b]Ol.aDL\H4~<Yg{Foo.792=5z[
+rAv}iZ?CGP'= {84k>zzk|_&m<;E{L2mKu'0#^O[|O^?0s 3A4\$9:k0?|2mn=+sF=<R%vixM" 8`?[$? <pO`K5ogH=AV%oB	l@:18OtqDh'Hr(&hA^Sk<K8xNz)ykBs`hm"7q=H#?@j&/lUAd%=n#s\@iG[{'m=5t@_~y	%@'J;r1W=;I'Fuw9f1OA_m058D}Fmf9sIw	zc_Y,1||DA~L{$=OZ(4i<+XnW}lh  ;w[r8l3^;;du~d.~=5t!aia]_NW=uR'|%~B9Af+T^/}-x&k5WN3+vr:Ft$ofW+Mu<#vX</.cync;~Gg)jnH+&MS~)|:EH]f:q[|R	]#w;j;m;#C|]+W?mO<#YS@?~@}s3wzeSwH3t#s?uF}q2svigK<$-B&Hqy&v0gK1|A;\<<rNgo2Ugi_]?hnEFR#eLH3x.tE!@ RviX;daX7Z=k}OrR^Q8#B$ou*Ws0a:9;\#RkPNKTcN	q@qUcL1'(6^w^a/Ow^(o+ukUy%~;%8u7~CcLwV$y~dt;T(,x[z?]yt?s,cv/X"1[2I3N8gN#L|c>t\*e8>L#_mWwX WiN/4ii~"c<}zucPGN}n%$}fjEqJG4O&1N^}Ot)XG~]}9'Eh*_&="i>!N~5iR}O^Nr+[}w-ziMUvxyT>kejZZhVY8VnB"[^6~i"7W^iR.CWWeC$mZ5hVjF+56a>+ya3@niTiz:.*6cd::D x M,	Xa>ye
+3Gr,fa>{c{_Kkd{CJl=grK:b=qx(ZQ<kdyN[BoiH'
+t^uZg#A@Fl%nzULu	d=Eq-*-g+LIe*<>/3rryn#gQb)mY}^O7C6z4Z((x^Eygq-&_G4iJ=}<[k<_v><a%k6Y.o7EAfe<A <b^5:V`17'P E#<kot<G&ur 2Dg=A+i puFy[7Vtfs(S<:z;K[X	o<px;8Gh
+/WkMFn%Y/'iI-\W(R3Bi$<k:Z+NGYt_3B;"M>a|.uXG>z84E)ue[wL}6kxRa%@wvWXj/`pQ=C(VDWL9
+&]]`?sFn;R}1q5j:<_xZ-xMfjGC&3dAA#N6#k9k`Yy3hxy&3qf4/do-d.Cxx@8fyLk| Eb
+ZlOV JMfo?!6|F~(KcO_{JLkE;K\xLu@Y@8q8&NsocQ~i\`]P`^h{]rLhrDUm^eWu {WtF	x*6z}zD#9Fy^
+%]uAeGxx>s ,b~3e(5Nc%!Pc;6fgz^mut0mhhCmSG)AyZJvyH	_,uq^mkfv|ubL_j8w]Ct=>rYk`\b$q73Fq^cux`gGe:<syz W=jw@\q=Hpy.#a mCGkuZPZUN3?1g?~C7@.Qrrm6WZ=zv,\oc}6r_Bx^9Ym/vf>v_ud{[,7,:T3G!|zjMmWy3<~;/Z@]N+uH+?~._[+7:[CVJ?iFZ3"1?RUf#+%<w3\.@X9eQ<+mDzuC)zzG]p2)[MD~hY4n|sh*Y.%(q KCQv
+/,fnm#NHS:)e"*i]?
+A[}^D{>u)|60xI+<r*(:zcL=b|v)<:ve s5t)w}Anv>;Inz	`
+SN0@__qP{o#W5g;;Gu~rqthr:~_S	8: ~y!M=##ELBu"qKuBiN@>xS;Is:wve]T%[:k?lEH5xl LrK~BMj\zXIh,ZtLO|j"wcP
+Sl}<'~YKlRt<?;`}q9[?Y}oo5_rX
+@z:8g{ct8._MaX5	Cg$}	riaoap^G,WE@~hcz=u:':{IH#;ob[B=e#=R.WC5C^G NbK|kO~wfufuv7*<FxFW<F.w4een.WW3Sp&ijG]~3pL63x}K\".n8pgMsbF-F,O+)78x+NEew/y{kBRGRY0k-6zrD'(R[u`IqR@=H6}Y?f>+R	rnL:a=SwO|n!o
+9v+3h5f^W/'@9Pec#P-~j}Kr;ewu79ioB~1A;*d8ky/FlLk:7sVp?Rn |3Jt{{>6<?FXeMg]{gnA~W{e>m6Z'}1o3\lwDA>H%|d;g--p^NWj1rm-wI;NKk8{B	Gwi[?si
+gJYUPvu|%)axWOvetFL?Yqf79V}~[kw8O]:\DqCN:-eq";Vsm y"wv_rR>O>J|U:QAehI$c{4rF^}wzQJg4YbI2Wzxw5(Q/:n?istCj<w!|>&[uiiB9}=(yhDv_sZwYmv{o]}`N~@lEq@ZQqA6;(QH6#{GEmy|#ow6y|@!~7n}#)|8{E&hDJ2$=]sy@3q<0Vw>	Y?_i:>ZjLw9B\w$8OIwc}J,pemRxg)x ;x)r]Gvq\@]'ClVwswYe|~y:{z'V^Dg/n%5yWhKk:q}h}%Ef7iW7%Z-<`@B:(G7J|u]Qrc
+^"Jk}E=]~89Q6%=cg.msEO@G(
+|#t6:1O?_Q;^O b4u$}l9aV0U1<a>yde?8-ue`	+I(bw>S5h:G!HX'0^Ism_QYwD4<\iiOQ+}}%GP#pu+>eH^H?@"VEH}3-?%~+)FwSw#s|oj3a(s&%X>u~Pg_IzIPgt8_qDVw1nvG_rr+~:
+GGu~R6ljprQF[zG\YsKJ9gm$q,F}3 vm06~)Dz_I=zGU~xogsM~/]xvX!9T:z:{8kimuBw0?h?`V>4;axswUz u:I-?Ix,i&S8]Im?WE{bry
+<RO:!WTeyKSGA@/Orc+(*/jQQREy7-Z(
+AI,_7sq>rS/.x/,%ys )/+*1**K
+zXCxuMaUPUdZSAZ/^#F
+wDUB%W[']7O1J*
+h}UUjuSEw8\roIEq_Yy(
+vDblFa9U95+K2u~gdYmg,vr*5S(2*%27@f
+tfZJefWFWpDT]Y<w9r#_f"/) YTiMh4*#seWUl,UZXqEjbUpu*JPbQ^YqwWL1V!d~Uee~[W^R^+v _XUMx9NA%5E]bY?[I-{7h<|KU3Fl$(.[evsz*,/GEj8Z	wU
+@LX~Jd)"KVdQT6I][(12*WUVl0*W({tHke4Q,CG)P(-&LE@jDVxGkJUD(UTBB UVG
+*s]"vtt2bMd
+)WUTb[Ru/|^P?R*W{G1bT)+m_eqYN5JcU!Bq/tubL*h %=#W(bQR5GDuD"9&Fo*uttM$EB1T% {*-[Y:)wa A}7o~}7o~I=)ZBK]Zo~A8H/DW
+F&^i[XV^Rkc:$wJQx;iYEqzjTS*=CQM/^RWPvl"f9_ABEkIV_,VX%c-5%)r$^3AwN%5)TTT E/^cU/1W[Ydy:u x/-Br&Gn23;B,}%rk<uJ-X/q*T<U\E_UywU[YC"2{DQ5U{e[]Pw6bPR]ZYUQg e+#0yS #*YWUQR55mRbZSXNEsMDCrb*@`V6j\*yQi!lPT^)+#-(YS"c55UbL71S&[&*,B+mm8;r|VG5e5fd:w7-m1g2Q\YR-HZ@=bDcJHjmQjHm`%UUl4V^Yv.TUcWC|AfkK*+1lXbIdzD,diNV4 (# qd;&:,D'a\^VR," MW=WU Sl&#FS\
+_*+9k:@U2
+FV`;	5lWqcjJ1b*OQV,-]W^#dpQ ~LTX\SA	bY>"_e|Mr)t`.PVS'"T~|MV-xa +Kj<px_g4\3n0xg]"<sKTn;
+i$n;W:%L>?|:D
+'ibu5%MBs)`dl\&2
+R[Z~	cV.r1S9l+$m*-,/+6K/=%B)D`
+^&+Ue$a
+_^RX\eE8R&OJJ(QDMiG>.x\
+r(;=!KUK;
+%/1!x\,Ym"<JB)4VcK]Jz#^ib> 8d VLu9\
+o_[<sA*. Mr-6$OhYmMys-=$rf2oQ"Dn[fEKsEs\%Z(N\OT5wTBVDh1\_48Y}+)PIU*A@WRXZr!Ds(VE72*JRd~D]0r_AFl\u#"pU<p,f=%5e*1ZW[@\/+b0KfIX~*HT+JzVxwI6WTeFm =-m(l!_J5M&+JR7%%iK>wdJ^xn=%4\%)j'ApCrix&tIZ;~?7T}'.&D	^FFv
+0UHt]TUY]|y	7d'12
+K
+W	\w-"O+JqJuEe]"p~yd*PzbN*]!gIUSWAY%8Vq
+78=EU25eE"JdY$ kYazW[b.Z8"FC_cs8.#B0FtBe<j.JdwqNKPrNtIP=JI7HwP	G~]'n#^ $7t@D#ro[wyl_$/_NuxwHo?Dtw
+N]"Gx8hpG:%g~t:yxf+)Uxx9qo[T^~>+t	";<wsMvkgNscK3ewL~6\?(Au.p]Ke:L0'yN4fO]Zkil$yWFL"wm0.-yS#G__@In N  
\ No newline at end of file
