diff -uraN u-boot-2016.11/arch/arc/dts/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arc/dts/.gitignore
--- u-boot-2016.11/arch/arc/dts/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arc/dts/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1 +0,0 @@
-*.dtb
diff -uraN u-boot-2016.11/arch/arm/config.mk gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/config.mk
--- u-boot-2016.11/arch/arm/config.mk	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/config.mk	2021-06-07 13:01:31.000000000 +0300
@@ -118,9 +118,9 @@
 
 # limit ourselves to the sections we want in the .bin.
 ifdef CONFIG_ARM64
-OBJCOPYFLAGS += -j .text -j .rodata -j .data -j .u_boot_list -j .rela.dyn
+OBJCOPYFLAGS += -j .text -j .image -j .rodata -j .data -j .u_boot_list -j .rela.dyn
 else
-OBJCOPYFLAGS += -j .text -j .secure_text -j .secure_data -j .rodata -j .hash \
+OBJCOPYFLAGS += -j .text -j .secure_text -j .image -j .secure_data -j .rodata -j .hash \
 		-j .data -j .got -j .got.plt -j .u_boot_list -j .rel.dyn
 endif
 
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/cache_v7.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/cache_v7.c
--- u-boot-2016.11/arch/arm/cpu/armv7/cache_v7.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/cache_v7.c	2021-06-07 13:01:31.000000000 +0300
@@ -117,9 +117,32 @@
  */
 void invalidate_dcache_range(unsigned long start, unsigned long stop)
 {
-	check_cache_range(start, stop);
+	unsigned int align = 0;
 
-	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_INVAL_RANGE);
+	if (!IS_ALIGNED(start, CONFIG_SYS_CACHELINE_SIZE)){
+		align = 1;
+	}
+
+	if (!IS_ALIGNED(stop, CONFIG_SYS_CACHELINE_SIZE)){
+		align = 1;
+	}
+
+	if (!align){
+		v7_dcache_maint_range(start, stop, ARMV7_DCACHE_INVAL_RANGE);
+	}
+	else{
+		u32 line_len, ccsidr;
+
+		ccsidr = get_ccsidr();
+		line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
+				CCSIDR_LINE_SIZE_OFFSET) + 2;
+		/* Converting from words to bytes */
+		line_len += 2;
+		/* converting from log2(linelen) to linelen */
+		line_len = 1 << line_len;
+
+		v7_dcache_clean_inval_range(start, stop, line_len);
+	}
 
 	v7_outer_cache_inval_range(start, stop);
 }
@@ -131,7 +154,6 @@
  */
 void flush_dcache_range(unsigned long start, unsigned long stop)
 {
-	check_cache_range(start, stop);
 
 	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_CLEAN_INVAL_RANGE);
 
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/config.mk gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/config.mk
--- u-boot-2016.11/arch/arm/cpu/armv7/config.mk	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/config.mk	2021-06-07 13:01:31.000000000 +0300
@@ -10,4 +10,5 @@
 # the default so we must pass in -mno-unaligned-access so that it is aware
 # of our decision.
 PF_NO_UNALIGNED := $(call cc-option, -mno-unaligned-access,)
+PF_NO_UNALIGNED += $(call cc-option, -fno-store-merging,)
 PLATFORM_CPPFLAGS += $(PF_NO_UNALIGNED)
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/cpu.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/cpu.c
--- u-boot-2016.11/arch/arm/cpu/armv7/cpu.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/cpu.c	2021-06-07 13:01:31.000000000 +0300
@@ -54,8 +54,9 @@
 		* any static data) So just invalidate the entire d-cache again
 		* to avoid coherency problems for kernel
 		*/
+#ifndef CONFIG_SYS_LEVEL2_CACHE_SHARE
 		invalidate_dcache_all();
-
+#endif
 		icache_disable();
 		invalidate_icache_all();
 	} else {
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/boot_mode.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/boot_mode.c
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/boot_mode.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/boot_mode.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/platform.h>
+
+int get_boot_media(void)
+{
+	unsigned int reg_val, boot_mode, spi_device_mode;
+	int boot_media;
+
+	reg_val = readl(SYS_CTRL_REG_BASE + REG_SYSSTAT);
+	boot_mode = get_sys_boot_mode(reg_val);
+
+	switch (boot_mode) {
+	case BOOT_FROM_SPI:
+		spi_device_mode = get_spi_device_type(reg_val);
+		if (spi_device_mode)
+			boot_media = BOOT_MEDIA_NAND;
+		else
+			boot_media = BOOT_MEDIA_SPIFLASH;
+		break;
+	case BOOT_FROM_EMMC:
+		boot_media = BOOT_MEDIA_EMMC;
+		break;
+	default:
+		boot_media = BOOT_MEDIA_UNKNOWN;
+		break;
+	}
+
+	return boot_media;
+}
+
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/emmc_boot.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/emmc_boot.c
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/emmc_boot.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/emmc_boot.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,181 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <config.h>
+
+#ifdef CONFIG_GENERIC_MMC
+#include <asm/arch/platform.h>
+#include <compiler.h>
+
+#ifndef CONFIG_ASIC
+#define DELAY_US        10
+#else
+#define DELAY_US        1000
+#endif
+
+#define MMC_BLK_SZ      512
+
+/* mmc.h */
+#define MMC_CMD_GO_IDLE_STATE       0
+#define MMC_CMD_SEND_OP_COND        1
+#define MMC_CMD_ALL_SEND_CID        2
+#define MMC_CMD_SET_RELATIVE_ADDR   3
+#define MMC_CMD_SET_DSR         4
+#define MMC_CMD_SWITCH          6
+#define MMC_CMD_SELECT_CARD     7
+#define MMC_CMD_SEND_EXT_CSD        8
+#define MMC_CMD_SEND_CSD        9
+#define MMC_CMD_SEND_CID        10
+#define MMC_CMD_STOP_TRANSMISSION   12
+#define MMC_CMD_SEND_STATUS     13
+#define MMC_CMD_SET_BLOCKLEN        16
+#define MMC_CMD_READ_SINGLE_BLOCK   17
+#define MMC_CMD_READ_MULTIPLE_BLOCK 18
+#define MMC_CMD_WRITE_SINGLE_BLOCK  24
+#define MMC_CMD_WRITE_MULTIPLE_BLOCK    25
+#define MMC_CMD_APP_CMD         55
+#define SD_CMD_SEND_IF_COND     8
+#define SD_CMD_APP_SEND_OP_COND     41
+#define SD_CMD_APP_SET_BUS_WIDTH    6
+
+#define OCR_BUSY        0x80000000
+#define OCR_HCS         0x40000000
+
+#define MMC_VDD_32_33       0x00100000  /* VDD voltage 3.2 ~ 3.3 */
+#define MMC_VDD_33_34       0x00200000  /* VDD voltage 3.3 ~ 3.4 */
+
+#define MMC_SWITCH_MODE_WRITE_BYTE  0x03 /* Set target byte to value */
+
+#define EXT_CSD_BUS_WIDTH   183 /* R/W */
+#define EXT_CSD_HS_TIMING   185 /* R/W */
+
+#define EXT_CSD_BUS_WIDTH_1 0   /* Card is in 1 bit mode */
+#define EXT_CSD_BUS_WIDTH_4 1   /* Card is in 4 bit mode */
+#define EXT_CSD_BUS_WIDTH_8 2   /* Card is in 8 bit mode */
+
+static inline void delay(unsigned int cnt)
+{
+	while (cnt--)
+		__asm__ __volatile__("nop");
+}
+
+#ifdef CONFIG_SDHCI
+#define SDHCI_BUFFER            0x20
+#define SDHCI_INT_STATUS        0x30
+#define SDHCI_INT_DATA_AVAIL    0x00000020
+#define SDHCI_INT_ERROR_MASK    0xFFFF8000
+
+#define debug_printf(fmt, args...) ;
+
+static inline unsigned int sdhci_readl(unsigned addr)
+{
+	uintptr_t reg_addr  = EMMC_BASE_REG + addr;
+
+	return *((volatile unsigned *) (reg_addr));
+}
+
+static inline void sdhci_writel(unsigned val, unsigned addr)
+{
+	uintptr_t reg_addr  = EMMC_BASE_REG + addr;
+
+	(*(volatile unsigned *) (reg_addr)) = (val);
+}
+
+static void sdhci_read_block_pio(void *data_addr, unsigned int block)
+{
+	const unsigned int offset = sizeof(unsigned int);
+	unsigned int size;
+	unsigned char *buf;
+
+	size = MMC_BLK_SZ;
+	buf = (unsigned char *)data_addr + MMC_BLK_SZ * block;
+	while (size) {
+		*(unsigned int *)buf = sdhci_readl(SDHCI_BUFFER);
+		buf += offset;
+		size -= offset;
+	}
+}
+
+int sdhci_check_int_status(unsigned int mask, unsigned int timeout)
+{
+	unsigned int reg;
+
+	for (;;) {
+		reg = sdhci_readl(SDHCI_INT_STATUS);
+		if (reg & mask)
+			break;
+		if (!(--timeout)) {
+			debug_printf("wait int status time out, reg = 0x%x, mask = 0x%x\n",
+						 reg, mask);
+			return -1;
+		}
+		if (reg & SDHCI_INT_ERROR_MASK) {
+			debug_printf("int err: reg = 0x%x\n", reg);
+			return -1;
+		}
+
+		delay(1000 * DELAY_US); /* ms converted to us multiplied by 1000 */
+	}
+
+	return 0;
+}
+
+static void copy_step1_to_ddr(unsigned int *dst, unsigned int *src, unsigned int size)
+{
+	const unsigned int cycle = size / sizeof(unsigned int);
+	unsigned int i;
+
+	for (i = 0; i < cycle; i++)
+		*dst++ = *src++;
+}
+
+#define CP_STEP1_SIZE 0x6000
+int sdhci_read_boot_data(void *data_addr, unsigned int data_size)
+{
+	const unsigned int timeout = 2000; /* 2s timeout: 2000000 * 1us */
+	unsigned int blocks = 0;
+	unsigned int read_block;
+	int ret;
+
+	if (data_size <= CP_STEP1_SIZE) {
+		copy_step1_to_ddr((void *)data_addr, (void *)RAM_START_ADRS, data_size);
+		return 0;
+	} else {
+		copy_step1_to_ddr((void *)data_addr, (void *)RAM_START_ADRS, CP_STEP1_SIZE);
+		data_addr += CP_STEP1_SIZE;
+		data_size -= CP_STEP1_SIZE;
+	}
+
+	if (data_size % MMC_BLK_SZ) {
+		debug_printf("sdhci_read_boot_data error\n");
+		debug_printf("data_size:%d not round by block size\n", data_size);
+		read_block = data_size / MMC_BLK_SZ + 1;
+	} else {
+		read_block = data_size / MMC_BLK_SZ;
+	}
+
+	while (1) {
+		ret = sdhci_check_int_status(SDHCI_INT_DATA_AVAIL, timeout);
+		if (ret) {
+			debug_printf("wait data available int time out\n");
+			return ret;
+		}
+
+		sdhci_writel(SDHCI_INT_DATA_AVAIL, SDHCI_INT_STATUS);
+		sdhci_read_block_pio(data_addr, blocks);
+
+		blocks++;
+		if (blocks == read_block)
+			break;
+	}
+
+	return 0;
+}
+
+void emmc_boot_read(void *ptr, unsigned int size)
+{
+	sdhci_read_boot_data(ptr, size);
+}
+#endif
+#endif
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/hw_decompress.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/hw_decompress.c
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/hw_decompress.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/hw_decompress.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,405 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#include <config.h>
+#include <linux/kconfig.h>
+#include <asm/io.h>
+#include <compiler.h>
+#include <cpu_common.h>
+
+#define error(_s)               uart_early_puts(_s)
+#define putstr(_s)              uart_early_puts(_s)
+
+#define PAGE_SIZE       4096
+#define page_nr(x) (((x) + PAGE_SIZE - 1) / PAGE_SIZE)
+
+/* The base address for emar */
+#define HW_DEC_REG_BASE_ADDR    (GZIP_REG_BASE)
+
+/* The global init registers for emar interface */
+#define EAMR_RID_REG_OFST   0x0108UL
+#define EAMR_ROSD_REG_OFST  0x010CUL
+#define EAMR_WID_REG_OFST   0x0110UL
+#define EAMR_WOSD_REG_OFST  0x0114UL
+
+/* The enable register */
+#define EAMR_WORK_EN_REG_OFST 0x0100UL
+
+#define DPRS_DATA_SRC_BADDR 0x2040UL
+#define DPRS_DATA_SRC_LEN   0x2044UL
+
+/* Decompress parameter reigsters for page address */
+#define DPRS_DATA_RTN_BADDR 0x2020UL
+#define DPRS_DATA_RTN_LEN   0x2024UL
+
+/* Decompress parameter registers for page data */
+#define DPRS_DATA_INFO_BADDR 0x2028UL
+#define DPRS_DATA_INFO_LEN  0x202CUL
+
+#define DPRS_DATA_CRC32     0x2030UL
+
+#define CRC_CHECK_EN        0x4000UL
+
+/* The status registers */
+#define BUF_INFO            0x2080UL
+#define DPRS_RTN_INFO       0x2084UL
+#define DPRS_RTN_LEN        0x2088UL
+#define BUF_INFO_CLR        0x2090UL
+#define RLT_INFO_CLR        0x2094UL
+
+/* The intr registers */
+#define INT_EN_REG_ADDR     0x0128UL
+#define INT_STATUS_REG_ADDR 0x0124UL
+#define INT_CLEAR_REG_ADDR  0x0130UL
+
+#define TASK_MODE_REG       0x2134UL
+
+/* Define the union u_dprs_data_buf_info */
+typedef union {
+	/* Define the struct bits */
+	struct {
+		unsigned int    buf_len: 24; /* [23..0] */
+		unsigned int    buf_id: 2; /* [25..24] */
+		unsigned int    reserved_1: 2; /* [27..26] */
+		unsigned int    eop: 1; /* [28] */
+		unsigned int    sop: 1; /* [29] */
+		unsigned int    reserved_0: 1; /* [30] */
+		unsigned int    mode: 1; /* [31] */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    u32;
+} u_dprs_data_buf_info;
+
+typedef union {
+	struct {
+		unsigned int buf_id: 2; /* [1:0] */
+		unsigned int rsv: 29;   /* [30:2] */
+		unsigned int aval_flg: 1;   /* [31] */
+	} bits;
+	unsigned int u32;
+} u_buf_status;
+
+typedef union {
+	struct {
+		unsigned int err_info: 8;   /* [7:0] */
+		unsigned int rsv: 23;   /* [30:8] */
+		unsigned int aval_flg: 1;   /* [31] */
+	} bits;
+
+	unsigned int u32;
+} u_dprs_rtn_status;
+
+/* Define the union U_INT_EN */
+typedef union {
+	/* Define the struct bits */
+	struct {
+		unsigned int    task_intrpt_en: 1; /* [0] */
+		unsigned int    block_intrpt_en: 1; /* [1] */
+		unsigned int    reserved_0: 30; /* [31..2] */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    u32;
+} u_intr_en;
+
+typedef union {
+	/* Define the struct bits */
+	struct {
+		unsigned int    task_intrpt: 1; /* [0] */
+		unsigned int    block_intrpt: 1; /* [1] */
+		unsigned int    reserved_0: 30; /* [31..2] */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    u32;
+} u_intr_status;
+
+typedef union {
+	/* Define the struct bits */
+	struct {
+		unsigned int    task_intrpt_clr: 1; /* [0] */
+		unsigned int    block_intrpt_clr: 1; /* [1] */
+		unsigned int    reserved_0: 30; /* [31..2] */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    u32;
+} u_intr_clr;
+
+
+#define PERI_CRG100 0x190
+
+#define GZIP_OFFSET PERI_CRG100
+#define GZIP_CLKEN (0x1<<0)
+
+#ifndef GZIP_REG_BASE
+#define GZIP_REG_BASE   0x11310000
+#endif
+
+#define HW_DEC_REG_BASE_ADDR  (GZIP_REG_BASE)
+
+static void disable_decompress_clock(void)
+{
+	unsigned int regval;
+
+	regval = readl(CRG_REG_BASE + GZIP_OFFSET);
+	regval &= ~GZIP_CLKEN;
+	writel(regval, CRG_REG_BASE + GZIP_OFFSET);
+}
+
+static void enable_decompress_clock(void)
+{
+	unsigned int regval;
+
+	regval = readl(CRG_REG_BASE + GZIP_OFFSET);
+	regval |= GZIP_CLKEN;
+	writel(regval, CRG_REG_BASE + GZIP_OFFSET);
+}
+
+
+unsigned int hw_dec_type;
+unsigned int hw_dec_sop;
+unsigned int hw_dec_eop;
+unsigned int hw_dec_cur_blk;
+unsigned int hw_blk_total_num;
+
+void hw_dec_sop_eop_first_set(int block_num)
+{
+	if (block_num == 1) {
+		hw_dec_sop = 1;
+		hw_dec_eop = 1;
+	} else {
+		hw_dec_sop = 1;
+		hw_dec_eop = 0;
+	}
+
+	hw_dec_cur_blk = 0;
+	hw_blk_total_num = block_num;
+}
+
+static inline void hw_dec_work_en_set(int work_en_flg)
+{
+	/* Enable the emar */
+	writel(work_en_flg, HW_DEC_REG_BASE_ADDR + EAMR_WORK_EN_REG_OFST);
+}
+
+static inline void hw_dec_rtn_baddr_set(unsigned int addr)
+{
+	writel(addr, HW_DEC_REG_BASE_ADDR + DPRS_DATA_RTN_BADDR);
+}
+
+static inline void hw_dec_dprs_data_baddr_set(unsigned int addr)
+{
+	writel(addr, HW_DEC_REG_BASE_ADDR + DPRS_DATA_INFO_BADDR);
+}
+
+static inline void hw_dec_data_rtn_len_set(unsigned int len)
+{
+	writel(len, HW_DEC_REG_BASE_ADDR + DPRS_DATA_RTN_LEN);
+}
+
+static inline void hw_dec_dprs_data_len_set(unsigned int len)
+{
+	writel(len, HW_DEC_REG_BASE_ADDR + DPRS_DATA_INFO_LEN);
+}
+
+static inline void hw_dec_crc_check_en(unsigned int crc_en)
+{
+	writel(crc_en, HW_DEC_REG_BASE_ADDR + CRC_CHECK_EN);
+}
+
+static inline void hw_dec_data_crc32_set(unsigned int crc32)
+{
+	writel(crc32, HW_DEC_REG_BASE_ADDR + DPRS_DATA_CRC32);
+}
+
+static inline unsigned int hw_dec_buf_status_get(void)
+{
+	return readl(HW_DEC_REG_BASE_ADDR + BUF_INFO);
+}
+
+static inline unsigned int hw_dec_dprs_rtn_status_get(void)
+{
+	return readl(HW_DEC_REG_BASE_ADDR + DPRS_RTN_INFO);
+}
+
+static inline void hw_dec_buf_status_clr(void)
+{
+	writel(0x1, HW_DEC_REG_BASE_ADDR + BUF_INFO_CLR);
+}
+
+static inline void hw_dec_dprs_rtn_status_clr(void)
+{
+	writel(0x1, HW_DEC_REG_BASE_ADDR + RLT_INFO_CLR);
+}
+
+static void hw_dec_intr_en_set(int blk_intr_en, int task_intr_en)
+{
+	u_intr_en intr_en;
+	intr_en.bits.task_intrpt_en = task_intr_en;
+	intr_en.bits.block_intrpt_en = blk_intr_en;
+	writel(intr_en.u32, HW_DEC_REG_BASE_ADDR + INT_EN_REG_ADDR);
+}
+
+static inline unsigned int hw_dec_intr_status_get(void)
+{
+	return readl(HW_DEC_REG_BASE_ADDR + INT_STATUS_REG_ADDR);
+}
+
+static void hw_dec_block_intr_status_clr(void)
+{
+	u_intr_clr intr_clr;
+
+	intr_clr.u32 = readl(HW_DEC_REG_BASE_ADDR + INT_CLEAR_REG_ADDR);
+	intr_clr.bits.block_intrpt_clr = 0x1;
+	writel(intr_clr.u32, HW_DEC_REG_BASE_ADDR + INT_CLEAR_REG_ADDR);
+}
+
+static void hw_dec_task_intr_status_clr(void)
+{
+	u_intr_clr intr_clr;
+
+	intr_clr.u32 = readl(HW_DEC_REG_BASE_ADDR + INT_CLEAR_REG_ADDR);
+	intr_clr.bits.task_intrpt_clr = 0x1;
+	writel(intr_clr.u32, HW_DEC_REG_BASE_ADDR + INT_CLEAR_REG_ADDR);
+}
+
+int hw_dec_intr_proc(int irq, void *para)
+{
+	u_buf_status buf_status;
+	u_intr_status intr_status;
+	u_dprs_rtn_status dprs_status;
+	int ret = 0;
+
+	intr_status.u32 = hw_dec_intr_status_get();
+	if (intr_status.bits.block_intrpt) {
+		buf_status.u32 = hw_dec_buf_status_get();
+		if (buf_status.bits.aval_flg)
+			hw_dec_buf_status_clr();
+
+		hw_dec_block_intr_status_clr();
+	}
+
+	if (intr_status.bits.task_intrpt) {
+		dprs_status.u32 = hw_dec_dprs_rtn_status_get();
+		if (dprs_status.bits.aval_flg) {
+			if (dprs_status.bits.err_info)
+				ret = -2; /* -2:failed */
+
+			hw_dec_dprs_rtn_status_clr();
+		}
+
+		hw_dec_task_intr_status_clr();
+		goto out;
+	}
+
+	ret = -1;
+out:
+	return ret;
+}
+
+void hw_dec_start(unsigned int src_baddr,
+			unsigned int dst_baddr,
+			unsigned int src_len,
+			unsigned int dst_len,
+			unsigned int crc_en,
+			unsigned int crc32,
+			unsigned int dec_type)
+{
+	unsigned int val;
+
+	if (hw_dec_sop) {
+		if (!dec_type) {
+			/* set the parameters of output buffer */
+			hw_dec_rtn_baddr_set(dst_baddr);
+			hw_dec_data_rtn_len_set(dst_len);
+		} else {
+			/* set the parameter of output buffer */
+			hw_dec_dprs_data_baddr_set(dst_baddr);
+			hw_dec_dprs_data_len_set(page_nr(dst_len) * 4); /* 4:Align */
+		}
+	}
+
+	/* set the parameter of input buffer */
+	writel(src_baddr, HW_DEC_REG_BASE_ADDR + DPRS_DATA_SRC_BADDR);
+
+	val = src_len |
+		(hw_dec_sop << 28) | (hw_dec_eop << 29) | (!dec_type << 31); /* 28,29,31 Move Left bit */
+	writel(val, HW_DEC_REG_BASE_ADDR + DPRS_DATA_SRC_LEN);
+
+	hw_dec_crc_check_en(crc_en);
+}
+
+static inline void delay(unsigned int num)
+{
+	volatile unsigned int i;
+
+	for (i = 0; i < (100 * num); i++) /* 100: Cycle */
+		__asm__ __volatile__("nop");
+}
+
+int hw_dec_wait_finish(void)
+{
+	int ret;
+	int times = 0;
+
+	do {
+		ret = hw_dec_intr_proc(HW_DEC_INTR, NULL);
+		times++;
+		if (times > 2000000) { /* 2000000 ms */
+			error("hardware decompress overtime!\n");
+			break;
+		}
+		delay(1);
+	} while (-1 == ret);
+
+	return ret;
+}
+
+int hw_dec_decompress(unsigned char *dst, int *dstlen,
+			unsigned char *src, int srclen,
+			void *unused)
+{
+	int ret;
+
+	hw_dec_sop_eop_first_set(1);
+	hw_dec_start((unsigned int)(uintptr_t)src, (unsigned int)(uintptr_t)dst,
+				 srclen, *dstlen, 1, 0, hw_dec_type);
+
+	ret = hw_dec_wait_finish();
+
+	*dstlen = readl(HW_DEC_REG_BASE_ADDR + DPRS_RTN_LEN);
+
+	if (ret)
+		return -1;
+
+	return 0;
+}
+
+void hw_dec_init(void)
+{
+	/* enable decompress clock */
+	enable_decompress_clock();
+	/* Init the emar interface */
+	writel(0, HW_DEC_REG_BASE_ADDR + EAMR_RID_REG_OFST);
+	writel(0x3, HW_DEC_REG_BASE_ADDR + EAMR_ROSD_REG_OFST);
+	writel(0, HW_DEC_REG_BASE_ADDR + EAMR_WID_REG_OFST);
+	writel(0x3, HW_DEC_REG_BASE_ADDR + EAMR_WOSD_REG_OFST);
+
+	/* Enable interrupt */
+	hw_dec_intr_en_set(0x1, 0x1);
+
+	/* Enable emar */
+	hw_dec_work_en_set(0x1);
+}
+
+void hw_dec_uinit(void)
+{
+	hw_dec_work_en_set(0x0);
+	hw_dec_intr_en_set(0x0, 0x0);
+
+	/* disable decompress clock */
+	disable_decompress_clock();
+}
+
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/image_data.S gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/image_data.S
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/image_data.S	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/image_data.S	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,9 @@
+.section .image,#alloc
+.globl	input_data
+/*gzip source addr must be 16 bytes aligned*/
+.balign 16
+input_data:
+.incbin   "image_data.gzip"
+
+.globl    input_data_end
+input_data_end:
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/init_registers.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/init_registers.c
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/init_registers.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/init_registers.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,171 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <asm/arch/platform.h>
+#include <compiler.h>
+
+#define W_WHETHER_WRITE     (1<<0)
+#define W_WHETHER_PM        (1<<1)
+#define W_WHETHER_BOOT_NORMAL   (1<<2)
+#define W_BIT_OFFSET        3
+#define W_BIT_MASK          (0x1f<<W_BIT_OFFSET)
+#define W_REG_BIT_OFFSET    11
+#define W_REG_BIT_MASK      (0x1f<<W_REG_BIT_OFFSET)
+
+#define R_WHETHER_READ      (W_WHETHER_WRITE<<16)
+#define R_WHETHER_PM        (W_WHETHER_PM<<16)
+#define R_WHETHER_BOOT_NORMAL   (W_WHETHER_BOOT_NORMAL<<16)
+#define R_BIT_OFFSET        (W_BIT_OFFSET + 16)
+#define R_BIT_MASK          (W_BIT_MASK<<16)
+#define R_REG_BIT_OFFSET    (W_REG_BIT_OFFSET + 16)
+#define R_REG_BIT_MASK      (W_REG_BIT_MASK<<16)
+
+#define RW_BIT_NUM	32
+
+struct regentry {
+	unsigned int reg_addr;
+	unsigned int value;
+	unsigned int delay;
+	unsigned int attr;
+};
+
+static inline void dwb(void) /* drain write buffer */
+{
+}
+
+static inline unsigned int readl(unsigned addr)
+{
+	unsigned int val;
+	val = (*(volatile unsigned int *)(uintptr_t)(addr));
+	return val;
+}
+
+static inline void writel(unsigned val, unsigned addr)
+{
+	dwb();
+	(*(volatile unsigned *)(uintptr_t)(addr)) = val;
+	dwb();
+}
+
+static inline void delay(void)
+{
+	__asm__ __volatile__("nop");
+}
+
+static void reg_read(struct regentry *reg, unsigned int *ret)
+{
+	unsigned int reg_val_r;
+	unsigned int bit_start_r;
+	unsigned int bit_num_r;
+
+	bit_start_r = ((reg->attr & R_REG_BIT_MASK) >> R_REG_BIT_OFFSET);
+	bit_num_r = ((reg->attr & R_BIT_MASK) >> R_BIT_OFFSET) + 1;
+	reg_val_r = (*(volatile unsigned *)(uintptr_t)(reg->reg_addr));
+
+	if (bit_num_r != RW_BIT_NUM) {
+		reg_val_r >>= bit_start_r;
+		reg_val_r &= ((1 << bit_num_r) - 1);
+	}
+
+	*ret = ((reg_val_r == reg->value) ? 0 : 1);
+}
+
+static void reg_write(struct regentry *reg)
+{
+	unsigned int reg_val_w;
+	unsigned int delay_2;
+	unsigned int bit_start_w;
+	unsigned int bit_num_w;
+
+	delay_2 = reg->delay;
+	bit_start_w = ((reg->attr & W_REG_BIT_MASK) >> W_REG_BIT_OFFSET);
+	bit_num_w = ((reg->attr & W_BIT_MASK) >> W_BIT_OFFSET) + 1;
+	reg_val_w = (*(volatile unsigned *)(uintptr_t)(reg->reg_addr));
+
+	if (bit_num_w == RW_BIT_NUM) {
+		reg_val_w = reg->value;
+	} else {
+		reg_val_w &= (~(((1 << bit_num_w) - 1) << bit_start_w));
+		reg_val_w |= (reg->value) << bit_start_w;
+	}
+	writel(reg_val_w, reg->reg_addr);
+
+	do {
+		delay();
+	} while (delay_2--);
+}
+
+static void read_write(struct regentry *reg, unsigned int pm)
+{
+	unsigned int ret;
+	unsigned int delay_1;
+
+	ret = 0;
+	delay_1 = reg->delay;
+
+	if (pm) {
+		if (reg->attr & W_WHETHER_PM) {
+			reg_write(reg);
+		} else if (reg->attr & R_WHETHER_PM) {
+			do {
+				reg_read(reg, &ret);
+				delay();
+			} while (ret);
+
+			do {
+				delay();
+			} while (delay_1--);
+		} else {
+			do {
+				delay();
+			} while (delay_1--);
+		}
+	} else {
+		if (reg->attr & W_WHETHER_BOOT_NORMAL) {
+			reg_write(reg);
+		} else if (reg->attr & R_WHETHER_BOOT_NORMAL) {
+			do {
+				reg_read(reg, &ret);
+				delay();
+			} while (ret);
+
+			do {
+				delay();
+			} while (delay_1--);
+		} else {
+			do {
+				delay();
+			} while (delay_1--);
+		}
+	}
+}
+
+static void part_read_write(struct regentry *reg_table, unsigned int pm)
+{
+	unsigned int i;
+
+	for (i = 0; ; i++) {
+		if ((!reg_table[i].reg_addr) && (!reg_table[i].value) &&
+				(!reg_table[i].delay) && (!reg_table[i].attr))
+			goto main_end;
+
+		read_write(&reg_table[i], pm);
+	}
+
+main_end:
+	delay();
+}
+
+/*
+ * base - reg base address
+ * pm   - is suspend
+ *      0 normal
+ *      1 pm
+ */
+void init_registers(unsigned long base, unsigned long pm)
+{
+	struct regentry *reg_table = (struct regentry *)base;
+
+	part_read_write(reg_table, pm);
+}
\ No newline at end of file
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/lowlevel_init_v300.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/lowlevel_init_v300.c
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/lowlevel_init_v300.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/lowlevel_init_v300.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,465 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <asm/arch/platform.h>
+#include <config.h>
+#include <ddr_training_impl.h>
+#include <compiler.h>
+
+static inline void delay(unsigned int num)
+{
+	volatile unsigned int i;
+
+	for (i = 0; i < (100 * num); i++) /* 100: Cycle */
+		__asm__ __volatile__("nop");
+}
+
+static inline void dwb(void) /* drain write buffer */
+{
+}
+
+static inline unsigned int readl(unsigned addr)
+{
+	unsigned int val;
+
+	val = (*(volatile unsigned int *)(uintptr_t)(addr));
+	return val;
+}
+
+static inline void writel(unsigned val, unsigned addr)
+{
+	dwb();
+	(*(volatile unsigned *)(uintptr_t)(addr)) = val;
+	dwb();
+}
+
+#define REG_BASE_RNG_GEN            0x10090000
+#define TRNG_DSTA_FIFO_DATA_OFST    0x204
+#define TRNG_DATA_ST_OFST           0x208
+#define BIT_TRNG_FIFO_DATA_CNT      0x8
+#define TRNG_FIFO_DATA_CNT_MASK     0xff
+#define REG_PERI_CRG104             0x1a0
+#define TRNG_CLK_ENABLE             (0x1<<3)
+#define TRNG_CLK_DISABLE            ~(0x1<<3)
+#define TRNG_CTRL_DEF_VAL           0xa
+#define SEC_COM_TRNG_CTRL_OFST    0x200
+
+#define REG_BASE_MISC               0x12030000
+#define DDR_CA0_OFST                0x28
+#define DDR_CA1_OFST                0x2C
+#define DDR_CA2_OFST                0x30
+
+#define REG_BASE_DDRC               0x120d0000
+#define DDRC_CTRL_SREF_OFST         (0x8000 + 0x0)
+#define DDRC_CFG_DDRMODE_OFST       (0x8000 + 0x50)
+#define DDRC_CURR_FUNC_OFST         (0x8000 + 0x294)
+
+#define DDRC_CHANNEL_VALID_MASK     0xf
+#define DDRC_SELF_REFURBISH_MASK    0x1
+
+#define DDRC_SELF_REFURBISH_EN      0x1
+#define DDRC_SELF_REFURBISH_EXIT    (0x1 << 1)
+
+#define HPM_CORE_MIN 150
+#define HPM_CORE_MAX 350
+
+#define TEMPERATURE_MIN 117
+#define TEMPERATURE_MAX 841
+
+#define HPM_CORE_VALUE_MIN 190
+#define HPM_CORE_VALUE_MAX 310
+
+#undef reg_get
+#undef reg_set
+#define reg_get(addr) readl(addr)
+#define reg_set(addr, val) writel(val, (unsigned int)(addr))
+#define hpm_formula(hpm, temp)  ((hpm) + 4 + ((((temp) - 70) * 205) >> 10))
+#define volt_formula(val) (1307 - ((1537 * (val)) >> 10))
+#define duty_formula(val) ((unsigned int)((1099 - (val)) * 460) >> 10)
+
+void trng_init(void)
+{
+	unsigned int reg_val;
+	/* open rsa and trng clock */
+	reg_val = reg_get(CRG_REG_BASE + REG_PERI_CRG104);
+	reg_val |= TRNG_CLK_ENABLE;
+	reg_set(CRG_REG_BASE + REG_PERI_CRG104, reg_val);
+
+	/* set trng ctrl register */
+	reg_set(REG_BASE_RNG_GEN + SEC_COM_TRNG_CTRL_OFST,
+			TRNG_CTRL_DEF_VAL);
+}
+
+void trng_deinit(void)
+{
+	unsigned int reg_val;
+
+	/* close rsa and trng clock */
+	reg_val = reg_get(CRG_REG_BASE + REG_PERI_CRG104);
+	reg_val &= TRNG_CLK_DISABLE;
+	reg_set(CRG_REG_BASE + REG_PERI_CRG104, reg_val);
+}
+
+/* svb */
+#define SVB_VER        0x01
+
+#define CYCLE_NUM 4
+#define  HPM_CORE_REG0 0x120280d8
+#define  HPM_CORE_REG1 0x120280dc
+
+#define PWM0_REG 0X12080000
+#define PWM_REG_OFFSET 0x20
+#define PWM_CFG1 0X04
+#define PWM_CTRL 0X0C
+
+#define SVB_VER_REG         0x12020168
+#define HPM_CHECK_REG       0x1202015c
+#define SYS_CTRL_VOLT_REG   0x12020158
+#define SVB_PWM_SEL         0x1202009c
+
+#define TSENSOR_STATUS0 0x120280bc
+#define OTP_HPM_CORE_REG 0x100a002c
+
+static unsigned hpm_value_avg(const unsigned int *val, int num)
+{
+	unsigned int i;
+	unsigned tmp = 0;
+
+	for (i = 0; i < num; i++)
+		tmp += val[i] >> NUM_2;
+
+	return tmp >> NUM_2;
+}
+
+static void get_hpm_value(unsigned int* const hpm_core)
+{
+	int i;
+	unsigned int temp;
+	unsigned int core_value[NUM_4];
+
+	core_value[NUM_0] = 0;
+	core_value[NUM_1] = 0;
+	core_value[NUM_2] = 0;
+	core_value[NUM_3] = 0;
+
+	for (i = 0; i < CYCLE_NUM; i++) {
+		delay(10); /* delay 10ms */
+
+		temp = readl(HPM_CORE_REG0);
+		core_value[NUM_1] += (temp >> 16) & 0x3ff; /* get hight 16 bits */
+		core_value[NUM_0] += temp & 0x3ff;
+		temp = readl(HPM_CORE_REG1);
+		core_value[NUM_3] += (temp >> 16) & 0x3ff; /* get hight 16 bits */
+		core_value[NUM_2] += temp & 0x3ff;
+	}
+
+	*hpm_core = hpm_value_avg(core_value, NUM_4);
+}
+
+static void start_hpm(unsigned int *hpm_core)
+{
+	get_hpm_value(hpm_core);
+}
+
+static void hpm_check(unsigned int *hpm_core)
+{
+	union {
+		struct {
+			unsigned int reserved_0 : 16; /* [15..0] */
+			unsigned int sys_hpm_core : 9; /* [24..16] */
+			unsigned int reserved_1 : 1; /* [25] */
+			unsigned int hpm_core_err : 1; /* [26] */
+			unsigned int reserved_2 : 5; /* [27..31] */
+		} bits;
+
+		unsigned int u32;
+	} sysboot10;
+	sysboot10.u32 = readl(HPM_CHECK_REG);
+	sysboot10.bits.sys_hpm_core = 0;
+	sysboot10.bits.hpm_core_err = 0;
+
+	if (*hpm_core < HPM_CORE_MIN) {
+		*hpm_core = HPM_CORE_MIN;
+		sysboot10.bits.hpm_core_err = 1;
+	}
+	if (*hpm_core > HPM_CORE_MAX) {
+		*hpm_core = HPM_CORE_MAX;
+		sysboot10.bits.hpm_core_err = 1;
+	}
+
+	sysboot10.bits.sys_hpm_core = *hpm_core;
+
+	writel(sysboot10.u32, HPM_CHECK_REG);
+}
+
+
+
+static void set_hpm_core_volt(unsigned int hpm_core_value, unsigned int pwm_id)
+{
+	unsigned int volt;
+	unsigned int duty;
+	unsigned int otp_vmin_core = readl(OTP_HPM_CORE_REG);
+
+	if (hpm_core_value <= HPM_CORE_VALUE_MIN)
+		volt = 1022; /* 1022:volt value */
+	else if (hpm_core_value >= HPM_CORE_VALUE_MAX)
+		volt = 842; /* 842:volt value */
+	else
+		volt = volt_formula(hpm_core_value);
+
+	volt = volt + (int)((short int)(otp_vmin_core >> 16)); /* get hight 16 bits */
+
+	writel(volt, SYS_CTRL_VOLT_REG);
+	duty = duty_formula(volt);
+	writel(duty, PWM0_REG + pwm_id * PWM_REG_OFFSET + PWM_CFG1);
+	writel(0x5, PWM0_REG + pwm_id * PWM_REG_OFFSET +  PWM_CTRL);
+}
+
+void start_svb(void)
+{
+	unsigned int hpm_core = 0;
+	unsigned int pwm_id;
+	
+
+	unsigned int tmp_reg = readl(SVB_VER_REG);
+	tmp_reg = (tmp_reg & 0xff00ffff) | (SVB_VER << 16); /* Move Left 16bit */
+	writel(tmp_reg, SVB_VER_REG);
+
+	
+	start_hpm(&hpm_core);
+	hpm_check(&hpm_core);
+
+	pwm_id = readl(SVB_PWM_SEL) & 0xf;
+	set_hpm_core_volt(hpm_core, pwm_id);
+	delay(160); /* delay 160ms */
+}
+
+/* [CUSTOM] DDR PHY0-PHY1 base register */
+#define DDR_REG_BASE_PHY0       0x120dc000
+
+/* [CUSTOM] DDR DMC0-DMC3 base register */
+#define DDR_REG_BASE_DMC0       0x120d8000
+#define DDR_REG_BASE_DMC1       0x120d8000
+
+#ifdef DDR_REG_BASE_PHY1
+#define DDR_REG_BASE_DMC2       0x120d9000
+#define DDR_REG_BASE_DMC3       0x120d9000
+#endif
+
+#define CRG_REG_BASE            0x12010000
+#define PERI_CRG_DDRT           0x198
+
+#define DDR_REG_BASE_SYSCTRL    0x12020000
+/* [SYSCTRL]RAM Retention control register 0 */
+#define SYSCTRL_MISC_CTRL4      0x8010
+
+#define DDR_PHY_DRAMCFG         0x2c    /* DRAM config register */
+#define PHY_DRAMCFG_TYPE_MASK   0xf /* [3:0] */
+#define PHY_DRAMCFG_TYPE_LPDDR4 0x6   /* [2:0] 110 LPDDR4 */
+
+#define BYTE_NUM  2
+
+/**
+ * ddr_boot_prepare
+ * @void
+ *
+ * Do some prepare before ddr training.
+ * Keep empty when nothing to do.
+ */
+static void ddr_boot_prepare(struct tr_relate_reg* const reg)
+{
+	/* select ddrt bus path */
+	reg->custom.ive_ddrt_mst_sel = readl(DDR_REG_BASE_SYSCTRL + SYSCTRL_MISC_CTRL4);
+	writel(reg->custom.ive_ddrt_mst_sel & 0xffffffdf,
+		   DDR_REG_BASE_SYSCTRL + SYSCTRL_MISC_CTRL4);
+
+	/* turn on ddrt clock */
+	reg->custom.ddrt_clk_reg = readl(CRG_REG_BASE + PERI_CRG_DDRT);
+	/* enable ddrt0 clock */
+	writel(reg->custom.ddrt_clk_reg | (0x1 << 1), CRG_REG_BASE + PERI_CRG_DDRT);
+	__asm__ __volatile__("nop");
+	/* disable ddrt0 soft reset */
+	writel(readl(CRG_REG_BASE + PERI_CRG_DDRT) & (~(0x1 << 0)),
+		   CRG_REG_BASE + PERI_CRG_DDRT);
+
+	/* disable rdqs anti-aging */
+	reg->custom.phy0_age_compst_en = readl(DDR_REG_BASE_PHY0 + DDR_PHY_PHYRSCTRL);
+	writel((reg->custom.phy0_age_compst_en & 0x7fffffff),
+		   DDR_REG_BASE_PHY0 + DDR_PHY_PHYRSCTRL);
+#ifdef DDR_REG_BASE_PHY1
+	reg->custom.phy1_age_compst_en = readl(DDR_REG_BASE_PHY1 + DDR_PHY_PHYRSCTRL);
+	writel((reg->custom.phy1_age_compst_en & 0x7fffffff),
+		   DDR_REG_BASE_PHY1 + DDR_PHY_PHYRSCTRL);
+#endif
+}
+
+/**
+ * ddr_boot_restore
+ * @void
+ *
+ * Restore register config after ddr training.
+ * Keep empty when nothing to do.
+ */
+static void ddr_boot_restore(const struct tr_relate_reg *reg)
+{
+	/* restore ddrt bus path */
+	writel(reg->custom.ive_ddrt_mst_sel, DDR_REG_BASE_SYSCTRL + SYSCTRL_MISC_CTRL4);
+
+	/* restore ddrt clock */
+	writel(reg->custom.ddrt_clk_reg, CRG_REG_BASE + PERI_CRG_DDRT);
+
+	/* restore rdqs anti-aging */
+	writel(reg->custom.phy0_age_compst_en, DDR_REG_BASE_PHY0 + DDR_PHY_PHYRSCTRL);
+#ifdef DDR_REG_BASE_PHY1
+	writel(reg->custom.phy1_age_compst_en, DDR_REG_BASE_PHY1 + DDR_PHY_PHYRSCTRL);
+#endif
+}
+
+/**
+ * ddr_rdqs_bdl_adj
+ * @void
+ *
+ * Adjust rdqs/rdq/rdm bdl to avoid problem cause by ddr anti-aging.
+ */
+#if 0
+static void ddr_rdqs_bdl_adj(void)
+{
+	int i;
+	unsigned int rdqs;
+	unsigned int rdq03;
+	unsigned int rdq47;
+	unsigned int rdm;
+	unsigned int tmp;
+
+	for (i = 0; i < BYTE_NUM; i++) {
+		rdqs = readl(DDR_REG_BASE_PHY0 + 0x22c + i * 0x80);
+		rdq03 = readl(DDR_REG_BASE_PHY0 + 0x21c + i * 0x80);
+		rdq47 = readl(DDR_REG_BASE_PHY0 + 0x220 + i * 0x80);
+		rdm = readl(DDR_REG_BASE_PHY0 + 0x224 + i * 0x80);
+
+		/* rdqs bdl lower two bit shoud be 0x11 */
+		while ((rdqs & 0x3) < 0x3) {
+			/* rdqs/rdq/rdm bdl + 1 */
+			rdqs = rdqs + 0x1;
+			rdq03 = rdq03 + 0x01010101;
+			rdq47 = rdq47 + 0x01010101;
+			rdm = rdm + 0x1;
+
+			writel(rdqs, DDR_REG_BASE_PHY0 + 0x22c + i * 0x80);
+			writel(rdq03, DDR_REG_BASE_PHY0 + 0x21c + i * 0x80);
+			writel(rdq47, DDR_REG_BASE_PHY0 + 0x220 + i * 0x80);
+			writel(rdm, DDR_REG_BASE_PHY0 + 0x224 + i * 0x80);
+		}
+	}
+
+	tmp = readl(DDR_REG_BASE_PHY0 + DDR_PHY_MISC);
+	tmp |= (1 << PHY_MISC_UPDATE_BIT);
+	/* update new config to PHY */
+	writel(tmp, DDR_REG_BASE_PHY0 + DDR_PHY_MISC);
+	tmp &= ~(1 << PHY_MISC_UPDATE_BIT);
+	writel(tmp, DDR_REG_BASE_PHY0 + DDR_PHY_MISC);
+	tmp = readl(DDR_REG_BASE_PHY0 + DDR_PHY_PHYINITCTRL);
+	/* set 1 to issue PHY counter reset signal */
+	tmp |= (1 << PHY_PHYCONN_RST_BIT);
+	writel(tmp, DDR_REG_BASE_PHY0 + DDR_PHY_PHYINITCTRL);
+	/* set 0 to end the reset signal */
+	tmp &= ~(1 << PHY_PHYCONN_RST_BIT);
+	writel(tmp, DDR_REG_BASE_PHY0 + DDR_PHY_PHYINITCTRL);
+}
+#endif
+
+#define OTP_CPU_CLK_OFFSET	0x0084
+#define CRG32_CPU_CLK_OFFSET	0x0080
+#define CRG123_CPU_CLK_OFFSET	0x01EC
+
+static void switch_cpu_freq(void)
+{
+	unsigned int mux_chn;
+	unsigned int reg_val;
+
+	if (readl(SYS_CTRL_REG_BASE + REG_SC_GEN5) != 0x1)
+		return;
+
+	mux_chn = readl(SYS_CTRL_REG_BASE + OTP_CPU_CLK_OFFSET);
+	mux_chn = (mux_chn >> 1) & 0x3;
+
+	reg_val = readl(CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+	reg_val |= 0x3;
+	writel(reg_val, CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+
+	if ((mux_chn == 0) || (mux_chn == 3)) {
+		reg_val = readl(CRG_REG_BASE + CRG123_CPU_CLK_OFFSET);
+		reg_val &= ~0x1;
+		writel(reg_val, CRG_REG_BASE + CRG123_CPU_CLK_OFFSET);
+		delay(1);
+
+		reg_val = readl(CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+		reg_val &= ~0x3;
+		reg_val |= 0x1;
+		writel(reg_val, CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+	} else if (mux_chn == 1) {
+		reg_val = readl(CRG_REG_BASE + CRG123_CPU_CLK_OFFSET);
+		reg_val |= 0x1;
+		writel(reg_val, CRG_REG_BASE + CRG123_CPU_CLK_OFFSET);
+		delay(1);
+
+		reg_val = readl(CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+		reg_val &= ~0x3;
+		writel(reg_val, CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+	} else if (mux_chn == 2) {
+		reg_val = readl(CRG_REG_BASE + CRG123_CPU_CLK_OFFSET);
+		reg_val |= 0x1;
+		writel(reg_val, CRG_REG_BASE + CRG123_CPU_CLK_OFFSET);
+		delay(1);
+
+		reg_val = readl(CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+		reg_val &= ~0x3;
+		reg_val |= 0x2;
+		writel(reg_val, CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+	}
+
+}
+
+void start_ddr_training(unsigned int base)
+{
+	struct tr_relate_reg relate_reg;
+	struct tr_relate_reg *reg = &relate_reg;
+
+	start_svb();
+
+	switch_cpu_freq();
+
+	ddr_boot_prepare(reg);
+
+	/* ddr pcode training */
+//	ddr_pcode_training_if();
+	/* ddr hw training */
+	ddr_hw_training_if();
+	/* ddr sw training */
+	ddr_sw_training_if();
+
+//	ddr_rdqs_bdl_adj();
+
+	ddr_boot_restore(reg);
+
+	/* the value should config after trainning, or
+	  it will cause chip compatibility problems */
+	if ((readl(DDR_REG_BASE_PHY0 + DDR_PHY_DRAMCFG) &
+		PHY_DRAMCFG_TYPE_MASK) == PHY_DRAMCFG_TYPE_LPDDR4) {
+		writel(0x401, DDR_REG_BASE_DMC0 + 0x28);
+		writel(0x401, DDR_REG_BASE_DMC1 + 0x28);
+	} else {
+		writel(0x401, DDR_REG_BASE_DMC0 + 0x28);
+	}
+#ifdef DDR_REG_BASE_PHY1
+	if ((readl(DDR_REG_BASE_PHY1 + DDR_PHY_DRAMCFG) &
+		PHY_DRAMCFG_TYPE_MASK) == PHY_DRAMCFG_TYPE_LPDDR4) {
+		writel(0x401, DDR_REG_BASE_DMC2 + 0x28);
+		writel(0x401, DDR_REG_BASE_DMC3 + 0x28);
+	} else {
+		writel(0x401, DDR_REG_BASE_DMC1 + 0x28);
+	}
+#endif
+	/* enable ddr scramb */
+}
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/Makefile
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/Makefile	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,110 @@
+PWD           = $(shell pwd)
+SRCDIR        =
+OUTDIR        =
+
+################################################################################
+CC       := $(CROSS_COMPILE)gcc
+AR       := $(CROSS_COMPILE)ar
+LD       := $(CROSS_COMPILE)ld
+OBJCOPY  := $(CROSS_COMPILE)objcopy
+
+
+################################################################################
+BOOT     := u-boot-$(SOC)
+TEXTBASE := 0x40700000
+
+CFLAGS   :=-Os -fno-builtin -ffreestanding \
+	-D__KERNEL__ -DTEXT_BASE=$(TEXTBASE) \
+	-I$(SRCDIR)/include \
+	-I$(OUTDIR)/include \
+	-I$(SRCDIR)/drivers/ddr/goke/default \
+	-I$(SRCDIR)/drivers/ddr/goke/$(SOC) \
+	-I$(SRCDIR)/arch/arm/include \
+	-I$(SRCDIR)/lib/hw_dec \
+	-fno-pic -ffunction-sections \
+	-fdata-sections -fno-common -ffixed-r9    \
+	-fno-common -pipe -march=armv7-a \
+	-Wall -Wstrict-prototypes -fno-stack-protector \
+	-D__LINUX_ARM_ARCH__=7 -D__ARM__ \
+	-DCONFIG_MMC\
+	$(MKFLAGS) -fno-strict-aliasing
+
+ifeq ($(ENABLE_MINI_BOOT),y)
+	CFLAGS += -DENABLE_MINI_BOOT
+	UBOOT_LDS := u-boot-mini.lds
+else
+	UBOOT_LDS := u-boot.lds
+endif
+
+################################################################################
+COBJS := start.o \
+	lowlevel_init_v300.o \
+	init_registers.o \
+	uart.o \
+	ddr_training_impl.o \
+	ddr_training_ctl.o \
+	ddr_training_boot.o \
+	ddr_training_custom.o \
+	ddr_training_console.o \
+	hw_decompress.o \
+	startup.o \
+	image_data.o \
+	reset.o
+
+ifneq ($(ENABLE_MINI_BOOT),y)
+COBJS += emmc_boot.o \
+		 div0.o
+endif
+
+REG := $(wildcard $(OUTDIR)/*.reg $(OUTDIR)/.reg)
+
+################################################################################
+.PHONY: $(BOOT).bin
+$(BOOT).bin: $(BOOT).tmp regfile
+	@dd if=./$(BOOT).tmp of=./tmp1 bs=1 count=64 2>/dev/null
+	@dd if=$(REG) of=./tmp2 bs=5120 conv=sync 2>/dev/null
+	@dd if=./$(BOOT).tmp of=./tmp3 bs=1 skip=5184 2>/dev/null
+	@cat tmp1 tmp2 tmp3 > $(BOOT).bin
+	@rm -f tmp1 tmp2 tmp3
+	@chmod 754 $(BOOT).bin
+	@cp -fv $@ $(OUTDIR)
+	@echo $(BOOT).bin is Ready.
+
+$(BOOT).tmp: $(BOOT).elf
+	$(OBJCOPY) -O srec $< $(BOOT).srec
+	$(OBJCOPY) -j .text -O binary $< $(BOOT).text
+	$(OBJCOPY) --gap-fill=0xff -O binary $< $@
+
+$(BOOT).elf: image_data.gzip $(COBJS)
+	$(LD) -Bstatic -T $(UBOOT_LDS) -Ttext $(TEXTBASE) \
+		$(COBJS) -Map $(BOOT).map -o $@
+	$(OBJDUMP) -d  $@ > $@.asm
+
+.PHONY: regfile
+regfile:
+	@if [ "$(words $(REG))" = "0" ]; then ( \
+		echo '***' Need '.reg' or '*.reg' file in directory $(OUTDIR); \
+		exit 1; \
+	) fi
+	@if [ "$(words $(REG))" != "1" ]; then ( \
+		echo '***' Found multi '.reg' or '*.reg' file in directory $(OUTDIR); \
+		echo '***' Files: $(notdir $(REG)); \
+		exit 1; \
+	) fi
+
+################################################################################
+
+# -1 : --fast      -9 : --best
+image_data.gzip: $(BINIMAGE)
+	$(OUTDIR)/../../../tools/utils/bin/gzip -fNqc -7 $< > $@
+
+%.o: %.c
+	$(CC) $(CFLAGS) -Wall -Wstrict-prototypes \
+		-fno-stack-protector -o $@ $< -c
+
+%.o: %.S
+	$(CC) -D__ASSEMBLY__ $(CFLAGS) -o $@ $< -c
+
+image_data.o: image_data.S image_data.gzip
+	$(CC) -D__ASSEMBLY__ $(CFLAGS) -o $@ $< -c
+
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/reset.S gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/reset.S
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/reset.S	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/reset.S	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,18 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <config.h>
+
+.global reset_cpu
+reset_cpu:
+	ldr	r1, rstctl			@ get addr for global reset
+						@ reg
+	mov	r3, #0x2			@ full reset pll + mpu
+	str	r3, [r1]			@ force reset
+	mov	r0, r0
+
+_loop_forever:
+	b	_loop_forever
+rstctl:
+	.word  SYS_CTRL_REG_BASE + REG_SC_SYSRES
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/start.S gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/start.S
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/start.S	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/start.S	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,519 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <asm-offsets.h>
+#include <config.h>
+#include <asm/system.h>
+#include <linux/linkage.h>
+#include <asm/armv7.h>
+
+/*************************************************************************
+ *
+ * Startup Code (reset vector)
+ *
+ * Do important init only if we don't start from memory!
+ * Setup memory and board specific bits prior to relocation.
+ * Relocate armboot to ram. Setup stack.
+ *
+ *************************************************************************/
+.globl	_start
+_start:
+	b	reset
+    b .
+    b .
+    b .
+    b .
+    b .
+    b .
+    b .
+	.balignl 64,0xdeadbeef
+	
+	.globl	reset
+	.globl	save_boot_params_ret
+#ifdef CONFIG_ARMV7_LPAE
+	.global	switch_to_hypervisor_ret
+#endif
+
+ __blank_zone_start:
+	.fill 1024*5,1,0
+__blank_zone_end:
+
+	.globl _blank_zone_start
+_blank_zone_start:
+	.word __blank_zone_start
+
+
+	.globl _blank_zone_end
+_blank_zone_end:
+	.word __blank_zone_end
+
+	.balignl 16,0xdeadbeef
+	.globl	_TEXT_BASE
+_TEXT_BASE:
+	.word TEXT_BASE
+ 
+
+_clr_remap_fmc_entry:
+	.word   FMC_MEM_BASE + do_clr_remap - CONFIG_SYS_TEXT_BASE_ORI
+
+_start_armboot:
+	.word start_armboot
+
+reset:
+	/* Allow the board to save important registers */
+	b	save_boot_params
+save_boot_params_ret:
+#ifdef CONFIG_ARMV7_LPAE
+/*
+ * check for Hypervisor support
+ */
+	mrc	p15, 0, r0, c0, c1, 1		@ read ID_PFR1
+	and	r0, r0, #CPUID_ARM_VIRT_MASK	@ mask virtualization bits
+	cmp	r0, #(1 << CPUID_ARM_VIRT_SHIFT)
+	beq	switch_to_hypervisor
+switch_to_hypervisor_ret:
+#endif
+	/*
+	 * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,
+	 * except if in HYP mode already
+	 */
+	mrs	r0, cpsr
+	and	r1, r0, #0x1f		@ mask mode bits
+	teq	r1, #0x1a		@ test for HYP mode
+	bicne	r0, r0, #0x1f		@ clear all mode bits
+	orrne	r0, r0, #0x13		@ set SVC mode
+	orr	r0, r0, #0xc0		@ disable FIQ and IRQ
+	msr	cpsr,r0
+
+/*
+ * Setup vector:
+ * (OMAP4 spl TEXT_BASE is not 32 byte aligned.
+ * Continue to use ROM code vector only in OMAP4 spl)
+ */
+#if !(defined(CONFIG_OMAP44XX) && defined(CONFIG_SPL_BUILD))
+	/* Set V=0 in CP15 SCTLR register - for VBAR to point to vector */
+	mrc	p15, 0, r0, c1, c0, 0	@ Read CP15 SCTLR Register
+	bic	r0, #CR_V		@ V = 0
+	mcr	p15, 0, r0, c1, c0, 0	@ Write CP15 SCTLR Register
+
+	/* Set vector address in CP15 VBAR register */
+	adrl	r0, _start
+	mcr	p15, 0, r0, c12, c0, 0	@Set VBAR
+#endif
+
+	/* the mask ROM code should have PLL and others stable */
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
+	bl	cpu_init_cp15
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT_ONLY
+	bl	cpu_init_crit
+#endif
+#endif
+
+#ifndef CONFIG_GK_DISABLE_DOWNLOAD
+	/*
+	 *  read system register REG_SC_GEN2
+         *  check if ziju flag
+	 */
+	ldr	r0, =SYS_CTRL_REG_BASE
+	ldr	r1, [r0, #REG_SC_GEN2]
+	ldr	r2, =0x7a696a75          /* magic for "ziju" */
+	cmp	r1, r2
+	bne	normal_start_flow
+	mov	r1, sp                   /* save sp */
+	str	r1, [r0, #REG_SC_GEN2]  /* clear ziju flag */
+
+    /* init PLL/DDRC/pin mux/... */
+	ldr	r0, _blank_zone_start
+	ldr	r1, _TEXT_BASE
+	sub	r0, r0, r1
+	ldr	r1, =RAM_START_ADRS
+	ldr	sp, =STACK_TRAINING
+	add	r0, r0, r1
+	mov	r1, #0x0                 /* flags: 0->normal 1->pm */
+	bl	init_registers           /* init PLL/DDRC/... */
+	/* after ziju, we need ddr traning */
+	ldr	r0, =SYS_CTRL_REG_BASE
+	bl	start_ddr_training       /* DDR training */
+    ldr	r0, =SYS_CTRL_REG_BASE
+	ldr	r1, [r0, #REG_SC_GEN2]
+	mov	sp, r1		         /* restore sp */
+	ldr	r1, [r0, #REG_SC_GEN3]
+	mov	pc, r1                  /* return to bootrom */
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	b	.                        /* bug here */
+
+normal_start_flow:
+#endif
+	/* init serial and printf a string. */
+	ldr     sp, =STACK_TRAINING
+#ifdef ENABLE_MINI_BOOT
+	bl	timer_init
+#else
+	bl      uart_early_init
+	bl      msg_main_cpu_startup
+#endif
+
+	/*
+	 * enable syscnt 
+	 */
+	ldr	r0, =SYSCNT_REG_BASE
+	ldr 	r3, =SYSCNT_FREQ
+	str	r3, [r0, #SYSCNT_FREQ_REG]
+	mov	r3, #0x1
+	str	r3, [r0, #SYSCNT_ENABLE_REG]
+
+	@if running not boot from nand/spi/emmc,
+	@we skipping boot_type checking.
+	mov    r0, pc, lsr#24
+	cmp    r0, #0x0
+	bne    do_clr_remap
+
+check_boot_type:
+#ifndef ENABLE_MINI_BOOT
+    ldr     r0, =SYS_CTRL_REG_BASE
+    ldr     r0, [r0, #REG_SYSSTAT]
+    mov     r6, r0, lsr#4
+	and     r6, #0x1
+    cmp     r6, #0x1
+    ldrlo   pc, _clr_remap_fmc_entry
+#else
+	ldr pc, _clr_remap_fmc_entry
+#endif
+
+do_clr_remap:
+#ifndef ENABLE_MINI_BOOT
+        /* do clear remap */
+	ldr     r4, =SYS_CTRL_REG_BASE
+	ldr	r0, [r4, #REG_SC_CTRL]
+
+	@Set clear remap bit.
+	orr	r0, #(1<<8)
+	str	r0, [r4, #REG_SC_CTRL]
+#endif
+	@enable I-Cache now
+	mrc p15, 0, r0, c1, c0, 0
+    orr r0, r0, #0x00001000 /* set bit 12 (I) I-Cache */
+    mcr p15, 0, r0, c1, c0, 0
+
+	@Check wether I'm running in dynamic mem bank:<0x40000000
+	mov r0, pc, lsr#28
+	cmp r0, #4
+	blo	ddr_init
+
+no_ddr_init:
+	adrl	r0, _start
+	b       copy_to_ddr
+
+ddr_init:
+	ldr     r0, _blank_zone_start
+	ldr     r1, _TEXT_BASE
+	sub     r0, r0, r1
+	adrl	r1, _start
+	add     r0, r0, r1
+	mov     r1, #0          /* flags: 0->normal 1->pm */
+	bl      init_registers
+
+	ldr	sp, =STACK_TRAINING
+	ldr	r0, =SYS_CTRL_REG_BASE
+	bl	start_ddr_training       /* DDR training */
+
+check_boot_mode:
+#ifndef ENABLE_MINI_BOOT
+	ldr	r0, =SYS_CTRL_REG_BASE
+	ldr     r0, [r0, #REG_SYSSTAT]
+	mov     r6, r0, lsr#4
+	and	r6, #0x1
+	cmp     r6, #BOOT_FROM_EMMC
+	bne     copy_flash_to_ddr
+#else
+	b copy_flash_to_ddr
+#endif
+
+#ifndef ENABLE_MINI_BOOT
+emmc_boot:
+	ldr     r0, _TEXT_BASE
+	ldr	r1, =__image_copy_start
+	ldr	r2, =__bss_start
+	sub	r1, r2, r1
+	bl	emmc_boot_read
+	b       relocate
+#endif
+
+copy_flash_to_ddr:
+	/* relocate SPI nor/nand Boot to DDR  */
+	ldr	r0, =FMC_MEM_BASE
+
+copy_to_ddr:
+	/* now, r0 stores __reset offset from where we get started */
+	ldr     r1, =__image_copy_start
+
+	/* compare source and target address, *
+	 *if equal no copy to target address */
+	cmp     r0, r1
+	beq	start_armboot
+
+	ldr     r2, =__image_copy_start/*_start*/
+	ldr     r3, =__bss_start
+	sub     r2, r3, r2      /* r2 <- size of armboot */
+	/* memcpy(r1, r0, r2) */
+	bl      memcpy
+
+relocate:
+	ldr r0, =_start_armboot
+	ldr pc, [r0]
+
+bug:
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	b       .                       /* bug here */
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+@
+@       void memcpy(r1, r0, r2);
+@
+
+.align  2
+memcpy:
+	add     r2, r0, r2
+	memcpy_loop:
+	ldmia   r0!, {r3 - r10}
+	stmia   r1!, {r3 - r10}
+	cmp     r0, r2
+	ble     memcpy_loop
+	mov     pc, lr
+
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+.align  2
+msg_main_cpu_startup:
+	mov     r5, lr
+	add     r0, pc, #4
+	bl      uart_early_puts
+	mov     pc, r5
+	L10:
+#ifndef CONFIG_SUPPORT_CA_RELEASE
+	.ascii "\r\n\r\nSystem startup\r\n\0"
+#else
+	.ascii "\r\n\r\n\r\n\0"
+#endif
+
+/*------------------------------------------------------------------------------*/
+
+ENTRY(c_runtime_cpu_setup)
+/*
+ * If I-cache is enabled invalidate it
+ */
+#ifndef CONFIG_SYS_ICACHE_OFF
+	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
+	mcr     p15, 0, r0, c7, c10, 4	@ DSB
+	mcr     p15, 0, r0, c7, c5, 4	@ ISB
+#endif
+
+	bx	lr
+
+ENDPROC(c_runtime_cpu_setup)
+
+/*************************************************************************
+ *
+ * void save_boot_params(u32 r0, u32 r1, u32 r2, u32 r3)
+ *	__attribute__((weak));
+ *
+ * Stack pointer is not yet initialized at this moment
+ * Don't save anything to stack even if compiled with -O0
+ *
+ *************************************************************************/
+ENTRY(save_boot_params)
+	b	save_boot_params_ret		@ back to my caller
+ENDPROC(save_boot_params)
+	.weak	save_boot_params
+
+#ifdef CONFIG_ARMV7_LPAE
+ENTRY(switch_to_hypervisor)
+	b	switch_to_hypervisor_ret
+ENDPROC(switch_to_hypervisor)
+	.weak	switch_to_hypervisor
+#endif
+
+/*************************************************************************
+ *
+ * cpu_init_cp15
+ *
+ * Setup CP15 registers (cache, MMU, TLBs). The I-cache is turned on unless
+ * CONFIG_SYS_ICACHE_OFF is defined.
+ *
+ *************************************************************************/
+ENTRY(cpu_init_cp15)
+	/*
+	 * Invalidate L1 I/D
+	 */
+	mov	r0, #0			@ set up for MCR
+	mcr	p15, 0, r0, c8, c7, 0	@ invalidate TLBs
+	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
+	mcr	p15, 0, r0, c7, c5, 6	@ invalidate BP array
+	mcr     p15, 0, r0, c7, c10, 4	@ DSB
+	mcr     p15, 0, r0, c7, c5, 4	@ ISB
+
+	/*
+	 * disable MMU stuff and caches
+	 */
+	mrc	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #0x00002000	@ clear bits 13 (--V-)
+	bic	r0, r0, #0x00000007	@ clear bits 2:0 (-CAM)
+	orr	r0, r0, #0x00000002	@ set bit 1 (--A-) Align
+	orr	r0, r0, #0x00000800	@ set bit 11 (Z---) BTB
+#ifdef CONFIG_SYS_ICACHE_OFF
+	bic	r0, r0, #0x00001000	@ clear bit 12 (I) I-cache
+#else
+	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-cache
+#endif
+	mcr	p15, 0, r0, c1, c0, 0
+
+#ifdef CONFIG_ARM_ERRATA_716044
+	mrc	p15, 0, r0, c1, c0, 0	@ read system control register
+	orr	r0, r0, #1 << 11	@ set bit #11
+	mcr	p15, 0, r0, c1, c0, 0	@ write system control register
+#endif
+
+#if (defined(CONFIG_ARM_ERRATA_742230) || defined(CONFIG_ARM_ERRATA_794072))
+	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register
+	orr	r0, r0, #1 << 4		@ set bit #4
+	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_743622
+	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register
+	orr	r0, r0, #1 << 6		@ set bit #6
+	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_751472
+	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register
+	orr	r0, r0, #1 << 11	@ set bit #11
+	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register
+#endif
+#ifdef CONFIG_ARM_ERRATA_761320
+	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register
+	orr	r0, r0, #1 << 21	@ set bit #21
+	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register
+#endif
+
+	mov	r5, lr			@ Store my Caller
+	mrc	p15, 0, r1, c0, c0, 0	@ r1 has Read Main ID Register (MIDR)
+	mov	r3, r1, lsr #20		@ get variant field
+	and	r3, r3, #0xf		@ r3 has CPU variant
+	and	r4, r1, #0xf		@ r4 has CPU revision
+	mov	r2, r3, lsl #4		@ shift variant field for combined value
+	orr	r2, r4, r2		@ r2 has combined CPU variant + revision
+
+#ifdef CONFIG_ARM_ERRATA_798870
+	cmp	r2, #0x30		@ Applies to lower than R3p0
+	bge	skip_errata_798870      @ skip if not affected rev
+	cmp	r2, #0x20		@ Applies to including and above R2p0
+	blt	skip_errata_798870      @ skip if not affected rev
+
+	mrc	p15, 1, r0, c15, c0, 0  @ read l2 aux ctrl reg
+	orr	r0, r0, #1 << 7         @ Enable hazard-detect timeout
+	push	{r1-r5}			@ Save the cpu info registers
+	bl	v7_arch_cp15_set_l2aux_ctrl
+	isb				@ Recommended ISB after l2actlr update
+	pop	{r1-r5}			@ Restore the cpu info - fall through
+skip_errata_798870:
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_801819
+	cmp	r2, #0x24		@ Applies to lt including R2p4
+	bgt	skip_errata_801819      @ skip if not affected rev
+	cmp	r2, #0x20		@ Applies to including and above R2p0
+	blt	skip_errata_801819      @ skip if not affected rev
+	mrc	p15, 0, r0, c0, c0, 6	@ pick up REVIDR reg
+	and	r0, r0, #1 << 3		@ check REVIDR[3]
+	cmp	r0, #1 << 3
+	beq	skip_errata_801819	@ skip erratum if REVIDR[3] is set
+
+	mrc	p15, 0, r0, c1, c0, 1	@ read auxilary control register
+	orr	r0, r0, #3 << 27	@ Disables streaming. All write-allocate
+					@ lines allocate in the L1 or L2 cache.
+	orr	r0, r0, #3 << 25	@ Disables streaming. All write-allocate
+					@ lines allocate in the L1 cache.
+	push	{r1-r5}			@ Save the cpu info registers
+	bl	v7_arch_cp15_set_acr
+	pop	{r1-r5}			@ Restore the cpu info - fall through
+skip_errata_801819:
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_454179
+	cmp	r2, #0x21		@ Only on < r2p1
+	bge	skip_errata_454179
+
+	mrc	p15, 0, r0, c1, c0, 1	@ Read ACR
+	orr	r0, r0, #(0x3 << 6)	@ Set DBSM(BIT7) and IBE(BIT6) bits
+	push	{r1-r5}			@ Save the cpu info registers
+	bl	v7_arch_cp15_set_acr
+	pop	{r1-r5}			@ Restore the cpu info - fall through
+
+skip_errata_454179:
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_430973
+	cmp	r2, #0x21		@ Only on < r2p1
+	bge	skip_errata_430973
+
+	mrc	p15, 0, r0, c1, c0, 1	@ Read ACR
+	orr	r0, r0, #(0x1 << 6)	@ Set IBE bit
+	push	{r1-r5}			@ Save the cpu info registers
+	bl	v7_arch_cp15_set_acr
+	pop	{r1-r5}			@ Restore the cpu info - fall through
+
+skip_errata_430973:
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_621766
+	cmp	r2, #0x21		@ Only on < r2p1
+	bge	skip_errata_621766
+
+	mrc	p15, 0, r0, c1, c0, 1	@ Read ACR
+	orr	r0, r0, #(0x1 << 5)	@ Set L1NEON bit
+	push	{r1-r5}			@ Save the cpu info registers
+	bl	v7_arch_cp15_set_acr
+	pop	{r1-r5}			@ Restore the cpu info - fall through
+
+skip_errata_621766:
+#endif
+
+	mov	pc, r5			@ back to my caller
+ENDPROC(cpu_init_cp15)
+
+#if !defined(CONFIG_SKIP_LOWLEVEL_INIT) && \
+	!defined(CONFIG_SKIP_LOWLEVEL_INIT_ONLY)
+/*************************************************************************
+ *
+ * CPU_init_critical registers
+ *
+ * setup important registers
+ * setup memory timing
+ *
+ *************************************************************************/
+ENTRY(cpu_init_crit)
+	/*
+	 * Jump to board specific initialization...
+	 * The Mask ROM will have already initialized
+	 * basic memory. Go here to bump up clock rate and handle
+	 * wake up conditions.
+	 */
+	b	lowlevel_init		@ go setup pll,mux,memory
+ENDPROC(cpu_init_crit)
+#endif
+
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/startup.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/startup.c
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/startup.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/startup.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,246 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <config.h>
+#include <linux/kconfig.h>
+#include <asm/io.h>
+#include <compiler.h>
+#include <cpu_common.h>
+
+extern unsigned int hw_dec_type;
+
+extern void hw_dec_init(void);
+extern int hw_dec_decompress(unsigned char *dst, int *dstlen,
+		      unsigned char *src, int srclen,
+		      void *unused);
+extern void hw_dec_uinit(void);
+
+/******************************************************************************/
+const uintptr_t image_entry = (CONFIG_SYS_TEXT_BASE);
+
+/******************************************************************************/
+
+#define GZIP_SIZE_OFFSET 0x4
+
+#ifndef CONFIG_SYS_ICACHE_OFF
+/* Invalidate entire I-cache and branch predictor array */
+static void invalidate_icache_all(void)
+{
+	/*
+	 * Invalidate all instruction caches to PoU.
+	 * Also flushes branch target cache.
+	 */
+	asm volatile("mcr p15, 0, %0, c7, c5, 0" : : "r"(0));
+
+	/* Invalidate entire branch predictor array */
+	asm volatile("mcr p15, 0, %0, c7, c5, 6" : : "r"(0));
+
+	/* Full system DSB - make sure that the invalidation is complete */
+	dsb();
+
+	/* ISB - make sure the instruction stream sees it */
+	isb();
+}
+#else
+static void invalidate_icache_all(void)
+{
+}
+#endif
+
+#ifdef CONFIG_MINI_BOOT
+
+#ifndef bit
+#define bit(x) (1 << (x))
+#endif
+
+#define TIME2_CLK_SEL  bit(18)
+
+int timer_init(void)
+{
+	/*
+	 * Under uboot, 0xffffffff is set to load register,
+	 * timer_clk equals BUSCLK/2/256.
+	 * e.g. BUSCLK equals 50M, it will roll back after 0xffffffff/timer_clk
+	 * 43980s equals 12hours
+	 */
+	__raw_writel(0, CFG_TIMERBASE + REG_TIMER_CONTROL);
+	__raw_writel(~0, CFG_TIMERBASE + REG_TIMER_RELOAD);
+
+	/* 32 bit, periodic */
+	__raw_writel(CFG_TIMER_CTRL, CFG_TIMERBASE + REG_TIMER_CONTROL);
+
+	/* start timer2 with mode below */
+	unsigned int reg;
+
+	reg = __raw_readl(SYS_CTRL_REG_BASE + REG_SC_CTRL);
+	/* for timer2,use sys BUS clk */
+	reg |= TIME2_CLK_SEL;
+	__raw_writel(reg, SYS_CTRL_REG_BASE + REG_SC_CTRL);
+
+	/* disable timer2 */
+	__raw_writel(0, TIMER2_REG_BASE + REG_TIMER_CONTROL);
+	/* timer2 load */
+	__raw_writel(~0, TIMER2_REG_BASE + REG_TIMER_RELOAD);
+
+	/*
+	 * Timing mode: 32bits [bit 1 set as 1]
+	 * ticking with 1/256 clock frequency [bit 3 set as 1, bit 2 set as 0]
+	 * timing circulary [bit 6 set as 1]
+	 * timer enabled [bit 7 set as 1]
+	 */
+	reg = (1 << 7) | (1 << 6) | (1 << 3) | (1 << 1);
+	__raw_writel(reg, TIMER2_REG_BASE + REG_TIMER_CONTROL);
+
+	return 0;
+}
+
+#define TIME_STAMP_CNT      0x12020138
+#define TIME_STAMP_VALUE    0x04010050
+#define CONFIG_TIME_STAMP_ENABLE
+
+void time_stamp(const char *strfunc, int nline, int type)
+{
+#ifdef CONFIG_TIME_STAMP_ENABLE
+	static int init_flag = 0;
+	unsigned int cnt;
+	unsigned int stamp;
+	unsigned int *addr = NULL;
+
+	if (!init_flag) {
+		init_flag = 1;
+		*(unsigned int *)TIME_STAMP_CNT = 0;
+	}
+
+	cnt = *(unsigned int *)TIME_STAMP_CNT;
+	stamp = *(unsigned int *)(TIMER2_REG_BASE + REG_TIMER_VALUE);
+	addr = (unsigned int *)(TIME_STAMP_VALUE + cnt * 16); /* 16:The number in the formula */
+
+	*addr = ~stamp;
+	addr++;
+	*addr = (uintptr_t)strfunc;
+	addr++;
+	*addr = nline;
+	addr++;
+	*addr = type;
+	cnt++;
+	*(unsigned int *)TIME_STAMP_CNT = cnt;
+#endif
+}
+#endif
+
+
+/******************************************************************************/
+void start_armboot(void)
+{
+	unsigned char *pdst_l32 = NULL;
+	unsigned int image_data_len;
+	int pdst_len;
+	int ret;
+	int i;
+	char *p = NULL;
+	char *q = NULL;
+
+#ifndef CONFIG_MINI_BOOT
+	uart_early_init();
+	uart_early_puts("\r\nUncompress ");
+#endif
+
+	/* use direct address mode */
+	hw_dec_type = 0;
+	/* init hw decompress IP */
+	hw_dec_init();
+
+	/* start decompress */
+	pdst_l32 = (unsigned char *)image_entry;
+	image_data_len = input_data_end - input_data;
+
+	/* get dets length from compress image */
+	p = (char *)&pdst_len;
+	q = (char *)(input_data_end - GZIP_SIZE_OFFSET);
+	for (i = 0; i < sizeof(int); i++)
+		p[i] = q[i];
+
+	ret = hw_dec_decompress(pdst_l32, &pdst_len, input_data,
+						image_data_len, NULL);
+	if (!ret) {
+#ifndef CONFIG_MINI_BOOT
+		uart_early_puts("Ok!");
+#endif
+	} else {
+#ifndef CONFIG_MINI_BOOT
+		uart_early_puts("Fail!");
+#endif
+		while (1);
+	}
+
+	/* uinit hw decompress IP */
+	hw_dec_uinit();
+	void (*uboot)(void);
+	uboot = (void (*))CONFIG_SYS_TEXT_BASE;
+	invalidate_icache_all();
+	uboot();
+}
+
+void hang(void)
+{
+	uart_early_puts("### ERROR ### Please RESET the board ###\n");
+	for (; ;) ;
+}
+
+
+void do_bad_sync(void)
+{
+	uart_early_puts("bad sync abort\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_sync(void)
+{
+	uart_early_puts("sync abort\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_bad_error(void)
+{
+	uart_early_puts("bad error\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_error(void)
+{
+	uart_early_puts("error\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_bad_fiq(void)
+{
+	uart_early_puts("bad fast interrupt request\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_bad_irq(void)
+{
+	uart_early_puts("bad interrupt request\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_fiq(void)
+{
+	uart_early_puts("fast interrupt request\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_irq(void)
+{
+	uart_early_puts("interrupt request\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/uart.S gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/uart.S
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/uart.S	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/uart.S	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,126 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <config.h>
+
+@******************************************************************************
+@
+@  void uart_early_init(void);
+@
+.text
+.align	2
+.global	uart_early_init
+.type	uart_early_init, %function
+uart_early_init:
+#ifndef CONFIG_GK_DISABLE_CONSOLE
+	ldr	a4, uart_base_addr_L0
+	mov	a3, #0
+	/* Disable UART */
+	str	a3, [a4, #48]
+	/* Set baud rate to 115200, uart clock:24M */
+	add	a3, a3, #13
+	str	a3, [a4, #36]
+	mov	a3, #1
+	str	a3, [a4, #40]
+	/* Set the UART to be 8 bits, 1 stop bit, no parity, fifo enabled. */
+	ldr	a3, =112
+	str	a3, [a4, #44]
+	/* Enable UART */
+	ldr	a3, =769
+	str	a3, [a4, #48]
+#endif
+	bx	lr
+uart_base_addr_L0:
+	.word CONFIG_CUR_UART_BASE
+
+@******************************************************************************
+@
+@  void uart_early_puts(const char *ss);
+@
+.align	2
+.global	uart_early_puts
+.type	uart_early_puts, %function
+uart_early_puts:
+#ifndef CONFIG_GK_DISABLE_CONSOLE
+#if !defined(CONFIG_SUPPORT_CA_RELEASE)
+	ldr	a2, uart_base_addr_L1
+	b	next_char
+output:
+	ldr	a4, [a2, #24]
+	tst	a4, #32
+	bne	output
+	str	a3, [a2, #0]
+	add	a1, a1, #1
+next_char:
+	ldrb	a3, [a1]
+	cmp	a3, #0
+	bne	output
+#endif /* CONFIG_SUPPORT_CA_RELEASE */
+#endif /* CONFIG_GK_DISABLE_CONSOLE */
+	bx	lr
+uart_base_addr_L1:
+	.word CONFIG_CUR_UART_BASE
+
+@******************************************************************************
+@
+@  void uart_early_put_hex(int hex);
+@
+@  call example:
+@    mov	r0, sp
+@    bl	uart_early_put_hex
+@
+.align	2
+.global	uart_early_put_hex
+.type	uart_early_put_hex, %function
+uart_early_put_hex:
+#if !defined(CONFIG_SUPPORT_CA_RELEASE)
+	ldr	a2, uart_base_addr_L2
+	mov	a3, #28
+wait2:
+	ldr	a4, [a2, #24]
+	tst	a4, #32
+	bne	wait2
+
+	mov	a4, #0xF
+	and	a4, a4, a1, lsr a3
+	cmp	a4, #9
+	addle	a4, a4, #0x30	@ a4 = a4 + '0'
+	addgt	a4, a4, #55	@ a4 = a4 - 10 + 'A'
+	str	a4, [a2, #0]
+	cmp	a3, #0
+	beq	exit2
+	sub	a3, a3, #4
+	b	wait2
+exit2:
+#endif /* CONFIG_SUPPORT_CA_RELEASE */
+	bx	lr
+uart_base_addr_L2:
+	.word CONFIG_CUR_UART_BASE
+
+@******************************************************************************
+@
+@  void uart_early_putc(int chr);
+@
+@  call example:
+@    mov	r0, #'A'
+@    bl	uart_early_putc
+@
+.align	2
+.global	uart_early_putc
+.type	uart_early_putc, %function
+uart_early_putc:
+#ifndef CONFIG_GK_DISABLE_CONSOLE
+#if !defined(CONFIG_SUPPORT_CA_RELEASE)
+	ldr	a2, uart_base_addr_L3
+wait3:
+	ldr	a4, [a2, #24]
+	tst	a4, #32
+	bne	wait3
+	str	a1, [a2, #0]
+
+#endif /* CONFIG_SUPPORT_CA_RELEASE */
+#endif /* CONFIG_GK_DISABLE_CONSOLE */
+	bx	lr
+uart_base_addr_L3:
+	.word CONFIG_CUR_UART_BASE
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/u-boot.lds gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/u-boot.lds
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/u-boot.lds	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/u-boot.lds	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,52 @@
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x40700000;
+	__image_copy_start =.;
+	. = ALIGN(4);
+	.text	:
+	{
+		__text_start = .;
+		start.o (.text*)
+		init_registers.o (.text*)
+		lowlevel_init_v300.o (.text*)
+		ddr_training_impl.o (.text*)
+		ddr_training_console.o (.text*)
+		ddr_training_ctl.o (.text*)
+		ddr_training_boot.o (.text*)
+		ddr_training_custom.o (.text*)
+		uart.o (.text*)
+		div0.o (.text*)
+		emmc_boot.o (.text*)
+		image_data.o (.text*)
+		hw_decompress.o (.text*)
+		startup.o(.text*)
+		reset.o(.text*)
+		__init_end = .;
+		ASSERT(((__init_end - __text_start) < 0x6000), "init sections too big!");
+		*(.text*)
+	}
+	__text_end = .;
+
+	. = ALIGN(4);
+	.image : { *(.image) }
+
+	. = ALIGN(4);
+	.rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = ALIGN(4);
+	__image_copy_end =.;
+	__bss_start = .;
+	.bss : { *(.bss) }
+	__bss_end = .;
+	_end = .;
+}
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/u-boot-mini.lds gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/u-boot-mini.lds
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7202v300/u-boot-mini.lds	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7202v300/u-boot-mini.lds	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,50 @@
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x40700000;
+	__image_copy_start =.;
+	. = ALIGN(4);
+	.text	:
+	{
+		__text_start = .;
+		start.o (.text*)
+		init_registers.o (.text*)
+		lowlevel_init_v300.o (.text*)
+		ddr_training_impl.o (.text*)
+		ddr_training_console.o (.text*)
+		ddr_training_ctl.o (.text*)
+		ddr_training_boot.o (.text*)
+		ddr_training_custom.o (.text*)
+		uart.o (.text*)
+		image_data.o (.text*)
+		hw_decompress.o (.text*)
+		startup.o(.text*)
+		reset.o(.text*)
+		__init_end = .;
+		ASSERT(((__init_end - __text_start) < 0x6000), "init sections too big!");
+		*(.text*)
+	}
+	__text_end = .;
+
+	. = ALIGN(4);
+	.image : { *(.image) }
+
+	. = ALIGN(4);
+	.rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = ALIGN(4);
+	__image_copy_end =.;
+	__bss_start = .;
+	.bss : { *(.bss) }
+	__bss_end = .;
+	_end = .;
+}
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/boot_mode.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/boot_mode.c
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/boot_mode.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/boot_mode.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/platform.h>
+
+int get_boot_media(void)
+{
+	unsigned int reg_val, boot_mode, spi_device_mode;
+	int boot_media;
+
+	reg_val = readl(SYS_CTRL_REG_BASE + REG_SYSSTAT);
+	boot_mode = get_sys_boot_mode(reg_val);
+
+	switch (boot_mode) {
+	case BOOT_FROM_SPI:
+		spi_device_mode = get_spi_device_type(reg_val);
+		if (spi_device_mode)
+			boot_media = BOOT_MEDIA_NAND;
+		else
+			boot_media = BOOT_MEDIA_SPIFLASH;
+		break;
+	case BOOT_FROM_EMMC:
+		boot_media = BOOT_MEDIA_EMMC;
+		break;
+	default:
+		boot_media = BOOT_MEDIA_UNKNOWN;
+		break;
+	}
+
+	return boot_media;
+}
+
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/emmc_boot.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/emmc_boot.c
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/emmc_boot.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/emmc_boot.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,181 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <config.h>
+
+#ifdef CONFIG_GENERIC_MMC
+#include <asm/arch/platform.h>
+#include <compiler.h>
+
+#ifndef CONFIG_ASIC
+#define DELAY_US        10
+#else
+#define DELAY_US        1000
+#endif
+
+#define MMC_BLK_SZ      512
+
+/* mmc.h */
+#define MMC_CMD_GO_IDLE_STATE       0
+#define MMC_CMD_SEND_OP_COND        1
+#define MMC_CMD_ALL_SEND_CID        2
+#define MMC_CMD_SET_RELATIVE_ADDR   3
+#define MMC_CMD_SET_DSR         4
+#define MMC_CMD_SWITCH          6
+#define MMC_CMD_SELECT_CARD     7
+#define MMC_CMD_SEND_EXT_CSD        8
+#define MMC_CMD_SEND_CSD        9
+#define MMC_CMD_SEND_CID        10
+#define MMC_CMD_STOP_TRANSMISSION   12
+#define MMC_CMD_SEND_STATUS     13
+#define MMC_CMD_SET_BLOCKLEN        16
+#define MMC_CMD_READ_SINGLE_BLOCK   17
+#define MMC_CMD_READ_MULTIPLE_BLOCK 18
+#define MMC_CMD_WRITE_SINGLE_BLOCK  24
+#define MMC_CMD_WRITE_MULTIPLE_BLOCK    25
+#define MMC_CMD_APP_CMD         55
+#define SD_CMD_SEND_IF_COND     8
+#define SD_CMD_APP_SEND_OP_COND     41
+#define SD_CMD_APP_SET_BUS_WIDTH    6
+
+#define OCR_BUSY        0x80000000
+#define OCR_HCS         0x40000000
+
+#define MMC_VDD_32_33       0x00100000  /* VDD voltage 3.2 ~ 3.3 */
+#define MMC_VDD_33_34       0x00200000  /* VDD voltage 3.3 ~ 3.4 */
+
+#define MMC_SWITCH_MODE_WRITE_BYTE  0x03 /* Set target byte to value */
+
+#define EXT_CSD_BUS_WIDTH   183 /* R/W */
+#define EXT_CSD_HS_TIMING   185 /* R/W */
+
+#define EXT_CSD_BUS_WIDTH_1 0   /* Card is in 1 bit mode */
+#define EXT_CSD_BUS_WIDTH_4 1   /* Card is in 4 bit mode */
+#define EXT_CSD_BUS_WIDTH_8 2   /* Card is in 8 bit mode */
+
+static inline void delay(unsigned int cnt)
+{
+	while (cnt--)
+		__asm__ __volatile__("nop");
+}
+
+#ifdef CONFIG_SDHCI
+#define SDHCI_BUFFER            0x20
+#define SDHCI_INT_STATUS        0x30
+#define SDHCI_INT_DATA_AVAIL    0x00000020
+#define SDHCI_INT_ERROR_MASK    0xFFFF8000
+
+#define debug_printf(fmt, args...) ;
+
+static inline unsigned int sdhci_readl(unsigned addr)
+{
+	uintptr_t reg_addr  = EMMC_BASE_REG + addr;
+
+	return *((volatile unsigned *) (reg_addr));
+}
+
+static inline void sdhci_writel(unsigned val, unsigned addr)
+{
+	uintptr_t reg_addr  = EMMC_BASE_REG + addr;
+
+	(*(volatile unsigned *) (reg_addr)) = (val);
+}
+
+static void sdhci_read_block_pio(void *data_addr, unsigned int block)
+{
+	const unsigned int offset = sizeof(unsigned int);
+	unsigned int size;
+	unsigned char *buf;
+
+	size = MMC_BLK_SZ;
+	buf = (unsigned char *)data_addr + MMC_BLK_SZ * block;
+	while (size) {
+		*(unsigned int *)buf = sdhci_readl(SDHCI_BUFFER);
+		buf += offset;
+		size -= offset;
+	}
+}
+
+int sdhci_check_int_status(unsigned int mask, unsigned int timeout)
+{
+	unsigned int reg;
+
+	for (;;) {
+		reg = sdhci_readl(SDHCI_INT_STATUS);
+		if (reg & mask)
+			break;
+		if (!(--timeout)) {
+			debug_printf("wait int status time out, reg = 0x%x, mask = 0x%x\n",
+						 reg, mask);
+			return -1;
+		}
+		if (reg & SDHCI_INT_ERROR_MASK) {
+			debug_printf("int err: reg = 0x%x\n", reg);
+			return -1;
+		}
+
+		delay(1000 * DELAY_US); /* ms converted to us multiplied by 1000 */
+	}
+
+	return 0;
+}
+
+static void copy_step1_to_ddr(unsigned int *dst, unsigned int *src, unsigned int size)
+{
+	const unsigned int cycle = size / sizeof(unsigned int);
+	unsigned int i;
+
+	for (i = 0; i < cycle; i++)
+		*dst++ = *src++;
+}
+
+#define CP_STEP1_SIZE 0x6000
+int sdhci_read_boot_data(void *data_addr, unsigned int data_size)
+{
+	const unsigned int timeout = 2000; /* 2s timeout: 2000000 * 1us */
+	unsigned int blocks = 0;
+	unsigned int read_block;
+	int ret;
+
+	if (data_size <= CP_STEP1_SIZE) {
+		copy_step1_to_ddr((void *)data_addr, (void *)RAM_START_ADRS, data_size);
+		return 0;
+	} else {
+		copy_step1_to_ddr((void *)data_addr, (void *)RAM_START_ADRS, CP_STEP1_SIZE);
+		data_addr += CP_STEP1_SIZE;
+		data_size -= CP_STEP1_SIZE;
+	}
+
+	if (data_size % MMC_BLK_SZ) {
+		debug_printf("sdhci_read_boot_data error\n");
+		debug_printf("data_size:%d not round by block size\n", data_size);
+		read_block = data_size / MMC_BLK_SZ + 1;
+	} else {
+		read_block = data_size / MMC_BLK_SZ;
+	}
+
+	while (1) {
+		ret = sdhci_check_int_status(SDHCI_INT_DATA_AVAIL, timeout);
+		if (ret) {
+			debug_printf("wait data available int time out\n");
+			return ret;
+		}
+
+		sdhci_writel(SDHCI_INT_DATA_AVAIL, SDHCI_INT_STATUS);
+		sdhci_read_block_pio(data_addr, blocks);
+
+		blocks++;
+		if (blocks == read_block)
+			break;
+	}
+
+	return 0;
+}
+
+void emmc_boot_read(void *ptr, unsigned int size)
+{
+	sdhci_read_boot_data(ptr, size);
+}
+#endif
+#endif
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/hw_decompress.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/hw_decompress.c
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/hw_decompress.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/hw_decompress.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,405 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#include <config.h>
+#include <linux/kconfig.h>
+#include <asm/io.h>
+#include <compiler.h>
+#include <cpu_common.h>
+
+#define error(_s)               uart_early_puts(_s)
+#define putstr(_s)              uart_early_puts(_s)
+
+#define PAGE_SIZE       4096
+#define page_nr(x) (((x) + PAGE_SIZE - 1) / PAGE_SIZE)
+
+/* The base address for emar */
+#define HW_DEC_REG_BASE_ADDR    (GZIP_REG_BASE)
+
+/* The global init registers for emar interface */
+#define EAMR_RID_REG_OFST   0x0108UL
+#define EAMR_ROSD_REG_OFST  0x010CUL
+#define EAMR_WID_REG_OFST   0x0110UL
+#define EAMR_WOSD_REG_OFST  0x0114UL
+
+/* The enable register */
+#define EAMR_WORK_EN_REG_OFST 0x0100UL
+
+#define DPRS_DATA_SRC_BADDR 0x2040UL
+#define DPRS_DATA_SRC_LEN   0x2044UL
+
+/* Decompress parameter reigsters for page address */
+#define DPRS_DATA_RTN_BADDR 0x2020UL
+#define DPRS_DATA_RTN_LEN   0x2024UL
+
+/* Decompress parameter registers for page data */
+#define DPRS_DATA_INFO_BADDR 0x2028UL
+#define DPRS_DATA_INFO_LEN  0x202CUL
+
+#define DPRS_DATA_CRC32     0x2030UL
+
+#define CRC_CHECK_EN        0x4000UL
+
+/* The status registers */
+#define BUF_INFO            0x2080UL
+#define DPRS_RTN_INFO       0x2084UL
+#define DPRS_RTN_LEN        0x2088UL
+#define BUF_INFO_CLR        0x2090UL
+#define RLT_INFO_CLR        0x2094UL
+
+/* The intr registers */
+#define INT_EN_REG_ADDR     0x0128UL
+#define INT_STATUS_REG_ADDR 0x0124UL
+#define INT_CLEAR_REG_ADDR  0x0130UL
+
+#define TASK_MODE_REG       0x2134UL
+
+/* Define the union u_dprs_data_buf_info */
+typedef union {
+	/* Define the struct bits */
+	struct {
+		unsigned int    buf_len: 24; /* [23..0] */
+		unsigned int    buf_id: 2; /* [25..24] */
+		unsigned int    reserved_1: 2; /* [27..26] */
+		unsigned int    eop: 1; /* [28] */
+		unsigned int    sop: 1; /* [29] */
+		unsigned int    reserved_0: 1; /* [30] */
+		unsigned int    mode: 1; /* [31] */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    u32;
+} u_dprs_data_buf_info;
+
+typedef union {
+	struct {
+		unsigned int buf_id: 2; /* [1:0] */
+		unsigned int rsv: 29;   /* [30:2] */
+		unsigned int aval_flg: 1;   /* [31] */
+	} bits;
+	unsigned int u32;
+} u_buf_status;
+
+typedef union {
+	struct {
+		unsigned int err_info: 8;   /* [7:0] */
+		unsigned int rsv: 23;   /* [30:8] */
+		unsigned int aval_flg: 1;   /* [31] */
+	} bits;
+
+	unsigned int u32;
+} u_dprs_rtn_status;
+
+/* Define the union U_INT_EN */
+typedef union {
+	/* Define the struct bits */
+	struct {
+		unsigned int    task_intrpt_en: 1; /* [0] */
+		unsigned int    block_intrpt_en: 1; /* [1] */
+		unsigned int    reserved_0: 30; /* [31..2] */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    u32;
+} u_intr_en;
+
+typedef union {
+	/* Define the struct bits */
+	struct {
+		unsigned int    task_intrpt: 1; /* [0] */
+		unsigned int    block_intrpt: 1; /* [1] */
+		unsigned int    reserved_0: 30; /* [31..2] */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    u32;
+} u_intr_status;
+
+typedef union {
+	/* Define the struct bits */
+	struct {
+		unsigned int    task_intrpt_clr: 1; /* [0] */
+		unsigned int    block_intrpt_clr: 1; /* [1] */
+		unsigned int    reserved_0: 30; /* [31..2] */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    u32;
+} u_intr_clr;
+
+
+#define PERI_CRG100 0x190
+
+#define GZIP_OFFSET PERI_CRG100
+#define GZIP_CLKEN (0x1<<0)
+
+#ifndef GZIP_REG_BASE
+#define GZIP_REG_BASE   0x11310000
+#endif
+
+#define HW_DEC_REG_BASE_ADDR  (GZIP_REG_BASE)
+
+static void disable_decompress_clock(void)
+{
+	unsigned int regval;
+
+	regval = readl(CRG_REG_BASE + GZIP_OFFSET);
+	regval &= ~GZIP_CLKEN;
+	writel(regval, CRG_REG_BASE + GZIP_OFFSET);
+}
+
+static void enable_decompress_clock(void)
+{
+	unsigned int regval;
+
+	regval = readl(CRG_REG_BASE + GZIP_OFFSET);
+	regval |= GZIP_CLKEN;
+	writel(regval, CRG_REG_BASE + GZIP_OFFSET);
+}
+
+
+unsigned int hw_dec_type;
+unsigned int hw_dec_sop;
+unsigned int hw_dec_eop;
+unsigned int hw_dec_cur_blk;
+unsigned int hw_blk_total_num;
+
+void hw_dec_sop_eop_first_set(int block_num)
+{
+	if (block_num == 1) {
+		hw_dec_sop = 1;
+		hw_dec_eop = 1;
+	} else {
+		hw_dec_sop = 1;
+		hw_dec_eop = 0;
+	}
+
+	hw_dec_cur_blk = 0;
+	hw_blk_total_num = block_num;
+}
+
+static inline void hw_dec_work_en_set(int work_en_flg)
+{
+	/* Enable the emar */
+	writel(work_en_flg, HW_DEC_REG_BASE_ADDR + EAMR_WORK_EN_REG_OFST);
+}
+
+static inline void hw_dec_rtn_baddr_set(unsigned int addr)
+{
+	writel(addr, HW_DEC_REG_BASE_ADDR + DPRS_DATA_RTN_BADDR);
+}
+
+static inline void hw_dec_dprs_data_baddr_set(unsigned int addr)
+{
+	writel(addr, HW_DEC_REG_BASE_ADDR + DPRS_DATA_INFO_BADDR);
+}
+
+static inline void hw_dec_data_rtn_len_set(unsigned int len)
+{
+	writel(len, HW_DEC_REG_BASE_ADDR + DPRS_DATA_RTN_LEN);
+}
+
+static inline void hw_dec_dprs_data_len_set(unsigned int len)
+{
+	writel(len, HW_DEC_REG_BASE_ADDR + DPRS_DATA_INFO_LEN);
+}
+
+static inline void hw_dec_crc_check_en(unsigned int crc_en)
+{
+	writel(crc_en, HW_DEC_REG_BASE_ADDR + CRC_CHECK_EN);
+}
+
+static inline void hw_dec_data_crc32_set(unsigned int crc32)
+{
+	writel(crc32, HW_DEC_REG_BASE_ADDR + DPRS_DATA_CRC32);
+}
+
+static inline unsigned int hw_dec_buf_status_get(void)
+{
+	return readl(HW_DEC_REG_BASE_ADDR + BUF_INFO);
+}
+
+static inline unsigned int hw_dec_dprs_rtn_status_get(void)
+{
+	return readl(HW_DEC_REG_BASE_ADDR + DPRS_RTN_INFO);
+}
+
+static inline void hw_dec_buf_status_clr(void)
+{
+	writel(0x1, HW_DEC_REG_BASE_ADDR + BUF_INFO_CLR);
+}
+
+static inline void hw_dec_dprs_rtn_status_clr(void)
+{
+	writel(0x1, HW_DEC_REG_BASE_ADDR + RLT_INFO_CLR);
+}
+
+static void hw_dec_intr_en_set(int blk_intr_en, int task_intr_en)
+{
+	u_intr_en intr_en;
+	intr_en.bits.task_intrpt_en = task_intr_en;
+	intr_en.bits.block_intrpt_en = blk_intr_en;
+	writel(intr_en.u32, HW_DEC_REG_BASE_ADDR + INT_EN_REG_ADDR);
+}
+
+static inline unsigned int hw_dec_intr_status_get(void)
+{
+	return readl(HW_DEC_REG_BASE_ADDR + INT_STATUS_REG_ADDR);
+}
+
+static void hw_dec_block_intr_status_clr(void)
+{
+	u_intr_clr intr_clr;
+
+	intr_clr.u32 = readl(HW_DEC_REG_BASE_ADDR + INT_CLEAR_REG_ADDR);
+	intr_clr.bits.block_intrpt_clr = 0x1;
+	writel(intr_clr.u32, HW_DEC_REG_BASE_ADDR + INT_CLEAR_REG_ADDR);
+}
+
+static void hw_dec_task_intr_status_clr(void)
+{
+	u_intr_clr intr_clr;
+
+	intr_clr.u32 = readl(HW_DEC_REG_BASE_ADDR + INT_CLEAR_REG_ADDR);
+	intr_clr.bits.task_intrpt_clr = 0x1;
+	writel(intr_clr.u32, HW_DEC_REG_BASE_ADDR + INT_CLEAR_REG_ADDR);
+}
+
+int hw_dec_intr_proc(int irq, void *para)
+{
+	u_buf_status buf_status;
+	u_intr_status intr_status;
+	u_dprs_rtn_status dprs_status;
+	int ret = 0;
+
+	intr_status.u32 = hw_dec_intr_status_get();
+	if (intr_status.bits.block_intrpt) {
+		buf_status.u32 = hw_dec_buf_status_get();
+		if (buf_status.bits.aval_flg)
+			hw_dec_buf_status_clr();
+
+		hw_dec_block_intr_status_clr();
+	}
+
+	if (intr_status.bits.task_intrpt) {
+		dprs_status.u32 = hw_dec_dprs_rtn_status_get();
+		if (dprs_status.bits.aval_flg) {
+			if (dprs_status.bits.err_info)
+				ret = -2; /* -2:failed */
+
+			hw_dec_dprs_rtn_status_clr();
+		}
+
+		hw_dec_task_intr_status_clr();
+		goto out;
+	}
+
+	ret = -1;
+out:
+	return ret;
+}
+
+void hw_dec_start(unsigned int src_baddr,
+			unsigned int dst_baddr,
+			unsigned int src_len,
+			unsigned int dst_len,
+			unsigned int crc_en,
+			unsigned int crc32,
+			unsigned int dec_type)
+{
+	unsigned int val;
+
+	if (hw_dec_sop) {
+		if (!dec_type) {
+			/* set the parameters of output buffer */
+			hw_dec_rtn_baddr_set(dst_baddr);
+			hw_dec_data_rtn_len_set(dst_len);
+		} else {
+			/* set the parameter of output buffer */
+			hw_dec_dprs_data_baddr_set(dst_baddr);
+			hw_dec_dprs_data_len_set(page_nr(dst_len) * 4); /* 4:Align */
+		}
+	}
+
+	/* set the parameter of input buffer */
+	writel(src_baddr, HW_DEC_REG_BASE_ADDR + DPRS_DATA_SRC_BADDR);
+
+	val = src_len |
+		(hw_dec_sop << 28) | (hw_dec_eop << 29) | (!dec_type << 31); /* 28,29,31 Move Left bit */
+	writel(val, HW_DEC_REG_BASE_ADDR + DPRS_DATA_SRC_LEN);
+
+	hw_dec_crc_check_en(crc_en);
+}
+
+static inline void delay(unsigned int num)
+{
+	volatile unsigned int i;
+
+	for (i = 0; i < (100 * num); i++) /* 100: Cycle */
+		__asm__ __volatile__("nop");
+}
+
+int hw_dec_wait_finish(void)
+{
+	int ret;
+	int times = 0;
+
+	do {
+		ret = hw_dec_intr_proc(HW_DEC_INTR, NULL);
+		times++;
+		if (times > 2000000) { /* 2000000 ms */
+			error("hardware decompress overtime!\n");
+			break;
+		}
+		delay(1);
+	} while (-1 == ret);
+
+	return ret;
+}
+
+int hw_dec_decompress(unsigned char *dst, int *dstlen,
+			unsigned char *src, int srclen,
+			void *unused)
+{
+	int ret;
+
+	hw_dec_sop_eop_first_set(1);
+	hw_dec_start((unsigned int)(uintptr_t)src, (unsigned int)(uintptr_t)dst,
+				 srclen, *dstlen, 1, 0, hw_dec_type);
+
+	ret = hw_dec_wait_finish();
+
+	*dstlen = readl(HW_DEC_REG_BASE_ADDR + DPRS_RTN_LEN);
+
+	if (ret)
+		return -1;
+
+	return 0;
+}
+
+void hw_dec_init(void)
+{
+	/* enable decompress clock */
+	enable_decompress_clock();
+	/* Init the emar interface */
+	writel(0, HW_DEC_REG_BASE_ADDR + EAMR_RID_REG_OFST);
+	writel(0x3, HW_DEC_REG_BASE_ADDR + EAMR_ROSD_REG_OFST);
+	writel(0, HW_DEC_REG_BASE_ADDR + EAMR_WID_REG_OFST);
+	writel(0x3, HW_DEC_REG_BASE_ADDR + EAMR_WOSD_REG_OFST);
+
+	/* Enable interrupt */
+	hw_dec_intr_en_set(0x1, 0x1);
+
+	/* Enable emar */
+	hw_dec_work_en_set(0x1);
+}
+
+void hw_dec_uinit(void)
+{
+	hw_dec_work_en_set(0x0);
+	hw_dec_intr_en_set(0x0, 0x0);
+
+	/* disable decompress clock */
+	disable_decompress_clock();
+}
+
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/image_data.S gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/image_data.S
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/image_data.S	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/image_data.S	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,9 @@
+.section .image,#alloc
+.globl	input_data
+/*gzip source addr must be 16 bytes aligned*/
+.balign 16
+input_data:
+.incbin   "image_data.gzip"
+
+.globl    input_data_end
+input_data_end:
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/init_registers.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/init_registers.c
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/init_registers.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/init_registers.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,171 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <asm/arch/platform.h>
+#include <compiler.h>
+
+#define W_WHETHER_WRITE     (1<<0)
+#define W_WHETHER_PM        (1<<1)
+#define W_WHETHER_BOOT_NORMAL   (1<<2)
+#define W_BIT_OFFSET        3
+#define W_BIT_MASK          (0x1f<<W_BIT_OFFSET)
+#define W_REG_BIT_OFFSET    11
+#define W_REG_BIT_MASK      (0x1f<<W_REG_BIT_OFFSET)
+
+#define R_WHETHER_READ      (W_WHETHER_WRITE<<16)
+#define R_WHETHER_PM        (W_WHETHER_PM<<16)
+#define R_WHETHER_BOOT_NORMAL   (W_WHETHER_BOOT_NORMAL<<16)
+#define R_BIT_OFFSET        (W_BIT_OFFSET + 16)
+#define R_BIT_MASK          (W_BIT_MASK<<16)
+#define R_REG_BIT_OFFSET    (W_REG_BIT_OFFSET + 16)
+#define R_REG_BIT_MASK      (W_REG_BIT_MASK<<16)
+
+#define RW_BIT_NUM	32
+
+struct regentry {
+	unsigned int reg_addr;
+	unsigned int value;
+	unsigned int delay;
+	unsigned int attr;
+};
+
+static inline void dwb(void) /* drain write buffer */
+{
+}
+
+static inline unsigned int readl(unsigned addr)
+{
+	unsigned int val;
+	val = (*(volatile unsigned int *)(uintptr_t)(addr));
+	return val;
+}
+
+static inline void writel(unsigned val, unsigned addr)
+{
+	dwb();
+	(*(volatile unsigned *)(uintptr_t)(addr)) = val;
+	dwb();
+}
+
+static inline void delay(void)
+{
+	__asm__ __volatile__("nop");
+}
+
+static void reg_read(struct regentry *reg, unsigned int *ret)
+{
+	unsigned int reg_val_r;
+	unsigned int bit_start_r;
+	unsigned int bit_num_r;
+
+	bit_start_r = ((reg->attr & R_REG_BIT_MASK) >> R_REG_BIT_OFFSET);
+	bit_num_r = ((reg->attr & R_BIT_MASK) >> R_BIT_OFFSET) + 1;
+	reg_val_r = (*(volatile unsigned *)(uintptr_t)(reg->reg_addr));
+
+	if (bit_num_r != RW_BIT_NUM) {
+		reg_val_r >>= bit_start_r;
+		reg_val_r &= ((1 << bit_num_r) - 1);
+	}
+
+	*ret = ((reg_val_r == reg->value) ? 0 : 1);
+}
+
+static void reg_write(struct regentry *reg)
+{
+	unsigned int reg_val_w;
+	unsigned int delay_2;
+	unsigned int bit_start_w;
+	unsigned int bit_num_w;
+
+	delay_2 = reg->delay;
+	bit_start_w = ((reg->attr & W_REG_BIT_MASK) >> W_REG_BIT_OFFSET);
+	bit_num_w = ((reg->attr & W_BIT_MASK) >> W_BIT_OFFSET) + 1;
+	reg_val_w = (*(volatile unsigned *)(uintptr_t)(reg->reg_addr));
+
+	if (bit_num_w == RW_BIT_NUM) {
+		reg_val_w = reg->value;
+	} else {
+		reg_val_w &= (~(((1 << bit_num_w) - 1) << bit_start_w));
+		reg_val_w |= (reg->value) << bit_start_w;
+	}
+	writel(reg_val_w, reg->reg_addr);
+
+	do {
+		delay();
+	} while (delay_2--);
+}
+
+static void read_write(struct regentry *reg, unsigned int pm)
+{
+	unsigned int ret;
+	unsigned int delay_1;
+
+	ret = 0;
+	delay_1 = reg->delay;
+
+	if (pm) {
+		if (reg->attr & W_WHETHER_PM) {
+			reg_write(reg);
+		} else if (reg->attr & R_WHETHER_PM) {
+			do {
+				reg_read(reg, &ret);
+				delay();
+			} while (ret);
+
+			do {
+				delay();
+			} while (delay_1--);
+		} else {
+			do {
+				delay();
+			} while (delay_1--);
+		}
+	} else {
+		if (reg->attr & W_WHETHER_BOOT_NORMAL) {
+			reg_write(reg);
+		} else if (reg->attr & R_WHETHER_BOOT_NORMAL) {
+			do {
+				reg_read(reg, &ret);
+				delay();
+			} while (ret);
+
+			do {
+				delay();
+			} while (delay_1--);
+		} else {
+			do {
+				delay();
+			} while (delay_1--);
+		}
+	}
+}
+
+static void part_read_write(struct regentry *reg_table, unsigned int pm)
+{
+	unsigned int i;
+
+	for (i = 0; ; i++) {
+		if ((!reg_table[i].reg_addr) && (!reg_table[i].value) &&
+				(!reg_table[i].delay) && (!reg_table[i].attr))
+			goto main_end;
+
+		read_write(&reg_table[i], pm);
+	}
+
+main_end:
+	delay();
+}
+
+/*
+ * base - reg base address
+ * pm   - is suspend
+ *      0 normal
+ *      1 pm
+ */
+void init_registers(unsigned long base, unsigned long pm)
+{
+	struct regentry *reg_table = (struct regentry *)base;
+
+	part_read_write(reg_table, pm);
+}
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/lowlevel_init_v300.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/lowlevel_init_v300.c
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/lowlevel_init_v300.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/lowlevel_init_v300.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,462 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#include <compiler.h>
+#include <asm/arch/platform.h>
+#include <config.h>
+#include <ddr_training_impl.h>
+
+static inline void delay(unsigned int num)
+{
+	volatile unsigned int i;
+
+	for (i = 0; i < (100 * num); i++) /* 100: Cycle */
+		__asm__ __volatile__("nop");
+}
+
+static inline void dwb(void) /* drain write buffer */
+{
+}
+
+static inline unsigned int readl(unsigned addr)
+{
+	unsigned int val;
+
+	val = (*(volatile unsigned int *)((uintptr_t)(addr)));
+	return val;
+}
+
+static inline void writel(unsigned val, unsigned addr)
+{
+	dwb();
+	(*(volatile unsigned *)((uintptr_t)(addr))) = (val);
+	dwb();
+}
+
+#define REG_BASE_RNG_GEN	    0x10090000
+#define TRNG_DSTA_FIFO_DATA_OFST    0x204
+#define TRNG_DATA_ST_OFST           0x208
+#define BIT_TRNG_FIFO_DATA_CNT      0x8
+#define TRNG_FIFO_DATA_CNT_MASK     0xff
+#define REG_PERI_CRG104             0x1a0
+#define TRNG_CLK_ENABLE             (0x1<<3)
+#define TRNG_CLK_DISABLE            ~(0x1<<3)
+#define TRNG_CTRL_DEF_VAL           0xa
+#define SEC_COM_TRNG_CTRL_OFST    0x200
+
+#define REG_BASE_MISC               0x12030000
+#define DDR_CA0_OFST                0x28
+#define DDR_CA1_OFST                0x2C
+#define DDR_CA2_OFST                0x30
+
+#define REG_BASE_DDRC               0x120d0000
+#define DDRC_CTRL_SREF_OFST         (0x8000 + 0x0)
+#define DDRC_CFG_DDRMODE_OFST       (0x8000 + 0x50)
+#define DDRC_CURR_FUNC_OFST         (0x8000 + 0x294)
+
+#define DDRC_CHANNEL_VALID_MASK     0xf
+#define DDRC_SELF_REFURBISH_MASK    0x1
+
+#define DDRC_SELF_REFURBISH_EN      0x1
+#define DDRC_SELF_REFURBISH_EXIT    (0x1 << 1)
+
+#define HPM_CORE_MIN 150
+#define HPM_CORE_MAX 350
+
+#define HPM_CORE_VALUE_MIN  190
+#define HPM_CORE_VALUE_MAX  310
+
+#define TEMPERATURE_MIN 117
+#define TEMPERATURE_MAX 841
+
+#undef reg_get
+#undef reg_set
+#define reg_get(addr) readl(addr)
+#define reg_set(addr, val) writel(val, (unsigned int)(addr))
+
+#define hpm_formula(hpm, temp)  ((hpm) + 4 + ((((temp) - 70) * 205) >> 10))
+#define volt_formula(val) (1307 - ((1537 * (val)) >> 10))
+#define duty_formula(val)  ((unsigned int)((1099 - (val)) * 460) >> 10)
+
+void trng_init(void)
+{
+	unsigned int reg_val;
+	/* open rsa and trng clock */
+	reg_val = reg_get(CRG_REG_BASE + REG_PERI_CRG104);
+	reg_val |= TRNG_CLK_ENABLE;
+	reg_set(CRG_REG_BASE + REG_PERI_CRG104, reg_val);
+
+	/* set trng ctrl register */
+	reg_set(REG_BASE_RNG_GEN + SEC_COM_TRNG_CTRL_OFST,
+			TRNG_CTRL_DEF_VAL);
+}
+
+void trng_deinit(void)
+{
+	unsigned int reg_val;
+
+	/* close rsa and trng clock */
+	reg_val = reg_get(CRG_REG_BASE + REG_PERI_CRG104);
+	reg_val &= TRNG_CLK_DISABLE;
+	reg_set(CRG_REG_BASE + REG_PERI_CRG104, reg_val);
+}
+
+/* svb */
+#define SVB_VER        0x01
+
+#define CYCLE_NUM 4
+#define  HPM_CORE_REG0 0x120280d8
+#define  HPM_CORE_REG1 0x120280dc
+
+#define PWM0_REG 0X12080000
+#define PWM_CFG1 0X04
+#define PWM_CTRL 0X0C
+
+#define SVB_VER_REG         0x12020168
+#define  HPM_CHECK_REG 0x1202015c
+#define SYS_CTRL_VOLT_REG 0x12020158
+
+#define TSENSOR_STATUS0 0x120280bc
+#define OTP_HPM_CORE_REG 0x100a002c
+
+
+static unsigned hpm_value_avg(const unsigned int *val, int num)
+{
+	unsigned int i;
+	unsigned tmp = 0;
+
+	for (i = 0; i < num; i++)
+		tmp += val[i] >> NUM_2;
+
+	return tmp >> NUM_2;
+}
+
+static void get_hpm_value(unsigned int* const hpm_core)
+{
+	int i;
+	unsigned int temp;
+	unsigned int core_value[NUM_4];
+
+	core_value[NUM_0] = 0;
+	core_value[NUM_1] = 0;
+	core_value[NUM_2] = 0;
+	core_value[NUM_3] = 0;
+
+	for (i = 0; i < CYCLE_NUM; i++) {
+		delay(10); /* delay 10ms */
+
+		temp = readl(HPM_CORE_REG0);
+		core_value[NUM_1] += (temp >> 16) & 0x3ff; /* get hight 16 bits */
+		core_value[NUM_0] += temp & 0x3ff;
+		temp = readl(HPM_CORE_REG1);
+		core_value[NUM_3] += (temp >> 16) & 0x3ff; /* get hight 16 bits */
+		core_value[NUM_2] += temp & 0x3ff;
+	}
+
+	*hpm_core = hpm_value_avg(core_value, NUM_4);
+}
+
+static void start_hpm(unsigned int *hpm_core)
+{
+	get_hpm_value(hpm_core);
+}
+
+static void hpm_check(unsigned int *hpm_core)
+{
+	union {
+		struct {
+			unsigned int reserved_0 : 16; /* [15..0] */
+			unsigned int sys_hpm_core : 9; /* [24..16] */
+			unsigned int reserved_1 : 1; /* [25] */
+			unsigned int hpm_core_err : 1; /* [26] */
+			unsigned int reserved_2 : 5; /* [27..31] */
+		} bits;
+
+		unsigned int u32;
+	} sysboot10;
+	sysboot10.u32 = readl(HPM_CHECK_REG);
+	sysboot10.bits.sys_hpm_core = 0;
+	sysboot10.bits.hpm_core_err = 0;
+
+	if (*hpm_core < HPM_CORE_MIN) {
+		*hpm_core = HPM_CORE_MIN;
+		sysboot10.bits.hpm_core_err = 1;
+	}
+	if (*hpm_core > HPM_CORE_MAX) {
+		*hpm_core = HPM_CORE_MAX;
+		sysboot10.bits.hpm_core_err = 1;
+	}
+
+	sysboot10.bits.sys_hpm_core = *hpm_core;
+
+	writel(sysboot10.u32, HPM_CHECK_REG);
+}
+
+
+static void set_hpm_core_volt(unsigned int hpm_core_value)
+{
+	unsigned int volt;
+	unsigned int duty;
+	unsigned int otp_vmin_core = readl(OTP_HPM_CORE_REG);
+
+	if (hpm_core_value <= HPM_CORE_VALUE_MIN)
+		volt = 1022; /* 1022: volt value */
+	else if (hpm_core_value >= HPM_CORE_VALUE_MAX)
+		volt = 842; /* 842: volt value */
+	else
+		volt = volt_formula(hpm_core_value);
+
+	volt = volt + (int)((short int)(otp_vmin_core >> 16)); /* get hight 16 bits */
+
+	writel(volt, SYS_CTRL_VOLT_REG);
+	duty = duty_formula(volt);
+
+	writel(duty, PWM0_REG + PWM_CFG1);
+	writel(0x5, PWM0_REG + PWM_CTRL);
+}
+
+void start_svb(void)
+{
+	unsigned int hpm_core = 0;
+	
+
+	unsigned int tmp_reg = readl(SVB_VER_REG);
+	tmp_reg = (tmp_reg & 0xff00ffff) | (SVB_VER << 16); /* Move Left 16bit */
+	writel(tmp_reg, SVB_VER_REG);
+
+	
+	start_hpm(&hpm_core);
+	hpm_check(&hpm_core);
+
+	set_hpm_core_volt(hpm_core);
+	delay(200); /* delay 200ms */
+}
+
+/* [CUSTOM] DDR PHY0-PHY1 base register */
+#define DDR_REG_BASE_PHY0       0x120dc000
+
+/* [CUSTOM] DDR DMC0-DMC3 base register */
+#define DDR_REG_BASE_DMC0       0x120d8000
+#define DDR_REG_BASE_DMC1       0x120d8000
+
+#ifdef DDR_REG_BASE_PHY1
+#define DDR_REG_BASE_DMC2       0x120d9000
+#define DDR_REG_BASE_DMC3       0x120d9000
+#endif
+
+#define CRG_REG_BASE            0x12010000
+#define PERI_CRG_DDRT           0x198
+
+#define DDR_REG_BASE_SYSCTRL    0x12020000
+/* [SYSCTRL]RAM Retention control register 0 */
+#define SYSCTRL_MISC_CTRL4      0x8010
+
+#define DDR_PHY_DRAMCFG         0x2c    /* DRAM config register */
+#define PHY_DRAMCFG_TYPE_MASK   0xf /* [3:0] */
+#define PHY_DRAMCFG_TYPE_LPDDR4 0x6   /* [2:0] 110 LPDDR4 */
+
+#define BYTE_NUM  2
+
+/**
+ * ddr_boot_prepare
+ * @void
+ *
+ * Do some prepare before ddr training.
+ * Keep empty when nothing to do.
+ */
+static void ddr_boot_prepare(struct tr_relate_reg* const reg)
+{
+	/* select ddrt bus path */
+	reg->custom.ive_ddrt_mst_sel = readl(DDR_REG_BASE_SYSCTRL + SYSCTRL_MISC_CTRL4);
+	writel(reg->custom.ive_ddrt_mst_sel & 0xffffffdf,
+		   DDR_REG_BASE_SYSCTRL + SYSCTRL_MISC_CTRL4);
+
+	/* turn on ddrt clock */
+	reg->custom.ddrt_clk_reg = readl(CRG_REG_BASE + PERI_CRG_DDRT);
+	/* enable ddrt0 clock */
+	writel(reg->custom.ddrt_clk_reg | (0x1 << 1), CRG_REG_BASE + PERI_CRG_DDRT);
+	__asm__ __volatile__("nop");
+	/* disable ddrt0 soft reset */
+	writel(readl(CRG_REG_BASE + PERI_CRG_DDRT) & (~(0x1 << 0)),
+		   CRG_REG_BASE + PERI_CRG_DDRT);
+
+	/* disable rdqs anti-aging */
+	reg->custom.phy0_age_compst_en = readl(DDR_REG_BASE_PHY0 + DDR_PHY_PHYRSCTRL);
+	writel((reg->custom.phy0_age_compst_en & 0x7fffffff),
+		   DDR_REG_BASE_PHY0 + DDR_PHY_PHYRSCTRL);
+#ifdef DDR_REG_BASE_PHY1
+	reg->custom.phy1_age_compst_en = readl(DDR_REG_BASE_PHY1 + DDR_PHY_PHYRSCTRL);
+	writel((reg->custom.phy1_age_compst_en & 0x7fffffff),
+		   DDR_REG_BASE_PHY1 + DDR_PHY_PHYRSCTRL);
+#endif
+}
+
+/**
+ * ddr_boot_restore
+ * @void
+ *
+ * Restore register config after ddr training.
+ * Keep empty when nothing to do.
+ */
+static void ddr_boot_restore(const struct tr_relate_reg *reg)
+{
+	/* restore ddrt bus path */
+	writel(reg->custom.ive_ddrt_mst_sel, DDR_REG_BASE_SYSCTRL + SYSCTRL_MISC_CTRL4);
+
+	/* restore ddrt clock */
+	writel(reg->custom.ddrt_clk_reg, CRG_REG_BASE + PERI_CRG_DDRT);
+
+	/* restore rdqs anti-aging */
+	writel(reg->custom.phy0_age_compst_en, DDR_REG_BASE_PHY0 + DDR_PHY_PHYRSCTRL);
+#ifdef DDR_REG_BASE_PHY1
+	writel(reg->custom.phy1_age_compst_en, DDR_REG_BASE_PHY1 + DDR_PHY_PHYRSCTRL);
+#endif
+}
+
+/**
+ * ddr_rdqs_bdl_adj
+ * @void
+ *
+ * Adjust rdqs/rdq/rdm bdl to avoid problem cause by ddr anti-aging.
+ */
+#if 0
+static void ddr_rdqs_bdl_adj(void)
+{
+	int i;
+	unsigned int rdqs;
+	unsigned int rdq03;
+	unsigned int rdq47;
+	unsigned int rdm;
+	unsigned int tmp;
+
+	for (i = 0; i < BYTE_NUM; i++) {
+		rdqs = readl(DDR_REG_BASE_PHY0 + 0x22c + i * 0x80);
+		rdq03 = readl(DDR_REG_BASE_PHY0 + 0x21c + i * 0x80);
+		rdq47 = readl(DDR_REG_BASE_PHY0 + 0x220 + i * 0x80);
+		rdm = readl(DDR_REG_BASE_PHY0 + 0x224 + i * 0x80);
+
+		/* rdqs bdl lower two bit shoud be 0x11 */
+		while ((rdqs & 0x3) < 0x3) {
+			/* rdqs/rdq/rdm bdl + 1 */
+			rdqs = rdqs + 0x1;
+			rdq03 = rdq03 + 0x01010101;
+			rdq47 = rdq47 + 0x01010101;
+			rdm = rdm + 0x1;
+
+			writel(rdqs, DDR_REG_BASE_PHY0 + 0x22c + i * 0x80);
+			writel(rdq03, DDR_REG_BASE_PHY0 + 0x21c + i * 0x80);
+			writel(rdq47, DDR_REG_BASE_PHY0 + 0x220 + i * 0x80);
+			writel(rdm, DDR_REG_BASE_PHY0 + 0x224 + i * 0x80);
+		}
+	}
+
+	tmp = readl(DDR_REG_BASE_PHY0 + DDR_PHY_MISC);
+	tmp |= (1 << PHY_MISC_UPDATE_BIT);
+	/* update new config to PHY */
+	writel(tmp, DDR_REG_BASE_PHY0 + DDR_PHY_MISC);
+	tmp &= ~(1 << PHY_MISC_UPDATE_BIT);
+	writel(tmp, DDR_REG_BASE_PHY0 + DDR_PHY_MISC);
+	tmp = readl(DDR_REG_BASE_PHY0 + DDR_PHY_PHYINITCTRL);
+	/* set 1 to issue PHY counter reset signal */
+	tmp |= (1 << PHY_PHYCONN_RST_BIT);
+	writel(tmp, DDR_REG_BASE_PHY0 + DDR_PHY_PHYINITCTRL);
+	/* set 0 to end the reset signal */
+	tmp &= ~(1 << PHY_PHYCONN_RST_BIT);
+	writel(tmp, DDR_REG_BASE_PHY0 + DDR_PHY_PHYINITCTRL);
+}
+#endif
+
+#define OTP_CPU_CLK_OFFSET	0x0084
+#define CRG32_CPU_CLK_OFFSET	0x0080
+#define CRG123_CPU_CLK_OFFSET	0x01EC
+
+static void switch_cpu_freq(void)
+{
+	unsigned int mux_chn;
+	unsigned int reg_val;
+
+	if (readl(SYS_CTRL_REG_BASE + REG_SC_GEN5) != 0x1)
+		return;
+
+	mux_chn = readl(SYS_CTRL_REG_BASE + OTP_CPU_CLK_OFFSET);
+	mux_chn = (mux_chn >> 1) & 0x3;
+
+	reg_val = readl(CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+	reg_val |= 0x3;
+	writel(reg_val, CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+
+	if ((mux_chn == 0) || (mux_chn == 3)) {
+		reg_val = readl(CRG_REG_BASE + CRG123_CPU_CLK_OFFSET);
+		reg_val &= ~0x1;
+		writel(reg_val, CRG_REG_BASE + CRG123_CPU_CLK_OFFSET);
+		delay(1);
+
+		reg_val = readl(CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+		reg_val &= ~0x3;
+		reg_val |= 0x1;
+		writel(reg_val, CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+	} else if (mux_chn == 1) {
+		reg_val = readl(CRG_REG_BASE + CRG123_CPU_CLK_OFFSET);
+		reg_val |= 0x1;
+		writel(reg_val, CRG_REG_BASE + CRG123_CPU_CLK_OFFSET);
+		delay(1);
+
+		reg_val = readl(CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+		reg_val &= ~0x3;
+		writel(reg_val, CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+	} else if (mux_chn == 2) {
+		reg_val = readl(CRG_REG_BASE + CRG123_CPU_CLK_OFFSET);
+		reg_val |= 0x1;
+		writel(reg_val, CRG_REG_BASE + CRG123_CPU_CLK_OFFSET);
+		delay(1);
+
+		reg_val = readl(CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+		reg_val &= ~0x3;
+		reg_val |= 0x2;
+		writel(reg_val, CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+	}
+
+}
+
+void start_ddr_training(unsigned int base)
+{
+	struct tr_relate_reg relate_reg;
+	struct tr_relate_reg *reg = &relate_reg;
+
+	start_svb();
+
+	switch_cpu_freq();
+
+	ddr_boot_prepare(reg);
+
+	/* ddr pcode training */
+//	ddr_pcode_training_if();
+	/* ddr hw training */
+	ddr_hw_training_if();
+	/* ddr sw training */
+	ddr_sw_training_if();
+
+//	ddr_rdqs_bdl_adj();
+
+	ddr_boot_restore(reg);
+
+	/* the value should config after trainning, or
+	  it will cause chip compatibility problems */
+	if ((readl(DDR_REG_BASE_PHY0 + DDR_PHY_DRAMCFG) &
+		PHY_DRAMCFG_TYPE_MASK) == PHY_DRAMCFG_TYPE_LPDDR4) {
+		writel(0x401, DDR_REG_BASE_DMC0 + 0x28);
+		writel(0x401, DDR_REG_BASE_DMC1 + 0x28);
+	} else {
+		writel(0x401, DDR_REG_BASE_DMC0 + 0x28);
+	}
+#ifdef DDR_REG_BASE_PHY1
+	if ((readl(DDR_REG_BASE_PHY1 + DDR_PHY_DRAMCFG) &
+		PHY_DRAMCFG_TYPE_MASK) == PHY_DRAMCFG_TYPE_LPDDR4) {
+		writel(0x401, DDR_REG_BASE_DMC2 + 0x28);
+		writel(0x401, DDR_REG_BASE_DMC3 + 0x28);
+	} else {
+		writel(0x401, DDR_REG_BASE_DMC1 + 0x28);
+	}
+#endif
+	/* enable ddr scramb */
+}
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/Makefile
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/Makefile	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,110 @@
+PWD           = $(shell pwd)
+SRCDIR        =
+OUTDIR        =
+
+################################################################################
+CC       := $(CROSS_COMPILE)gcc
+AR       := $(CROSS_COMPILE)ar
+LD       := $(CROSS_COMPILE)ld
+OBJCOPY  := $(CROSS_COMPILE)objcopy
+
+
+################################################################################
+BOOT     := u-boot-$(SOC)
+TEXTBASE := 0x40700000
+
+CFLAGS   :=-Os -fno-builtin -ffreestanding \
+	-D__KERNEL__ -DTEXT_BASE=$(TEXTBASE) \
+	-I$(SRCDIR)/include \
+	-I$(OUTDIR)/include \
+	-I$(SRCDIR)/drivers/ddr/goke/default \
+	-I$(SRCDIR)/drivers/ddr/goke/$(SOC) \
+	-I$(SRCDIR)/arch/arm/include \
+	-I$(SRCDIR)/lib/hw_dec \
+	-fno-pic -ffunction-sections \
+	-fdata-sections -fno-common -ffixed-r9    \
+	-fno-common -pipe -march=armv7-a \
+	-Wall -Wstrict-prototypes -fno-stack-protector \
+	-D__LINUX_ARM_ARCH__=7 -D__ARM__ \
+	-DCONFIG_MMC\
+	$(MKFLAGS) -fno-strict-aliasing
+
+ifeq ($(ENABLE_MINI_BOOT),y)
+	CFLAGS += -DENABLE_MINI_BOOT
+	UBOOT_LDS := u-boot-mini.lds
+else
+	UBOOT_LDS := u-boot.lds
+endif
+
+################################################################################
+COBJS := start.o \
+	lowlevel_init_v300.o \
+	init_registers.o \
+	uart.o \
+	ddr_training_impl.o \
+	ddr_training_ctl.o \
+	ddr_training_boot.o \
+	ddr_training_custom.o \
+	ddr_training_console.o \
+	hw_decompress.o \
+	startup.o \
+	image_data.o \
+	reset.o
+
+ifneq ($(ENABLE_MINI_BOOT),y)
+COBJS += emmc_boot.o \
+		 div0.o
+endif
+
+REG := $(wildcard $(OUTDIR)/*.reg $(OUTDIR)/.reg)
+
+################################################################################
+.PHONY: $(BOOT).bin
+$(BOOT).bin: $(BOOT).tmp regfile
+	@dd if=./$(BOOT).tmp of=./tmp1 bs=1 count=64 2>/dev/null
+	@dd if=$(REG) of=./tmp2 bs=5120 conv=sync 2>/dev/null
+	@dd if=./$(BOOT).tmp of=./tmp3 bs=1 skip=5184 2>/dev/null
+	@cat tmp1 tmp2 tmp3 > $(BOOT).bin
+	@rm -f tmp1 tmp2 tmp3
+	@chmod 754 $(BOOT).bin
+	@cp -fv $@ $(OUTDIR)
+	@echo $(BOOT).bin is Ready.
+
+$(BOOT).tmp: $(BOOT).elf
+	$(OBJCOPY) -O srec $< $(BOOT).srec
+	$(OBJCOPY) -j .text -O binary $< $(BOOT).text
+	$(OBJCOPY) --gap-fill=0xff -O binary $< $@
+
+$(BOOT).elf: image_data.gzip $(COBJS)
+	$(LD) -Bstatic -T $(UBOOT_LDS) -Ttext $(TEXTBASE) \
+		$(COBJS) -Map $(BOOT).map -o $@
+	$(OBJDUMP) -d  $@ > $@.asm
+
+.PHONY: regfile
+regfile:
+	@if [ "$(words $(REG))" = "0" ]; then ( \
+		echo '***' Need '.reg' or '*.reg' file in directory $(OUTDIR); \
+		exit 1; \
+	) fi
+	@if [ "$(words $(REG))" != "1" ]; then ( \
+		echo '***' Found multi '.reg' or '*.reg' file in directory $(OUTDIR); \
+		echo '***' Files: $(notdir $(REG)); \
+		exit 1; \
+	) fi
+
+################################################################################
+
+# -1 : --fast      -9 : --best
+image_data.gzip: $(BINIMAGE)
+	$(OUTDIR)/../../../tools/utils/bin/gzip -fNqc -7 $< > $@
+
+%.o: %.c
+	$(CC) $(CFLAGS) -Wall -Wstrict-prototypes \
+		-fno-stack-protector -o $@ $< -c
+
+%.o: %.S
+	$(CC) -D__ASSEMBLY__ $(CFLAGS) -o $@ $< -c
+
+image_data.o: image_data.S image_data.gzip
+	$(CC) -D__ASSEMBLY__ $(CFLAGS) -o $@ $< -c
+
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/reset.S gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/reset.S
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/reset.S	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/reset.S	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,18 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <config.h>
+
+.global reset_cpu
+reset_cpu:
+	ldr	r1, rstctl			@ get addr for global reset
+						@ reg
+	mov	r3, #0x2			@ full reset pll + mpu
+	str	r3, [r1]			@ force reset
+	mov	r0, r0
+
+_loop_forever:
+	b	_loop_forever
+rstctl:
+	.word  SYS_CTRL_REG_BASE + REG_SC_SYSRES
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/start.S gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/start.S
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/start.S	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/start.S	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,519 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <asm-offsets.h>
+#include <config.h>
+#include <asm/system.h>
+#include <linux/linkage.h>
+#include <asm/armv7.h>
+
+/*************************************************************************
+ *
+ * Startup Code (reset vector)
+ *
+ * Do important init only if we don't start from memory!
+ * Setup memory and board specific bits prior to relocation.
+ * Relocate armboot to ram. Setup stack.
+ *
+ *************************************************************************/
+.globl	_start
+_start:
+	b	reset
+    b .
+    b .
+    b .
+    b .
+    b .
+    b .
+    b .
+	.balignl 64,0xdeadbeef
+	
+	.globl	reset
+	.globl	save_boot_params_ret
+#ifdef CONFIG_ARMV7_LPAE
+	.global	switch_to_hypervisor_ret
+#endif
+
+ __blank_zone_start:
+	.fill 1024*5,1,0
+__blank_zone_end:
+
+	.globl _blank_zone_start
+_blank_zone_start:
+	.word __blank_zone_start
+
+
+	.globl _blank_zone_end
+_blank_zone_end:
+	.word __blank_zone_end
+
+	.balignl 16,0xdeadbeef
+	.globl	_TEXT_BASE
+_TEXT_BASE:
+	.word TEXT_BASE
+ 
+
+_clr_remap_fmc_entry:
+	.word   FMC_MEM_BASE + do_clr_remap - CONFIG_SYS_TEXT_BASE_ORI
+
+_start_armboot:
+	.word start_armboot
+
+reset:
+	/* Allow the board to save important registers */
+	b	save_boot_params
+save_boot_params_ret:
+#ifdef CONFIG_ARMV7_LPAE
+/*
+ * check for Hypervisor support
+ */
+	mrc	p15, 0, r0, c0, c1, 1		@ read ID_PFR1
+	and	r0, r0, #CPUID_ARM_VIRT_MASK	@ mask virtualization bits
+	cmp	r0, #(1 << CPUID_ARM_VIRT_SHIFT)
+	beq	switch_to_hypervisor
+switch_to_hypervisor_ret:
+#endif
+	/*
+	 * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,
+	 * except if in HYP mode already
+	 */
+	mrs	r0, cpsr
+	and	r1, r0, #0x1f		@ mask mode bits
+	teq	r1, #0x1a		@ test for HYP mode
+	bicne	r0, r0, #0x1f		@ clear all mode bits
+	orrne	r0, r0, #0x13		@ set SVC mode
+	orr	r0, r0, #0xc0		@ disable FIQ and IRQ
+	msr	cpsr,r0
+
+/*
+ * Setup vector:
+ * (OMAP4 spl TEXT_BASE is not 32 byte aligned.
+ * Continue to use ROM code vector only in OMAP4 spl)
+ */
+#if !(defined(CONFIG_OMAP44XX) && defined(CONFIG_SPL_BUILD))
+	/* Set V=0 in CP15 SCTLR register - for VBAR to point to vector */
+	mrc	p15, 0, r0, c1, c0, 0	@ Read CP15 SCTLR Register
+	bic	r0, #CR_V		@ V = 0
+	mcr	p15, 0, r0, c1, c0, 0	@ Write CP15 SCTLR Register
+
+	/* Set vector address in CP15 VBAR register */
+	adrl	r0, _start
+	mcr	p15, 0, r0, c12, c0, 0	@Set VBAR
+#endif
+
+	/* the mask ROM code should have PLL and others stable */
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
+	bl	cpu_init_cp15
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT_ONLY
+	bl	cpu_init_crit
+#endif
+#endif
+
+#ifndef CONFIG_GK_DISABLE_DOWNLOAD
+	/*
+	 *  read system register REG_SC_GEN2
+         *  check if ziju flag
+	 */
+	ldr	r0, =SYS_CTRL_REG_BASE
+	ldr	r1, [r0, #REG_SC_GEN2]
+	ldr	r2, =0x7a696a75          /* magic for "ziju" */
+	cmp	r1, r2
+	bne	normal_start_flow
+	mov	r1, sp                   /* save sp */
+	str	r1, [r0, #REG_SC_GEN2]  /* clear ziju flag */
+
+    /* init PLL/DDRC/pin mux/... */
+	ldr	r0, _blank_zone_start
+	ldr	r1, _TEXT_BASE
+	sub	r0, r0, r1
+	ldr	r1, =RAM_START_ADRS
+	ldr	sp, =STACK_TRAINING
+	add	r0, r0, r1
+	mov	r1, #0x0                 /* flags: 0->normal 1->pm */
+	bl	init_registers           /* init PLL/DDRC/... */
+	/* after ziju, we need ddr traning */
+	ldr	r0, =SYS_CTRL_REG_BASE
+	bl	start_ddr_training       /* DDR training */
+    ldr	r0, =SYS_CTRL_REG_BASE
+	ldr	r1, [r0, #REG_SC_GEN2]
+	mov	sp, r1		         /* restore sp */
+	ldr	r1, [r0, #REG_SC_GEN3]
+	mov	pc, r1                  /* return to bootrom */
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	b	.                        /* bug here */
+
+normal_start_flow:
+#endif
+	/* init serial and printf a string. */
+	ldr     sp, =STACK_TRAINING
+#ifdef ENABLE_MINI_BOOT
+	bl	timer_init
+#else
+	bl      uart_early_init
+	bl      msg_main_cpu_startup
+#endif
+
+	/*
+	 * enable syscnt 
+	 */
+	ldr	r0, =SYSCNT_REG_BASE
+	ldr 	r3, =SYSCNT_FREQ
+	str	r3, [r0, #SYSCNT_FREQ_REG]
+	mov	r3, #0x1
+	str	r3, [r0, #SYSCNT_ENABLE_REG]
+
+	@if running not boot from nand/spi/emmc,
+	@we skipping boot_type checking.
+	mov    r0, pc, lsr#24
+	cmp    r0, #0x0
+	bne    do_clr_remap
+
+check_boot_type:
+#ifndef ENABLE_MINI_BOOT
+    ldr     r0, =SYS_CTRL_REG_BASE
+    ldr     r0, [r0, #REG_SYSSTAT]
+    mov     r6, r0, lsr#4
+	and     r6, #0x1
+    cmp     r6, #0x1
+    ldrlo   pc, _clr_remap_fmc_entry
+#else
+	ldr pc, _clr_remap_fmc_entry
+#endif
+
+do_clr_remap:
+#ifndef ENABLE_MINI_BOOT
+        /* do clear remap */
+	ldr     r4, =SYS_CTRL_REG_BASE
+	ldr	r0, [r4, #REG_SC_CTRL]
+
+	@Set clear remap bit.
+	orr	r0, #(1<<8)
+	str	r0, [r4, #REG_SC_CTRL]
+#endif
+	@enable I-Cache now
+	mrc p15, 0, r0, c1, c0, 0
+    orr r0, r0, #0x00001000 /* set bit 12 (I) I-Cache */
+    mcr p15, 0, r0, c1, c0, 0
+
+	@Check wether I'm running in dynamic mem bank:<0x40000000
+	mov r0, pc, lsr#28
+	cmp r0, #4
+	blo	ddr_init
+
+no_ddr_init:
+	adrl	r0, _start
+	b       copy_to_ddr
+
+ddr_init:
+	ldr     r0, _blank_zone_start
+	ldr     r1, _TEXT_BASE
+	sub     r0, r0, r1
+	adrl	r1, _start
+	add     r0, r0, r1
+	mov     r1, #0          /* flags: 0->normal 1->pm */
+	bl      init_registers
+
+	ldr	sp, =STACK_TRAINING
+	ldr	r0, =SYS_CTRL_REG_BASE
+	bl	start_ddr_training       /* DDR training */
+
+check_boot_mode:
+#ifndef ENABLE_MINI_BOOT
+	ldr	r0, =SYS_CTRL_REG_BASE
+	ldr     r0, [r0, #REG_SYSSTAT]
+	mov     r6, r0, lsr#4
+	and	r6, #0x1
+	cmp     r6, #BOOT_FROM_EMMC
+	bne     copy_flash_to_ddr
+#else
+	b copy_flash_to_ddr
+#endif
+
+#ifndef ENABLE_MINI_BOOT
+emmc_boot:
+	ldr     r0, _TEXT_BASE
+	ldr	r1, =__image_copy_start
+	ldr	r2, =__bss_start
+	sub	r1, r2, r1
+	bl	emmc_boot_read
+	b       relocate
+#endif
+
+copy_flash_to_ddr:
+	/* relocate SPI nor/nand Boot to DDR  */
+	ldr	r0, =FMC_MEM_BASE
+
+copy_to_ddr:
+	/* now, r0 stores __reset offset from where we get started */
+	ldr     r1, =__image_copy_start
+
+	/* compare source and target address, *
+	 *if equal no copy to target address */
+	cmp     r0, r1
+	beq	start_armboot
+
+	ldr     r2, =__image_copy_start/*_start*/
+	ldr     r3, =__bss_start
+	sub     r2, r3, r2      /* r2 <- size of armboot */
+	/* memcpy(r1, r0, r2) */
+	bl      memcpy
+
+relocate:
+	ldr r0, =_start_armboot
+	ldr pc, [r0]
+
+bug:
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	b       .                       /* bug here */
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+@
+@       void memcpy(r1, r0, r2);
+@
+
+.align  2
+memcpy:
+	add     r2, r0, r2
+	memcpy_loop:
+	ldmia   r0!, {r3 - r10}
+	stmia   r1!, {r3 - r10}
+	cmp     r0, r2
+	ble     memcpy_loop
+	mov     pc, lr
+
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+.align  2
+msg_main_cpu_startup:
+	mov     r5, lr
+	add     r0, pc, #4
+	bl      uart_early_puts
+	mov     pc, r5
+	L10:
+#ifndef CONFIG_SUPPORT_CA_RELEASE
+	.ascii "\r\n\r\nSystem startup\r\n\0"
+#else
+	.ascii "\r\n\r\n\r\n\0"
+#endif
+
+/*------------------------------------------------------------------------------*/
+
+ENTRY(c_runtime_cpu_setup)
+/*
+ * If I-cache is enabled invalidate it
+ */
+#ifndef CONFIG_SYS_ICACHE_OFF
+	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
+	mcr     p15, 0, r0, c7, c10, 4	@ DSB
+	mcr     p15, 0, r0, c7, c5, 4	@ ISB
+#endif
+
+	bx	lr
+
+ENDPROC(c_runtime_cpu_setup)
+
+/*************************************************************************
+ *
+ * void save_boot_params(u32 r0, u32 r1, u32 r2, u32 r3)
+ *	__attribute__((weak));
+ *
+ * Stack pointer is not yet initialized at this moment
+ * Don't save anything to stack even if compiled with -O0
+ *
+ *************************************************************************/
+ENTRY(save_boot_params)
+	b	save_boot_params_ret		@ back to my caller
+ENDPROC(save_boot_params)
+	.weak	save_boot_params
+
+#ifdef CONFIG_ARMV7_LPAE
+ENTRY(switch_to_hypervisor)
+	b	switch_to_hypervisor_ret
+ENDPROC(switch_to_hypervisor)
+	.weak	switch_to_hypervisor
+#endif
+
+/*************************************************************************
+ *
+ * cpu_init_cp15
+ *
+ * Setup CP15 registers (cache, MMU, TLBs). The I-cache is turned on unless
+ * CONFIG_SYS_ICACHE_OFF is defined.
+ *
+ *************************************************************************/
+ENTRY(cpu_init_cp15)
+	/*
+	 * Invalidate L1 I/D
+	 */
+	mov	r0, #0			@ set up for MCR
+	mcr	p15, 0, r0, c8, c7, 0	@ invalidate TLBs
+	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
+	mcr	p15, 0, r0, c7, c5, 6	@ invalidate BP array
+	mcr     p15, 0, r0, c7, c10, 4	@ DSB
+	mcr     p15, 0, r0, c7, c5, 4	@ ISB
+
+	/*
+	 * disable MMU stuff and caches
+	 */
+	mrc	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #0x00002000	@ clear bits 13 (--V-)
+	bic	r0, r0, #0x00000007	@ clear bits 2:0 (-CAM)
+	orr	r0, r0, #0x00000002	@ set bit 1 (--A-) Align
+	orr	r0, r0, #0x00000800	@ set bit 11 (Z---) BTB
+#ifdef CONFIG_SYS_ICACHE_OFF
+	bic	r0, r0, #0x00001000	@ clear bit 12 (I) I-cache
+#else
+	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-cache
+#endif
+	mcr	p15, 0, r0, c1, c0, 0
+
+#ifdef CONFIG_ARM_ERRATA_716044
+	mrc	p15, 0, r0, c1, c0, 0	@ read system control register
+	orr	r0, r0, #1 << 11	@ set bit #11
+	mcr	p15, 0, r0, c1, c0, 0	@ write system control register
+#endif
+
+#if (defined(CONFIG_ARM_ERRATA_742230) || defined(CONFIG_ARM_ERRATA_794072))
+	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register
+	orr	r0, r0, #1 << 4		@ set bit #4
+	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_743622
+	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register
+	orr	r0, r0, #1 << 6		@ set bit #6
+	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_751472
+	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register
+	orr	r0, r0, #1 << 11	@ set bit #11
+	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register
+#endif
+#ifdef CONFIG_ARM_ERRATA_761320
+	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register
+	orr	r0, r0, #1 << 21	@ set bit #21
+	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register
+#endif
+
+	mov	r5, lr			@ Store my Caller
+	mrc	p15, 0, r1, c0, c0, 0	@ r1 has Read Main ID Register (MIDR)
+	mov	r3, r1, lsr #20		@ get variant field
+	and	r3, r3, #0xf		@ r3 has CPU variant
+	and	r4, r1, #0xf		@ r4 has CPU revision
+	mov	r2, r3, lsl #4		@ shift variant field for combined value
+	orr	r2, r4, r2		@ r2 has combined CPU variant + revision
+
+#ifdef CONFIG_ARM_ERRATA_798870
+	cmp	r2, #0x30		@ Applies to lower than R3p0
+	bge	skip_errata_798870      @ skip if not affected rev
+	cmp	r2, #0x20		@ Applies to including and above R2p0
+	blt	skip_errata_798870      @ skip if not affected rev
+
+	mrc	p15, 1, r0, c15, c0, 0  @ read l2 aux ctrl reg
+	orr	r0, r0, #1 << 7         @ Enable hazard-detect timeout
+	push	{r1-r5}			@ Save the cpu info registers
+	bl	v7_arch_cp15_set_l2aux_ctrl
+	isb				@ Recommended ISB after l2actlr update
+	pop	{r1-r5}			@ Restore the cpu info - fall through
+skip_errata_798870:
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_801819
+	cmp	r2, #0x24		@ Applies to lt including R2p4
+	bgt	skip_errata_801819      @ skip if not affected rev
+	cmp	r2, #0x20		@ Applies to including and above R2p0
+	blt	skip_errata_801819      @ skip if not affected rev
+	mrc	p15, 0, r0, c0, c0, 6	@ pick up REVIDR reg
+	and	r0, r0, #1 << 3		@ check REVIDR[3]
+	cmp	r0, #1 << 3
+	beq	skip_errata_801819	@ skip erratum if REVIDR[3] is set
+
+	mrc	p15, 0, r0, c1, c0, 1	@ read auxilary control register
+	orr	r0, r0, #3 << 27	@ Disables streaming. All write-allocate
+					@ lines allocate in the L1 or L2 cache.
+	orr	r0, r0, #3 << 25	@ Disables streaming. All write-allocate
+					@ lines allocate in the L1 cache.
+	push	{r1-r5}			@ Save the cpu info registers
+	bl	v7_arch_cp15_set_acr
+	pop	{r1-r5}			@ Restore the cpu info - fall through
+skip_errata_801819:
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_454179
+	cmp	r2, #0x21		@ Only on < r2p1
+	bge	skip_errata_454179
+
+	mrc	p15, 0, r0, c1, c0, 1	@ Read ACR
+	orr	r0, r0, #(0x3 << 6)	@ Set DBSM(BIT7) and IBE(BIT6) bits
+	push	{r1-r5}			@ Save the cpu info registers
+	bl	v7_arch_cp15_set_acr
+	pop	{r1-r5}			@ Restore the cpu info - fall through
+
+skip_errata_454179:
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_430973
+	cmp	r2, #0x21		@ Only on < r2p1
+	bge	skip_errata_430973
+
+	mrc	p15, 0, r0, c1, c0, 1	@ Read ACR
+	orr	r0, r0, #(0x1 << 6)	@ Set IBE bit
+	push	{r1-r5}			@ Save the cpu info registers
+	bl	v7_arch_cp15_set_acr
+	pop	{r1-r5}			@ Restore the cpu info - fall through
+
+skip_errata_430973:
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_621766
+	cmp	r2, #0x21		@ Only on < r2p1
+	bge	skip_errata_621766
+
+	mrc	p15, 0, r0, c1, c0, 1	@ Read ACR
+	orr	r0, r0, #(0x1 << 5)	@ Set L1NEON bit
+	push	{r1-r5}			@ Save the cpu info registers
+	bl	v7_arch_cp15_set_acr
+	pop	{r1-r5}			@ Restore the cpu info - fall through
+
+skip_errata_621766:
+#endif
+
+	mov	pc, r5			@ back to my caller
+ENDPROC(cpu_init_cp15)
+
+#if !defined(CONFIG_SKIP_LOWLEVEL_INIT) && \
+	!defined(CONFIG_SKIP_LOWLEVEL_INIT_ONLY)
+/*************************************************************************
+ *
+ * CPU_init_critical registers
+ *
+ * setup important registers
+ * setup memory timing
+ *
+ *************************************************************************/
+ENTRY(cpu_init_crit)
+	/*
+	 * Jump to board specific initialization...
+	 * The Mask ROM will have already initialized
+	 * basic memory. Go here to bump up clock rate and handle
+	 * wake up conditions.
+	 */
+	b	lowlevel_init		@ go setup pll,mux,memory
+ENDPROC(cpu_init_crit)
+#endif
+
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/startup.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/startup.c
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/startup.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/startup.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,246 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <config.h>
+#include <linux/kconfig.h>
+#include <asm/io.h>
+#include <compiler.h>
+#include <cpu_common.h>
+
+extern unsigned int hw_dec_type;
+
+extern void hw_dec_init(void);
+extern int hw_dec_decompress(unsigned char *dst, int *dstlen,
+		      unsigned char *src, int srclen,
+		      void *unused);
+extern void hw_dec_uinit(void);
+
+/******************************************************************************/
+const uintptr_t image_entry = (CONFIG_SYS_TEXT_BASE);
+
+/******************************************************************************/
+
+#define GZIP_SIZE_OFFSET 0x4
+
+#ifndef CONFIG_SYS_ICACHE_OFF
+/* Invalidate entire I-cache and branch predictor array */
+static void invalidate_icache_all(void)
+{
+	/*
+	 * Invalidate all instruction caches to PoU.
+	 * Also flushes branch target cache.
+	 */
+	asm volatile("mcr p15, 0, %0, c7, c5, 0" : : "r"(0));
+
+	/* Invalidate entire branch predictor array */
+	asm volatile("mcr p15, 0, %0, c7, c5, 6" : : "r"(0));
+
+	/* Full system DSB - make sure that the invalidation is complete */
+	dsb();
+
+	/* ISB - make sure the instruction stream sees it */
+	isb();
+}
+#else
+static void invalidate_icache_all(void)
+{
+}
+#endif
+
+#ifdef CONFIG_MINI_BOOT
+
+#ifndef bit
+#define bit(x) (1 << (x))
+#endif
+
+#define TIME2_CLK_SEL  bit(18)
+
+int timer_init(void)
+{
+	/*
+	 * Under uboot, 0xffffffff is set to load register,
+	 * timer_clk equals BUSCLK/2/256.
+	 * e.g. BUSCLK equals 50M, it will roll back after 0xffffffff/timer_clk
+	 * 43980s equals 12hours
+	 */
+	__raw_writel(0, CFG_TIMERBASE + REG_TIMER_CONTROL);
+	__raw_writel(~0, CFG_TIMERBASE + REG_TIMER_RELOAD);
+
+	/* 32 bit, periodic */
+	__raw_writel(CFG_TIMER_CTRL, CFG_TIMERBASE + REG_TIMER_CONTROL);
+
+	/* start timer2 with mode below */
+	unsigned int reg;
+
+	reg = __raw_readl(SYS_CTRL_REG_BASE + REG_SC_CTRL);
+	/* for timer2,use sys BUS clk */
+	reg |= TIME2_CLK_SEL;
+	__raw_writel(reg, SYS_CTRL_REG_BASE + REG_SC_CTRL);
+
+	/* disable timer2 */
+	__raw_writel(0, TIMER2_REG_BASE + REG_TIMER_CONTROL);
+	/* timer2 load */
+	__raw_writel(~0, TIMER2_REG_BASE + REG_TIMER_RELOAD);
+
+	/*
+	 * Timing mode: 32bits [bit 1 set as 1]
+	 * ticking with 1/256 clock frequency [bit 3 set as 1, bit 2 set as 0]
+	 * timing circulary [bit 6 set as 1]
+	 * timer enabled [bit 7 set as 1]
+	 */
+	reg = (1 << 7) | (1 << 6) | (1 << 3) | (1 << 1);
+	__raw_writel(reg, TIMER2_REG_BASE + REG_TIMER_CONTROL);
+
+	return 0;
+}
+
+#define TIME_STAMP_CNT      0x12020138
+#define TIME_STAMP_VALUE    0x04010050
+#define CONFIG_TIME_STAMP_ENABLE
+
+void time_stamp(const char *strfunc, int nline, int type)
+{
+#ifdef CONFIG_TIME_STAMP_ENABLE
+	static int init_flag = 0;
+	unsigned int cnt;
+	unsigned int stamp;
+	unsigned int *addr = NULL;
+
+	if (!init_flag) {
+		init_flag = 1;
+		*(unsigned int *)TIME_STAMP_CNT = 0;
+	}
+
+	cnt = *(unsigned int *)TIME_STAMP_CNT;
+	stamp = *(unsigned int *)(TIMER2_REG_BASE + REG_TIMER_VALUE);
+	addr = (unsigned int *)(TIME_STAMP_VALUE + cnt * 16); /* 16:The number in the formula */
+
+	*addr = ~stamp;
+	addr++;
+	*addr = (uintptr_t)strfunc;
+	addr++;
+	*addr = nline;
+	addr++;
+	*addr = type;
+	cnt++;
+	*(unsigned int *)TIME_STAMP_CNT = cnt;
+#endif
+}
+#endif
+
+
+/******************************************************************************/
+void start_armboot(void)
+{
+	unsigned char *pdst_l32 = NULL;
+	unsigned int image_data_len;
+	int pdst_len;
+	int ret;
+	int i;
+	char *p = NULL;
+	char *q = NULL;
+
+#ifndef CONFIG_MINI_BOOT
+	uart_early_init();
+	uart_early_puts("\r\nUncompress ");
+#endif
+
+	/* use direct address mode */
+	hw_dec_type = 0;
+	/* init hw decompress IP */
+	hw_dec_init();
+
+	/* start decompress */
+	pdst_l32 = (unsigned char *)image_entry;
+	image_data_len = input_data_end - input_data;
+
+	/* get dets length from compress image */
+	p = (char *)&pdst_len;
+	q = (char *)(input_data_end - GZIP_SIZE_OFFSET);
+	for (i = 0; i < sizeof(int); i++)
+		p[i] = q[i];
+
+	ret = hw_dec_decompress(pdst_l32, &pdst_len, input_data,
+						image_data_len, NULL);
+	if (!ret) {
+#ifndef CONFIG_MINI_BOOT
+		uart_early_puts("Ok!");
+#endif
+	} else {
+#ifndef CONFIG_MINI_BOOT
+		uart_early_puts("Fail!");
+#endif
+		while (1);
+	}
+
+	/* uinit hw decompress IP */
+	hw_dec_uinit();
+	void (*uboot)(void);
+	uboot = (void (*))CONFIG_SYS_TEXT_BASE;
+	invalidate_icache_all();
+	uboot();
+}
+
+void hang(void)
+{
+	uart_early_puts("### ERROR ### Please RESET the board ###\n");
+	for (; ;) ;
+}
+
+
+void do_bad_sync(void)
+{
+	uart_early_puts("bad sync abort\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_sync(void)
+{
+	uart_early_puts("sync abort\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_bad_error(void)
+{
+	uart_early_puts("bad error\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_error(void)
+{
+	uart_early_puts("error\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_bad_fiq(void)
+{
+	uart_early_puts("bad fast interrupt request\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_bad_irq(void)
+{
+	uart_early_puts("bad interrupt request\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_fiq(void)
+{
+	uart_early_puts("fast interrupt request\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_irq(void)
+{
+	uart_early_puts("interrupt request\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/uart.S gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/uart.S
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/uart.S	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/uart.S	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,126 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <config.h>
+
+@******************************************************************************
+@
+@  void uart_early_init(void);
+@
+.text
+.align	2
+.global	uart_early_init
+.type	uart_early_init, %function
+uart_early_init:
+#ifndef CONFIG_GK_DISABLE_CONSOLE
+	ldr	a4, uart_base_addr_L0
+	mov	a3, #0
+	/* Disable UART */
+	str	a3, [a4, #48]
+	/* Set baud rate to 115200, uart clock:24M */
+	add	a3, a3, #13
+	str	a3, [a4, #36]
+	mov	a3, #1
+	str	a3, [a4, #40]
+	/* Set the UART to be 8 bits, 1 stop bit, no parity, fifo enabled. */
+	ldr	a3, =112
+	str	a3, [a4, #44]
+	/* Enable UART */
+	ldr	a3, =769
+	str	a3, [a4, #48]
+#endif
+	bx	lr
+uart_base_addr_L0:
+	.word CONFIG_CUR_UART_BASE
+
+@******************************************************************************
+@
+@  void uart_early_puts(const char *ss);
+@
+.align	2
+.global	uart_early_puts
+.type	uart_early_puts, %function
+uart_early_puts:
+#ifndef CONFIG_GK_DISABLE_CONSOLE
+#if !defined(CONFIG_SUPPORT_CA_RELEASE)
+	ldr	a2, uart_base_addr_L1
+	b	next_char
+output:
+	ldr	a4, [a2, #24]
+	tst	a4, #32
+	bne	output
+	str	a3, [a2, #0]
+	add	a1, a1, #1
+next_char:
+	ldrb	a3, [a1]
+	cmp	a3, #0
+	bne	output
+#endif /* CONFIG_SUPPORT_CA_RELEASE */
+#endif /* CONFIG_GK_DISABLE_CONSOLE */
+	bx	lr
+uart_base_addr_L1:
+	.word CONFIG_CUR_UART_BASE
+
+@******************************************************************************
+@
+@  void uart_early_put_hex(int hex);
+@
+@  call example:
+@    mov	r0, sp
+@    bl	uart_early_put_hex
+@
+.align	2
+.global	uart_early_put_hex
+.type	uart_early_put_hex, %function
+uart_early_put_hex:
+#if !defined(CONFIG_SUPPORT_CA_RELEASE)
+	ldr	a2, uart_base_addr_L2
+	mov	a3, #28
+wait2:
+	ldr	a4, [a2, #24]
+	tst	a4, #32
+	bne	wait2
+
+	mov	a4, #0xF
+	and	a4, a4, a1, lsr a3
+	cmp	a4, #9
+	addle	a4, a4, #0x30	@ a4 = a4 + '0'
+	addgt	a4, a4, #55	@ a4 = a4 - 10 + 'A'
+	str	a4, [a2, #0]
+	cmp	a3, #0
+	beq	exit2
+	sub	a3, a3, #4
+	b	wait2
+exit2:
+#endif /* CONFIG_SUPPORT_CA_RELEASE */
+	bx	lr
+uart_base_addr_L2:
+	.word CONFIG_CUR_UART_BASE
+
+@******************************************************************************
+@
+@  void uart_early_putc(int chr);
+@
+@  call example:
+@    mov	r0, #'A'
+@    bl	uart_early_putc
+@
+.align	2
+.global	uart_early_putc
+.type	uart_early_putc, %function
+uart_early_putc:
+#ifndef CONFIG_GK_DISABLE_CONSOLE
+#if !defined(CONFIG_SUPPORT_CA_RELEASE)
+	ldr	a2, uart_base_addr_L3
+wait3:
+	ldr	a4, [a2, #24]
+	tst	a4, #32
+	bne	wait3
+	str	a1, [a2, #0]
+
+#endif /* CONFIG_SUPPORT_CA_RELEASE */
+#endif /* CONFIG_GK_DISABLE_CONSOLE */
+	bx	lr
+uart_base_addr_L3:
+	.word CONFIG_CUR_UART_BASE
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/u-boot.lds gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/u-boot.lds
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/u-boot.lds	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/u-boot.lds	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,52 @@
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x40700000;
+	__image_copy_start =.;
+	. = ALIGN(4);
+	.text	:
+	{
+		__text_start = .;
+		start.o (.text*)
+		init_registers.o (.text*)
+		lowlevel_init_v300.o (.text*)
+		ddr_training_impl.o (.text*)
+		ddr_training_console.o (.text*)
+		ddr_training_ctl.o (.text*)
+		ddr_training_boot.o (.text*)
+		ddr_training_custom.o (.text*)
+		uart.o (.text*)
+		div0.o (.text*)
+		emmc_boot.o (.text*)
+		image_data.o (.text*)
+		hw_decompress.o (.text*)
+		startup.o(.text*)
+		reset.o(.text*)
+		__init_end = .;
+		ASSERT(((__init_end - __text_start) < 0x6000), "init sections too big!");
+		*(.text*)
+	}
+	__text_end = .;
+
+	. = ALIGN(4);
+	.image : { *(.image) }
+
+	. = ALIGN(4);
+	.rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = ALIGN(4);
+	__image_copy_end =.;
+	__bss_start = .;
+	.bss : { *(.bss) }
+	__bss_end = .;
+	_end = .;
+}
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/u-boot-mini.lds gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/u-boot-mini.lds
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v200/u-boot-mini.lds	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v200/u-boot-mini.lds	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,50 @@
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x40700000;
+	__image_copy_start =.;
+	. = ALIGN(4);
+	.text	:
+	{
+		__text_start = .;
+		start.o (.text*)
+		init_registers.o (.text*)
+		lowlevel_init_v300.o (.text*)
+		ddr_training_impl.o (.text*)
+		ddr_training_console.o (.text*)
+		ddr_training_ctl.o (.text*)
+		ddr_training_boot.o (.text*)
+		ddr_training_custom.o (.text*)
+		uart.o (.text*)
+		image_data.o (.text*)
+		hw_decompress.o (.text*)
+		startup.o(.text*)
+		reset.o(.text*)
+		__init_end = .;
+		ASSERT(((__init_end - __text_start) < 0x6000), "init sections too big!");
+		*(.text*)
+	}
+	__text_end = .;
+
+	. = ALIGN(4);
+	.image : { *(.image) }
+
+	. = ALIGN(4);
+	.rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = ALIGN(4);
+	__image_copy_end =.;
+	__bss_start = .;
+	.bss : { *(.bss) }
+	__bss_end = .;
+	_end = .;
+}
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v300/boot_mode.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v300/boot_mode.c
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v300/boot_mode.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v300/boot_mode.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/platform.h>
+
+int get_boot_media(void)
+{
+	unsigned int reg_val, boot_mode, spi_device_mode;
+	int boot_media;
+
+	reg_val = readl(SYS_CTRL_REG_BASE + REG_SYSSTAT);
+	boot_mode = get_sys_boot_mode(reg_val);
+
+	switch (boot_mode) {
+	case BOOT_FROM_SPI:
+		spi_device_mode = get_spi_device_type(reg_val);
+		if (spi_device_mode)
+			boot_media = BOOT_MEDIA_NAND;
+		else
+			boot_media = BOOT_MEDIA_SPIFLASH;
+		break;
+	case BOOT_FROM_EMMC:
+		boot_media = BOOT_MEDIA_EMMC;
+		break;
+	default:
+		boot_media = BOOT_MEDIA_UNKNOWN;
+		break;
+	}
+
+	return boot_media;
+}
+
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v300/emmc_boot.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v300/emmc_boot.c
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v300/emmc_boot.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v300/emmc_boot.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,181 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <config.h>
+
+#ifdef CONFIG_GENERIC_MMC
+#include <asm/arch/platform.h>
+#include <compiler.h>
+
+#ifndef CONFIG_ASIC
+#define DELAY_US        10
+#else
+#define DELAY_US        1000
+#endif
+
+#define MMC_BLK_SZ      512
+
+/* mmc.h */
+#define MMC_CMD_GO_IDLE_STATE       0
+#define MMC_CMD_SEND_OP_COND        1
+#define MMC_CMD_ALL_SEND_CID        2
+#define MMC_CMD_SET_RELATIVE_ADDR   3
+#define MMC_CMD_SET_DSR         4
+#define MMC_CMD_SWITCH          6
+#define MMC_CMD_SELECT_CARD     7
+#define MMC_CMD_SEND_EXT_CSD        8
+#define MMC_CMD_SEND_CSD        9
+#define MMC_CMD_SEND_CID        10
+#define MMC_CMD_STOP_TRANSMISSION   12
+#define MMC_CMD_SEND_STATUS     13
+#define MMC_CMD_SET_BLOCKLEN        16
+#define MMC_CMD_READ_SINGLE_BLOCK   17
+#define MMC_CMD_READ_MULTIPLE_BLOCK 18
+#define MMC_CMD_WRITE_SINGLE_BLOCK  24
+#define MMC_CMD_WRITE_MULTIPLE_BLOCK    25
+#define MMC_CMD_APP_CMD         55
+#define SD_CMD_SEND_IF_COND     8
+#define SD_CMD_APP_SEND_OP_COND     41
+#define SD_CMD_APP_SET_BUS_WIDTH    6
+
+#define OCR_BUSY        0x80000000
+#define OCR_HCS         0x40000000
+
+#define MMC_VDD_32_33       0x00100000  /* VDD voltage 3.2 ~ 3.3 */
+#define MMC_VDD_33_34       0x00200000  /* VDD voltage 3.3 ~ 3.4 */
+
+#define MMC_SWITCH_MODE_WRITE_BYTE  0x03 /* Set target byte to value */
+
+#define EXT_CSD_BUS_WIDTH   183 /* R/W */
+#define EXT_CSD_HS_TIMING   185 /* R/W */
+
+#define EXT_CSD_BUS_WIDTH_1 0   /* Card is in 1 bit mode */
+#define EXT_CSD_BUS_WIDTH_4 1   /* Card is in 4 bit mode */
+#define EXT_CSD_BUS_WIDTH_8 2   /* Card is in 8 bit mode */
+
+static inline void delay(unsigned int cnt)
+{
+	while (cnt--)
+		__asm__ __volatile__("nop");
+}
+
+#ifdef CONFIG_SDHCI
+#define SDHCI_BUFFER            0x20
+#define SDHCI_INT_STATUS        0x30
+#define SDHCI_INT_DATA_AVAIL    0x00000020
+#define SDHCI_INT_ERROR_MASK    0xFFFF8000
+
+#define debug_printf(fmt, args...) ;
+
+static inline unsigned int sdhci_readl(unsigned addr)
+{
+	uintptr_t reg_addr  = EMMC_BASE_REG + addr;
+
+	return *((volatile unsigned *) (reg_addr));
+}
+
+static inline void sdhci_writel(unsigned val, unsigned addr)
+{
+	uintptr_t reg_addr  = EMMC_BASE_REG + addr;
+
+	(*(volatile unsigned *) (reg_addr)) = (val);
+}
+
+static void sdhci_read_block_pio(void *data_addr, unsigned int block)
+{
+	const unsigned int offset = sizeof(unsigned int);
+	unsigned int size;
+	unsigned char *buf;
+
+	size = MMC_BLK_SZ;
+	buf = (unsigned char *)data_addr + MMC_BLK_SZ * block;
+	while (size) {
+		*(unsigned int *)buf = sdhci_readl(SDHCI_BUFFER);
+		buf += offset;
+		size -= offset;
+	}
+}
+
+int sdhci_check_int_status(unsigned int mask, unsigned int timeout)
+{
+	unsigned int reg;
+
+	for (;;) {
+		reg = sdhci_readl(SDHCI_INT_STATUS);
+		if (reg & mask)
+			break;
+		if (!(--timeout)) {
+			debug_printf("wait int status time out, reg = 0x%x, mask = 0x%x\n",
+						 reg, mask);
+			return -1;
+		}
+		if (reg & SDHCI_INT_ERROR_MASK) {
+			debug_printf("int err: reg = 0x%x\n", reg);
+			return -1;
+		}
+
+		delay(1000 * DELAY_US); /* ms converted to us multiplied by 1000 */
+	}
+
+	return 0;
+}
+
+static void copy_step1_to_ddr(unsigned int *dst, unsigned int *src, unsigned int size)
+{
+	const unsigned int cycle = size / sizeof(unsigned int);
+	unsigned int i;
+
+	for (i = 0; i < cycle; i++)
+		*dst++ = *src++;
+}
+
+#define CP_STEP1_SIZE 0x6000
+int sdhci_read_boot_data(void *data_addr, unsigned int data_size)
+{
+	const unsigned int timeout = 2000; /* 2s timeout: 2000000 * 1us */
+	unsigned int blocks = 0;
+	unsigned int read_block;
+	int ret;
+
+	if (data_size <= CP_STEP1_SIZE) {
+		copy_step1_to_ddr((void *)data_addr, (void *)RAM_START_ADRS, data_size);
+		return 0;
+	} else {
+		copy_step1_to_ddr((void *)data_addr, (void *)RAM_START_ADRS, CP_STEP1_SIZE);
+		data_addr += CP_STEP1_SIZE;
+		data_size -= CP_STEP1_SIZE;
+	}
+
+	if (data_size % MMC_BLK_SZ) {
+		debug_printf("sdhci_read_boot_data error\n");
+		debug_printf("data_size:%d not round by block size\n", data_size);
+		read_block = data_size / MMC_BLK_SZ + 1;
+	} else {
+		read_block = data_size / MMC_BLK_SZ;
+	}
+
+	while (1) {
+		ret = sdhci_check_int_status(SDHCI_INT_DATA_AVAIL, timeout);
+		if (ret) {
+			debug_printf("wait data available int time out\n");
+			return ret;
+		}
+
+		sdhci_writel(SDHCI_INT_DATA_AVAIL, SDHCI_INT_STATUS);
+		sdhci_read_block_pio(data_addr, blocks);
+
+		blocks++;
+		if (blocks == read_block)
+			break;
+	}
+
+	return 0;
+}
+
+void emmc_boot_read(void *ptr, unsigned int size)
+{
+	sdhci_read_boot_data(ptr, size);
+}
+#endif
+#endif
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v300/hw_decompress.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v300/hw_decompress.c
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v300/hw_decompress.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v300/hw_decompress.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,405 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#include <config.h>
+#include <linux/kconfig.h>
+#include <asm/io.h>
+#include <compiler.h>
+#include <cpu_common.h>
+
+#define error(_s)               uart_early_puts(_s)
+#define putstr(_s)              uart_early_puts(_s)
+
+#define PAGE_SIZE       4096
+#define page_nr(x) (((x) + PAGE_SIZE - 1) / PAGE_SIZE)
+
+/* The base address for emar */
+#define HW_DEC_REG_BASE_ADDR    (GZIP_REG_BASE)
+
+/* The global init registers for emar interface */
+#define EAMR_RID_REG_OFST   0x0108UL
+#define EAMR_ROSD_REG_OFST  0x010CUL
+#define EAMR_WID_REG_OFST   0x0110UL
+#define EAMR_WOSD_REG_OFST  0x0114UL
+
+/* The enable register */
+#define EAMR_WORK_EN_REG_OFST 0x0100UL
+
+#define DPRS_DATA_SRC_BADDR 0x2040UL
+#define DPRS_DATA_SRC_LEN   0x2044UL
+
+/* Decompress parameter reigsters for page address */
+#define DPRS_DATA_RTN_BADDR 0x2020UL
+#define DPRS_DATA_RTN_LEN   0x2024UL
+
+/* Decompress parameter registers for page data */
+#define DPRS_DATA_INFO_BADDR 0x2028UL
+#define DPRS_DATA_INFO_LEN  0x202CUL
+
+#define DPRS_DATA_CRC32     0x2030UL
+
+#define CRC_CHECK_EN        0x4000UL
+
+/* The status registers */
+#define BUF_INFO            0x2080UL
+#define DPRS_RTN_INFO       0x2084UL
+#define DPRS_RTN_LEN        0x2088UL
+#define BUF_INFO_CLR        0x2090UL
+#define RLT_INFO_CLR        0x2094UL
+
+/* The intr registers */
+#define INT_EN_REG_ADDR     0x0128UL
+#define INT_STATUS_REG_ADDR 0x0124UL
+#define INT_CLEAR_REG_ADDR  0x0130UL
+
+#define TASK_MODE_REG       0x2134UL
+
+/* Define the union u_dprs_data_buf_info */
+typedef union {
+	/* Define the struct bits */
+	struct {
+		unsigned int    buf_len: 24; /* [23..0] */
+		unsigned int    buf_id: 2; /* [25..24] */
+		unsigned int    reserved_1: 2; /* [27..26] */
+		unsigned int    eop: 1; /* [28] */
+		unsigned int    sop: 1; /* [29] */
+		unsigned int    reserved_0: 1; /* [30] */
+		unsigned int    mode: 1; /* [31] */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    u32;
+} u_dprs_data_buf_info;
+
+typedef union {
+	struct {
+		unsigned int buf_id: 2; /* [1:0] */
+		unsigned int rsv: 29;   /* [30:2] */
+		unsigned int aval_flg: 1;   /* [31] */
+	} bits;
+	unsigned int u32;
+} u_buf_status;
+
+typedef union {
+	struct {
+		unsigned int err_info: 8;   /* [7:0] */
+		unsigned int rsv: 23;   /* [30:8] */
+		unsigned int aval_flg: 1;   /* [31] */
+	} bits;
+
+	unsigned int u32;
+} u_dprs_rtn_status;
+
+/* Define the union U_INT_EN */
+typedef union {
+	/* Define the struct bits */
+	struct {
+		unsigned int    task_intrpt_en: 1; /* [0] */
+		unsigned int    block_intrpt_en: 1; /* [1] */
+		unsigned int    reserved_0: 30; /* [31..2] */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    u32;
+} u_intr_en;
+
+typedef union {
+	/* Define the struct bits */
+	struct {
+		unsigned int    task_intrpt: 1; /* [0] */
+		unsigned int    block_intrpt: 1; /* [1] */
+		unsigned int    reserved_0: 30; /* [31..2] */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    u32;
+} u_intr_status;
+
+typedef union {
+	/* Define the struct bits */
+	struct {
+		unsigned int    task_intrpt_clr: 1; /* [0] */
+		unsigned int    block_intrpt_clr: 1; /* [1] */
+		unsigned int    reserved_0: 30; /* [31..2] */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    u32;
+} u_intr_clr;
+
+
+#define PERI_CRG100 0x190
+
+#define GZIP_OFFSET PERI_CRG100
+#define GZIP_CLKEN (0x1<<0)
+
+#ifndef GZIP_REG_BASE
+#define GZIP_REG_BASE   0x11310000
+#endif
+
+#define HW_DEC_REG_BASE_ADDR  (GZIP_REG_BASE)
+
+static void disable_decompress_clock(void)
+{
+	unsigned int regval;
+
+	regval = readl(CRG_REG_BASE + GZIP_OFFSET);
+	regval &= ~GZIP_CLKEN;
+	writel(regval, CRG_REG_BASE + GZIP_OFFSET);
+}
+
+static void enable_decompress_clock(void)
+{
+	unsigned int regval;
+
+	regval = readl(CRG_REG_BASE + GZIP_OFFSET);
+	regval |= GZIP_CLKEN;
+	writel(regval, CRG_REG_BASE + GZIP_OFFSET);
+}
+
+
+unsigned int hw_dec_type;
+unsigned int hw_dec_sop;
+unsigned int hw_dec_eop;
+unsigned int hw_dec_cur_blk;
+unsigned int hw_blk_total_num;
+
+void hw_dec_sop_eop_first_set(int block_num)
+{
+	if (block_num == 1) {
+		hw_dec_sop = 1;
+		hw_dec_eop = 1;
+	} else {
+		hw_dec_sop = 1;
+		hw_dec_eop = 0;
+	}
+
+	hw_dec_cur_blk = 0;
+	hw_blk_total_num = block_num;
+}
+
+static inline void hw_dec_work_en_set(int work_en_flg)
+{
+	/* Enable the emar */
+	writel(work_en_flg, HW_DEC_REG_BASE_ADDR + EAMR_WORK_EN_REG_OFST);
+}
+
+static inline void hw_dec_rtn_baddr_set(unsigned int addr)
+{
+	writel(addr, HW_DEC_REG_BASE_ADDR + DPRS_DATA_RTN_BADDR);
+}
+
+static inline void hw_dec_dprs_data_baddr_set(unsigned int addr)
+{
+	writel(addr, HW_DEC_REG_BASE_ADDR + DPRS_DATA_INFO_BADDR);
+}
+
+static inline void hw_dec_data_rtn_len_set(unsigned int len)
+{
+	writel(len, HW_DEC_REG_BASE_ADDR + DPRS_DATA_RTN_LEN);
+}
+
+static inline void hw_dec_dprs_data_len_set(unsigned int len)
+{
+	writel(len, HW_DEC_REG_BASE_ADDR + DPRS_DATA_INFO_LEN);
+}
+
+static inline void hw_dec_crc_check_en(unsigned int crc_en)
+{
+	writel(crc_en, HW_DEC_REG_BASE_ADDR + CRC_CHECK_EN);
+}
+
+static inline void hw_dec_data_crc32_set(unsigned int crc32)
+{
+	writel(crc32, HW_DEC_REG_BASE_ADDR + DPRS_DATA_CRC32);
+}
+
+static inline unsigned int hw_dec_buf_status_get(void)
+{
+	return readl(HW_DEC_REG_BASE_ADDR + BUF_INFO);
+}
+
+static inline unsigned int hw_dec_dprs_rtn_status_get(void)
+{
+	return readl(HW_DEC_REG_BASE_ADDR + DPRS_RTN_INFO);
+}
+
+static inline void hw_dec_buf_status_clr(void)
+{
+	writel(0x1, HW_DEC_REG_BASE_ADDR + BUF_INFO_CLR);
+}
+
+static inline void hw_dec_dprs_rtn_status_clr(void)
+{
+	writel(0x1, HW_DEC_REG_BASE_ADDR + RLT_INFO_CLR);
+}
+
+static void hw_dec_intr_en_set(int blk_intr_en, int task_intr_en)
+{
+	u_intr_en intr_en;
+	intr_en.bits.task_intrpt_en = task_intr_en;
+	intr_en.bits.block_intrpt_en = blk_intr_en;
+	writel(intr_en.u32, HW_DEC_REG_BASE_ADDR + INT_EN_REG_ADDR);
+}
+
+static inline unsigned int hw_dec_intr_status_get(void)
+{
+	return readl(HW_DEC_REG_BASE_ADDR + INT_STATUS_REG_ADDR);
+}
+
+static void hw_dec_block_intr_status_clr(void)
+{
+	u_intr_clr intr_clr;
+
+	intr_clr.u32 = readl(HW_DEC_REG_BASE_ADDR + INT_CLEAR_REG_ADDR);
+	intr_clr.bits.block_intrpt_clr = 0x1;
+	writel(intr_clr.u32, HW_DEC_REG_BASE_ADDR + INT_CLEAR_REG_ADDR);
+}
+
+static void hw_dec_task_intr_status_clr(void)
+{
+	u_intr_clr intr_clr;
+
+	intr_clr.u32 = readl(HW_DEC_REG_BASE_ADDR + INT_CLEAR_REG_ADDR);
+	intr_clr.bits.task_intrpt_clr = 0x1;
+	writel(intr_clr.u32, HW_DEC_REG_BASE_ADDR + INT_CLEAR_REG_ADDR);
+}
+
+int hw_dec_intr_proc(int irq, void *para)
+{
+	u_buf_status buf_status;
+	u_intr_status intr_status;
+	u_dprs_rtn_status dprs_status;
+	int ret = 0;
+
+	intr_status.u32 = hw_dec_intr_status_get();
+	if (intr_status.bits.block_intrpt) {
+		buf_status.u32 = hw_dec_buf_status_get();
+		if (buf_status.bits.aval_flg)
+			hw_dec_buf_status_clr();
+
+		hw_dec_block_intr_status_clr();
+	}
+
+	if (intr_status.bits.task_intrpt) {
+		dprs_status.u32 = hw_dec_dprs_rtn_status_get();
+		if (dprs_status.bits.aval_flg) {
+			if (dprs_status.bits.err_info)
+				ret = -2; /* -2:failed */
+
+			hw_dec_dprs_rtn_status_clr();
+		}
+
+		hw_dec_task_intr_status_clr();
+		goto out;
+	}
+
+	ret = -1;
+out:
+	return ret;
+}
+
+void hw_dec_start(unsigned int src_baddr,
+			unsigned int dst_baddr,
+			unsigned int src_len,
+			unsigned int dst_len,
+			unsigned int crc_en,
+			unsigned int crc32,
+			unsigned int dec_type)
+{
+	unsigned int val;
+
+	if (hw_dec_sop) {
+		if (!dec_type) {
+			/* set the parameters of output buffer */
+			hw_dec_rtn_baddr_set(dst_baddr);
+			hw_dec_data_rtn_len_set(dst_len);
+		} else {
+			/* set the parameter of output buffer */
+			hw_dec_dprs_data_baddr_set(dst_baddr);
+			hw_dec_dprs_data_len_set(page_nr(dst_len) * 4); /* 4:Align */
+		}
+	}
+
+	/* set the parameter of input buffer */
+	writel(src_baddr, HW_DEC_REG_BASE_ADDR + DPRS_DATA_SRC_BADDR);
+
+	val = src_len |
+		(hw_dec_sop << 28) | (hw_dec_eop << 29) | (!dec_type << 31); /* 28,29,31 Move Left bit */
+	writel(val, HW_DEC_REG_BASE_ADDR + DPRS_DATA_SRC_LEN);
+
+	hw_dec_crc_check_en(crc_en);
+}
+
+static inline void delay(unsigned int num)
+{
+	volatile unsigned int i;
+
+	for (i = 0; i < (100 * num); i++) /* 100: Cycle */
+		__asm__ __volatile__("nop");
+}
+
+int hw_dec_wait_finish(void)
+{
+	int ret;
+	int times = 0;
+
+	do {
+		ret = hw_dec_intr_proc(HW_DEC_INTR, NULL);
+		times++;
+		if (times > 2000000) { /* 2000000 ms */
+			error("hardware decompress overtime!\n");
+			break;
+		}
+		delay(1);
+	} while (-1 == ret);
+
+	return ret;
+}
+
+int hw_dec_decompress(unsigned char *dst, int *dstlen,
+			unsigned char *src, int srclen,
+			void *unused)
+{
+	int ret;
+
+	hw_dec_sop_eop_first_set(1);
+	hw_dec_start((unsigned int)(uintptr_t)src, (unsigned int)(uintptr_t)dst,
+				 srclen, *dstlen, 1, 0, hw_dec_type);
+
+	ret = hw_dec_wait_finish();
+
+	*dstlen = readl(HW_DEC_REG_BASE_ADDR + DPRS_RTN_LEN);
+
+	if (ret)
+		return -1;
+
+	return 0;
+}
+
+void hw_dec_init(void)
+{
+	/* enable decompress clock */
+	enable_decompress_clock();
+	/* Init the emar interface */
+	writel(0, HW_DEC_REG_BASE_ADDR + EAMR_RID_REG_OFST);
+	writel(0x3, HW_DEC_REG_BASE_ADDR + EAMR_ROSD_REG_OFST);
+	writel(0, HW_DEC_REG_BASE_ADDR + EAMR_WID_REG_OFST);
+	writel(0x3, HW_DEC_REG_BASE_ADDR + EAMR_WOSD_REG_OFST);
+
+	/* Enable interrupt */
+	hw_dec_intr_en_set(0x1, 0x1);
+
+	/* Enable emar */
+	hw_dec_work_en_set(0x1);
+}
+
+void hw_dec_uinit(void)
+{
+	hw_dec_work_en_set(0x0);
+	hw_dec_intr_en_set(0x0, 0x0);
+
+	/* disable decompress clock */
+	disable_decompress_clock();
+}
+
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v300/image_data.S gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v300/image_data.S
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v300/image_data.S	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v300/image_data.S	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,9 @@
+.section .image,#alloc
+.globl	input_data
+/*gzip source addr must be 16 bytes aligned*/
+.balign 16
+input_data:
+.incbin   "image_data.gzip"
+
+.globl    input_data_end
+input_data_end:
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v300/init_registers.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v300/init_registers.c
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v300/init_registers.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v300/init_registers.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,171 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <asm/arch/platform.h>
+#include <compiler.h>
+
+#define W_WHETHER_WRITE     (1<<0)
+#define W_WHETHER_PM        (1<<1)
+#define W_WHETHER_BOOT_NORMAL   (1<<2)
+#define W_BIT_OFFSET        3
+#define W_BIT_MASK          (0x1f<<W_BIT_OFFSET)
+#define W_REG_BIT_OFFSET    11
+#define W_REG_BIT_MASK      (0x1f<<W_REG_BIT_OFFSET)
+
+#define R_WHETHER_READ      (W_WHETHER_WRITE<<16)
+#define R_WHETHER_PM        (W_WHETHER_PM<<16)
+#define R_WHETHER_BOOT_NORMAL   (W_WHETHER_BOOT_NORMAL<<16)
+#define R_BIT_OFFSET        (W_BIT_OFFSET + 16)
+#define R_BIT_MASK          (W_BIT_MASK<<16)
+#define R_REG_BIT_OFFSET    (W_REG_BIT_OFFSET + 16)
+#define R_REG_BIT_MASK      (W_REG_BIT_MASK<<16)
+
+#define RW_BIT_NUM	32
+
+struct regentry {
+	unsigned int reg_addr;
+	unsigned int value;
+	unsigned int delay;
+	unsigned int attr;
+};
+
+static inline void dwb(void) /* drain write buffer */
+{
+}
+
+static inline unsigned int readl(unsigned addr)
+{
+	unsigned int val;
+	val = (*(volatile unsigned int *)(uintptr_t)(addr));
+	return val;
+}
+
+static inline void writel(unsigned val, unsigned addr)
+{
+	dwb();
+	(*(volatile unsigned *)(uintptr_t)(addr)) = val;
+	dwb();
+}
+
+static inline void delay(void)
+{
+	__asm__ __volatile__("nop");
+}
+
+static void reg_read(struct regentry *reg, unsigned int *ret)
+{
+	unsigned int reg_val_r;
+	unsigned int bit_start_r;
+	unsigned int bit_num_r;
+
+	bit_start_r = ((reg->attr & R_REG_BIT_MASK) >> R_REG_BIT_OFFSET);
+	bit_num_r = ((reg->attr & R_BIT_MASK) >> R_BIT_OFFSET) + 1;
+	reg_val_r = (*(volatile unsigned *)(uintptr_t)(reg->reg_addr));
+
+	if (bit_num_r != RW_BIT_NUM) {
+		reg_val_r >>= bit_start_r;
+		reg_val_r &= ((1 << bit_num_r) - 1);
+	}
+
+	*ret = ((reg_val_r == reg->value) ? 0 : 1);
+}
+
+static void reg_write(struct regentry *reg)
+{
+	unsigned int reg_val_w;
+	unsigned int delay_2;
+	unsigned int bit_start_w;
+	unsigned int bit_num_w;
+
+	delay_2 = reg->delay;
+	bit_start_w = ((reg->attr & W_REG_BIT_MASK) >> W_REG_BIT_OFFSET);
+	bit_num_w = ((reg->attr & W_BIT_MASK) >> W_BIT_OFFSET) + 1;
+	reg_val_w = (*(volatile unsigned *)(uintptr_t)(reg->reg_addr));
+
+	if (bit_num_w == RW_BIT_NUM) {
+		reg_val_w = reg->value;
+	} else {
+		reg_val_w &= (~(((1 << bit_num_w) - 1) << bit_start_w));
+		reg_val_w |= (reg->value) << bit_start_w;
+	}
+	writel(reg_val_w, reg->reg_addr);
+
+	do {
+		delay();
+	} while (delay_2--);
+}
+
+static void read_write(struct regentry *reg, unsigned int pm)
+{
+	unsigned int ret;
+	unsigned int delay_1;
+
+	ret = 0;
+	delay_1 = reg->delay;
+
+	if (pm) {
+		if (reg->attr & W_WHETHER_PM) {
+			reg_write(reg);
+		} else if (reg->attr & R_WHETHER_PM) {
+			do {
+				reg_read(reg, &ret);
+				delay();
+			} while (ret);
+
+			do {
+				delay();
+			} while (delay_1--);
+		} else {
+			do {
+				delay();
+			} while (delay_1--);
+		}
+	} else {
+		if (reg->attr & W_WHETHER_BOOT_NORMAL) {
+			reg_write(reg);
+		} else if (reg->attr & R_WHETHER_BOOT_NORMAL) {
+			do {
+				reg_read(reg, &ret);
+				delay();
+			} while (ret);
+
+			do {
+				delay();
+			} while (delay_1--);
+		} else {
+			do {
+				delay();
+			} while (delay_1--);
+		}
+	}
+}
+
+static void part_read_write(struct regentry *reg_table, unsigned int pm)
+{
+	unsigned int i;
+
+	for (i = 0; ; i++) {
+		if ((!reg_table[i].reg_addr) && (!reg_table[i].value) &&
+				(!reg_table[i].delay) && (!reg_table[i].attr))
+			goto main_end;
+
+		read_write(&reg_table[i], pm);
+	}
+
+main_end:
+	delay();
+}
+
+/*
+ * base - reg base address
+ * pm   - is suspend
+ *      0 normal
+ *      1 pm
+ */
+void init_registers(unsigned long base, unsigned long pm)
+{
+	struct regentry *reg_table = (struct regentry *)base;
+
+	part_read_write(reg_table, pm);
+}
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v300/lowlevel_init_v300.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v300/lowlevel_init_v300.c
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v300/lowlevel_init_v300.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v300/lowlevel_init_v300.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,482 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#include <compiler.h>
+#include <asm/arch/platform.h>
+#include <config.h>
+#include <ddr_training_impl.h>
+
+static inline void delay(unsigned int num)
+{
+	volatile unsigned int i;
+
+	for (i = 0; i < (100 * num); i++) /* 100: Cycle */
+		__asm__ __volatile__("nop");
+}
+
+static inline void dwb(void) /* drain write buffer */
+{
+}
+
+static inline unsigned int readl(unsigned addr)
+{
+	unsigned int val;
+
+	val = (*(volatile unsigned int *)((uintptr_t)(addr)));
+	return val;
+}
+
+static inline void writel(unsigned val, unsigned addr)
+{
+	dwb();
+	(*(volatile unsigned *)((uintptr_t)(addr))) = (val);
+	dwb();
+}
+
+#define REG_BASE_RNG_GEN            0x10090000
+#define TRNG_DSTA_FIFO_DATA_OFST    0x204
+#define TRNG_DATA_ST_OFST           0x208
+#define BIT_TRNG_FIFO_DATA_CNT      0x8
+#define TRNG_FIFO_DATA_CNT_MASK     0xff
+#define REG_PERI_CRG104             0x1a0
+#define TRNG_CLK_ENABLE             (0x1<<3)
+#define TRNG_CLK_DISABLE            ~(0x1<<3)
+#define TRNG_CTRL_DEF_VAL           0xa
+#define SEC_COM_TRNG_CTRL_OFST    0x200
+
+#define REG_BASE_MISC               0x12030000
+#define DDR_CA0_OFST                0x28
+#define DDR_CA1_OFST                0x2C
+#define DDR_CA2_OFST                0x30
+
+#define REG_BASE_DDRC               0x120d0000
+#define DDRC_CTRL_SREF_OFST         (0x8000 + 0x0)
+#define DDRC_CFG_DDRMODE_OFST       (0x8000 + 0x50)
+#define DDRC_CURR_FUNC_OFST         (0x8000 + 0x294)
+
+#define DDRC_CHANNEL_VALID_MASK     0xf
+#define DDRC_SELF_REFURBISH_MASK    0x1
+
+#define DDRC_SELF_REFURBISH_EN      0x1
+#define DDRC_SELF_REFURBISH_EXIT    (0x1 << 1)
+
+#define HPM_CORE_MIN 150
+#define HPM_CORE_MAX 350
+#define TEMPERATURE_MIN 117
+#define TEMPERATURE_MAX 841
+#define HPM_CORE_VALUE_MIN  190
+#define HPM_CORE_VALUE_MAX  310
+
+#undef reg_get
+#undef reg_set
+#define reg_get(addr) readl(addr)
+#define reg_set(addr, val) writel(val, (unsigned int)(addr))
+
+#define temperature_formula(val) (((((val) - 117) * 212) >> 10) - 40)
+#define hpm_formula(hpm, temp)  ((hpm) + 4 + ((((temp) - 70) * 205) >> 10))
+#define volt_formula(val) (1287 - ((1514 * (val)) >> 10))
+#define duty_formula(val)  (((unsigned int)((1099 - (val)) * 460) >> 10) - 1)
+#define svb_pwm_reg_val(val) ((((val) << 16) & 0XFFFF0000) + 0x0c75)
+
+void trng_init(void)
+{
+	unsigned int reg_val;
+	/* open rsa and trng clock */
+	reg_val = reg_get(CRG_REG_BASE + REG_PERI_CRG104);
+	reg_val |= TRNG_CLK_ENABLE;
+	reg_set(CRG_REG_BASE + REG_PERI_CRG104, reg_val);
+
+	/* set trng ctrl register */
+	reg_set(REG_BASE_RNG_GEN + SEC_COM_TRNG_CTRL_OFST,
+			TRNG_CTRL_DEF_VAL);
+}
+
+void trng_deinit(void)
+{
+	unsigned int reg_val;
+
+	/* close rsa and trng clock */
+	reg_val = reg_get(CRG_REG_BASE + REG_PERI_CRG104);
+	reg_val &= TRNG_CLK_DISABLE;
+	reg_set(CRG_REG_BASE + REG_PERI_CRG104, reg_val);
+}
+
+/* svb */
+#define SVB_VER             0x10
+
+#define CYCLE_NUM 4
+#define  HPM_CORE_REG0 0x120280d8
+#define  HPM_CORE_REG1 0x120280dc
+
+#define SVB_PWM_REG 0X120280b0
+
+#define SVB_VER_REG         0x12020168
+#define  HPM_CHECK_REG 0x1202015c
+#define SYS_CTRL_VOLT_REG 0x12020158
+
+#define TSENSOR_STATUS0 0x120280bc
+#define OTP_HPM_CORE_REG 0x100a002c
+
+static unsigned hpm_value_avg(unsigned int *val, int num)
+{
+	unsigned int i;
+	unsigned tmp = 0;
+
+	for (i = 0; i < num; i++)
+		tmp += val[i] >> NUM_2;
+
+	return tmp >> NUM_2;
+}
+
+static void get_hpm_value(unsigned int *hpm_core)
+{
+	int i;
+	unsigned int temp;
+	unsigned int core_value[NUM_4];
+
+	core_value[NUM_0] = 0;
+	core_value[NUM_1] = 0;
+	core_value[NUM_2] = 0;
+	core_value[NUM_3] = 0;
+
+	for (i = 0; i < CYCLE_NUM; i++) {
+		delay(10); /* delay 10ms */
+
+		temp = readl(HPM_CORE_REG0);
+		core_value[NUM_1] += (temp >> 16) & 0x3ff; /* get hight 16 bits */
+		core_value[NUM_0] += temp & 0x3ff;
+		temp = readl(HPM_CORE_REG1);
+		core_value[NUM_3] += (temp >> 16) & 0x3ff; /* get hight 16 bits */
+		core_value[NUM_2] += temp & 0x3ff;
+	}
+
+	*hpm_core = hpm_value_avg(core_value, NUM_4);
+}
+
+static void start_hpm(unsigned int *hpm_core)
+{
+	get_hpm_value(hpm_core);
+}
+
+static void hpm_check(unsigned int *hpm_core)
+{
+	union {
+		struct {
+			unsigned int reserved_0 : 16; /* [15..0] */
+			unsigned int sys_hpm_core : 9; /* [24..16] */
+			unsigned int reserved_1 : 1; /* [25] */
+			unsigned int hpm_core_err : 1; /* [26] */
+			unsigned int reserved_2 : 5; /* [27..31] */
+		} bits;
+
+		unsigned int u32;
+	} sysboot10;
+	sysboot10.u32 = readl(HPM_CHECK_REG);
+	sysboot10.bits.sys_hpm_core = 0;
+	sysboot10.bits.hpm_core_err = 0;
+
+	if (*hpm_core < HPM_CORE_MIN) {
+		*hpm_core = HPM_CORE_MIN;
+		sysboot10.bits.hpm_core_err = 1;
+	}
+	if (*hpm_core > HPM_CORE_MAX) {
+		*hpm_core = HPM_CORE_MAX;
+		sysboot10.bits.hpm_core_err = 1;
+	}
+
+	sysboot10.bits.sys_hpm_core = *hpm_core;
+
+	writel(sysboot10.u32, HPM_CHECK_REG);
+}
+
+static void get_temperature(unsigned int *temperature)
+{
+	unsigned int value;
+
+	value = readl(TSENSOR_STATUS0);
+	value = value & 0x3ff; /* 0x3ff: mask */
+
+	if (value <= TEMPERATURE_MIN)
+		*temperature = -40; /* -40: temperature val */
+	else if (value >= TEMPERATURE_MAX)
+		*temperature = 110; /* 110: temperature val */
+	else
+		*temperature = temperature_formula(value);
+}
+
+static void adjust_hpm(unsigned int *hpm_core, unsigned int temperature)
+{
+	/* 283 70: hpm_core and temperature Threshold */
+	if ((*hpm_core >= 283) && (temperature >= 70))
+		*hpm_core = hpm_formula(*hpm_core, temperature);
+	/* 222 70: hpm_core and temperature Threshold */
+	else if ((*hpm_core <= 222) && (temperature >= 70))
+		*hpm_core = *hpm_core - NUM_4;
+}
+
+static void set_hpm_core_volt(unsigned int hpm_core_value)
+{
+	unsigned int volt;
+	unsigned int duty;
+	unsigned int otp_vmin_core = readl(OTP_HPM_CORE_REG);
+
+	if (hpm_core_value <= HPM_CORE_VALUE_MIN)
+		volt = 1006; /* 1006: volt value */
+	else if (hpm_core_value >= HPM_CORE_VALUE_MAX)
+		volt = 829; /* 829: volt value */
+	else
+		volt = volt_formula(hpm_core_value);
+
+	volt = volt + (int)((short int)(otp_vmin_core >> 16)); /* get hight 16 bits */
+
+	writel(volt, SYS_CTRL_VOLT_REG);
+	duty = duty_formula(volt);
+
+	writel(svb_pwm_reg_val(duty), SVB_PWM_REG);
+}
+
+void start_svb(void)
+{
+	unsigned int hpm_core = 0;
+	unsigned int temperature = 0;
+
+	unsigned int tmp_reg = readl(SVB_VER_REG);
+	tmp_reg = (tmp_reg & 0xff00ffff) | (SVB_VER << 16); /* Move Left 16bit */
+	writel(tmp_reg, SVB_VER_REG);
+
+	get_temperature(&temperature);
+	start_hpm(&hpm_core);
+	adjust_hpm(&hpm_core, temperature);
+	hpm_check(&hpm_core);
+
+	set_hpm_core_volt(hpm_core);
+	delay(200); /* delay 200ms */
+}
+
+
+/* [CUSTOM] DDR PHY0-PHY1 base register */
+#define DDR_REG_BASE_PHY0       0x120dc000
+
+/* [CUSTOM] DDR DMC0-DMC3 base register */
+#define DDR_REG_BASE_DMC0       0x120d8000
+#define DDR_REG_BASE_DMC1       0x120d8000
+
+#ifdef DDR_REG_BASE_PHY1
+#define DDR_REG_BASE_DMC2       0x120d9000
+#define DDR_REG_BASE_DMC3       0x120d9000
+#endif
+
+#define CRG_REG_BASE            0x12010000
+#define PERI_CRG_DDRT           0x198
+
+#define DDR_REG_BASE_SYSCTRL    0x12020000
+/* [SYSCTRL]RAM Retention control register 0 */
+#define SYSCTRL_MISC_CTRL4      0x8010
+
+#define DDR_PHY_DRAMCFG         0x2c    /* DRAM config register */
+#define PHY_DRAMCFG_TYPE_MASK   0xf /* [3:0] */
+#define PHY_DRAMCFG_TYPE_LPDDR4 0x6   /* [2:0] 110 LPDDR4 */
+
+#define BYTE_NUM  2
+
+/**
+ * ddr_boot_prepare
+ * @void
+ *
+ * Do some prepare before ddr training.
+ * Keep empty when nothing to do.
+ */
+static void ddr_boot_prepare(struct tr_relate_reg *reg)
+{
+	/* select ddrt bus path */
+	reg->custom.ive_ddrt_mst_sel = readl(DDR_REG_BASE_SYSCTRL + SYSCTRL_MISC_CTRL4);
+	writel(reg->custom.ive_ddrt_mst_sel & 0xffffffdf,
+		   DDR_REG_BASE_SYSCTRL + SYSCTRL_MISC_CTRL4);
+
+	/* turn on ddrt clock */
+	reg->custom.ddrt_clk_reg = readl(CRG_REG_BASE + PERI_CRG_DDRT);
+	/* enable ddrt0 clock */
+	writel(reg->custom.ddrt_clk_reg | (0x1 << 1), CRG_REG_BASE + PERI_CRG_DDRT);
+	__asm__ __volatile__("nop");
+	/* disable ddrt0 soft reset */
+	writel(readl(CRG_REG_BASE + PERI_CRG_DDRT) & (~(0x1 << 0)),
+		   CRG_REG_BASE + PERI_CRG_DDRT);
+
+	/* disable rdqs anti-aging */
+	reg->custom.phy0_age_compst_en = readl(DDR_REG_BASE_PHY0 + DDR_PHY_PHYRSCTRL);
+	writel((reg->custom.phy0_age_compst_en & 0x7fffffff),
+		   DDR_REG_BASE_PHY0 + DDR_PHY_PHYRSCTRL);
+#ifdef DDR_REG_BASE_PHY1
+	reg->custom.phy1_age_compst_en = readl(DDR_REG_BASE_PHY1 + DDR_PHY_PHYRSCTRL);
+	writel((reg->custom.phy1_age_compst_en & 0x7fffffff),
+		   DDR_REG_BASE_PHY1 + DDR_PHY_PHYRSCTRL);
+#endif
+}
+
+/**
+ * ddr_boot_restore
+ * @void
+ *
+ * Restore register config after ddr training.
+ * Keep empty when nothing to do.
+ */
+static void ddr_boot_restore(struct tr_relate_reg *reg)
+{
+	/* restore ddrt bus path */
+	writel(reg->custom.ive_ddrt_mst_sel, DDR_REG_BASE_SYSCTRL + SYSCTRL_MISC_CTRL4);
+
+	/* restore ddrt clock */
+	writel(reg->custom.ddrt_clk_reg, CRG_REG_BASE + PERI_CRG_DDRT);
+
+	/* restore rdqs anti-aging */
+	writel(reg->custom.phy0_age_compst_en, DDR_REG_BASE_PHY0 + DDR_PHY_PHYRSCTRL);
+#ifdef DDR_REG_BASE_PHY1
+	writel(reg->custom.phy1_age_compst_en, DDR_REG_BASE_PHY1 + DDR_PHY_PHYRSCTRL);
+#endif
+}
+
+/**
+ * ddr_rdqs_bdl_adj
+ * @void
+ *
+ * Adjust rdqs/rdq/rdm bdl to avoid problem cause by ddr anti-aging.
+ */
+#if 0
+static void ddr_rdqs_bdl_adj(void)
+{
+	int i;
+	unsigned int rdqs;
+	unsigned int rdq03, rdq47;
+	unsigned int rdm;
+	unsigned int tmp;
+
+	for (i = 0; i < BYTE_NUM; i++) {
+		rdqs = readl(DDR_REG_BASE_PHY0 + 0x22c + i * 0x80);
+		rdq03 = readl(DDR_REG_BASE_PHY0 + 0x21c + i * 0x80);
+		rdq47 = readl(DDR_REG_BASE_PHY0 + 0x220 + i * 0x80);
+		rdm = readl(DDR_REG_BASE_PHY0 + 0x224 + i * 0x80);
+
+		/* rdqs bdl lower two bit shoud be 0x11 */
+		while ((rdqs & 0x3) < 0x3) {
+			/* rdqs/rdq/rdm bdl + 1 */
+			rdqs = rdqs + 0x1;
+			rdq03 = rdq03 + 0x01010101;
+			rdq47 = rdq47 + 0x01010101;
+			rdm = rdm + 0x1;
+
+			writel(rdqs, DDR_REG_BASE_PHY0 + 0x22c + i * 0x80);
+			writel(rdq03, DDR_REG_BASE_PHY0 + 0x21c + i * 0x80);
+			writel(rdq47, DDR_REG_BASE_PHY0 + 0x220 + i * 0x80);
+			writel(rdm, DDR_REG_BASE_PHY0 + 0x224 + i * 0x80);
+		}
+	}
+
+	tmp = readl(DDR_REG_BASE_PHY0 + DDR_PHY_MISC);
+	tmp |= (1 << PHY_MISC_UPDATE_BIT);
+	/* update new config to PHY */
+	writel(tmp, DDR_REG_BASE_PHY0 + DDR_PHY_MISC);
+	tmp &= ~(1 << PHY_MISC_UPDATE_BIT);
+	writel(tmp, DDR_REG_BASE_PHY0 + DDR_PHY_MISC);
+	tmp = readl(DDR_REG_BASE_PHY0 + DDR_PHY_PHYINITCTRL);
+	/* set 1 to issue PHY counter reset signal */
+	tmp |= (1 << PHY_PHYCONN_RST_BIT);
+	writel(tmp, DDR_REG_BASE_PHY0 + DDR_PHY_PHYINITCTRL);
+	/* set 0 to end the reset signal */
+	tmp &= ~(1 << PHY_PHYCONN_RST_BIT);
+	writel(tmp, DDR_REG_BASE_PHY0 + DDR_PHY_PHYINITCTRL);
+}
+#endif
+
+#define OTP_CPU_CLK_OFFSET	0x0084
+#define CRG32_CPU_CLK_OFFSET	0x0080
+#define CRG123_CPU_CLK_OFFSET	0x01EC
+
+static void switch_cpu_freq(void)
+{
+	unsigned int mux_chn;
+	unsigned int reg_val;
+
+	if (readl(SYS_CTRL_REG_BASE + REG_SC_GEN5) != 0x1)
+		return;
+
+	mux_chn = readl(SYS_CTRL_REG_BASE + OTP_CPU_CLK_OFFSET);
+	mux_chn = (mux_chn >> 1) & 0x3;
+
+	reg_val = readl(CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+	reg_val |= 0x3;
+	writel(reg_val, CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+
+	if ((mux_chn == 0) || (mux_chn == 3)) {
+		reg_val = readl(CRG_REG_BASE + CRG123_CPU_CLK_OFFSET);
+		reg_val &= ~0x1;
+		writel(reg_val, CRG_REG_BASE + CRG123_CPU_CLK_OFFSET);
+		delay(1);
+
+		reg_val = readl(CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+		reg_val &= ~0x3;
+		reg_val |= 0x1;
+		writel(reg_val, CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+	} else if (mux_chn == 1) {
+		reg_val = readl(CRG_REG_BASE + CRG123_CPU_CLK_OFFSET);
+		reg_val |= 0x1;
+		writel(reg_val, CRG_REG_BASE + CRG123_CPU_CLK_OFFSET);
+		delay(1);
+
+		reg_val = readl(CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+		reg_val &= ~0x3;
+		writel(reg_val, CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+	} else if (mux_chn == 2) {
+		reg_val = readl(CRG_REG_BASE + CRG123_CPU_CLK_OFFSET);
+		reg_val |= 0x1;
+		writel(reg_val, CRG_REG_BASE + CRG123_CPU_CLK_OFFSET);
+		delay(1);
+
+		reg_val = readl(CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+		reg_val &= ~0x3;
+		reg_val |= 0x2;
+		writel(reg_val, CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+	}
+
+}
+
+void start_ddr_training(unsigned int base)
+{
+	struct tr_relate_reg relate_reg;
+	struct tr_relate_reg *reg = &relate_reg;
+
+//	start_svb();
+	switch_cpu_freq();
+
+	ddr_boot_prepare(reg);
+
+	/* ddr pcode training */
+//	ddr_pcode_training_if();
+	/* ddr hw training */
+	ddr_hw_training_if();
+	/* ddr sw training */
+	ddr_sw_training_if();
+
+//	ddr_rdqs_bdl_adj();
+
+	ddr_boot_restore(reg);
+
+	/* the value should config after trainning, or
+	  it will cause chip compatibility problems */
+	if ((readl(DDR_REG_BASE_PHY0 + DDR_PHY_DRAMCFG) &
+		PHY_DRAMCFG_TYPE_MASK) == PHY_DRAMCFG_TYPE_LPDDR4) {
+		writel(0x401, DDR_REG_BASE_DMC0 + 0x28);
+		writel(0x401, DDR_REG_BASE_DMC1 + 0x28);
+	} else {
+		writel(0x401, DDR_REG_BASE_DMC0 + 0x28);
+	}
+#ifdef DDR_REG_BASE_PHY1
+	if ((readl(DDR_REG_BASE_PHY1 + DDR_PHY_DRAMCFG) &
+		PHY_DRAMCFG_TYPE_MASK) == PHY_DRAMCFG_TYPE_LPDDR4) {
+		writel(0x401, DDR_REG_BASE_DMC2 + 0x28);
+		writel(0x401, DDR_REG_BASE_DMC3 + 0x28);
+	} else {
+		writel(0x401, DDR_REG_BASE_DMC1 + 0x28);
+	}
+#endif
+	/* enable ddr scramb */
+}
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v300/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v300/Makefile
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v300/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v300/Makefile	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,100 @@
+PWD           = $(shell pwd)
+SRCDIR        =
+OUTDIR        =
+
+################################################################################
+CC       := $(CROSS_COMPILE)gcc
+AR       := $(CROSS_COMPILE)ar
+LD       := $(CROSS_COMPILE)ld
+OBJCOPY  := $(CROSS_COMPILE)objcopy
+
+
+################################################################################
+BOOT     := u-boot-$(SOC)
+TEXTBASE := 0x40700000
+
+CFLAGS   :=-Os -fno-builtin -ffreestanding \
+	-D__KERNEL__ -DTEXT_BASE=$(TEXTBASE) \
+	-I$(SRCDIR)/include \
+	-I$(OUTDIR)/include \
+	-I$(SRCDIR)/drivers/ddr/goke/default \
+	-I$(SRCDIR)/drivers/ddr/goke/$(SOC) \
+	-I$(SRCDIR)/arch/arm/include \
+	-I$(SRCDIR)/lib/hw_dec \
+	-fno-pic -ffunction-sections \
+	-fdata-sections -fno-common -ffixed-r9    \
+	-fno-common -pipe -march=armv7-a \
+	-Wall -Wstrict-prototypes -fno-stack-protector \
+	-D__LINUX_ARM_ARCH__=7 -D__ARM__ \
+	-DCONFIG_MMC\
+	$(MKFLAGS) -fno-strict-aliasing
+
+################################################################################
+COBJS := start.o \
+	lowlevel_init_v300.o \
+	init_registers.o \
+	emmc_boot.o \
+	uart.o \
+	ddr_training_impl.o \
+	ddr_training_ctl.o \
+	ddr_training_boot.o \
+	ddr_training_custom.o \
+	ddr_training_console.o \
+	hw_decompress.o \
+	startup.o \
+	image_data.o \
+	div0.o \
+	reset.o
+
+REG := $(wildcard $(OUTDIR)/*.reg $(OUTDIR)/.reg)
+
+################################################################################
+.PHONY: $(BOOT).bin
+$(BOOT).bin: $(BOOT).tmp regfile
+	@dd if=./$(BOOT).tmp of=./tmp1 bs=1 count=64 2>/dev/null
+	@dd if=$(REG) of=./tmp2 bs=5120 conv=sync 2>/dev/null
+	@dd if=./$(BOOT).tmp of=./tmp3 bs=1 skip=5184 2>/dev/null
+	@cat tmp1 tmp2 tmp3 > $(BOOT).bin
+	@rm -f tmp1 tmp2 tmp3
+	@chmod 754 $(BOOT).bin
+	@cp -fv $@ $(OUTDIR)
+	@echo $(BOOT).bin is Ready.
+
+$(BOOT).tmp: $(BOOT).elf
+	$(OBJCOPY) -O srec $< $(BOOT).srec
+	$(OBJCOPY) -j .text -O binary $< $(BOOT).text
+	$(OBJCOPY) --gap-fill=0xff -O binary $< $@
+
+$(BOOT).elf: image_data.gzip $(COBJS)
+	$(LD) -Bstatic -T u-boot.lds -Ttext $(TEXTBASE) \
+		$(COBJS) -Map $(BOOT).map -o $@
+	$(OBJDUMP) -d  $@ > $@.asm
+
+.PHONY: regfile
+regfile:
+	@if [ "$(words $(REG))" = "0" ]; then ( \
+		echo '***' Need '.reg' or '*.reg' file in directory $(OUTDIR); \
+		exit 1; \
+	) fi
+	@if [ "$(words $(REG))" != "1" ]; then ( \
+		echo '***' Found multi '.reg' or '*.reg' file in directory $(OUTDIR); \
+		echo '***' Files: $(notdir $(REG)); \
+		exit 1; \
+	) fi
+
+################################################################################
+
+# -1 : --fast      -9 : --best
+image_data.gzip: $(BINIMAGE)
+	$(OUTDIR)/../../../tools/utils/bin/gzip -fNqc -7 $< > $@
+
+%.o: %.c
+	$(CC) $(CFLAGS) -Wall -Wstrict-prototypes \
+		-fno-stack-protector -o $@ $< -c
+
+%.o: %.S
+	$(CC) -D__ASSEMBLY__ $(CFLAGS) -o $@ $< -c
+
+image_data.o: image_data.S image_data.gzip
+	$(CC) -D__ASSEMBLY__ $(CFLAGS) -o $@ $< -c
+
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v300/reset.S gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v300/reset.S
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v300/reset.S	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v300/reset.S	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,18 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <config.h>
+
+.global reset_cpu
+reset_cpu:
+	ldr	r1, rstctl			@ get addr for global reset
+						@ reg
+	mov	r3, #0x2			@ full reset pll + mpu
+	str	r3, [r1]			@ force reset
+	mov	r0, r0
+
+_loop_forever:
+	b	_loop_forever
+rstctl:
+	.word  SYS_CTRL_REG_BASE + REG_SC_SYSRES
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v300/start.S gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v300/start.S
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v300/start.S	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v300/start.S	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,504 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <asm-offsets.h>
+#include <config.h>
+#include <asm/system.h>
+#include <linux/linkage.h>
+#include <asm/armv7.h>
+
+/*************************************************************************
+ *
+ * Startup Code (reset vector)
+ *
+ * Do important init only if we don't start from memory!
+ * Setup memory and board specific bits prior to relocation.
+ * Relocate armboot to ram. Setup stack.
+ *
+ *************************************************************************/
+.globl	_start
+_start:
+	b	reset
+    b .
+    b .
+    b .
+    b .
+    b .
+    b .
+    b .
+	.balignl 64,0xdeadbeef
+	
+	.globl	reset
+	.globl	save_boot_params_ret
+#ifdef CONFIG_ARMV7_LPAE
+	.global	switch_to_hypervisor_ret
+#endif
+
+ __blank_zone_start:
+	.fill 1024*5,1,0
+__blank_zone_end:
+
+	.globl _blank_zone_start
+_blank_zone_start:
+	.word __blank_zone_start
+
+
+	.globl _blank_zone_end
+_blank_zone_end:
+	.word __blank_zone_end
+
+	.balignl 16,0xdeadbeef
+	.globl	_TEXT_BASE
+_TEXT_BASE:
+	.word TEXT_BASE
+ 
+
+_clr_remap_fmc_entry:
+	.word   FMC_MEM_BASE + do_clr_remap - CONFIG_SYS_TEXT_BASE_ORI
+
+_start_armboot:
+	.word start_armboot
+
+reset:
+	/* Allow the board to save important registers */
+	b	save_boot_params
+save_boot_params_ret:
+#ifdef CONFIG_ARMV7_LPAE
+/*
+ * check for Hypervisor support
+ */
+	mrc	p15, 0, r0, c0, c1, 1		@ read ID_PFR1
+	and	r0, r0, #CPUID_ARM_VIRT_MASK	@ mask virtualization bits
+	cmp	r0, #(1 << CPUID_ARM_VIRT_SHIFT)
+	beq	switch_to_hypervisor
+switch_to_hypervisor_ret:
+#endif
+	/*
+	 * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,
+	 * except if in HYP mode already
+	 */
+	mrs	r0, cpsr
+	and	r1, r0, #0x1f		@ mask mode bits
+	teq	r1, #0x1a		@ test for HYP mode
+	bicne	r0, r0, #0x1f		@ clear all mode bits
+	orrne	r0, r0, #0x13		@ set SVC mode
+	orr	r0, r0, #0xc0		@ disable FIQ and IRQ
+	msr	cpsr,r0
+
+/*
+ * Setup vector:
+ * (OMAP4 spl TEXT_BASE is not 32 byte aligned.
+ * Continue to use ROM code vector only in OMAP4 spl)
+ */
+#if !(defined(CONFIG_OMAP44XX) && defined(CONFIG_SPL_BUILD))
+	/* Set V=0 in CP15 SCTLR register - for VBAR to point to vector */
+	mrc	p15, 0, r0, c1, c0, 0	@ Read CP15 SCTLR Register
+	bic	r0, #CR_V		@ V = 0
+	mcr	p15, 0, r0, c1, c0, 0	@ Write CP15 SCTLR Register
+
+	/* Set vector address in CP15 VBAR register */
+	adrl	r0, _start
+	mcr	p15, 0, r0, c12, c0, 0	@Set VBAR
+#endif
+
+	/* the mask ROM code should have PLL and others stable */
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
+	bl	cpu_init_cp15
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT_ONLY
+	bl	cpu_init_crit
+#endif
+#endif
+
+#ifndef CONFIG_GK_DISABLE_DOWNLOAD
+	/*
+	 *  read system register REG_SC_GEN2
+         *  check if ziju flag
+	 */
+	ldr	r0, =SYS_CTRL_REG_BASE
+	ldr	r1, [r0, #REG_SC_GEN2]
+	ldr	r2, =0x7a696a75          /* magic for "ziju" */
+	cmp	r1, r2
+	bne	normal_start_flow
+	mov	r1, sp                   /* save sp */
+	str	r1, [r0, #REG_SC_GEN2]  /* clear ziju flag */
+
+    /* init PLL/DDRC/pin mux/... */
+	ldr	r0, _blank_zone_start
+	ldr	r1, _TEXT_BASE
+	sub	r0, r0, r1
+	ldr	r1, =RAM_START_ADRS
+	ldr	sp, =STACK_TRAINING
+	add	r0, r0, r1
+	mov	r1, #0x0                 /* flags: 0->normal 1->pm */
+	bl	init_registers           /* init PLL/DDRC/... */
+	/* after ziju, we need ddr traning */
+	ldr	r0, =SYS_CTRL_REG_BASE
+	bl	start_ddr_training       /* DDR training */
+    ldr	r0, =SYS_CTRL_REG_BASE
+	ldr	r1, [r0, #REG_SC_GEN2]
+	mov	sp, r1		         /* restore sp */
+	ldr	r1, [r0, #REG_SC_GEN3]
+	mov	pc, r1                  /* return to bootrom */
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	b	.                        /* bug here */
+
+normal_start_flow:
+#endif
+	/* init serial and printf a string. */
+	ldr     sp, =STACK_TRAINING
+	bl      uart_early_init
+	bl      msg_main_cpu_startup
+
+	/*
+	 * enable syscnt 
+	 */
+	ldr	r0, =SYSCNT_REG_BASE
+	ldr 	r3, =SYSCNT_FREQ
+	str	r3, [r0, #SYSCNT_FREQ_REG]
+	mov	r3, #0x1
+	str	r3, [r0, #SYSCNT_ENABLE_REG]
+
+	@if running not boot from nand/spi/emmc,
+	@we skipping boot_type checking.
+	mov    r0, pc, lsr#24
+	cmp    r0, #0x0
+	bne    do_clr_remap
+
+check_boot_type:
+    ldr     r0, =SYS_CTRL_REG_BASE
+    ldr     r0, [r0, #REG_SYSSTAT]
+    mov     r6, r0, lsr#4
+	and     r6, #0x1
+    cmp     r6, #0x1
+    ldrlo   pc, _clr_remap_fmc_entry
+
+do_clr_remap:
+        /* do clear remap */
+	ldr     r4, =SYS_CTRL_REG_BASE
+	ldr	r0, [r4, #REG_SC_CTRL]
+
+	@Set clear remap bit.
+	orr	r0, #(1<<8)
+	str	r0, [r4, #REG_SC_CTRL]
+
+	@enable I-Cache now
+	mrc p15, 0, r0, c1, c0, 0
+    orr r0, r0, #0x00001000 /* set bit 12 (I) I-Cache */
+    mcr p15, 0, r0, c1, c0, 0
+
+	@Check wether I'm running in dynamic mem bank:<0x40000000
+	mov r0, pc, lsr#28
+	cmp r0, #4
+	blo	ddr_init
+
+no_ddr_init:
+	adrl	r0, _start
+	b       copy_to_ddr
+
+ddr_init:
+	ldr     r0, _blank_zone_start
+	ldr     r1, _TEXT_BASE
+	sub     r0, r0, r1
+	adrl	r1, _start
+	add     r0, r0, r1
+	mov     r1, #0          /* flags: 0->normal 1->pm */
+	bl      init_registers
+
+	ldr	sp, =STACK_TRAINING
+	ldr	r0, =SYS_CTRL_REG_BASE
+	bl	start_ddr_training       /* DDR training */
+
+check_boot_mode:
+	ldr	r0, =SYS_CTRL_REG_BASE
+	ldr     r0, [r0, #REG_SYSSTAT]
+	mov     r6, r0, lsr#4
+	and	r6, #0x1
+	cmp     r6, #BOOT_FROM_EMMC
+	bne     copy_flash_to_ddr
+
+emmc_boot:
+	ldr     r0, _TEXT_BASE
+	ldr	r1, =__image_copy_start
+	ldr	r2, =__bss_start
+	sub	r1, r2, r1
+	bl	emmc_boot_read
+	b       relocate
+
+copy_flash_to_ddr:
+	/* relocate SPI nor/nand Boot to DDR  */
+	ldr	r0, =FMC_MEM_BASE
+
+copy_to_ddr:
+	/* now, r0 stores __reset offset from where we get started */
+	ldr     r1, =__image_copy_start
+
+	/* compare source and target address, *
+	 *if equal no copy to target address */
+	cmp     r0, r1
+	beq	start_armboot
+
+	ldr     r2, =__image_copy_start/*_start*/
+	ldr     r3, =__bss_start
+	sub     r2, r3, r2      /* r2 <- size of armboot */
+	/* memcpy(r1, r0, r2) */
+	bl      memcpy
+
+relocate:
+	ldr r0, =_start_armboot
+	ldr pc, [r0]
+
+bug:
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	b       .                       /* bug here */
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+@
+@       void memcpy(r1, r0, r2);
+@
+
+.align  2
+memcpy:
+	add     r2, r0, r2
+	memcpy_loop:
+	ldmia   r0!, {r3 - r10}
+	stmia   r1!, {r3 - r10}
+	cmp     r0, r2
+	ble     memcpy_loop
+	mov     pc, lr
+
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+.align  2
+msg_main_cpu_startup:
+	mov     r5, lr
+	add     r0, pc, #4
+	bl      uart_early_puts
+	mov     pc, r5
+	L10:
+#ifndef CONFIG_SUPPORT_CA_RELEASE
+	.ascii "\r\n\r\nSystem startup\r\n\0"
+#else
+	.ascii "\r\n\r\n\r\n\0"
+#endif
+
+/*------------------------------------------------------------------------------*/
+
+ENTRY(c_runtime_cpu_setup)
+/*
+ * If I-cache is enabled invalidate it
+ */
+#ifndef CONFIG_SYS_ICACHE_OFF
+	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
+	mcr     p15, 0, r0, c7, c10, 4	@ DSB
+	mcr     p15, 0, r0, c7, c5, 4	@ ISB
+#endif
+
+	bx	lr
+
+ENDPROC(c_runtime_cpu_setup)
+
+/*************************************************************************
+ *
+ * void save_boot_params(u32 r0, u32 r1, u32 r2, u32 r3)
+ *	__attribute__((weak));
+ *
+ * Stack pointer is not yet initialized at this moment
+ * Don't save anything to stack even if compiled with -O0
+ *
+ *************************************************************************/
+ENTRY(save_boot_params)
+	b	save_boot_params_ret		@ back to my caller
+ENDPROC(save_boot_params)
+	.weak	save_boot_params
+
+#ifdef CONFIG_ARMV7_LPAE
+ENTRY(switch_to_hypervisor)
+	b	switch_to_hypervisor_ret
+ENDPROC(switch_to_hypervisor)
+	.weak	switch_to_hypervisor
+#endif
+
+/*************************************************************************
+ *
+ * cpu_init_cp15
+ *
+ * Setup CP15 registers (cache, MMU, TLBs). The I-cache is turned on unless
+ * CONFIG_SYS_ICACHE_OFF is defined.
+ *
+ *************************************************************************/
+ENTRY(cpu_init_cp15)
+	/*
+	 * Invalidate L1 I/D
+	 */
+	mov	r0, #0			@ set up for MCR
+	mcr	p15, 0, r0, c8, c7, 0	@ invalidate TLBs
+	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
+	mcr	p15, 0, r0, c7, c5, 6	@ invalidate BP array
+	mcr     p15, 0, r0, c7, c10, 4	@ DSB
+	mcr     p15, 0, r0, c7, c5, 4	@ ISB
+
+	/*
+	 * disable MMU stuff and caches
+	 */
+	mrc	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #0x00002000	@ clear bits 13 (--V-)
+	bic	r0, r0, #0x00000007	@ clear bits 2:0 (-CAM)
+	orr	r0, r0, #0x00000002	@ set bit 1 (--A-) Align
+	orr	r0, r0, #0x00000800	@ set bit 11 (Z---) BTB
+#ifdef CONFIG_SYS_ICACHE_OFF
+	bic	r0, r0, #0x00001000	@ clear bit 12 (I) I-cache
+#else
+	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-cache
+#endif
+	mcr	p15, 0, r0, c1, c0, 0
+
+#ifdef CONFIG_ARM_ERRATA_716044
+	mrc	p15, 0, r0, c1, c0, 0	@ read system control register
+	orr	r0, r0, #1 << 11	@ set bit #11
+	mcr	p15, 0, r0, c1, c0, 0	@ write system control register
+#endif
+
+#if (defined(CONFIG_ARM_ERRATA_742230) || defined(CONFIG_ARM_ERRATA_794072))
+	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register
+	orr	r0, r0, #1 << 4		@ set bit #4
+	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_743622
+	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register
+	orr	r0, r0, #1 << 6		@ set bit #6
+	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_751472
+	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register
+	orr	r0, r0, #1 << 11	@ set bit #11
+	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register
+#endif
+#ifdef CONFIG_ARM_ERRATA_761320
+	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register
+	orr	r0, r0, #1 << 21	@ set bit #21
+	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register
+#endif
+
+	mov	r5, lr			@ Store my Caller
+	mrc	p15, 0, r1, c0, c0, 0	@ r1 has Read Main ID Register (MIDR)
+	mov	r3, r1, lsr #20		@ get variant field
+	and	r3, r3, #0xf		@ r3 has CPU variant
+	and	r4, r1, #0xf		@ r4 has CPU revision
+	mov	r2, r3, lsl #4		@ shift variant field for combined value
+	orr	r2, r4, r2		@ r2 has combined CPU variant + revision
+
+#ifdef CONFIG_ARM_ERRATA_798870
+	cmp	r2, #0x30		@ Applies to lower than R3p0
+	bge	skip_errata_798870      @ skip if not affected rev
+	cmp	r2, #0x20		@ Applies to including and above R2p0
+	blt	skip_errata_798870      @ skip if not affected rev
+
+	mrc	p15, 1, r0, c15, c0, 0  @ read l2 aux ctrl reg
+	orr	r0, r0, #1 << 7         @ Enable hazard-detect timeout
+	push	{r1-r5}			@ Save the cpu info registers
+	bl	v7_arch_cp15_set_l2aux_ctrl
+	isb				@ Recommended ISB after l2actlr update
+	pop	{r1-r5}			@ Restore the cpu info - fall through
+skip_errata_798870:
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_801819
+	cmp	r2, #0x24		@ Applies to lt including R2p4
+	bgt	skip_errata_801819      @ skip if not affected rev
+	cmp	r2, #0x20		@ Applies to including and above R2p0
+	blt	skip_errata_801819      @ skip if not affected rev
+	mrc	p15, 0, r0, c0, c0, 6	@ pick up REVIDR reg
+	and	r0, r0, #1 << 3		@ check REVIDR[3]
+	cmp	r0, #1 << 3
+	beq	skip_errata_801819	@ skip erratum if REVIDR[3] is set
+
+	mrc	p15, 0, r0, c1, c0, 1	@ read auxilary control register
+	orr	r0, r0, #3 << 27	@ Disables streaming. All write-allocate
+					@ lines allocate in the L1 or L2 cache.
+	orr	r0, r0, #3 << 25	@ Disables streaming. All write-allocate
+					@ lines allocate in the L1 cache.
+	push	{r1-r5}			@ Save the cpu info registers
+	bl	v7_arch_cp15_set_acr
+	pop	{r1-r5}			@ Restore the cpu info - fall through
+skip_errata_801819:
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_454179
+	cmp	r2, #0x21		@ Only on < r2p1
+	bge	skip_errata_454179
+
+	mrc	p15, 0, r0, c1, c0, 1	@ Read ACR
+	orr	r0, r0, #(0x3 << 6)	@ Set DBSM(BIT7) and IBE(BIT6) bits
+	push	{r1-r5}			@ Save the cpu info registers
+	bl	v7_arch_cp15_set_acr
+	pop	{r1-r5}			@ Restore the cpu info - fall through
+
+skip_errata_454179:
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_430973
+	cmp	r2, #0x21		@ Only on < r2p1
+	bge	skip_errata_430973
+
+	mrc	p15, 0, r0, c1, c0, 1	@ Read ACR
+	orr	r0, r0, #(0x1 << 6)	@ Set IBE bit
+	push	{r1-r5}			@ Save the cpu info registers
+	bl	v7_arch_cp15_set_acr
+	pop	{r1-r5}			@ Restore the cpu info - fall through
+
+skip_errata_430973:
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_621766
+	cmp	r2, #0x21		@ Only on < r2p1
+	bge	skip_errata_621766
+
+	mrc	p15, 0, r0, c1, c0, 1	@ Read ACR
+	orr	r0, r0, #(0x1 << 5)	@ Set L1NEON bit
+	push	{r1-r5}			@ Save the cpu info registers
+	bl	v7_arch_cp15_set_acr
+	pop	{r1-r5}			@ Restore the cpu info - fall through
+
+skip_errata_621766:
+#endif
+
+	mov	pc, r5			@ back to my caller
+ENDPROC(cpu_init_cp15)
+
+#if !defined(CONFIG_SKIP_LOWLEVEL_INIT) && \
+	!defined(CONFIG_SKIP_LOWLEVEL_INIT_ONLY)
+/*************************************************************************
+ *
+ * CPU_init_critical registers
+ *
+ * setup important registers
+ * setup memory timing
+ *
+ *************************************************************************/
+ENTRY(cpu_init_crit)
+	/*
+	 * Jump to board specific initialization...
+	 * The Mask ROM will have already initialized
+	 * basic memory. Go here to bump up clock rate and handle
+	 * wake up conditions.
+	 */
+	b	lowlevel_init		@ go setup pll,mux,memory
+ENDPROC(cpu_init_crit)
+#endif
+
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v300/startup.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v300/startup.c
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v300/startup.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v300/startup.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,156 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <config.h>
+#include <linux/kconfig.h>
+#include <asm/io.h>
+#include <compiler.h>
+#include <cpu_common.h>
+
+extern unsigned int hw_dec_type;
+
+extern void hw_dec_init(void);
+extern int hw_dec_decompress(unsigned char *dst, int *dstlen,
+		      unsigned char *src, int srclen,
+		      void *unused);
+extern void hw_dec_uinit(void);
+
+/******************************************************************************/
+const uintptr_t image_entry = (CONFIG_SYS_TEXT_BASE);
+
+/******************************************************************************/
+
+#define GZIP_SIZE_OFFSET 0x4
+
+#ifndef CONFIG_SYS_ICACHE_OFF
+/* Invalidate entire I-cache and branch predictor array */
+static void invalidate_icache_all(void)
+{
+	/*
+	 * Invalidate all instruction caches to PoU.
+	 * Also flushes branch target cache.
+	 */
+	asm volatile("mcr p15, 0, %0, c7, c5, 0" : : "r"(0));
+
+	/* Invalidate entire branch predictor array */
+	asm volatile("mcr p15, 0, %0, c7, c5, 6" : : "r"(0));
+
+	/* Full system DSB - make sure that the invalidation is complete */
+	dsb();
+
+	/* ISB - make sure the instruction stream sees it */
+	isb();
+}
+#else
+static void invalidate_icache_all(void)
+{
+}
+#endif
+
+/******************************************************************************/
+void start_armboot(void)
+{
+	unsigned char *pdst_l32 = NULL;
+	unsigned int image_data_len;
+	int pdst_len;
+	int ret;
+	int i;
+	char *p = NULL;
+	char *q = NULL;
+
+	uart_early_init();
+	uart_early_puts("\r\nUncompress ");
+
+	/* use direct address mode */
+	hw_dec_type = 0;
+	/* init hw decompress IP */
+	hw_dec_init();
+
+	/* start decompress */
+	pdst_l32 = (unsigned char *)(uintptr_t)image_entry;
+	image_data_len = input_data_end - input_data;
+
+	/* get dets length from compress image */
+	p = (char *)&pdst_len;
+	q = (char *)(input_data_end - GZIP_SIZE_OFFSET);
+	for (i = 0; i < sizeof(int); i++)
+		p[i] = q[i];
+
+	ret = hw_dec_decompress(pdst_l32, &pdst_len, input_data, image_data_len, NULL);
+	if (!ret) {
+		uart_early_puts("Ok!");
+	} else {
+		uart_early_puts("Fail!");
+		while (1) ;
+	}
+	/* uinit hw decompress IP */
+	hw_dec_uinit();
+	void (*uboot)(void);
+	uboot = (void (*))CONFIG_SYS_TEXT_BASE;
+	invalidate_icache_all();
+	uboot();
+}
+
+void hang(void)
+{
+	uart_early_puts("### ERROR ### Please RESET the board ###\n");
+	for (;;) ;
+}
+
+
+void do_bad_sync(void)
+{
+	uart_early_puts("bad sync abort\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_sync(void)
+{
+	uart_early_puts("sync abort\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_bad_error(void)
+{
+	uart_early_puts("bad error\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_error(void)
+{
+	uart_early_puts("error\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_bad_fiq(void)
+{
+	uart_early_puts("bad fast interrupt request\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_bad_irq(void)
+{
+	uart_early_puts("bad interrupt request\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_fiq(void)
+{
+	uart_early_puts("fast interrupt request\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_irq(void)
+{
+	uart_early_puts("interrupt request\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v300/uart.S gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v300/uart.S
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v300/uart.S	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v300/uart.S	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,126 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <config.h>
+
+@******************************************************************************
+@
+@  void uart_early_init(void);
+@
+.text
+.align	2
+.global	uart_early_init
+.type	uart_early_init, %function
+uart_early_init:
+#ifndef CONFIG_GK_DISABLE_CONSOLE
+	ldr	a4, uart_base_addr_L0
+	mov	a3, #0
+	/* Disable UART */
+	str	a3, [a4, #48]
+	/* Set baud rate to 115200, uart clock:24M */
+	add	a3, a3, #13
+	str	a3, [a4, #36]
+	mov	a3, #1
+	str	a3, [a4, #40]
+	/* Set the UART to be 8 bits, 1 stop bit, no parity, fifo enabled. */
+	ldr	a3, =112
+	str	a3, [a4, #44]
+	/* Enable UART */
+	ldr	a3, =769
+	str	a3, [a4, #48]
+#endif
+	bx	lr
+uart_base_addr_L0:
+	.word CONFIG_CUR_UART_BASE
+
+@******************************************************************************
+@
+@  void uart_early_puts(const char *ss);
+@
+.align	2
+.global	uart_early_puts
+.type	uart_early_puts, %function
+uart_early_puts:
+#ifndef CONFIG_GK_DISABLE_CONSOLE
+#if !defined(CONFIG_SUPPORT_CA_RELEASE)
+	ldr	a2, uart_base_addr_L1
+	b	next_char
+output:
+	ldr	a4, [a2, #24]
+	tst	a4, #32
+	bne	output
+	str	a3, [a2, #0]
+	add	a1, a1, #1
+next_char:
+	ldrb	a3, [a1]
+	cmp	a3, #0
+	bne	output
+#endif /* CONFIG_SUPPORT_CA_RELEASE */
+#endif /* CONFIG_GK_DISABLE_CONSOLE */
+	bx	lr
+uart_base_addr_L1:
+	.word CONFIG_CUR_UART_BASE
+
+@******************************************************************************
+@
+@  void uart_early_put_hex(int hex);
+@
+@  call example:
+@    mov	r0, sp
+@    bl	uart_early_put_hex
+@
+.align	2
+.global	uart_early_put_hex
+.type	uart_early_put_hex, %function
+uart_early_put_hex:
+#if !defined(CONFIG_SUPPORT_CA_RELEASE)
+	ldr	a2, uart_base_addr_L2
+	mov	a3, #28
+wait2:
+	ldr	a4, [a2, #24]
+	tst	a4, #32
+	bne	wait2
+
+	mov	a4, #0xF
+	and	a4, a4, a1, lsr a3
+	cmp	a4, #9
+	addle	a4, a4, #0x30	@ a4 = a4 + '0'
+	addgt	a4, a4, #55	@ a4 = a4 - 10 + 'A'
+	str	a4, [a2, #0]
+	cmp	a3, #0
+	beq	exit2
+	sub	a3, a3, #4
+	b	wait2
+exit2:
+#endif /* CONFIG_SUPPORT_CA_RELEASE */
+	bx	lr
+uart_base_addr_L2:
+	.word CONFIG_CUR_UART_BASE
+
+@******************************************************************************
+@
+@  void uart_early_putc(int chr);
+@
+@  call example:
+@    mov	r0, #'A'
+@    bl	uart_early_putc
+@
+.align	2
+.global	uart_early_putc
+.type	uart_early_putc, %function
+uart_early_putc:
+#ifndef CONFIG_GK_DISABLE_CONSOLE
+#if !defined(CONFIG_SUPPORT_CA_RELEASE)
+	ldr	a2, uart_base_addr_L3
+wait3:
+	ldr	a4, [a2, #24]
+	tst	a4, #32
+	bne	wait3
+	str	a1, [a2, #0]
+
+#endif /* CONFIG_SUPPORT_CA_RELEASE */
+#endif /* CONFIG_GK_DISABLE_CONSOLE */
+	bx	lr
+uart_base_addr_L3:
+	.word CONFIG_CUR_UART_BASE
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7205v300/u-boot.lds gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v300/u-boot.lds
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7205v300/u-boot.lds	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7205v300/u-boot.lds	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,52 @@
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x40700000;
+	__image_copy_start =.;
+	. = ALIGN(4);
+	.text	:
+	{
+		__text_start = .;
+		start.o (.text*)
+		init_registers.o (.text*)
+		lowlevel_init_v300.o (.text*)
+		ddr_training_impl.o (.text*)
+		ddr_training_console.o (.text*)
+		ddr_training_ctl.o (.text*)
+		ddr_training_boot.o (.text*)
+		ddr_training_custom.o (.text*)
+		uart.o (.text*)
+		div0.o (.text*)
+		emmc_boot.o (.text*)
+		image_data.o (.text*)
+		hw_decompress.o (.text*)
+		startup.o(.text*)
+		reset.o(.text*)
+		__init_end = .;
+		ASSERT(((__init_end - __text_start) < 0x6000), "init sections too big!");
+		*(.text*)
+	}
+	__text_end = .;
+
+	. = ALIGN(4);
+	.image : { *(.image) }
+
+	. = ALIGN(4);
+	.rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = ALIGN(4);
+	__image_copy_end =.;
+	__bss_start = .;
+	.bss : { *(.bss) }
+	__bss_end = .;
+	_end = .;
+}
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7605v100/boot_mode.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7605v100/boot_mode.c
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7605v100/boot_mode.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7605v100/boot_mode.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/platform.h>
+
+int get_boot_media(void)
+{
+	unsigned int reg_val, boot_mode, spi_device_mode;
+	int boot_media;
+
+	reg_val = readl(SYS_CTRL_REG_BASE + REG_SYSSTAT);
+	boot_mode = get_sys_boot_mode(reg_val);
+
+	switch (boot_mode) {
+	case BOOT_FROM_SPI:
+		spi_device_mode = get_spi_device_type(reg_val);
+		if (spi_device_mode)
+			boot_media = BOOT_MEDIA_NAND;
+		else
+			boot_media = BOOT_MEDIA_SPIFLASH;
+		break;
+	case BOOT_FROM_EMMC:
+		boot_media = BOOT_MEDIA_EMMC;
+		break;
+	default:
+		boot_media = BOOT_MEDIA_UNKNOWN;
+		break;
+	}
+
+	return boot_media;
+}
+
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7605v100/emmc_boot.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7605v100/emmc_boot.c
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7605v100/emmc_boot.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7605v100/emmc_boot.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,181 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <config.h>
+
+#ifdef CONFIG_GENERIC_MMC
+#include <asm/arch/platform.h>
+#include <compiler.h>
+
+#ifndef CONFIG_ASIC
+#define DELAY_US        10
+#else
+#define DELAY_US        1000
+#endif
+
+#define MMC_BLK_SZ      512
+
+/* mmc.h */
+#define MMC_CMD_GO_IDLE_STATE       0
+#define MMC_CMD_SEND_OP_COND        1
+#define MMC_CMD_ALL_SEND_CID        2
+#define MMC_CMD_SET_RELATIVE_ADDR   3
+#define MMC_CMD_SET_DSR         4
+#define MMC_CMD_SWITCH          6
+#define MMC_CMD_SELECT_CARD     7
+#define MMC_CMD_SEND_EXT_CSD        8
+#define MMC_CMD_SEND_CSD        9
+#define MMC_CMD_SEND_CID        10
+#define MMC_CMD_STOP_TRANSMISSION   12
+#define MMC_CMD_SEND_STATUS     13
+#define MMC_CMD_SET_BLOCKLEN        16
+#define MMC_CMD_READ_SINGLE_BLOCK   17
+#define MMC_CMD_READ_MULTIPLE_BLOCK 18
+#define MMC_CMD_WRITE_SINGLE_BLOCK  24
+#define MMC_CMD_WRITE_MULTIPLE_BLOCK    25
+#define MMC_CMD_APP_CMD         55
+#define SD_CMD_SEND_IF_COND     8
+#define SD_CMD_APP_SEND_OP_COND     41
+#define SD_CMD_APP_SET_BUS_WIDTH    6
+
+#define OCR_BUSY        0x80000000
+#define OCR_HCS         0x40000000
+
+#define MMC_VDD_32_33       0x00100000  /* VDD voltage 3.2 ~ 3.3 */
+#define MMC_VDD_33_34       0x00200000  /* VDD voltage 3.3 ~ 3.4 */
+
+#define MMC_SWITCH_MODE_WRITE_BYTE  0x03 /* Set target byte to value */
+
+#define EXT_CSD_BUS_WIDTH   183 /* R/W */
+#define EXT_CSD_HS_TIMING   185 /* R/W */
+
+#define EXT_CSD_BUS_WIDTH_1 0   /* Card is in 1 bit mode */
+#define EXT_CSD_BUS_WIDTH_4 1   /* Card is in 4 bit mode */
+#define EXT_CSD_BUS_WIDTH_8 2   /* Card is in 8 bit mode */
+
+static inline void delay(unsigned int cnt)
+{
+	while (cnt--)
+		__asm__ __volatile__("nop");
+}
+
+#ifdef CONFIG_SDHCI
+#define SDHCI_BUFFER            0x20
+#define SDHCI_INT_STATUS        0x30
+#define SDHCI_INT_DATA_AVAIL    0x00000020
+#define SDHCI_INT_ERROR_MASK    0xFFFF8000
+
+#define debug_printf(fmt, args...) ;
+
+static inline unsigned int sdhci_readl(unsigned addr)
+{
+	uintptr_t reg_addr  = EMMC_BASE_REG + addr;
+
+	return *((volatile unsigned *) (reg_addr));
+}
+
+static inline void sdhci_writel(unsigned val, unsigned addr)
+{
+	uintptr_t reg_addr  = EMMC_BASE_REG + addr;
+
+	(*(volatile unsigned *) (reg_addr)) = (val);
+}
+
+static void sdhci_read_block_pio(void *data_addr, unsigned int block)
+{
+	const unsigned int offset = sizeof(unsigned int);
+	unsigned int size;
+	unsigned char *buf;
+
+	size = MMC_BLK_SZ;
+	buf = (unsigned char *)data_addr + MMC_BLK_SZ * block;
+	while (size) {
+		*(unsigned int *)buf = sdhci_readl(SDHCI_BUFFER);
+		buf += offset;
+		size -= offset;
+	}
+}
+
+int sdhci_check_int_status(unsigned int mask, unsigned int timeout)
+{
+	unsigned int reg;
+
+	for (;;) {
+		reg = sdhci_readl(SDHCI_INT_STATUS);
+		if (reg & mask)
+			break;
+		if (!(--timeout)) {
+			debug_printf("wait int status time out, reg = 0x%x, mask = 0x%x\n",
+						 reg, mask);
+			return -1;
+		}
+		if (reg & SDHCI_INT_ERROR_MASK) {
+			debug_printf("int err: reg = 0x%x\n", reg);
+			return -1;
+		}
+
+		delay(1000 * DELAY_US); /* ms converted to us multiplied by 1000 */
+	}
+
+	return 0;
+}
+
+static void copy_step1_to_ddr(unsigned int *dst, unsigned int *src, unsigned int size)
+{
+	const unsigned int cycle = size / sizeof(unsigned int);
+	unsigned int i;
+
+	for (i = 0; i < cycle; i++)
+		*dst++ = *src++;
+}
+
+#define CP_STEP1_SIZE 0x6000
+int sdhci_read_boot_data(void *data_addr, unsigned int data_size)
+{
+	const unsigned int timeout = 2000; /* 2s timeout: 2000000 * 1us */
+	unsigned int blocks = 0;
+	unsigned int read_block;
+	int ret;
+
+	if (data_size <= CP_STEP1_SIZE) {
+		copy_step1_to_ddr((void *)data_addr, (void *)RAM_START_ADRS, data_size);
+		return 0;
+	} else {
+		copy_step1_to_ddr((void *)data_addr, (void *)RAM_START_ADRS, CP_STEP1_SIZE);
+		data_addr += CP_STEP1_SIZE;
+		data_size -= CP_STEP1_SIZE;
+	}
+
+	if (data_size % MMC_BLK_SZ) {
+		debug_printf("sdhci_read_boot_data error\n");
+		debug_printf("data_size:%d not round by block size\n", data_size);
+		read_block = data_size / MMC_BLK_SZ + 1;
+	} else {
+		read_block = data_size / MMC_BLK_SZ;
+	}
+
+	while (1) {
+		ret = sdhci_check_int_status(SDHCI_INT_DATA_AVAIL, timeout);
+		if (ret) {
+			debug_printf("wait data available int time out\n");
+			return ret;
+		}
+
+		sdhci_writel(SDHCI_INT_DATA_AVAIL, SDHCI_INT_STATUS);
+		sdhci_read_block_pio(data_addr, blocks);
+
+		blocks++;
+		if (blocks == read_block)
+			break;
+	}
+
+	return 0;
+}
+
+void emmc_boot_read(void *ptr, unsigned int size)
+{
+	sdhci_read_boot_data(ptr, size);
+}
+#endif
+#endif
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7605v100/hw_decompress.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7605v100/hw_decompress.c
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7605v100/hw_decompress.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7605v100/hw_decompress.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,405 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#include <config.h>
+#include <linux/kconfig.h>
+#include <asm/io.h>
+#include <compiler.h>
+#include <cpu_common.h>
+
+#define error(_s)               uart_early_puts(_s)
+#define putstr(_s)              uart_early_puts(_s)
+
+#define PAGE_SIZE       4096
+#define page_nr(x) (((x) + PAGE_SIZE - 1) / PAGE_SIZE)
+
+/* The base address for emar */
+#define HW_DEC_REG_BASE_ADDR    (GZIP_REG_BASE)
+
+/* The global init registers for emar interface */
+#define EAMR_RID_REG_OFST   0x0108UL
+#define EAMR_ROSD_REG_OFST  0x010CUL
+#define EAMR_WID_REG_OFST   0x0110UL
+#define EAMR_WOSD_REG_OFST  0x0114UL
+
+/* The enable register */
+#define EAMR_WORK_EN_REG_OFST 0x0100UL
+
+#define DPRS_DATA_SRC_BADDR 0x2040UL
+#define DPRS_DATA_SRC_LEN   0x2044UL
+
+/* Decompress parameter reigsters for page address */
+#define DPRS_DATA_RTN_BADDR 0x2020UL
+#define DPRS_DATA_RTN_LEN   0x2024UL
+
+/* Decompress parameter registers for page data */
+#define DPRS_DATA_INFO_BADDR 0x2028UL
+#define DPRS_DATA_INFO_LEN  0x202CUL
+
+#define DPRS_DATA_CRC32     0x2030UL
+
+#define CRC_CHECK_EN        0x4000UL
+
+/* The status registers */
+#define BUF_INFO            0x2080UL
+#define DPRS_RTN_INFO       0x2084UL
+#define DPRS_RTN_LEN        0x2088UL
+#define BUF_INFO_CLR        0x2090UL
+#define RLT_INFO_CLR        0x2094UL
+
+/* The intr registers */
+#define INT_EN_REG_ADDR     0x0128UL
+#define INT_STATUS_REG_ADDR 0x0124UL
+#define INT_CLEAR_REG_ADDR  0x0130UL
+
+#define TASK_MODE_REG       0x2134UL
+
+/* Define the union u_dprs_data_buf_info */
+typedef union {
+	/* Define the struct bits */
+	struct {
+		unsigned int    buf_len: 24; /* [23..0] */
+		unsigned int    buf_id: 2; /* [25..24] */
+		unsigned int    reserved_1: 2; /* [27..26] */
+		unsigned int    eop: 1; /* [28] */
+		unsigned int    sop: 1; /* [29] */
+		unsigned int    reserved_0: 1; /* [30] */
+		unsigned int    mode: 1; /* [31] */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    u32;
+} u_dprs_data_buf_info;
+
+typedef union {
+	struct {
+		unsigned int buf_id: 2; /* [1:0] */
+		unsigned int rsv: 29;   /* [30:2] */
+		unsigned int aval_flg: 1;   /* [31] */
+	} bits;
+	unsigned int u32;
+} u_buf_status;
+
+typedef union {
+	struct {
+		unsigned int err_info: 8;   /* [7:0] */
+		unsigned int rsv: 23;   /* [30:8] */
+		unsigned int aval_flg: 1;   /* [31] */
+	} bits;
+
+	unsigned int u32;
+} u_dprs_rtn_status;
+
+/* Define the union U_INT_EN */
+typedef union {
+	/* Define the struct bits */
+	struct {
+		unsigned int    task_intrpt_en: 1; /* [0] */
+		unsigned int    block_intrpt_en: 1; /* [1] */
+		unsigned int    reserved_0: 30; /* [31..2] */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    u32;
+} u_intr_en;
+
+typedef union {
+	/* Define the struct bits */
+	struct {
+		unsigned int    task_intrpt: 1; /* [0] */
+		unsigned int    block_intrpt: 1; /* [1] */
+		unsigned int    reserved_0: 30; /* [31..2] */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    u32;
+} u_intr_status;
+
+typedef union {
+	/* Define the struct bits */
+	struct {
+		unsigned int    task_intrpt_clr: 1; /* [0] */
+		unsigned int    block_intrpt_clr: 1; /* [1] */
+		unsigned int    reserved_0: 30; /* [31..2] */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    u32;
+} u_intr_clr;
+
+
+#define PERI_CRG100 0x190
+
+#define GZIP_OFFSET PERI_CRG100
+#define GZIP_CLKEN (0x1<<0)
+
+#ifndef GZIP_REG_BASE
+#define GZIP_REG_BASE   0x11310000
+#endif
+
+#define HW_DEC_REG_BASE_ADDR  (GZIP_REG_BASE)
+
+static void disable_decompress_clock(void)
+{
+	unsigned int regval;
+
+	regval = readl(CRG_REG_BASE + GZIP_OFFSET);
+	regval &= ~GZIP_CLKEN;
+	writel(regval, CRG_REG_BASE + GZIP_OFFSET);
+}
+
+static void enable_decompress_clock(void)
+{
+	unsigned int regval;
+
+	regval = readl(CRG_REG_BASE + GZIP_OFFSET);
+	regval |= GZIP_CLKEN;
+	writel(regval, CRG_REG_BASE + GZIP_OFFSET);
+}
+
+
+unsigned int hw_dec_type;
+unsigned int hw_dec_sop;
+unsigned int hw_dec_eop;
+unsigned int hw_dec_cur_blk;
+unsigned int hw_blk_total_num;
+
+void hw_dec_sop_eop_first_set(int block_num)
+{
+	if (block_num == 1) {
+		hw_dec_sop = 1;
+		hw_dec_eop = 1;
+	} else {
+		hw_dec_sop = 1;
+		hw_dec_eop = 0;
+	}
+
+	hw_dec_cur_blk = 0;
+	hw_blk_total_num = block_num;
+}
+
+static inline void hw_dec_work_en_set(int work_en_flg)
+{
+	/* Enable the emar */
+	writel(work_en_flg, HW_DEC_REG_BASE_ADDR + EAMR_WORK_EN_REG_OFST);
+}
+
+static inline void hw_dec_rtn_baddr_set(unsigned int addr)
+{
+	writel(addr, HW_DEC_REG_BASE_ADDR + DPRS_DATA_RTN_BADDR);
+}
+
+static inline void hw_dec_dprs_data_baddr_set(unsigned int addr)
+{
+	writel(addr, HW_DEC_REG_BASE_ADDR + DPRS_DATA_INFO_BADDR);
+}
+
+static inline void hw_dec_data_rtn_len_set(unsigned int len)
+{
+	writel(len, HW_DEC_REG_BASE_ADDR + DPRS_DATA_RTN_LEN);
+}
+
+static inline void hw_dec_dprs_data_len_set(unsigned int len)
+{
+	writel(len, HW_DEC_REG_BASE_ADDR + DPRS_DATA_INFO_LEN);
+}
+
+static inline void hw_dec_crc_check_en(unsigned int crc_en)
+{
+	writel(crc_en, HW_DEC_REG_BASE_ADDR + CRC_CHECK_EN);
+}
+
+static inline void hw_dec_data_crc32_set(unsigned int crc32)
+{
+	writel(crc32, HW_DEC_REG_BASE_ADDR + DPRS_DATA_CRC32);
+}
+
+static inline unsigned int hw_dec_buf_status_get(void)
+{
+	return readl(HW_DEC_REG_BASE_ADDR + BUF_INFO);
+}
+
+static inline unsigned int hw_dec_dprs_rtn_status_get(void)
+{
+	return readl(HW_DEC_REG_BASE_ADDR + DPRS_RTN_INFO);
+}
+
+static inline void hw_dec_buf_status_clr(void)
+{
+	writel(0x1, HW_DEC_REG_BASE_ADDR + BUF_INFO_CLR);
+}
+
+static inline void hw_dec_dprs_rtn_status_clr(void)
+{
+	writel(0x1, HW_DEC_REG_BASE_ADDR + RLT_INFO_CLR);
+}
+
+static void hw_dec_intr_en_set(int blk_intr_en, int task_intr_en)
+{
+	u_intr_en intr_en;
+	intr_en.bits.task_intrpt_en = task_intr_en;
+	intr_en.bits.block_intrpt_en = blk_intr_en;
+	writel(intr_en.u32, HW_DEC_REG_BASE_ADDR + INT_EN_REG_ADDR);
+}
+
+static inline unsigned int hw_dec_intr_status_get(void)
+{
+	return readl(HW_DEC_REG_BASE_ADDR + INT_STATUS_REG_ADDR);
+}
+
+static void hw_dec_block_intr_status_clr(void)
+{
+	u_intr_clr intr_clr;
+
+	intr_clr.u32 = readl(HW_DEC_REG_BASE_ADDR + INT_CLEAR_REG_ADDR);
+	intr_clr.bits.block_intrpt_clr = 0x1;
+	writel(intr_clr.u32, HW_DEC_REG_BASE_ADDR + INT_CLEAR_REG_ADDR);
+}
+
+static void hw_dec_task_intr_status_clr(void)
+{
+	u_intr_clr intr_clr;
+
+	intr_clr.u32 = readl(HW_DEC_REG_BASE_ADDR + INT_CLEAR_REG_ADDR);
+	intr_clr.bits.task_intrpt_clr = 0x1;
+	writel(intr_clr.u32, HW_DEC_REG_BASE_ADDR + INT_CLEAR_REG_ADDR);
+}
+
+int hw_dec_intr_proc(int irq, void *para)
+{
+	u_buf_status buf_status;
+	u_intr_status intr_status;
+	u_dprs_rtn_status dprs_status;
+	int ret = 0;
+
+	intr_status.u32 = hw_dec_intr_status_get();
+	if (intr_status.bits.block_intrpt) {
+		buf_status.u32 = hw_dec_buf_status_get();
+		if (buf_status.bits.aval_flg)
+			hw_dec_buf_status_clr();
+
+		hw_dec_block_intr_status_clr();
+	}
+
+	if (intr_status.bits.task_intrpt) {
+		dprs_status.u32 = hw_dec_dprs_rtn_status_get();
+		if (dprs_status.bits.aval_flg) {
+			if (dprs_status.bits.err_info)
+				ret = -2; /* -2:failed */
+
+			hw_dec_dprs_rtn_status_clr();
+		}
+
+		hw_dec_task_intr_status_clr();
+		goto out;
+	}
+
+	ret = -1;
+out:
+	return ret;
+}
+
+void hw_dec_start(unsigned int src_baddr,
+			unsigned int dst_baddr,
+			unsigned int src_len,
+			unsigned int dst_len,
+			unsigned int crc_en,
+			unsigned int crc32,
+			unsigned int dec_type)
+{
+	unsigned int val;
+
+	if (hw_dec_sop) {
+		if (!dec_type) {
+			/* set the parameters of output buffer */
+			hw_dec_rtn_baddr_set(dst_baddr);
+			hw_dec_data_rtn_len_set(dst_len);
+		} else {
+			/* set the parameter of output buffer */
+			hw_dec_dprs_data_baddr_set(dst_baddr);
+			hw_dec_dprs_data_len_set(page_nr(dst_len) * 4); /* 4:Align */
+		}
+	}
+
+	/* set the parameter of input buffer */
+	writel(src_baddr, HW_DEC_REG_BASE_ADDR + DPRS_DATA_SRC_BADDR);
+
+	val = src_len |
+		(hw_dec_sop << 28) | (hw_dec_eop << 29) | (!dec_type << 31); /* 28,29,31 Move Left bit */
+	writel(val, HW_DEC_REG_BASE_ADDR + DPRS_DATA_SRC_LEN);
+
+	hw_dec_crc_check_en(crc_en);
+}
+
+static inline void delay(unsigned int num)
+{
+	volatile unsigned int i;
+
+	for (i = 0; i < (100 * num); i++) /* 100: Cycle */
+		__asm__ __volatile__("nop");
+}
+
+int hw_dec_wait_finish(void)
+{
+	int ret;
+	int times = 0;
+
+	do {
+		ret = hw_dec_intr_proc(HW_DEC_INTR, NULL);
+		times++;
+		if (times > 2000000) { /* 2000000 ms */
+			error("hardware decompress overtime!\n");
+			break;
+		}
+		delay(1);
+	} while (-1 == ret);
+
+	return ret;
+}
+
+int hw_dec_decompress(unsigned char *dst, int *dstlen,
+			unsigned char *src, int srclen,
+			void *unused)
+{
+	int ret;
+
+	hw_dec_sop_eop_first_set(1);
+	hw_dec_start((unsigned int)(uintptr_t)src, (unsigned int)(uintptr_t)dst,
+				 srclen, *dstlen, 1, 0, hw_dec_type);
+
+	ret = hw_dec_wait_finish();
+
+	*dstlen = readl(HW_DEC_REG_BASE_ADDR + DPRS_RTN_LEN);
+
+	if (ret)
+		return -1;
+
+	return 0;
+}
+
+void hw_dec_init(void)
+{
+	/* enable decompress clock */
+	enable_decompress_clock();
+	/* Init the emar interface */
+	writel(0, HW_DEC_REG_BASE_ADDR + EAMR_RID_REG_OFST);
+	writel(0x3, HW_DEC_REG_BASE_ADDR + EAMR_ROSD_REG_OFST);
+	writel(0, HW_DEC_REG_BASE_ADDR + EAMR_WID_REG_OFST);
+	writel(0x3, HW_DEC_REG_BASE_ADDR + EAMR_WOSD_REG_OFST);
+
+	/* Enable interrupt */
+	hw_dec_intr_en_set(0x1, 0x1);
+
+	/* Enable emar */
+	hw_dec_work_en_set(0x1);
+}
+
+void hw_dec_uinit(void)
+{
+	hw_dec_work_en_set(0x0);
+	hw_dec_intr_en_set(0x0, 0x0);
+
+	/* disable decompress clock */
+	disable_decompress_clock();
+}
+
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7605v100/image_data.S gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7605v100/image_data.S
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7605v100/image_data.S	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7605v100/image_data.S	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,9 @@
+.section .image,#alloc
+.globl	input_data
+/*gzip source addr must be 16 bytes aligned*/
+.balign 16
+input_data:
+.incbin   "image_data.gzip"
+
+.globl    input_data_end
+input_data_end:
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7605v100/init_registers.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7605v100/init_registers.c
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7605v100/init_registers.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7605v100/init_registers.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,173 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <asm/arch/platform.h>
+#include <compiler.h>
+
+#define W_WHETHER_WRITE     (1<<0)
+#define W_WHETHER_PM        (1<<1)
+#define W_WHETHER_BOOT_NORMAL   (1<<2)
+#define W_BIT_OFFSET        3
+#define W_BIT_MASK          (0x1f<<W_BIT_OFFSET)
+#define W_REG_BIT_OFFSET    11
+#define W_REG_BIT_MASK      (0x1f<<W_REG_BIT_OFFSET)
+
+#define R_WHETHER_READ      (W_WHETHER_WRITE<<16)
+#define R_WHETHER_PM        (W_WHETHER_PM<<16)
+#define R_WHETHER_BOOT_NORMAL   (W_WHETHER_BOOT_NORMAL<<16)
+#define R_BIT_OFFSET        (W_BIT_OFFSET + 16)
+#define R_BIT_MASK          (W_BIT_MASK<<16)
+#define R_REG_BIT_OFFSET    (W_REG_BIT_OFFSET + 16)
+#define R_REG_BIT_MASK      (W_REG_BIT_MASK<<16)
+
+#define RW_BIT_NUM	32
+
+struct regentry {
+	unsigned int reg_addr;
+	unsigned int value;
+	unsigned int delay;
+	unsigned int attr;
+};
+
+static inline void dwb(void) /* drain write buffer */
+{
+}
+
+static inline unsigned int readl(unsigned addr)
+{
+	unsigned int val;
+	val = (*(volatile unsigned int *)(uintptr_t)(addr));
+	return val;
+}
+
+static inline void writel(unsigned val, unsigned addr)
+{
+	dwb();
+	(*(volatile unsigned *)(uintptr_t)(addr)) = val;
+	dwb();
+}
+
+static inline void delay(void)
+{
+	__asm__ __volatile__("nop");
+}
+
+static void reg_read(struct regentry *reg, unsigned int *ret)
+{
+	unsigned int reg_val_r;
+	unsigned int bit_start_r;
+	unsigned int bit_num_r;
+
+	bit_start_r = ((reg->attr & R_REG_BIT_MASK) >> R_REG_BIT_OFFSET);
+	bit_num_r = ((reg->attr & R_BIT_MASK) >> R_BIT_OFFSET) + 1;
+	reg_val_r = (*(volatile unsigned *)(uintptr_t)(reg->reg_addr));
+
+	if (bit_num_r != RW_BIT_NUM) {
+		reg_val_r >>= bit_start_r;
+		reg_val_r &= ((1 << bit_num_r) - 1);
+	}
+
+	*ret = ((reg_val_r == reg->value) ? 0 : 1);
+}
+
+static void reg_write(struct regentry *reg)
+{
+	unsigned int reg_val_w;
+	unsigned int delay_2;
+	unsigned int bit_start_w;
+	unsigned int bit_num_w;
+
+	delay_2 = reg->delay;
+	bit_start_w = ((reg->attr & W_REG_BIT_MASK) >> W_REG_BIT_OFFSET);
+	bit_num_w = ((reg->attr & W_BIT_MASK) >> W_BIT_OFFSET) + 1;
+	reg_val_w = (*(volatile unsigned *)(uintptr_t)(reg->reg_addr));
+
+	if (bit_num_w == RW_BIT_NUM) {
+		reg_val_w = reg->value;
+	} else {
+		reg_val_w &= (~(((1 << bit_num_w) - 1) << bit_start_w));
+		reg_val_w |= (reg->value) << bit_start_w;
+	}
+	writel(reg_val_w, reg->reg_addr);
+
+	do {
+		delay();
+	} while (delay_2--);
+}
+
+static void read_write(struct regentry *reg, unsigned int pm)
+{
+	unsigned int ret;
+	unsigned int delay_1;
+
+	ret = 0;
+	delay_1 = reg->delay;
+
+	if (pm) {
+		if (reg->attr & W_WHETHER_PM) {
+			reg_write(reg);
+		} else if (reg->attr & R_WHETHER_PM) {
+			do {
+				reg_read(reg, &ret);
+				delay();
+			} while (ret);
+
+			do {
+				delay();
+			} while (delay_1--);
+		} else {
+			do {
+				delay();
+			} while (delay_1--);
+		}
+	} else {
+		if (reg->attr & W_WHETHER_BOOT_NORMAL) {
+			reg_write(reg);
+		} else if (reg->attr & R_WHETHER_BOOT_NORMAL) {
+			do {
+				reg_read(reg, &ret);
+				delay();
+			} while (ret);
+
+			do {
+				delay();
+			} while (delay_1--);
+		} else {
+			do {
+				delay();
+			} while (delay_1--);
+		}
+	}
+}
+
+static void part_read_write(struct regentry *reg_table, unsigned int pm)
+{
+	unsigned int i;
+
+	for (i = 0; ; i++) {
+		if ((!reg_table[i].reg_addr) && (!reg_table[i].value) &&
+			(!reg_table[i].delay) && (!reg_table[i].attr)) {
+			goto main_end;
+		}
+
+		read_write(&reg_table[i], pm);
+	}
+
+main_end:
+	delay();
+}
+
+/*
+ * base - reg base address
+ * pm   - is suspend
+ *      0 normal
+ *      1 pm
+ */
+void init_registers(unsigned long base, unsigned long pm)
+{
+	struct regentry *reg_table = (struct regentry *)base;
+
+	part_read_write(reg_table, pm);
+}
+
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7605v100/lowlevel_init_v300.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7605v100/lowlevel_init_v300.c
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7605v100/lowlevel_init_v300.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7605v100/lowlevel_init_v300.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,485 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#include <compiler.h>
+#include <asm/arch/platform.h>
+#include <config.h>
+#include <ddr_training_impl.h>
+
+static inline void delay(unsigned int num)
+{
+	volatile unsigned int i;
+
+	for (i = 0; i < (100 * num); i++) /* 100: Cycle */
+		__asm__ __volatile__("nop");
+}
+
+static inline void dwb(void) /* drain write buffer */
+{
+}
+
+static inline unsigned int readl(unsigned addr)
+{
+	unsigned int val;
+
+	val = (*(volatile unsigned int *)((uintptr_t)(addr)));
+	return val;
+}
+
+static inline void writel(unsigned val, unsigned addr)
+{
+	dwb();
+	(*(volatile unsigned *)((uintptr_t)(addr))) = (val);
+	dwb();
+}
+
+#define REG_BASE_RNG_GEN            0x10090000
+#define TRNG_DSTA_FIFO_DATA_OFST    0x204
+#define TRNG_DATA_ST_OFST           0x208
+#define BIT_TRNG_FIFO_DATA_CNT      0x8
+#define TRNG_FIFO_DATA_CNT_MASK     0xff
+#define REG_PERI_CRG104             0x1a0
+#define TRNG_CLK_ENABLE             (0x1<<3)
+#define TRNG_CLK_DISABLE            ~(0x1<<3)
+#define TRNG_CTRL_DEF_VAL           0xa
+#define SEC_COM_TRNG_CTRL_OFST    0x200
+
+#define REG_BASE_MISC               0x12030000
+#define DDR_CA0_OFST                0x28
+#define DDR_CA1_OFST                0x2C
+#define DDR_CA2_OFST                0x30
+
+#define REG_BASE_DDRC               0x120d0000
+#define DDRC_CTRL_SREF_OFST         (0x8000 + 0x0)
+#define DDRC_CFG_DDRMODE_OFST       (0x8000 + 0x50)
+#define DDRC_CURR_FUNC_OFST         (0x8000 + 0x294)
+
+#define DDRC_CHANNEL_VALID_MASK     0xf
+#define DDRC_SELF_REFURBISH_MASK    0x1
+
+#define DDRC_SELF_REFURBISH_EN      0x1
+#define DDRC_SELF_REFURBISH_EXIT    (0x1 << 1)
+
+#undef reg_get
+#undef reg_set
+#define reg_get(addr) readl(addr)
+#define reg_set(addr, val) writel(val, (unsigned int)(addr))
+
+#define duty_formula(val)  (((unsigned int)((1099 - (val)) * 460) >> 10) - 1)
+#define volt_formula(val) (1287 - ((1514 * (val)) >> 10))
+#define temperature_formula(val)  (((((val) - 117) * 212) >> 10) - 40)
+#define hpm_formula(hpm, temp)  ((hpm) + 4 + ((((temp) - 70) * 205) >> 10))
+
+void trng_init(void)
+{
+	unsigned int reg_val;
+	/* open rsa and trng clock */
+	reg_val = reg_get(CRG_REG_BASE + REG_PERI_CRG104);
+	reg_val |= TRNG_CLK_ENABLE;
+	reg_set(CRG_REG_BASE + REG_PERI_CRG104, reg_val);
+
+	/* set trng ctrl register */
+	reg_set(REG_BASE_RNG_GEN + SEC_COM_TRNG_CTRL_OFST,
+			TRNG_CTRL_DEF_VAL);
+}
+
+void trng_deinit(void)
+{
+	unsigned int reg_val;
+
+	/* close rsa and trng clock */
+	reg_val = reg_get(CRG_REG_BASE + REG_PERI_CRG104);
+	reg_val &= TRNG_CLK_DISABLE;
+	reg_set(CRG_REG_BASE + REG_PERI_CRG104, reg_val);
+}
+
+/* svb */
+#define SVB_VER             0x10
+
+#define CYCLE_NUM 4
+#define  HPM_CORE_REG0 0x120280d8
+#define  HPM_CORE_REG1 0x120280dc
+
+#define SVB_PWM_REG 0X120280b0
+
+#define SVB_VER_REG         0x12020168
+#define  HPM_CHECK_REG 0x1202015c
+#define SYS_CTRL_VOLT_REG 0x12020158
+
+#define TSENSOR_STATUS0 0x120280bc
+#define OTP_HPM_CORE_REG 0x100a002c
+
+#define HPM_CORE_MIN 150
+#define HPM_CORE_MAX 350
+
+#define TEMPERATURE_MIN  117
+#define TEMPERATURE_MAX  841
+
+#define  HPM_CORE_VALUE_MIN 190
+#define  HPM_CORE_VALUE_MAX 310
+
+#define svb_pwm_reg_val(val) ((((val) << 16) & 0XFFFF0000) + 0x0c75)
+
+static unsigned hpm_value_avg(unsigned int *val, int num)
+{
+	unsigned int i;
+	unsigned tmp = 0;
+
+	for (i = 0; i < num; i++)
+		tmp += val[i] >> NUM_2;
+
+	return tmp >> NUM_2;
+}
+
+static void get_hpm_value(unsigned int *hpm_core)
+{
+	int i;
+	unsigned int temp;
+	unsigned int core_value[NUM_4];
+
+	core_value[NUM_0] = 0;
+	core_value[NUM_1] = 0;
+	core_value[NUM_2] = 0;
+	core_value[NUM_3] = 0;
+
+	for (i = 0; i < CYCLE_NUM; i++) {
+		delay(10); /* delay 10ms */
+
+		temp = readl(HPM_CORE_REG0);
+		core_value[NUM_1] += (temp >> 16) & 0x3ff; /* get hight 16 bits */
+		core_value[NUM_0] += temp & 0x3ff;
+		temp = readl(HPM_CORE_REG1);
+		core_value[NUM_3] += (temp >> 16) & 0x3ff; /* get hight 16 bits */
+		core_value[NUM_2] += temp & 0x3ff;
+	}
+
+	*hpm_core = hpm_value_avg(core_value, NUM_4);
+}
+
+static void start_hpm(unsigned int *hpm_core)
+{
+	get_hpm_value(hpm_core);
+}
+
+static void hpm_check(unsigned int *hpm_core)
+{
+	union {
+		struct {
+			unsigned int reserved_0 : 16; /* [15..0] */
+			unsigned int sys_hpm_core : 9; /* [24..16] */
+			unsigned int reserved_1 : 1; /* [25] */
+			unsigned int hpm_core_err : 1; /* [26] */
+			unsigned int reserved_2 : 5; /* [27..31] */
+		} bits;
+
+		unsigned int u32;
+	} sysboot10;
+	sysboot10.u32 = readl(HPM_CHECK_REG);
+	sysboot10.bits.sys_hpm_core = 0;
+	sysboot10.bits.hpm_core_err = 0;
+
+	if (*hpm_core < HPM_CORE_MIN) {
+		*hpm_core = HPM_CORE_MIN;
+		sysboot10.bits.hpm_core_err = 1;
+	}
+	if (*hpm_core > HPM_CORE_MAX) {
+		*hpm_core = HPM_CORE_MAX;
+		sysboot10.bits.hpm_core_err = 1;
+	}
+
+	sysboot10.bits.sys_hpm_core = *hpm_core;
+
+	writel(sysboot10.u32, HPM_CHECK_REG);
+}
+
+static void get_temperature(unsigned int *temperature)
+{
+	unsigned int value;
+
+	value = readl(TSENSOR_STATUS0);
+	value = value & 0x3ff;
+
+	if (value <= TEMPERATURE_MIN)
+		*temperature = -40; /* -40: temperature value */
+	else if (value >= TEMPERATURE_MAX)
+		*temperature = 110; /* 110: temperature value */
+	else
+		*temperature = temperature_formula(value);
+}
+
+static void adjust_hpm(unsigned int *hpm_core, unsigned int temperature)
+{
+	/* 283 70: hpm_core and temperature Threshold */
+	if ((*hpm_core >= 283) && (temperature >= 70))
+		*hpm_core = hpm_formula(*hpm_core, temperature);
+	/* 222 70: hpm_core and temperature Threshold */
+	else if ((*hpm_core <= 222) && (temperature >= 70))
+		*hpm_core = *hpm_core - NUM_4;
+}
+
+static void set_hpm_core_volt(unsigned int hpm_core_value)
+{
+	unsigned int volt;
+	unsigned int duty;
+	unsigned int otp_vmin_core = readl(OTP_HPM_CORE_REG);
+
+	if (hpm_core_value <= HPM_CORE_VALUE_MIN)
+		volt = 1006; /* 1006: volt value */
+	else if (hpm_core_value >= HPM_CORE_VALUE_MAX)
+		volt = 829; /* 829: volt value */
+	else
+		volt = volt_formula(hpm_core_value);
+
+	volt = volt + (int)((short int)(otp_vmin_core >> 16)); /* get hight 16 bits */
+
+	writel(volt, SYS_CTRL_VOLT_REG);
+	duty = duty_formula(volt);
+
+	writel(svb_pwm_reg_val(duty), SVB_PWM_REG);
+}
+
+void start_svb(void)
+{
+	unsigned int hpm_core = 0;
+	unsigned int temperature = 0;
+
+	unsigned int tmp_reg = readl(SVB_VER_REG);
+	tmp_reg = (tmp_reg & 0xff00ffff) | (SVB_VER << 16); /* Move Left 16bit */
+	writel(tmp_reg, SVB_VER_REG);
+
+	get_temperature(&temperature);
+	start_hpm(&hpm_core);
+	adjust_hpm(&hpm_core, temperature);
+	hpm_check(&hpm_core);
+
+	set_hpm_core_volt(hpm_core);
+	delay(200); /* delay 200ms */
+}
+
+
+/* [CUSTOM] DDR PHY0-PHY1 base register */
+#define DDR_REG_BASE_PHY0       0x120dc000
+
+/* [CUSTOM] DDR DMC0-DMC3 base register */
+#define DDR_REG_BASE_DMC0       0x120d8000
+#define DDR_REG_BASE_DMC1       0x120d8000
+
+#ifdef DDR_REG_BASE_PHY1
+#define DDR_REG_BASE_DMC2       0x120d9000
+#define DDR_REG_BASE_DMC3       0x120d9000
+#endif
+
+#define CRG_REG_BASE            0x12010000
+#define PERI_CRG_DDRT           0x198
+
+#define DDR_REG_BASE_SYSCTRL    0x12020000
+/* [SYSCTRL]RAM Retention control register 0 */
+#define SYSCTRL_MISC_CTRL4      0x8010
+
+#define DDR_PHY_DRAMCFG         0x2c    /* DRAM config register */
+#define PHY_DRAMCFG_TYPE_MASK   0xf /* [3:0] */
+#define PHY_DRAMCFG_TYPE_LPDDR4 0x6   /* [2:0] 110 LPDDR4 */
+
+#define BYTE_NUM  2
+
+/**
+ * ddr_boot_prepare
+ * @void
+ *
+ * Do some prepare before ddr training.
+ * Keep empty when nothing to do.
+ */
+static void ddr_boot_prepare(struct tr_relate_reg *reg)
+{
+	/* select ddrt bus path */
+	reg->custom.ive_ddrt_mst_sel = readl(DDR_REG_BASE_SYSCTRL + SYSCTRL_MISC_CTRL4);
+	writel(reg->custom.ive_ddrt_mst_sel & 0xffffffdf,
+		   DDR_REG_BASE_SYSCTRL + SYSCTRL_MISC_CTRL4);
+
+	/* turn on ddrt clock */
+	reg->custom.ddrt_clk_reg = readl(CRG_REG_BASE + PERI_CRG_DDRT);
+	/* enable ddrt0 clock */
+	writel(reg->custom.ddrt_clk_reg | (0x1 << 1), CRG_REG_BASE + PERI_CRG_DDRT);
+	__asm__ __volatile__("nop");
+	/* disable ddrt0 soft reset */
+	writel(readl(CRG_REG_BASE + PERI_CRG_DDRT) & (~(0x1 << 0)),
+		   CRG_REG_BASE + PERI_CRG_DDRT);
+
+	/* disable rdqs anti-aging */
+	reg->custom.phy0_age_compst_en = readl(DDR_REG_BASE_PHY0 + DDR_PHY_PHYRSCTRL);
+	writel((reg->custom.phy0_age_compst_en & 0x7fffffff),
+		   DDR_REG_BASE_PHY0 + DDR_PHY_PHYRSCTRL);
+#ifdef DDR_REG_BASE_PHY1
+	reg->custom.phy1_age_compst_en = readl(DDR_REG_BASE_PHY1 + DDR_PHY_PHYRSCTRL);
+	writel((reg->custom.phy1_age_compst_en & 0x7fffffff),
+		   DDR_REG_BASE_PHY1 + DDR_PHY_PHYRSCTRL);
+#endif
+}
+
+/**
+ * ddr_boot_restore
+ * @void
+ *
+ * Restore register config after ddr training.
+ * Keep empty when nothing to do.
+ */
+static void ddr_boot_restore(struct tr_relate_reg *reg)
+{
+	/* restore ddrt bus path */
+	writel(reg->custom.ive_ddrt_mst_sel, DDR_REG_BASE_SYSCTRL + SYSCTRL_MISC_CTRL4);
+
+	/* restore ddrt clock */
+	writel(reg->custom.ddrt_clk_reg, CRG_REG_BASE + PERI_CRG_DDRT);
+
+	/* restore rdqs anti-aging */
+	writel(reg->custom.phy0_age_compst_en, DDR_REG_BASE_PHY0 + DDR_PHY_PHYRSCTRL);
+#ifdef DDR_REG_BASE_PHY1
+	writel(reg->custom.phy1_age_compst_en, DDR_REG_BASE_PHY1 + DDR_PHY_PHYRSCTRL);
+#endif
+}
+
+/**
+ * ddr_rdqs_bdl_adj
+ * @void
+ *
+ * Adjust rdqs/rdq/rdm bdl to avoid problem cause by ddr anti-aging.
+ */
+#if 0
+static void ddr_rdqs_bdl_adj(void)
+{
+	int i;
+	unsigned int rdqs;
+	unsigned int rdq03, rdq47;
+	unsigned int rdm;
+	unsigned int tmp;
+
+	for (i = 0; i < BYTE_NUM; i++) {
+		rdqs = readl(DDR_REG_BASE_PHY0 + 0x22c + i * 0x80);
+		rdq03 = readl(DDR_REG_BASE_PHY0 + 0x21c + i * 0x80);
+		rdq47 = readl(DDR_REG_BASE_PHY0 + 0x220 + i * 0x80);
+		rdm = readl(DDR_REG_BASE_PHY0 + 0x224 + i * 0x80);
+
+		/* rdqs bdl lower two bit shoud be 0x11 */
+		while ((rdqs & 0x3) < 0x3) {
+			/* rdqs/rdq/rdm bdl + 1 */
+			rdqs = rdqs + 0x1;
+			rdq03 = rdq03 + 0x01010101;
+			rdq47 = rdq47 + 0x01010101;
+			rdm = rdm + 0x1;
+
+			writel(rdqs, DDR_REG_BASE_PHY0 + 0x22c + i * 0x80);
+			writel(rdq03, DDR_REG_BASE_PHY0 + 0x21c + i * 0x80);
+			writel(rdq47, DDR_REG_BASE_PHY0 + 0x220 + i * 0x80);
+			writel(rdm, DDR_REG_BASE_PHY0 + 0x224 + i * 0x80);
+		}
+	}
+
+	tmp = readl(DDR_REG_BASE_PHY0 + DDR_PHY_MISC);
+	tmp |= (1 << PHY_MISC_UPDATE_BIT);
+	/* update new config to PHY */
+	writel(tmp, DDR_REG_BASE_PHY0 + DDR_PHY_MISC);
+	tmp &= ~(1 << PHY_MISC_UPDATE_BIT);
+	writel(tmp, DDR_REG_BASE_PHY0 + DDR_PHY_MISC);
+	tmp = readl(DDR_REG_BASE_PHY0 + DDR_PHY_PHYINITCTRL);
+	/* set 1 to issue PHY counter reset signal */
+	tmp |= (1 << PHY_PHYCONN_RST_BIT);
+	writel(tmp, DDR_REG_BASE_PHY0 + DDR_PHY_PHYINITCTRL);
+	/* set 0 to end the reset signal */
+	tmp &= ~(1 << PHY_PHYCONN_RST_BIT);
+	writel(tmp, DDR_REG_BASE_PHY0 + DDR_PHY_PHYINITCTRL);
+}
+#endif
+
+#define OTP_CPU_CLK_OFFSET	0x0084
+#define CRG32_CPU_CLK_OFFSET	0x0080
+#define CRG123_CPU_CLK_OFFSET	0x01EC
+
+static void switch_cpu_freq(void)
+{
+	unsigned int mux_chn;
+	unsigned int reg_val;
+
+	if (readl(SYS_CTRL_REG_BASE + REG_SC_GEN5) != 0x1)
+		return;
+
+	mux_chn = readl(SYS_CTRL_REG_BASE + OTP_CPU_CLK_OFFSET);
+	mux_chn = (mux_chn >> 1) & 0x3;
+
+	reg_val = readl(CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+	reg_val |= 0x3;
+	writel(reg_val, CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+
+	if ((mux_chn == 0) || (mux_chn == 3)) {
+		reg_val = readl(CRG_REG_BASE + CRG123_CPU_CLK_OFFSET);
+		reg_val &= ~0x1;
+		writel(reg_val, CRG_REG_BASE + CRG123_CPU_CLK_OFFSET);
+		delay(1);
+
+		reg_val = readl(CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+		reg_val &= ~0x3;
+		reg_val |= 0x1;
+		writel(reg_val, CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+	} else if (mux_chn == 1) {
+		reg_val = readl(CRG_REG_BASE + CRG123_CPU_CLK_OFFSET);
+		reg_val |= 0x1;
+		writel(reg_val, CRG_REG_BASE + CRG123_CPU_CLK_OFFSET);
+		delay(1);
+
+		reg_val = readl(CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+		reg_val &= ~0x3;
+		writel(reg_val, CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+	} else if (mux_chn == 2) {
+		reg_val = readl(CRG_REG_BASE + CRG123_CPU_CLK_OFFSET);
+		reg_val |= 0x1;
+		writel(reg_val, CRG_REG_BASE + CRG123_CPU_CLK_OFFSET);
+		delay(1);
+
+		reg_val = readl(CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+		reg_val &= ~0x3;
+		reg_val |= 0x2;
+		writel(reg_val, CRG_REG_BASE + CRG32_CPU_CLK_OFFSET);
+	}
+
+}
+
+void start_ddr_training(unsigned int base)
+{
+	struct tr_relate_reg relate_reg;
+	struct tr_relate_reg *reg = &relate_reg;
+
+//	start_svb();
+	switch_cpu_freq();
+
+	ddr_boot_prepare(reg);
+
+	/* ddr pcode training */
+//	ddr_pcode_training_if();
+	/* ddr hw training */
+	ddr_hw_training_if();
+	/* ddr sw training */
+	ddr_sw_training_if();
+
+//	ddr_rdqs_bdl_adj();
+
+	ddr_boot_restore(reg);
+
+	/* the value should config after trainning, or
+	  it will cause chip compatibility problems */
+	if ((readl(DDR_REG_BASE_PHY0 + DDR_PHY_DRAMCFG) &
+		PHY_DRAMCFG_TYPE_MASK) == PHY_DRAMCFG_TYPE_LPDDR4) {
+		writel(0x401, DDR_REG_BASE_DMC0 + 0x28);
+		writel(0x401, DDR_REG_BASE_DMC1 + 0x28);
+	} else {
+		writel(0x401, DDR_REG_BASE_DMC0 + 0x28);
+	}
+#ifdef DDR_REG_BASE_PHY1
+	if ((readl(DDR_REG_BASE_PHY1 + DDR_PHY_DRAMCFG) &
+		PHY_DRAMCFG_TYPE_MASK) == PHY_DRAMCFG_TYPE_LPDDR4) {
+		writel(0x401, DDR_REG_BASE_DMC2 + 0x28);
+		writel(0x401, DDR_REG_BASE_DMC3 + 0x28);
+	} else {
+		writel(0x401, DDR_REG_BASE_DMC1 + 0x28);
+	}
+#endif
+	/* enable ddr scramb */
+}
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7605v100/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7605v100/Makefile
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7605v100/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7605v100/Makefile	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,100 @@
+PWD           = $(shell pwd)
+SRCDIR        =
+OUTDIR        =
+
+################################################################################
+CC       := $(CROSS_COMPILE)gcc
+AR       := $(CROSS_COMPILE)ar
+LD       := $(CROSS_COMPILE)ld
+OBJCOPY  := $(CROSS_COMPILE)objcopy
+
+
+################################################################################
+BOOT     := u-boot-$(SOC)
+TEXTBASE := 0x40700000
+
+CFLAGS   :=-Os -fno-builtin -ffreestanding \
+	-D__KERNEL__ -DTEXT_BASE=$(TEXTBASE) \
+	-I$(SRCDIR)/include \
+	-I$(OUTDIR)/include \
+	-I$(SRCDIR)/drivers/ddr/goke/default \
+	-I$(SRCDIR)/drivers/ddr/goke/$(SOC) \
+	-I$(SRCDIR)/arch/arm/include \
+	-I$(SRCDIR)/lib/hw_dec \
+	-fno-pic -ffunction-sections \
+	-fdata-sections -fno-common -ffixed-r9    \
+	-fno-common -pipe -march=armv7-a \
+	-Wall -Wstrict-prototypes -fno-stack-protector \
+	-D__LINUX_ARM_ARCH__=7 -D__ARM__ \
+	-DCONFIG_MMC\
+	$(MKFLAGS) -fno-strict-aliasing
+
+################################################################################
+COBJS := start.o \
+	lowlevel_init_v300.o \
+	init_registers.o \
+	emmc_boot.o \
+	uart.o \
+	ddr_training_impl.o \
+	ddr_training_ctl.o \
+	ddr_training_boot.o \
+	ddr_training_custom.o \
+	ddr_training_console.o \
+	hw_decompress.o \
+	startup.o \
+	image_data.o \
+	div0.o \
+	reset.o
+
+REG := $(wildcard $(OUTDIR)/*.reg $(OUTDIR)/.reg)
+
+################################################################################
+.PHONY: $(BOOT).bin
+$(BOOT).bin: $(BOOT).tmp regfile
+	@dd if=./$(BOOT).tmp of=./tmp1 bs=1 count=64 2>/dev/null
+	@dd if=$(REG) of=./tmp2 bs=5120 conv=sync 2>/dev/null
+	@dd if=./$(BOOT).tmp of=./tmp3 bs=1 skip=5184 2>/dev/null
+	@cat tmp1 tmp2 tmp3 > $(BOOT).bin
+	@rm -f tmp1 tmp2 tmp3
+	@chmod 754 $(BOOT).bin
+	@cp -fv $@ $(OUTDIR)
+	@echo $(BOOT).bin is Ready.
+
+$(BOOT).tmp: $(BOOT).elf
+	$(OBJCOPY) -O srec $< $(BOOT).srec
+	$(OBJCOPY) -j .text -O binary $< $(BOOT).text
+	$(OBJCOPY) --gap-fill=0xff -O binary $< $@
+
+$(BOOT).elf: image_data.gzip $(COBJS)
+	$(LD) -Bstatic -T u-boot.lds -Ttext $(TEXTBASE) \
+		$(COBJS) -Map $(BOOT).map -o $@
+	$(OBJDUMP) -d  $@ > $@.asm
+
+.PHONY: regfile
+regfile:
+	@if [ "$(words $(REG))" = "0" ]; then ( \
+		echo '***' Need '.reg' or '*.reg' file in directory $(OUTDIR); \
+		exit 1; \
+	) fi
+	@if [ "$(words $(REG))" != "1" ]; then ( \
+		echo '***' Found multi '.reg' or '*.reg' file in directory $(OUTDIR); \
+		echo '***' Files: $(notdir $(REG)); \
+		exit 1; \
+	) fi
+
+################################################################################
+
+# -1 : --fast      -9 : --best
+image_data.gzip: $(BINIMAGE)
+	$(OUTDIR)/../../../tools/utils/bin/gzip -fNqc -7 $< > $@
+
+%.o: %.c
+	$(CC) $(CFLAGS) -Wall -Wstrict-prototypes \
+		-fno-stack-protector -o $@ $< -c
+
+%.o: %.S
+	$(CC) -D__ASSEMBLY__ $(CFLAGS) -o $@ $< -c
+
+image_data.o: image_data.S image_data.gzip
+	$(CC) -D__ASSEMBLY__ $(CFLAGS) -o $@ $< -c
+
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7605v100/reset.S gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7605v100/reset.S
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7605v100/reset.S	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7605v100/reset.S	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,18 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <config.h>
+
+.global reset_cpu
+reset_cpu:
+	ldr	r1, rstctl			@ get addr for global reset
+						@ reg
+	mov	r3, #0x2			@ full reset pll + mpu
+	str	r3, [r1]			@ force reset
+	mov	r0, r0
+
+_loop_forever:
+	b	_loop_forever
+rstctl:
+	.word  SYS_CTRL_REG_BASE + REG_SC_SYSRES
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7605v100/start.S gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7605v100/start.S
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7605v100/start.S	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7605v100/start.S	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,504 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <asm-offsets.h>
+#include <config.h>
+#include <asm/system.h>
+#include <linux/linkage.h>
+#include <asm/armv7.h>
+
+/*************************************************************************
+ *
+ * Startup Code (reset vector)
+ *
+ * Do important init only if we don't start from memory!
+ * Setup memory and board specific bits prior to relocation.
+ * Relocate armboot to ram. Setup stack.
+ *
+ *************************************************************************/
+.globl	_start
+_start:
+	b	reset
+    b .
+    b .
+    b .
+    b .
+    b .
+    b .
+    b .
+	.balignl 64,0xdeadbeef
+	
+	.globl	reset
+	.globl	save_boot_params_ret
+#ifdef CONFIG_ARMV7_LPAE
+	.global	switch_to_hypervisor_ret
+#endif
+
+ __blank_zone_start:
+	.fill 1024*5,1,0
+__blank_zone_end:
+
+	.globl _blank_zone_start
+_blank_zone_start:
+	.word __blank_zone_start
+
+
+	.globl _blank_zone_end
+_blank_zone_end:
+	.word __blank_zone_end
+
+	.balignl 16,0xdeadbeef
+	.globl	_TEXT_BASE
+_TEXT_BASE:
+	.word TEXT_BASE
+ 
+
+_clr_remap_fmc_entry:
+	.word   FMC_MEM_BASE + do_clr_remap - CONFIG_SYS_TEXT_BASE_ORI
+
+_start_armboot:
+	.word start_armboot
+
+reset:
+	/* Allow the board to save important registers */
+	b	save_boot_params
+save_boot_params_ret:
+#ifdef CONFIG_ARMV7_LPAE
+/*
+ * check for Hypervisor support
+ */
+	mrc	p15, 0, r0, c0, c1, 1		@ read ID_PFR1
+	and	r0, r0, #CPUID_ARM_VIRT_MASK	@ mask virtualization bits
+	cmp	r0, #(1 << CPUID_ARM_VIRT_SHIFT)
+	beq	switch_to_hypervisor
+switch_to_hypervisor_ret:
+#endif
+	/*
+	 * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,
+	 * except if in HYP mode already
+	 */
+	mrs	r0, cpsr
+	and	r1, r0, #0x1f		@ mask mode bits
+	teq	r1, #0x1a		@ test for HYP mode
+	bicne	r0, r0, #0x1f		@ clear all mode bits
+	orrne	r0, r0, #0x13		@ set SVC mode
+	orr	r0, r0, #0xc0		@ disable FIQ and IRQ
+	msr	cpsr,r0
+
+/*
+ * Setup vector:
+ * (OMAP4 spl TEXT_BASE is not 32 byte aligned.
+ * Continue to use ROM code vector only in OMAP4 spl)
+ */
+#if !(defined(CONFIG_OMAP44XX) && defined(CONFIG_SPL_BUILD))
+	/* Set V=0 in CP15 SCTLR register - for VBAR to point to vector */
+	mrc	p15, 0, r0, c1, c0, 0	@ Read CP15 SCTLR Register
+	bic	r0, #CR_V		@ V = 0
+	mcr	p15, 0, r0, c1, c0, 0	@ Write CP15 SCTLR Register
+
+	/* Set vector address in CP15 VBAR register */
+	adrl	r0, _start
+	mcr	p15, 0, r0, c12, c0, 0	@Set VBAR
+#endif
+
+	/* the mask ROM code should have PLL and others stable */
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
+	bl	cpu_init_cp15
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT_ONLY
+	bl	cpu_init_crit
+#endif
+#endif
+
+#ifndef CONFIG_GK_DISABLE_DOWNLOAD
+	/*
+	 *  read system register REG_SC_GEN2
+         *  check if ziju flag
+	 */
+	ldr	r0, =SYS_CTRL_REG_BASE
+	ldr	r1, [r0, #REG_SC_GEN2]
+	ldr	r2, =0x7a696a75          /* magic for "ziju" */
+	cmp	r1, r2
+	bne	normal_start_flow
+	mov	r1, sp                   /* save sp */
+	str	r1, [r0, #REG_SC_GEN2]  /* clear ziju flag */
+
+    /* init PLL/DDRC/pin mux/... */
+	ldr	r0, _blank_zone_start
+	ldr	r1, _TEXT_BASE
+	sub	r0, r0, r1
+	ldr	r1, =RAM_START_ADRS
+	ldr	sp, =STACK_TRAINING
+	add	r0, r0, r1
+	mov	r1, #0x0                 /* flags: 0->normal 1->pm */
+	bl	init_registers           /* init PLL/DDRC/... */
+	/* after ziju, we need ddr traning */
+	ldr	r0, =SYS_CTRL_REG_BASE
+	bl	start_ddr_training       /* DDR training */
+    ldr	r0, =SYS_CTRL_REG_BASE
+	ldr	r1, [r0, #REG_SC_GEN2]
+	mov	sp, r1		         /* restore sp */
+	ldr	r1, [r0, #REG_SC_GEN3]
+	mov	pc, r1                  /* return to bootrom */
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	b	.                        /* bug here */
+
+normal_start_flow:
+#endif
+	/* init serial and printf a string. */
+	ldr     sp, =STACK_TRAINING
+	bl      uart_early_init
+	bl      msg_main_cpu_startup
+
+	/*
+	 * enable syscnt 
+	 */
+	ldr	r0, =SYSCNT_REG_BASE
+	ldr 	r3, =SYSCNT_FREQ
+	str	r3, [r0, #SYSCNT_FREQ_REG]
+	mov	r3, #0x1
+	str	r3, [r0, #SYSCNT_ENABLE_REG]
+
+	@if running not boot from nand/spi/emmc,
+	@we skipping boot_type checking.
+	mov    r0, pc, lsr#24
+	cmp    r0, #0x0
+	bne    do_clr_remap
+
+check_boot_type:
+    ldr     r0, =SYS_CTRL_REG_BASE
+    ldr     r0, [r0, #REG_SYSSTAT]
+    mov     r6, r0, lsr#4
+	and     r6, #0x1
+    cmp     r6, #0x1
+    ldrlo   pc, _clr_remap_fmc_entry
+
+do_clr_remap:
+        /* do clear remap */
+	ldr     r4, =SYS_CTRL_REG_BASE
+	ldr	r0, [r4, #REG_SC_CTRL]
+
+	@Set clear remap bit.
+	orr	r0, #(1<<8)
+	str	r0, [r4, #REG_SC_CTRL]
+
+	@enable I-Cache now
+	mrc p15, 0, r0, c1, c0, 0
+    orr r0, r0, #0x00001000 /* set bit 12 (I) I-Cache */
+    mcr p15, 0, r0, c1, c0, 0
+
+	@Check wether I'm running in dynamic mem bank:<0x40000000
+	mov r0, pc, lsr#28
+	cmp r0, #4
+	blo	ddr_init
+
+no_ddr_init:
+	adrl	r0, _start
+	b       copy_to_ddr
+
+ddr_init:
+	ldr     r0, _blank_zone_start
+	ldr     r1, _TEXT_BASE
+	sub     r0, r0, r1
+	adrl	r1, _start
+	add     r0, r0, r1
+	mov     r1, #0          /* flags: 0->normal 1->pm */
+	bl      init_registers
+
+	ldr	sp, =STACK_TRAINING
+	ldr	r0, =SYS_CTRL_REG_BASE
+	bl	start_ddr_training       /* DDR training */
+
+check_boot_mode:
+	ldr	r0, =SYS_CTRL_REG_BASE
+	ldr     r0, [r0, #REG_SYSSTAT]
+	mov     r6, r0, lsr#4
+	and	r6, #0x1
+	cmp     r6, #BOOT_FROM_EMMC
+	bne     copy_flash_to_ddr
+
+emmc_boot:
+	ldr     r0, _TEXT_BASE
+	ldr	r1, =__image_copy_start
+	ldr	r2, =__bss_start
+	sub	r1, r2, r1
+	bl	emmc_boot_read
+	b       relocate
+
+copy_flash_to_ddr:
+	/* relocate SPI nor/nand Boot to DDR  */
+	ldr	r0, =FMC_MEM_BASE
+
+copy_to_ddr:
+	/* now, r0 stores __reset offset from where we get started */
+	ldr     r1, =__image_copy_start
+
+	/* compare source and target address, *
+	 *if equal no copy to target address */
+	cmp     r0, r1
+	beq	start_armboot
+
+	ldr     r2, =__image_copy_start/*_start*/
+	ldr     r3, =__bss_start
+	sub     r2, r3, r2      /* r2 <- size of armboot */
+	/* memcpy(r1, r0, r2) */
+	bl      memcpy
+
+relocate:
+	ldr r0, =_start_armboot
+	ldr pc, [r0]
+
+bug:
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	b       .                       /* bug here */
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+@
+@       void memcpy(r1, r0, r2);
+@
+
+.align  2
+memcpy:
+	add     r2, r0, r2
+	memcpy_loop:
+	ldmia   r0!, {r3 - r10}
+	stmia   r1!, {r3 - r10}
+	cmp     r0, r2
+	ble     memcpy_loop
+	mov     pc, lr
+
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+.align  2
+msg_main_cpu_startup:
+	mov     r5, lr
+	add     r0, pc, #4
+	bl      uart_early_puts
+	mov     pc, r5
+	L10:
+#ifndef CONFIG_SUPPORT_CA_RELEASE
+	.ascii "\r\n\r\nSystem startup\r\n\0"
+#else
+	.ascii "\r\n\r\n\r\n\0"
+#endif
+
+/*------------------------------------------------------------------------------*/
+
+ENTRY(c_runtime_cpu_setup)
+/*
+ * If I-cache is enabled invalidate it
+ */
+#ifndef CONFIG_SYS_ICACHE_OFF
+	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
+	mcr     p15, 0, r0, c7, c10, 4	@ DSB
+	mcr     p15, 0, r0, c7, c5, 4	@ ISB
+#endif
+
+	bx	lr
+
+ENDPROC(c_runtime_cpu_setup)
+
+/*************************************************************************
+ *
+ * void save_boot_params(u32 r0, u32 r1, u32 r2, u32 r3)
+ *	__attribute__((weak));
+ *
+ * Stack pointer is not yet initialized at this moment
+ * Don't save anything to stack even if compiled with -O0
+ *
+ *************************************************************************/
+ENTRY(save_boot_params)
+	b	save_boot_params_ret		@ back to my caller
+ENDPROC(save_boot_params)
+	.weak	save_boot_params
+
+#ifdef CONFIG_ARMV7_LPAE
+ENTRY(switch_to_hypervisor)
+	b	switch_to_hypervisor_ret
+ENDPROC(switch_to_hypervisor)
+	.weak	switch_to_hypervisor
+#endif
+
+/*************************************************************************
+ *
+ * cpu_init_cp15
+ *
+ * Setup CP15 registers (cache, MMU, TLBs). The I-cache is turned on unless
+ * CONFIG_SYS_ICACHE_OFF is defined.
+ *
+ *************************************************************************/
+ENTRY(cpu_init_cp15)
+	/*
+	 * Invalidate L1 I/D
+	 */
+	mov	r0, #0			@ set up for MCR
+	mcr	p15, 0, r0, c8, c7, 0	@ invalidate TLBs
+	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
+	mcr	p15, 0, r0, c7, c5, 6	@ invalidate BP array
+	mcr     p15, 0, r0, c7, c10, 4	@ DSB
+	mcr     p15, 0, r0, c7, c5, 4	@ ISB
+
+	/*
+	 * disable MMU stuff and caches
+	 */
+	mrc	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #0x00002000	@ clear bits 13 (--V-)
+	bic	r0, r0, #0x00000007	@ clear bits 2:0 (-CAM)
+	orr	r0, r0, #0x00000002	@ set bit 1 (--A-) Align
+	orr	r0, r0, #0x00000800	@ set bit 11 (Z---) BTB
+#ifdef CONFIG_SYS_ICACHE_OFF
+	bic	r0, r0, #0x00001000	@ clear bit 12 (I) I-cache
+#else
+	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-cache
+#endif
+	mcr	p15, 0, r0, c1, c0, 0
+
+#ifdef CONFIG_ARM_ERRATA_716044
+	mrc	p15, 0, r0, c1, c0, 0	@ read system control register
+	orr	r0, r0, #1 << 11	@ set bit #11
+	mcr	p15, 0, r0, c1, c0, 0	@ write system control register
+#endif
+
+#if (defined(CONFIG_ARM_ERRATA_742230) || defined(CONFIG_ARM_ERRATA_794072))
+	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register
+	orr	r0, r0, #1 << 4		@ set bit #4
+	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_743622
+	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register
+	orr	r0, r0, #1 << 6		@ set bit #6
+	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_751472
+	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register
+	orr	r0, r0, #1 << 11	@ set bit #11
+	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register
+#endif
+#ifdef CONFIG_ARM_ERRATA_761320
+	mrc	p15, 0, r0, c15, c0, 1	@ read diagnostic register
+	orr	r0, r0, #1 << 21	@ set bit #21
+	mcr	p15, 0, r0, c15, c0, 1	@ write diagnostic register
+#endif
+
+	mov	r5, lr			@ Store my Caller
+	mrc	p15, 0, r1, c0, c0, 0	@ r1 has Read Main ID Register (MIDR)
+	mov	r3, r1, lsr #20		@ get variant field
+	and	r3, r3, #0xf		@ r3 has CPU variant
+	and	r4, r1, #0xf		@ r4 has CPU revision
+	mov	r2, r3, lsl #4		@ shift variant field for combined value
+	orr	r2, r4, r2		@ r2 has combined CPU variant + revision
+
+#ifdef CONFIG_ARM_ERRATA_798870
+	cmp	r2, #0x30		@ Applies to lower than R3p0
+	bge	skip_errata_798870      @ skip if not affected rev
+	cmp	r2, #0x20		@ Applies to including and above R2p0
+	blt	skip_errata_798870      @ skip if not affected rev
+
+	mrc	p15, 1, r0, c15, c0, 0  @ read l2 aux ctrl reg
+	orr	r0, r0, #1 << 7         @ Enable hazard-detect timeout
+	push	{r1-r5}			@ Save the cpu info registers
+	bl	v7_arch_cp15_set_l2aux_ctrl
+	isb				@ Recommended ISB after l2actlr update
+	pop	{r1-r5}			@ Restore the cpu info - fall through
+skip_errata_798870:
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_801819
+	cmp	r2, #0x24		@ Applies to lt including R2p4
+	bgt	skip_errata_801819      @ skip if not affected rev
+	cmp	r2, #0x20		@ Applies to including and above R2p0
+	blt	skip_errata_801819      @ skip if not affected rev
+	mrc	p15, 0, r0, c0, c0, 6	@ pick up REVIDR reg
+	and	r0, r0, #1 << 3		@ check REVIDR[3]
+	cmp	r0, #1 << 3
+	beq	skip_errata_801819	@ skip erratum if REVIDR[3] is set
+
+	mrc	p15, 0, r0, c1, c0, 1	@ read auxilary control register
+	orr	r0, r0, #3 << 27	@ Disables streaming. All write-allocate
+					@ lines allocate in the L1 or L2 cache.
+	orr	r0, r0, #3 << 25	@ Disables streaming. All write-allocate
+					@ lines allocate in the L1 cache.
+	push	{r1-r5}			@ Save the cpu info registers
+	bl	v7_arch_cp15_set_acr
+	pop	{r1-r5}			@ Restore the cpu info - fall through
+skip_errata_801819:
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_454179
+	cmp	r2, #0x21		@ Only on < r2p1
+	bge	skip_errata_454179
+
+	mrc	p15, 0, r0, c1, c0, 1	@ Read ACR
+	orr	r0, r0, #(0x3 << 6)	@ Set DBSM(BIT7) and IBE(BIT6) bits
+	push	{r1-r5}			@ Save the cpu info registers
+	bl	v7_arch_cp15_set_acr
+	pop	{r1-r5}			@ Restore the cpu info - fall through
+
+skip_errata_454179:
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_430973
+	cmp	r2, #0x21		@ Only on < r2p1
+	bge	skip_errata_430973
+
+	mrc	p15, 0, r0, c1, c0, 1	@ Read ACR
+	orr	r0, r0, #(0x1 << 6)	@ Set IBE bit
+	push	{r1-r5}			@ Save the cpu info registers
+	bl	v7_arch_cp15_set_acr
+	pop	{r1-r5}			@ Restore the cpu info - fall through
+
+skip_errata_430973:
+#endif
+
+#ifdef CONFIG_ARM_ERRATA_621766
+	cmp	r2, #0x21		@ Only on < r2p1
+	bge	skip_errata_621766
+
+	mrc	p15, 0, r0, c1, c0, 1	@ Read ACR
+	orr	r0, r0, #(0x1 << 5)	@ Set L1NEON bit
+	push	{r1-r5}			@ Save the cpu info registers
+	bl	v7_arch_cp15_set_acr
+	pop	{r1-r5}			@ Restore the cpu info - fall through
+
+skip_errata_621766:
+#endif
+
+	mov	pc, r5			@ back to my caller
+ENDPROC(cpu_init_cp15)
+
+#if !defined(CONFIG_SKIP_LOWLEVEL_INIT) && \
+	!defined(CONFIG_SKIP_LOWLEVEL_INIT_ONLY)
+/*************************************************************************
+ *
+ * CPU_init_critical registers
+ *
+ * setup important registers
+ * setup memory timing
+ *
+ *************************************************************************/
+ENTRY(cpu_init_crit)
+	/*
+	 * Jump to board specific initialization...
+	 * The Mask ROM will have already initialized
+	 * basic memory. Go here to bump up clock rate and handle
+	 * wake up conditions.
+	 */
+	b	lowlevel_init		@ go setup pll,mux,memory
+ENDPROC(cpu_init_crit)
+#endif
+
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7605v100/startup.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7605v100/startup.c
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7605v100/startup.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7605v100/startup.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,156 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <config.h>
+#include <linux/kconfig.h>
+#include <asm/io.h>
+#include <compiler.h>
+#include <cpu_common.h>
+
+extern unsigned int hw_dec_type;
+
+extern void hw_dec_init(void);
+extern int hw_dec_decompress(unsigned char *dst, int *dstlen,
+		      unsigned char *src, int srclen,
+		      void *unused);
+extern void hw_dec_uinit(void);
+
+/******************************************************************************/
+const uintptr_t image_entry = (CONFIG_SYS_TEXT_BASE);
+
+/******************************************************************************/
+
+#define GZIP_SIZE_OFFSET 0x4
+
+#ifndef CONFIG_SYS_ICACHE_OFF
+/* Invalidate entire I-cache and branch predictor array */
+static void invalidate_icache_all(void)
+{
+	/*
+	 * Invalidate all instruction caches to PoU.
+	 * Also flushes branch target cache.
+	 */
+	asm volatile("mcr p15, 0, %0, c7, c5, 0" : : "r"(0));
+
+	/* Invalidate entire branch predictor array */
+	asm volatile("mcr p15, 0, %0, c7, c5, 6" : : "r"(0));
+
+	/* Full system DSB - make sure that the invalidation is complete */
+	dsb();
+
+	/* ISB - make sure the instruction stream sees it */
+	isb();
+}
+#else
+static void invalidate_icache_all(void)
+{
+}
+#endif
+
+/******************************************************************************/
+void start_armboot(void)
+{
+	unsigned char *pdst_l32 = NULL;
+	unsigned int image_data_len;
+	int pdst_len;
+	int ret;
+	int i;
+	char *p = NULL;
+	char *q = NULL;
+
+	uart_early_init();
+	uart_early_puts("\r\nUncompress ");
+
+	/* use direct address mode */
+	hw_dec_type = 0;
+	/* init hw decompress IP */
+	hw_dec_init();
+
+	/* start decompress */
+	pdst_l32 = (unsigned char *)(uintptr_t)image_entry;
+	image_data_len = input_data_end - input_data;
+
+	/* get dets length from compress image */
+	p = (char *)&pdst_len;
+	q = (char *)(input_data_end - GZIP_SIZE_OFFSET);
+	for (i = 0; i < sizeof(int); i++)
+		p[i] = q[i];
+
+	ret = hw_dec_decompress(pdst_l32, &pdst_len, input_data, image_data_len, NULL);
+	if (!ret) {
+		uart_early_puts("Ok!");
+	} else {
+		uart_early_puts("Fail!");
+		while (1) ;
+	}
+	/* uinit hw decompress IP */
+	hw_dec_uinit();
+	void (*uboot)(void);
+	uboot = (void (*))CONFIG_SYS_TEXT_BASE;
+	invalidate_icache_all();
+	uboot();
+}
+
+void hang(void)
+{
+	uart_early_puts("### ERROR ### Please RESET the board ###\n");
+	for (;;) ;
+}
+
+
+void do_bad_sync(void)
+{
+	uart_early_puts("bad sync abort\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_sync(void)
+{
+	uart_early_puts("sync abort\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_bad_error(void)
+{
+	uart_early_puts("bad error\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_error(void)
+{
+	uart_early_puts("error\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_bad_fiq(void)
+{
+	uart_early_puts("bad fast interrupt request\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_bad_irq(void)
+{
+	uart_early_puts("bad interrupt request\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_fiq(void)
+{
+	uart_early_puts("fast interrupt request\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
+
+void do_irq(void)
+{
+	uart_early_puts("interrupt request\r\n");
+	uart_early_puts("Resetting CPU ...\r\n");
+	reset_cpu(0);
+}
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7605v100/uart.S gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7605v100/uart.S
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7605v100/uart.S	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7605v100/uart.S	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,126 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <config.h>
+
+@******************************************************************************
+@
+@  void uart_early_init(void);
+@
+.text
+.align	2
+.global	uart_early_init
+.type	uart_early_init, %function
+uart_early_init:
+#ifndef CONFIG_GK_DISABLE_CONSOLE
+	ldr	a4, uart_base_addr_L0
+	mov	a3, #0
+	/* Disable UART */
+	str	a3, [a4, #48]
+	/* Set baud rate to 115200, uart clock:24M */
+	add	a3, a3, #13
+	str	a3, [a4, #36]
+	mov	a3, #1
+	str	a3, [a4, #40]
+	/* Set the UART to be 8 bits, 1 stop bit, no parity, fifo enabled. */
+	ldr	a3, =112
+	str	a3, [a4, #44]
+	/* Enable UART */
+	ldr	a3, =769
+	str	a3, [a4, #48]
+#endif
+	bx	lr
+uart_base_addr_L0:
+	.word CONFIG_CUR_UART_BASE
+
+@******************************************************************************
+@
+@  void uart_early_puts(const char *ss);
+@
+.align	2
+.global	uart_early_puts
+.type	uart_early_puts, %function
+uart_early_puts:
+#ifndef CONFIG_GK_DISABLE_CONSOLE
+#if !defined(CONFIG_SUPPORT_CA_RELEASE)
+	ldr	a2, uart_base_addr_L1
+	b	next_char
+output:
+	ldr	a4, [a2, #24]
+	tst	a4, #32
+	bne	output
+	str	a3, [a2, #0]
+	add	a1, a1, #1
+next_char:
+	ldrb	a3, [a1]
+	cmp	a3, #0
+	bne	output
+#endif /* CONFIG_SUPPORT_CA_RELEASE */
+#endif /* CONFIG_GK_DISABLE_CONSOLE */
+	bx	lr
+uart_base_addr_L1:
+	.word CONFIG_CUR_UART_BASE
+
+@******************************************************************************
+@
+@  void uart_early_put_hex(int hex);
+@
+@  call example:
+@    mov	r0, sp
+@    bl	uart_early_put_hex
+@
+.align	2
+.global	uart_early_put_hex
+.type	uart_early_put_hex, %function
+uart_early_put_hex:
+#if !defined(CONFIG_SUPPORT_CA_RELEASE)
+	ldr	a2, uart_base_addr_L2
+	mov	a3, #28
+wait2:
+	ldr	a4, [a2, #24]
+	tst	a4, #32
+	bne	wait2
+
+	mov	a4, #0xF
+	and	a4, a4, a1, lsr a3
+	cmp	a4, #9
+	addle	a4, a4, #0x30	@ a4 = a4 + '0'
+	addgt	a4, a4, #55	@ a4 = a4 - 10 + 'A'
+	str	a4, [a2, #0]
+	cmp	a3, #0
+	beq	exit2
+	sub	a3, a3, #4
+	b	wait2
+exit2:
+#endif /* CONFIG_SUPPORT_CA_RELEASE */
+	bx	lr
+uart_base_addr_L2:
+	.word CONFIG_CUR_UART_BASE
+
+@******************************************************************************
+@
+@  void uart_early_putc(int chr);
+@
+@  call example:
+@    mov	r0, #'A'
+@    bl	uart_early_putc
+@
+.align	2
+.global	uart_early_putc
+.type	uart_early_putc, %function
+uart_early_putc:
+#ifndef CONFIG_GK_DISABLE_CONSOLE
+#if !defined(CONFIG_SUPPORT_CA_RELEASE)
+	ldr	a2, uart_base_addr_L3
+wait3:
+	ldr	a4, [a2, #24]
+	tst	a4, #32
+	bne	wait3
+	str	a1, [a2, #0]
+
+#endif /* CONFIG_SUPPORT_CA_RELEASE */
+#endif /* CONFIG_GK_DISABLE_CONSOLE */
+	bx	lr
+uart_base_addr_L3:
+	.word CONFIG_CUR_UART_BASE
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/gk7605v100/u-boot.lds gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7605v100/u-boot.lds
--- u-boot-2016.11/arch/arm/cpu/armv7/gk7605v100/u-boot.lds	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/gk7605v100/u-boot.lds	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,52 @@
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x40700000;
+	__image_copy_start =.;
+	. = ALIGN(4);
+	.text	:
+	{
+		__text_start = .;
+		start.o (.text*)
+		init_registers.o (.text*)
+		lowlevel_init_v300.o (.text*)
+		ddr_training_impl.o (.text*)
+		ddr_training_console.o (.text*)
+		ddr_training_ctl.o (.text*)
+		ddr_training_boot.o (.text*)
+		ddr_training_custom.o (.text*)
+		uart.o (.text*)
+		div0.o (.text*)
+		emmc_boot.o (.text*)
+		image_data.o (.text*)
+		hw_decompress.o (.text*)
+		startup.o(.text*)
+		reset.o(.text*)
+		__init_end = .;
+		ASSERT(((__init_end - __text_start) < 0x6000), "init sections too big!");
+		*(.text*)
+	}
+	__text_end = .;
+
+	. = ALIGN(4);
+	.image : { *(.image) }
+
+	. = ALIGN(4);
+	.rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = ALIGN(4);
+	__image_copy_end =.;
+	__bss_start = .;
+	.bss : { *(.bss) }
+	__bss_end = .;
+	_end = .;
+}
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/Kconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/Kconfig
--- u-boot-2016.11/arch/arm/cpu/armv7/Kconfig	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/Kconfig	2021-06-07 13:01:31.000000000 +0300
@@ -12,7 +12,7 @@
 config ARMV7_NONSEC
 	bool "Enable support for booting in non-secure mode" if EXPERT
 	depends on CPU_V7_HAS_NONSEC
-	default y
+	default y if !MINI_BOOT
 	---help---
 	Say Y here to enable support for booting in non-secure / SVC mode.
 
diff -uraN u-boot-2016.11/arch/arm/cpu/armv7/start.S gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/start.S
--- u-boot-2016.11/arch/arm/cpu/armv7/start.S	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/cpu/armv7/start.S	2021-06-07 13:01:31.000000000 +0300
@@ -36,6 +36,7 @@
 #endif
 
 reset:
+#ifndef CONFIG_MINI_BOOT
 	/* Allow the board to save important registers */
 	b	save_boot_params
 save_boot_params_ret:
@@ -84,6 +85,7 @@
 	bl	cpu_init_crit
 #endif
 #endif
+#endif
 
 	bl	_main
 
@@ -103,6 +105,7 @@
 
 ENDPROC(c_runtime_cpu_setup)
 
+#ifndef CONFIG_MINI_BOOT
 /*************************************************************************
  *
  * void save_boot_params(u32 r0, u32 r1, u32 r2, u32 r3)
@@ -116,6 +119,7 @@
 	b	save_boot_params_ret		@ back to my caller
 ENDPROC(save_boot_params)
 	.weak	save_boot_params
+#endif
 
 #ifdef CONFIG_ARMV7_LPAE
 ENTRY(switch_to_hypervisor)
diff -uraN u-boot-2016.11/arch/arm/dts/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/dts/.gitignore
--- u-boot-2016.11/arch/arm/dts/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/dts/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1 +0,0 @@
-*.dtb
diff -uraN u-boot-2016.11/arch/arm/include/asm/arch-gk7202v300/boot0.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/arch-gk7202v300/boot0.h
--- u-boot-2016.11/arch/arm/include/asm/arch-gk7202v300/boot0.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/arch-gk7202v300/boot0.h	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,16 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#ifndef __BOOT0_H
+#define __BOOT0_H
+
+#define ARM_SOC_BOOT0_HOOK
+
+/* BOOT0 header information */
+#define VENDOR_BOOT0_HOOK   \
+	__blank_zone_start : \
+	.fill 1024*8,1,0;   \
+	__blank_zone_end :
+
+#include <../mach-goke/boot0_hook.S>
+#endif /* __BOOT0_H */
diff -uraN u-boot-2016.11/arch/arm/include/asm/arch-gk7202v300/mmu.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/arch-gk7202v300/mmu.h
--- u-boot-2016.11/arch/arm/include/asm/arch-gk7202v300/mmu.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/arch-gk7202v300/mmu.h	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,191 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __ARM_ARCH_MMU_H
+#define __ARM_ARCH_MMU_H
+
+#include <linux/types.h>
+#ifdef CONFIG_ARCH_MMU
+/*
+ * Translation Table Base Bit Masks
+ */
+#define ARM_TRANSLATION_TABLE_MASK               0xFFFFC000
+
+/*
+ * Domain Access Control Bit Masks
+ */
+#define arm_access_type_no_access(domain_num)    (0x0 << (domain_num)*2)
+#define arm_access_type_client(domain_num)       (0x1 << (domain_num)*2)
+#define arm_access_type_manager(domain_num)      (0x3 << (domain_num)*2)
+
+
+#define ARM_MMU_FIRST_LEVEL_FAULT_ID 0x0
+
+struct arm_mmu_first_level_fault {
+	unsigned int id: 2;
+	unsigned int sbz: 30;
+};
+
+#define ARM_MMU_FIRST_LEVEL_PAGE_TABLE_ID 0x1
+
+struct arm_mmu_first_level_page_table {
+	unsigned int id: 2;
+	unsigned int sbz0: 1;
+	unsigned int ns: 1;
+	unsigned int sbz1: 1;
+	unsigned int domain: 4;
+	unsigned int imp: 1;
+	unsigned int base_address: 22;
+};
+
+#define ARM_MMU_FIRST_LEVEL_SECTION_ID 0x2
+
+struct arm_mmu_first_level_section {
+	unsigned int id: 2;
+	unsigned int b: 1;
+	unsigned int c: 1;
+	unsigned int xn: 1;
+	unsigned int domain: 4;
+	unsigned int imp: 1;
+	unsigned int ap0: 2;
+	unsigned int tex: 3;
+	unsigned int ap1: 1;
+	unsigned int s: 1;
+	unsigned int ng: 1;
+	unsigned int reserved: 1;
+	unsigned int ns: 1;
+	unsigned int base_address: 12;
+};
+
+struct arm_mmu_first_level_reserved {
+	unsigned int id: 2;
+	unsigned int sbz: 30;
+};
+
+#define ARM_MMU_SECOND_LEVEL_FAULT_ID 0x0
+
+struct arm_mmu_second_level_fault {
+	unsigned int id: 2;
+	unsigned int sbz: 30;
+};
+
+#define ARM_MMU_SECOND_LEVEL_SMALL_ID 0x2
+
+struct arm_mmu_second_level_small {
+	unsigned int id: 2;
+	unsigned int b: 1;
+	unsigned int c: 1;
+	unsigned int ap0: 2;
+	unsigned int tex: 3;
+	unsigned int ap1: 1;
+	unsigned int s: 1;
+	unsigned int ng: 1;
+	unsigned int base_address: 20;
+};
+
+#define ARM_MMU_FIRST_LEVEL_RESERVED_ID 0x3
+
+#define arm_mmu_first_level_descriptor_address(ttb_base, table_index) \
+	(unsigned long *)((unsigned long)(ttb_base) + ((table_index) << 2))
+
+#define ARM_FIRST_LEVEL_PAGE_TABLE_SIZE 0x4000
+
+union arm_mmu_first_level_descriptor {
+	unsigned long word;
+	struct arm_mmu_first_level_fault fault;
+	struct arm_mmu_first_level_page_table page_table;
+	struct arm_mmu_first_level_section section;
+	struct arm_mmu_first_level_reserved reserved;
+};
+
+union arm_mmu_second_level_descriptor {
+	unsigned long word;
+	struct arm_mmu_second_level_fault fault;
+	struct arm_mmu_second_level_small small;
+};
+
+static inline void arm_mmu_section(int ttb_base, int actual_base,
+			int virtual_base, unsigned int tex, unsigned int cacheable,
+			unsigned int bufferable, unsigned int perm,
+			unsigned int shareable)
+{
+	register union arm_mmu_first_level_descriptor desc;
+
+	desc.word = 0;
+	desc.section.id = ARM_MMU_FIRST_LEVEL_SECTION_ID;
+	desc.section.c = cacheable;
+	desc.section.b = bufferable;
+	desc.section.xn = 0;
+	desc.section.domain = 0;
+	desc.section.ap0 = perm;
+	desc.section.tex = tex;
+	desc.section.ap1 = 0;
+	desc.section.s = shareable;
+	desc.section.base_address = actual_base;
+	*arm_mmu_first_level_descriptor_address(ttb_base, (virtual_base))
+		= desc.word;
+}
+
+static inline void x_arm_mmu_section(int abase, int vbase, int size,
+									 unsigned int tex, unsigned int cache, unsigned int buff,
+									 unsigned int access, unsigned int shareable)
+{
+	int i;
+	int j = abase;
+	int k = vbase;
+	unsigned long ttb_base = CONFIG_TTB_ADDR;
+
+	for (i = size; i > 0 ; i--, j++, k++)
+		arm_mmu_section(ttb_base, j, k, tex, cache,
+						buff, access, shareable);
+}
+
+#define ARM_UNCACHEABLE     0
+#define ARM_CACHEABLE       1
+#define ARM_UNBUFFERABLE    0
+#define ARM_BUFFERABLE      1
+
+#define ARM_ACCESS_PERM_NONE_NONE   0
+#define ARM_ACCESS_PERM_RW_NONE     1
+#define ARM_ACCESS_PERM_RW_RO       2
+#define ARM_ACCESS_PERM_RW_RW       3
+
+#define ARM_NOSHAREABLE     0
+#define ARM_SHAREABLE       1
+
+#define ARM_MEMTYPE_STRONGORDER      0
+#define ARM_MEMTYPE_DEVICE           1
+#define ARM_MEMTYPE_NORMAL           2
+#define ARM_MEMTYPE_RESERVED         3
+
+
+#define ARM_CACHETYPE_NOCACHE        0
+#define ARM_CACHETYPE_WRITEBACK      1
+#define ARM_CACHETYPE_WRITETHROUGH   2
+#define ARM_CACHETYPE_WRITEBACK_ONLY 3
+
+
+/*
+ * Initialization for the Domain Access Control Register
+ */
+#define ARM_ACCESS_DACR_DEFAULT      (  \
+	arm_access_type_manager(0)    | \
+	arm_access_type_no_access(1)  | \
+	arm_access_type_no_access(2)  | \
+	arm_access_type_no_access(3)  | \
+	arm_access_type_no_access(4)  | \
+	arm_access_type_no_access(5)  | \
+	arm_access_type_no_access(6)  | \
+	arm_access_type_no_access(7)  | \
+	arm_access_type_no_access(8)  | \
+	arm_access_type_no_access(9)  | \
+	arm_access_type_no_access(10) | \
+	arm_access_type_no_access(11) | \
+	arm_access_type_no_access(12) | \
+	arm_access_type_no_access(13) | \
+	arm_access_type_no_access(14) | \
+	arm_access_type_no_access(15))
+
+#endif
+#endif
diff -uraN u-boot-2016.11/arch/arm/include/asm/arch-gk7202v300/platform.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/arch-gk7202v300/platform.h
--- u-boot-2016.11/arch/arm/include/asm/arch-gk7202v300/platform.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/arch-gk7202v300/platform.h	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,235 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __CHIP_REGS_H__
+#define __CHIP_REGS_H__
+
+
+/* -------------------------------------------------------------------- */
+#define RAM_START_ADRS          0x04010500
+#define STACK_TRAINING          0x0401A000
+
+/* -------------------------------------------------------------------- */
+#define FMC_REG_BASE            0x10000000
+
+/* -------------------------------------------------------------------- */
+#define REG_BASE_SF             0x10040000
+
+/* -------------------------------------------------------------------- */
+#define EMMC_REG_BASE           0x10010000
+#define SDIO1_REG_BASE          0x10020000
+
+/* -------------------------------------------------------------------- */
+#define USB3_CTRL_REG_BASE      0x10030000
+
+/* -------------------------------------------------------------------- */
+#define USB_OHCI_BASE         0x10030000
+
+/* -------------------------------------------------------------------- */
+#define DDRC0_REG_BASE          0x11330000
+
+/* -------------------------------------------------------------------- */
+#define TIMER0_REG_BASE         0x12000000
+#define TIMER1_REG_BASE         0x12000020
+#define TIMER2_REG_BASE         0x12001000
+#define TIMER3_REG_BASE         0x12001020
+
+#define REG_TIMER_RELOAD        0x0
+#define REG_TIMER_VALUE         0x4
+#define REG_TIMER_CONTROL       0x8
+
+#define CFG_TIMER_CLK           3000000
+#define CFG_TIMERBASE           TIMER0_REG_BASE
+
+/* enable timer.32bit, periodic,mask irq, 1 divider. */
+#define CFG_TIMER_CTRL          0xC2
+
+/* -------------------------------------------------------------------- */
+/* Clock and Reset Generator REG */
+/* -------------------------------------------------------------------- */
+#define CRG_REG_BASE            0x12010000
+
+#define REG_CRG80           0x0140
+#define REG_CRG81           0x0144
+#define REG_CRG91           0x016c
+#define REG_CRG110          0x01b8
+
+/* USB 2.0 CRG Control register offset */
+#define REG_USB2_CTRL       REG_CRG80
+
+/* FMC CRG register offset */
+#define REG_FMC_CRG         REG_CRG81
+#define FMC_SRST            (0x1 << 0)
+#define FMC_CLK_ENABLE      (0x1 << 1)
+#define FMC_CLK_SEL_MASK    (0x7 << 2)
+#define FMC_CLK_SEL_SHIFT   0x2
+/* SDR/DDR clock */
+#define FMC_CLK_24M         0x0
+#define FMC_CLK_100M        0x1
+#define FMC_CLK_150M        0x2
+
+#define FMC_CLK_200M        0x3
+
+/* Only DDR clock */
+#define FMC_CLK_300M        0x4
+#define FMC_CLK_360M        0x5
+
+#define fmc_clk_sel(_clk) \
+	(((_clk) << FMC_CLK_SEL_SHIFT) & FMC_CLK_SEL_MASK)
+#define get_fmc_clk_type(_reg) \
+	(((_reg) & FMC_CLK_SEL_MASK) >> FMC_CLK_SEL_SHIFT)
+
+/* Ethernet CRG register offset */
+#define REG_ETH_CRG         REG_CRG91
+#define REG_ETH_MAC_IF      0x8c
+
+/* Uart CRG register offset */
+#define REG_UART_CRG            REG_CRG110
+#define uart_clk_sel(_clk)      (((_clk) & 0x3) << 18)
+#define UART_CLK_SEL_MASK       (0x3 << 18)
+#define UART_CLK_APB            0
+#define UART_CLK_24M            1
+#define UART_CLK_2M         2
+
+/* SDIO0 CRG register offset */
+#define REG_SDIO0_CRG           (CRG_REG_BASE + 0x238)
+
+/* eMMC CRG register offset */
+#define REG_EMMC_CRG            (CRG_REG_BASE + 0x1f4)
+#define mmc_clk_sel(_clk)       (((_clk) & 0x7) << 24)
+#define MMC_CLK_SEL_MASK        (0x7 << 24)
+#define get_mmc_clk_type(_reg)      (((_reg) >> 24) & 0x7)
+
+/* -------------------------------------------------------------------- */
+/* System Control REG */
+/* -------------------------------------------------------------------- */
+#define SYS_CTRL_REG_BASE       0x12020000
+#define REG_BASE_SCTL           SYS_CTRL_REG_BASE
+#define REG_SC_SYSSTAT          0x8c
+#define spi_input_sle(x)        (((x) >> 16) & 0x1)
+
+/* System Control register offset */
+#define REG_SC_CTRL         0x0000
+#define sc_ctrl_timer0_clk_sel(_clk)    (((_clk) & 0x1) << 16)
+#define TIMER0_CLK_SEL_MASK     (0x1 << 16)
+#define TIMER_CLK_3M            0
+#define TIMER_CLK_BUS           1
+#define SC_CTRL_REMAP_CLEAR     (0x1 << 8)
+
+/* System soft reset register offset */
+#define REG_SC_SYSRES           0x0004
+
+/* System Status register offset */
+#define REG_SYSSTAT         0x008c
+/* bit[7]=0: 3-Byte address mode; bit[7]=1: 4-Byte address mode */
+#define get_spi_nor_addr_mode(_reg) (((_reg) >> 7) & 0x1)
+/* bit[6]=0; SPI nor flash; bit[6]=1: SPI nand flash */
+#define get_spi_device_type(_reg)   (((_reg) >> 10) & 0x1)
+/* bit[4]=0  SPI; bit[4]=1: EMMC */
+#define get_sys_boot_mode(_reg)     (((_reg) >> 4) & 0x1)
+#define BOOT_FROM_SPI           0
+#define BOOT_FROM_SPI_NAND      1
+#define BOOT_FROM_NAND          2
+#define BOOT_FROM_EMMC          1
+#define NF_BOOTBW_MASK          (1 << 11)
+
+
+#define REG_SC_GEN5         0x0134
+#define REG_SC_GEN0         0x0138
+#define REG_SC_GEN1         0x013c
+#define REG_SC_GEN2         0x0140
+#define REG_SC_GEN3         0x0144
+#define REG_SC_GEN4         0x0148
+#define REG_SC_GEN9         0x0154
+
+/********** Communication Register and flag used by bootrom *************/
+#define REG_START_FLAG      (SYS_CTRL_REG_BASE + REG_SC_GEN1)
+#define START_MAGIC         0x444f574e
+#define SELF_BOOT_TYPE_USBDEV           0x2  /* debug */
+
+/* -------------------------------------------------------------------- */
+/* Peripheral Control REG */
+/* -------------------------------------------------------------------- */
+#define MISC_REG_BASE           0x12028000
+
+#define MISC_CTRL17                     0x0044
+#define MISC_CTRL18         0x48
+#define MISC_CTRL7          0x001C
+#define MISC_CTRL8          0x0020
+#define MISC_CTRL9          0x0024
+
+#define EMMC_ISO_EN         (0x1 << 16)
+#define RG_EMMC_LHEN_IN         (0x3f << 17)
+
+/* USB 2.0 MISC Control register offset */
+#define REG_USB2_CTRL0          MISC_CTRL7
+/* base on needs #define REG_USB2_CTRL1 MISC_CTRL9 */
+
+/* FEPHY Control register offset */
+#define REG_FEPHY_CTRL0               MISC_CTRL8
+#define REG_FEPHY_CTRL1               MISC_CTRL9
+
+/* -------------------------------------------------------------------- */
+#define IO_CONFIG_REG_BASE      0x12050000
+
+/* -------------------------------------------------------------------- */
+#define UART0_REG_BASE          0x12040000
+#define UART1_REG_BASE          0x12041000
+#define UART2_REG_BASE          0x12042000
+
+/* -------------------------------------------------------------------- */
+#define GPIO0_REG_BASE          0x120B0000
+#define GPIO1_REG_BASE          0x120B1000
+#define GPIO2_REG_BASE          0x120B2000
+#define GPIO3_REG_BASE          0x120B3000
+#define GPIO4_REG_BASE          0x120B4000
+#define GPIO5_REG_BASE          0x120B5000
+#define GPIO6_REG_BASE          0x120B6000
+#define GPIO7_REG_BASE          0x120B7000
+#define GPIO8_REG_BASE          0x120B8000
+#define GPIO9_REG_BASE          0x120B9000
+
+#define FMC_MEM_BASE            0x14000000
+#define FMC_TEXT_ADRS           FMC_MEM_BASE
+#define DDR_MEM_BASE            0x40000000
+#define HW_DEC_INTR              86
+/*-----------------------------------------------------------------------
+ * EMMC / SD
+ * ----------------------------------------------------------------------*/
+/* SDIO0 REG */
+#define SDIO0_BASE_REG          0x10010000
+
+/* EMMC REG */
+#define EMMC_BASE_REG           0x10010000
+
+#define REG_BASE_PERI_CTRL              REG_BASE_SCTL
+#define REG_BASE_IO_CONFIG              IO_CONFIG_REG_BASE
+
+#define MMC_IOMUX_START_ADDR            0xF8
+#define MMC_IOMUX_END_ADDR              0x13C
+#define MMC_IOMUX_CTRL_MASK             (1<<0 | 1<<1)
+#define MMC_IOMUX_CTRL                  (1<<1)
+
+#define SYSCNT_REG_BASE     0x12050000
+#define SYSCNT_ENABLE_REG       0x0
+#define SYSCNT_FREQ_REG         0x20
+#define SYSCNT_FREQ         50000000
+
+#define REG_BASE_SYSCNT SYSCNT_REG_BASE
+#define CNTCR 0x0
+#define CNTFID0 0x20
+
+/* --------------------------------------------------------- */
+#define NUM_0					0
+#define NUM_1					1
+#define NUM_2					2
+#define NUM_3					3
+#define NUM_4					4
+#define NUM_5					5
+#define NUM_6					6
+#define NUM_7					7
+#define NUM_8					8
+#define NUM_9					9
+
+#endif /* End of __CHIP_REGS_H__ */
diff -uraN u-boot-2016.11/arch/arm/include/asm/arch-gk7205v200/boot0.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/arch-gk7205v200/boot0.h
--- u-boot-2016.11/arch/arm/include/asm/arch-gk7205v200/boot0.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/arch-gk7205v200/boot0.h	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,16 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#ifndef __BOOT0_H
+#define __BOOT0_H
+
+#define ARM_SOC_BOOT0_HOOK
+
+/* BOOT0 header information */
+#define VENDOR_BOOT0_HOOK   \
+	__blank_zone_start : \
+	.fill 1024*8,1,0;   \
+	__blank_zone_end :
+
+#include <../mach-goke/boot0_hook.S>
+#endif /* __BOOT0_H */
diff -uraN u-boot-2016.11/arch/arm/include/asm/arch-gk7205v200/mmu.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/arch-gk7205v200/mmu.h
--- u-boot-2016.11/arch/arm/include/asm/arch-gk7205v200/mmu.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/arch-gk7205v200/mmu.h	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,191 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __ARM_ARCH_MMU_H
+#define __ARM_ARCH_MMU_H
+
+#include <linux/types.h>
+#ifdef CONFIG_ARCH_MMU
+/*
+ * Translation Table Base Bit Masks
+ */
+#define ARM_TRANSLATION_TABLE_MASK               0xFFFFC000
+
+/*
+ * Domain Access Control Bit Masks
+ */
+#define arm_access_type_no_access(domain_num)    (0x0 << (domain_num)*2)
+#define arm_access_type_client(domain_num)       (0x1 << (domain_num)*2)
+#define arm_access_type_manager(domain_num)      (0x3 << (domain_num)*2)
+
+
+#define ARM_MMU_FIRST_LEVEL_FAULT_ID 0x0
+
+struct arm_mmu_first_level_fault {
+	unsigned int id: 2;
+	unsigned int sbz: 30;
+};
+
+#define ARM_MMU_FIRST_LEVEL_PAGE_TABLE_ID 0x1
+
+struct arm_mmu_first_level_page_table {
+	unsigned int id: 2;
+	unsigned int sbz0: 1;
+	unsigned int ns: 1;
+	unsigned int sbz1: 1;
+	unsigned int domain: 4;
+	unsigned int imp: 1;
+	unsigned int base_address: 22;
+};
+
+#define ARM_MMU_FIRST_LEVEL_SECTION_ID 0x2
+
+struct arm_mmu_first_level_section {
+	unsigned int id: 2;
+	unsigned int b: 1;
+	unsigned int c: 1;
+	unsigned int xn: 1;
+	unsigned int domain: 4;
+	unsigned int imp: 1;
+	unsigned int ap0: 2;
+	unsigned int tex: 3;
+	unsigned int ap1: 1;
+	unsigned int s: 1;
+	unsigned int ng: 1;
+	unsigned int reserved: 1;
+	unsigned int ns: 1;
+	unsigned int base_address: 12;
+};
+
+struct arm_mmu_first_level_reserved {
+	unsigned int id: 2;
+	unsigned int sbz: 30;
+};
+
+#define ARM_MMU_SECOND_LEVEL_FAULT_ID 0x0
+
+struct arm_mmu_second_level_fault {
+	unsigned int id: 2;
+	unsigned int sbz: 30;
+};
+
+#define ARM_MMU_SECOND_LEVEL_SMALL_ID 0x2
+
+struct arm_mmu_second_level_small {
+	unsigned int id: 2;
+	unsigned int b: 1;
+	unsigned int c: 1;
+	unsigned int ap0: 2;
+	unsigned int tex: 3;
+	unsigned int ap1: 1;
+	unsigned int s: 1;
+	unsigned int ng: 1;
+	unsigned int base_address: 20;
+};
+
+#define ARM_MMU_FIRST_LEVEL_RESERVED_ID 0x3
+
+#define arm_mmu_first_level_descriptor_address(ttb_base, table_index) \
+	(unsigned long *)((unsigned long)(ttb_base) + ((table_index) << 2))
+
+#define ARM_FIRST_LEVEL_PAGE_TABLE_SIZE 0x4000
+
+union arm_mmu_first_level_descriptor {
+	unsigned long word;
+	struct arm_mmu_first_level_fault fault;
+	struct arm_mmu_first_level_page_table page_table;
+	struct arm_mmu_first_level_section section;
+	struct arm_mmu_first_level_reserved reserved;
+};
+
+union arm_mmu_second_level_descriptor {
+	unsigned long word;
+	struct arm_mmu_second_level_fault fault;
+	struct arm_mmu_second_level_small small;
+};
+
+static inline void arm_mmu_section(int ttb_base, int actual_base,
+			int virtual_base, unsigned int tex, unsigned int cacheable,
+			unsigned int bufferable, unsigned int perm,
+			unsigned int shareable)
+{
+	register union arm_mmu_first_level_descriptor desc;
+
+	desc.word = 0;
+	desc.section.id = ARM_MMU_FIRST_LEVEL_SECTION_ID;
+	desc.section.c = cacheable;
+	desc.section.b = bufferable;
+	desc.section.xn = 0;
+	desc.section.domain = 0;
+	desc.section.ap0 = perm;
+	desc.section.tex = tex;
+	desc.section.ap1 = 0;
+	desc.section.s = shareable;
+	desc.section.base_address = actual_base;
+	*arm_mmu_first_level_descriptor_address(ttb_base, (virtual_base))
+		= desc.word;
+}
+
+static inline void x_arm_mmu_section(int abase, int vbase, int size,
+									 unsigned int tex, unsigned int cache, unsigned int buff,
+									 unsigned int access, unsigned int shareable)
+{
+	int i;
+	int j = abase;
+	int k = vbase;
+	unsigned long ttb_base = CONFIG_TTB_ADDR;
+
+	for (i = size; i > 0 ; i--, j++, k++)
+		arm_mmu_section(ttb_base, j, k, tex, cache,
+						buff, access, shareable);
+}
+
+#define ARM_UNCACHEABLE     0
+#define ARM_CACHEABLE       1
+#define ARM_UNBUFFERABLE    0
+#define ARM_BUFFERABLE      1
+
+#define ARM_ACCESS_PERM_NONE_NONE   0
+#define ARM_ACCESS_PERM_RW_NONE     1
+#define ARM_ACCESS_PERM_RW_RO       2
+#define ARM_ACCESS_PERM_RW_RW       3
+
+#define ARM_NOSHAREABLE     0
+#define ARM_SHAREABLE       1
+
+#define ARM_MEMTYPE_STRONGORDER      0
+#define ARM_MEMTYPE_DEVICE           1
+#define ARM_MEMTYPE_NORMAL           2
+#define ARM_MEMTYPE_RESERVED         3
+
+
+#define ARM_CACHETYPE_NOCACHE        0
+#define ARM_CACHETYPE_WRITEBACK      1
+#define ARM_CACHETYPE_WRITETHROUGH   2
+#define ARM_CACHETYPE_WRITEBACK_ONLY 3
+
+
+/*
+ * Initialization for the Domain Access Control Register
+ */
+#define ARM_ACCESS_DACR_DEFAULT      (  \
+	arm_access_type_manager(0)    | \
+	arm_access_type_no_access(1)  | \
+	arm_access_type_no_access(2)  | \
+	arm_access_type_no_access(3)  | \
+	arm_access_type_no_access(4)  | \
+	arm_access_type_no_access(5)  | \
+	arm_access_type_no_access(6)  | \
+	arm_access_type_no_access(7)  | \
+	arm_access_type_no_access(8)  | \
+	arm_access_type_no_access(9)  | \
+	arm_access_type_no_access(10) | \
+	arm_access_type_no_access(11) | \
+	arm_access_type_no_access(12) | \
+	arm_access_type_no_access(13) | \
+	arm_access_type_no_access(14) | \
+	arm_access_type_no_access(15))
+
+#endif
+#endif
diff -uraN u-boot-2016.11/arch/arm/include/asm/arch-gk7205v200/platform.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/arch-gk7205v200/platform.h
--- u-boot-2016.11/arch/arm/include/asm/arch-gk7205v200/platform.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/arch-gk7205v200/platform.h	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,236 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __CHIP_REGS_H__
+#define __CHIP_REGS_H__
+
+
+/* -------------------------------------------------------------------- */
+#define RAM_START_ADRS          0x04010500
+#define STACK_TRAINING          0x0401A000
+
+/* -------------------------------------------------------------------- */
+#define FMC_REG_BASE            0x10000000
+
+/* -------------------------------------------------------------------- */
+#define REG_BASE_SF             0x10040000
+
+/* -------------------------------------------------------------------- */
+#define EMMC_REG_BASE           0x10010000
+#define SDIO1_REG_BASE          0x10020000
+
+/* -------------------------------------------------------------------- */
+#define USB3_CTRL_REG_BASE      0x10030000
+
+/* -------------------------------------------------------------------- */
+#define USB_OHCI_BASE         0x10030000
+
+/* -------------------------------------------------------------------- */
+#define DDRC0_REG_BASE          0x11330000
+
+/* -------------------------------------------------------------------- */
+#define TIMER0_REG_BASE         0x12000000
+#define TIMER1_REG_BASE         0x12000020
+#define TIMER2_REG_BASE         0x12001000
+#define TIMER3_REG_BASE         0x12001020
+
+#define REG_TIMER_RELOAD        0x0
+#define REG_TIMER_VALUE         0x4
+#define REG_TIMER_CONTROL       0x8
+
+#define CFG_TIMER_CLK           3000000
+#define CFG_TIMERBASE           TIMER0_REG_BASE
+
+/* enable timer.32bit, periodic,mask irq, 1 divider. */
+#define CFG_TIMER_CTRL          0xC2
+
+/* -------------------------------------------------------------------- */
+/* Clock and Reset Generator REG */
+/* -------------------------------------------------------------------- */
+#define CRG_REG_BASE            0x12010000
+
+#define REG_CRG80           0x0140
+#define REG_CRG81           0x0144
+#define REG_CRG91           0x016c
+#define REG_CRG110          0x01b8
+
+/* USB 2.0 CRG Control register offset */
+#define REG_USB2_CTRL       REG_CRG80
+
+/* FMC CRG register offset */
+#define REG_FMC_CRG         REG_CRG81
+#define FMC_SRST            (0x1 << 0)
+#define FMC_CLK_ENABLE      (0x1 << 1)
+#define FMC_CLK_SEL_MASK    (0x7 << 2)
+#define FMC_CLK_SEL_SHIFT   0x2
+/* SDR/DDR clock */
+#define FMC_CLK_24M         0x0
+#define FMC_CLK_100M        0x1
+#define FMC_CLK_150M        0x2
+
+#define FMC_CLK_200M        0x3
+
+/* Only DDR clock */
+#define FMC_CLK_300M        0x4
+#define FMC_CLK_360M        0x5
+
+#define fmc_clk_sel(_clk) \
+	(((_clk) << FMC_CLK_SEL_SHIFT) & FMC_CLK_SEL_MASK)
+#define get_fmc_clk_type(_reg) \
+	(((_reg) & FMC_CLK_SEL_MASK) >> FMC_CLK_SEL_SHIFT)
+
+/* Ethernet CRG register offset */
+#define REG_ETH_CRG         REG_CRG91
+#define REG_ETH_MAC_IF      0x8c
+
+/* Uart CRG register offset */
+#define REG_UART_CRG            REG_CRG110
+#define uart_clk_sel(_clk)      (((_clk) & 0x3) << 18)
+#define UART_CLK_SEL_MASK       (0x3 << 18)
+#define UART_CLK_APB            0
+#define UART_CLK_24M            1
+#define UART_CLK_2M         2
+
+/* SDIO0 CRG register offset */
+#define REG_SDIO0_CRG           (CRG_REG_BASE + 0x238)
+
+/* eMMC CRG register offset */
+#define REG_EMMC_CRG            (CRG_REG_BASE + 0x1f4)
+#define mmc_clk_sel(_clk)       (((_clk) & 0x7) << 24)
+#define MMC_CLK_SEL_MASK        (0x7 << 24)
+#define get_mmc_clk_type(_reg)      (((_reg) >> 24) & 0x7)
+
+/* -------------------------------------------------------------------- */
+/* System Control REG */
+/* -------------------------------------------------------------------- */
+#define SYS_CTRL_REG_BASE       0x12020000
+#define REG_BASE_SCTL           SYS_CTRL_REG_BASE
+#define REG_SC_SYSSTAT          0x8c
+#define spi_input_sle(x)        (((x) >> 16) & 0x1)
+
+/* System Control register offset */
+#define REG_SC_CTRL         0x0000
+#define sc_ctrl_timer0_clk_sel(_clk)    (((_clk) & 0x1) << 16)
+#define TIMER0_CLK_SEL_MASK     (0x1 << 16)
+#define TIMER_CLK_3M            0
+#define TIMER_CLK_BUS           1
+#define SC_CTRL_REMAP_CLEAR     (0x1 << 8)
+
+/* System soft reset register offset */
+#define REG_SC_SYSRES           0x0004
+
+/* System Status register offset */
+#define REG_SYSSTAT         0x008c
+/* bit[7]=0: 3-Byte address mode; bit[7]=1: 4-Byte address mode */
+#define get_spi_nor_addr_mode(_reg) (((_reg) >> 7) & 0x1)
+/* bit[6]=0; SPI nor flash; bit[6]=1: SPI nand flash */
+#define get_spi_device_type(_reg)   (((_reg) >> 10) & 0x1)
+/* bit[4]=0 SPI; bit[4]=1: EMMC */
+#define get_sys_boot_mode(_reg)     (((_reg) >> 4) & 0x1)
+#define BOOT_FROM_SPI           0
+#define BOOT_FROM_SPI_NAND      1
+#define BOOT_FROM_NAND          2
+#define BOOT_FROM_EMMC          1
+#define NF_BOOTBW_MASK          (1 << 11)
+
+
+#define REG_SC_GEN5         0x0134
+#define REG_SC_GEN0         0x0138
+#define REG_SC_GEN1         0x013c
+#define REG_SC_GEN2         0x0140
+#define REG_SC_GEN3         0x0144
+#define REG_SC_GEN4         0x0148
+#define REG_SC_GEN9         0x0154
+
+/********** Communication Register and flag used by bootrom *************/
+#define REG_START_FLAG      (SYS_CTRL_REG_BASE + REG_SC_GEN1)
+#define START_MAGIC         0x444f574e
+#define SELF_BOOT_TYPE_USBDEV           0x2  /* debug */
+
+/* -------------------------------------------------------------------- */
+/* Peripheral Control REG */
+/* -------------------------------------------------------------------- */
+#define MISC_REG_BASE           0x12028000
+
+#define MISC_CTRL17                     0x0044
+#define MISC_CTRL18         0x48
+#define MISC_CTRL7          0x001C
+#define MISC_CTRL8          0x0020
+#define MISC_CTRL9          0x0024
+
+#define EMMC_ISO_EN         (0x1 << 16)
+#define RG_EMMC_LHEN_IN         (0x3f << 17)
+
+/* USB 2.0 MISC Control register offset */
+#define REG_USB2_CTRL0          MISC_CTRL7
+/* base on needs #define REG_USB2_CTRL1  MISC_CTRL9 */
+
+/* FEPHY Control register offset */
+#define REG_FEPHY_CTRL0               MISC_CTRL8
+#define REG_FEPHY_CTRL1               MISC_CTRL9
+
+/* -------------------------------------------------------------------- */
+#define IO_CONFIG_REG_BASE      0x12050000
+
+/* -------------------------------------------------------------------- */
+#define UART0_REG_BASE          0x12040000
+#define UART1_REG_BASE          0x12041000
+#define UART2_REG_BASE          0x12042000
+
+/* -------------------------------------------------------------------- */
+#define GPIO0_REG_BASE          0x120B0000
+#define GPIO1_REG_BASE          0x120B1000
+#define GPIO2_REG_BASE          0x120B2000
+#define GPIO3_REG_BASE          0x120B3000
+#define GPIO4_REG_BASE          0x120B4000
+#define GPIO5_REG_BASE          0x120B5000
+#define GPIO6_REG_BASE          0x120B6000
+#define GPIO7_REG_BASE          0x120B7000
+#define GPIO8_REG_BASE          0x120B8000
+#define GPIO9_REG_BASE          0x120B9000
+
+#define FMC_MEM_BASE            0x14000000
+#define FMC_TEXT_ADRS           FMC_MEM_BASE
+#define DDR_MEM_BASE            0x40000000
+#define HW_DEC_INTR              86
+/*-----------------------------------------------------------------------
+ * EMMC / SD
+ * ----------------------------------------------------------------------*/
+/* SDIO0 REG */
+#define SDIO0_BASE_REG          0x10010000
+
+/* EMMC REG */
+#define EMMC_BASE_REG           0x10010000
+
+#define REG_BASE_PERI_CTRL              REG_BASE_SCTL
+#define REG_BASE_IO_CONFIG              IO_CONFIG_REG_BASE
+
+#define MMC_IOMUX_START_ADDR            0xF8
+#define MMC_IOMUX_END_ADDR              0x13C
+#define MMC_IOMUX_CTRL_MASK             (1<<0 | 1<<1)
+#define MMC_IOMUX_CTRL                  (1<<1)
+
+#define SYSCNT_REG_BASE     0x12050000
+#define SYSCNT_ENABLE_REG       0x0
+#define SYSCNT_FREQ_REG         0x20
+#define SYSCNT_FREQ         50000000
+
+#define REG_BASE_SYSCNT SYSCNT_REG_BASE
+#define CNTCR 0x0
+#define CNTFID0 0x20
+
+/* ---------------------------------------------------------*/
+#define NUM_0					0
+#define NUM_1					1
+#define NUM_2					2
+#define NUM_3					3
+#define NUM_4					4
+#define NUM_5					5
+#define NUM_6					6
+#define NUM_7					7
+#define NUM_8					8
+#define NUM_9					9
+
+#endif /* End of __CHIP_REGS_H__ */
+
diff -uraN u-boot-2016.11/arch/arm/include/asm/arch-gk7205v300/boot0.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/arch-gk7205v300/boot0.h
--- u-boot-2016.11/arch/arm/include/asm/arch-gk7205v300/boot0.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/arch-gk7205v300/boot0.h	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,16 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#ifndef __BOOT0_H
+#define __BOOT0_H
+
+#define ARM_SOC_BOOT0_HOOK
+
+/* BOOT0 header information */
+#define VENDOR_BOOT0_HOOK   \
+	__blank_zone_start : \
+	.fill 1024*8,1,0;   \
+	__blank_zone_end :
+
+#include <../mach-goke/boot0_hook.S>
+#endif /* __BOOT0_H */
diff -uraN u-boot-2016.11/arch/arm/include/asm/arch-gk7205v300/mmu.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/arch-gk7205v300/mmu.h
--- u-boot-2016.11/arch/arm/include/asm/arch-gk7205v300/mmu.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/arch-gk7205v300/mmu.h	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,191 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __ARM_ARCH_MMU_H
+#define __ARM_ARCH_MMU_H
+
+#include <linux/types.h>
+#ifdef CONFIG_ARCH_MMU
+/*
+ * Translation Table Base Bit Masks
+ */
+#define ARM_TRANSLATION_TABLE_MASK               0xFFFFC000
+
+/*
+ * Domain Access Control Bit Masks
+ */
+#define arm_access_type_no_access(domain_num)    (0x0 << (domain_num)*2)
+#define arm_access_type_client(domain_num)       (0x1 << (domain_num)*2)
+#define arm_access_type_manager(domain_num)      (0x3 << (domain_num)*2)
+
+
+#define ARM_MMU_FIRST_LEVEL_FAULT_ID 0x0
+
+struct arm_mmu_first_level_fault {
+	unsigned int id: 2;
+	unsigned int sbz: 30;
+};
+
+#define ARM_MMU_FIRST_LEVEL_PAGE_TABLE_ID 0x1
+
+struct arm_mmu_first_level_page_table {
+	unsigned int id: 2;
+	unsigned int sbz0: 1;
+	unsigned int ns: 1;
+	unsigned int sbz1: 1;
+	unsigned int domain: 4;
+	unsigned int imp: 1;
+	unsigned int base_address: 22;
+};
+
+#define ARM_MMU_FIRST_LEVEL_SECTION_ID 0x2
+
+struct arm_mmu_first_level_section {
+	unsigned int id: 2;
+	unsigned int b: 1;
+	unsigned int c: 1;
+	unsigned int xn: 1;
+	unsigned int domain: 4;
+	unsigned int imp: 1;
+	unsigned int ap0: 2;
+	unsigned int tex: 3;
+	unsigned int ap1: 1;
+	unsigned int s: 1;
+	unsigned int ng: 1;
+	unsigned int reserved: 1;
+	unsigned int ns: 1;
+	unsigned int base_address: 12;
+};
+
+struct arm_mmu_first_level_reserved {
+	unsigned int id: 2;
+	unsigned int sbz: 30;
+};
+
+#define ARM_MMU_SECOND_LEVEL_FAULT_ID 0x0
+
+struct arm_mmu_second_level_fault {
+	unsigned int id: 2;
+	unsigned int sbz: 30;
+};
+
+#define ARM_MMU_SECOND_LEVEL_SMALL_ID 0x2
+
+struct arm_mmu_second_level_small {
+	unsigned int id: 2;
+	unsigned int b: 1;
+	unsigned int c: 1;
+	unsigned int ap0: 2;
+	unsigned int tex: 3;
+	unsigned int ap1: 1;
+	unsigned int s: 1;
+	unsigned int ng: 1;
+	unsigned int base_address: 20;
+};
+
+#define ARM_MMU_FIRST_LEVEL_RESERVED_ID 0x3
+
+#define arm_mmu_first_level_descriptor_address(ttb_base, table_index) \
+	(unsigned long *)((unsigned long)(ttb_base) + ((table_index) << 2))
+
+#define ARM_FIRST_LEVEL_PAGE_TABLE_SIZE 0x4000
+
+union arm_mmu_first_level_descriptor {
+	unsigned long word;
+	struct arm_mmu_first_level_fault fault;
+	struct arm_mmu_first_level_page_table page_table;
+	struct arm_mmu_first_level_section section;
+	struct arm_mmu_first_level_reserved reserved;
+};
+
+union arm_mmu_second_level_descriptor {
+	unsigned long word;
+	struct arm_mmu_second_level_fault fault;
+	struct arm_mmu_second_level_small small;
+};
+
+static inline void arm_mmu_section(int ttb_base, int actual_base,
+			int virtual_base, unsigned int tex, unsigned int cacheable,
+			unsigned int bufferable, unsigned int perm,
+			unsigned int shareable)
+{
+	register union arm_mmu_first_level_descriptor desc;
+
+	desc.word = 0;
+	desc.section.id = ARM_MMU_FIRST_LEVEL_SECTION_ID;
+	desc.section.c = cacheable;
+	desc.section.b = bufferable;
+	desc.section.xn = 0;
+	desc.section.domain = 0;
+	desc.section.ap0 = perm;
+	desc.section.tex = tex;
+	desc.section.ap1 = 0;
+	desc.section.s = shareable;
+	desc.section.base_address = actual_base;
+	*arm_mmu_first_level_descriptor_address(ttb_base, (virtual_base))
+		= desc.word;
+}
+
+static inline void x_arm_mmu_section(int abase, int vbase, int size,
+									 unsigned int tex, unsigned int cache, unsigned int buff,
+									 unsigned int access, unsigned int shareable)
+{
+	int i;
+	int j = abase;
+	int k = vbase;
+	unsigned long ttb_base = CONFIG_TTB_ADDR;
+
+	for (i = size; i > 0 ; i--, j++, k++)
+		arm_mmu_section(ttb_base, j, k, tex, cache,
+						buff, access, shareable);
+}
+
+#define ARM_UNCACHEABLE     0
+#define ARM_CACHEABLE       1
+#define ARM_UNBUFFERABLE    0
+#define ARM_BUFFERABLE      1
+
+#define ARM_ACCESS_PERM_NONE_NONE   0
+#define ARM_ACCESS_PERM_RW_NONE     1
+#define ARM_ACCESS_PERM_RW_RO       2
+#define ARM_ACCESS_PERM_RW_RW       3
+
+#define ARM_NOSHAREABLE     0
+#define ARM_SHAREABLE       1
+
+#define ARM_MEMTYPE_STRONGORDER      0
+#define ARM_MEMTYPE_DEVICE           1
+#define ARM_MEMTYPE_NORMAL           2
+#define ARM_MEMTYPE_RESERVED         3
+
+
+#define ARM_CACHETYPE_NOCACHE        0
+#define ARM_CACHETYPE_WRITEBACK      1
+#define ARM_CACHETYPE_WRITETHROUGH   2
+#define ARM_CACHETYPE_WRITEBACK_ONLY 3
+
+
+/*
+ * Initialization for the Domain Access Control Register
+ */
+#define ARM_ACCESS_DACR_DEFAULT      (  \
+	arm_access_type_manager(0)    | \
+	arm_access_type_no_access(1)  | \
+	arm_access_type_no_access(2)  | \
+	arm_access_type_no_access(3)  | \
+	arm_access_type_no_access(4)  | \
+	arm_access_type_no_access(5)  | \
+	arm_access_type_no_access(6)  | \
+	arm_access_type_no_access(7)  | \
+	arm_access_type_no_access(8)  | \
+	arm_access_type_no_access(9)  | \
+	arm_access_type_no_access(10) | \
+	arm_access_type_no_access(11) | \
+	arm_access_type_no_access(12) | \
+	arm_access_type_no_access(13) | \
+	arm_access_type_no_access(14) | \
+	arm_access_type_no_access(15))
+
+#endif
+#endif
diff -uraN u-boot-2016.11/arch/arm/include/asm/arch-gk7205v300/platform.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/arch-gk7205v300/platform.h
--- u-boot-2016.11/arch/arm/include/asm/arch-gk7205v300/platform.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/arch-gk7205v300/platform.h	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,236 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __CHIP_REGS_H__
+#define __CHIP_REGS_H__
+
+
+/* -------------------------------------------------------------------- */
+#define RAM_START_ADRS          0x04010500
+#define STACK_TRAINING          0x0401A000
+
+/* -------------------------------------------------------------------- */
+#define FMC_REG_BASE            0x10000000
+
+/* -------------------------------------------------------------------- */
+#define REG_BASE_SF             0x10040000
+
+/* -------------------------------------------------------------------- */
+#define EMMC_REG_BASE           0x10010000
+#define SDIO1_REG_BASE          0x10020000
+
+/* -------------------------------------------------------------------- */
+#define USB3_CTRL_REG_BASE      0x10030000
+
+/* -------------------------------------------------------------------- */
+#define USB_OHCI_BASE         0x10030000
+
+/* -------------------------------------------------------------------- */
+#define DDRC0_REG_BASE          0x11330000
+
+/* -------------------------------------------------------------------- */
+#define TIMER0_REG_BASE         0x12000000
+#define TIMER1_REG_BASE         0x12000020
+#define TIMER2_REG_BASE         0x12001000
+#define TIMER3_REG_BASE         0x12001020
+
+#define REG_TIMER_RELOAD        0x0
+#define REG_TIMER_VALUE         0x4
+#define REG_TIMER_CONTROL       0x8
+
+#define CFG_TIMER_CLK           3000000
+#define CFG_TIMERBASE           TIMER0_REG_BASE
+
+/* enable timer.32bit, periodic,mask irq, 1 divider. */
+#define CFG_TIMER_CTRL          0xC2
+
+/* -------------------------------------------------------------------- */
+/* Clock and Reset Generator REG */
+/* -------------------------------------------------------------------- */
+#define CRG_REG_BASE            0x12010000
+
+#define REG_CRG80           0x0140
+#define REG_CRG81           0x0144
+#define REG_CRG91           0x016c
+#define REG_CRG110          0x01b8
+
+/* USB 2.0 CRG Control register offset */
+#define REG_USB2_CTRL       REG_CRG80
+
+/* FMC CRG register offset */
+#define REG_FMC_CRG         REG_CRG81
+#define FMC_SRST            (0x1 << 0)
+#define FMC_CLK_ENABLE      (0x1 << 1)
+#define FMC_CLK_SEL_MASK    (0x7 << 2)
+#define FMC_CLK_SEL_SHIFT   0x2
+/* SDR/DDR clock */
+#define FMC_CLK_24M         0x0
+#define FMC_CLK_100M        0x1
+#define FMC_CLK_150M        0x2
+
+#define FMC_CLK_200M        0x3
+
+/* Only DDR clock */
+#define FMC_CLK_300M        0x4
+#define FMC_CLK_360M        0x5
+
+#define fmc_clk_sel(_clk) \
+	(((_clk) << FMC_CLK_SEL_SHIFT) & FMC_CLK_SEL_MASK)
+#define get_fmc_clk_type(_reg) \
+	(((_reg) & FMC_CLK_SEL_MASK) >> FMC_CLK_SEL_SHIFT)
+
+/* Ethernet CRG register offset */
+#define REG_ETH_CRG         REG_CRG91
+#define REG_ETH_MAC_IF      0x8c
+
+/* Uart CRG register offset */
+#define REG_UART_CRG            REG_CRG110
+#define uart_clk_sel(_clk)      (((_clk) & 0x3) << 18)
+#define UART_CLK_SEL_MASK       (0x3 << 18)
+#define UART_CLK_APB            0
+#define UART_CLK_24M            1
+#define UART_CLK_2M         2
+
+/* SDIO0 CRG register offset */
+#define REG_SDIO0_CRG           (CRG_REG_BASE + 0x238)
+
+/* eMMC CRG register offset */
+#define REG_EMMC_CRG            (CRG_REG_BASE + 0x1f4)
+#define mmc_clk_sel(_clk)       (((_clk) & 0x7) << 24)
+#define MMC_CLK_SEL_MASK        (0x7 << 24)
+#define get_mmc_clk_type(_reg)      (((_reg) >> 24) & 0x7)
+
+/* -------------------------------------------------------------------- */
+/* System Control REG */
+/* -------------------------------------------------------------------- */
+#define SYS_CTRL_REG_BASE       0x12020000
+#define REG_BASE_SCTL           SYS_CTRL_REG_BASE
+#define REG_SC_SYSSTAT          0x8c
+#define spi_input_sle(x)        (((x) >> 16) & 0x1)
+
+/* System Control register offset */
+#define REG_SC_CTRL         0x0000
+#define sc_ctrl_timer0_clk_sel(_clk)    (((_clk) & 0x1) << 16)
+#define TIMER0_CLK_SEL_MASK     (0x1 << 16)
+#define TIMER_CLK_3M            0
+#define TIMER_CLK_BUS           1
+#define SC_CTRL_REMAP_CLEAR     (0x1 << 8)
+
+/* System soft reset register offset */
+#define REG_SC_SYSRES           0x0004
+
+/* System Status register offset */
+#define REG_SYSSTAT         0x008c
+/* bit[7]=0: 3-Byte address mode; bit[7]=1: 4-Byte address mode */
+#define get_spi_nor_addr_mode(_reg) (((_reg) >> 7) & 0x1)
+/* bit[6]=0; SPI nor flash; bit[6]=1: SPI nand flash */
+#define get_spi_device_type(_reg)   (((_reg) >> 10) & 0x1)
+/* bit[4]=0  SPI; bit[4]=1: EMMC */
+#define get_sys_boot_mode(_reg)     (((_reg) >> 4) & 0x1)
+#define BOOT_FROM_SPI           0
+#define BOOT_FROM_SPI_NAND      1
+#define BOOT_FROM_NAND          2
+#define BOOT_FROM_EMMC          1
+#define NF_BOOTBW_MASK          (1 << 11)
+
+
+#define REG_SC_GEN5         0x0134
+#define REG_SC_GEN0         0x0138
+#define REG_SC_GEN1         0x013c
+#define REG_SC_GEN2         0x0140
+#define REG_SC_GEN3         0x0144
+#define REG_SC_GEN4         0x0148
+#define REG_SC_GEN9         0x0154
+
+/********** Communication Register and flag used by bootrom *************/
+#define REG_START_FLAG      (SYS_CTRL_REG_BASE + REG_SC_GEN1)
+#define START_MAGIC         0x444f574e
+#define SELF_BOOT_TYPE_USBDEV           0x2  /* debug */
+
+/* -------------------------------------------------------------------- */
+/* Peripheral Control REG */
+/* -------------------------------------------------------------------- */
+#define MISC_REG_BASE           0x12028000
+
+#define MISC_CTRL17                     0x0044
+#define MISC_CTRL18         0x48
+#define MISC_CTRL7          0x001C
+#define MISC_CTRL8          0x0020
+#define MISC_CTRL9          0x0024
+
+#define EMMC_ISO_EN         (0x1 << 16)
+#define RG_EMMC_LHEN_IN         (0x3f << 17)
+
+/* USB 2.0 MISC Control register offset */
+#define REG_USB2_CTRL0          MISC_CTRL7
+/* base on needs #define REG_USB2_CTRL1 MISC_CTRL9 */
+
+/* FEPHY Control register offset */
+#define REG_FEPHY_CTRL0               MISC_CTRL8
+#define REG_FEPHY_CTRL1               MISC_CTRL9
+
+/* -------------------------------------------------------------------- */
+#define IO_CONFIG_REG_BASE      0x12050000
+
+/* -------------------------------------------------------------------- */
+#define UART0_REG_BASE          0x12040000
+#define UART1_REG_BASE          0x12041000
+#define UART2_REG_BASE          0x12042000
+
+/* -------------------------------------------------------------------- */
+#define GPIO0_REG_BASE          0x120B0000
+#define GPIO1_REG_BASE          0x120B1000
+#define GPIO2_REG_BASE          0x120B2000
+#define GPIO3_REG_BASE          0x120B3000
+#define GPIO4_REG_BASE          0x120B4000
+#define GPIO5_REG_BASE          0x120B5000
+#define GPIO6_REG_BASE          0x120B6000
+#define GPIO7_REG_BASE          0x120B7000
+#define GPIO8_REG_BASE          0x120B8000
+#define GPIO9_REG_BASE          0x120B9000
+
+#define FMC_MEM_BASE            0x14000000
+#define FMC_TEXT_ADRS           FMC_MEM_BASE
+#define DDR_MEM_BASE            0x40000000
+#define HW_DEC_INTR             86
+/*-----------------------------------------------------------------------
+ * EMMC / SD
+ * ----------------------------------------------------------------------*/
+/* SDIO0 REG */
+#define SDIO0_BASE_REG          0x10010000
+
+/* EMMC REG */
+#define EMMC_BASE_REG           0x10010000
+
+#define REG_BASE_PERI_CTRL              REG_BASE_SCTL
+#define REG_BASE_IO_CONFIG              IO_CONFIG_REG_BASE
+
+#define MMC_IOMUX_START_ADDR            0xF8
+#define MMC_IOMUX_END_ADDR              0x13C
+#define MMC_IOMUX_CTRL_MASK             (1<<0 | 1<<1)
+#define MMC_IOMUX_CTRL                  (1<<1)
+
+#define SYSCNT_REG_BASE     0x12050000
+#define SYSCNT_ENABLE_REG       0x0
+#define SYSCNT_FREQ_REG         0x20
+#define SYSCNT_FREQ         50000000
+
+#define REG_BASE_SYSCNT SYSCNT_REG_BASE
+#define CNTCR 0x0
+#define CNTFID0 0x20
+
+/* --------------------------------------------------------- */
+#define NUM_0					0
+#define NUM_1					1
+#define NUM_2					2
+#define NUM_3					3
+#define NUM_4					4
+#define NUM_5					5
+#define NUM_6					6
+#define NUM_7					7
+#define NUM_8					8
+#define NUM_9					9
+
+#endif /* End of __CHIP_REGS_H__ */
+
diff -uraN u-boot-2016.11/arch/arm/include/asm/arch-gk7605v100/boot0.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/arch-gk7605v100/boot0.h
--- u-boot-2016.11/arch/arm/include/asm/arch-gk7605v100/boot0.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/arch-gk7605v100/boot0.h	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,16 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#ifndef __BOOT0_H
+#define __BOOT0_H
+
+#define ARM_SOC_BOOT0_HOOK
+
+/* BOOT0 header information */
+#define VENDOR_BOOT0_HOOK   \
+	__blank_zone_start : \
+	.fill 1024*8,1,0;   \
+	__blank_zone_end :
+
+#include <../mach-goke/boot0_hook.S>
+#endif /* __BOOT0_H */
diff -uraN u-boot-2016.11/arch/arm/include/asm/arch-gk7605v100/mmu.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/arch-gk7605v100/mmu.h
--- u-boot-2016.11/arch/arm/include/asm/arch-gk7605v100/mmu.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/arch-gk7605v100/mmu.h	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,191 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __ARM_ARCH_MMU_H
+#define __ARM_ARCH_MMU_H
+
+#include <linux/types.h>
+#ifdef CONFIG_ARCH_MMU
+/*
+ * Translation Table Base Bit Masks
+ */
+#define ARM_TRANSLATION_TABLE_MASK               0xFFFFC000
+
+/*
+ * Domain Access Control Bit Masks
+ */
+#define arm_access_type_no_access(domain_num)    (0x0 << (domain_num)*2)
+#define arm_access_type_client(domain_num)       (0x1 << (domain_num)*2)
+#define arm_access_type_manager(domain_num)      (0x3 << (domain_num)*2)
+
+
+#define ARM_MMU_FIRST_LEVEL_FAULT_ID 0x0
+
+struct arm_mmu_first_level_fault {
+	unsigned int id: 2;
+	unsigned int sbz: 30;
+};
+
+#define ARM_MMU_FIRST_LEVEL_PAGE_TABLE_ID 0x1
+
+struct arm_mmu_first_level_page_table {
+	unsigned int id: 2;
+	unsigned int sbz0: 1;
+	unsigned int ns: 1;
+	unsigned int sbz1: 1;
+	unsigned int domain: 4;
+	unsigned int imp: 1;
+	unsigned int base_address: 22;
+};
+
+#define ARM_MMU_FIRST_LEVEL_SECTION_ID 0x2
+
+struct arm_mmu_first_level_section {
+	unsigned int id: 2;
+	unsigned int b: 1;
+	unsigned int c: 1;
+	unsigned int xn: 1;
+	unsigned int domain: 4;
+	unsigned int imp: 1;
+	unsigned int ap0: 2;
+	unsigned int tex: 3;
+	unsigned int ap1: 1;
+	unsigned int s: 1;
+	unsigned int ng: 1;
+	unsigned int reserved: 1;
+	unsigned int ns: 1;
+	unsigned int base_address: 12;
+};
+
+struct arm_mmu_first_level_reserved {
+	unsigned int id: 2;
+	unsigned int sbz: 30;
+};
+
+#define ARM_MMU_SECOND_LEVEL_FAULT_ID 0x0
+
+struct arm_mmu_second_level_fault {
+	unsigned int id: 2;
+	unsigned int sbz: 30;
+};
+
+#define ARM_MMU_SECOND_LEVEL_SMALL_ID 0x2
+
+struct arm_mmu_second_level_small {
+	unsigned int id: 2;
+	unsigned int b: 1;
+	unsigned int c: 1;
+	unsigned int ap0: 2;
+	unsigned int tex: 3;
+	unsigned int ap1: 1;
+	unsigned int s: 1;
+	unsigned int ng: 1;
+	unsigned int base_address: 20;
+};
+
+#define ARM_MMU_FIRST_LEVEL_RESERVED_ID 0x3
+
+#define arm_mmu_first_level_descriptor_address(ttb_base, table_index) \
+	(unsigned long *)((unsigned long)(ttb_base) + ((table_index) << 2))
+
+#define ARM_FIRST_LEVEL_PAGE_TABLE_SIZE 0x4000
+
+union arm_mmu_first_level_descriptor {
+	unsigned long word;
+	struct arm_mmu_first_level_fault fault;
+	struct arm_mmu_first_level_page_table page_table;
+	struct arm_mmu_first_level_section section;
+	struct arm_mmu_first_level_reserved reserved;
+};
+
+union arm_mmu_second_level_descriptor {
+	unsigned long word;
+	struct arm_mmu_second_level_fault fault;
+	struct arm_mmu_second_level_small small;
+};
+
+static inline void arm_mmu_section(int ttb_base, int actual_base,
+			int virtual_base, unsigned int tex, unsigned int cacheable,
+			unsigned int bufferable, unsigned int perm,
+			unsigned int shareable)
+{
+	register union arm_mmu_first_level_descriptor desc;
+
+	desc.word = 0;
+	desc.section.id = ARM_MMU_FIRST_LEVEL_SECTION_ID;
+	desc.section.c = cacheable;
+	desc.section.b = bufferable;
+	desc.section.xn = 0;
+	desc.section.domain = 0;
+	desc.section.ap0 = perm;
+	desc.section.tex = tex;
+	desc.section.ap1 = 0;
+	desc.section.s = shareable;
+	desc.section.base_address = actual_base;
+	*arm_mmu_first_level_descriptor_address(ttb_base, (virtual_base))
+		= desc.word;
+}
+
+static inline void x_arm_mmu_section(int abase, int vbase, int size,
+									 unsigned int tex, unsigned int cache, unsigned int buff,
+									 unsigned int access, unsigned int shareable)
+{
+	int i;
+	int j = abase;
+	int k = vbase;
+	unsigned long ttb_base = CONFIG_TTB_ADDR;
+
+	for (i = size; i > 0 ; i--, j++, k++)
+		arm_mmu_section(ttb_base, j, k, tex, cache,
+						buff, access, shareable);
+}
+
+#define ARM_UNCACHEABLE     0
+#define ARM_CACHEABLE       1
+#define ARM_UNBUFFERABLE    0
+#define ARM_BUFFERABLE      1
+
+#define ARM_ACCESS_PERM_NONE_NONE   0
+#define ARM_ACCESS_PERM_RW_NONE     1
+#define ARM_ACCESS_PERM_RW_RO       2
+#define ARM_ACCESS_PERM_RW_RW       3
+
+#define ARM_NOSHAREABLE     0
+#define ARM_SHAREABLE       1
+
+#define ARM_MEMTYPE_STRONGORDER      0
+#define ARM_MEMTYPE_DEVICE           1
+#define ARM_MEMTYPE_NORMAL           2
+#define ARM_MEMTYPE_RESERVED         3
+
+
+#define ARM_CACHETYPE_NOCACHE        0
+#define ARM_CACHETYPE_WRITEBACK      1
+#define ARM_CACHETYPE_WRITETHROUGH   2
+#define ARM_CACHETYPE_WRITEBACK_ONLY 3
+
+
+/*
+ * Initialization for the Domain Access Control Register
+ */
+#define ARM_ACCESS_DACR_DEFAULT      (  \
+	arm_access_type_manager(0)    | \
+	arm_access_type_no_access(1)  | \
+	arm_access_type_no_access(2)  | \
+	arm_access_type_no_access(3)  | \
+	arm_access_type_no_access(4)  | \
+	arm_access_type_no_access(5)  | \
+	arm_access_type_no_access(6)  | \
+	arm_access_type_no_access(7)  | \
+	arm_access_type_no_access(8)  | \
+	arm_access_type_no_access(9)  | \
+	arm_access_type_no_access(10) | \
+	arm_access_type_no_access(11) | \
+	arm_access_type_no_access(12) | \
+	arm_access_type_no_access(13) | \
+	arm_access_type_no_access(14) | \
+	arm_access_type_no_access(15))
+
+#endif
+#endif
diff -uraN u-boot-2016.11/arch/arm/include/asm/arch-gk7605v100/platform.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/arch-gk7605v100/platform.h
--- u-boot-2016.11/arch/arm/include/asm/arch-gk7605v100/platform.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/arch-gk7605v100/platform.h	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,235 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __CHIP_REGS_H__
+#define __CHIP_REGS_H__
+
+
+/* -------------------------------------------------------------------- */
+#define RAM_START_ADRS          0x04010500
+#define STACK_TRAINING          0x0401A000
+
+/* -------------------------------------------------------------------- */
+#define FMC_REG_BASE            0x10000000
+
+/* -------------------------------------------------------------------- */
+#define REG_BASE_SF             0x10040000
+
+/* -------------------------------------------------------------------- */
+#define EMMC_REG_BASE           0x10010000
+#define SDIO1_REG_BASE          0x10020000
+
+/* -------------------------------------------------------------------- */
+#define USB3_CTRL_REG_BASE      0x10030000
+
+/* -------------------------------------------------------------------- */
+#define USB_OHCI_BASE         0x10030000
+
+/* -------------------------------------------------------------------- */
+#define DDRC0_REG_BASE          0x11330000
+
+/* -------------------------------------------------------------------- */
+#define TIMER0_REG_BASE         0x12000000
+#define TIMER1_REG_BASE         0x12000020
+#define TIMER2_REG_BASE         0x12001000
+#define TIMER3_REG_BASE         0x12001020
+
+#define REG_TIMER_RELOAD        0x0
+#define REG_TIMER_VALUE         0x4
+#define REG_TIMER_CONTROL       0x8
+
+#define CFG_TIMER_CLK           3000000
+#define CFG_TIMERBASE           TIMER0_REG_BASE
+
+/* enable timer.32bit, periodic,mask irq, 1 divider. */
+#define CFG_TIMER_CTRL          0xC2
+
+/* -------------------------------------------------------------------- */
+/* Clock and Reset Generator REG */
+/* -------------------------------------------------------------------- */
+#define CRG_REG_BASE            0x12010000
+
+#define REG_CRG80           0x0140
+#define REG_CRG81           0x0144
+#define REG_CRG91           0x016c
+#define REG_CRG110          0x01b8
+
+/* USB 2.0 CRG Control register offset */
+#define REG_USB2_CTRL       REG_CRG80
+
+/* FMC CRG register offset */
+#define REG_FMC_CRG         REG_CRG81
+#define FMC_SRST            (0x1 << 0)
+#define FMC_CLK_ENABLE      (0x1 << 1)
+#define FMC_CLK_SEL_MASK    (0x7 << 2)
+#define FMC_CLK_SEL_SHIFT   0x2
+/* SDR/DDR clock */
+#define FMC_CLK_24M         0x0
+#define FMC_CLK_100M        0x1
+#define FMC_CLK_150M        0x2
+
+#define FMC_CLK_200M        0x3
+
+/* Only DDR clock */
+#define FMC_CLK_300M        0x4
+#define FMC_CLK_360M        0x5
+
+#define fmc_clk_sel(_clk) \
+	(((_clk) << FMC_CLK_SEL_SHIFT) & FMC_CLK_SEL_MASK)
+#define get_fmc_clk_type(_reg) \
+	(((_reg) & FMC_CLK_SEL_MASK) >> FMC_CLK_SEL_SHIFT)
+
+/* Ethernet CRG register offset */
+#define REG_ETH_CRG         REG_CRG91
+#define REG_ETH_MAC_IF      0x8c
+
+/* Uart CRG register offset */
+#define REG_UART_CRG            REG_CRG110
+#define uart_clk_sel(_clk)      (((_clk) & 0x3) << 18)
+#define UART_CLK_SEL_MASK       (0x3 << 18)
+#define UART_CLK_APB            0
+#define UART_CLK_24M            1
+#define UART_CLK_2M         2
+
+/* SDIO0 CRG register offset */
+#define REG_SDIO0_CRG           (CRG_REG_BASE + 0x238)
+
+/* eMMC CRG register offset */
+#define REG_EMMC_CRG            (CRG_REG_BASE + 0x1f4)
+#define mmc_clk_sel(_clk)       (((_clk) & 0x7) << 24)
+#define MMC_CLK_SEL_MASK        (0x7 << 24)
+#define get_mmc_clk_type(_reg)      (((_reg) >> 24) & 0x7)
+
+/* -------------------------------------------------------------------- */
+/* System Control REG */
+/* -------------------------------------------------------------------- */
+#define SYS_CTRL_REG_BASE       0x12020000
+#define REG_BASE_SCTL           SYS_CTRL_REG_BASE
+#define REG_SC_SYSSTAT          0x8c
+#define spi_input_sle(x)        (((x) >> 16) & 0x1)
+
+/* System Control register offset */
+#define REG_SC_CTRL         0x0000
+#define sc_ctrl_timer0_clk_sel(_clk)    (((_clk) & 0x1) << 16)
+#define TIMER0_CLK_SEL_MASK     (0x1 << 16)
+#define TIMER_CLK_3M            0
+#define TIMER_CLK_BUS           1
+#define SC_CTRL_REMAP_CLEAR     (0x1 << 8)
+
+/* System soft reset register offset */
+#define REG_SC_SYSRES           0x0004
+
+/* System Status register offset */
+#define REG_SYSSTAT         0x008c
+/* bit[7]=0: 3-Byte address mode; bit[7]=1: 4-Byte address mode */
+#define get_spi_nor_addr_mode(_reg) (((_reg) >> 7) & 0x1)
+/* bit[6]=0; SPI nor flash; bit[6]=1: SPI nand flash */
+#define get_spi_device_type(_reg)   (((_reg) >> 10) & 0x1)
+/* bit[4]=0  SPI; bit[4]=1: EMMC */
+#define get_sys_boot_mode(_reg)     (((_reg) >> 4) & 0x1)
+#define BOOT_FROM_SPI           0
+#define BOOT_FROM_SPI_NAND      1
+#define BOOT_FROM_NAND          2
+#define BOOT_FROM_EMMC          1
+#define NF_BOOTBW_MASK          (1 << 11)
+
+
+#define REG_SC_GEN5         0x0134
+#define REG_SC_GEN0         0x0138
+#define REG_SC_GEN1         0x013c
+#define REG_SC_GEN2         0x0140
+#define REG_SC_GEN3         0x0144
+#define REG_SC_GEN4         0x0148
+#define REG_SC_GEN9         0x0154
+
+/********** Communication Register and flag used by bootrom *************/
+#define REG_START_FLAG      (SYS_CTRL_REG_BASE + REG_SC_GEN1)
+#define START_MAGIC         0x444f574e
+#define SELF_BOOT_TYPE_USBDEV           0x2  /* debug */
+
+/* -------------------------------------------------------------------- */
+/* Peripheral Control REG */
+/* -------------------------------------------------------------------- */
+#define MISC_REG_BASE           0x12028000
+
+#define MISC_CTRL17                     0x0044
+#define MISC_CTRL18         0x48
+#define MISC_CTRL7          0x001C
+#define MISC_CTRL8          0x0020
+#define MISC_CTRL9          0x0024
+
+#define EMMC_ISO_EN         (0x1 << 16)
+#define RG_EMMC_LHEN_IN         (0x3f << 17)
+
+/* USB 2.0 MISC Control register offset */
+#define REG_USB2_CTRL0          MISC_CTRL7
+/* base on needs #define REG_USB2_CTRL1 MISC_CTRL9 */
+
+/* FEPHY Control register offset */
+#define REG_FEPHY_CTRL0               MISC_CTRL8
+#define REG_FEPHY_CTRL1               MISC_CTRL9
+
+/* -------------------------------------------------------------------- */
+#define IO_CONFIG_REG_BASE      0x12050000
+
+/* -------------------------------------------------------------------- */
+#define UART0_REG_BASE          0x12040000
+#define UART1_REG_BASE          0x12041000
+#define UART2_REG_BASE          0x12042000
+
+/* -------------------------------------------------------------------- */
+#define GPIO0_REG_BASE          0x120B0000
+#define GPIO1_REG_BASE          0x120B1000
+#define GPIO2_REG_BASE          0x120B2000
+#define GPIO3_REG_BASE          0x120B3000
+#define GPIO4_REG_BASE          0x120B4000
+#define GPIO5_REG_BASE          0x120B5000
+#define GPIO6_REG_BASE          0x120B6000
+#define GPIO7_REG_BASE          0x120B7000
+#define GPIO8_REG_BASE          0x120B8000
+#define GPIO9_REG_BASE          0x120B9000
+
+#define FMC_MEM_BASE            0x14000000
+#define FMC_TEXT_ADRS           FMC_MEM_BASE
+#define DDR_MEM_BASE            0x40000000
+#define HW_DEC_INTR              86
+/*-----------------------------------------------------------------------
+ * EMMC / SD
+ * ----------------------------------------------------------------------*/
+/* SDIO0 REG */
+#define SDIO0_BASE_REG          0x10010000
+
+/* EMMC REG */
+#define EMMC_BASE_REG           0x10010000
+
+#define REG_BASE_PERI_CTRL              REG_BASE_SCTL
+#define REG_BASE_IO_CONFIG              IO_CONFIG_REG_BASE
+
+#define MMC_IOMUX_START_ADDR            0xF8
+#define MMC_IOMUX_END_ADDR              0x13C
+#define MMC_IOMUX_CTRL_MASK             (1<<0 | 1<<1)
+#define MMC_IOMUX_CTRL                  (1<<1)
+
+#define SYSCNT_REG_BASE     0x12050000
+#define SYSCNT_ENABLE_REG       0x0
+#define SYSCNT_FREQ_REG         0x20
+#define SYSCNT_FREQ         50000000
+
+#define REG_BASE_SYSCNT SYSCNT_REG_BASE
+#define CNTCR 0x0
+#define CNTFID0 0x20
+
+/* --------------------------------------------------------- */
+#define NUM_0					0
+#define NUM_1					1
+#define NUM_2					2
+#define NUM_3					3
+#define NUM_4					4
+#define NUM_5					5
+#define NUM_6					6
+#define NUM_7					7
+#define NUM_8					8
+#define NUM_9					9
+
+#endif /* End of __CHIP_REGS_H__ */
diff -uraN u-boot-2016.11/arch/arm/include/asm/config.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/config.h
--- u-boot-2016.11/arch/arm/include/asm/config.h	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/config.h	2021-06-07 13:01:31.000000000 +0300
@@ -6,7 +6,9 @@
 
 #ifndef _ASM_CONFIG_H_
 #define _ASM_CONFIG_H_
+#include <generated/autoconf.h>
 
+#ifndef CONFIG_MINI_BOOT
 #define CONFIG_LMB
 #define CONFIG_SYS_BOOT_RAMDISK_HIGH
 
@@ -21,5 +23,6 @@
 	defined(CONFIG_FSL_LAYERSCAPE)
 #include <asm/arch/config.h>
 #endif
+#endif
 
 #endif
diff -uraN u-boot-2016.11/arch/arm/include/asm/mach-types.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/mach-types.h
--- u-boot-2016.11/arch/arm/include/asm/mach-types.h	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/include/asm/mach-types.h	2021-06-07 13:01:31.000000000 +0300
@@ -1107,6 +1107,10 @@
 #define MACH_TYPE_COLIBRI_T30          4493
 #define MACH_TYPE_APALIS_T30           4513
 #define MACH_TYPE_OMAPL138_LCDK        2495
+#define MACH_TYPE_GK7202V300	       8000
+#define MACH_TYPE_GK7205V200           8000
+#define MACH_TYPE_GK7205V300           8000
+#define MACH_TYPE_GK7605V100           8000
 
 #ifdef CONFIG_ARCH_EBSA110
 # ifdef machine_arch_type
diff -uraN u-boot-2016.11/arch/arm/Kconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/Kconfig
--- u-boot-2016.11/arch/arm/Kconfig	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/Kconfig	2021-06-07 13:01:31.000000000 +0300
@@ -13,6 +13,10 @@
 	bool
 	default y if ARM64
 
+config MINI_BOOT
+	bool "Enable goke minit uboot"
+	default n
+
 config HAS_VBAR
 	bool
 
@@ -47,7 +51,7 @@
 config CPU_V7
 	bool
 	select HAS_VBAR
-	select HAS_THUMB2
+	select HAS_THUMB2 if !MINI_BOOT
 	select SYS_CACHE_SHIFT_6
 
 config CPU_V7M
@@ -711,6 +715,38 @@
 	  Support for HiKey 96boards platform. It features a HI6220
 	  SoC, with 8xA53 CPU, mali450 gpu, and 1GB RAM.
 
+config TARGET_GK7205V200
+	bool "Support GK7205V200"
+	select CPU_V7
+	select DM if !MINI_BOOT
+	select CPU_V7_HAS_NONSEC if !MINI_BOOT
+	help
+	Support for Goke GK7205V200 platform.
+
+config TARGET_GK7202V300
+	bool "Support GK7202V300"
+	select CPU_V7
+	select DM if !MINI_BOOT
+	select CPU_V7_HAS_NONSEC if !MINI_BOOT
+	help
+	Support for Goke GK7202V300 platform.
+
+config TARGET_GK7605V100
+	bool "Support GK7605V100"
+	select CPU_V7
+	select DM
+	select CPU_V7_HAS_NONSEC
+	help
+	Support for Goke GK7605V100 platform.
+
+config TARGET_GK7205V300
+	bool "Support GK7205V300"
+	select CPU_V7
+	select DM
+	select CPU_V7_HAS_NONSEC
+	help
+	Support for Goke GK7205V300 platform.
+
 config TARGET_LS1012AQDS
 	bool "Support ls1012aqds"
 	select ARCH_LS1012A
@@ -984,6 +1020,10 @@
 source "board/gumstix/pepper/Kconfig"
 source "board/h2200/Kconfig"
 source "board/hisilicon/hikey/Kconfig"
+source "board/goke/gk7205v200/Kconfig"
+source "board/goke/gk7205v300/Kconfig"
+source "board/goke/gk7202v300/Kconfig"
+source "board/goke/gk7605v100/Kconfig"
 source "board/imx31_phycore/Kconfig"
 source "board/isee/igep0033/Kconfig"
 source "board/mpl/vcma9/Kconfig"
diff -uraN u-boot-2016.11/arch/arm/lib/interrupts.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/lib/interrupts.c
--- u-boot-2016.11/arch/arm/lib/interrupts.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/lib/interrupts.c	2021-06-07 13:01:31.000000000 +0300
@@ -118,12 +118,15 @@
 
 void bad_mode (void)
 {
+#ifndef CONFIG_MINI_BOOT
 	panic ("Resetting CPU ...\n");
 	reset_cpu (0);
+#endif
 }
 
 void show_regs (struct pt_regs *regs)
 {
+#ifndef CONFIG_MINI_BOOT
 	unsigned long __maybe_unused flags;
 	const char __maybe_unused *processor_modes[] = {
 	"USER_26",	"FIQ_26",	"IRQ_26",	"SVC_26",
@@ -162,62 +165,77 @@
 		fast_interrupts_enabled (regs) ? "on" : "off",
 		processor_modes[processor_mode (regs)],
 		thumb_mode (regs) ? " (T)" : "");
+#endif
 }
 
 void do_undefined_instruction (struct pt_regs *pt_regs)
 {
+#ifndef CONFIG_MINI_BOOT
 	efi_restore_gd();
 	printf ("undefined instruction\n");
 	show_regs (pt_regs);
 	bad_mode ();
+#endif
 }
 
 void do_software_interrupt (struct pt_regs *pt_regs)
 {
+#ifndef CONFIG_MINI_BOOT
 	efi_restore_gd();
 	printf ("software interrupt\n");
 	show_regs (pt_regs);
 	bad_mode ();
+#endif
 }
 
 void do_prefetch_abort (struct pt_regs *pt_regs)
 {
+#ifndef CONFIG_MINI_BOOT
 	efi_restore_gd();
 	printf ("prefetch abort\n");
 	show_regs (pt_regs);
 	bad_mode ();
+#endif
 }
 
 void do_data_abort (struct pt_regs *pt_regs)
 {
+#ifndef CONFIG_MINI_BOOT
 	efi_restore_gd();
 	printf ("data abort\n");
 	show_regs (pt_regs);
 	bad_mode ();
+#endif
 }
 
 void do_not_used (struct pt_regs *pt_regs)
 {
+#ifndef CONFIG_MINI_BOOT
 	efi_restore_gd();
 	printf ("not used\n");
 	show_regs (pt_regs);
 	bad_mode ();
+#endif
 }
 
 void do_fiq (struct pt_regs *pt_regs)
 {
+#ifndef CONFIG_MINI_BOOT
 	efi_restore_gd();
 	printf ("fast interrupt request\n");
 	show_regs (pt_regs);
 	bad_mode ();
+#endif
 }
 
 #ifndef CONFIG_USE_IRQ
 void do_irq (struct pt_regs *pt_regs)
 {
+#ifndef CONFIG_MINI_BOOT
 	efi_restore_gd();
 	printf ("interrupt request\n");
 	show_regs (pt_regs);
 	bad_mode ();
+#endif
 }
 #endif
diff -uraN u-boot-2016.11/arch/arm/lib/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/lib/Makefile
--- u-boot-2016.11/arch/arm/lib/Makefile	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/lib/Makefile	2021-06-07 13:01:31.000000000 +0300
@@ -53,6 +53,8 @@
 obj-y	+= reset.o
 endif
 
+obj-y += shutdown.o
+
 obj-y	+= cache.o
 ifndef CONFIG_ARM64
 obj-y	+= cache-cp15.o
diff -uraN u-boot-2016.11/arch/arm/lib/relocate.S gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/lib/relocate.S
--- u-boot-2016.11/arch/arm/lib/relocate.S	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/lib/relocate.S	2021-06-07 13:01:31.000000000 +0300
@@ -93,6 +93,8 @@
 	 */
 	ldr	r2, =__rel_dyn_start	/* r2 <- SRC &__rel_dyn_start */
 	ldr	r3, =__rel_dyn_end	/* r3 <- SRC &__rel_dyn_end */
+	cmp	r2, r3
+	beq	relocate_done
 fixloop:
 	ldmia	r2!, {r0-r1}		/* (r0,r1) <- (SRC location,fixup) */
 	and	r1, r1, #0xff
diff -uraN u-boot-2016.11/arch/arm/lib/reset.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/lib/reset.c
--- u-boot-2016.11/arch/arm/lib/reset.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/lib/reset.c	2021-06-07 13:01:31.000000000 +0300
@@ -33,6 +33,8 @@
 
 	udelay (50000);				/* wait 50 ms */
 
+	do_shutdown();
+
 	disable_interrupts();
 
 	reset_misc();
diff -uraN u-boot-2016.11/arch/arm/lib/shutdown.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/lib/shutdown.c
--- u-boot-2016.11/arch/arm/lib/shutdown.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/lib/shutdown.c	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <common.h>
+
+#define CFG_MAX_SHUTDOWN       10
+
+static struct shutdown_ctrl {
+	int count;
+	void (*shutdown[CFG_MAX_SHUTDOWN])(void);
+} shutdown_ctrl = {0, {0}, };
+
+void add_shutdown(void (*shutdown)(void))
+{
+	if (shutdown_ctrl.count >= CFG_MAX_SHUTDOWN) {
+		printf("Can't add shutdown function,"
+			   "Please increase CFG_MAX_SHUTDOWN count\n");
+		return;
+	}
+	shutdown_ctrl.shutdown[shutdown_ctrl.count++]
+		= shutdown;
+}
+
+void do_shutdown(void)
+{
+	int ix;
+	for (ix = 0; ix < shutdown_ctrl.count; ix++)
+		shutdown_ctrl.shutdown[ix]();
+}
diff -uraN u-boot-2016.11/arch/arm/lib/vectors.S gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/lib/vectors.S
--- u-boot-2016.11/arch/arm/lib/vectors.S	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/lib/vectors.S	2021-06-07 13:01:31.000000000 +0300
@@ -60,16 +60,6 @@
 	ldr	pc, _irq
 	ldr	pc, _fiq
 
-#ifdef CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK
-/*
- * Various SoCs need something special and SoC-specific up front in
- * order to boot, allow them to set that in their boot0.h file and then
- * use it here.
- */
-#include <asm/arch/boot0.h>
-ARM_SOC_BOOT0_HOOK
-#endif
-
 /*
  *************************************************************************
  *
@@ -98,6 +88,16 @@
 
 	.balignl 16,0xdeadbeef
 
+#ifdef CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK
+/*
+ * Various SoCs need something special and SoC-specific up front in
+ * order to boot, allow them to set that in their boot0.h file and then
+ * use it here.
+ */
+#include <asm/arch/boot0.h>
+ARM_SOC_BOOT0_HOOK
+#endif
+
 /*
  *************************************************************************
  *
diff -uraN u-boot-2016.11/arch/arm/mach-goke/boot0_hook.S gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/mach-goke/boot0_hook.S
--- u-boot-2016.11/arch/arm/mach-goke/boot0_hook.S	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/arm/mach-goke/boot0_hook.S	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <linux/linkage.h>
+
+VENDOR_BOOT0_HOOK
+
+    .globl _blank_zone_start
+_blank_zone_start:  .word __blank_zone_start
+ENTRY(get_blank_start)
+	ldr r0, _blank_zone_start
+	ldr r1, =__image_copy_start
+	sub r0, r0, r1
+	adrl r1, _start
+	add r0, r0, r1
+	mov pc, lr
+ENDPROC(get_blank_start)
+
+ENTRY(get_code_start)
+	adrl r0, _start
+	mov pc, lr
+ENDPROC(get_code_start)
diff -uraN u-boot-2016.11/arch/blackfin/cpu/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/blackfin/cpu/.gitignore
--- u-boot-2016.11/arch/blackfin/cpu/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/blackfin/cpu/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1,2 +0,0 @@
-init.lds
-init.elf
diff -uraN u-boot-2016.11/arch/blackfin/lib/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/blackfin/lib/.gitignore
--- u-boot-2016.11/arch/blackfin/lib/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/blackfin/lib/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1 +0,0 @@
-u-boot.lds
diff -uraN u-boot-2016.11/arch/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/.gitignore
--- u-boot-2016.11/arch/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1 +0,0 @@
-/*/include/asm/arch
diff -uraN u-boot-2016.11/arch/microblaze/dts/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/microblaze/dts/.gitignore
--- u-boot-2016.11/arch/microblaze/dts/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/microblaze/dts/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1 +0,0 @@
-*.dtb
diff -uraN u-boot-2016.11/arch/mips/dts/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/mips/dts/.gitignore
--- u-boot-2016.11/arch/mips/dts/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/mips/dts/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1 +0,0 @@
-*.dtb
diff -uraN u-boot-2016.11/arch/nios2/dts/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/nios2/dts/.gitignore
--- u-boot-2016.11/arch/nios2/dts/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/nios2/dts/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1 +0,0 @@
-*.dtb
diff -uraN u-boot-2016.11/arch/powerpc/dts/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/powerpc/dts/.gitignore
--- u-boot-2016.11/arch/powerpc/dts/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/powerpc/dts/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1 +0,0 @@
-*.dtb
diff -uraN u-boot-2016.11/arch/sandbox/dts/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/sandbox/dts/.gitignore
--- u-boot-2016.11/arch/sandbox/dts/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/sandbox/dts/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1 +0,0 @@
-*.dtb
diff -uraN u-boot-2016.11/arch/x86/dts/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/x86/dts/.gitignore
--- u-boot-2016.11/arch/x86/dts/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/arch/x86/dts/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1 +0,0 @@
-*.dtb
diff -uraN u-boot-2016.11/board/advantech/som-db5800-som-6867/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/advantech/som-db5800-som-6867/.gitignore
--- u-boot-2016.11/board/advantech/som-db5800-som-6867/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/advantech/som-db5800-som-6867/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1,3 +0,0 @@
-dsdt.aml
-dsdt.asl.tmp
-dsdt.c
diff -uraN u-boot-2016.11/board/congatec/conga-qeval20-qa3-e3845/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/congatec/conga-qeval20-qa3-e3845/.gitignore
--- u-boot-2016.11/board/congatec/conga-qeval20-qa3-e3845/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/congatec/conga-qeval20-qa3-e3845/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1,3 +0,0 @@
-dsdt.aml
-dsdt.asl.tmp
-dsdt.c
diff -uraN u-boot-2016.11/board/goke/gk7202v300/board.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/goke/gk7202v300/board.c
--- u-boot-2016.11/board/goke/gk7202v300/board.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/goke/gk7202v300/board.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,473 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#include <config.h>
+#include <common.h>
+#include <asm/io.h>
+#include <spi_flash.h>
+#include <linux/mtd/mtd.h>
+#include <nand.h>
+#include <netdev.h>
+#include <mmc.h>
+#include <asm/sections.h>
+#include <sdhci.h>
+#include <cpu_common.h>
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+void enable_caches(void)
+{
+	/* Enable D-cache. I-cache is already enabled in start.S */
+	dcache_enable();
+}
+#endif
+static int boot_media = BOOT_MEDIA_UNKNOWN;
+int get_boot_media(void)
+{
+	unsigned int reg_val, boot_mode, spi_device_mode;
+	int boot_media = BOOT_MEDIA_UNKNOWN;
+
+	reg_val = readl(SYS_CTRL_REG_BASE + REG_SYSSTAT);
+	boot_mode = get_sys_boot_mode(reg_val);
+
+	switch (boot_mode) {
+	case BOOT_FROM_SPI:
+		spi_device_mode = get_spi_device_type(reg_val);
+		if (spi_device_mode)
+			boot_media = BOOT_MEDIA_NAND;
+		else
+			boot_media = BOOT_MEDIA_SPIFLASH;
+		break;
+	case BOOT_FROM_EMMC:
+		boot_media = BOOT_MEDIA_EMMC;
+		break;
+	default:
+		boot_media = BOOT_MEDIA_UNKNOWN;
+		break;
+	}
+
+	return boot_media;
+}
+
+#if defined(CONFIG_SHOW_BOOT_PROGRESS)
+void show_boot_progress(int progress)
+{
+	printf("Boot reached stage %d\n", progress);
+}
+#endif
+
+static inline void delay(unsigned long loops)
+{
+	__asm__ volatile("1:\n"
+			"subs %0, %1, #1\n"
+			"bne 1b" : "=r"(loops) : "0"(loops));
+}
+
+int get_text_base(void)
+{
+	return CONFIG_SYS_TEXT_BASE;
+}
+
+static void boot_flag_init(void)
+{
+	unsigned int reg, boot_mode, spi_device_mode;
+
+	/* get boot mode */
+	reg = __raw_readl(SYS_CTRL_REG_BASE + REG_SYSSTAT);
+	boot_mode = get_sys_boot_mode(reg);
+
+	switch (boot_mode) {
+	case BOOT_FROM_SPI:
+		spi_device_mode = get_spi_device_type(reg);
+		if (spi_device_mode)
+			boot_media = BOOT_MEDIA_NAND;
+		else
+			boot_media = BOOT_MEDIA_SPIFLASH;
+		break;
+	case BOOT_FROM_EMMC:    /* emmc mode */
+		boot_media = BOOT_MEDIA_EMMC;
+		break;
+	default:
+		boot_media = BOOT_MEDIA_UNKNOWN;
+		break;
+	}
+}
+
+int board_early_init_f(void)
+{
+	return 0;
+}
+
+#define UBOOT_DATA_ADDR     0x41000000UL
+#define UBOOT_DATA_SIZE     0x80000UL
+int data_to_spiflash(void)
+{
+	static struct spi_flash *flash = NULL;
+	void *buf = NULL;
+
+	unsigned int val;
+
+	/* 0:bus; 0:cs; 1000000:max_hz; 0x3:spi_mode */
+	flash = spi_flash_probe(0, 0, 1000000, 0x3);
+	if (!flash) {
+		printf("Failed to initialize SPI flash\n");
+		return -1;  /* -1:failed */
+	}
+
+	/* erase the address range. */
+	printf("Spi flash erase...\n");
+	val = flash->erase(flash, NUM_0, UBOOT_DATA_SIZE);
+	if (val) {
+		printf("SPI flash sector erase failed\n");
+		return 1; /* 1:failed */
+	}
+
+	buf = map_physmem((unsigned long)UBOOT_DATA_ADDR,
+			UBOOT_DATA_SIZE, MAP_WRBACK);
+	if (!buf) {
+		puts("Failed to map physical memory\n");
+		return 1; /* 1:failed */
+	}
+
+	/* copy the data from RAM to FLASH */
+	printf("Spi flash write...\n");
+	val = flash->write(flash, NUM_0, UBOOT_DATA_SIZE, buf);
+	if (val) {
+		printf("SPI flash write failed, return %u\n",
+				val);
+		unmap_physmem(buf, UBOOT_DATA_SIZE);
+		return 1; /* 1:failed */
+	}
+
+	unmap_physmem(buf, UBOOT_DATA_SIZE);
+	return 0; /* 0:success */
+}
+
+int data_to_nandflash(void)
+{
+	struct mtd_info *nand_flash = NULL;
+	void *buf = NULL;
+	size_t length = UBOOT_DATA_SIZE;
+	unsigned int val;
+
+	nand_flash = nand_info[0];
+
+	printf("Nand flash erase...\n");
+	val = nand_erase(nand_flash, 0, UBOOT_DATA_SIZE);
+	if (val) {
+		printf("Nand flash erase failed\n");
+		return 1;
+	}
+
+	buf = map_physmem((unsigned long)UBOOT_DATA_ADDR,
+			UBOOT_DATA_SIZE, MAP_WRBACK);
+	if (!buf) {
+		puts("Failed to map physical memory\n");
+		return 1;
+	}
+
+	printf("Nand flash write...\n");
+	val = nand_write(nand_flash, 0, &length, buf);
+	if (val) {
+		printf("Nand flash write failed, return %u\n",
+				val);
+		unmap_physmem(buf, UBOOT_DATA_SIZE);
+		return 1;
+	}
+
+	unmap_physmem(buf, UBOOT_DATA_SIZE);
+	return 0;
+}
+
+int data_to_emmc(void)
+{
+	struct mmc *mmc = find_mmc_device(0);
+	void *buf = NULL;
+
+	if (!mmc)
+		return 1;
+
+	(void)mmc_init(mmc);
+
+	buf = map_physmem((unsigned long)UBOOT_DATA_ADDR,
+			UBOOT_DATA_SIZE, MAP_WRBACK);
+	if (!buf) {
+		puts("Failed to map physical memory\n");
+		return 1;
+	}
+
+	printf("MMC write...\n");
+	blk_dwrite(mmc_get_blk_desc(mmc), 0, (UBOOT_DATA_SIZE >> NUM_9), buf);
+	unmap_physmem(buf, UBOOT_DATA_SIZE);
+	return 0;
+}
+
+int save_bootdata_to_flash(void)
+{
+	unsigned int sd_update_flag = 0;
+	int ret = 0;
+	sd_update_flag = readl(SYS_CTRL_REG_BASE + REG_SC_GEN4);
+	if (sd_update_flag == START_MAGIC) {
+#if defined(CONFIG_FMC)
+		if (boot_media == BOOT_MEDIA_SPIFLASH) {
+			ret = data_to_spiflash();
+			if (ret != 0)
+				return ret;
+		}
+		if (boot_media == BOOT_MEDIA_NAND) {
+			ret = data_to_nandflash();
+			if (ret != 0)
+				return ret;
+		}
+#endif
+#if defined(CONFIG_SUPPORT_EMMC_BOOT)
+		if (boot_media == BOOT_MEDIA_EMMC) {
+			ret = data_to_emmc();
+			if (ret != 0)
+				return ret;
+		}
+#endif
+
+		printf("update success!\n");
+	}
+
+	return 0;
+}
+
+int auto_update_flag = 0;
+int bare_chip_program = 0;
+
+#define REG_BASE_GPIO0          0x120b0000
+#define GPIO0_0_DATA_OFST       0x4
+#define GPIO_DIR_OFST       0x400
+
+/** upgrade status register address */
+#define UPGRADE_STATUS_REG_ADDR 0x120F0048
+
+typedef enum tagUPGRADE_STATUS_E {
+	UPGRADE_STATUS_IDLE = 0,
+	UPGRADE_STATUS_PROCESSING,
+	UPGRADE_STATUS_FINISH,
+	UPGRADE_STATUS_BUTT
+} upgrade_status_e;
+
+int is_bare_program(void)
+{
+	return 1;
+}
+
+int is_auto_update(void)
+{
+#if (defined CONFIG_AUTO_SD_UPDATE) || (defined CONFIG_AUTO_USB_UPDATE)
+	/* to add some judgement if neccessary */
+	unsigned int  val[NUM_3];
+
+	unsigned int *puregval = (unsigned int *)UPGRADE_STATUS_REG_ADDR;
+	if (((*puregval) & (UPGRADE_STATUS_PROCESSING)) != 0)
+		return 1; /* update enable */
+
+	writel(0, REG_BASE_GPIO0 + GPIO_DIR_OFST);
+
+	val[NUM_0] = readl(REG_BASE_GPIO0 + GPIO0_0_DATA_OFST);
+	if (val[NUM_0])
+		return 0;
+
+	udelay(10000); /* delay 10000 us */
+	val[NUM_1] = readl(REG_BASE_GPIO0 + GPIO0_0_DATA_OFST);
+	udelay(10000); /* delay 10000 us */
+	val[NUM_2] = readl(REG_BASE_GPIO0 + GPIO0_0_DATA_OFST);
+	udelay(10000); /* delay 10000 us */
+
+	if (val[NUM_0] == val[NUM_1] && val[NUM_1] == val[NUM_2] && val[NUM_0] == NUM_0)
+		return 1;    /* update enable */
+	else
+		return 0;
+
+#else
+	return 0;
+#endif
+}
+
+void select_upgrade_dev(void)
+{
+#ifdef CONFIG_EMMC
+	unsigned int uval = readl(UPGRADE_STATUS_REG_ADDR);
+	unsigned int stor_dev = 0;
+	unsigned int stor_paration = 0;
+	stor_dev = (uval >> 16) & 0x03; /* 16,0x03: store dev */
+	stor_paration = (uval >> 18) & 0x1f; /* 18,0x1f: store paration */
+	if (((uval) & (UPGRADE_STATUS_PROCESSING)) != NUM_0) {
+		/* the upgrade startup by linux application */
+		if (stor_dev == NUM_0) {
+			/* emmc */
+			target_dev = NUM_0;
+			target_paratition = stor_paration;
+		} else {
+			/* sd */
+			target_dev = NUM_1;
+		}
+	} else {
+		/* the upgrade startup by upgrade key on the board, os defaule upgrade style */
+		target_dev = NUM_1;
+	}
+
+	printf("update dev is %d: paratition is %d\n", target_dev, target_paratition);
+#endif
+	return;
+}
+
+int misc_init_r(void)
+{
+#ifdef CONFIG_RANDOM_ETHADDR
+	random_init_r();
+#endif
+	setenv("verify", "n");
+
+#if (CONFIG_AUTO_UPDATE == 1)
+	/* auto update flag */
+	if (is_auto_update())
+		auto_update_flag = NUM_1;
+	else
+		auto_update_flag = NUM_0;
+
+	/* bare chip program flag */
+	if (is_bare_program())
+		bare_chip_program = NUM_1;
+	else
+		bare_chip_program = NUM_0;
+
+#ifdef CFG_MMU_HANDLEOK
+	dcache_stop();
+#endif
+
+#ifdef CFG_MMU_HANDLEOK
+	dcache_start();
+#endif
+
+#endif
+
+#if (CONFIG_AUTO_UPDATE == 1)
+	int update_flag = -1; /* -1:default failed */
+	if (auto_update_flag) {
+		select_upgrade_dev();
+		update_flag = do_auto_update();
+		unsigned int *puregval = (unsigned int *)UPGRADE_STATUS_REG_ADDR;
+		if (((*puregval) & (UPGRADE_STATUS_PROCESSING)) && (update_flag == NUM_0)) {
+			printf("upgrade status: finish\n");
+			*puregval = UPGRADE_STATUS_FINISH;
+		}
+	}
+	if (bare_chip_program && !auto_update_flag)
+		save_bootdata_to_flash();
+	if (update_flag == NUM_0)
+		do_reset(NULL, 0, 0, NULL);
+#endif
+	return 0;
+}
+
+int board_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gd->bd->bi_arch_number = MACH_TYPE_GK7202V300;
+	gd->bd->bi_boot_params = CFG_BOOT_PARAMS;
+
+	boot_flag_init();
+
+	return 0;
+}
+
+int dram_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gd->ram_size = PHYS_SDRAM_1_SIZE;
+	return 0;
+}
+
+void reset_cpu(ulong addr)
+{
+	/* 0x12345678:writing any value will cause a reset. */
+	writel(0x12345678, SYS_CTRL_REG_BASE + REG_SC_SYSRES);
+	while (1);
+}
+
+int timer_init(void)
+{
+	/*
+	 * Under uboot, 0xffffffff is set to load register,
+	 * timer_clk equals BUSCLK/2/256.
+	 * e.g. BUSCLK equals 50M, it will roll back after 0xffffffff/timer_clk
+	 * 43980s equals 12hours
+	 */
+	__raw_writel(0, TIMER0_REG_BASE + REG_TIMER_CONTROL);
+	__raw_writel(~0, TIMER0_REG_BASE + REG_TIMER_RELOAD);
+
+	/* 32 bit, periodic */
+	__raw_writel(CFG_TIMER_CTRL, TIMER0_REG_BASE + REG_TIMER_CONTROL);
+
+	return 0;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	int rc = 0;
+
+#ifdef CONFIG_NET_FEMAC
+	rc = bspeth_initialize(bis);
+#endif
+	return rc;
+}
+
+#ifdef CONFIG_GENERIC_MMC
+int board_mmc_init(bd_t *bis)
+{
+	int ret = 0;
+
+#ifdef CONFIG_GK_SDHCI
+
+#ifndef CONFIG_FMC
+	ret = sdhci_add_port(0, EMMC_BASE_REG, MMC_TYPE_MMC);
+	if (!ret) {
+		ret = bsp_mmc_init(0);
+		if (ret)
+			printf("No EMMC device found !\n");
+	}
+#else
+
+#ifdef CONFIG_AUTO_SD_UPDATE
+	ret = sdhci_add_port(0, SDIO0_BASE_REG, MMC_TYPE_SD);
+	if (ret)
+		return ret;
+
+	ret = bsp_mmc_init(0);
+	if (ret)
+		printf("No SD device found !\n");
+#endif
+
+#endif
+#endif
+
+	return ret;
+}
+#endif
+
+#ifdef CONFIG_MINI_BOOT
+void udc_connect(void)
+{
+}
+#endif
+
+#ifdef CONFIG_ARMV7_NONSEC
+void smp_set_core_boot_addr(unsigned long addr, int corenr)
+{
+}
+
+void smp_kick_all_cpus(void)
+{
+}
+
+void smp_waitloop(unsigned previous_address)
+{
+}
+#endif
+
diff -uraN u-boot-2016.11/board/goke/gk7202v300/Kconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/goke/gk7202v300/Kconfig
--- u-boot-2016.11/board/goke/gk7202v300/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/goke/gk7202v300/Kconfig	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,15 @@
+if TARGET_GK7202V300
+
+config SYS_BOARD
+	default "gk7202v300"
+
+config SYS_VENDOR
+	default "goke"
+
+config SYS_SOC
+	default "gk7202v300"
+
+config SYS_CONFIG_NAME
+	default "gk7202v300"
+
+endif
diff -uraN u-boot-2016.11/board/goke/gk7202v300/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/goke/gk7202v300/Makefile
--- u-boot-2016.11/board/goke/gk7202v300/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/goke/gk7202v300/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,8 @@
+#
+# (C) Copyright 2000-2004
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y	+= board.o
diff -uraN u-boot-2016.11/board/goke/gk7205v200/board.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/goke/gk7205v200/board.c
--- u-boot-2016.11/board/goke/gk7205v200/board.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/goke/gk7205v200/board.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,424 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#include <config.h>
+#include <common.h>
+#include <asm/io.h>
+#include <spi_flash.h>
+#include <linux/mtd/mtd.h>
+#include <nand.h>
+#include <netdev.h>
+#include <mmc.h>
+#include <asm/sections.h>
+#include <sdhci.h>
+#include <cpu_common.h>
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+void enable_caches(void)
+{
+	/* Enable D-cache. I-cache is already enabled in start.S */
+	dcache_enable();
+}
+#endif
+static int boot_media = BOOT_MEDIA_UNKNOWN;
+int get_boot_media(void)
+{
+	unsigned int reg_val, boot_mode, spi_device_mode;
+	int boot_media = BOOT_MEDIA_UNKNOWN;
+
+	reg_val = readl(SYS_CTRL_REG_BASE + REG_SYSSTAT);
+	boot_mode = get_sys_boot_mode(reg_val);
+
+	switch (boot_mode) {
+	case BOOT_FROM_SPI:
+		spi_device_mode = get_spi_device_type(reg_val);
+		if (spi_device_mode)
+			boot_media = BOOT_MEDIA_NAND;
+		else
+			boot_media = BOOT_MEDIA_SPIFLASH;
+		break;
+	case BOOT_FROM_EMMC:
+		boot_media = BOOT_MEDIA_EMMC;
+		break;
+	default:
+		boot_media = BOOT_MEDIA_UNKNOWN;
+		break;
+	}
+
+	return boot_media;
+}
+
+#if defined(CONFIG_SHOW_BOOT_PROGRESS)
+void show_boot_progress(int progress)
+{
+	printf("Boot reached stage %d\n", progress);
+}
+#endif
+
+static inline void delay(unsigned long loops)
+{
+	__asm__ volatile("1:\n"
+			"subs %0, %1, #1\n"
+			"bne 1b" : "=r"(loops) : "0"(loops));
+}
+
+int get_text_base(void)
+{
+	return CONFIG_SYS_TEXT_BASE;
+}
+
+static void boot_flag_init(void)
+{
+	unsigned int reg, boot_mode, spi_device_mode;
+
+	/* get boot mode */
+	reg = __raw_readl(SYS_CTRL_REG_BASE + REG_SYSSTAT);
+	boot_mode = get_sys_boot_mode(reg);
+
+	switch (boot_mode) {
+	case BOOT_FROM_SPI:
+		spi_device_mode = get_spi_device_type(reg);
+		if (spi_device_mode)
+			boot_media = BOOT_MEDIA_NAND;
+		else
+			boot_media = BOOT_MEDIA_SPIFLASH;
+		break;
+	case BOOT_FROM_EMMC:    /* emmc mode */
+		boot_media = BOOT_MEDIA_EMMC;
+		break;
+	default:
+		boot_media = BOOT_MEDIA_UNKNOWN;
+		break;
+	}
+}
+
+int board_early_init_f(void)
+{
+	return 0;
+}
+
+#define UBOOT_DATA_ADDR     0x41000000UL
+#define UBOOT_DATA_SIZE     0x80000UL
+int data_to_spiflash(void)
+{
+	static struct spi_flash *flash = NULL;
+	void *buf = NULL;
+
+	unsigned int val;
+
+	/* 0:bus; 0:cs; 1000000:max_hz; 0x3:spi_mode */
+	flash = spi_flash_probe(0, 0, 1000000, 0x3);
+	if (!flash) {
+		printf("Failed to initialize SPI flash\n");
+		return -1;  /* -1:failed */
+	}
+
+	/* erase the address range. */
+	printf("Spi flash erase...\n");
+	val = flash->erase(flash, NUM_0, UBOOT_DATA_SIZE);
+	if (val) {
+		printf("SPI flash sector erase failed\n");
+		return 1; /* 1:failed */
+	}
+
+	buf = map_physmem((unsigned long)UBOOT_DATA_ADDR,
+			UBOOT_DATA_SIZE, MAP_WRBACK);
+	if (!buf) {
+		puts("Failed to map physical memory\n");
+		return 1; /* 1:failed */
+	}
+
+	/* copy the data from RAM to FLASH */
+	printf("Spi flash write...\n");
+	val = flash->write(flash, NUM_0, UBOOT_DATA_SIZE, buf);
+	if (val) {
+		printf("SPI flash write failed, return %u\n",
+				val);
+		unmap_physmem(buf, UBOOT_DATA_SIZE);
+		return 1; /* 1:failed */
+	}
+
+	unmap_physmem(buf, UBOOT_DATA_SIZE);
+	return 0; /* 0:success */
+}
+
+int data_to_nandflash(void)
+{
+	struct mtd_info *nand_flash = NULL;
+	void *buf = NULL;
+	size_t length = UBOOT_DATA_SIZE;
+	unsigned int val;
+
+	nand_flash = nand_info[0];
+
+	printf("Nand flash erase...\n");
+	val = nand_erase(nand_flash, 0, UBOOT_DATA_SIZE);
+	if (val) {
+		printf("Nand flash erase failed\n");
+		return 1;
+	}
+
+	buf = map_physmem((unsigned long)UBOOT_DATA_ADDR,
+			UBOOT_DATA_SIZE, MAP_WRBACK);
+	if (!buf) {
+		puts("Failed to map physical memory\n");
+		return 1;
+	}
+
+	printf("Nand flash write...\n");
+	val = nand_write(nand_flash, 0, &length, buf);
+	if (val) {
+		printf("Nand flash write failed, return %u\n",
+				val);
+		unmap_physmem(buf, UBOOT_DATA_SIZE);
+		return 1;
+	}
+
+	unmap_physmem(buf, UBOOT_DATA_SIZE);
+	return 0;
+}
+
+int data_to_emmc(void)
+{
+	struct mmc *mmc = find_mmc_device(0);
+	void *buf = NULL;
+
+	if (!mmc)
+		return 1;
+
+	(void)mmc_init(mmc);
+
+	buf = map_physmem((unsigned long)UBOOT_DATA_ADDR,
+			UBOOT_DATA_SIZE, MAP_WRBACK);
+	if (!buf) {
+		puts("Failed to map physical memory\n");
+		return 1;
+	}
+
+	printf("MMC write...\n");
+	blk_dwrite(mmc_get_blk_desc(mmc), 0, (UBOOT_DATA_SIZE >> NUM_9), buf);
+	unmap_physmem(buf, UBOOT_DATA_SIZE);
+	return 0;
+}
+
+int save_bootdata_to_flash(void)
+{
+	unsigned int sd_update_flag = 0;
+	int ret = 0;
+	sd_update_flag = readl(SYS_CTRL_REG_BASE + REG_SC_GEN4);
+	if (sd_update_flag == START_MAGIC) {
+#if defined(CONFIG_FMC)
+		if (boot_media == BOOT_MEDIA_SPIFLASH) {
+			ret = data_to_spiflash();
+			if (ret != 0)
+				return ret;
+		}
+		if (boot_media == BOOT_MEDIA_NAND) {
+			ret = data_to_nandflash();
+			if (ret != 0)
+				return ret;
+		}
+#endif
+#if defined(CONFIG_SUPPORT_EMMC_BOOT)
+		if (boot_media == BOOT_MEDIA_EMMC) {
+			ret = data_to_emmc();
+			if (ret != 0)
+				return ret;
+		}
+#endif
+
+		printf("update success!\n");
+	}
+
+	return 0;
+}
+
+int auto_update_flag = 0;
+int bare_chip_program = 0;
+
+#define REG_BASE_GPIO0          0x120b0000
+#define GPIO0_0_DATA_OFST       0x4
+#define GPIO_DIR_OFST       0x400
+
+int is_bare_program(void)
+{
+	return 1;
+}
+
+int is_auto_update(void)
+{
+#if (defined CONFIG_AUTO_SD_UPDATE) || (defined CONFIG_AUTO_USB_UPDATE)
+	/* to add some judgement if neccessary */
+	unsigned int  val[NUM_3];
+
+	writel(0, REG_BASE_GPIO0 + GPIO_DIR_OFST);
+
+	val[NUM_0] = readl(REG_BASE_GPIO0 + GPIO0_0_DATA_OFST);
+	if (val[NUM_0])
+		return 0;
+
+	udelay(10000); /* delay 10000 us */
+	val[NUM_1] = readl(REG_BASE_GPIO0 + GPIO0_0_DATA_OFST);
+	udelay(10000); /* delay 10000 us */
+	val[NUM_2] = readl(REG_BASE_GPIO0 + GPIO0_0_DATA_OFST);
+	udelay(10000); /* delay 10000 us */
+
+	if (val[NUM_0] == val[NUM_1] && val[NUM_1] == val[NUM_2] && val[NUM_0] == NUM_0)
+		return 1;    /* update enable */
+	else
+		return 0;
+
+#else
+	return 0;
+#endif
+}
+
+int misc_init_r(void)
+{
+#ifdef CONFIG_RANDOM_ETHADDR
+	random_init_r();
+#endif
+	setenv("verify", "n");
+
+#if (CONFIG_AUTO_UPDATE == 1)
+	/* auto update flag */
+	if (is_auto_update())
+		auto_update_flag = 1;
+	else
+		auto_update_flag = 0;
+
+	/* bare chip program flag */
+	if (is_bare_program())
+		bare_chip_program = 1;
+	else
+		bare_chip_program = 0;
+
+#ifdef CFG_MMU_HANDLEOK
+	dcache_stop();
+#endif
+
+#ifdef CFG_MMU_HANDLEOK
+	dcache_start();
+#endif
+
+#endif
+
+#if (CONFIG_AUTO_UPDATE == 1)
+	int update_flag = -1;
+	if (auto_update_flag)
+		update_flag = do_auto_update();
+	if (bare_chip_program && !auto_update_flag)
+		save_bootdata_to_flash();
+	if (update_flag == 0)
+		do_reset(NULL, 0, 0, NULL);
+#endif
+	return 0;
+}
+
+int board_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gd->bd->bi_arch_number = MACH_TYPE_GK7205V200;
+	gd->bd->bi_boot_params = CFG_BOOT_PARAMS;
+
+	boot_flag_init();
+
+	return 0;
+}
+
+int dram_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gd->ram_size = PHYS_SDRAM_1_SIZE;
+	return 0;
+}
+
+void reset_cpu(ulong addr)
+{
+	/* 0x12345678:writing any value will cause a reset. */
+	writel(0x12345678, SYS_CTRL_REG_BASE + REG_SC_SYSRES);
+	while (1);
+}
+
+int timer_init(void)
+{
+	/*
+	 * Under uboot, 0xffffffff is set to load register,
+	 * timer_clk equals BUSCLK/2/256.
+	 * e.g. BUSCLK equals 50M, it will roll back after 0xffffffff/timer_clk
+	 * 43980s equals 12hours
+	 */
+	__raw_writel(0, TIMER0_REG_BASE + REG_TIMER_CONTROL);
+	__raw_writel(~0, TIMER0_REG_BASE + REG_TIMER_RELOAD);
+
+	/* 32 bit, periodic */
+	__raw_writel(CFG_TIMER_CTRL, TIMER0_REG_BASE + REG_TIMER_CONTROL);
+
+	return 0;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	int rc = 0;
+
+#ifdef CONFIG_NET_FEMAC
+	rc = bspeth_initialize(bis);
+#endif
+	return rc;
+}
+
+#ifdef CONFIG_GENERIC_MMC
+int board_mmc_init(bd_t *bis)
+{
+	int ret = 0;
+
+#ifdef CONFIG_GK_SDHCI
+
+#ifndef CONFIG_FMC
+	ret = sdhci_add_port(0, EMMC_BASE_REG, MMC_TYPE_MMC);
+	if (!ret) {
+		ret = bsp_mmc_init(0);
+		if (ret)
+			printf("No EMMC device found !\n");
+	}
+#else
+
+#ifdef CONFIG_AUTO_SD_UPDATE
+	ret = sdhci_add_port(0, SDIO0_BASE_REG, MMC_TYPE_SD);
+	if (ret)
+		return ret;
+
+	ret = bsp_mmc_init(0);
+	if (ret)
+		printf("No SD device found !\n");
+#endif
+
+#endif
+#endif
+
+	return ret;
+}
+#endif
+
+#ifdef CONFIG_MINI_BOOT
+void udc_connect(void)
+{
+}
+#endif
+
+#ifdef CONFIG_ARMV7_NONSEC
+void smp_set_core_boot_addr(unsigned long addr, int corenr)
+{
+}
+
+void smp_kick_all_cpus(void)
+{
+}
+
+void smp_waitloop(unsigned previous_address)
+{
+}
+#endif
+
diff -uraN u-boot-2016.11/board/goke/gk7205v200/Kconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/goke/gk7205v200/Kconfig
--- u-boot-2016.11/board/goke/gk7205v200/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/goke/gk7205v200/Kconfig	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,15 @@
+if TARGET_GK7205V200
+
+config SYS_BOARD
+	default "gk7205v200"
+
+config SYS_VENDOR
+	default "goke"
+
+config SYS_SOC
+	default "gk7205v200"
+
+config SYS_CONFIG_NAME
+	default "gk7205v200"
+
+endif
diff -uraN u-boot-2016.11/board/goke/gk7205v200/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/goke/gk7205v200/Makefile
--- u-boot-2016.11/board/goke/gk7205v200/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/goke/gk7205v200/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,8 @@
+#
+# (C) Copyright 2000-2004
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y	+= board.o
diff -uraN u-boot-2016.11/board/goke/gk7205v300/board.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/goke/gk7205v300/board.c
--- u-boot-2016.11/board/goke/gk7205v300/board.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/goke/gk7205v300/board.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,424 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#include <config.h>
+#include <common.h>
+#include <asm/io.h>
+#include <spi_flash.h>
+#include <linux/mtd/mtd.h>
+#include <nand.h>
+#include <netdev.h>
+#include <mmc.h>
+#include <asm/sections.h>
+#include <sdhci.h>
+#include <cpu_common.h>
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+void enable_caches(void)
+{
+	/* Enable D-cache. I-cache is already enabled in start.S */
+	dcache_enable();
+}
+#endif
+static int boot_media = BOOT_MEDIA_UNKNOWN;
+int get_boot_media(void)
+{
+	unsigned int reg_val, boot_mode, spi_device_mode;
+	int boot_media = BOOT_MEDIA_UNKNOWN;
+
+	reg_val = readl(SYS_CTRL_REG_BASE + REG_SYSSTAT);
+	boot_mode = get_sys_boot_mode(reg_val);
+
+	switch (boot_mode) {
+	case BOOT_FROM_SPI:
+		spi_device_mode = get_spi_device_type(reg_val);
+		if (spi_device_mode)
+			boot_media = BOOT_MEDIA_NAND;
+		else
+			boot_media = BOOT_MEDIA_SPIFLASH;
+		break;
+	case BOOT_FROM_EMMC:
+		boot_media = BOOT_MEDIA_EMMC;
+		break;
+	default:
+		boot_media = BOOT_MEDIA_UNKNOWN;
+		break;
+	}
+
+	return boot_media;
+}
+
+#if defined(CONFIG_SHOW_BOOT_PROGRESS)
+void show_boot_progress(int progress)
+{
+	printf("Boot reached stage %d\n", progress);
+}
+#endif
+
+static inline void delay(unsigned long loops)
+{
+	__asm__ volatile("1:\n"
+			"subs %0, %1, #1\n"
+			"bne 1b" : "=r"(loops) : "0"(loops));
+}
+
+int get_text_base(void)
+{
+	return CONFIG_SYS_TEXT_BASE;
+}
+
+static void boot_flag_init(void)
+{
+	unsigned int reg, boot_mode, spi_device_mode;
+
+	/* get boot mode */
+	reg = __raw_readl(SYS_CTRL_REG_BASE + REG_SYSSTAT);
+	boot_mode = get_sys_boot_mode(reg);
+
+	switch (boot_mode) {
+	case BOOT_FROM_SPI:
+		spi_device_mode = get_spi_device_type(reg);
+		if (spi_device_mode)
+			boot_media = BOOT_MEDIA_NAND;
+		else
+			boot_media = BOOT_MEDIA_SPIFLASH;
+		break;
+	case BOOT_FROM_EMMC:    /* emmc mode */
+		boot_media = BOOT_MEDIA_EMMC;
+		break;
+	default:
+		boot_media = BOOT_MEDIA_UNKNOWN;
+		break;
+	}
+}
+
+int board_early_init_f(void)
+{
+	return 0;
+}
+
+#define UBOOT_DATA_ADDR     0x41000000UL
+#define UBOOT_DATA_SIZE     0x80000UL
+int data_to_spiflash(void)
+{
+	static struct spi_flash *flash = NULL;
+	void *buf = NULL;
+
+	unsigned int val;
+
+	/* 0:bus; 0:cs; 1000000:max_hz; 0x3:spi_mode */
+	flash = spi_flash_probe(0, 0, 1000000, 0x3);
+	if (!flash) {
+		printf("Failed to initialize SPI flash\n");
+		return -1;  /* -1:failed */
+	}
+
+	/* erase the address range. */
+	printf("Spi flash erase...\n");
+	val = flash->erase(flash, NUM_0, UBOOT_DATA_SIZE);
+	if (val) {
+		printf("SPI flash sector erase failed\n");
+		return 1; /* 1:failed */
+	}
+
+	buf = map_physmem((unsigned long)UBOOT_DATA_ADDR,
+			UBOOT_DATA_SIZE, MAP_WRBACK);
+	if (!buf) {
+		puts("Failed to map physical memory\n");
+		return 1; /* 1:failed */
+	}
+
+	/* copy the data from RAM to FLASH */
+	printf("Spi flash write...\n");
+	val = flash->write(flash, NUM_0, UBOOT_DATA_SIZE, buf);
+	if (val) {
+		printf("SPI flash write failed, return %u\n",
+				val);
+		unmap_physmem(buf, UBOOT_DATA_SIZE);
+		return 1; /* 1:failed */
+	}
+
+	unmap_physmem(buf, UBOOT_DATA_SIZE);
+	return 0; /* 0:success */
+}
+
+int data_to_nandflash(void)
+{
+	struct mtd_info *nand_flash = NULL;
+	void *buf = NULL;
+	size_t length = UBOOT_DATA_SIZE;
+	unsigned int val;
+
+	nand_flash = nand_info[0];
+
+	printf("Nand flash erase...\n");
+	val = nand_erase(nand_flash, 0, UBOOT_DATA_SIZE);
+	if (val) {
+		printf("Nand flash erase failed\n");
+		return 1;
+	}
+
+	buf = map_physmem((unsigned long)UBOOT_DATA_ADDR,
+			UBOOT_DATA_SIZE, MAP_WRBACK);
+	if (!buf) {
+		puts("Failed to map physical memory\n");
+		return 1;
+	}
+
+	printf("Nand flash write...\n");
+	val = nand_write(nand_flash, 0, &length, buf);
+	if (val) {
+		printf("Nand flash write failed, return %u\n",
+				val);
+		unmap_physmem(buf, UBOOT_DATA_SIZE);
+		return 1;
+	}
+
+	unmap_physmem(buf, UBOOT_DATA_SIZE);
+	return 0;
+}
+
+int data_to_emmc(void)
+{
+	struct mmc *mmc = find_mmc_device(0);
+	void *buf = NULL;
+
+	if (!mmc)
+		return 1;
+
+	(void)mmc_init(mmc);
+
+	buf = map_physmem((unsigned long)UBOOT_DATA_ADDR,
+			UBOOT_DATA_SIZE, MAP_WRBACK);
+	if (!buf) {
+		puts("Failed to map physical memory\n");
+		return 1;
+	}
+
+	printf("MMC write...\n");
+	blk_dwrite(mmc_get_blk_desc(mmc), 0, (UBOOT_DATA_SIZE >> NUM_9), buf);
+	unmap_physmem(buf, UBOOT_DATA_SIZE);
+	return 0;
+}
+
+int save_bootdata_to_flash(void)
+{
+	unsigned int sd_update_flag = 0;
+	int ret = 0;
+	sd_update_flag = readl(SYS_CTRL_REG_BASE + REG_SC_GEN4);
+	if (sd_update_flag == START_MAGIC) {
+#if defined(CONFIG_FMC)
+		if (boot_media == BOOT_MEDIA_SPIFLASH) {
+			ret = data_to_spiflash();
+			if (ret != 0)
+				return ret;
+		}
+		if (boot_media == BOOT_MEDIA_NAND) {
+			ret = data_to_nandflash();
+			if (ret != 0)
+				return ret;
+		}
+#endif
+#if defined(CONFIG_SUPPORT_EMMC_BOOT)
+		if (boot_media == BOOT_MEDIA_EMMC) {
+			ret = data_to_emmc();
+			if (ret != 0)
+				return ret;
+		}
+#endif
+
+		printf("update success!\n");
+	}
+
+	return 0;
+}
+
+int auto_update_flag = 0;
+int bare_chip_program = 0;
+
+#define REG_BASE_GPIO0          0x120b0000
+#define GPIO0_0_DATA_OFST       0x4
+#define GPIO_DIR_OFST       0x400
+
+int is_bare_program(void)
+{
+	return 1;
+}
+
+int is_auto_update(void)
+{
+#if (defined CONFIG_AUTO_SD_UPDATE) || (defined CONFIG_AUTO_USB_UPDATE)
+	/* to add some judgement if neccessary */
+	unsigned int  val[NUM_3];
+
+	writel(0, REG_BASE_GPIO0 + GPIO_DIR_OFST);
+
+	val[NUM_0] = readl(REG_BASE_GPIO0 + GPIO0_0_DATA_OFST);
+	if (val[NUM_0])
+		return 0;
+
+	udelay(10000); /* delay 10000 us */
+	val[NUM_1] = readl(REG_BASE_GPIO0 + GPIO0_0_DATA_OFST);
+	udelay(10000); /* delay 10000 us */
+	val[NUM_2] = readl(REG_BASE_GPIO0 + GPIO0_0_DATA_OFST);
+	udelay(10000); /* delay 10000 us */
+
+	if (val[NUM_0] == val[NUM_1] && val[NUM_1] == val[NUM_2] && val[NUM_0] == NUM_0)
+		return 1;    /* update enable */
+	else
+		return 0;
+
+#else
+	return 0;
+#endif
+}
+
+int misc_init_r(void)
+{
+#ifdef CONFIG_RANDOM_ETHADDR
+	random_init_r();
+#endif
+	setenv("verify", "n");
+
+#if (CONFIG_AUTO_UPDATE == 1)
+	/* auto update flag */
+	if (is_auto_update())
+		auto_update_flag = 1;
+	else
+		auto_update_flag = 0;
+
+	/* bare chip program flag */
+	if (is_bare_program())
+		bare_chip_program = 1;
+	else
+		bare_chip_program = 0;
+
+#ifdef CFG_MMU_HANDLEOK
+	dcache_stop();
+#endif
+
+#ifdef CFG_MMU_HANDLEOK
+	dcache_start();
+#endif
+
+#endif
+
+#if (CONFIG_AUTO_UPDATE == 1)
+	int update_flag = -1;
+	if (auto_update_flag)
+		update_flag = do_auto_update();
+	if (bare_chip_program && !auto_update_flag)
+		save_bootdata_to_flash();
+	if (update_flag == 0)
+		do_reset(NULL, 0, 0, NULL);
+#endif
+	return 0;
+}
+
+int board_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gd->bd->bi_arch_number = MACH_TYPE_GK7205V300;
+	gd->bd->bi_boot_params = CFG_BOOT_PARAMS;
+
+	boot_flag_init();
+
+	return 0;
+}
+
+int dram_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gd->ram_size = PHYS_SDRAM_1_SIZE;
+	return 0;
+}
+
+void reset_cpu(ulong addr)
+{
+	/* 0x12345678:writing any value will cause a reset. */
+	writel(0x12345678, SYS_CTRL_REG_BASE + REG_SC_SYSRES);
+	while (1);
+}
+
+int timer_init(void)
+{
+	/*
+	 * Under uboot, 0xffffffff is set to load register,
+	 * timer_clk equals BUSCLK/2/256.
+	 * e.g. BUSCLK equals 50M, it will roll back after 0xffffffff/timer_clk
+	 * 43980s equals 12hours
+	 */
+	__raw_writel(0, TIMER0_REG_BASE + REG_TIMER_CONTROL);
+	__raw_writel(~0, TIMER0_REG_BASE + REG_TIMER_RELOAD);
+
+	/* 32 bit, periodic */
+	__raw_writel(CFG_TIMER_CTRL, TIMER0_REG_BASE + REG_TIMER_CONTROL);
+
+	return 0;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	int rc = 0;
+
+#ifdef CONFIG_NET_FEMAC
+	rc = bspeth_initialize(bis);
+#endif
+	return rc;
+}
+
+#ifdef CONFIG_GENERIC_MMC
+int board_mmc_init(bd_t *bis)
+{
+	int ret = 0;
+
+#ifdef CONFIG_GK_SDHCI
+
+#ifndef CONFIG_FMC
+	ret = sdhci_add_port(0, EMMC_BASE_REG, MMC_TYPE_MMC);
+	if (!ret) {
+		ret = bsp_mmc_init(0);
+		if (ret)
+			printf("No EMMC device found !\n");
+	}
+#else
+
+#ifdef CONFIG_AUTO_SD_UPDATE
+	ret = sdhci_add_port(0, SDIO0_BASE_REG, MMC_TYPE_SD);
+	if (ret)
+		return ret;
+
+	ret = bsp_mmc_init(0);
+	if (ret)
+		printf("No SD device found !\n");
+#endif
+
+#endif
+#endif
+
+	return ret;
+}
+#endif
+
+#ifdef CONFIG_MINI_BOOT
+void udc_connect(void)
+{
+}
+#endif
+
+#ifdef CONFIG_ARMV7_NONSEC
+void smp_set_core_boot_addr(unsigned long addr, int corenr)
+{
+}
+
+void smp_kick_all_cpus(void)
+{
+}
+
+void smp_waitloop(unsigned previous_address)
+{
+}
+#endif
+
diff -uraN u-boot-2016.11/board/goke/gk7205v300/Kconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/goke/gk7205v300/Kconfig
--- u-boot-2016.11/board/goke/gk7205v300/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/goke/gk7205v300/Kconfig	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,15 @@
+if TARGET_GK7205V300
+
+config SYS_BOARD
+	default "gk7205v300"
+
+config SYS_VENDOR
+	default "goke"
+
+config SYS_SOC
+	default "gk7205v300"
+
+config SYS_CONFIG_NAME
+	default "gk7205v300"
+
+endif
diff -uraN u-boot-2016.11/board/goke/gk7205v300/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/goke/gk7205v300/Makefile
--- u-boot-2016.11/board/goke/gk7205v300/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/goke/gk7205v300/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,8 @@
+#
+# (C) Copyright 2000-2004
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y	+= board.o
diff -uraN u-boot-2016.11/board/goke/gk7605v100/board.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/goke/gk7605v100/board.c
--- u-boot-2016.11/board/goke/gk7605v100/board.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/goke/gk7605v100/board.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,424 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#include <config.h>
+#include <common.h>
+#include <asm/io.h>
+#include <spi_flash.h>
+#include <linux/mtd/mtd.h>
+#include <nand.h>
+#include <netdev.h>
+#include <mmc.h>
+#include <asm/sections.h>
+#include <sdhci.h>
+#include <cpu_common.h>
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+void enable_caches(void)
+{
+	/* Enable D-cache. I-cache is already enabled in start.S */
+	dcache_enable();
+}
+#endif
+static int boot_media = BOOT_MEDIA_UNKNOWN;
+int get_boot_media(void)
+{
+	unsigned int reg_val, boot_mode, spi_device_mode;
+	int boot_media = BOOT_MEDIA_UNKNOWN;
+
+	reg_val = readl(SYS_CTRL_REG_BASE + REG_SYSSTAT);
+	boot_mode = get_sys_boot_mode(reg_val);
+
+	switch (boot_mode) {
+	case BOOT_FROM_SPI:
+		spi_device_mode = get_spi_device_type(reg_val);
+		if (spi_device_mode)
+			boot_media = BOOT_MEDIA_NAND;
+		else
+			boot_media = BOOT_MEDIA_SPIFLASH;
+		break;
+	case BOOT_FROM_EMMC:
+		boot_media = BOOT_MEDIA_EMMC;
+		break;
+	default:
+		boot_media = BOOT_MEDIA_UNKNOWN;
+		break;
+	}
+
+	return boot_media;
+}
+
+#if defined(CONFIG_SHOW_BOOT_PROGRESS)
+void show_boot_progress(int progress)
+{
+	printf("Boot reached stage %d\n", progress);
+}
+#endif
+
+static inline void delay(unsigned long loops)
+{
+	__asm__ volatile("1:\n"
+			"subs %0, %1, #1\n"
+			"bne 1b" : "=r"(loops) : "0"(loops));
+}
+
+int get_text_base(void)
+{
+	return CONFIG_SYS_TEXT_BASE;
+}
+
+static void boot_flag_init(void)
+{
+	unsigned int reg, boot_mode, spi_device_mode;
+
+	/* get boot mode */
+	reg = __raw_readl(SYS_CTRL_REG_BASE + REG_SYSSTAT);
+	boot_mode = get_sys_boot_mode(reg);
+
+	switch (boot_mode) {
+	case BOOT_FROM_SPI:
+		spi_device_mode = get_spi_device_type(reg);
+		if (spi_device_mode)
+			boot_media = BOOT_MEDIA_NAND;
+		else
+			boot_media = BOOT_MEDIA_SPIFLASH;
+		break;
+	case BOOT_FROM_EMMC:    /* emmc mode */
+		boot_media = BOOT_MEDIA_EMMC;
+		break;
+	default:
+		boot_media = BOOT_MEDIA_UNKNOWN;
+		break;
+	}
+}
+
+int board_early_init_f(void)
+{
+	return 0;
+}
+
+#define UBOOT_DATA_ADDR     0x41000000UL
+#define UBOOT_DATA_SIZE     0x80000UL
+int data_to_spiflash(void)
+{
+	static struct spi_flash *flash = NULL;
+	void *buf = NULL;
+
+	unsigned int val;
+
+	/* 0:bus; 0:cs; 1000000:max_hz; 0x3:spi_mode */
+	flash = spi_flash_probe(0, 0, 1000000, 0x3);
+	if (!flash) {
+		printf("Failed to initialize SPI flash\n");
+		return -1;  /* -1:failed */
+	}
+
+	/* erase the address range. */
+	printf("Spi flash erase...\n");
+	val = flash->erase(flash, NUM_0, UBOOT_DATA_SIZE);
+	if (val) {
+		printf("SPI flash sector erase failed\n");
+		return 1; /* 1:failed */
+	}
+
+	buf = map_physmem((unsigned long)UBOOT_DATA_ADDR,
+			UBOOT_DATA_SIZE, MAP_WRBACK);
+	if (!buf) {
+		puts("Failed to map physical memory\n");
+		return 1; /* 1:failed */
+	}
+
+	/* copy the data from RAM to FLASH */
+	printf("Spi flash write...\n");
+	val = flash->write(flash, NUM_0, UBOOT_DATA_SIZE, buf);
+	if (val) {
+		printf("SPI flash write failed, return %u\n",
+				val);
+		unmap_physmem(buf, UBOOT_DATA_SIZE);
+		return 1; /* 1:failed */
+	}
+
+	unmap_physmem(buf, UBOOT_DATA_SIZE);
+	return 0; /* 0:success */
+}
+
+int data_to_nandflash(void)
+{
+	struct mtd_info *nand_flash = NULL;
+	void *buf = NULL;
+	size_t length = UBOOT_DATA_SIZE;
+	unsigned int val;
+
+	nand_flash = nand_info[0];
+
+	printf("Nand flash erase...\n");
+	val = nand_erase(nand_flash, 0, UBOOT_DATA_SIZE);
+	if (val) {
+		printf("Nand flash erase failed\n");
+		return 1;
+	}
+
+	buf = map_physmem((unsigned long)UBOOT_DATA_ADDR,
+			UBOOT_DATA_SIZE, MAP_WRBACK);
+	if (!buf) {
+		puts("Failed to map physical memory\n");
+		return 1;
+	}
+
+	printf("Nand flash write...\n");
+	val = nand_write(nand_flash, 0, &length, buf);
+	if (val) {
+		printf("Nand flash write failed, return %u\n",
+				val);
+		unmap_physmem(buf, UBOOT_DATA_SIZE);
+		return 1;
+	}
+
+	unmap_physmem(buf, UBOOT_DATA_SIZE);
+	return 0;
+}
+
+int data_to_emmc(void)
+{
+	struct mmc *mmc = find_mmc_device(0);
+	void *buf = NULL;
+
+	if (!mmc)
+		return 1;
+
+	(void)mmc_init(mmc);
+
+	buf = map_physmem((unsigned long)UBOOT_DATA_ADDR,
+			UBOOT_DATA_SIZE, MAP_WRBACK);
+	if (!buf) {
+		puts("Failed to map physical memory\n");
+		return 1;
+	}
+
+	printf("MMC write...\n");
+	blk_dwrite(mmc_get_blk_desc(mmc), 0, (UBOOT_DATA_SIZE >> NUM_9), buf);
+	unmap_physmem(buf, UBOOT_DATA_SIZE);
+	return 0;
+}
+
+int save_bootdata_to_flash(void)
+{
+	unsigned int sd_update_flag = 0;
+	int ret = 0;
+	sd_update_flag = readl(SYS_CTRL_REG_BASE + REG_SC_GEN4);
+	if (sd_update_flag == START_MAGIC) {
+#if defined(CONFIG_FMC)
+		if (boot_media == BOOT_MEDIA_SPIFLASH) {
+			ret = data_to_spiflash();
+			if (ret != 0)
+				return ret;
+		}
+		if (boot_media == BOOT_MEDIA_NAND) {
+			ret = data_to_nandflash();
+			if (ret != 0)
+				return ret;
+		}
+#endif
+#if defined(CONFIG_SUPPORT_EMMC_BOOT)
+		if (boot_media == BOOT_MEDIA_EMMC) {
+			ret = data_to_emmc();
+			if (ret != 0)
+				return ret;
+		}
+#endif
+
+		printf("update success!\n");
+	}
+
+	return 0;
+}
+
+int auto_update_flag = 0;
+int bare_chip_program = 0;
+
+#define REG_BASE_GPIO0          0x120b0000
+#define GPIO0_0_DATA_OFST       0x4
+#define GPIO_DIR_OFST       0x400
+
+int is_bare_program(void)
+{
+	return 1;
+}
+
+int is_auto_update(void)
+{
+#if (defined CONFIG_AUTO_SD_UPDATE) || (defined CONFIG_AUTO_USB_UPDATE)
+	/* to add some judgement if neccessary */
+	unsigned int  val[NUM_3];
+
+	writel(0, REG_BASE_GPIO0 + GPIO_DIR_OFST);
+
+	val[NUM_0] = readl(REG_BASE_GPIO0 + GPIO0_0_DATA_OFST);
+	if (val[NUM_0])
+		return 0;
+
+	udelay(10000); /* delay 10000 us */
+	val[NUM_1] = readl(REG_BASE_GPIO0 + GPIO0_0_DATA_OFST);
+	udelay(10000); /* delay 10000 us */
+	val[NUM_2] = readl(REG_BASE_GPIO0 + GPIO0_0_DATA_OFST);
+	udelay(10000); /* delay 10000 us */
+
+	if (val[NUM_0] == val[NUM_1] && val[NUM_1] == val[NUM_2] && val[NUM_0] == NUM_0)
+		return 1;    /* update enable */
+	else
+		return 0;
+
+#else
+	return 0;
+#endif
+}
+
+int misc_init_r(void)
+{
+#ifdef CONFIG_RANDOM_ETHADDR
+	random_init_r();
+#endif
+	setenv("verify", "n");
+
+#if (CONFIG_AUTO_UPDATE == 1)
+	/* auto update flag */
+	if (is_auto_update())
+		auto_update_flag = 1;
+	else
+		auto_update_flag = 0;
+
+	/* bare chip program flag */
+	if (is_bare_program())
+		bare_chip_program = 1;
+	else
+		bare_chip_program = 0;
+
+#ifdef CFG_MMU_HANDLEOK
+	dcache_stop();
+#endif
+
+#ifdef CFG_MMU_HANDLEOK
+	dcache_start();
+#endif
+
+#endif
+
+#if (CONFIG_AUTO_UPDATE == 1)
+	int update_flag = -1;
+	if (auto_update_flag)
+		update_flag = do_auto_update();
+	if (bare_chip_program && !auto_update_flag)
+		save_bootdata_to_flash();
+	if (update_flag == 0)
+		do_reset(NULL, 0, 0, NULL);
+#endif
+	return 0;
+}
+
+int board_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gd->bd->bi_arch_number = MACH_TYPE_GK7605V100;
+	gd->bd->bi_boot_params = CFG_BOOT_PARAMS;
+
+	boot_flag_init();
+
+	return 0;
+}
+
+int dram_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gd->ram_size = PHYS_SDRAM_1_SIZE;
+	return 0;
+}
+
+void reset_cpu(ulong addr)
+{
+	/* 0x12345678:writing any value will cause a reset. */
+	writel(0x12345678, SYS_CTRL_REG_BASE + REG_SC_SYSRES);
+	while (1);
+}
+
+int timer_init(void)
+{
+	/*
+	 * Under uboot, 0xffffffff is set to load register,
+	 * timer_clk equals BUSCLK/2/256.
+	 * e.g. BUSCLK equals 50M, it will roll back after 0xffffffff/timer_clk
+	 * 43980s equals 12hours
+	 */
+	__raw_writel(0, TIMER0_REG_BASE + REG_TIMER_CONTROL);
+	__raw_writel(~0, TIMER0_REG_BASE + REG_TIMER_RELOAD);
+
+	/* 32 bit, periodic */
+	__raw_writel(CFG_TIMER_CTRL, TIMER0_REG_BASE + REG_TIMER_CONTROL);
+
+	return 0;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	int rc = 0;
+
+#ifdef CONFIG_NET_FEMAC
+	rc = bspeth_initialize(bis);
+#endif
+	return rc;
+}
+
+#ifdef CONFIG_GENERIC_MMC
+int board_mmc_init(bd_t *bis)
+{
+	int ret = 0;
+
+#ifdef CONFIG_GK_SDHCI
+
+#ifndef CONFIG_FMC
+	ret = sdhci_add_port(0, EMMC_BASE_REG, MMC_TYPE_MMC);
+	if (!ret) {
+		ret = bsp_mmc_init(0);
+		if (ret)
+			printf("No EMMC device found !\n");
+	}
+#else
+
+#ifdef CONFIG_AUTO_SD_UPDATE
+	ret = sdhci_add_port(0, SDIO0_BASE_REG, MMC_TYPE_SD);
+	if (ret)
+		return ret;
+
+	ret = bsp_mmc_init(0);
+	if (ret)
+		printf("No SD device found !\n");
+#endif
+
+#endif
+#endif
+
+	return ret;
+}
+#endif
+
+#ifdef CONFIG_MINI_BOOT
+void udc_connect(void)
+{
+}
+#endif
+
+#ifdef CONFIG_ARMV7_NONSEC
+void smp_set_core_boot_addr(unsigned long addr, int corenr)
+{
+}
+
+void smp_kick_all_cpus(void)
+{
+}
+
+void smp_waitloop(unsigned previous_address)
+{
+}
+#endif
+
diff -uraN u-boot-2016.11/board/goke/gk7605v100/Kconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/goke/gk7605v100/Kconfig
--- u-boot-2016.11/board/goke/gk7605v100/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/goke/gk7605v100/Kconfig	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,15 @@
+if TARGET_GK7605V100
+
+config SYS_BOARD
+	default "gk7605v100"
+
+config SYS_VENDOR
+	default "goke"
+
+config SYS_SOC
+	default "gk7605v100"
+
+config SYS_CONFIG_NAME
+	default "gk7605v100"
+
+endif
diff -uraN u-boot-2016.11/board/goke/gk7605v100/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/goke/gk7605v100/Makefile
--- u-boot-2016.11/board/goke/gk7605v100/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/goke/gk7605v100/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,8 @@
+#
+# (C) Copyright 2000-2004
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y	+= board.o
diff -uraN u-boot-2016.11/board/intel/bayleybay/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/intel/bayleybay/.gitignore
--- u-boot-2016.11/board/intel/bayleybay/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/intel/bayleybay/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1,3 +0,0 @@
-dsdt.aml
-dsdt.asl.tmp
-dsdt.c
diff -uraN u-boot-2016.11/board/intel/galileo/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/intel/galileo/.gitignore
--- u-boot-2016.11/board/intel/galileo/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/intel/galileo/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1,3 +0,0 @@
-dsdt.aml
-dsdt.asl.tmp
-dsdt.c
diff -uraN u-boot-2016.11/board/intel/minnowmax/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/intel/minnowmax/.gitignore
--- u-boot-2016.11/board/intel/minnowmax/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/intel/minnowmax/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1,3 +0,0 @@
-dsdt.aml
-dsdt.asl.tmp
-dsdt.c
diff -uraN u-boot-2016.11/board/xilinx/zynq/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/xilinx/zynq/.gitignore
--- u-boot-2016.11/board/xilinx/zynq/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/board/xilinx/zynq/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1 +0,0 @@
-/ps7_init_gpl.[ch]
diff -uraN u-boot-2016.11/.checkpatch.conf gk7205v100_u-boot-2016.11_sdk-C00SPC020/.checkpatch.conf
--- u-boot-2016.11/.checkpatch.conf	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/.checkpatch.conf	1970-01-01 03:00:00.000000000 +0300
@@ -1,27 +0,0 @@
-# Not Linux, so don't expect a Linux tree.
---no-tree
-
-# Temporary for false positive in checkpatch
---ignore COMPLEX_MACRO
-
-# For CONFIG_SYS_I2C_NOPROBES
---ignore MULTISTATEMENT_MACRO_USE_DO_WHILE
-
-# For simple_strtoul
---ignore CONSIDER_KSTRTO
-
-# For min/max
---ignore MINMAX
-
-# enable more tests
---strict
-
-# Not Linux, so we don't recommend usleep_range() over udelay()
---ignore USLEEP_RANGE
-
-# Ignore networking block comment style
---ignore NETWORKING_BLOCK_COMMENT_STYLE
-
-# Ignore "WARNING: Prefer ether_addr_copy() over memcpy() if the Ethernet
-# addresses are __aligned(2)".
---ignore PREFER_ETHER_ADDR_COPY
diff -uraN u-boot-2016.11/cmd/boot.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/boot.c
--- u-boot-2016.11/cmd/boot.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/boot.c	2021-06-07 13:01:32.000000000 +0300
@@ -34,6 +34,8 @@
 
 	printf ("## Starting application at 0x%08lX ...\n", addr);
 
+	cleanup_before_linux();
+
 	/*
 	 * pass address parameter as argv[0] (aka command name),
 	 * and all remaining args
diff -uraN u-boot-2016.11/cmd/cmd_ao.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/cmd_ao.c
--- u-boot-2016.11/cmd/cmd_ao.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/cmd_ao.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,132 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+/*
+ * audio output Support
+ */
+#include <common.h>
+#include <command.h>
+
+#include "audio_ao.h"
+
+extern int acodec_i2s_set(AUDIO_SAMPLE_RATE_E enSample);
+extern int acodec_device_init(void);
+extern int acodec_device_exit(void);
+extern int start_ao(unsigned int u32Addr, unsigned int u32Size,
+		    AUDIO_SAMPLE_RATE_E enSample, unsigned int u32Chncnt, unsigned int u32Vol);
+extern int stop_ao(void);
+extern void amp_mute(void);
+extern void amp_unmute(void);
+
+int do_startao(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned int addr, size, vol;
+	AUDIO_SAMPLE_RATE_E samplelist[]= {
+		AUDIO_SAMPLE_RATE_8000,
+		AUDIO_SAMPLE_RATE_11025,
+		AUDIO_SAMPLE_RATE_12000,
+		AUDIO_SAMPLE_RATE_16000,
+		AUDIO_SAMPLE_RATE_22050,
+		AUDIO_SAMPLE_RATE_24000,
+		AUDIO_SAMPLE_RATE_32000,
+		AUDIO_SAMPLE_RATE_44100,
+		AUDIO_SAMPLE_RATE_48000
+	};
+
+	AUDIO_SAMPLE_RATE_E enSample = AUDIO_SAMPLE_RATE_8000;
+	unsigned int ChnCnt;
+	unsigned int i;
+	unsigned int bflag = 0;
+
+	if (argc < 6) {
+		printf("Insufficient parameter!\n");
+		printf ("Usage:\n%s\n", cmdtp->usage);
+		return -1;
+	}
+
+	addr = (unsigned int)simple_strtoul(argv[1], NULL, 10);
+	size = (unsigned int)simple_strtoul(argv[2], NULL, 10);
+	enSample  = (unsigned int)simple_strtoul(argv[3], NULL, 10);
+	ChnCnt  = (unsigned int)simple_strtoul(argv[4], NULL, 10);
+	vol = (unsigned int)simple_strtoul(argv[5], NULL, 10);
+
+	if (addr%32) {
+		printf("[Error] Invalid addr parameter:0x%0x, address should be aligned by 32Byte!\n", addr);
+		return -1;
+	}
+	if (size%32) {
+		printf("[Warning] Invalid size parameter:0x%0x, size should be aligned by 32Byte!\n", size);
+		return -1;
+	}
+
+	if (size == 0) {
+		printf("[Warning] Invalid size parameter:0x%0x, size should be greater than 0!\n", size);
+		return -1;
+	}
+
+	for (i=0; i<sizeof(samplelist)/sizeof(samplelist[0]); i++) {
+		if (enSample == samplelist[i]) {
+			bflag = 1;
+			break;
+		}
+	}
+
+	if (bflag == 0) {
+		printf("[Warning] Invalid samplerate parameter.\n");
+		return -1;
+	}
+
+	if (vol > 6) {
+		printf("[Warning] Invalid volume parameter, range:[0, 6]dB!\n");
+		return -1;
+	}
+
+	if ((ChnCnt == 0) || (ChnCnt > 2)) {
+		printf("[Warning] Invalid channelnum parameter, range:[1, 2].\n");
+		return -1;
+	}
+
+	acodec_device_init();
+	acodec_i2s_set(enSample);
+	udelay(100 * 1000);
+	start_ao(addr, size, enSample, ChnCnt, vol);
+	amp_unmute();
+
+	printf("ao dev start ok!\n");
+
+	return 0;
+}
+
+int do_stopao(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	amp_mute();
+	stop_ao();
+	//acodec_device_exit();
+
+	printf("ao dev closed!\n");
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	startao,    10,	1,  do_startao,
+	"startao   - open interface of ao device.\n"
+	"\t- startao [addr size samplerate channelnum volume]",
+	"\nargs: [addr size samplerate channelnum volume]\n"
+	"\t-<addr> : address of raw audio data,align by 32Byte\n"
+	"\t-<size>: size of raw audio data,align by 32Byte\n"
+	"\t-<samplerate>: sample rate of raw audio data\n"
+	"\t-<channelnum>: channel number of raw audio data\n"
+	"\t-<volume>: audio output volume default:0dB, range:0 ~ 6dB\n"
+);
+
+U_BOOT_CMD(
+	stopao,    1,	0,  do_stopao,
+	"stopao   - close interface of ao device.\n",
+	""
+);
+
+
+
+
diff -uraN u-boot-2016.11/cmd/cmd_dec.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/cmd_dec.c
--- u-boot-2016.11/cmd/cmd_dec.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/cmd_dec.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <common.h>
+#include <command.h>
+
+#ifdef CONFIG_GODNET
+#include <godnet_vo.h>
+#endif
+
+#ifdef CONFIG_GODARM
+#include <godarm_vo.h>
+#endif
+
+extern int load_jpeg(void);
+extern int jpeg_decode(unsigned int format);
+
+int do_jpgd(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	int ret;
+	unsigned int format;
+
+	if (argc < 2) {
+		printf("Insufficient parameter!\n");
+		printf("Usage:\n%s\n", cmdtp->usage);
+		return -1;
+	}
+
+	format  = (unsigned int)simple_strtoul(argv[1], NULL, 10);
+#ifdef RGB_OUTPUT_ENABLE
+	if (format > 2) {
+#else
+	if (format != 0) {
+#endif
+		printf("Invalid parameter!\n");
+		return -1;
+	}
+
+#ifdef CONFIG_SYS_LONGHELP
+	printf("you should first set:\n%s\n", cmdtp->help);
+#endif
+
+	ret = load_jpeg();
+	if (ret != 0) {
+		printf("load jpeg err. \n");
+		//todo return 0 or ret?
+		return 0;
+	}
+	jpeg_decode(format);
+
+	printf("decode jpeg!\n");
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	decjpg,    CFG_MAXARGS, 1,  do_jpgd,
+	"jpgd   - decode jpeg picture.\n"
+	"decjpg [format]",
+	"\nargs: [format]\n"
+#ifdef RGB_OUTPUT_ENABLE
+	"\t-<format> : 0: semi-plannar yvu420, 1: ARGB1555, 2: ARGB8888\n"
+#else
+	"\t-<format> : 0: semi-plannar yvu420\n"
+#endif
+	"\t- setenv jpeg_addr     0x--------\n"
+	"\t- setenv jpeg_size     0x--------\n"
+	"\t- setenv vobuf         0x--------\n"
+	"\t- setenv jpeg_emar_buf 0x--------\n"
+);
+
+
diff -uraN u-boot-2016.11/cmd/cmd_vo.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/cmd_vo.c
--- u-boot-2016.11/cmd/cmd_vo.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/cmd_vo.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,521 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <common.h>
+#include <command.h>
+#include "common_vo.h"
+#include "vo.h"
+#if CONFIG_HDMI_SUPPORT
+#include "hdmi.h"
+#endif
+
+#define CFG_MAXARGS_SETVOBG 3
+#define CFG_MAXARGS_STARTVO 4
+#define CFG_MAXARGS_STOPVO 2
+#define CFG_MAXARGS_STARTVL 8
+#define CFG_MAXARGS_STOPVL 2
+#define CFG_MAXARGS_STARTGX 9
+#define CFG_MAXARGS_STOPGX 2
+#define CMD_VO_ARGS_BASE10 10
+#define CMD_VO_ARGS_BASE16 16
+#define INSUFFICIENT_PARAM_STR "insufficient parameter or operation not permitted!\n"
+
+#define VO_DEV_MAX_NUM 3
+
+static unsigned int g_a_interface_type[VO_DEV_MAX_NUM] = { [0 ... (VO_DEV_MAX_NUM - 1)] = 0};
+
+static unsigned int vo_get_interface_type(unsigned int dev)
+{
+    if (dev >= VO_DEV_MAX_NUM) {
+        return 0;
+    }
+    return g_a_interface_type[dev];
+}
+
+static void vo_set_interface_type(unsigned int dev, unsigned int type)
+{
+    if (dev >= VO_DEV_MAX_NUM) {
+        return;
+    }
+    g_a_interface_type[dev] = type;
+}
+
+static int vobg_parse(char *const argv[], unsigned int *dev, unsigned int *rgb)
+{
+    int ret;
+    unsigned long dev_tmp, rgb_tmp;
+    ret = strict_strtoul(argv[1], CMD_VO_ARGS_BASE10, &dev_tmp); /* 1st arg */
+    if (ret != 0) {
+        printf("parse dev failed.\n");
+        return -1;
+    }
+    ret = strict_strtoul(argv[2], CMD_VO_ARGS_BASE10, &rgb_tmp); /* 2nd arg */
+    if (ret != 0) {
+        printf("parse color failed.\n");
+        return -1;
+    }
+    *dev = (unsigned int)dev_tmp;
+    *rgb = (unsigned int)rgb_tmp;
+    return 0;
+}
+
+static int do_vobg(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+    int ret;
+    unsigned int dev, rgb;
+
+    if (argc < 3) { /* max 3 args */
+        printf("insufficient parameter!\n");
+        printf("usage:\n%s\n", cmdtp->usage);
+        return -1;
+    }
+    ret = vobg_parse(argv, &dev, &rgb);
+    if (ret != 0) {
+        printf("insufficient parameter!\n");
+        return -1;
+    }
+    ret = set_vobg(dev, rgb);
+    if (ret != 0) {
+        printf(INSUFFICIENT_PARAM_STR);
+        return -1;
+    }
+
+    printf("dev %u set background color 0x%x!\n", dev, rgb);
+
+    return 0;
+}
+
+static int startvo_parse(char *const argv[], unsigned int *dev, unsigned int *intftype, unsigned int *sync)
+{
+    int ret;
+    unsigned long dev_tmp, intftype_tmp, sync_tmp;
+    ret = strict_strtoul(argv[1], CMD_VO_ARGS_BASE10, &dev_tmp);  /* 1st arg */
+    if (ret != 0) {
+        printf("parse dev failed.\n");
+        return -1;
+    }
+    ret = strict_strtoul(argv[2], CMD_VO_ARGS_BASE10, &intftype_tmp);  /* 2nd arg */
+    if (ret != 0) {
+        printf("parse intftype failed.\n");
+        return -1;
+    }
+    ret = strict_strtoul(argv[3], CMD_VO_ARGS_BASE10, &sync_tmp);  /* 3rd arg */
+    if (ret != 0) {
+        printf("parse sync failed.\n");
+        return -1;
+    }
+    *dev = (unsigned int)dev_tmp;
+    *intftype = (unsigned int)intftype_tmp;
+    *sync = (unsigned int)sync_tmp;
+    return 0;
+}
+
+#if CONFIG_HDMI_SUPPORT
+static void do_start_hdmi(unsigned int intftype, unsigned int sync)
+{
+    if (intftype & VO_INTF_HDMI) {
+        if (intftype == (VO_INTF_HDMI | VO_INTF_MIPI)) {
+            /* start hdmi */
+            hdmi_display(sync, HDMI_VIDEO_MODE_RGB444, HDMI_VIDEO_MODE_YCBCR444);
+        } else {
+            /* start hdmi */
+            hdmi_display(sync, HDMI_VIDEO_MODE_YCBCR444, HDMI_VIDEO_MODE_YCBCR444);
+        }
+    }
+}
+#endif
+
+static int do_startvo(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+    int ret;
+    unsigned int dev, intftype, sync;
+
+    if (argc < 4) { /* max 4 args */
+        printf("insufficient parameter!\n");
+        printf("usage:\n%s\n", cmdtp->usage);
+        return -1;
+    }
+    ret = startvo_parse(argv, &dev, &intftype, &sync);
+    if (ret != 0) {
+        printf("insufficient parameter!\n");
+        return -1;
+    }
+
+    ret = start_vo(dev, intftype, sync);
+    if (ret != 0) {
+        printf(INSUFFICIENT_PARAM_STR);
+        return -1;
+    }
+
+#if CONFIG_HDMI_SUPPORT
+    do_start_hdmi(intftype, sync);
+#endif
+
+    vo_set_interface_type(dev, intftype);
+
+    printf("dev %u opened!\n", dev);
+
+    return 0;
+}
+
+static void do_stop_hdmi(unsigned int dev)
+{
+    if (vo_get_interface_type(dev) & VO_INTF_HDMI) {
+        /* stop hdmi */
+#if CONFIG_HDMI_SUPPORT
+        hdmi_stop();
+#endif
+    }
+}
+
+static void do_stop_intf(unsigned int dev)
+{
+    do_stop_hdmi(dev);
+    vo_set_interface_type(dev, 0);
+}
+
+static int stopvo_parse(char *const argv[], unsigned int *dev)
+{
+    int ret;
+    unsigned long dev_tmp;
+    ret = strict_strtoul(argv[1], CMD_VO_ARGS_BASE10, &dev_tmp);
+    if (ret != 0) {
+        printf("parse dev failed.\n");
+        return -1;
+    }
+    *dev = (unsigned int)dev_tmp;
+    return 0;
+}
+
+static int do_stopvo(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+    int ret;
+    unsigned int dev;
+    if (argc < 2) { /* max 2 args */
+        printf("insufficient parameter!\n");
+        printf("usage:\n%s\n", cmdtp->usage);
+        return -1;
+    }
+    ret = stopvo_parse(argv, &dev);
+    if (ret != 0) {
+        printf("insufficient parameter!\n");
+        return -1;
+    }
+
+    /* step1: stop vo */
+    ret = stop_vo(dev);
+    if (ret != 0) {
+        printf(INSUFFICIENT_PARAM_STR);
+        return -1;
+    }
+    /* step2: stop intf */
+    do_stop_intf(dev);
+
+    printf("dev %u closed!\n", dev);
+
+    return 0;
+}
+
+static int start_layer_parse(char *const argv[], unsigned int *layer,
+    unsigned long *addr, unsigned int *strd, gk_rect *layer_rect)
+{
+    int ret;
+    unsigned long layer_tmp, addr_tmp, strd_tmp, x_tmp, y_tmp, width_tmp, height_tmp;
+    ret = strict_strtoul(argv[1], CMD_VO_ARGS_BASE10, &layer_tmp);  /* 1st arg */
+    if (ret != 0) {
+        printf("parse layer failed.\n");
+        return -1;
+    }
+    ret = strict_strtoul(argv[2], CMD_VO_ARGS_BASE16, &addr_tmp);  /* 2nd arg */
+    if (ret != 0) {
+        printf("parse addr failed.\n");
+        return -1;
+    }
+    ret = strict_strtoul(argv[3], CMD_VO_ARGS_BASE10, &strd_tmp);  /* 3rd arg */
+    if (ret != 0) {
+        printf("parse strd failed.\n");
+        return -1;
+    }
+    ret = strict_strtoul(argv[4], CMD_VO_ARGS_BASE10, &x_tmp);  /* 4th arg */
+    if (ret != 0) {
+        printf("parse x failed.\n");
+        return -1;
+    }
+    ret = strict_strtoul(argv[5], CMD_VO_ARGS_BASE10, &y_tmp);  /* 5th arg */
+    if (ret != 0) {
+        printf("parse y failed.\n");
+        return -1;
+    }
+    ret = strict_strtoul(argv[6], CMD_VO_ARGS_BASE10, &width_tmp);  /* 6th arg */
+    if (ret != 0) {
+        printf("parse width failed.\n");
+        return -1;
+    }
+    ret = strict_strtoul(argv[7], CMD_VO_ARGS_BASE10, &height_tmp);  /* 7th arg */
+    if (ret != 0) {
+        printf("parse height failed.\n");
+        return -1;
+    }
+    *layer = (unsigned int)layer_tmp;
+    *addr = addr_tmp;
+    *strd = (unsigned int)strd_tmp;
+    layer_rect->x = (unsigned int)x_tmp;
+    layer_rect->y = (unsigned int)y_tmp;
+    layer_rect->width = (unsigned int)width_tmp;
+    layer_rect->height = (unsigned int)height_tmp;
+    return 0;
+}
+
+static int start_gx_type_parse(char *const argv[], unsigned int *type)
+{
+    int ret;
+    unsigned long type_tmp;
+    ret = strict_strtoul(argv[8], CMD_VO_ARGS_BASE10, &type_tmp);  /* 8th arg */
+    if (ret != 0) {
+        printf("parse type failed.\n");
+        return -1;
+    }
+    *type = (unsigned int)type_tmp;
+    return 0;
+}
+
+static int do_startgx(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+    int ret;
+    unsigned int layer, strd, type;
+    unsigned long addr;
+    gk_rect gx_rect;
+    if (argc < 9) { /* max 9 args */
+        printf("insufficient parameter!\n");
+        printf("usage:\n%s\n", cmdtp->usage);
+        return -1;
+    }
+    ret = start_layer_parse(argv, &layer, &addr, &strd, &gx_rect);
+    if (ret != 0) {
+        printf("insufficient parameter!\n");
+        return -1;
+    }
+
+    ret = start_gx_type_parse(argv, &type);
+    if (ret != 0) {
+        printf("insufficient parameter!\n");
+        return -1;
+    }
+
+    ret = start_gx(layer, addr, strd, gx_rect, type);
+    if (ret != 0) {
+        printf(INSUFFICIENT_PARAM_STR);
+        return -1;
+    }
+
+    printf("graphic layer %u opened!\n", layer);
+
+    return 0;
+}
+
+static int stopgx_parse(char *const argv[], unsigned int *layer)
+{
+    int ret;
+    unsigned long layer_tmp;
+    ret = strict_strtoul(argv[1], CMD_VO_ARGS_BASE10, &layer_tmp);  /* 1st arg */
+    if (ret != 0) {
+        printf("parse layer failed.\n");
+        return -1;
+    }
+    *layer = (unsigned int)layer_tmp;
+    return 0;
+}
+
+static int do_stopgx(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+    int ret;
+    unsigned int layer;
+
+    if (argc < 2) { /* max 2 args */
+        printf("insufficient parameter!\n");
+        printf("usage:\n%s\n", cmdtp->usage);
+        return -1;
+    }
+
+    ret = stopgx_parse(argv, &layer);
+    if (ret != 0) {
+        printf("insufficient parameter!\n");
+        return -1;
+    }
+
+    ret = stop_gx(layer);
+    if (ret != 0) {
+        printf(INSUFFICIENT_PARAM_STR);
+        return -1;
+    }
+
+    printf("graphic layer %u closed!\n", layer);
+
+    return 0;
+}
+
+static int do_startvl(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+    int ret;
+    unsigned int layer, strd;
+    unsigned long addr;
+    gk_rect layer_rect;
+
+    if (argc < 8) { /* max 8 args */
+        printf("insufficient parameter!\n");
+        printf("usage:\n%s\n", cmdtp->usage);
+        return -1;
+    }
+
+    ret = start_layer_parse(argv, &layer, &addr, &strd, &layer_rect);
+    if (ret != 0) {
+        printf("insufficient parameter!\n");
+        return -1;
+    }
+
+    ret = start_videolayer(layer, addr, strd, layer_rect);
+    if (ret != 0) {
+        printf(INSUFFICIENT_PARAM_STR);
+        return -1;
+    }
+
+    printf("video layer %u opened!\n", layer);
+
+    return 0;
+}
+
+static int stopvl_parse(char *const argv[], unsigned int *layer)
+{
+    int ret;
+    unsigned long layer_tmp;
+    ret = strict_strtoul(argv[1], CMD_VO_ARGS_BASE10, &layer_tmp);  /* 1st arg */
+    if (ret != 0) {
+        printf("parse layer failed.\n");
+        return -1;
+    }
+    *layer = (unsigned int)layer_tmp;
+    return 0;
+}
+
+static int do_stopvl(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+    int ret;
+    unsigned int layer;
+
+    if (argc < 2) { /* max 2 args */
+        printf("insufficient parameter!\n");
+        printf("usage:\n%s\n", cmdtp->usage);
+        return -1;
+    }
+    ret = stopvl_parse(argv, &layer);
+    if (ret != 0) {
+        printf("insufficient parameter!\n");
+        return -1;
+    }
+
+    ret = stop_videolayer(layer);
+    if (ret != 0) {
+        printf(INSUFFICIENT_PARAM_STR);
+        return -1;
+    }
+
+    printf("video layer %u closed!\n", layer);
+
+    return 0;
+}
+
+#define USAGE_DEV_STRING                          \
+    "\t-<dev> : 0: DHD0,1: DHD1,2: DSD0\n"
+
+#define USAGE_INTF_STRING                                                          \
+    "\t-<intftype>: 1(CVBS),2(VGA),8(BT.1120),16(HDMI)\n"                           \
+    "\t\t32(RGB_6BIT),64(RGB_8BIT),128(RGB_16BIT),256(RGB_18BIT),512(RGB_24BIT)\n"
+
+#define USAGE_GX_STRING                            \
+    "\t-<layer>   : 4(G0), 5(G1), 7(G3)\n"
+
+#define USAGE_VL_STRING                            \
+    "\t-<layer>   : 0(V0), 1(V1), 3(V3)\n"
+
+#define USAGE_GX_TYPE                              \
+    "\t-<type>    : 0(argb1555), 1(bmp1555)\n"
+
+#define USAGE_START_VO                                                             \
+    "\nargs: [dev, intftype, sync]\n"                                              \
+    USAGE_DEV_STRING                                                               \
+    USAGE_INTF_STRING                                                              \
+    "\t-<sync>:\n"                                                                 \
+    "\t\t0(PAL),          1(NTSC),         2(960H_PAL),     3(960H_NTSC)\n"        \
+    "\t\t4(640x480_60),   5(480P60),       6(576P50),       7(800x600_60)\n"       \
+    "\t\t8(1024x768_60),  9(720P50),       10(720P60),      11(1280x800_60)\n"     \
+    "\t\t12(1280x1024_60),13(1366x768_60), 14(1400x1050_60),15(1440x900_60)\n"     \
+    "\t\t16(1600x1200_60),17(1680x1050_60),18(1080P24),     19(1080P25)\n"         \
+    "\t\t20(1080P30),     21(1080I50),     22(1080I60),     23(1080P50)\n"         \
+    "\t\t24(1080P60),     25(1920x1200_60),26(1920x2160_30),27(2560x1440_30)\n"    \
+    "\t\t28(2560x1440_60),29(2560x1600_60),30(3840x2160_24),31(3840x2160_25)\n"    \
+    "\t\t32(3840x2160_30),33(3840x2160_50),34(3840x2160_60),35(4096x2160_24)\n"    \
+    "\t\t36(4096x2160_25),37(4096x2160_30),38(4096x2160_50),39(4096x2160_60)\n"    \
+    "\t\t40(7680x4320_30),41(240x320_50),  42(320x240_50),  43(240x320_60)\n"      \
+    "\t\t44(320x240_60),  45(800x600_50),  46(720x1280_60), 47(1080x1920_60)\n"    \
+    "\t\t48(user)\n"
+
+#define USAGE_STOP_VO                             \
+    "\nargs: [dev]\n"                             \
+    USAGE_DEV_STRING
+
+#define USAGE_START_GX                            \
+    "\nargs: [layer, addr, stride, x, y, w, h, type]\n" \
+    USAGE_GX_STRING                               \
+    "\t-<addr>    : picture address\n"            \
+    "\t-<stride>  : picture stride\n"             \
+    "\t-<x,y,w,h> : display area\n"               \
+    USAGE_GX_TYPE
+
+#define USAGE_STOP_GX                             \
+    "\nargs: [layer]\n"                           \
+    USAGE_GX_STRING
+
+#define USAGE_START_VL                            \
+    "\nargs: [layer, addr, stride, x, y, w, h]\n" \
+    USAGE_VL_STRING                               \
+    "\t-<addr>    : picture address\n"            \
+    "\t-<stride>  : picture stride\n"             \
+    "\t-<x,y,w,h> : display area\n"
+
+#define USAGE_STOP_VL                             \
+   "\nargs: [layer]\n"                            \
+    USAGE_VL_STRING
+
+#define USAGE_SET_VO_BG                           \
+   "\nargs: [dev, color]\n"                       \
+    USAGE_DEV_STRING                              \
+   "\t-<color>: rgb color space\n"
+
+U_BOOT_CMD(startvo, CFG_MAXARGS_STARTVO, 1, do_startvo,
+           "startvo   - open vo device with a certain output interface.\n"
+           "\t- startvo [dev intftype sync]", USAGE_START_VO);
+
+U_BOOT_CMD(stopvo, CFG_MAXARGS_STOPVO, 1, do_stopvo,
+           "stopvo   - close interface of vo device.\n"
+           "\t- stopvo [dev]", USAGE_STOP_VO);
+
+U_BOOT_CMD(startgx, CFG_MAXARGS_STARTGX, 1, do_startgx,
+           "startgx   - open graphics layer.\n"
+           "\t- startgx [layer addr stride x y w h type]", USAGE_START_GX);
+
+U_BOOT_CMD(stopgx, CFG_MAXARGS_STOPGX, 1, do_stopgx,
+           "stopgx   - close graphics layer.\n"
+           "\t- stopgx [layer]", USAGE_STOP_GX);
+
+U_BOOT_CMD(startvl, CFG_MAXARGS_STARTVL, 1, do_startvl,
+           "startvl   - open video layer.\n"
+           "\t- startvl [layer addr stride x y w h]", USAGE_START_VL);
+
+U_BOOT_CMD(stopvl, CFG_MAXARGS_STOPVL, 1, do_stopvl,
+           "stopvl   - close video layer.\n"
+           "\t- stopvl [layer]", USAGE_STOP_VL);
+
+U_BOOT_CMD(setvobg, CFG_MAXARGS_SETVOBG, 1, do_vobg,
+           "setvobg   - set vo backgroud color.\n"
+           "\t- setvobg [dev color]", USAGE_SET_VO_BG);
diff -uraN u-boot-2016.11/cmd/cmd_vo_gk7205v200.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/cmd_vo_gk7205v200.c
--- u-boot-2016.11/cmd/cmd_vo_gk7205v200.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/cmd_vo_gk7205v200.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,339 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <common.h>
+#include <command.h>
+#include "gk7205v200_vo.h"
+
+extern int set_vobg(unsigned int dev, unsigned int rgb);
+extern int start_vo(unsigned int dev, unsigned int type, unsigned int sync);
+extern int stop_vo(unsigned int dev);
+extern int start_videolayer(unsigned int layer, unsigned long addr, unsigned int strd, gk_vo_rect layer_rect);
+extern int stop_videolayer(unsigned int layer);
+extern int start_gx(unsigned int layer, unsigned long addr, unsigned int strd, gk_vo_rect gx_rect);
+extern int stop_gx(unsigned int layer);
+
+static int check_vo_support(unsigned int dev, unsigned int type, unsigned int sync)
+{
+    /* check interface type, ONLY VGA & HDMI interface is supported. */
+    if (dev == VO_DEV_DHD0) {
+        if ((type & (~(VO_INTF_BT1120 | VO_INTF_BT656 | VO_INTF_LCD_6BIT | VO_INTF_LCD_8BIT | VO_INTF_LCD_16BIT))) ||
+            (type == 0)) {
+            printf("hd%u only supports BT.656,BT.1120,LCD_6BIT/8BIT/16BIT intftype, intf %u is illegal!\n",
+                   dev, type);
+            return -1;
+        }
+    } else {
+        printf("unknow dev(%u)!\n", dev);
+        return -1;
+    }
+
+    if (sync == VO_OUTPUT_USER) {
+        return 0;
+    }
+
+    if (VO_INTF_BT1120 & type) {
+        if ((((sync < VO_OUTPUT_1080P24) && (sync > VO_OUTPUT_1080I60)) ||
+             ((sync < VO_OUTPUT_576P50) && (sync > VO_OUTPUT_1024x768_60))) &&
+            (sync != VO_OUTPUT_640x480_60)) {
+            printf("vo%u's intfsync %u illegal!\n", dev, sync);
+            return -1;
+        }
+    }
+
+    if (VO_INTF_BT656 & type) {
+        if ((sync != VO_OUTPUT_PAL) && (sync != VO_OUTPUT_NTSC)) {
+            printf("vo%u's intfsync %u illegal!\n", dev, sync);
+            return -1;
+        }
+    }
+
+    if (VO_INTF_LCD_8BIT & type) {
+        if (VO_OUTPUT_320x240_60 != sync) {
+            printf("vo%u's intfsync %u illegal!\n", dev, sync);
+            return -1;
+        }
+    }
+
+    if (VO_INTF_LCD_6BIT & type) {
+        if ((sync < VO_OUTPUT_320x240_50) || (sync > VO_OUTPUT_240x320_50)) {
+            printf("vo%u's intfsync %u illegal!\n", dev, sync);
+            return -1;
+        }
+    }
+
+    if (VO_INTF_LCD_16BIT & type) {
+        if (VO_OUTPUT_240x320_60 != sync) {
+            printf("vo%u's intfsync %u illegal!\n", dev, sync);
+            return -1;
+        }
+    }
+
+    return 0;
+}
+
+static int do_vobg(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+    unsigned int dev, rgb;
+
+    if (argc < 3) {
+        printf("insufficient parameter!\n");
+        printf("usage:\n%s\n", cmdtp->usage);
+        return -1;
+    }
+
+    dev = (unsigned int)simple_strtoul(argv[1], NULL, 10);
+    rgb = (unsigned int)simple_strtoul(argv[2], NULL, 10);
+    if (dev >= VO_DEV_BUTT) {
+        printf("invalid parameter!\n");
+        return -1;
+    }
+
+    set_vobg(dev, rgb);
+
+    printf("dev %u set background color!\n", dev);
+
+    return 0;
+}
+
+static int do_startvo(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+    unsigned int dev, intftype, sync;
+
+    if (argc < 4) {
+        printf("insufficient parameter!\n");
+        printf("usage:\n%s\n", cmdtp->usage);
+        return -1;
+    }
+
+    dev = (unsigned int)simple_strtoul(argv[1], NULL, 10);
+    intftype = (unsigned int)simple_strtoul(argv[2], NULL, 10);
+    sync = (unsigned int)simple_strtoul(argv[3], NULL, 10);
+    if ((dev >= VO_DEV_BUTT) || (sync >= VO_OUTPUT_BUTT)) {
+        printf("invalid parameter!\n");
+        return -1;
+    }
+
+    if (check_vo_support(dev, intftype, sync)) {
+        printf("unsupport parameter!\n");
+        return -1;
+    }
+
+    start_vo(dev, intftype, sync);
+
+    printf("dev %u opened!\n", dev);
+
+    return 0;
+}
+
+static int do_stopvo(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+    unsigned int dev;
+    if (argc < 2) {
+        printf("insufficient parameter!\n");
+        printf("usage:\n%s\n", cmdtp->usage);
+        return -1;
+    }
+
+    dev = (unsigned int)simple_strtoul(argv[1], NULL, 10);
+    if (dev >= VO_DEV_BUTT) {
+        printf("invalid parameter!\n");
+        return -1;
+    }
+
+    stop_vo(dev);
+
+    printf("dev %u closed!\n", dev);
+
+    return 0;
+}
+
+static int do_startvl(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+    unsigned int layer, strd, x, y, w, h;
+    unsigned long addr;
+    gk_vo_rect layer_rect;
+
+    if (argc < 8) {
+        printf("insufficient parameter!\n");
+        printf("usage:\n%s\n", cmdtp->usage);
+        return -1;
+    }
+
+    layer = (unsigned int)simple_strtoul(argv[1], NULL, 10);
+    addr = (unsigned long)simple_strtoul(argv[2], NULL, 16);
+    strd = (unsigned int)simple_strtoul(argv[3], NULL, 10);
+    x = (unsigned int)simple_strtoul(argv[4], NULL, 10);
+    y = (unsigned int)simple_strtoul(argv[5], NULL, 10);
+    w = (unsigned int)simple_strtoul(argv[6], NULL, 10);
+    h = (unsigned int)simple_strtoul(argv[7], NULL, 10);
+
+    if ((layer != VO_LAYER_VHD0) ||
+        (strd > (PIC_MAX_WIDTH * 2)) ||
+        ((x > PIC_MAX_WIDTH) || (x & 0x1)) ||
+        ((y > PIC_MAX_HEIGHT) || (y & 0x1)) ||
+        ((w > PIC_MAX_WIDTH) || (w & 0x1) || (w < PIC_MIN_LENTH)) ||
+        ((h > PIC_MAX_HEIGHT) || (h & 0x1) || (h < PIC_MIN_LENTH))) {
+        printf("invalid parameter!\n");
+        return -1;
+    }
+
+    layer_rect.x = x;
+    layer_rect.y = y;
+    layer_rect.w = w;
+    layer_rect.h = h;
+
+    start_videolayer(layer, addr, strd, layer_rect);
+
+    printf("video layer %u opened!\n", layer);
+
+    return 0;
+}
+
+static int do_stopvl(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+    unsigned int layer;
+
+    if (argc < 2) {
+        printf("insufficient parameter!\n");
+        printf("usage:\n%s\n", cmdtp->usage);
+        return -1;
+    }
+
+    layer = (unsigned int)simple_strtoul(argv[1], NULL, 10);
+
+    if (layer > VO_LAYER_VHD0) {
+        printf("invalid parameter!\n");
+        return -1;
+    }
+
+    stop_videolayer(layer);
+
+    printf("video layer %u closed!\n", layer);
+
+    return 0;
+}
+
+static int do_startgx(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+    unsigned int layer, strd, x, y, w, h;
+    unsigned long addr;
+    gk_vo_rect gx_rect;
+    if (argc < 8) {
+        printf("insufficient parameter!\n");
+        printf("usage:\n%s\n", cmdtp->usage);
+        return -1;
+    }
+
+    layer = (unsigned int)simple_strtoul(argv[1], NULL, 10);
+    addr = (unsigned long)simple_strtoul(argv[2], NULL, 16);
+    strd = (unsigned int)simple_strtoul(argv[3], NULL, 10);
+    x = (unsigned int)simple_strtoul(argv[4], NULL, 10);
+    y = (unsigned int)simple_strtoul(argv[5], NULL, 10);
+    w = (unsigned int)simple_strtoul(argv[6], NULL, 10);
+    h = (unsigned int)simple_strtoul(argv[7], NULL, 10);
+
+    if ((layer != VO_GRAPHC_G0) ||
+        ((x > PIC_MAX_WIDTH) || (x & 0x1)) ||
+        ((y > PIC_MAX_HEIGHT) || (y & 0x1)) ||
+        ((w > PIC_MAX_WIDTH) || (w & 0x1) || (w < PIC_MIN_LENTH)) ||
+        ((h > PIC_MAX_HEIGHT) || (h & 0x1) || (h < PIC_MIN_LENTH))) {
+        printf("invalid parameter!\n");
+        return -1;
+    }
+
+    gx_rect.x = x;
+    gx_rect.y = y;
+    gx_rect.w = w;
+    gx_rect.h = h;
+
+    start_gx(layer, addr, strd, gx_rect);
+
+    printf("graphic layer %u opened!\n", layer);
+
+    return 0;
+}
+
+static int do_stopgx(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+    unsigned int layer;
+
+    if (argc < 2) {
+        printf("insufficient parameter!\n");
+        printf("usage:\n%s\n", cmdtp->usage);
+        return -1;
+    }
+
+    layer = (unsigned int)simple_strtoul(argv[1], NULL, 10);
+
+    if (layer >= VO_GRAPHC_BUTT) {
+        printf("invalid parameter!\n");
+        return -1;
+    }
+
+    stop_gx(layer);
+
+    printf("graphic layer %u closed!\n", layer);
+
+    return 0;
+}
+
+U_BOOT_CMD(startvo, CFG_MAXARGS, 1, do_startvo,
+       "startvo   - open vo device with a certain output interface.\n"
+       "\t- startvo [dev intftype sync]",
+       "\nargs: [dev, intftype, sync]\n"
+       "\t-<dev> : 0: DHD0\n"
+       "\t-<intftype>: 8(BT.656),16(BT.1120),512(LCD_6BIT),1024(LCD_8BIT),2048(LCD_16BIT)\n"
+       "\t-<sync>: typical value:\n"
+       "\t\tfor BT.656:\n"
+       "\t\t\t0(PAL),           1(NTSC)\n"
+       "\t\tfor BT.1120:\n"
+       "\t\t\t2(1080P24),       3(1080P25),       4(1080P30),       5(720P50)\n"
+       "\t\t\t6(720P60),        7(1080I50),       8(1080I60),       11(576P50)\n"
+       "\t\t\t12(480P60),       13(800x600),      14(1024x768),     22(640x480)\n"
+       "\t\tfor LCD:\n"
+       "\t\t\t39(320x240P60),    40(320x240P50),   41(240x320P50), 42(240x320P60)\n");
+
+U_BOOT_CMD(stopvo, CFG_MAXARGS, 1, do_stopvo,
+       "stopvo   - close interface of vo device.\n"
+       "\t- stopvo [dev]",
+       "\nargs: [dev]\n"
+       "\t-<dev> : 0(HD0)\n");
+
+U_BOOT_CMD(startvl, CFG_MAXARGS, 1, do_startvl,
+       "startvl   - open video layer.\n"
+       "\t- startvl [layer addr stride x y w h]\n",
+       "\nargs: [layer, addr, stride, x, y, w, h]\n"
+       "\t-<layer>   : 0(V0)\n"
+       "\t-<addr>    : picture address\n"
+       "\t-<stride>  : picture stride\n"
+       "\t-<x,y,w,h> : display area\n");
+
+U_BOOT_CMD(stopvl, CFG_MAXARGS, 1, do_stopvl,
+       "stopvl   - close video layer.\n"
+       "\t- stopvl [layer]",
+       "\nargs: [layer]\n"
+       "\t-<layer> : 0(V0)\n");
+
+U_BOOT_CMD(setvobg, CFG_MAXARGS, 1, do_vobg,
+       "setvobg   - set vo backgroud color.\n"
+       "\t- setvobg [dev color]",
+       "\nargs: [dev, color]\n"
+       "\t-<dev> : 0(HD0)\n"
+       "\t-<color>: rgb color space\n");
+
+U_BOOT_CMD(startgx, CFG_MAXARGS, 1, do_startgx,
+       "startgx   - open graphics layer.\n"
+       "\t- startgx [layer addr stride x y w h]\n",
+       "\nargs: [layer, addr, stride, x, y, w, h]\n"
+       "\t-<layer>   : 0(G0)\n"
+       "\t-<addr>    : picture address\n"
+       "\t-<stride>  : picture stride\n"
+       "\t-<x,y,w,h> : display area\n");
+
+U_BOOT_CMD(stopgx, CFG_MAXARGS, 1, do_stopgx,
+       "stopgx   - close graphics layer.\n"
+       "\t- stopgx [layer]",
+       "\nargs: [layer]\n"
+       "\t-<layer> : 0(G0)\n");
diff -uraN u-boot-2016.11/cmd/getinfo.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/getinfo.c
--- u-boot-2016.11/cmd/getinfo.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/getinfo.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,130 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <common.h>
+#include <command.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <version.h>
+
+#include <asm/io.h>
+
+#if defined(CONFIG_FMC_SPI_NAND) \
+	|| defined(CONFIG_FMC_NAND)
+#include <nfc_common.h>
+#endif
+
+/*****************************************************************************/
+#if defined(CONFIG_FMC_SPI_NAND) || defined(CONFIG_FMC_NAND) || \
+	defined(CONFIG_FMC_SPI_NOR)
+static int print_mtd_info(const struct mtd_info_ex *mtd_info,const char *cmd)
+{
+	unsigned int len, ix;
+
+	if (mtd_info == NULL || mtd_info->type == 0) { /* no find spi/nand */
+		printf("no find ");
+		if (*cmd == 's')
+			printf("spi");
+		else if (*cmd == 'n')
+			printf("nand");
+		printf("\n");
+	} else {
+		printf("Block:%sB ", ultohstr(mtd_info->erasesize));
+		printf("Chip:%sB*%d ",
+			   ultohstr(mtd_info->chipsize),
+			   mtd_info->numchips);
+
+		if (*cmd == 'n') {
+			printf("Page:%sB ", ultohstr(mtd_info->pagesize));
+			printf("OOB:%sB ", ultohstr(mtd_info->oobsize));
+#if defined(CONFIG_FMC_SPI_NAND) || defined(CONFIG_FMC_NAND)
+#ifdef CONFIG_CMD_NAND
+			printf("ECC:%s ", nand_ecc_name(mtd_info->ecctype));
+#endif
+#else
+			printf("ECC:%s ",
+				   get_ecctype_str((mtd_info->ecctype & 0x7)));
+#endif
+		}
+		printf("\nID:");
+
+		len = (mtd_info->id_length > 8 ? 8 : mtd_info->id_length); /* 8:len of max id */
+		for (ix = 0; ix < len; ix++)
+			printf("0x%02X ", mtd_info->ids[ix]);
+		printf("\nName:\"%s\"\n", mtd_info->name);
+	}
+
+	return 0;
+}
+#endif
+
+static int do_getinfo(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	char *cmd = NULL;
+
+	if (argc < 2) { /* 2:len of argv */
+		cmd_usage(cmdtp);
+		return -1;
+	}
+
+	cmd = argv[1];
+	if (strcmp(cmd, "bootmode") == 0) {
+		switch (get_boot_media()) {
+		default:
+		case BOOT_MEDIA_UNKNOWN:
+			printf("Boot from unknown device,"
+				   " please check your hardware config.\n");
+			return -1;
+
+		case BOOT_MEDIA_NAND:
+			printf("nand\n");
+			break;
+
+		case BOOT_MEDIA_SPIFLASH:
+			printf("spi\n");
+			break;
+
+		case BOOT_MEDIA_EMMC:
+			printf("emmc\n");
+			break;
+
+		case BOOT_MEDIA_UFS:
+			printf("ufs\n");
+			break;
+		}
+		return 0;
+	}
+
+	if (strcmp(cmd, "version") == 0) {
+		printf("version: %s\n", U_BOOT_VERSION);
+		return 0;
+	}
+
+#if defined(CONFIG_FMC_SPI_NAND) || defined(CONFIG_FMC_NAND)
+	if (strcmp(cmd, "nand") == 0) {
+		struct mtd_info_ex *mtd_info = NULL;
+		mtd_info = get_nand_info();
+		return print_mtd_info(mtd_info, cmd);
+	}
+#endif
+
+#ifdef CONFIG_FMC_SPI_NOR
+	if (strcmp(cmd, "spi") == 0) {
+		struct mtd_info_ex *mtd_info = NULL;
+		mtd_info = get_spiflash_info();
+		return print_mtd_info(mtd_info, cmd);
+	}
+#endif
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	getinfo, CONFIG_SYS_MAXARGS, 1, do_getinfo,
+	"print hardware information",
+	"bootmode - get start memeory type e.g. nand/spi etc\n"
+	"getinfo nand - get nand flash information\n"
+	"getinfo spi - get spi flash information\n"
+	"getinfo version - get system version\n"
+);
diff -uraN u-boot-2016.11/cmd/i2c.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/i2c.c
--- u-boot-2016.11/cmd/i2c.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/i2c.c	2021-06-07 13:01:32.000000000 +0300
@@ -200,7 +200,7 @@
  *
  * Returns I2C bus speed in Hz.
  */
-#if !defined(CONFIG_SYS_I2C) && !defined(CONFIG_DM_I2C)
+#if !defined(CONFIG_SYS_I2C) && !defined(CONFIG_DM_I2C) && !defined(CONFIG_GK_I2C)
 /*
  * TODO: Implement architecture-specific get/set functions
  * Should go away, if we switched completely to new multibus support
@@ -958,7 +958,7 @@
 	if (argc == 2)
 		addr = simple_strtol(argv[1], 0, 16);
 
-	puts ("Valid chip addresses:");
+	puts ("Valid i2c num:\n");
 	for (j = 0; j < 128; j++) {
 		if ((0 <= addr) && (j != addr))
 			continue;
@@ -1784,7 +1784,7 @@
  * on error.
  */
 #if defined(CONFIG_SYS_I2C) || defined(CONFIG_I2C_MULTI_BUS) || \
-		defined(CONFIG_DM_I2C)
+		defined(CONFIG_DM_I2C) || defined(CONFIG_GK_I2C)
 static int do_i2c_bus_num(cmd_tbl_t *cmdtp, int flag, int argc,
 				char * const argv[])
 {
@@ -1910,6 +1910,9 @@
  */
 static int do_i2c_reset(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
 {
+#ifdef CONFIG_GK_I2C
+	printf("Error: Not supported!!\n");
+#else
 #if defined(CONFIG_DM_I2C)
 	struct udevice *bus;
 
@@ -1924,6 +1927,7 @@
 #else
 	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
 #endif
+#endif
 	return 0;
 }
 
@@ -1933,7 +1937,7 @@
 #endif
 	U_BOOT_CMD_MKENT(crc32, 3, 1, do_i2c_crc, "", ""),
 #if defined(CONFIG_SYS_I2C) || \
-	defined(CONFIG_I2C_MULTI_BUS) || defined(CONFIG_DM_I2C)
+	defined(CONFIG_I2C_MULTI_BUS) || defined(CONFIG_DM_I2C) || defined(CONFIG_GK_I2C)
 	U_BOOT_CMD_MKENT(dev, 1, 1, do_i2c_bus_num, "", ""),
 #endif  /* CONFIG_I2C_MULTI_BUS */
 #if defined(CONFIG_I2C_EDID)
@@ -2009,8 +2013,8 @@
 #endif
 	"crc32 chip address[.0, .1, .2] count - compute CRC32 checksum\n"
 #if defined(CONFIG_SYS_I2C) || \
-	defined(CONFIG_I2C_MULTI_BUS) || defined(CONFIG_DM_I2C)
-	"i2c dev [dev] - show or set current I2C bus\n"
+	defined(CONFIG_I2C_MULTI_BUS) || defined(CONFIG_DM_I2C) || defined(CONFIG_GK_I2C)
+	"i2c dev [i2c num] - show or set current I2C device\n"
 #endif  /* CONFIG_I2C_MULTI_BUS */
 #if defined(CONFIG_I2C_EDID)
 	"i2c edid chip - print EDID configuration information\n"
@@ -2020,7 +2024,7 @@
 	"i2c mm chip address[.0, .1, .2] - write to I2C device (auto-incrementing)\n"
 	"i2c mw chip address[.0, .1, .2] value [count] - write to I2C device (fill)\n"
 	"i2c nm chip address[.0, .1, .2] - write to I2C device (constant address)\n"
-	"i2c probe [address] - test for and show device(s) on the I2C bus\n"
+	"i2c probe [i2c num] - eg, i2c probe 10, init the i2c 10 \n"
 	"i2c read chip address[.0, .1, .2] length memaddress - read to memory\n"
 	"i2c write memaddress chip address[.0, .1, .2] length [-s] - write memory\n"
 	"          to I2C; the -s option selects bulk write in a single transaction\n"
diff -uraN u-boot-2016.11/cmd/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/Makefile
--- u-boot-2016.11/cmd/Makefile	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -104,9 +104,11 @@
 ifdef CONFIG_PCI
 obj-$(CONFIG_CMD_PCI) += pci.o
 endif
+ifndef CONFIG_MINI_BOOT
 obj-y += pcmcia.o
+endif #CONFIG_MINI_BOOT
 obj-$(CONFIG_CMD_PORTIO) += portio.o
-obj-$(CONFIG_CMD_PXE) += pxe.o
+#obj-$(CONFIG_CMD_PXE) += pxe.o
 obj-$(CONFIG_CMD_QFW) += qfw.o
 obj-$(CONFIG_CMD_READ) += read.o
 obj-$(CONFIG_CMD_REGINFO) += reginfo.o
@@ -142,6 +144,7 @@
 obj-$(CONFIG_CMD_FASTBOOT) += fastboot.o
 obj-$(CONFIG_CMD_FS_UUID) += fs_uuid.o
 
+obj-$(CONFIG_CMD_USB) += usbtftp.o
 obj-$(CONFIG_CMD_USB_MASS_STORAGE) += usb_mass_storage.o
 obj-$(CONFIG_CMD_THOR_DOWNLOAD) += thordown.o
 obj-$(CONFIG_CMD_XIMG) += ximg.o
@@ -163,3 +166,7 @@
 
 # core command
 obj-y += nvedit.o
+
+obj-y += getinfo.o
+
+sinclude $(srctree)/cmd/Makefile-product
diff -uraN u-boot-2016.11/cmd/Makefile-product gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/Makefile-product
--- u-boot-2016.11/cmd/Makefile-product	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/Makefile-product	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,28 @@
+ifeq ($(CONFIG_AUDIO_ENABLE),y)
+obj-y += cmd_ao.o
+endif
+
+# Osd command
+ifeq ($(CONFIG_OSD_ENABLE),y)
+# for dec
+ifneq ($(CONFIG_PRODUCTNAME),"gk7205v300")
+ifneq ($(CONFIG_PRODUCTNAME),"gk7205v200")
+ifneq ($(CONFIG_PRODUCTNAME),"gk7202v300")
+ifneq ($(CONFIG_PRODUCTNAME),"gk7605v100")
+obj-y += cmd_dec.o
+endif
+endif
+endif
+endif
+
+# for vo
+ifeq ($(CONFIG_PRODUCTNAME),"gk7205v200")
+obj-y += cmd_vo_gk7205v200.o
+else ifeq ($(CONFIG_PRODUCTNAME),"gk7205v300")
+obj-y += cmd_vo_gk7205v200.o
+else ifeq ($(CONFIG_PRODUCTNAME),"gk7202v300")
+obj-y += cmd_vo_gk7205v200.o
+else ifeq ($(CONFIG_PRODUCTNAME),"gk7605v100")
+obj-y += cmd_vo_gk7205v200.o
+endif
+endif
diff -uraN u-boot-2016.11/cmd/mmc.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/mmc.c
--- u-boot-2016.11/cmd/mmc.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/mmc.c	2021-06-07 13:01:32.000000000 +0300
@@ -8,13 +8,20 @@
 #include <common.h>
 #include <command.h>
 #include <console.h>
+#include <memalign.h>
 #include <mmc.h>
 
+#define RESERVE_TWO_DECIMAL    100
+#define DIV_ONE_MB             20
+
+#ifdef CONFIG_EXT4_SPARSE
+extern int ext4_unsparse(struct mmc *mmc, u32 dev, u8 *pbuf, u32 blk, u32 cnt);
+#endif
 static int curr_device = -1;
 
 static void print_mmcinfo(struct mmc *mmc)
 {
-	int i;
+	unsigned int i;
 
 	printf("Device: %s\n", mmc->cfg->name);
 	printf("Manufacturer ID: %x\n", mmc->cid[0] >> 24);
@@ -34,8 +41,7 @@
 	printf("\n");
 
 	printf("High Capacity: %s\n", mmc->high_capacity ? "Yes" : "No");
-	puts("Capacity: ");
-	print_size(mmc->capacity, "\n");
+	print_to_tool("Capacity: %lld\r\n", mmc->capacity);
 
 	printf("Bus Width: %d-bit%s\n", mmc->bus_width,
 			mmc->ddr_mode ? " DDR" : "");
@@ -82,6 +88,41 @@
 		}
 	}
 }
+static int print_mmcreg(struct mmc *mmc)
+{
+	int i, err;
+	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, MMC_MAX_BLOCK_LEN);
+
+	printf("OCR register: %08x\n", mmc->ocr);
+	printf("CID register: %08x %08x %08x %08x\n",
+			mmc->cid[0], mmc->cid[1], mmc->cid[2], mmc->cid[3]);
+	printf("CSD register: %08x %08x %08x %08x\n",
+			mmc->csd[0], mmc->csd[1], mmc->csd[2], mmc->csd[3]);
+	printf("RCA register: %08x\n", mmc->rca);
+	if (!IS_SD(mmc)) {
+		err = mmc_send_ext_csd(mmc, ext_csd);
+		if (err) {
+			printf("Get ext_csd fail!\n");
+			return -1;
+		}
+
+		printf("Extended CSD register:\n");
+		for (i = 0; i < 512; i += 8)
+			printf("%03d: %02x %02x %02x %02x"
+					" %02x %02x %02x %02x\n",
+					i,
+					ext_csd[i],
+					ext_csd[i+1],
+					ext_csd[i+2],
+					ext_csd[i+3],
+					ext_csd[i+4],
+					ext_csd[i+5],
+					ext_csd[i+6],
+					ext_csd[i+7]);
+	}
+	printf("\n");
+	return 0;
+}
 static struct mmc *init_mmc_device(int dev, bool force_init)
 {
 	struct mmc *mmc;
@@ -117,6 +158,23 @@
 	print_mmcinfo(mmc);
 	return CMD_RET_SUCCESS;
 }
+static int do_mmcreg(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	struct mmc *mmc;
+	int dev;
+
+	if (argc != 2)
+		return CMD_RET_USAGE;
+
+	dev = simple_strtoul(argv[1], NULL, 16);
+
+	mmc = init_mmc_device(dev, false);
+	if (!mmc)
+		return CMD_RET_FAILURE;
+
+	print_mmcreg(mmc);
+	return CMD_RET_SUCCESS;
+}
 
 #ifdef CONFIG_SUPPORT_EMMC_RPMB
 static int confirm_key_prog(void)
@@ -273,26 +331,39 @@
 	struct mmc *mmc;
 	u32 blk, cnt, n;
 	void *addr;
+	int dev;
+	unsigned long long start_ticks, end_ticks;
+	unsigned long long size, speed_byte, speed_tmp;
 
-	if (argc != 4)
+	if (argc != 5)
 		return CMD_RET_USAGE;
 
-	addr = (void *)simple_strtoul(argv[1], NULL, 16);
-	blk = simple_strtoul(argv[2], NULL, 16);
-	cnt = simple_strtoul(argv[3], NULL, 16);
+	dev = simple_strtoul(argv[1], NULL, 16);
+	addr = (void *)simple_strtoul(argv[2], NULL, 16);
+	blk = simple_strtoul(argv[3], NULL, 16);
+	cnt = simple_strtoul(argv[4], NULL, 16);
 
-	mmc = init_mmc_device(curr_device, false);
+	mmc = init_mmc_device(dev, false);
 	if (!mmc)
 		return CMD_RET_FAILURE;
 
+	curr_device = dev;
 	printf("\nMMC read: dev # %d, block # %d, count %d ... ",
 	       curr_device, blk, cnt);
 
+	start_ticks = get_ticks();
 	n = blk_dread(mmc_get_blk_desc(mmc), blk, cnt, addr);
+	end_ticks = get_ticks();
 	/* flush cache after read */
-	flush_cache((ulong)addr, cnt * 512); /* FIXME */
+	flush_cache((ulong)(uintptr_t)addr, cnt * MMC_MAX_BLOCK_LEN);
 	printf("%d blocks read: %s\n", n, (n == cnt) ? "OK" : "ERROR");
 
+	size = mmc->read_bl_len * cnt;
+	speed_byte = (size * CONFIG_SYS_HZ * CONFIG_SYS_HZ) / (end_ticks - start_ticks);
+	speed_tmp = (speed_byte & 0xFFFFF) * RESERVE_TWO_DECIMAL;
+	printf("%llu.%02llu MB/s\n", speed_byte >> DIV_ONE_MB,
+	       speed_tmp >> DIV_ONE_MB);
+
 	return (n == cnt) ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
 }
 static int do_mmc_write(cmd_tbl_t *cmdtp, int flag,
@@ -301,28 +372,50 @@
 	struct mmc *mmc;
 	u32 blk, cnt, n;
 	void *addr;
+	int dev;
+	unsigned long long start_ticks, end_ticks;
+	unsigned long long size, speed_byte, speed_tmp;
 
-	if (argc != 4)
+	if (argc != 5)
 		return CMD_RET_USAGE;
 
-	addr = (void *)simple_strtoul(argv[1], NULL, 16);
-	blk = simple_strtoul(argv[2], NULL, 16);
-	cnt = simple_strtoul(argv[3], NULL, 16);
+	dev = simple_strtoul(argv[1], NULL, 16);
+	addr = (void *)simple_strtoul(argv[2], NULL, 16);
+	blk = simple_strtoul(argv[3], NULL, 16);
+	cnt = simple_strtoul(argv[4], NULL, 16);
 
-	mmc = init_mmc_device(curr_device, false);
+	mmc = init_mmc_device(dev, false);
 	if (!mmc)
 		return CMD_RET_FAILURE;
 
-	printf("\nMMC write: dev # %d, block # %d, count %d ... ",
-	       curr_device, blk, cnt);
+	curr_device = dev;
 
 	if (mmc_getwp(mmc) == 1) {
 		printf("Error: card is write protected!\n");
 		return CMD_RET_FAILURE;
 	}
+
+#ifdef CONFIG_EXT4_SPARSE
+	if (!strcmp(argv[0], "write.ext4sp")) {
+		printf("\nMMC write ext4 sparse: dev # %d, block # %d, count %d ... ",
+				curr_device, blk, cnt);
+		return ext4_unsparse(mmc, dev, addr, blk, cnt);
+	}
+#endif
+
+	printf("\nMMC write: dev # %d, block # %d, count %d ... ",
+	       curr_device, blk, cnt);
+
+	start_ticks = get_ticks();
 	n = blk_dwrite(mmc_get_blk_desc(mmc), blk, cnt, addr);
+	end_ticks = get_ticks();
 	printf("%d blocks written: %s\n", n, (n == cnt) ? "OK" : "ERROR");
 
+	size = mmc->read_bl_len * cnt;
+	speed_byte = (size * CONFIG_SYS_HZ * CONFIG_SYS_HZ) / (end_ticks - start_ticks);
+	speed_tmp = (speed_byte & 0xFFFFF) * RESERVE_TWO_DECIMAL;
+	printf("%llu.%02llu MB/s\n", speed_byte >> DIV_ONE_MB,
+	       speed_tmp >> DIV_ONE_MB);
 	return (n == cnt) ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
 }
 static int do_mmc_erase(cmd_tbl_t *cmdtp, int flag,
@@ -731,8 +824,9 @@
 
 static cmd_tbl_t cmd_mmc[] = {
 	U_BOOT_CMD_MKENT(info, 1, 0, do_mmcinfo, "", ""),
-	U_BOOT_CMD_MKENT(read, 4, 1, do_mmc_read, "", ""),
-	U_BOOT_CMD_MKENT(write, 4, 0, do_mmc_write, "", ""),
+	U_BOOT_CMD_MKENT(reg, 2, 0, do_mmcreg, "", ""),
+	U_BOOT_CMD_MKENT(read, 5, 1, do_mmc_read, "", ""),
+	U_BOOT_CMD_MKENT(write, 5, 0, do_mmc_write, "", ""),
 	U_BOOT_CMD_MKENT(erase, 3, 0, do_mmc_erase, "", ""),
 	U_BOOT_CMD_MKENT(rescan, 1, 1, do_mmc_rescan, "", ""),
 	U_BOOT_CMD_MKENT(part, 1, 1, do_mmc_part, "", ""),
@@ -781,8 +875,9 @@
 	mmc, 29, 1, do_mmcops,
 	"MMC sub system",
 	"info - display info of the current MMC device\n"
-	"mmc read addr blk# cnt\n"
-	"mmc write addr blk# cnt\n"
+	"mmc reg [dev] - display register of the current MMC device\n"
+	"mmc read dev addr blk# cnt\n"
+	"mmc write dev addr blk# cnt\n"
 	"mmc erase blk# cnt\n"
 	"mmc rescan\n"
 	"mmc part - lists available partition on current mmc device\n"
diff -uraN u-boot-2016.11/cmd/nand.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/nand.c
--- u-boot-2016.11/cmd/nand.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/nand.c	2021-06-07 13:01:32.000000000 +0300
@@ -29,6 +29,8 @@
 #include <jffs2/jffs2.h>
 #include <nand.h>
 
+#include <nfc_common.h>
+
 #if defined(CONFIG_CMD_MTDPARTS)
 
 /* partition handling routines */
@@ -38,6 +40,141 @@
 		      u8 *part_num, struct part_info **part);
 #endif
 
+/*
+ * fmc :
+ * v100: 2k4b 2k8b 2k24b 4k4b 4k8b 4k24b
+ */
+
+#define NFC_VER_VER          (0xFFF00000)
+
+#define SET_NFC_VER(_ver, _pagesize, _ecc) \
+	((((_ver) << 20) & NFC_VER_VER) | \
+	 (((_pagesize) & 0xFFFF) << 4) | ((_ecc) & 0xF))
+
+static unsigned int fmc100_support_yaffs2[] = {
+	SET_NFC_VER(FMC_VER_100, _2K, ET_ECC_4BIT),
+	SET_NFC_VER(FMC_VER_100, _2K, ET_ECC_8BIT),
+	SET_NFC_VER(FMC_VER_100, _2K, ET_ECC_24BIT1K),
+
+	SET_NFC_VER(FMC_VER_100, _4K, ET_ECC_4BIT),
+	SET_NFC_VER(FMC_VER_100, _4K, ET_ECC_8BIT),
+	SET_NFC_VER(FMC_VER_100, _4K, ET_ECC_24BIT1K),
+
+	SET_NFC_VER(FMC_VER_100, _8K, ET_ECC_24BIT1K),
+	SET_NFC_VER(FMC_VER_100, _8K, ET_ECC_40BIT1K),
+	SET_NFC_VER(FMC_VER_100, _8K, ET_ECC_64BIT1K),
+
+	SET_NFC_VER(FMC_VER_100, _16K, ET_ECC_40BIT1K),
+	SET_NFC_VER(FMC_VER_100, _16K, ET_ECC_64BIT1K),
+
+	0,
+};
+
+static unsigned int *get_support_yaffs2(unsigned int nandip)
+{
+	switch (nandip) {
+	default:
+	case FMC_VER_100:
+		return fmc100_support_yaffs2;
+	}
+}
+
+static unsigned int get_yaffs2_version(unsigned int nandip, int pagesize,
+		int ecc)
+{
+	int ix;
+	unsigned int *ver = get_support_yaffs2(nandip);
+	unsigned int tmp = SET_NFC_VER(0, (unsigned int)pagesize, (unsigned int)ecc);
+
+	for (ix = 0; ver[ix]; ix++) {
+		if ((ver[ix] & ~NFC_VER_VER) == tmp)
+			return ver[ix];
+	}
+
+	return 0;
+}
+
+static int yaffs_tag_check(unsigned char *buffer, unsigned int writesize,
+		unsigned int length)
+{
+	unsigned int yaffs_yaff_ver;
+
+	static char *ecctype_str[] = { "0bit", "4bit", "8bit", "24bits/1K",
+		"28bits/1K", "40bits/1K", "64bits/1K", "unknown"};
+
+	/* this follow must be consistent with mkyaffs2image !!! */
+	struct yaffs2_tag {
+#define YAFFS2_SIGN_MAGIC    "YFSS!V10"
+		unsigned char magic[8];
+		unsigned int nandip;
+		unsigned char yaffs2ver[4];
+		unsigned int pagesize;
+		unsigned int ecctype;
+	};
+
+	struct yaffs2_tag *tags = (struct yaffs2_tag *)buffer;
+	unsigned int ecctype;
+	int ret;
+
+	ret = nand_get_ecctype();
+	if (ret < 0) {
+		printf("Cannot get corret ecctype. \n");
+		return -1;
+	}
+	ecctype = (unsigned int)ret;
+
+	if (length < 512) {
+		printf("buffer length is too short.\n");
+		return -1;
+	}
+
+	if (memcmp(tags->magic, (unsigned char *)YAFFS2_SIGN_MAGIC, 8)) {
+		printf("!!! The yaffs2 filesystem image has no tag " \
+				"information.\n please update your mkyaffs2image" \
+				" tool, and remake yaffs2 filesystem image.\n");
+		return -1;
+	}
+
+	if (writesize != tags->pagesize) {
+		printf("!!! yaffs2 filesystem image pagesize(%d) is NOT" \
+				" consistent with hardware pagesize(%d).\n",
+				tags->pagesize, writesize);
+		goto fail;
+	}
+
+	if (ecctype != tags->ecctype) {
+		printf("!!! yaffs2 filesystem image ecctype(%s) is NOT" \
+				" consistent with hardware ecctype(%s).\n",
+				ecctype_str[tags->ecctype & 0xF],
+				ecctype_str[ecctype & 0xF]);
+		goto fail;
+	}
+
+	yaffs_yaff_ver = get_yaffs2_version(tags->nandip, writesize, ecctype);
+	if (!yaffs_yaff_ver) {
+		printf("!!! The yaffs2 filesystem image" \
+				" has invalid tag information.\n");
+		goto fail1;
+	}
+
+	    return 0;
+
+fail:
+		printf("Please remake yaffs2 filesystem image, " \
+				"make sure your yaffs2 filesystem image pagesize and ecctype" \
+				" is consistent with hardware config.\n");
+		printf("Current hardware config, pagesize:%d, ecctype:%s\n",
+				writesize, ecctype_str[ecctype & 0xF]);
+
+		return -1;
+fail1:
+		printf("1. Confirm your yaffs2 filesystem image version.\n" \
+				"2. Update your mkyaffs2image tool," \
+				" remake yaffs2 filesystem image.\n");
+
+		return -1;
+}
+
 static int nand_dump(struct mtd_info *mtd, ulong off, int only_oob,
 		     int repeat)
 {
@@ -364,6 +501,16 @@
 		       (unsigned long long)*size, badblocks);
 	}
 }
+#ifdef CONFIG_GK_SPIFLASH_SPEED
+unsigned long ticks2usec(unsigned long  ticks)
+{
+        ulong tbclk = get_tbclk();
+        tbclk/=1000000;
+        ticks /= tbclk;
+        return ((ulong)ticks);
+}
+#endif
+
 
 static int do_nand(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
@@ -372,6 +519,10 @@
 	loff_t off, size, maxsize;
 	char *cmd, *s;
 	struct mtd_info *mtd;
+#ifdef CONFIG_GK_SPIFLASH_SPEED
+	unsigned long long time_s;
+	unsigned long long time_e;
+#endif
 #ifdef CONFIG_SYS_NAND_QUIET
 	int quiet = CONFIG_SYS_NAND_QUIET;
 #else
@@ -510,7 +661,9 @@
 		opts.jffs2  = clean;
 		opts.quiet  = quiet;
 		opts.spread = spread;
-
+#ifdef CONFIG_GK_SPIFLASH_SPEED
+		loff_t erase_size = opts.length;
+#endif
 		if (scrub) {
 			if (scrub_yes) {
 				opts.scrub = 1;
@@ -524,9 +677,18 @@
 				}
 			}
 		}
+#ifdef CONFIG_GK_SPIFLASH_SPEED
+		time_s=get_ticks();
+#endif
 		ret = nand_erase_opts(mtd, &opts);
+#ifdef CONFIG_GK_SPIFLASH_SPEED
+		time_e=get_ticks();
+#endif
 		printf("%s\n", ret ? "ERROR" : "OK");
-
+#ifdef CONFIG_GK_SPIFLASH_SPEED
+		printf("\nnand erase time ::time= %lu usec;speed: %lu KB/S\n",ticks2usec(time_e - time_s),
+                      (unsigned long)(erase_size >> 10)*1000000/ticks2usec(time_e - time_s));
+#endif
 		return ret == 0 ? 0 : 1;
 	}
 
@@ -601,7 +763,9 @@
 		}
 
 		mtd = nand_info[dev];
-
+#ifdef CONFIG_GK_SPIFLASH_SPEED
+ 		time_s=get_ticks();
+#endif
 		if (!s || !strcmp(s, ".jffs2") ||
 		    !strcmp(s, ".e") || !strcmp(s, ".i")) {
 			if (read)
@@ -630,7 +794,9 @@
 				.ooblen = rwsize,
 				.mode = MTD_OPS_RAW
 			};
-
+#ifdef CONFIG_GK_SPIFLASH_SPEED
+			time_s=get_ticks();
+#endif
 			if (read)
 				ret = mtd_read_oob(mtd, off, &ops);
 			else
@@ -638,11 +804,52 @@
 		} else if (raw) {
 			ret = raw_access(mtd, addr, off, pagecount, read,
 					 no_verify);
+		} else if ((s != NULL && !strcmp(s, ".yaffs"))) {
+			if (read) {
+				ret = nand_read_yaffs_skip_bad(mtd, off,
+						&rwsize, (u_char *)(uintptr_t)addr);
+			} else {
+				if (yaffs_tag_check((unsigned char *)(uintptr_t)addr,
+					mtd->writesize, size))
+					return 1;
+
+				ret = nand_write_yaffs_skip_bad(mtd, off,
+						&rwsize, (u_char *)(uintptr_t)addr);
+			}
+		} else if ((s != NULL && !strcmp(s, ".ecc0"))) {
+			ecc0_flag = 1;
+			if (read) {
+				ret = nand_read_yaffs_skip_bad(mtd, off,
+						&rwsize, (u_char *)(uintptr_t)addr);
+			} else {
+				ret = nand_write_yaffs_skip_bad(mtd, off,
+						&rwsize, (u_char *)(uintptr_t)addr);
+			}
+			ecc0_flag = 0;
+		} else if (((s != NULL && !strcmp(s, ".yaffsuc")))) {
+			if (read) {
+				printf("not support\n");
+				return 1;
+			} else
+				ret = nand_write_yaffs_skip_bad(mtd, off,
+						&rwsize, (u_char *)(uintptr_t)addr);
+
 		} else {
 			printf("Unknown nand command suffix '%s'.\n", s);
 			return 1;
 		}
-
+#ifdef CONFIG_GK_SPIFLASH_SPEED
+		time_e=get_ticks();
+		unsigned long speed_kb=lldiv((size>>10)*1000000,ticks2usec(time_e-time_s));
+		unsigned int first_bit=lldiv(speed_kb,1024);
+		unsigned int second_bit=(speed_kb%1024)*10/1024;
+		unsigned int third_bit=((speed_kb%1024)*10%1024)*10/1024;
+		unsigned int forth_bit=(((speed_kb%1024)*10%1024)*10%1024)*10/1024;
+
+		printf("\nnand %s::time = %lu usec.\n,  size =  %lu KB, speed: %u.%u%u%u MB/S\n",
+			read ? "read" : "written", ticks2usec(time_e - time_s), (unsigned long)(size >> 10), 
+			first_bit,second_bit,third_bit,forth_bit);
+#endif
 		printf(" %zu bytes %s: %s\n", rwsize,
 		       read ? "read" : "written", ret ? "ERROR" : "OK");
 
@@ -792,6 +999,17 @@
 	"nand read.raw - addr off|partition [count]\n"
 	"nand write.raw[.noverify] - addr off|partition [count]\n"
 	"    Use read.raw/write.raw to avoid ECC and access the flash as-is.\n"
+	"nand read.yaffs - addr off|partition size\n"
+	"nand write.yaffs - addr off|partition size\n"
+	"    read/write 'size' bytes starting at offset 'off'\n"
+	"    to/from memory address 'addr', skipping bad blocks.\n"
+	"nand write.yaffsuc - addr off|partition size\n"
+	"    read/write 'size' bytes starting at offset 'off'\n"
+	"    to/from memory address 'addr', skipping bad blocks.\n"
+	"nand read.ecc0 - addr off|partition size\n"
+	"nand write.ecc0 - addr off|partition size\n"
+	"    read/write 'size' bytes starting at offset 'off'\n"
+	"    to/from memory address 'addr', skipping bad blocks.\n"
 #ifdef CONFIG_CMD_NAND_TRIMFFS
 	"nand write.trimffs - addr off|partition size\n"
 	"    write 'size' bytes starting at offset 'off' from memory address\n"
diff -uraN u-boot-2016.11/cmd/nvedit.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/nvedit.c
--- u-boot-2016.11/cmd/nvedit.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/nvedit.c	2021-06-07 13:01:32.000000000 +0300
@@ -744,6 +744,7 @@
 }
 
 #ifndef CONFIG_SPL_BUILD
+#ifndef CONFIG_MINI_BOOT
 static int do_env_default(cmd_tbl_t *cmdtp, int __flag,
 			  int argc, char * const argv[])
 {
@@ -815,6 +816,7 @@
 
 	return ret;
 }
+#endif
 
 #ifdef CONFIG_CMD_EXPORTENV
 /*
@@ -1119,8 +1121,12 @@
 #if defined(CONFIG_CMD_ASKENV)
 	U_BOOT_CMD_MKENT(ask, CONFIG_SYS_MAXARGS, 1, do_env_ask, "", ""),
 #endif
+
+#ifndef CONFIG_MINI_BOOT
 	U_BOOT_CMD_MKENT(default, 1, 0, do_env_default, "", ""),
 	U_BOOT_CMD_MKENT(delete, CONFIG_SYS_MAXARGS, 0, do_env_delete, "", ""),
+#endif
+
 #if defined(CONFIG_CMD_EDITENV)
 	U_BOOT_CMD_MKENT(edit, 2, 0, do_env_edit, "", ""),
 #endif
diff -uraN u-boot-2016.11/cmd/sf.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/sf.c
--- u-boot-2016.11/cmd/sf.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/sf.c	2021-06-07 13:01:32.000000000 +0300
@@ -146,8 +146,6 @@
 		printf("Failed to initialize SPI flash at %u:%u\n", bus, cs);
 		return 1;
 	}
-
-	flash = new;
 #endif
 
 	return 0;
@@ -263,10 +261,14 @@
 {
 	unsigned long addr;
 	void *buf;
-	char *endp;
+    char *endp;
 	int ret = 1;
 	int dev = 0;
-	loff_t offset, len, maxsize;
+#ifdef CONFIG_GK_SPIFLASH_SPEED
+	unsigned long long time_s;
+	unsigned long long time_e;
+#endif		
+	loff_t offset, len, maxsize, off_start;
 
 	if (argc < 3)
 		return -1;
@@ -299,13 +301,74 @@
 		int read;
 
 		read = strncmp(argv[0], "read", 4) == 0;
-		if (read)
+#ifdef CONFIG_GK_SPIFLASH_SPEED		
+		time_s = get_ticks();
+#endif
+		if (read) {
 			ret = spi_flash_read(flash, offset, len, buf);
-		else
-			ret = spi_flash_write(flash, offset, len, buf);
+			off_start = offset;
+		} else {
+			unsigned long write_start, write_len, write_step;
+			int percent_complete = -1;
+			char *pbuf = buf;
+
+			off_start = offset;
+
+			write_start = offset;
+			write_len=len;
+			write_step  = flash->erase_size;
+
+			while (write_len > 0) {
+				if (write_len < write_step)
+					write_step = write_len;
+
+				ret = spi_flash_write(flash, offset, write_step, pbuf);
+				if (ret)
+					    break;
+
+				offset += write_step;
+				pbuf   += write_step;
+				write_len    -= write_step;
+
+				do {
+					unsigned long long n = (unsigned long long)
+						(offset - write_start) * 100;
+					int percent;
+
+					do_div(n, len);
+					percent = (int)n;
+
+					/* output progress message only at whole percent
+					 *      * steps to reduce the number of messages
+					 *           * printed on (slow) serial consoles
+					 *                */
+					if (percent != percent_complete) {
+						percent_complete = percent;
+
+						printf("\rWriting at 0x%llx -- %3d%% "
+								"complete.", offset, percent);
+					}
+				} while (0);
+			}
+		}
 
-		printf("SF: %zu bytes @ %#x %s: ", (size_t)len, (u32)offset,
-		       read ? "Read" : "Written");
+		puts("\n");
+#ifdef CONFIG_GK_SPIFLASH_SPEED
+		time_e = get_ticks();	
+		
+		unsigned long speed_kb=lldiv((len>>10)*1000000,ticks2usec(time_e-time_s));
+        unsigned int first_bit=lldiv(speed_kb,1024);
+        unsigned int second_bit=(speed_kb%1024)*10/1024;
+        unsigned int third_bit=((speed_kb%1024)*10%1024)*10/1024;
+        unsigned int forth_bit=(((speed_kb%1024)*10%1024)*10%1024)*10/1024;
+
+		printf("\nSF:%zu bytes @ %#x %s: cost:%lu usec;speed:%u.%u%u%u MB/S\n",(size_t)len,(u32)off_start,
+				read ? "Read" :"Written",(unsigned long )ticks2usec(time_e - time_s),first_bit,
+				second_bit,third_bit,forth_bit
+				);
+#endif
+		printf("SF: %zu bytes @ %#x %s: ", (size_t)len,(u32)off_start,
+				read ? "Read" :"Written");
 		if (ret)
 			printf("ERROR %d\n", ret);
 		else
@@ -323,6 +386,13 @@
 	int dev = 0;
 	loff_t offset, len, maxsize;
 	ulong size;
+	unsigned long erase_start, erase_len, erase_step;
+	unsigned long erase_end = 0;
+#ifdef CONFIG_GK_SPIFLASH_SPEED
+	unsigned long long time_s; 
+	unsigned long long time_e;
+#endif
+	int percent_complete = -1;
 
 	if (argc < 3)
 		return -1;
@@ -342,13 +412,105 @@
 		return 1;
 	}
 
-	ret = spi_flash_erase(flash, offset, size);
-	printf("SF: %zu bytes @ %#x Erased: %s\n", (size_t)size, (u32)offset,
-	       ret ? "ERROR" : "OK");
+	erase_start = offset;
+	erase_len   = size;
+	erase_step  = flash->erase_size;
+#ifdef CONFIG_GK_SPIFLASH_SPEED
+	time_s=get_ticks();
+#endif
+	while (size > 0){
+		if (size < erase_step)
+			erase_step = size;
+
+		ret = spi_flash_erase(flash, offset, erase_step);
+		if (ret) {
+			printf("SPI flash %s failed\n", argv[0]);
+			return 1;
+		}
+
+		size -= erase_step;
+		offset += erase_step;
+		erase_end += erase_step;
+
+		do {
+			unsigned long long n = (unsigned long long)
+				(offset - erase_start) * 100;
+			int percent;
+
+			do_div(n, erase_len);
+			percent = (int)n;
+
+			/* output progress message only at whole percent
+			 *      * steps to reduce the number of messages printed
+			 *           * on (slow) serial consoles
+			 *                */
+			if (percent != percent_complete) {
+				percent_complete = percent;
 
+				printf("\rErasing at 0x%llx -- %3d%% complete.",
+						offset, percent);
+			}
+		} while (0);
+	}
+#ifdef CONFIG_GK_SPIFLASH_SPEED
+	time_e = get_ticks();
+#endif
+	puts("\n");
+
+	printf("SF: %zu bytes @ %#x Erased: %s\n", (size_t)erase_end, (u32)erase_start,
+			ret ? "ERROR" : "OK");
+#ifdef CONFIG_GK_SPIFLASH_SPEED
+	printf("\nSF: %zu bytes @ %#x Erased cost:%lu usec;speed: %lu KB/S\n",(size_t)erase_end,(u32)erase_start,
+			(unsigned long )ticks2usec(time_e - time_s),(unsigned long)(erase_end >> 10)*1000000/ticks2usec(time_e - time_s));
+#endif
 	return ret == 0 ? 0 : 1;
 }
 
+#ifdef CONFIG_SPI_BLOCK_PROTECT
+static int do_spi_flash_lock(int argc, char * const argv[])
+{
+	char *endp;
+	unsigned char level;
+	unsigned char cmp = BP_CMP_BOTTOM;
+
+	if ((argc < 1) || (argc > 2))
+		goto usage;
+
+	/* sf lock */
+	if (argc == 1) {
+		spi_flash_lock(0, 0, BP_OP_GET);
+		puts("\n");
+		goto usage;
+	}
+
+	/* sf lock all/level */
+	if (argc == 2) {
+		if (strcmp(argv[1], "all") == 0) {
+			level = flash->bp_level_max;
+		} else {
+			level = simple_strtoul(argv[1], &endp, 0);
+			if (level > flash->bp_level_max)
+				goto usage;
+			if (*endp != 0)
+				goto usage;
+		}
+	}
+
+	spi_flash_lock(cmp, level, BP_OP_SET);
+
+	return 0;
+usage:
+	puts("\tsf lock level/all\n");
+	printf("Usage:\n\t all: level(%d), lock all blocks.\n",
+			flash->bp_level_max);
+	puts("\tlevel(0): unlock all blocks.\n");
+	printf("\tset spi nor chip block protection level(0 - %d).\n",
+			flash->bp_level_max);
+	printf("\tAs usual: lock_len = chipsize >> (%d - level)\n",
+			flash->bp_level_max);
+	return 1;
+}
+#else
 static int do_spi_protect(int argc, char * const argv[])
 {
 	int ret = 0;
@@ -379,6 +541,7 @@
 
 	return ret == 0 ? 0 : 1;
 }
+#endif /* CONFIG_SPI_BLOCK_PROTECT */
 
 #ifdef CONFIG_CMD_SF_TEST
 enum {
@@ -572,8 +735,13 @@
 		ret = do_spi_flash_read_write(argc, argv);
 	else if (strcmp(cmd, "erase") == 0)
 		ret = do_spi_flash_erase(argc, argv);
+#ifdef CONFIG_SPI_BLOCK_PROTECT
+	else if (strcmp(cmd, "lock") == 0)
+		ret = do_spi_flash_lock(argc, argv);
+#else
 	else if (strcmp(cmd, "protect") == 0)
 		ret = do_spi_protect(argc, argv);
+#endif
 #ifdef CONFIG_CMD_SF_TEST
 	else if (!strcmp(cmd, "test"))
 		ret = do_spi_flash_test(argc, argv);
@@ -615,5 +783,8 @@
 	"					  or to start of mtd `partition'\n"
 	"sf protect lock/unlock sector len	- protect/unprotect 'len' bytes starting\n"
 	"					  at address 'sector'\n"
+#ifdef CONFIG_SPI_BLOCK_PROTECT
+    "sf lock level|all      - set spi block protection level\n"
+#endif
 	SF_TEST_HELP
 );
diff -uraN u-boot-2016.11/cmd/usb.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/usb.c
--- u-boot-2016.11/cmd/usb.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/usb.c	2021-06-07 13:01:32.000000000 +0300
@@ -29,6 +29,8 @@
 static int __maybe_unused usb_ether_curr_dev = -1; /* current ethernet device */
 #endif
 
+extern void udc_connect(void);
+
 /* some display routines (info command) */
 static char *usb_get_class_desc(unsigned char dclass)
 {
@@ -625,10 +627,15 @@
 	if (argc < 2)
 		return CMD_RET_USAGE;
 
+	if (strncmp(argv[1], "device", 6) == 0) {
+		printf("Install USB Device...\n");
+		udc_connect();
+		return 0;
+	}
+
 	if (strncmp(argv[1], "start", 5) == 0) {
-		if (usb_started)
-			return 0; /* Already started */
 		printf("starting USB...\n");
+		usb_stop();
 		do_usb_start();
 		return 0;
 	}
diff -uraN u-boot-2016.11/cmd/usbtftp.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/usbtftp.c
--- u-boot-2016.11/cmd/usbtftp.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/cmd/usbtftp.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,419 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#include "../drivers/usb/gadget/udc3/usb3_drv.h"
+#include "common.h"
+
+#include <common.h>
+#include <malloc.h>
+#include <command.h>
+
+#include <spi.h>
+#include <spi_flash.h>
+#include <jffs2/jffs2.h>
+#include <linux/mtd/mtd.h>
+
+static unsigned int usb_open_flag = 0;
+static char command[256] = {0};
+
+static int udc_request(void)
+{
+	extern int get_eventbuf_count(usb3_device_t *dev);
+	extern void dcache_disable(void);
+	extern void usb3_common_init(usb3_device_t *dev, volatile uint8_t *base);
+	extern void phy_usb_init(int index);
+	extern void usb3_init(usb3_device_t *dev);
+	extern void dcache_enable(void);
+	extern int usb_stop(void);
+	extern void usb3_handle_event(usb3_device_t *dev);
+
+	dcache_disable();
+	usb3_device_t *usb3_dev;
+	struct usb_device_descriptor *usb3_dev_desc;
+	usb3_dev = (usb3_device_t *)malloc(sizeof(usb3_device_t));
+	if (usb3_dev == NULL) {
+		debug("usb3_dev: out of memory\n");
+		return -ENOMEM;
+	}
+	usb3_memset((void *)usb3_dev, 0, sizeof(usb3_device_t));
+	usb3_dev_desc = (usb_device_descriptor_t *)malloc(sizeof(
+						struct usb_device_descriptor));
+	usb3_pcd_t *pcd = &usb3_dev->pcd;
+	usb3_pcd_ep_t *ep = &pcd->in_ep;
+	usb3_pcd_req_t *req = &ep->req;
+	req->bufdma = (uint8_t *)malloc(512);
+	usb_info("size of usb3_dev %d\n", sizeof(*usb3_dev));
+	usb3_dev->base = (volatile uint8_t *)USB3_CTRL_REG_BASE;
+
+	uint8_t string_manu[] = {'G', 0, 'o', 0, 'k', 0, 'e', 0};
+	uint8_t string_prod[] = {'U', 0, 'S', 0, 'B', 0, 'B', 0, 'u', 0, 'r', 0, 'n', 0};
+	usb3_dev->string_manu_len = sizeof(string_manu);
+	usb3_dev->string_prod_len = sizeof(string_prod);
+	usb3_dev->dev_desc = usb3_dev_desc;
+	memcpy(usb3_dev->string_manu, string_manu, usb3_dev->string_manu_len);
+	memcpy(usb3_dev->string_prod, string_prod, usb3_dev->string_prod_len);
+	usb3_dev->pcd.ep0_setup_desc = (usb3_dma_desc_t *)
+				((uintptr_t)(usb3_dev->pcd.ep0_setup + 15) & (uint32_t)(~15));
+	usb3_dev->pcd.ep0_in_desc = (usb3_dma_desc_t *)
+				((uintptr_t)(usb3_dev->pcd.ep0_in + 15) & (uint32_t)(~15));
+	usb3_dev->pcd.ep0_out_desc = (usb3_dma_desc_t *)
+				((uintptr_t)(usb3_dev->pcd.ep0_out + 15) & (uint32_t)(~15));
+	usb3_dev->pcd.in_ep.ep_desc = (usb3_dma_desc_t *)
+				((uintptr_t)(usb3_dev->pcd.in_ep.epx_desc + 15) & (uint32_t)(~15));
+	usb3_dev->pcd.out_ep.ep_desc = (usb3_dma_desc_t *)
+				((uintptr_t)(usb3_dev->pcd.out_ep.epx_desc + 15) & (uint32_t)(~15));
+
+	/* Release usb3.0 controller */
+
+	phy_usb_init(0);
+
+	/* Get usb3.0 version number */
+	usb3_dev->snpsid = usb3_rd32((volatile uint32_t *)
+				(usb3_dev->base + USB3_CORE_REG_BASE + USB3_CORE_GSNPSID_REG_OFFSET));
+
+	/* Initialize usb3.0 core */
+	usb3_common_init(usb3_dev, usb3_dev->base + USB3_CORE_REG_BASE);
+
+	/* Initialize usb3.0 pcd */
+	usb3_init(usb3_dev);
+
+	usb_info("usb init done\n");
+
+	ulong time_start = get_timer(0);
+
+	/* inital the send buffer */
+	extern char tx_state[200];
+	memset(tx_state, 0, sizeof(tx_state));
+
+	while (usb_open_flag) {
+		usb3_handle_event(usb3_dev);
+
+		if (0 != get_eventbuf_count(usb3_dev)) {
+			time_start = get_timer(0);
+			continue;
+		}
+
+		if (get_timer(time_start) > 5000) {
+			printf("the USB has no data for about 5s, stop the USB Device\n");
+			break;
+		}
+	}
+
+	usb_open_flag = 0;
+
+	phy_usb_init(0);
+	usb_stop();
+
+	if (req->bufdma != NULL) {
+		free(req->bufdma);
+		req->bufdma = NULL;
+	}
+
+	if (usb3_dev_desc != NULL) {
+		free(usb3_dev_desc);
+		usb3_dev_desc = NULL;
+	}
+
+	if (usb3_dev != NULL) {
+		free(usb3_dev);
+		usb3_dev = NULL;
+	}
+
+	dcache_enable();
+
+	return 0;
+}
+
+static int do_usbtftp_download(int argc, char *const argv[])
+{
+	if (strlen(argv[1]) + strlen(argv[2]) + 15 >= 256)
+		return -1;
+
+	char *endp = NULL;
+	(void)simple_strtoul(argv[1], &endp, 16);
+	if (*argv[1] == 0 || *endp != 0)
+		return -1;
+
+	if (usb_open_flag == 1) {
+		printf("usbtftp is running.\n");
+		return 1;
+	}
+
+	memset(command, 0, sizeof(command));
+	sprintf(command, "usbtftp %s %s", argv[1], argv[2]);
+	usb_open_flag = 1;
+
+	(void)udc_request();
+	return 0;
+}
+
+#ifndef CONFIG_MMC
+static struct spi_flash *spiflash = NULL;
+
+static int do_flash_probe(void)
+{
+	unsigned int bus   = CONFIG_SF_DEFAULT_BUS;
+	unsigned int cs    = CONFIG_SF_DEFAULT_CS;
+	unsigned int speed = CONFIG_SF_DEFAULT_SPEED;
+	unsigned int mode  = CONFIG_SF_DEFAULT_MODE;
+
+#ifdef CONFIG_DM_SPI_FLASH
+	struct udevice *new = NULL;
+	struct udevice *bus_dev = NULL;
+	int ret;
+
+	/* In DM mode defaults will be taken from DT */
+	speed = 0, mode = 0;
+#else
+	struct spi_flash *new = NULL;
+#endif
+
+#ifdef CONFIG_DM_SPI_FLASH
+	/* Remove the old device, otherwise probe will just be a nop */
+	ret = spi_find_bus_and_cs(bus, cs, &bus_dev, &new);
+	if (!ret)
+		device_remove(new);
+	spiflash = NULL;
+	ret = spi_flash_probe_bus_cs(bus, cs, speed, mode, &new);
+	if (ret) {
+		printf("Failed to initialize SPI flash at %u:%u (error %d)\n", bus, cs, ret);
+		return 1;
+	}
+
+	spiflash = dev_get_uclass_priv(new);
+#else
+	if (spiflash)
+		spi_flash_free(spiflash);
+
+	new = spi_flash_probe(bus, cs, speed, mode);
+	if (!new) {
+		printf("Failed to initialize SPI flash at %u:%u\n", bus, cs);
+		return 1;
+	}
+	spiflash = new;
+#endif
+
+	return 0;
+}
+
+static unsigned char *membuf = NULL;
+static unsigned int mem_len = 0;
+static int do_spi_flash_read(int argc, char *const argv[])
+{
+	unsigned long size;
+	char *endp = NULL;
+	int ret;
+	int dev = 0;
+	loff_t offset, len, maxsize;
+
+	if (argc < 3)
+		return -1;
+
+	if (spiflash == NULL) {
+		printf("error, spiflash is null!\n");
+		return -1;
+	}
+
+	if (mtd_arg_off(argv[1], &dev, &offset, &len, &maxsize, MTD_DEV_TYPE_NOR,
+					spiflash->size)) {
+		return -1;
+	}
+
+	size = simple_strtoul(argv[3], &endp, 16);
+	if (*argv[3] == 0 || *endp != 0)
+		return -1;
+
+	/* Consistency checking */
+	if (offset + size > spiflash->size) {
+		printf("ERROR: attempting %s past flash size (%#x)\n", argv[0], spiflash->size);
+		return 1;
+	}
+
+	len = size;
+
+	membuf = (unsigned char *)malloc(size);
+	if (!membuf) {
+		puts("Failed to malloc memory\n");
+		return 1;
+	}
+
+	ret = spi_flash_read(spiflash, offset, len, (void *)membuf);
+
+	mem_len = size;
+	return ret == 0 ? 0 : 1;
+}
+
+static int frame_count = 0;
+#define FRAME_LENGTH (200)
+static int do_upload(uint8_t *const buff, unsigned int *bufflen)
+{
+	unsigned char *head = (unsigned char *)buff;
+	*bufflen = 0;
+
+	/* the tail frame has been sent, send again */
+	if (frame_count == -1) {
+		head[0] = 0xED;
+		*bufflen = 1;
+		return 0;
+	}
+
+	if (frame_count == 0) {
+		head[0] = 0xFE;
+		head[1] = (mem_len >> 24) & 0xFF;
+		head[2] = (mem_len >> 16) & 0xFF;
+		head[3] = (mem_len >> 8) & 0xFF;
+		head[4] = mem_len & 0xFF;
+
+		head[5] = (FRAME_LENGTH >> 24) & 0xFF;
+		head[6] = (FRAME_LENGTH >> 16) & 0xFF;
+		head[7] = (FRAME_LENGTH >> 8) & 0xFF;
+		head[8] = FRAME_LENGTH & 0xFF;
+
+		*bufflen = 9;
+		frame_count++;
+		return 0;
+	}
+
+	if (FRAME_LENGTH * frame_count <= mem_len) {
+		head[0] = 0xDA;
+		*bufflen = FRAME_LENGTH;
+	} else if ((FRAME_LENGTH * frame_count > mem_len) &&
+			   (FRAME_LENGTH * (frame_count - 1) < mem_len)) {
+		head[0] = 0xDA;
+		*bufflen = mem_len - FRAME_LENGTH * (frame_count - 1);
+	} else if ((FRAME_LENGTH * (frame_count - 1) >= mem_len)) {
+		head[0] = 0xED;
+		*bufflen = 0;
+		frame_count = -1;
+	}
+
+	if (*bufflen != 0) {
+		memcpy(head + 1, membuf +
+			   FRAME_LENGTH * (frame_count - 1), *bufflen);
+		frame_count++;
+	}
+
+	/* cmd is one byte */
+	*bufflen = *bufflen + 1;
+	return 0;
+}
+#endif
+
+static int do_usbtftp_upload(int argc, char *const argv[])
+{
+	if (strlen(argv[1]) + strlen(argv[2]) + 15 >= 256)
+		return -1;
+
+	if (usb_open_flag == 1) {
+		printf("usbtftp is running.\n");
+		return -1;
+	}
+
+#ifndef CONFIG_MMC
+	int ret;
+
+	ret = do_flash_probe();
+	if (ret != 0)
+		goto done;
+
+	ret = do_spi_flash_read(argc, argv);
+	if (ret != 0)
+		goto done;
+
+	frame_count = 0;
+
+	typedef int (*USB3_HANDLE_REQUEST)(uint8_t *const buff,
+						unsigned int *bufflen);
+	extern void SetUSB3CallBackFunc(USB3_HANDLE_REQUEST func);
+	SetUSB3CallBackFunc(do_upload);
+
+	memset(command, 0, sizeof(command));
+	sprintf(command, "usbtftp %s %s %s", argv[1], argv[2], argv[3]);
+	usb_open_flag = 1;
+
+	(void)udc_request();
+
+	frame_count = 0;
+
+	SetUSB3CallBackFunc(NULL);
+
+done:
+
+#ifdef CONFIG_DM_SPI_FLASH
+	spiflash = NULL;
+#else
+	if (spiflash) {
+		spi_flash_free(spiflash);
+		spiflash = NULL;
+	}
+#endif
+
+	if (membuf) {
+		free(membuf);
+		membuf = NULL;
+	}
+	mem_len = 0;
+
+	return ret;
+#else
+	printf("usbtftp upoload can not support emmc now.\n");
+	return -1;
+#endif
+}
+
+
+static int do_usbtftp(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	int ret = 0;
+	if (strncmp(argv[1], "start", 5) == 0) {
+		if (usb_open_flag == 0)
+			goto usage;
+
+		printf(" %s\n", command);
+		goto done;
+	}
+
+	if (strncmp(argv[1], "error", 5) == 0) {
+		if (usb_open_flag == 0)
+			goto usage;
+
+		usb_open_flag = 0;
+		printf("usbtftp error\n");
+		goto done;
+	}
+
+	if (strncmp(argv[1], "end", 3) == 0) {
+		if (usb_open_flag == 0)
+			goto usage;
+
+		usb_open_flag = 0;
+		printf("usbtftp end\n");
+		goto done;
+	}
+
+	if (argc == 3) {
+		ret = do_usbtftp_download(argc, argv);
+		goto done;
+	}
+
+	if (argc == 4) {
+		ret =  do_usbtftp_upload(argc, argv);
+		goto done;
+	}
+
+usage:
+	return CMD_RET_USAGE;
+
+done:
+	return ret;
+}
+
+U_BOOT_CMD(
+	usbtftp, 4, 0, do_usbtftp,
+	"download or upload image using USB protocol",
+	"command to download or upload image using USB protocol\n"
+	"usbtftp addr file len - upload `len(hex)' bytes starting at addr to file\n"
+	"usbtftp addr file     - download file to addr\n"
+);
+
+
diff -uraN u-boot-2016.11/common/board_f.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/board_f.c
--- u-boot-2016.11/common/board_f.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/board_f.c	2021-06-07 13:01:32.000000000 +0300
@@ -148,6 +148,7 @@
 	return 0;
 }
 
+#ifndef CONFIG_MINI_BOOT
 static int display_text_info(void)
 {
 #if !defined(CONFIG_SANDBOX) && !defined(CONFIG_EFI_APP)
@@ -173,12 +174,15 @@
 
 	return 0;
 }
+#endif
 
+#ifndef CONFIG_MINI_BOOT
 static int announce_dram_init(void)
 {
-	puts("DRAM:  ");
+	//puts("DRAM:  ");
 	return 0;
 }
+#endif
 
 #if defined(CONFIG_MIPS) || defined(CONFIG_PPC) || defined(CONFIG_M68K)
 static int init_func_ram(void)
@@ -220,9 +224,9 @@
 	size = gd->ram_size;
 #endif
 
-	print_size(size, "");
-	board_add_ram_info(0);
-	putc('\n');
+	//print_size(size, "");
+	//board_add_ram_info(0);
+	//putc('\n');
 
 	return 0;
 }
@@ -758,11 +762,12 @@
 #endif
 	memcpy(gd->new_gd, (char *)gd, sizeof(gd_t));
 
-	debug("Relocation Offset is: %08lx\n", gd->reloc_off);
-	debug("Relocating to %08lx, new gd at %08lx, sp at %08lx\n",
+#ifndef CONFIG_MINI_BOOT
+	printf("Relocation Offset is: %08lx\n", gd->reloc_off);
+	printf("Relocating to %08lx, new gd at %08lx, sp at %08lx\n",
 	      gd->relocaddr, (ulong)map_to_sysmem(gd->new_gd),
 	      gd->start_addr_sp);
-
+#endif
 	return 0;
 }
 
@@ -798,6 +803,7 @@
 }
 #endif
 
+#ifndef CONFIG_MINI_BOOT
 /* Record the board_init_f() bootstage (after arch_cpu_init()) */
 static int mark_bootstage(void)
 {
@@ -805,6 +811,7 @@
 
 	return 0;
 }
+#endif
 
 static int initf_console_record(void)
 {
@@ -868,7 +875,9 @@
 	mach_cpu_init,		/* SoC/machine dependent CPU setup */
 	initf_dm,
 	arch_cpu_init_dm,
+#ifndef CONFIG_MINI_BOOT
 	mark_bootstage,		/* need timer, go after init dm */
+#endif
 #if defined(CONFIG_BOARD_EARLY_INIT_F)
 	board_early_init_f,
 #endif
@@ -879,14 +888,18 @@
 		&& !defined(CONFIG_TQM885D)
 	adjust_sdram_tbs_8xx,
 #endif
+#ifndef CONFIG_MINI_BOOT
 	/* TODO: can we rename this to timer_init()? */
 	init_timebase,
 #endif
+#endif
 #if defined(CONFIG_ARM) || defined(CONFIG_MIPS) || \
 		defined(CONFIG_BLACKFIN) || defined(CONFIG_NDS32) || \
 		defined(CONFIG_SPARC)
+#ifndef CONFIG_MINI_BOOT
 	timer_init,		/* initialize timer */
 #endif
+#endif
 #ifdef CONFIG_SYS_ALLOC_DPRAM
 #if !defined(CONFIG_CPM2)
 	dpram_init,
@@ -912,8 +925,10 @@
 #ifdef CONFIG_SANDBOX
 	sandbox_early_getopt_check,
 #endif
+#ifndef CONFIG_MINI_BOOT
 	display_options,	/* say that we are here */
 	display_text_info,	/* show debugging info if required */
+#endif
 #if defined(CONFIG_MPC8260)
 	prt_8260_rsr,
 	prt_8260_clks,
@@ -924,7 +939,9 @@
 #if defined(CONFIG_PPC) || defined(CONFIG_M68K)
 	checkcpu,
 #endif
+#ifndef CONFIG_MINI_BOOT
 	print_cpuinfo,		/* display cpu info (and speed) */
+#endif
 #if defined(CONFIG_MPC5xxx)
 	prt_mpc5xxx_clks,
 #endif /* CONFIG_MPC5xxx */
@@ -935,14 +952,18 @@
 #if defined(CONFIG_MISC_INIT_F)
 	misc_init_f,
 #endif
+#ifndef CONFIG_MINI_BOOT
 	INIT_FUNC_WATCHDOG_RESET
+#endif
 #if defined(CONFIG_HARD_I2C) || defined(CONFIG_SYS_I2C)
 	init_func_i2c,
 #endif
 #if defined(CONFIG_HARD_SPI)
 	init_func_spi,
 #endif
+#ifndef CONFIG_MINI_BOOT
 	announce_dram_init,
+#endif
 	/* TODO: unify all these dram functions? */
 #if defined(CONFIG_ARM) || defined(CONFIG_X86) || defined(CONFIG_NDS32) || \
 		defined(CONFIG_MICROBLAZE) || defined(CONFIG_AVR32)
@@ -954,16 +975,21 @@
 #ifdef CONFIG_POST
 	post_init_f,
 #endif
+#ifndef CONFIG_MINI_BOOT
 	INIT_FUNC_WATCHDOG_RESET
+#endif
 #if defined(CONFIG_SYS_DRAM_TEST)
 	testdram,
 #endif /* CONFIG_SYS_DRAM_TEST */
+#ifndef CONFIG_MINI_BOOT
 	INIT_FUNC_WATCHDOG_RESET
-
+#endif
 #ifdef CONFIG_POST
 	init_post,
 #endif
+#ifndef CONFIG_MINI_BOOT
 	INIT_FUNC_WATCHDOG_RESET
+#endif
 	/*
 	 * Now that we have DRAM mapped and working, we can
 	 * relocate the code and continue running from DRAM.
diff -uraN u-boot-2016.11/common/board_r.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/board_r.c
--- u-boot-2016.11/common/board_r.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/board_r.c	2021-06-07 13:01:32.000000000 +0300
@@ -66,6 +66,9 @@
 #include <asm/arch/mmu.h>
 #endif
 #include <efi_loader.h>
+#ifdef CONFIG_CMD_SF
+#include <spi_flash.h>
+#endif
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -89,6 +92,7 @@
 {
 }
 
+#ifndef CONFIG_MINI_BOOT
 static int initr_secondary_cpu(void)
 {
 	/*
@@ -102,6 +106,7 @@
 
 	return 0;
 }
+#endif
 
 static int initr_trace(void)
 {
@@ -114,9 +119,10 @@
 
 static int initr_reloc(void)
 {
+#ifndef CONFIG_MINI_BOOT
 	/* tell others: relocation done */
 	gd->flags |= GD_FLG_RELOC | GD_FLG_FULL_MALLOC_INIT;
-
+#endif
 	return 0;
 }
 
@@ -431,6 +437,31 @@
 }
 #endif
 
+#ifdef CONFIG_CMD_SF
+
+#ifndef CONFIG_ENV_SPI_BUS
+# define CONFIG_ENV_SPI_BUS 0
+#endif
+#ifndef CONFIG_ENV_SPI_CS
+# define CONFIG_ENV_SPI_CS  0
+#endif
+#ifndef CONFIG_ENV_SPI_MAX_HZ
+# define CONFIG_ENV_SPI_MAX_HZ  1000000
+#endif
+#ifndef CONFIG_ENV_SPI_MODE
+# define CONFIG_ENV_SPI_MODE    SPI_MODE_3
+#endif
+
+/* go init the SPI Nor */
+static int initr_snor(void)
+{
+	puts("SPI Nor:  ");
+	spi_flash_probe(CONFIG_ENV_SPI_BUS, CONFIG_ENV_SPI_CS,
+			CONFIG_ENV_SPI_MAX_HZ, CONFIG_ENV_SPI_MODE);
+	return 0;
+}
+#endif
+
 #ifdef CONFIG_CMD_NAND
 /* go init the NAND */
 static int initr_nand(void)
@@ -469,6 +500,7 @@
 }
 #endif
 
+#ifndef CONFIG_MINI_BOOT
 /*
  * Tell if it's OK to load the environment early in boot.
  *
@@ -524,6 +556,7 @@
 #endif /* CONFIG_SYS_EXTBDINFO */
 	return 0;
 }
+#endif
 
 #ifdef CONFIG_SYS_BOOTPARAMS_LEN
 static int initr_malloc_bootparams(void)
@@ -537,11 +570,13 @@
 }
 #endif
 
+#ifndef CONFIG_MINI_BOOT
 static int initr_jumptable(void)
 {
 	jumptable_init();
 	return 0;
 }
+#endif
 
 #if defined(CONFIG_API)
 static int initr_api(void)
@@ -552,6 +587,7 @@
 }
 #endif
 
+#ifndef CONFIG_MINI_BOOT
 /* enable exceptions */
 #if defined(CONFIG_ARM) || defined(CONFIG_AVR32)
 static int initr_enable_interrupts(void)
@@ -560,6 +596,7 @@
 	return 0;
 }
 #endif
+#endif
 
 #ifdef CONFIG_CMD_NET
 static int initr_ethaddr(void)
@@ -737,6 +774,15 @@
 }
 #endif
 
+static int initr_download(void)
+{
+#ifndef CONFIG_GK_DISABLE_DOWNLOAD
+	extern void download_boot(const int (*handle)(void));
+	download_boot(NULL);
+#endif
+	return 0;
+}
+
 static int run_main_loop(void)
 {
 #ifdef CONFIG_SANDBOX
@@ -748,6 +794,10 @@
 	return 0;
 }
 
+#ifdef CONFIG_MINI_BOOT
+	extern int apps_startup(void);
+#endif
+
 /*
  * Over time we hope to remove these functions with code fragments and
  * stub funtcions, and instead call the relevant function directly.
@@ -853,6 +903,9 @@
 #ifdef CONFIG_PPC
 	initr_spi,
 #endif
+#ifdef CONFIG_CMD_SF
+	initr_snor,
+#endif
 #ifdef CONFIG_CMD_NAND
 	initr_nand,
 #endif
@@ -865,12 +918,16 @@
 #ifdef CONFIG_HAS_DATAFLASH
 	initr_dataflash,
 #endif
+#ifndef CONFIG_MINI_BOOT
 	initr_env,
+#endif
 #ifdef CONFIG_SYS_BOOTPARAMS_LEN
 	initr_malloc_bootparams,
 #endif
 	INIT_FUNC_WATCHDOG_RESET
+#ifndef CONFIG_MINI_BOOT
 	initr_secondary_cpu,
+#endif
 #if defined(CONFIG_ID_EEPROM) || defined(CONFIG_SYS_I2C_MAC_OFFSET)
 	mac_read_from_eeprom,
 #endif
@@ -882,7 +939,9 @@
 	initr_pci,
 #endif
 	stdio_add_devices,
+#ifndef CONFIG_MINI_BOOT
 	initr_jumptable,
+#endif
 #ifdef CONFIG_API
 	initr_api,
 #endif
@@ -900,10 +959,14 @@
 #ifdef CONFIG_CMD_KGDB
 	initr_kgdb,
 #endif
+#ifndef CONFIG_MINI_BOOT
 	interrupt_init,
+#endif
 #if defined(CONFIG_ARM) || defined(CONFIG_AVR32)
+#ifndef CONFIG_MINI_BOOT
 	initr_enable_interrupts,
 #endif
+#endif
 #if defined(CONFIG_MICROBLAZE) || defined(CONFIG_AVR32) || defined(CONFIG_M68K)
 	timer_init,		/* initialize timer */
 #endif
@@ -969,6 +1032,9 @@
 #if defined(CONFIG_SPARC)
 	prom_init,
 #endif
+
+	initr_download,
+
 	run_main_loop,
 };
 
diff -uraN u-boot-2016.11/common/bootm.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/bootm.c
--- u-boot-2016.11/common/bootm.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/bootm.c	2021-06-07 13:01:32.000000000 +0300
@@ -903,7 +903,8 @@
 	memmove(to, from, len);
 }
 
-static int bootm_host_load_image(const void *fit, int req_image_type)
+static int bootm_host_load_image(const void *fit, int req_image_type,
+				int cfg_noffset)
 {
 	const char *fit_uname_config = NULL;
 	ulong data, len;
@@ -915,6 +916,7 @@
 	void *load_buf;
 	int ret;
 
+	fit_uname_config = fdt_get_name(fit, cfg_noffset, NULL);
 	memset(&images, '\0', sizeof(images));
 	images.verify = 1;
 	noffset = fit_image_load(&images, (ulong)fit,
@@ -959,7 +961,7 @@
 	for (i = 0; i < ARRAY_SIZE(image_types); i++) {
 		int ret;
 
-		ret = bootm_host_load_image(fit, image_types[i]);
+		ret = bootm_host_load_image(fit, image_types[i], cfg_noffset);
 		if (!err && ret && ret != -ENOENT)
 			err = ret;
 	}
diff -uraN u-boot-2016.11/common/cli_hush.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/cli_hush.c
--- u-boot-2016.11/common/cli_hush.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/cli_hush.c	2021-06-07 13:01:32.000000000 +0300
@@ -1042,6 +1042,8 @@
 	if (n == -1 ) {
 		flag_repeat = 0;
 		i->__promptme = 0;
+	} else if (n == -3) {
+		flag_repeat = 0;
 	}
 	n = strlen(console_buffer);
 	console_buffer[n] = '\n';
diff -uraN u-boot-2016.11/common/cli_readline.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/cli_readline.c
--- u-boot-2016.11/common/cli_readline.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/cli_readline.c	2021-06-07 13:01:32.000000000 +0300
@@ -496,8 +496,12 @@
 	*len = eol_num;
 	buf[eol_num] = '\0';	/* lose the newline */
 
-	if (buf[0] && buf[0] != CREAD_HIST_CHAR)
+	if (buf[0] == '\0') {
+		return -3;
+	}
+	if (buf[0] && buf[0] != CREAD_HIST_CHAR) {
 		cread_add_to_hist(buf);
+	}
 	hist_cur = hist_add_idx;
 
 	return 0;
diff -uraN u-boot-2016.11/common/cmd_ugzip.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/cmd_ugzip.c
--- u-boot-2016.11/common/cmd_ugzip.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/cmd_ugzip.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+/*
+ * Command for compress.
+ */
+
+#include <common.h>
+
+#define HEAD_SIZE   0X10
+#define COMPRESSED_SIZE_OFFSET      0X0
+
+#define HEAD_MAGIC_NUM0 0X70697A67/*'g''z''i''p'*/
+#define HEAD_MAGIC_NUM0_OFFSET 0X8
+#define HEAD_MAGIC_NUM1 0X64616568/*'h''e''a''d'*/
+#define HEAD_MAGIC_NUM1_OFFSET 0XC
+extern unsigned int hw_dec_type;
+extern void hw_dec_init(void);
+extern void hw_dec_uinit(void);
+
+#if ((defined CONFIG_TARGET_GK7205V200) || (defined CONFIG_TARGET_GK7205V300) ||\
+	 (defined CONFIG_TARGET_GK7202V300) || (defined CONFIG_TARGET_GK7605V100))
+extern int hw_dec_decompress(unsigned char *dst, int *dstlen,
+				unsigned char *src, int srclen,
+				void *unused);
+#endif
+
+static int do_ugzip(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	uintptr_t  src, dst;
+	int size_comparessed, size_uncomparessed;
+	unsigned int magic_num0, magic_num1;
+	int ret = 0;
+	/* need two arguments */
+	if (argc != 3)
+		goto usage;
+
+	src = simple_strtoul(argv[1], NULL, 16);
+	dst = simple_strtoul(argv[2], NULL, 16);
+
+	if (src & 0XF) {
+		printf("ERR:\n    src[0X%08lx] is not 16Byte-aligned!\n", src);
+		return 1;
+	}
+	if (dst & 0XF) {
+		printf("ERR:\n    dst[0X%08lx] is not 16Byte-aligned!\n", dst);
+		return 1;
+	}
+
+	magic_num0 = *(unsigned int *)(src + HEAD_MAGIC_NUM0_OFFSET);
+	magic_num1 = *(unsigned int *)(src + HEAD_MAGIC_NUM1_OFFSET);
+	if ((magic_num0 != HEAD_MAGIC_NUM0) || (magic_num1 != HEAD_MAGIC_NUM1)) {
+		printf("ERR:\n    The magic numbers are not correct!\n"\
+			   "    Please check the source data!\n");
+		return 1;
+	}
+	size_comparessed = *(int *)(src + COMPRESSED_SIZE_OFFSET);
+	size_uncomparessed = *(int *)(src + UNCOMPRESSED_SIZE_OFFSET);
+	/*use direct address mode*/
+	hw_dec_type = 0;
+	/*init hw decompress IP*/
+	hw_dec_init();
+	/*start decompress*/
+#if ((defined CONFIG_TARGET_GK7205V200) || (defined CONFIG_TARGET_GK7205V300) || \
+	 (defined CONFIG_TARGET_GK7202V300) || (defined CONFIG_TARGET_GK7605V100))
+	ret = hw_dec_decompress((unsigned char *)dst, &size_uncomparessed, \
+					(unsigned char *)(src + HEAD_SIZE), \
+					size_comparessed, NULL);
+#endif
+	if (ret)
+		printf("ERR:\n    decompress fail!\n");
+	else
+		printf("decompress ok!\n");
+	/*uinit hw decompress IP*/
+	hw_dec_uinit();
+
+	return 1;
+
+usage:
+	cmd_usage(cmdtp);
+	return 1;
+}
+
+U_BOOT_CMD(
+	ugzip,  3,  1,  do_ugzip,
+	"Compress gzipfile with hardware IP",
+	"ugzip <src> <dst>\n"
+	"src and dst must be 16Byte-aligned"
+);
+
diff -uraN u-boot-2016.11/common/console.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/console.c
--- u-boot-2016.11/common/console.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/console.c	2021-06-07 13:01:32.000000000 +0300
@@ -713,6 +713,7 @@
 
 void stdio_print_current_devices(void)
 {
+#ifndef CONFIG_MINI_BOOT
 	/* Print information */
 	puts("In:    ");
 	if (stdio_devices[stdin] == NULL) {
@@ -734,6 +735,7 @@
 	} else {
 		printf ("%s\n", stdio_devices[stderr]->name);
 	}
+#endif
 }
 
 #ifdef CONFIG_SYS_CONSOLE_IS_IN_ENV
@@ -907,4 +909,21 @@
 	return 0;
 }
 
+void print_to_tool(const char *fmt, ...)
+{
+	va_list args;
+	char printbuffer[CONFIG_SYS_PBSIZE];
+
+	va_start(args, fmt);
+
+	/* For this to work, printbuffer must be larger than
+	 * anything we ever want to print.
+	 */
+	vsprintf(printbuffer, fmt, args);
+	va_end(args);
+
+	/* Print the string */
+	serial_puts_to_tool(printbuffer);
+}
+
 #endif /* CONFIG_SYS_CONSOLE_IS_IN_ENV */
diff -uraN u-boot-2016.11/common/download_process.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/download_process.c
--- u-boot-2016.11/common/download_process.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/download_process.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,220 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <common.h>
+#include <watchdog.h>
+#include <command.h>
+
+#ifdef DUMP_SWITCH
+static void dump_buf(char *buf, int len)
+{
+	int i;
+	char *p = buf;
+	printf("%s->%d, buf=0x%.8x, len=%d\n",
+			__FUNCTION__, __LINE__,
+			(int)(buf), (int)(len));
+	for (i = 0; i < (len); i++) {
+		printf("0x%.2x ", *(p + i));
+		if (!((i + 1) & 0x07))
+			printf("\n");
+	}
+	printf("\n");
+}
+#endif
+
+#define	XHEAD	0xAB
+#define	XCMD	0xCD
+#define	ACK     0xAA            /* ACK VALUE */
+#define	NAK     0x55            /* NAK VALUE */
+
+#define START_FRAME_LEN	5
+#define MAX_BUFF_SIZE		1024
+#define MAX_SEND_SIZE    20
+
+static char recv_buf[MAX_BUFF_SIZE];
+
+/* crc Array 256 */
+static unsigned short crc16_table[256] = {
+	0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7,
+	0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef,
+	0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6,
+	0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,
+	0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,
+	0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,
+	0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4,
+	0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc,
+	0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,
+	0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,
+	0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12,
+	0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,
+	0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41,
+	0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,
+	0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70,
+	0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78,
+	0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f,
+	0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
+	0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e,
+	0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,
+	0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,
+	0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
+	0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c,
+	0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,
+	0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab,
+	0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3,
+	0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,
+	0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92,
+	0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9,
+	0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1,
+	0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,
+	0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0,
+};
+
+static unsigned short calc_crc16(const unsigned char *packet, unsigned long length)
+{
+	unsigned short crc16 = 0;
+	unsigned long i;
+
+	for (i = 0; i < length; i++)
+		crc16 = ((crc16 << 8) |     /* fetches High or low 8 bit */
+			packet[i]) ^ crc16_table[(crc16 >> 8) & 0xFF];
+
+	for (i = 0; i < 2; i++)  /* 2: Cycle and fetches High or low 8 bit */
+		crc16 = ((crc16 << 8) | 0) ^ crc16_table[(crc16 >> 8) & 0xFF];
+
+	return crc16;
+}
+
+static int recv_byte(void)
+{
+	if (serial_tstc())
+		return serial_getc();
+
+	return -1;
+}
+
+static char recv_data(void)
+{
+	int ret = -1;
+
+	while (ret == -1)
+		ret = recv_byte();
+
+	return (char)ret;
+}
+
+void download_process(void)
+{
+	int i;
+	int cr;
+	int ret;
+	unsigned int head_frame_len;
+	unsigned int cmd_len = 0;
+	unsigned char send_buf[MAX_SEND_SIZE] = {0};
+	unsigned short cksum;
+
+	while (1) {
+retry:
+		cr = recv_byte();
+		if (cr == -1)
+			goto retry;
+
+		if (cr == XHEAD) {
+			head_frame_len = START_FRAME_LEN;
+			recv_buf[0] = (char)cr;
+
+			/* RECV: head frame */
+			for (i = 0; i < (head_frame_len - 1); i++)
+				recv_buf[i + 1] = recv_data();
+
+			/* crc check 3 length */
+			cksum = calc_crc16((unsigned char *)recv_buf, 3);
+			/* The most significant 8 bits of array 3 and array 4 are used. */
+			if (cksum == (((unsigned char)recv_buf[3] << 8) |
+						(unsigned char)recv_buf[4])) {
+				/* init, The most significant 8 bits of array 1 and array 2 Plus 3. */
+				cmd_len = (((unsigned char)recv_buf[1] << 8) |
+						(unsigned char)recv_buf[2]) + 3;
+
+				/* SEND: ack */
+				send_buf[0] = ACK;
+			} else {
+				/* init */
+				cmd_len = 0;
+
+				/* SEND: nak */
+				send_buf[0] = NAK;
+			}
+			serial_putc(send_buf[0]);
+		} else if (cr == XCMD) {
+			recv_buf[0] = (char)cr;
+
+			if (cmd_len > MAX_BUFF_SIZE)
+				goto retry;
+
+			/* RECV: cmd data */
+			for (i = 0; i < (cmd_len - 1); i++)
+				recv_buf[i + 1] = recv_data();
+
+			/* crc check cmd_len subtract 2 length */
+			cksum = calc_crc16((unsigned char *)recv_buf, cmd_len - 2);
+			/* cmd_len subtract 2 length significant 8 bits */
+			if (cksum == (((unsigned char)(recv_buf[cmd_len - 2]) << 8) |
+						  (unsigned char)recv_buf[cmd_len - 1])) {
+				/* SEND: ack wait result */
+				send_buf[0] = ACK;
+				serial_putc(send_buf[0]);
+			} else {
+				memset(recv_buf, 0, sizeof(recv_buf));
+				/* SEND: nak */
+				send_buf[0] = NAK;
+				serial_putc(send_buf[0]);
+
+				goto retry;
+			}
+
+			/* clean crc */
+			recv_buf[cmd_len - 1] = 0;
+			/* cmd_len subtract 2 length */
+			recv_buf[cmd_len - 2] = 0;
+
+			/* cmd process */
+			ret = run_command((recv_buf + 1), 0);
+			if (ret)
+				/* SEND: end flag */
+				serial_puts("[EOT](ERROR)\n");
+			else
+				/* SEND: end flag */
+				serial_puts("[EOT](OK)\n");
+		} else {
+			/* flush fifo */
+		}
+	}
+}
+
+__attribute__((weak)) void download_boot(int (*handle)(void))
+{
+	if ((*(volatile unsigned int *)(REG_START_FLAG)) == START_MAGIC) {
+		/* clear flag */
+		*(volatile unsigned int *)(REG_START_FLAG) = 0;
+
+		serial_puts("start download process.\n");
+
+		/* wait cmd from pc */
+		for (;;) {
+			if ((*(volatile unsigned int *)(SYS_CTRL_REG_BASE + REG_SC_GEN9)) ==
+								SELF_BOOT_TYPE_USBDEV) {
+#ifndef CONFIG_MINI_BOOT
+#ifdef CONFIG_PHY_VENDOR_USB
+				udc_connect();
+#endif
+#endif
+			} else {
+				download_process();
+			}
+		}
+	}
+
+	if (handle)
+		handle();
+}
diff -uraN u-boot-2016.11/common/env_common_func.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/env_common_func.c
--- u-boot-2016.11/common/env_common_func.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/env_common_func.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,124 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <common.h>
+#include <config.h>
+#include <environment.h>
+#include <cpu_common.h>
+
+struct env_common_func_t {
+	int (*saveenv)(void);
+	void (*env_relocate_spec)(void);
+	char *env_name_spec;
+};
+
+#ifdef CONFIG_ENV_IS_IN_NAND
+
+#ifdef CONFIG_CMD_NAND
+
+static struct env_common_func_t nand_env_cmn_func = {
+	.saveenv = nand_saveenv,
+	.env_relocate_spec = nand_env_relocate_spec,
+	.env_name_spec = "NAND",
+};
+#endif
+
+#else
+
+#endif /* CONFIG_ENV_IS_IN_NAND */
+
+#ifdef CONFIG_ENV_IS_IN_SPI_FLASH
+
+static struct env_common_func_t sf_env_cmn_func = {
+	.saveenv = sf_saveenv,
+	.env_relocate_spec = sf_env_relocate_spec,
+	.env_name_spec = "SPI Flash",
+};
+#else
+static struct env_common_func_t sf_env_cmn_func = {0};
+
+#endif /* CONFIG_ENV_IS_IN_SPI_FLASH */
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+
+static struct env_common_func_t emmc_env_cmn_func = {
+	.saveenv = emmc_saveenv,
+	.env_relocate_spec = emmc_env_relocate_spec,
+	.env_name_spec = "eMMC Flash",
+};
+#else
+static struct env_common_func_t emmc_env_cmn_func = {0};
+
+#endif /* CONFIG_ENV_IS_IN_EMMC_FLASH */
+
+#ifdef CONFIG_ENV_IS_IN_UFS
+
+static struct env_common_func_t ufs_env_cmn_func = {
+	.saveenv = ufs_saveenv,
+	.env_relocate_spec = ufs_env_relocate_spec,
+	.env_name_spec = "UFS Flash",
+};
+#else
+static struct env_common_func_t ufs_env_cmn_func = {0};
+
+#endif /* CONFIG_ENV_IS_IN_UFS_FLASH */
+char *env_name_spec;
+env_t *env_ptr;
+struct env_common_func_t *env_cmn_func = NULL;
+
+int saveenv(void)
+{
+	return env_cmn_func ? env_cmn_func->saveenv() : -1;
+}
+
+void env_relocate_spec(void)
+{
+	switch (get_boot_media()) {
+	default:
+		env_cmn_func = NULL;
+		break;
+	case BOOT_MEDIA_NAND:
+#ifdef CONFIG_CMD_NAND
+		env_cmn_func = &nand_env_cmn_func;
+#else
+		env_cmn_func = NULL;
+#endif
+		break;
+	case BOOT_MEDIA_SPIFLASH:
+		env_cmn_func = &sf_env_cmn_func;
+		break;
+	case BOOT_MEDIA_EMMC:
+		env_cmn_func = &emmc_env_cmn_func;
+		break;
+	case BOOT_MEDIA_UFS:
+		env_cmn_func = &ufs_env_cmn_func;
+		break;
+	case BOOT_MEDIA_UNKNOWN:
+		env_cmn_func = NULL;
+		break;
+	}
+
+	if (env_cmn_func && !env_cmn_func->env_name_spec)
+		env_cmn_func = NULL;
+
+	/* unknow start media */
+	if (!env_cmn_func)
+		return;
+
+	env_name_spec = env_cmn_func->env_name_spec;
+
+	env_cmn_func->env_relocate_spec();
+}
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int env_init(void)
+{
+	/* Device isn't usable before relocation */
+	gd->env_addr = (ulong)(uintptr_t)&default_environment[0];
+	gd->env_valid = 1;
+
+	return 0;
+}
+
diff -uraN u-boot-2016.11/common/env_mmc.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/env_mmc.c
--- u-boot-2016.11/common/env_mmc.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/env_mmc.c	2021-06-07 13:01:32.000000000 +0300
@@ -22,12 +22,12 @@
 #error CONFIG_ENV_SIZE_REDUND should be the same as CONFIG_ENV_SIZE
 #endif
 
-char *env_name_spec = "MMC";
+char *mmc_env_name_spec = "MMC";
 
 #ifdef ENV_IS_EMBEDDED
 env_t *env_ptr = &environment;
 #else /* ! ENV_IS_EMBEDDED */
-env_t *env_ptr;
+extern env_t *env_ptr;
 #endif /* ENV_IS_EMBEDDED */
 
 DECLARE_GLOBAL_DATA_PTR;
@@ -59,7 +59,7 @@
 	return CONFIG_SYS_MMC_ENV_DEV;
 }
 
-int env_init(void)
+int emmc_env_init(void)
 {
 	/* use default */
 	gd->env_addr	= (ulong)&default_environment[0];
@@ -142,7 +142,7 @@
 static unsigned char env_flags;
 #endif
 
-int saveenv(void)
+int emmc_saveenv(void)
 {
 	ALLOC_CACHE_ALIGN_BUFFER(env_t, env_new, 1);
 	int dev = mmc_get_env_dev();
@@ -208,7 +208,7 @@
 }
 
 #ifdef CONFIG_ENV_OFFSET_REDUND
-void env_relocate_spec(void)
+void emmc_env_relocate_spec(void)
 {
 #if !defined(ENV_IS_EMBEDDED)
 	struct mmc *mmc;
@@ -296,7 +296,7 @@
 #endif
 }
 #else /* ! CONFIG_ENV_OFFSET_REDUND */
-void env_relocate_spec(void)
+void emmc_env_relocate_spec(void)
 {
 #if !defined(ENV_IS_EMBEDDED)
 	ALLOC_CACHE_ALIGN_BUFFER(char, buf, CONFIG_ENV_SIZE);
diff -uraN u-boot-2016.11/common/env_nand.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/env_nand.c
--- u-boot-2016.11/common/env_nand.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/env_nand.c	2021-06-07 13:01:32.000000000 +0300
@@ -39,14 +39,14 @@
 #define CONFIG_ENV_RANGE	CONFIG_ENV_SIZE
 #endif
 
-char *env_name_spec = "NAND";
+char * nand_env_name_spec = "NAND";
 
 #if defined(ENV_IS_EMBEDDED)
 env_t *env_ptr = &environment;
 #elif defined(CONFIG_NAND_ENV_DST)
 env_t *env_ptr = (env_t *)CONFIG_NAND_ENV_DST;
 #else /* ! ENV_IS_EMBEDDED */
-env_t *env_ptr;
+extern env_t *env_ptr;
 #endif /* ENV_IS_EMBEDDED */
 
 DECLARE_GLOBAL_DATA_PTR;
@@ -63,7 +63,7 @@
  * This way the SPL loads not only the U-Boot image from NAND but
  * also the environment.
  */
-int env_init(void)
+int nand_env_init(void)
 {
 #if defined(ENV_IS_EMBEDDED) || defined(CONFIG_NAND_ENV_DST)
 	int crc1_ok = 0, crc2_ok = 0;
@@ -181,7 +181,7 @@
 static unsigned char env_flags;
 #endif
 
-int saveenv(void)
+int nand_saveenv(void)
 {
 	int	ret = 0;
 	ALLOC_CACHE_ALIGN_BUFFER(env_t, env_new, 1);
@@ -311,7 +311,7 @@
 #endif
 
 #ifdef CONFIG_ENV_OFFSET_REDUND
-void env_relocate_spec(void)
+void nand_env_relocate_spec (void)
 {
 #if !defined(ENV_IS_EMBEDDED)
 	int read1_fail = 0, read2_fail = 0;
@@ -383,7 +383,7 @@
  * device i.e., nand_dev_desc + 0. This is also the behaviour using
  * the new NAND code.
  */
-void env_relocate_spec(void)
+void nand_env_relocate_spec (void)
 {
 #if !defined(ENV_IS_EMBEDDED)
 	int ret;
diff -uraN u-boot-2016.11/common/env_sf.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/env_sf.c
--- u-boot-2016.11/common/env_sf.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/env_sf.c	2021-06-07 13:01:32.000000000 +0300
@@ -41,14 +41,14 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
-char *env_name_spec = "SPI Flash";
+char * sf_env_name_spec = "SPI Flash";
 
 static struct spi_flash *env_flash;
 
 #if defined(CONFIG_ENV_OFFSET_REDUND)
-int saveenv(void)
+int sf_saveenv(void)
 {
-	env_t	env_new;
+	__aligned(CONFIG_SYS_CACHELINE_SIZE) env_t	env_new;
 	char	*saved_buffer = NULL, flag = OBSOLETE_FLAG;
 	u32	saved_size, saved_offset, sector = 1;
 	int	ret;
@@ -149,7 +149,7 @@
 	return ret;
 }
 
-void env_relocate_spec(void)
+void sf_env_relocate_spec(void)
 {
 	int ret;
 	int crc1_ok = 0, crc2_ok = 0;
@@ -236,12 +236,12 @@
 	free(tmp_env2);
 }
 #else
-int saveenv(void)
+int sf_saveenv(void)
 {
 	u32	saved_size, saved_offset, sector = 1;
 	char	*saved_buffer = NULL;
 	int	ret = 1;
-	env_t	env_new;
+	__aligned(CONFIG_SYS_CACHELINE_SIZE) env_t	env_new;
 #ifdef CONFIG_DM_SPI_FLASH
 	struct udevice *new;
 
@@ -320,7 +320,7 @@
 	return ret;
 }
 
-void env_relocate_spec(void)
+void sf_env_relocate_spec(void)
 {
 	int ret;
 	char *buf = NULL;
@@ -353,7 +353,7 @@
 }
 #endif
 
-int env_init(void)
+int sf_env_init(void)
 {
 	/* SPI flash isn't usable before relocation */
 	gd->env_addr = (ulong)&default_environment[0];
diff -uraN u-boot-2016.11/common/image.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/image.c
--- u-boot-2016.11/common/image.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/image.c	2021-06-07 13:01:32.000000000 +0300
@@ -107,6 +107,7 @@
 	{	IH_OS_OSE,	"ose",		"Enea OSE",		},
 	{	IH_OS_PLAN9,	"plan9",	"Plan 9",		},
 	{	IH_OS_RTEMS,	"rtems",	"RTEMS",		},
+	{	IH_OS_TEE,	"tee",		"Trusted Execution Environment" },
 	{	IH_OS_U_BOOT,	"u-boot",	"U-Boot",		},
 	{	IH_OS_VXWORKS,	"vxworks",	"VxWorks",		},
 #if defined(CONFIG_CMD_ELF) || defined(USE_HOSTCC)
diff -uraN u-boot-2016.11/common/image-fit.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/image-fit.c
--- u-boot-2016.11/common/image-fit.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/image-fit.c	2021-06-07 13:01:32.000000000 +0300
@@ -276,8 +276,8 @@
 		return;
 	}
 	printf("%s", algo);
-	keyname = fdt_getprop(fit, noffset, "key-name-hint", NULL);
-	required = fdt_getprop(fit, noffset, "required", NULL) != NULL;
+	keyname = fdt_getprop(fit, noffset, FIT_KEY_HINT, NULL);
+	required = fdt_getprop(fit, noffset, FIT_KEY_REQUIRED, NULL) != NULL;
 	if (keyname)
 		printf(":%s", keyname);
 	if (required)
@@ -916,29 +916,39 @@
  *    -1, when algo is unsupported
  */
 int calculate_hash(const void *data, int data_len, const char *algo,
-			uint8_t *value, int *value_len)
+                   uint8_t *value, int *value_len)
 {
-	if (IMAGE_ENABLE_CRC32 && strcmp(algo, "crc32") == 0) {
-		*((uint32_t *)value) = crc32_wd(0, data, data_len,
-							CHUNKSZ_CRC32);
-		*((uint32_t *)value) = cpu_to_uimage(*((uint32_t *)value));
-		*value_len = 4;
-	} else if (IMAGE_ENABLE_SHA1 && strcmp(algo, "sha1") == 0) {
-		sha1_csum_wd((unsigned char *)data, data_len,
-			     (unsigned char *)value, CHUNKSZ_SHA1);
-		*value_len = 20;
-	} else if (IMAGE_ENABLE_SHA256 && strcmp(algo, "sha256") == 0) {
-		sha256_csum_wd((unsigned char *)data, data_len,
-			       (unsigned char *)value, CHUNKSZ_SHA256);
-		*value_len = SHA256_SUM_LEN;
-	} else if (IMAGE_ENABLE_MD5 && strcmp(algo, "md5") == 0) {
-		md5_wd((unsigned char *)data, data_len, value, CHUNKSZ_MD5);
-		*value_len = 16;
-	} else {
-		debug("Unsupported hash alogrithm\n");
-		return -1;
-	}
-	return 0;
+    if (IMAGE_ENABLE_CRC32 && strcmp(algo, "crc32") == 0) {
+        *((uint32_t *)value) = crc32_wd(0, data, data_len,
+                                        CHUNKSZ_CRC32);
+        *((uint32_t *)value) = cpu_to_uimage(*((uint32_t *)value));
+        *value_len = 4;
+    } else if (IMAGE_ENABLE_SHA1 && strcmp(algo, "sha1") == 0) {
+#ifndef CONFIG_SHA1
+        sha1_csum_wd((unsigned char *)data, data_len,
+                     (unsigned char *)value, CHUNKSZ_SHA1);
+        *value_len = 20;
+#else
+        debug("Unsupported hash sha1 alogrithm\n");
+        return -1;
+#endif
+    } else if (IMAGE_ENABLE_SHA256 && strcmp(algo, "sha256") == 0) {
+#ifndef CONFIG_SHA256
+        sha256_csum_wd((unsigned char *)data, data_len,
+                       (unsigned char *)value, CHUNKSZ_SHA256);
+        *value_len = SHA256_SUM_LEN;
+#else
+        debug("Unsupported hash sha1 alogrithm\n");
+        return -1;
+#endif
+    } else if (IMAGE_ENABLE_MD5 && strcmp(algo, "md5") == 0) {
+        md5_wd((unsigned char *)data, data_len, value, CHUNKSZ_MD5);
+        *value_len = 16;
+    } else {
+        debug("Unsupported hash alogrithm\n");
+        return -1;
+    }
+    return 0;
 }
 
 static int fit_image_check_hash(const void *fit, int noffset, const void *data,
@@ -1376,24 +1386,6 @@
 	return best_match_offset;
 }
 
-/**
- * fit_conf_get_node - get node offset for configuration of a given unit name
- * @fit: pointer to the FIT format image header
- * @conf_uname: configuration node unit name
- *
- * fit_conf_get_node() finds a configuration (within the '/configurations'
- * parent node) of a provided unit name. If configuration is found its node
- * offset is returned to the caller.
- *
- * When NULL is provided in second argument fit_conf_get_node() will search
- * for a default configuration node instead. Default configuration node unit
- * name is retrieved from FIT_DEFAULT_PROP property of the '/configurations'
- * node.
- *
- * returns:
- *     configuration node offset when found (>=0)
- *     negative number on failure (FDT_ERR_* code)
- */
 int fit_conf_get_node(const void *fit, const char *conf_uname)
 {
 	int noffset, confs_noffset;
@@ -1676,7 +1668,7 @@
 		fit_uname = fit_get_name(fit, noffset, NULL);
 	}
 	if (noffset < 0) {
-		puts("Could not find subimage node\n");
+		printf("Could not find subimage node type '%s'\n", prop_name);
 		bootstage_error(bootstage_id + BOOTSTAGE_SUB_SUBNODE);
 		return -ENOENT;
 	}
diff -uraN u-boot-2016.11/common/image-sig.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/image-sig.c
--- u-boot-2016.11/common/image-sig.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/image-sig.c	2021-06-07 13:01:32.000000000 +0300
@@ -156,7 +156,7 @@
 		return -1;
 	}
 	memset(info, '\0', sizeof(*info));
-	info->keyname = fdt_getprop(fit, noffset, "key-name-hint", NULL);
+	info->keyname = fdt_getprop(fit, noffset, FIT_KEY_HINT, NULL);
 	info->fit = (void *)fit;
 	info->node_offset = noffset;
 	info->algo = image_get_sig_algo(algo_name);
@@ -264,7 +264,8 @@
 		const char *required;
 		int ret;
 
-		required = fdt_getprop(sig_blob, noffset, "required", NULL);
+		required = fdt_getprop(sig_blob, noffset, FIT_KEY_REQUIRED,
+				       NULL);
 		if (!required || strcmp(required, "image"))
 			continue;
 		ret = fit_image_verify_sig(fit, image_noffset, data, size,
@@ -283,20 +284,39 @@
 	return 0;
 }
 
-int fit_config_check_sig(const void *fit, int noffset, int required_keynode,
-			 char **err_msgp)
+/**
+ * fit_config_check_sig() - Check the signature of a config
+ *
+ * @fit: FIT to check
+ * @noffset: Offset of configuration node (e.g. /configurations/conf-1)
+ * @required_keynode:	Offset in the control FDT of the required key node,
+ *			if any. If this is given, then the configuration wil not
+ *			pass verification unless that key is used. If this is
+ *			-1 then any signature will do.
+ * @conf_noffset: Offset of the configuration subnode being checked (e.g.
+ *	 /configurations/conf-1/kernel)
+ * @err_msgp:		In the event of an error, this will be pointed to a
+ *			help error string to display to the user.
+ * @return 0 if all verified ok, <0 on error
+ */
+static int fit_config_check_sig(const void *fit, int noffset,
+				int required_keynode, int conf_noffset,
+				char **err_msgp)
 {
 	char * const exc_prop[] = {"data"};
 	const char *prop, *end, *name;
 	struct image_sign_info info;
 	const uint32_t *strings;
+	const char *config_name;
 	uint8_t *fit_value;
 	int fit_value_len;
+	bool found_config;
 	int max_regions;
 	int i, prop_len;
 	char path[200];
 	int count;
 
+	config_name = fit_get_name(fit, conf_noffset, NULL);
 	debug("%s: fdt=%p, conf='%s', sig='%s'\n", __func__, gd_fdt_blob(),
 	      fit_get_name(fit, noffset, NULL),
 	      fit_get_name(gd_fdt_blob(), required_keynode, NULL));
@@ -332,9 +352,20 @@
 	char *node_inc[count];
 
 	debug("Hash nodes (%d):\n", count);
+	found_config = false;
 	for (name = prop, i = 0; name < end; name += strlen(name) + 1, i++) {
 		debug("   '%s'\n", name);
 		node_inc[i] = (char *)name;
+		if (!strncmp(FIT_CONFS_PATH, name, strlen(FIT_CONFS_PATH)) &&
+		    name[sizeof(FIT_CONFS_PATH) - 1] == '/' &&
+		    !strcmp(name + sizeof(FIT_CONFS_PATH), config_name)) {
+			debug("      (found config node %s)", config_name);
+			found_config = true;
+		}
+	}
+	if (!found_config) {
+		*err_msgp = "Selected config not in hashed nodes";
+		return -1;
 	}
 
 	/*
@@ -399,7 +430,7 @@
 		if (!strncmp(name, FIT_SIG_NODENAME,
 			     strlen(FIT_SIG_NODENAME))) {
 			ret = fit_config_check_sig(fit, noffset, sig_offset,
-						   &err_msg);
+						   conf_noffset, &err_msg);
 			if (ret) {
 				puts("- ");
 			} else {
@@ -415,13 +446,14 @@
 		goto error;
 	}
 
-	return verified ? 0 : -EPERM;
+	if (verified)
+		return 0;
 
 error:
 	printf(" error!\n%s for '%s' hash node in '%s' config node\n",
 	       err_msg, fit_get_name(fit, noffset, NULL),
 	       fit_get_name(fit, conf_noffset, NULL));
-	return -1;
+	return -EPERM;
 }
 
 int fit_config_verify_required_sigs(const void *fit, int conf_noffset,
@@ -442,7 +474,8 @@
 		const char *required;
 		int ret;
 
-		required = fdt_getprop(sig_blob, noffset, "required", NULL);
+		required = fdt_getprop(sig_blob, noffset, FIT_KEY_REQUIRED,
+				       NULL);
 		if (!required || strcmp(required, "conf"))
 			continue;
 		ret = fit_config_verify_sig(fit, conf_noffset, sig_blob,
diff -uraN u-boot-2016.11/common/Kconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/Kconfig
--- u-boot-2016.11/common/Kconfig	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/Kconfig	2021-06-07 13:01:32.000000000 +0300
@@ -170,6 +170,46 @@
 
 	  See doc/README.autoboot for details.
 
+menu "goke_setup"
+
+config GK_MC
+	bool "goke mc platform solution"
+	default n 
+	help
+	  support for Vendor mc platform solution
+
+config GK_SPIFLASH_SPEED
+	bool "goke spinor and spinand  speed "
+	default n
+	depends on FMC_SPI_NAND || FMC_SPI_NOR || FMC_NAND
+	help
+	  Support for flash speed  testing.
+
+config GK_UPGRADE_BY_SEGMENT
+	bool "goke Upgrade by segment write"
+	default n
+	help
+	  Support for upgrade by segment,this option is used only when the memory
+	  is small and the upgrade file is large. If you are not sure, select n by default.
+
+config GK_DISABLE_CONSOLE
+	bool "goke disable console"
+	default n
+	help
+	  The console in uboot is not secure. In formal commercial products,
+	  the input and output of the console should be turned off to avoid being attacked.
+	  Only during debugging, enable the input and output functions of the console.
+
+config GK_DISABLE_DOWNLOAD
+	bool "goke disable chip download"
+	default n
+	help
+	  The bare chip download programming function and the network download programming
+	  function are not safe in a commercial environment and may be used by hackers.
+	  Therefore, it needs to be disabled in the official product.
+
+endmenu
+
 menu "Console"
 
 config CONSOLE_RECORD
@@ -351,6 +391,13 @@
 	help
 	  This option is used to set the default fdt file to boot OS.
 
+config KERNEL_LOAD_ADDR
+	hex "Set kernel load address"
+	default 0x42080000
+	help
+	  Set the address of kernel to be loaded, because the single and
+	  big-little kernel should be loaded at diffrent address.
+
 config SYS_NO_FLASH
 	bool "Disable support for parallel NOR flash"
 	default n
diff -uraN u-boot-2016.11/common/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/Makefile
--- u-boot-2016.11/common/Makefile	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -9,8 +9,10 @@
 ifndef CONFIG_SPL_BUILD
 obj-y += init/
 obj-y += main.o
+ifndef CONFIG_MINI_BOOT
 obj-y += exports.o
 obj-y += hash.o
+endif
 obj-$(CONFIG_HUSH_PARSER) += cli_hush.o
 obj-$(CONFIG_AUTOBOOT) += autoboot.o
 
@@ -33,6 +35,7 @@
 obj-y += env_attr.o
 obj-y += env_callback.o
 obj-y += env_flags.o
+obj-y += env_common_func.o
 obj-$(CONFIG_ENV_IS_IN_DATAFLASH) += env_dataflash.o
 obj-$(CONFIG_ENV_IS_IN_EEPROM) += env_eeprom.o
 extra-$(CONFIG_ENV_IS_EMBEDDED) += env_embedded.o
@@ -177,5 +180,12 @@
 obj-y += command.o
 obj-y += s_record.o
 obj-y += xyzModem.o
+ifndef CONFIG_GK_DISABLE_DOWNLOAD
+obj-y += download_process.o
+endif
+
+ifdef CONFIG_CMD_UGZIP
+obj-y += cmd_ugzip.o
+endif
 
 CFLAGS_env_embedded.o := -Wa,--no-warn -DENV_CRC=$(shell tools/envcrc 2>/dev/null)
diff -uraN u-boot-2016.11/common/usb.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/usb.c
--- u-boot-2016.11/common/usb.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/usb.c	2021-06-07 13:01:32.000000000 +0300
@@ -144,6 +144,8 @@
 			if (usb_lowlevel_stop(i))
 				printf("failed to stop USB controller %d\n", i);
 		}
+		/* FIXME:Wait for the stop operation to complete. */
+		mdelay(100);
 	}
 
 	return 0;
@@ -221,6 +223,8 @@
 	ALLOC_CACHE_ALIGN_BUFFER(struct devrequest, setup_packet, 1);
 	int err;
 
+	/* FIXME:Avoid some devices not recognized. */
+	dcache_disable();
 	if ((timeout == 0) && (!asynch_allowed)) {
 		/* request for a asynch control pipe is not allowed */
 		return -EINVAL;
@@ -256,6 +260,7 @@
 	if (dev->status)
 		return -1;
 
+	dcache_enable();/* FIXME:dcache_disable() */
 	return dev->act_len;
 
 }
@@ -268,6 +273,8 @@
 int usb_bulk_msg(struct usb_device *dev, unsigned int pipe,
 			void *data, int len, int *actual_length, int timeout)
 {
+	/* FIXME:Prevent some U disk from reading and writing errors. */
+	dcache_disable();
 	if (len < 0)
 		return -EINVAL;
 	dev->status = USB_ST_NOT_PROC; /*not yet processed */
@@ -279,6 +286,8 @@
 		mdelay(1);
 	}
 	*actual_length = dev->act_len;
+
+	dcache_enable();/* FIXME:dcache_disable() */
 	if (dev->status == 0)
 		return 0;
 	else
@@ -927,6 +936,14 @@
 
 	desc = (struct usb_device_descriptor *)tmpbuf;
 
+	err = usb_get_descriptor(dev, USB_DT_DEVICE, 0, tmpbuf, 8);
+	if (err < 8) {
+		printf("\nUSB device not responding, giving up (status=%lX)\n",
+				dev->status);
+		return 1;
+	}
+	memcpy(&dev->descriptor, tmpbuf, 8);
+
 	err = usb_get_descriptor(dev, USB_DT_DEVICE, 0, desc, len);
 	if (err < expect_len) {
 		if (err < 0) {
diff -uraN u-boot-2016.11/common/usb_hub.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/usb_hub.c
--- u-boot-2016.11/common/usb_hub.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/usb_hub.c	2021-06-07 13:01:32.000000000 +0300
@@ -236,6 +236,12 @@
 		      (portstatus & USB_PORT_STAT_CONNECTION) ? 1 : 0,
 		      (portstatus & USB_PORT_STAT_ENABLE) ? 1 : 0);
 
+		if ((portchange & USB_PORT_STAT_C_CONNECTION) ||
+			!(portstatus & USB_PORT_STAT_CONNECTION)) {
+			usb_clear_port_feature(dev, port + 1, USB_PORT_FEAT_C_CONNECTION);
+			usb_clear_port_feature(dev, port + 1, USB_PORT_STAT_CONNECTION);
+			continue;
+		}
 		/*
 		 * Perhaps we should check for the following here:
 		 * - C_CONNECTION hasn't been set.
@@ -258,6 +264,7 @@
 
 		/* Switch to long reset delay for the next round */
 		delay = HUB_LONG_RESET_TIME;
+		mdelay(delay);
 	}
 
 	if (tries == MAX_TRIES) {
@@ -286,8 +293,10 @@
 	ALLOC_CACHE_ALIGN_BUFFER(struct usb_port_status, portsts, 1);
 	unsigned short portstatus;
 	int ret, speed;
+	int retry_count = 0;
 
 	/* Check status */
+re_enumerate:
 	ret = usb_get_port_status(dev, port + 1, portsts);
 	if (ret < 0) {
 		debug("get_port_status failed\n");
@@ -318,7 +327,7 @@
 	if (ret < 0) {
 		if (ret != -ENXIO)
 			printf("cannot reset port %i!?\n", port + 1);
-		return ret;
+		goto port_reset;
 	}
 
 	switch (portstatus & USB_PORT_STAT_SPEED_MASK) {
@@ -363,7 +372,14 @@
 #endif
 	if (ret < 0) {
 		debug("hub: disabling port %d\n", port + 1);
+port_reset:
 		usb_clear_port_feature(dev, port + 1, USB_PORT_FEAT_ENABLE);
+		retry_count++;
+		if (retry_count <= 5) {
+			usb_set_port_feature(dev, port + 1, USB_PORT_FEAT_RESET);
+			mdelay(1000);
+			goto re_enumerate;
+		}
 	}
 
 	return ret;
diff -uraN u-boot-2016.11/common/usb_storage.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/usb_storage.c
--- u-boot-2016.11/common/usb_storage.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/common/usb_storage.c	2021-06-07 13:01:32.000000000 +0300
@@ -107,6 +107,8 @@
  * limited to 65535 blocks.
  */
 #define USB_MAX_XFER_BLK	65535
+#elif defined(CONFIG_USB_XHCI_HCD)
+#define USB_MAX_XFER_BLK	240
 #else
 #define USB_MAX_XFER_BLK	20
 #endif
@@ -1009,16 +1011,6 @@
 			return 0;
 		}
 		usb_request_sense(srb, ss);
-		/*
-		 * Check the Key Code Qualifier, if it matches
-		 * "Not Ready - medium not present"
-		 * (the sense Key equals 0x2 and the ASC is 0x3a)
-		 * return immediately as the medium being absent won't change
-		 * unless there is a user action.
-		 */
-		if ((srb->sense_buf[2] == 0x02) &&
-		    (srb->sense_buf[12] == 0x3a))
-			return -1;
 		mdelay(100);
 	} while (retries--);
 
@@ -1440,10 +1432,6 @@
 		       "   Request Sense returned %02X %02X %02X\n",
 		       pccb->sense_buf[2], pccb->sense_buf[12],
 		       pccb->sense_buf[13]);
-		if (dev_desc->removable == 1) {
-			dev_desc->type = perq;
-			return 1;
-		}
 		return 0;
 	}
 	pccb->pdata = (unsigned char *)cap;
diff -uraN u-boot-2016.11/configs/gk7202v300_defconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/configs/gk7202v300_defconfig
--- u-boot-2016.11/configs/gk7202v300_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/configs/gk7202v300_defconfig	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,713 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# U-Boot 2016.11 Configuration
+#
+CONFIG_CREATE_ARCH_SYMLINK=y
+# CONFIG_ARC is not set
+CONFIG_ARM=y
+# CONFIG_AVR32 is not set
+# CONFIG_BLACKFIN is not set
+# CONFIG_M68K is not set
+# CONFIG_MICROBLAZE is not set
+# CONFIG_MIPS is not set
+# CONFIG_NDS32 is not set
+# CONFIG_NIOS2 is not set
+# CONFIG_OPENRISC is not set
+# CONFIG_PPC is not set
+# CONFIG_SANDBOX is not set
+# CONFIG_SH is not set
+# CONFIG_SPARC is not set
+# CONFIG_X86 is not set
+# CONFIG_XTENSA is not set
+CONFIG_SYS_ARCH="arm"
+CONFIG_SYS_CPU="armv7"
+CONFIG_SYS_SOC="gk7202v300"
+CONFIG_SYS_VENDOR="goke"
+CONFIG_SYS_BOARD="gk7202v300"
+CONFIG_SYS_CONFIG_NAME="gk7202v300"
+
+#
+# ARM architecture
+#
+# CONFIG_MINI_BOOT is not set
+CONFIG_HAS_VBAR=y
+CONFIG_HAS_THUMB2=y
+CONFIG_CPU_V7=y
+CONFIG_SYS_ARM_ARCH=7
+CONFIG_SYS_CACHE_SHIFT_6=y
+CONFIG_SYS_CACHELINE_SIZE=64
+# CONFIG_SEMIHOSTING is not set
+# CONFIG_SYS_L2CACHE_OFF is not set
+CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK=y
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_TARGET_EDB93XX is not set
+# CONFIG_TARGET_VCMA9 is not set
+# CONFIG_TARGET_SMDK2410 is not set
+# CONFIG_TARGET_ASPENITE is not set
+# CONFIG_TARGET_GPLUGD is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_KIRKWOOD is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_TARGET_DEVKIT3250 is not set
+# CONFIG_TARGET_WORK_92105 is not set
+# CONFIG_TARGET_MX25PDK is not set
+# CONFIG_TARGET_ZMX25 is not set
+# CONFIG_TARGET_APF27 is not set
+# CONFIG_TARGET_APX4DEVKIT is not set
+# CONFIG_TARGET_XFI3 is not set
+# CONFIG_TARGET_M28EVK is not set
+# CONFIG_TARGET_MX23EVK is not set
+# CONFIG_TARGET_MX28EVK is not set
+# CONFIG_TARGET_MX23_OLINUXINO is not set
+# CONFIG_TARGET_BG0900 is not set
+# CONFIG_TARGET_SANSA_FUZE_PLUS is not set
+# CONFIG_TARGET_SC_SPS_1 is not set
+# CONFIG_ORION5X is not set
+# CONFIG_TARGET_SPEAR300 is not set
+# CONFIG_TARGET_SPEAR310 is not set
+# CONFIG_TARGET_SPEAR320 is not set
+# CONFIG_TARGET_SPEAR600 is not set
+# CONFIG_TARGET_STV0991 is not set
+# CONFIG_TARGET_X600 is not set
+# CONFIG_TARGET_IMX31_PHYCORE is not set
+# CONFIG_TARGET_MX31ADS is not set
+# CONFIG_TARGET_MX31PDK is not set
+# CONFIG_TARGET_WOODBURN is not set
+# CONFIG_TARGET_WOODBURN_SD is not set
+# CONFIG_TARGET_FLEA3 is not set
+# CONFIG_TARGET_MX35PDK is not set
+# CONFIG_ARCH_BCM283X is not set
+# CONFIG_TARGET_VEXPRESS_CA15_TC2 is not set
+# CONFIG_TARGET_VEXPRESS_CA5X2 is not set
+# CONFIG_TARGET_VEXPRESS_CA9X4 is not set
+# CONFIG_TARGET_BRXRE1 is not set
+# CONFIG_TARGET_BRPPT1 is not set
+# CONFIG_TARGET_DRACO is not set
+# CONFIG_TARGET_THUBAN is not set
+# CONFIG_TARGET_RASTABAN is not set
+# CONFIG_TARGET_ETAMIN is not set
+# CONFIG_TARGET_PXM2 is not set
+# CONFIG_TARGET_RUT is not set
+# CONFIG_TARGET_TI814X_EVM is not set
+# CONFIG_TARGET_TI816X_EVM is not set
+# CONFIG_TARGET_BCM23550_W1D is not set
+# CONFIG_TARGET_BCM28155_AP is not set
+# CONFIG_TARGET_BCMCYGNUS is not set
+# CONFIG_TARGET_BCMNSP is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MX7 is not set
+# CONFIG_ARCH_MX6 is not set
+# CONFIG_ARCH_MX5 is not set
+# CONFIG_TARGET_M53EVK is not set
+# CONFIG_TARGET_MX51EVK is not set
+# CONFIG_TARGET_MX53ARD is not set
+# CONFIG_TARGET_MX53EVK is not set
+# CONFIG_TARGET_MX53LOCO is not set
+# CONFIG_TARGET_MX53SMD is not set
+# CONFIG_OMAP34XX is not set
+# CONFIG_OMAP44XX is not set
+# CONFIG_OMAP54XX is not set
+# CONFIG_AM43XX is not set
+# CONFIG_AM33XX is not set
+# CONFIG_ARCH_RMOBILE is not set
+# CONFIG_TARGET_S32V234EVB is not set
+# CONFIG_ARCH_SNAPDRAGON is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_TARGET_CM_T43 is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_TARGET_TS4800 is not set
+# CONFIG_TARGET_VF610TWR is not set
+# CONFIG_TARGET_COLIBRI_VF is not set
+# CONFIG_TARGET_PCM052 is not set
+# CONFIG_TARGET_BK4R1 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_ARCH_ZYNQMP is not set
+# CONFIG_TEGRA is not set
+# CONFIG_TARGET_VEXPRESS64_AEMV8A is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP_DRAM is not set
+# CONFIG_TARGET_VEXPRESS64_JUNO is not set
+# CONFIG_TARGET_LS2080A_EMU is not set
+# CONFIG_TARGET_LS2080A_SIMU is not set
+# CONFIG_TARGET_LS2080AQDS is not set
+# CONFIG_TARGET_LS2080ARDB is not set
+# CONFIG_TARGET_HIKEY is not set
+# CONFIG_TARGET_GK7205V200 is not set
+CONFIG_TARGET_GK7202V300=y
+# CONFIG_TARGET_GK7605V100 is not set
+# CONFIG_TARGET_GK7205V300 is not set
+# CONFIG_TARGET_LS1012AQDS is not set
+# CONFIG_TARGET_LS1012ARDB is not set
+# CONFIG_TARGET_LS1012AFRDM is not set
+# CONFIG_TARGET_LS1021AQDS is not set
+# CONFIG_TARGET_LS1021ATWR is not set
+# CONFIG_TARGET_LS1043AQDS is not set
+# CONFIG_TARGET_LS1043ARDB is not set
+# CONFIG_TARGET_LS1046AQDS is not set
+# CONFIG_TARGET_LS1046ARDB is not set
+# CONFIG_TARGET_H2200 is not set
+# CONFIG_TARGET_ZIPITZ2 is not set
+# CONFIG_TARGET_COLIBRI_PXA270 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_STM32 is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_TARGET_THUNDERX_88XX is not set
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_CPU_V7_HAS_NONSEC=y
+CONFIG_ARMV7_NONSEC=y
+CONFIG_ARMV7_BOOT_SEC_DEFAULT=y
+CONFIG_ARMV7_PSCI_NR_CPUS=4
+# CONFIG_ARMV7_LPAE is not set
+CONFIG_IDENT_STRING="gk7202v300"
+# CONFIG_PRE_CONSOLE_BUFFER is not set
+CONFIG_MMC=y
+# CONFIG_VIDEO is not set
+
+#
+# ARM debug
+#
+# CONFIG_DEBUG_LL is not set
+# CONFIG_AHCI is not set
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_DISTRO_DEFAULTS is not set
+CONFIG_SYS_MALLOC_F=y
+CONFIG_EXPERT=y
+CONFIG_SYS_MALLOC_CLEAR_ON_INIT=y
+# CONFIG_TOOLS_DEBUG is not set
+# CONFIG_PHYS_64BIT is not set
+
+#
+# Boot images
+#
+CONFIG_FIT=y
+# CONFIG_FIT_VERBOSE is not set
+# CONFIG_FIT_SIGNATURE is not set
+# CONFIG_FIT_BEST_MATCH is not set
+CONFIG_SYS_EXTRA_OPTIONS=""
+# CONFIG_SPL_LOAD_FIT is not set
+# CONFIG_SPL_DFU_SUPPORT is not set
+CONFIG_ARCH_FIXUP_FDT=y
+
+#
+# Boot timing
+#
+# CONFIG_BOOTSTAGE is not set
+CONFIG_BOOTSTAGE_USER_COUNT=20
+CONFIG_BOOTSTAGE_STASH_ADDR=0
+CONFIG_BOOTSTAGE_STASH_SIZE=4096
+
+#
+# Boot media
+#
+# CONFIG_NAND_BOOT is not set
+# CONFIG_ONENAND_BOOT is not set
+# CONFIG_QSPI_BOOT is not set
+# CONFIG_SATA_BOOT is not set
+# CONFIG_SD_BOOT is not set
+# CONFIG_SPI_BOOT is not set
+CONFIG_BOOTDELAY=2
+
+#
+# goke_setup
+#
+# CONFIG_GK_MC is not set
+# CONFIG_GK_SPIFLASH_SPEED is not set
+# CONFIG_GK_UPGRADE_BY_SEGMENT is not set
+# CONFIG_GK_DISABLE_CONSOLE is not set
+# CONFIG_GK_DISABLE_DOWNLOAD is not set
+
+#
+# Console
+#
+# CONFIG_CONSOLE_RECORD is not set
+# CONFIG_SILENT_CONSOLE is not set
+# CONFIG_CONSOLE_MUX is not set
+# CONFIG_SYS_CONSOLE_IS_IN_ENV is not set
+# CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE is not set
+# CONFIG_SYS_CONSOLE_ENV_OVERWRITE is not set
+# CONFIG_SYS_CONSOLE_INFO_QUIET is not set
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_DEFAULT_FDT_FILE=""
+CONFIG_KERNEL_LOAD_ADDR=0x42080000
+# CONFIG_SYS_NO_FLASH is not set
+# CONFIG_VERSION_VARIABLE is not set
+# CONFIG_DISPLAY_CPUINFO is not set
+# CONFIG_DISPLAY_BOARDINFO is not set
+# CONFIG_CMD_CREAD is not set
+
+#
+# SPL / TPL
+#
+
+#
+# Command line interface
+#
+CONFIG_CMDLINE=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="goke # "
+
+#
+# Autoboot options
+#
+CONFIG_AUTOBOOT=y
+# CONFIG_AUTOBOOT_KEYED is not set
+
+#
+# FASTBOOT
+#
+# CONFIG_FASTBOOT is not set
+
+#
+# Commands
+#
+
+#
+# Info commands
+#
+CONFIG_CMD_BDI=y
+CONFIG_CMD_CONSOLE=y
+# CONFIG_CMD_CPU is not set
+# CONFIG_CMD_LICENSE is not set
+
+#
+# Boot commands
+#
+CONFIG_CMD_BOOTD=y
+CONFIG_CMD_BOOTM=y
+# CONFIG_CMD_BOOTZ is not set
+CONFIG_CMD_ELF=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_RUN=y
+CONFIG_CMD_IMI=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_XIMG=y
+
+#
+# Environment commands
+#
+# CONFIG_CMD_ASKENV is not set
+CONFIG_CMD_EXPORTENV=y
+CONFIG_CMD_IMPORTENV=y
+CONFIG_CMD_EDITENV=y
+# CONFIG_CMD_GREPENV is not set
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_ENV_EXISTS=y
+
+#
+# Memory commands
+#
+CONFIG_CMD_MEMORY=y
+CONFIG_CMD_CRC32=y
+# CONFIG_LOOPW is not set
+# CONFIG_CMD_MEMTEST is not set
+# CONFIG_CMD_MX_CYCLIC is not set
+# CONFIG_CMD_MEMINFO is not set
+
+#
+# Device access commands
+#
+CONFIG_CMD_DM=y
+# CONFIG_CMD_DEMO is not set
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_LOADS=y
+CONFIG_CMD_FLASH=y
+# CONFIG_CMD_ARMFLASH is not set
+# CONFIG_CMD_MMC is not set
+# CONFIG_CMD_NAND is not set
+# CONFIG_CMD_SF is not set
+# CONFIG_CMD_SPI is not set
+# CONFIG_CMD_I2C is not set
+CONFIG_CMD_USB=y
+# CONFIG_CMD_DFU is not set
+# CONFIG_CMD_USB_MASS_STORAGE is not set
+CONFIG_CMD_FPGA=y
+# CONFIG_CMD_GPIO is not set
+
+#
+# Shell scripting commands
+#
+CONFIG_CMD_ECHO=y
+CONFIG_CMD_ITEST=y
+CONFIG_CMD_SOURCE=y
+CONFIG_CMD_SETEXPR=y
+
+#
+# Network commands
+#
+CONFIG_CMD_NET=y
+# CONFIG_CMD_TFTPPUT is not set
+# CONFIG_CMD_TFTPSRV is not set
+# CONFIG_CMD_RARP is not set
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_NFS=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+# CONFIG_CMD_CDP is not set
+# CONFIG_CMD_SNTP is not set
+# CONFIG_CMD_DNS is not set
+# CONFIG_CMD_LINK_LOCAL is not set
+
+#
+# Misc commands
+#
+CONFIG_CMD_CACHE=y
+# CONFIG_CMD_TIME is not set
+CONFIG_CMD_MISC=y
+# CONFIG_CMD_TIMER is not set
+# CONFIG_CMD_QFW is not set
+
+#
+# Power commands
+#
+
+#
+# Security commands
+#
+
+#
+# Firmware commands
+#
+
+#
+# Filesystem commands
+#
+# CONFIG_CMD_EXT2 is not set
+# CONFIG_CMD_EXT4 is not set
+# CONFIG_CMD_FAT is not set
+# CONFIG_CMD_FS_GENERIC is not set
+# CONFIG_CMD_UBI is not set
+CONFIG_SUPPORT_OF_CONTROL=y
+
+#
+# Device Tree Control
+#
+# CONFIG_OF_CONTROL is not set
+CONFIG_NET=y
+CONFIG_NET_RANDOM_ETHADDR=y
+# CONFIG_NETCONSOLE is not set
+CONFIG_NET_TFTP_VARS=y
+CONFIG_BOOTP_PXE_CLIENTARCH=0x15
+CONFIG_BOOTP_VCI_STRING="U-Boot.armv7"
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_DM=y
+CONFIG_DM_WARN=y
+CONFIG_DM_DEVICE_REMOVE=y
+CONFIG_DM_STDIO=y
+CONFIG_DM_SEQ_ALIAS=y
+# CONFIG_SPL_DM_SEQ_ALIAS is not set
+# CONFIG_REGMAP is not set
+# CONFIG_SPL_REGMAP is not set
+# CONFIG_DEVRES is not set
+# CONFIG_ADC is not set
+# CONFIG_ADC_EXYNOS is not set
+# CONFIG_ADC_SANDBOX is not set
+# CONFIG_BLK is not set
+# CONFIG_BLOCK_CACHE is not set
+
+#
+# Clock
+#
+# CONFIG_CLK is not set
+# CONFIG_CPU is not set
+
+#
+# Hardware crypto devices
+#
+# CONFIG_FSL_CAAM is not set
+
+#
+# Demo for driver model
+#
+# CONFIG_DM_DEMO is not set
+
+#
+# DFU support
+#
+
+#
+# DMA Support
+#
+# CONFIG_DMA is not set
+# CONFIG_TI_EDMA3 is not set
+
+#
+# FPGA support
+#
+# CONFIG_FPGA_XILINX is not set
+
+#
+# GPIO Support
+#
+# CONFIG_DM_GPIO is not set
+# CONFIG_INTEL_BROADWELL_GPIO is not set
+# CONFIG_LPC32XX_GPIO is not set
+# CONFIG_VYBRID_GPIO is not set
+
+#
+# I2C support
+#
+# CONFIG_DM_I2C is not set
+# CONFIG_DM_I2C_COMPAT is not set
+# CONFIG_SYS_I2C_DW is not set
+# CONFIG_DM_KEYBOARD is not set
+# CONFIG_CROS_EC_KEYB is not set
+
+#
+# LED Support
+#
+# CONFIG_LED is not set
+
+#
+# Mailbox Controller Support
+#
+
+#
+# Memory Controller drivers
+#
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MISC is not set
+# CONFIG_CROS_EC is not set
+# CONFIG_FSL_SEC_MON is not set
+# CONFIG_MXC_OCOTP is not set
+# CONFIG_NUVOTON_NCT6102D is not set
+# CONFIG_PWRSEQ is not set
+# CONFIG_PCA9551_LED is not set
+# CONFIG_WINBOND_W83627 is not set
+
+#
+# MMC Host controller Support
+#
+# CONFIG_DM_MMC is not set
+
+#
+# MTD Support
+#
+# CONFIG_MTD is not set
+CONFIG_FMC=y
+
+#
+# NAND Device Support
+#
+# CONFIG_NAND_DENALI is not set
+# CONFIG_NAND_VF610_NFC is not set
+# CONFIG_NAND_PXA3XX is not set
+# CONFIG_NAND_ARASAN is not set
+CONFIG_FMC_SPI_NAND=y
+# CONFIG_FMC_NAND is not set
+CONFIG_SPI_NAND_MAX_CHIP_NUM=1
+# CONFIG_FMC100_HARDWARE_PAGESIZE_ECC is not set
+CONFIG_FMC100_AUTO_PAGESIZE_ECC=y
+# CONFIG_FMC100_PAGESIZE_AUTO_ECC_NONE is not set
+
+#
+# Generic NAND options
+#
+
+#
+# SPI Flash Support
+#
+# CONFIG_SPI_FLASH is not set
+CONFIG_FMC_SPI_NOR=y
+# CONFIG_SPI_BLOCK_PROTECT is not set
+# CONFIG_DTR_MODE_SUPPORT is not set
+
+#
+# UBI support
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_DM_ETH is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_NETDEVICES is not set
+# CONFIG_PCI is not set
+# CONFIG_MVEBU_COMPHY_SUPPORT is not set
+CONFIG_PHY_VENDOR_USB=y
+
+#
+# Pin controllers
+#
+# CONFIG_PINCTRL is not set
+
+#
+# Power
+#
+
+#
+# Power Domain Support
+#
+# CONFIG_DM_PMIC is not set
+# CONFIG_DM_REGULATOR is not set
+# CONFIG_DM_PWM is not set
+# CONFIG_RAM is not set
+
+#
+# Remote Processor drivers
+#
+
+#
+# Reset Controller Support
+#
+
+#
+# Real Time Clock
+#
+# CONFIG_DM_RTC is not set
+
+#
+# Serial drivers
+#
+# CONFIG_DM_SERIAL is not set
+# CONFIG_DEBUG_UART is not set
+# CONFIG_DEBUG_UART_SKIP_INIT is not set
+# CONFIG_ATMEL_USART is not set
+# CONFIG_FSL_LPUART is not set
+# CONFIG_MVEBU_A3700_UART is not set
+# CONFIG_SYS_NS16550 is not set
+
+#
+# Sound support
+#
+# CONFIG_SOUND is not set
+
+#
+# SPI Support
+#
+# CONFIG_DM_SPI is not set
+# CONFIG_FSL_ESPI is not set
+# CONFIG_FSL_QSPI is not set
+# CONFIG_TI_QSPI is not set
+
+#
+# SPMI support
+#
+# CONFIG_SPMI is not set
+
+#
+# System reset device drivers
+#
+# CONFIG_SYSRESET is not set
+# CONFIG_DM_THERMAL is not set
+
+#
+# Timer Support
+#
+# CONFIG_TIMER is not set
+
+#
+# TPM support
+#
+CONFIG_USB=y
+# CONFIG_DM_USB is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_HOST=y
+CONFIG_USB_XHCI_HCD=y
+# CONFIG_USB_XHCI_DWC3 is not set
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_EHCI is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+
+#
+# MUSB Controller Driver
+#
+# CONFIG_USB_MUSB_HOST is not set
+# CONFIG_USB_MUSB_GADGET is not set
+
+#
+# ULPI drivers
+#
+
+#
+# USB peripherals
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_KEYBOARD is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# UFS Support
+#
+# CONFIG_UFS is not set
+
+#
+# Graphics support
+#
+# CONFIG_DM_VIDEO is not set
+
+#
+# TrueType Fonts
+#
+# CONFIG_VIDEO_VESA is not set
+# CONFIG_VIDEO_LCD_ANX9804 is not set
+# CONFIG_VIDEO_LCD_SSD2828 is not set
+# CONFIG_VIDEO_MVEBU is not set
+# CONFIG_DISPLAY is not set
+# CONFIG_VIDEO_BRIDGE is not set
+# CONFIG_LCD is not set
+# CONFIG_PHYS_TO_BUS is not set
+
+#
+# File systems
+#
+
+#
+# Library routines
+#
+# CONFIG_CC_OPTIMIZE_LIBS_FOR_SPEED is not set
+CONFIG_HAVE_PRIVATE_LIBGCC=y
+CONFIG_USE_PRIVATE_LIBGCC=y
+CONFIG_SYS_HZ=1000
+# CONFIG_USE_TINY_PRINTF is not set
+CONFIG_REGEX=y
+CONFIG_LIB_RAND=y
+# CONFIG_CMD_DHRYSTONE is not set
+# CONFIG_RSA is not set
+# CONFIG_TPM is not set
+
+#
+# Hashing Support
+#
+# CONFIG_SHA1 is not set
+# CONFIG_SHA256 is not set
+# CONFIG_SHA_HW_ACCEL is not set
+
+#
+# Compression Support
+#
+# CONFIG_LZ4 is not set
+# CONFIG_ERRNO_STR is not set
+# CONFIG_OF_LIBFDT is not set
+# CONFIG_OF_LIBFDT_OVERLAY is not set
+# CONFIG_SPL_OF_LIBFDT is not set
+
+#
+# System tables
+#
+CONFIG_HWDEC=y
+# CONFIG_OPTEE is not set
+CONFIG_OPTEE_LOAD_ADDR=0x00000000
+# CONFIG_BOOTM_OPTEE is not set
+# CONFIG_UNIT_TEST is not set
diff -uraN u-boot-2016.11/configs/gk7202v300_emmc_defconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/configs/gk7202v300_emmc_defconfig
--- u-boot-2016.11/configs/gk7202v300_emmc_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/configs/gk7202v300_emmc_defconfig	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,703 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# U-Boot 2016.11 Configuration
+#
+CONFIG_CREATE_ARCH_SYMLINK=y
+# CONFIG_ARC is not set
+CONFIG_ARM=y
+# CONFIG_AVR32 is not set
+# CONFIG_BLACKFIN is not set
+# CONFIG_M68K is not set
+# CONFIG_MICROBLAZE is not set
+# CONFIG_MIPS is not set
+# CONFIG_NDS32 is not set
+# CONFIG_NIOS2 is not set
+# CONFIG_OPENRISC is not set
+# CONFIG_PPC is not set
+# CONFIG_SANDBOX is not set
+# CONFIG_SH is not set
+# CONFIG_SPARC is not set
+# CONFIG_X86 is not set
+# CONFIG_XTENSA is not set
+CONFIG_SYS_ARCH="arm"
+CONFIG_SYS_CPU="armv7"
+CONFIG_SYS_SOC="gk7202v300"
+CONFIG_SYS_VENDOR="goke"
+CONFIG_SYS_BOARD="gk7202v300"
+CONFIG_SYS_CONFIG_NAME="gk7202v300"
+
+#
+# ARM architecture
+#
+# CONFIG_MINI_BOOT is not set
+CONFIG_HAS_VBAR=y
+CONFIG_HAS_THUMB2=y
+CONFIG_CPU_V7=y
+CONFIG_SYS_ARM_ARCH=7
+CONFIG_SYS_CACHE_SHIFT_6=y
+CONFIG_SYS_CACHELINE_SIZE=64
+# CONFIG_SEMIHOSTING is not set
+# CONFIG_SYS_L2CACHE_OFF is not set
+CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK=y
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_TARGET_EDB93XX is not set
+# CONFIG_TARGET_VCMA9 is not set
+# CONFIG_TARGET_SMDK2410 is not set
+# CONFIG_TARGET_ASPENITE is not set
+# CONFIG_TARGET_GPLUGD is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_KIRKWOOD is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_TARGET_DEVKIT3250 is not set
+# CONFIG_TARGET_WORK_92105 is not set
+# CONFIG_TARGET_MX25PDK is not set
+# CONFIG_TARGET_ZMX25 is not set
+# CONFIG_TARGET_APF27 is not set
+# CONFIG_TARGET_APX4DEVKIT is not set
+# CONFIG_TARGET_XFI3 is not set
+# CONFIG_TARGET_M28EVK is not set
+# CONFIG_TARGET_MX23EVK is not set
+# CONFIG_TARGET_MX28EVK is not set
+# CONFIG_TARGET_MX23_OLINUXINO is not set
+# CONFIG_TARGET_BG0900 is not set
+# CONFIG_TARGET_SANSA_FUZE_PLUS is not set
+# CONFIG_TARGET_SC_SPS_1 is not set
+# CONFIG_ORION5X is not set
+# CONFIG_TARGET_SPEAR300 is not set
+# CONFIG_TARGET_SPEAR310 is not set
+# CONFIG_TARGET_SPEAR320 is not set
+# CONFIG_TARGET_SPEAR600 is not set
+# CONFIG_TARGET_STV0991 is not set
+# CONFIG_TARGET_X600 is not set
+# CONFIG_TARGET_IMX31_PHYCORE is not set
+# CONFIG_TARGET_MX31ADS is not set
+# CONFIG_TARGET_MX31PDK is not set
+# CONFIG_TARGET_WOODBURN is not set
+# CONFIG_TARGET_WOODBURN_SD is not set
+# CONFIG_TARGET_FLEA3 is not set
+# CONFIG_TARGET_MX35PDK is not set
+# CONFIG_ARCH_BCM283X is not set
+# CONFIG_TARGET_VEXPRESS_CA15_TC2 is not set
+# CONFIG_TARGET_VEXPRESS_CA5X2 is not set
+# CONFIG_TARGET_VEXPRESS_CA9X4 is not set
+# CONFIG_TARGET_BRXRE1 is not set
+# CONFIG_TARGET_BRPPT1 is not set
+# CONFIG_TARGET_DRACO is not set
+# CONFIG_TARGET_THUBAN is not set
+# CONFIG_TARGET_RASTABAN is not set
+# CONFIG_TARGET_ETAMIN is not set
+# CONFIG_TARGET_PXM2 is not set
+# CONFIG_TARGET_RUT is not set
+# CONFIG_TARGET_TI814X_EVM is not set
+# CONFIG_TARGET_TI816X_EVM is not set
+# CONFIG_TARGET_BCM23550_W1D is not set
+# CONFIG_TARGET_BCM28155_AP is not set
+# CONFIG_TARGET_BCMCYGNUS is not set
+# CONFIG_TARGET_BCMNSP is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MX7 is not set
+# CONFIG_ARCH_MX6 is not set
+# CONFIG_ARCH_MX5 is not set
+# CONFIG_TARGET_M53EVK is not set
+# CONFIG_TARGET_MX51EVK is not set
+# CONFIG_TARGET_MX53ARD is not set
+# CONFIG_TARGET_MX53EVK is not set
+# CONFIG_TARGET_MX53LOCO is not set
+# CONFIG_TARGET_MX53SMD is not set
+# CONFIG_OMAP34XX is not set
+# CONFIG_OMAP44XX is not set
+# CONFIG_OMAP54XX is not set
+# CONFIG_AM43XX is not set
+# CONFIG_AM33XX is not set
+# CONFIG_ARCH_RMOBILE is not set
+# CONFIG_TARGET_S32V234EVB is not set
+# CONFIG_ARCH_SNAPDRAGON is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_TARGET_CM_T43 is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_TARGET_TS4800 is not set
+# CONFIG_TARGET_VF610TWR is not set
+# CONFIG_TARGET_COLIBRI_VF is not set
+# CONFIG_TARGET_PCM052 is not set
+# CONFIG_TARGET_BK4R1 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_ARCH_ZYNQMP is not set
+# CONFIG_TEGRA is not set
+# CONFIG_TARGET_VEXPRESS64_AEMV8A is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP_DRAM is not set
+# CONFIG_TARGET_VEXPRESS64_JUNO is not set
+# CONFIG_TARGET_LS2080A_EMU is not set
+# CONFIG_TARGET_LS2080A_SIMU is not set
+# CONFIG_TARGET_LS2080AQDS is not set
+# CONFIG_TARGET_LS2080ARDB is not set
+# CONFIG_TARGET_HIKEY is not set
+# CONFIG_TARGET_GK7205V200 is not set
+CONFIG_TARGET_GK7202V300=y
+# CONFIG_TARGET_GK7605V100 is not set
+# CONFIG_TARGET_GK7205V300 is not set
+# CONFIG_TARGET_LS1012AQDS is not set
+# CONFIG_TARGET_LS1012ARDB is not set
+# CONFIG_TARGET_LS1012AFRDM is not set
+# CONFIG_TARGET_LS1021AQDS is not set
+# CONFIG_TARGET_LS1021ATWR is not set
+# CONFIG_TARGET_LS1043AQDS is not set
+# CONFIG_TARGET_LS1043ARDB is not set
+# CONFIG_TARGET_LS1046AQDS is not set
+# CONFIG_TARGET_LS1046ARDB is not set
+# CONFIG_TARGET_H2200 is not set
+# CONFIG_TARGET_ZIPITZ2 is not set
+# CONFIG_TARGET_COLIBRI_PXA270 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_STM32 is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_TARGET_THUNDERX_88XX is not set
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_CPU_V7_HAS_NONSEC=y
+CONFIG_ARMV7_NONSEC=y
+CONFIG_ARMV7_BOOT_SEC_DEFAULT=y
+CONFIG_ARMV7_PSCI_NR_CPUS=4
+# CONFIG_ARMV7_LPAE is not set
+CONFIG_IDENT_STRING="gk7202v300"
+# CONFIG_PRE_CONSOLE_BUFFER is not set
+CONFIG_MMC=y
+# CONFIG_VIDEO is not set
+
+#
+# ARM debug
+#
+# CONFIG_DEBUG_LL is not set
+# CONFIG_AHCI is not set
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_DISTRO_DEFAULTS is not set
+CONFIG_SYS_MALLOC_F=y
+CONFIG_EXPERT=y
+CONFIG_SYS_MALLOC_CLEAR_ON_INIT=y
+# CONFIG_TOOLS_DEBUG is not set
+# CONFIG_PHYS_64BIT is not set
+
+#
+# Boot images
+#
+CONFIG_FIT=y
+# CONFIG_FIT_VERBOSE is not set
+# CONFIG_FIT_SIGNATURE is not set
+# CONFIG_FIT_BEST_MATCH is not set
+CONFIG_SYS_EXTRA_OPTIONS=""
+# CONFIG_SPL_LOAD_FIT is not set
+# CONFIG_SPL_DFU_SUPPORT is not set
+CONFIG_ARCH_FIXUP_FDT=y
+
+#
+# Boot timing
+#
+# CONFIG_BOOTSTAGE is not set
+CONFIG_BOOTSTAGE_USER_COUNT=20
+CONFIG_BOOTSTAGE_STASH_ADDR=0
+CONFIG_BOOTSTAGE_STASH_SIZE=4096
+
+#
+# Boot media
+#
+# CONFIG_NAND_BOOT is not set
+# CONFIG_ONENAND_BOOT is not set
+# CONFIG_QSPI_BOOT is not set
+# CONFIG_SATA_BOOT is not set
+# CONFIG_SD_BOOT is not set
+# CONFIG_SPI_BOOT is not set
+CONFIG_BOOTDELAY=2
+
+#
+# goke_setup
+#
+# CONFIG_GK_MC is not set
+# CONFIG_GK_UPGRADE_BY_SEGMENT is not set
+# CONFIG_GK_DISABLE_CONSOLE is not set
+# CONFIG_GK_DISABLE_DOWNLOAD is not set
+
+#
+# Console
+#
+# CONFIG_CONSOLE_RECORD is not set
+# CONFIG_SILENT_CONSOLE is not set
+# CONFIG_CONSOLE_MUX is not set
+# CONFIG_SYS_CONSOLE_IS_IN_ENV is not set
+# CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE is not set
+# CONFIG_SYS_CONSOLE_ENV_OVERWRITE is not set
+# CONFIG_SYS_CONSOLE_INFO_QUIET is not set
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_DEFAULT_FDT_FILE=""
+CONFIG_KERNEL_LOAD_ADDR=0x42080000
+# CONFIG_SYS_NO_FLASH is not set
+# CONFIG_VERSION_VARIABLE is not set
+# CONFIG_DISPLAY_CPUINFO is not set
+# CONFIG_DISPLAY_BOARDINFO is not set
+# CONFIG_CMD_CREAD is not set
+
+#
+# SPL / TPL
+#
+
+#
+# Command line interface
+#
+CONFIG_CMDLINE=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="goke # "
+
+#
+# Autoboot options
+#
+CONFIG_AUTOBOOT=y
+# CONFIG_AUTOBOOT_KEYED is not set
+
+#
+# FASTBOOT
+#
+# CONFIG_FASTBOOT is not set
+
+#
+# Commands
+#
+
+#
+# Info commands
+#
+CONFIG_CMD_BDI=y
+CONFIG_CMD_CONSOLE=y
+# CONFIG_CMD_CPU is not set
+# CONFIG_CMD_LICENSE is not set
+
+#
+# Boot commands
+#
+CONFIG_CMD_BOOTD=y
+CONFIG_CMD_BOOTM=y
+# CONFIG_CMD_BOOTZ is not set
+CONFIG_CMD_ELF=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_RUN=y
+CONFIG_CMD_IMI=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_XIMG=y
+
+#
+# Environment commands
+#
+# CONFIG_CMD_ASKENV is not set
+CONFIG_CMD_EXPORTENV=y
+CONFIG_CMD_IMPORTENV=y
+CONFIG_CMD_EDITENV=y
+# CONFIG_CMD_GREPENV is not set
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_ENV_EXISTS=y
+
+#
+# Memory commands
+#
+CONFIG_CMD_MEMORY=y
+CONFIG_CMD_CRC32=y
+# CONFIG_LOOPW is not set
+# CONFIG_CMD_MEMTEST is not set
+# CONFIG_CMD_MX_CYCLIC is not set
+# CONFIG_CMD_MEMINFO is not set
+
+#
+# Device access commands
+#
+CONFIG_CMD_DM=y
+# CONFIG_CMD_DEMO is not set
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_LOADS=y
+CONFIG_CMD_FLASH=y
+# CONFIG_CMD_ARMFLASH is not set
+# CONFIG_CMD_MMC is not set
+# CONFIG_CMD_NAND is not set
+# CONFIG_CMD_SF is not set
+# CONFIG_CMD_SPI is not set
+# CONFIG_CMD_I2C is not set
+CONFIG_CMD_USB=y
+# CONFIG_CMD_DFU is not set
+# CONFIG_CMD_USB_MASS_STORAGE is not set
+CONFIG_CMD_FPGA=y
+# CONFIG_CMD_GPIO is not set
+
+#
+# Shell scripting commands
+#
+CONFIG_CMD_ECHO=y
+CONFIG_CMD_ITEST=y
+CONFIG_CMD_SOURCE=y
+CONFIG_CMD_SETEXPR=y
+
+#
+# Network commands
+#
+CONFIG_CMD_NET=y
+# CONFIG_CMD_TFTPPUT is not set
+# CONFIG_CMD_TFTPSRV is not set
+# CONFIG_CMD_RARP is not set
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_NFS=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+# CONFIG_CMD_CDP is not set
+# CONFIG_CMD_SNTP is not set
+# CONFIG_CMD_DNS is not set
+# CONFIG_CMD_LINK_LOCAL is not set
+
+#
+# Misc commands
+#
+CONFIG_CMD_CACHE=y
+# CONFIG_CMD_TIME is not set
+CONFIG_CMD_MISC=y
+# CONFIG_CMD_TIMER is not set
+# CONFIG_CMD_QFW is not set
+
+#
+# Power commands
+#
+
+#
+# Security commands
+#
+
+#
+# Firmware commands
+#
+
+#
+# Filesystem commands
+#
+# CONFIG_CMD_EXT2 is not set
+# CONFIG_CMD_EXT4 is not set
+# CONFIG_CMD_FAT is not set
+# CONFIG_CMD_FS_GENERIC is not set
+# CONFIG_CMD_UBI is not set
+CONFIG_SUPPORT_OF_CONTROL=y
+
+#
+# Device Tree Control
+#
+# CONFIG_OF_CONTROL is not set
+CONFIG_NET=y
+CONFIG_NET_RANDOM_ETHADDR=y
+# CONFIG_NETCONSOLE is not set
+CONFIG_NET_TFTP_VARS=y
+CONFIG_BOOTP_PXE_CLIENTARCH=0x15
+CONFIG_BOOTP_VCI_STRING="U-Boot.armv7"
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_DM=y
+CONFIG_DM_WARN=y
+CONFIG_DM_DEVICE_REMOVE=y
+CONFIG_DM_STDIO=y
+CONFIG_DM_SEQ_ALIAS=y
+# CONFIG_SPL_DM_SEQ_ALIAS is not set
+# CONFIG_REGMAP is not set
+# CONFIG_SPL_REGMAP is not set
+# CONFIG_DEVRES is not set
+# CONFIG_ADC is not set
+# CONFIG_ADC_EXYNOS is not set
+# CONFIG_ADC_SANDBOX is not set
+# CONFIG_BLK is not set
+# CONFIG_BLOCK_CACHE is not set
+
+#
+# Clock
+#
+# CONFIG_CLK is not set
+# CONFIG_CPU is not set
+
+#
+# Hardware crypto devices
+#
+# CONFIG_FSL_CAAM is not set
+
+#
+# Demo for driver model
+#
+# CONFIG_DM_DEMO is not set
+
+#
+# DFU support
+#
+
+#
+# DMA Support
+#
+# CONFIG_DMA is not set
+# CONFIG_TI_EDMA3 is not set
+
+#
+# FPGA support
+#
+# CONFIG_FPGA_XILINX is not set
+
+#
+# GPIO Support
+#
+# CONFIG_DM_GPIO is not set
+# CONFIG_INTEL_BROADWELL_GPIO is not set
+# CONFIG_LPC32XX_GPIO is not set
+# CONFIG_VYBRID_GPIO is not set
+
+#
+# I2C support
+#
+# CONFIG_DM_I2C is not set
+# CONFIG_DM_I2C_COMPAT is not set
+# CONFIG_SYS_I2C_DW is not set
+# CONFIG_DM_KEYBOARD is not set
+# CONFIG_CROS_EC_KEYB is not set
+
+#
+# LED Support
+#
+# CONFIG_LED is not set
+
+#
+# Mailbox Controller Support
+#
+
+#
+# Memory Controller drivers
+#
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MISC is not set
+# CONFIG_CROS_EC is not set
+# CONFIG_FSL_SEC_MON is not set
+# CONFIG_MXC_OCOTP is not set
+# CONFIG_NUVOTON_NCT6102D is not set
+# CONFIG_PWRSEQ is not set
+# CONFIG_PCA9551_LED is not set
+# CONFIG_WINBOND_W83627 is not set
+
+#
+# MMC Host controller Support
+#
+# CONFIG_DM_MMC is not set
+
+#
+# MTD Support
+#
+# CONFIG_MTD is not set
+# CONFIG_FMC is not set
+
+#
+# NAND Device Support
+#
+# CONFIG_NAND_DENALI is not set
+# CONFIG_NAND_VF610_NFC is not set
+# CONFIG_NAND_PXA3XX is not set
+# CONFIG_NAND_ARASAN is not set
+
+#
+# Generic NAND options
+#
+
+#
+# SPI Flash Support
+#
+# CONFIG_SPI_FLASH is not set
+
+#
+# UBI support
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_DM_ETH is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_NETDEVICES is not set
+# CONFIG_PCI is not set
+# CONFIG_MVEBU_COMPHY_SUPPORT is not set
+CONFIG_PHY_VENDOR_USB=y
+
+#
+# Pin controllers
+#
+# CONFIG_PINCTRL is not set
+
+#
+# Power
+#
+
+#
+# Power Domain Support
+#
+# CONFIG_DM_PMIC is not set
+# CONFIG_DM_REGULATOR is not set
+# CONFIG_DM_PWM is not set
+# CONFIG_RAM is not set
+
+#
+# Remote Processor drivers
+#
+
+#
+# Reset Controller Support
+#
+
+#
+# Real Time Clock
+#
+# CONFIG_DM_RTC is not set
+
+#
+# Serial drivers
+#
+# CONFIG_DM_SERIAL is not set
+# CONFIG_DEBUG_UART is not set
+# CONFIG_DEBUG_UART_SKIP_INIT is not set
+# CONFIG_ATMEL_USART is not set
+# CONFIG_FSL_LPUART is not set
+# CONFIG_MVEBU_A3700_UART is not set
+# CONFIG_SYS_NS16550 is not set
+
+#
+# Sound support
+#
+# CONFIG_SOUND is not set
+
+#
+# SPI Support
+#
+# CONFIG_DM_SPI is not set
+# CONFIG_FSL_ESPI is not set
+# CONFIG_FSL_QSPI is not set
+# CONFIG_TI_QSPI is not set
+
+#
+# SPMI support
+#
+# CONFIG_SPMI is not set
+
+#
+# System reset device drivers
+#
+# CONFIG_SYSRESET is not set
+# CONFIG_DM_THERMAL is not set
+
+#
+# Timer Support
+#
+# CONFIG_TIMER is not set
+
+#
+# TPM support
+#
+CONFIG_USB=y
+# CONFIG_DM_USB is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_HOST=y
+CONFIG_USB_XHCI_HCD=y
+# CONFIG_USB_XHCI_DWC3 is not set
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_EHCI is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+
+#
+# MUSB Controller Driver
+#
+# CONFIG_USB_MUSB_HOST is not set
+# CONFIG_USB_MUSB_GADGET is not set
+
+#
+# ULPI drivers
+#
+
+#
+# USB peripherals
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_KEYBOARD is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# UFS Support
+#
+# CONFIG_UFS is not set
+
+#
+# Graphics support
+#
+# CONFIG_DM_VIDEO is not set
+
+#
+# TrueType Fonts
+#
+# CONFIG_VIDEO_VESA is not set
+# CONFIG_VIDEO_LCD_ANX9804 is not set
+# CONFIG_VIDEO_LCD_SSD2828 is not set
+# CONFIG_VIDEO_MVEBU is not set
+# CONFIG_DISPLAY is not set
+# CONFIG_VIDEO_BRIDGE is not set
+# CONFIG_LCD is not set
+# CONFIG_PHYS_TO_BUS is not set
+
+#
+# File systems
+#
+
+#
+# Library routines
+#
+# CONFIG_CC_OPTIMIZE_LIBS_FOR_SPEED is not set
+CONFIG_HAVE_PRIVATE_LIBGCC=y
+CONFIG_USE_PRIVATE_LIBGCC=y
+CONFIG_SYS_HZ=1000
+# CONFIG_USE_TINY_PRINTF is not set
+CONFIG_REGEX=y
+CONFIG_LIB_RAND=y
+# CONFIG_CMD_DHRYSTONE is not set
+# CONFIG_RSA is not set
+# CONFIG_TPM is not set
+
+#
+# Hashing Support
+#
+# CONFIG_SHA1 is not set
+# CONFIG_SHA256 is not set
+# CONFIG_SHA_HW_ACCEL is not set
+
+#
+# Compression Support
+#
+# CONFIG_LZ4 is not set
+# CONFIG_ERRNO_STR is not set
+# CONFIG_OF_LIBFDT is not set
+# CONFIG_OF_LIBFDT_OVERLAY is not set
+# CONFIG_SPL_OF_LIBFDT is not set
+
+#
+# System tables
+#
+CONFIG_HWDEC=y
+# CONFIG_OPTEE is not set
+CONFIG_OPTEE_LOAD_ADDR=0x00000000
+# CONFIG_BOOTM_OPTEE is not set
+# CONFIG_UNIT_TEST is not set
diff -uraN u-boot-2016.11/configs/gk7202v300_mini_defconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/configs/gk7202v300_mini_defconfig
--- u-boot-2016.11/configs/gk7202v300_mini_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/configs/gk7202v300_mini_defconfig	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,608 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# U-Boot 2016.11 Configuration
+#
+CONFIG_CREATE_ARCH_SYMLINK=y
+# CONFIG_ARC is not set
+CONFIG_ARM=y
+# CONFIG_AVR32 is not set
+# CONFIG_BLACKFIN is not set
+# CONFIG_M68K is not set
+# CONFIG_MICROBLAZE is not set
+# CONFIG_MIPS is not set
+# CONFIG_NDS32 is not set
+# CONFIG_NIOS2 is not set
+# CONFIG_OPENRISC is not set
+# CONFIG_PPC is not set
+# CONFIG_SANDBOX is not set
+# CONFIG_SH is not set
+# CONFIG_SPARC is not set
+# CONFIG_X86 is not set
+# CONFIG_XTENSA is not set
+CONFIG_SYS_ARCH="arm"
+CONFIG_SYS_CPU="armv7"
+CONFIG_SYS_SOC="gk7202v300"
+CONFIG_SYS_VENDOR="goke"
+CONFIG_SYS_BOARD="gk7202v300"
+CONFIG_SYS_CONFIG_NAME="gk7202v300"
+
+#
+# ARM architecture
+#
+CONFIG_MINI_BOOT=y
+CONFIG_HAS_VBAR=y
+CONFIG_CPU_V7=y
+CONFIG_SYS_ARM_ARCH=7
+CONFIG_SYS_CACHE_SHIFT_6=y
+CONFIG_SYS_CACHELINE_SIZE=64
+# CONFIG_SEMIHOSTING is not set
+# CONFIG_SYS_L2CACHE_OFF is not set
+# CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_TARGET_EDB93XX is not set
+# CONFIG_TARGET_VCMA9 is not set
+# CONFIG_TARGET_SMDK2410 is not set
+# CONFIG_TARGET_ASPENITE is not set
+# CONFIG_TARGET_GPLUGD is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_KIRKWOOD is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_TARGET_DEVKIT3250 is not set
+# CONFIG_TARGET_WORK_92105 is not set
+# CONFIG_TARGET_MX25PDK is not set
+# CONFIG_TARGET_ZMX25 is not set
+# CONFIG_TARGET_APF27 is not set
+# CONFIG_TARGET_APX4DEVKIT is not set
+# CONFIG_TARGET_XFI3 is not set
+# CONFIG_TARGET_M28EVK is not set
+# CONFIG_TARGET_MX23EVK is not set
+# CONFIG_TARGET_MX28EVK is not set
+# CONFIG_TARGET_MX23_OLINUXINO is not set
+# CONFIG_TARGET_BG0900 is not set
+# CONFIG_TARGET_SANSA_FUZE_PLUS is not set
+# CONFIG_TARGET_SC_SPS_1 is not set
+# CONFIG_ORION5X is not set
+# CONFIG_TARGET_SPEAR300 is not set
+# CONFIG_TARGET_SPEAR310 is not set
+# CONFIG_TARGET_SPEAR320 is not set
+# CONFIG_TARGET_SPEAR600 is not set
+# CONFIG_TARGET_STV0991 is not set
+# CONFIG_TARGET_X600 is not set
+# CONFIG_TARGET_IMX31_PHYCORE is not set
+# CONFIG_TARGET_MX31ADS is not set
+# CONFIG_TARGET_MX31PDK is not set
+# CONFIG_TARGET_WOODBURN is not set
+# CONFIG_TARGET_WOODBURN_SD is not set
+# CONFIG_TARGET_FLEA3 is not set
+# CONFIG_TARGET_MX35PDK is not set
+# CONFIG_ARCH_BCM283X is not set
+# CONFIG_TARGET_VEXPRESS_CA15_TC2 is not set
+# CONFIG_TARGET_VEXPRESS_CA5X2 is not set
+# CONFIG_TARGET_VEXPRESS_CA9X4 is not set
+# CONFIG_TARGET_BRXRE1 is not set
+# CONFIG_TARGET_BRPPT1 is not set
+# CONFIG_TARGET_DRACO is not set
+# CONFIG_TARGET_THUBAN is not set
+# CONFIG_TARGET_RASTABAN is not set
+# CONFIG_TARGET_ETAMIN is not set
+# CONFIG_TARGET_PXM2 is not set
+# CONFIG_TARGET_RUT is not set
+# CONFIG_TARGET_TI814X_EVM is not set
+# CONFIG_TARGET_TI816X_EVM is not set
+# CONFIG_TARGET_BCM23550_W1D is not set
+# CONFIG_TARGET_BCM28155_AP is not set
+# CONFIG_TARGET_BCMCYGNUS is not set
+# CONFIG_TARGET_BCMNSP is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MX7 is not set
+# CONFIG_ARCH_MX6 is not set
+# CONFIG_ARCH_MX5 is not set
+# CONFIG_TARGET_M53EVK is not set
+# CONFIG_TARGET_MX51EVK is not set
+# CONFIG_TARGET_MX53ARD is not set
+# CONFIG_TARGET_MX53EVK is not set
+# CONFIG_TARGET_MX53LOCO is not set
+# CONFIG_TARGET_MX53SMD is not set
+# CONFIG_OMAP34XX is not set
+# CONFIG_OMAP44XX is not set
+# CONFIG_OMAP54XX is not set
+# CONFIG_AM43XX is not set
+# CONFIG_AM33XX is not set
+# CONFIG_ARCH_RMOBILE is not set
+# CONFIG_TARGET_S32V234EVB is not set
+# CONFIG_ARCH_SNAPDRAGON is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_TARGET_CM_T43 is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_TARGET_TS4800 is not set
+# CONFIG_TARGET_VF610TWR is not set
+# CONFIG_TARGET_COLIBRI_VF is not set
+# CONFIG_TARGET_PCM052 is not set
+# CONFIG_TARGET_BK4R1 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_ARCH_ZYNQMP is not set
+# CONFIG_TEGRA is not set
+# CONFIG_TARGET_VEXPRESS64_AEMV8A is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP_DRAM is not set
+# CONFIG_TARGET_VEXPRESS64_JUNO is not set
+# CONFIG_TARGET_LS2080A_EMU is not set
+# CONFIG_TARGET_LS2080A_SIMU is not set
+# CONFIG_TARGET_LS2080AQDS is not set
+# CONFIG_TARGET_LS2080ARDB is not set
+# CONFIG_TARGET_HIKEY is not set
+# CONFIG_TARGET_GK7205V200 is not set
+CONFIG_TARGET_GK7202V300=y
+# CONFIG_TARGET_GK7605V100 is not set
+# CONFIG_TARGET_GK7205V300 is not set
+# CONFIG_TARGET_LS1012AQDS is not set
+# CONFIG_TARGET_LS1012ARDB is not set
+# CONFIG_TARGET_LS1012AFRDM is not set
+# CONFIG_TARGET_LS1021AQDS is not set
+# CONFIG_TARGET_LS1021ATWR is not set
+# CONFIG_TARGET_LS1043AQDS is not set
+# CONFIG_TARGET_LS1043ARDB is not set
+# CONFIG_TARGET_LS1046AQDS is not set
+# CONFIG_TARGET_LS1046ARDB is not set
+# CONFIG_TARGET_H2200 is not set
+# CONFIG_TARGET_ZIPITZ2 is not set
+# CONFIG_TARGET_COLIBRI_PXA270 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_STM32 is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_TARGET_THUNDERX_88XX is not set
+# CONFIG_ARMV7_LPAE is not set
+CONFIG_IDENT_STRING="gk7202v300"
+# CONFIG_PRE_CONSOLE_BUFFER is not set
+# CONFIG_MMC is not set
+# CONFIG_VIDEO is not set
+
+#
+# ARM debug
+#
+# CONFIG_DEBUG_LL is not set
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_DISTRO_DEFAULTS is not set
+# CONFIG_SYS_MALLOC_F is not set
+# CONFIG_EXPERT is not set
+# CONFIG_PHYS_64BIT is not set
+
+#
+# Boot images
+#
+# CONFIG_FIT is not set
+CONFIG_SYS_EXTRA_OPTIONS=""
+# CONFIG_ARCH_FIXUP_FDT is not set
+
+#
+# Boot timing
+#
+# CONFIG_BOOTSTAGE is not set
+CONFIG_BOOTSTAGE_USER_COUNT=20
+CONFIG_BOOTSTAGE_STASH_ADDR=0
+CONFIG_BOOTSTAGE_STASH_SIZE=4096
+
+#
+# Boot media
+#
+# CONFIG_NAND_BOOT is not set
+# CONFIG_ONENAND_BOOT is not set
+# CONFIG_QSPI_BOOT is not set
+# CONFIG_SATA_BOOT is not set
+# CONFIG_SD_BOOT is not set
+# CONFIG_SPI_BOOT is not set
+
+#
+# Console
+#
+# CONFIG_CONSOLE_RECORD is not set
+# CONFIG_SILENT_CONSOLE is not set
+# CONFIG_CONSOLE_MUX is not set
+# CONFIG_SYS_CONSOLE_IS_IN_ENV is not set
+# CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE is not set
+# CONFIG_SYS_CONSOLE_ENV_OVERWRITE is not set
+# CONFIG_SYS_CONSOLE_INFO_QUIET is not set
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_DEFAULT_FDT_FILE=""
+CONFIG_KERNEL_LOAD_ADDR=0x42080000
+# CONFIG_SYS_NO_FLASH is not set
+# CONFIG_VERSION_VARIABLE is not set
+# CONFIG_DISPLAY_CPUINFO is not set
+# CONFIG_DISPLAY_BOARDINFO is not set
+# CONFIG_CMD_CREAD is not set
+
+#
+# SPL / TPL
+#
+
+#
+# Command line interface
+#
+CONFIG_CMDLINE=y
+# CONFIG_HUSH_PARSER is not set
+CONFIG_SYS_PROMPT="goke # "
+
+#
+# Autoboot options
+#
+# CONFIG_AUTOBOOT is not set
+# CONFIG_AUTOBOOT_KEYED is not set
+
+#
+# FASTBOOT
+#
+# CONFIG_FASTBOOT is not set
+
+#
+# Commands
+#
+
+#
+# Info commands
+#
+# CONFIG_CMD_BDI is not set
+# CONFIG_CMD_CONSOLE is not set
+# CONFIG_CMD_CPU is not set
+# CONFIG_CMD_LICENSE is not set
+
+#
+# Boot commands
+#
+# CONFIG_CMD_BOOTD is not set
+# CONFIG_CMD_BOOTM is not set
+# CONFIG_CMD_BOOTZ is not set
+# CONFIG_CMD_ELF is not set
+# CONFIG_CMD_GO is not set
+# CONFIG_CMD_RUN is not set
+# CONFIG_CMD_IMI is not set
+# CONFIG_CMD_IMLS is not set
+# CONFIG_CMD_XIMG is not set
+
+#
+# Environment commands
+#
+# CONFIG_CMD_ASKENV is not set
+# CONFIG_CMD_EXPORTENV is not set
+# CONFIG_CMD_IMPORTENV is not set
+# CONFIG_CMD_EDITENV is not set
+# CONFIG_CMD_GREPENV is not set
+# CONFIG_CMD_SAVEENV is not set
+# CONFIG_CMD_ENV_EXISTS is not set
+
+#
+# Memory commands
+#
+# CONFIG_CMD_MEMORY is not set
+# CONFIG_CMD_CRC32 is not set
+# CONFIG_LOOPW is not set
+# CONFIG_CMD_MEMTEST is not set
+# CONFIG_CMD_MX_CYCLIC is not set
+# CONFIG_CMD_MEMINFO is not set
+
+#
+# Device access commands
+#
+# CONFIG_CMD_LOADB is not set
+# CONFIG_CMD_LOADS is not set
+# CONFIG_CMD_FLASH is not set
+# CONFIG_CMD_ARMFLASH is not set
+# CONFIG_CMD_MMC is not set
+# CONFIG_CMD_NAND is not set
+# CONFIG_CMD_SF is not set
+# CONFIG_CMD_SPI is not set
+# CONFIG_CMD_I2C is not set
+# CONFIG_CMD_USB is not set
+# CONFIG_CMD_DFU is not set
+# CONFIG_CMD_USB_MASS_STORAGE is not set
+# CONFIG_CMD_FPGA is not set
+# CONFIG_CMD_GPIO is not set
+
+#
+# Shell scripting commands
+#
+# CONFIG_CMD_ECHO is not set
+# CONFIG_CMD_ITEST is not set
+# CONFIG_CMD_SOURCE is not set
+# CONFIG_CMD_SETEXPR is not set
+
+#
+# Network commands
+#
+# CONFIG_CMD_NET is not set
+# CONFIG_CMD_TFTPPUT is not set
+# CONFIG_CMD_TFTPSRV is not set
+# CONFIG_CMD_RARP is not set
+# CONFIG_CMD_DHCP is not set
+# CONFIG_CMD_NFS is not set
+# CONFIG_CMD_MII is not set
+# CONFIG_CMD_PING is not set
+# CONFIG_CMD_CDP is not set
+# CONFIG_CMD_SNTP is not set
+# CONFIG_CMD_DNS is not set
+# CONFIG_CMD_LINK_LOCAL is not set
+
+#
+# Misc commands
+#
+# CONFIG_CMD_CACHE is not set
+# CONFIG_CMD_TIME is not set
+# CONFIG_CMD_MISC is not set
+# CONFIG_CMD_TIMER is not set
+# CONFIG_CMD_QFW is not set
+
+#
+# Power commands
+#
+
+#
+# Security commands
+#
+
+#
+# Firmware commands
+#
+
+#
+# Filesystem commands
+#
+# CONFIG_CMD_EXT2 is not set
+# CONFIG_CMD_EXT4 is not set
+# CONFIG_CMD_FAT is not set
+# CONFIG_CMD_FS_GENERIC is not set
+# CONFIG_CMD_UBI is not set
+CONFIG_SUPPORT_OF_CONTROL=y
+
+#
+# Device Tree Control
+#
+# CONFIG_OF_CONTROL is not set
+# CONFIG_NET is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_DM is not set
+# CONFIG_ADC is not set
+# CONFIG_ADC_EXYNOS is not set
+# CONFIG_ADC_SANDBOX is not set
+# CONFIG_BLOCK_CACHE is not set
+
+#
+# Clock
+#
+# CONFIG_CPU is not set
+
+#
+# Hardware crypto devices
+#
+# CONFIG_FSL_CAAM is not set
+
+#
+# Demo for driver model
+#
+
+#
+# DFU support
+#
+
+#
+# DMA Support
+#
+# CONFIG_TI_EDMA3 is not set
+
+#
+# FPGA support
+#
+# CONFIG_FPGA_XILINX is not set
+
+#
+# GPIO Support
+#
+
+#
+# I2C support
+#
+# CONFIG_SYS_I2C_DW is not set
+# CONFIG_CROS_EC_KEYB is not set
+
+#
+# LED Support
+#
+
+#
+# Mailbox Controller Support
+#
+
+#
+# Memory Controller drivers
+#
+
+#
+# Multifunction device drivers
+#
+# CONFIG_CROS_EC is not set
+# CONFIG_FSL_SEC_MON is not set
+# CONFIG_MXC_OCOTP is not set
+# CONFIG_NUVOTON_NCT6102D is not set
+# CONFIG_PCA9551_LED is not set
+# CONFIG_WINBOND_W83627 is not set
+
+#
+# MMC Host controller Support
+#
+
+#
+# MTD Support
+#
+CONFIG_FMC=y
+
+#
+# NAND Device Support
+#
+# CONFIG_NAND_DENALI is not set
+# CONFIG_NAND_VF610_NFC is not set
+# CONFIG_NAND_PXA3XX is not set
+# CONFIG_NAND_ARASAN is not set
+# CONFIG_FMC_SPI_NAND is not set
+# CONFIG_FMC_NAND is not set
+
+#
+# Generic NAND options
+#
+
+#
+# SPI Flash Support
+#
+# CONFIG_SPI_FLASH is not set
+CONFIG_FMC_SPI_NOR=y
+# CONFIG_SPI_BLOCK_PROTECT is not set
+# CONFIG_DTR_MODE_SUPPORT is not set
+
+#
+# UBI support
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_PCI is not set
+# CONFIG_MVEBU_COMPHY_SUPPORT is not set
+# CONFIG_PHY_VENDOR_USB is not set
+
+#
+# Pin controllers
+#
+
+#
+# Power
+#
+
+#
+# Power Domain Support
+#
+
+#
+# Remote Processor drivers
+#
+
+#
+# Reset Controller Support
+#
+
+#
+# Real Time Clock
+#
+
+#
+# Serial drivers
+#
+# CONFIG_DEBUG_UART is not set
+# CONFIG_DEBUG_UART_SKIP_INIT is not set
+# CONFIG_ATMEL_USART is not set
+# CONFIG_FSL_LPUART is not set
+# CONFIG_MVEBU_A3700_UART is not set
+# CONFIG_SYS_NS16550 is not set
+
+#
+# Sound support
+#
+# CONFIG_SOUND is not set
+
+#
+# SPI Support
+#
+# CONFIG_FSL_ESPI is not set
+# CONFIG_FSL_QSPI is not set
+# CONFIG_TI_QSPI is not set
+
+#
+# SPMI support
+#
+
+#
+# System reset device drivers
+#
+# CONFIG_DM_THERMAL is not set
+
+#
+# Timer Support
+#
+
+#
+# TPM support
+#
+# CONFIG_USB is not set
+
+#
+# UFS Support
+#
+# CONFIG_UFS is not set
+
+#
+# Graphics support
+#
+
+#
+# TrueType Fonts
+#
+# CONFIG_VIDEO_VESA is not set
+# CONFIG_VIDEO_LCD_ANX9804 is not set
+# CONFIG_VIDEO_LCD_SSD2828 is not set
+# CONFIG_VIDEO_MVEBU is not set
+# CONFIG_LCD is not set
+# CONFIG_PHYS_TO_BUS is not set
+
+#
+# File systems
+#
+
+#
+# Library routines
+#
+# CONFIG_CC_OPTIMIZE_LIBS_FOR_SPEED is not set
+CONFIG_HAVE_PRIVATE_LIBGCC=y
+# CONFIG_USE_PRIVATE_LIBGCC is not set
+CONFIG_SYS_HZ=1000
+# CONFIG_USE_TINY_PRINTF is not set
+# CONFIG_REGEX is not set
+# CONFIG_LIB_RAND is not set
+# CONFIG_CMD_DHRYSTONE is not set
+# CONFIG_RSA is not set
+
+#
+# Hashing Support
+#
+# CONFIG_SHA1 is not set
+# CONFIG_SHA256 is not set
+# CONFIG_SHA_HW_ACCEL is not set
+
+#
+# Compression Support
+#
+# CONFIG_LZ4 is not set
+# CONFIG_ERRNO_STR is not set
+# CONFIG_OF_LIBFDT is not set
+# CONFIG_OF_LIBFDT_OVERLAY is not set
+# CONFIG_SPL_OF_LIBFDT is not set
+
+#
+# System tables
+#
+CONFIG_HWDEC=y
+# CONFIG_OPTEE is not set
+CONFIG_OPTEE_LOAD_ADDR=0x00000000
+# CONFIG_BOOTM_OPTEE is not set
+# CONFIG_UNIT_TEST is not set
diff -uraN u-boot-2016.11/configs/gk7205v200_defconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/configs/gk7205v200_defconfig
--- u-boot-2016.11/configs/gk7205v200_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/configs/gk7205v200_defconfig	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,720 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# U-Boot 2016.11 Configuration
+#
+CONFIG_CREATE_ARCH_SYMLINK=y
+# CONFIG_ARC is not set
+CONFIG_ARM=y
+# CONFIG_AVR32 is not set
+# CONFIG_BLACKFIN is not set
+# CONFIG_M68K is not set
+# CONFIG_MICROBLAZE is not set
+# CONFIG_MIPS is not set
+# CONFIG_NDS32 is not set
+# CONFIG_NIOS2 is not set
+# CONFIG_OPENRISC is not set
+# CONFIG_PPC is not set
+# CONFIG_SANDBOX is not set
+# CONFIG_SH is not set
+# CONFIG_SPARC is not set
+# CONFIG_X86 is not set
+# CONFIG_XTENSA is not set
+CONFIG_SYS_ARCH="arm"
+CONFIG_SYS_CPU="armv7"
+CONFIG_SYS_SOC="gk7205v200"
+CONFIG_SYS_VENDOR="goke"
+CONFIG_SYS_BOARD="gk7205v200"
+CONFIG_SYS_CONFIG_NAME="gk7205v200"
+
+#
+# ARM architecture
+#
+# CONFIG_MINI_BOOT is not set
+CONFIG_HAS_VBAR=y
+CONFIG_HAS_THUMB2=y
+CONFIG_CPU_V7=y
+CONFIG_SYS_ARM_ARCH=7
+CONFIG_SYS_CACHE_SHIFT_6=y
+CONFIG_SYS_CACHELINE_SIZE=64
+# CONFIG_SEMIHOSTING is not set
+# CONFIG_SYS_L2CACHE_OFF is not set
+CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK=y
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_TARGET_EDB93XX is not set
+# CONFIG_TARGET_VCMA9 is not set
+# CONFIG_TARGET_SMDK2410 is not set
+# CONFIG_TARGET_ASPENITE is not set
+# CONFIG_TARGET_GPLUGD is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_KIRKWOOD is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_TARGET_DEVKIT3250 is not set
+# CONFIG_TARGET_WORK_92105 is not set
+# CONFIG_TARGET_MX25PDK is not set
+# CONFIG_TARGET_ZMX25 is not set
+# CONFIG_TARGET_APF27 is not set
+# CONFIG_TARGET_APX4DEVKIT is not set
+# CONFIG_TARGET_XFI3 is not set
+# CONFIG_TARGET_M28EVK is not set
+# CONFIG_TARGET_MX23EVK is not set
+# CONFIG_TARGET_MX28EVK is not set
+# CONFIG_TARGET_MX23_OLINUXINO is not set
+# CONFIG_TARGET_BG0900 is not set
+# CONFIG_TARGET_SANSA_FUZE_PLUS is not set
+# CONFIG_TARGET_SC_SPS_1 is not set
+# CONFIG_ORION5X is not set
+# CONFIG_TARGET_SPEAR300 is not set
+# CONFIG_TARGET_SPEAR310 is not set
+# CONFIG_TARGET_SPEAR320 is not set
+# CONFIG_TARGET_SPEAR600 is not set
+# CONFIG_TARGET_STV0991 is not set
+# CONFIG_TARGET_X600 is not set
+# CONFIG_TARGET_IMX31_PHYCORE is not set
+# CONFIG_TARGET_MX31ADS is not set
+# CONFIG_TARGET_MX31PDK is not set
+# CONFIG_TARGET_WOODBURN is not set
+# CONFIG_TARGET_WOODBURN_SD is not set
+# CONFIG_TARGET_FLEA3 is not set
+# CONFIG_TARGET_MX35PDK is not set
+# CONFIG_ARCH_BCM283X is not set
+# CONFIG_TARGET_VEXPRESS_CA15_TC2 is not set
+# CONFIG_TARGET_VEXPRESS_CA5X2 is not set
+# CONFIG_TARGET_VEXPRESS_CA9X4 is not set
+# CONFIG_TARGET_BRXRE1 is not set
+# CONFIG_TARGET_BRPPT1 is not set
+# CONFIG_TARGET_DRACO is not set
+# CONFIG_TARGET_THUBAN is not set
+# CONFIG_TARGET_RASTABAN is not set
+# CONFIG_TARGET_ETAMIN is not set
+# CONFIG_TARGET_PXM2 is not set
+# CONFIG_TARGET_RUT is not set
+# CONFIG_TARGET_TI814X_EVM is not set
+# CONFIG_TARGET_TI816X_EVM is not set
+# CONFIG_TARGET_BCM23550_W1D is not set
+# CONFIG_TARGET_BCM28155_AP is not set
+# CONFIG_TARGET_BCMCYGNUS is not set
+# CONFIG_TARGET_BCMNSP is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MX7 is not set
+# CONFIG_ARCH_MX6 is not set
+# CONFIG_ARCH_MX5 is not set
+# CONFIG_TARGET_M53EVK is not set
+# CONFIG_TARGET_MX51EVK is not set
+# CONFIG_TARGET_MX53ARD is not set
+# CONFIG_TARGET_MX53EVK is not set
+# CONFIG_TARGET_MX53LOCO is not set
+# CONFIG_TARGET_MX53SMD is not set
+# CONFIG_OMAP34XX is not set
+# CONFIG_OMAP44XX is not set
+# CONFIG_OMAP54XX is not set
+# CONFIG_AM43XX is not set
+# CONFIG_AM33XX is not set
+# CONFIG_ARCH_RMOBILE is not set
+# CONFIG_TARGET_S32V234EVB is not set
+# CONFIG_ARCH_SNAPDRAGON is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_TARGET_CM_T43 is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_TARGET_TS4800 is not set
+# CONFIG_TARGET_VF610TWR is not set
+# CONFIG_TARGET_COLIBRI_VF is not set
+# CONFIG_TARGET_PCM052 is not set
+# CONFIG_TARGET_BK4R1 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_ARCH_ZYNQMP is not set
+# CONFIG_TEGRA is not set
+# CONFIG_TARGET_VEXPRESS64_AEMV8A is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP_DRAM is not set
+# CONFIG_TARGET_VEXPRESS64_JUNO is not set
+# CONFIG_TARGET_LS2080A_EMU is not set
+# CONFIG_TARGET_LS2080A_SIMU is not set
+# CONFIG_TARGET_LS2080AQDS is not set
+# CONFIG_TARGET_LS2080ARDB is not set
+# CONFIG_TARGET_HIKEY is not set
+CONFIG_TARGET_GK7205V200=y
+# CONFIG_TARGET_GK7202V300 is not set
+# CONFIG_TARGET_GK7605V100 is not set
+# CONFIG_TARGET_GK7205V300 is not set
+# CONFIG_TARGET_LS1012AQDS is not set
+# CONFIG_TARGET_LS1012ARDB is not set
+# CONFIG_TARGET_LS1012AFRDM is not set
+# CONFIG_TARGET_LS1021AQDS is not set
+# CONFIG_TARGET_LS1021ATWR is not set
+# CONFIG_TARGET_LS1043AQDS is not set
+# CONFIG_TARGET_LS1043ARDB is not set
+# CONFIG_TARGET_LS1046AQDS is not set
+# CONFIG_TARGET_LS1046ARDB is not set
+# CONFIG_TARGET_H2200 is not set
+# CONFIG_TARGET_ZIPITZ2 is not set
+# CONFIG_TARGET_COLIBRI_PXA270 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_STM32 is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_TARGET_THUNDERX_88XX is not set
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_CPU_V7_HAS_NONSEC=y
+CONFIG_ARMV7_NONSEC=y
+CONFIG_ARMV7_BOOT_SEC_DEFAULT=y
+CONFIG_ARMV7_PSCI_NR_CPUS=4
+# CONFIG_ARMV7_LPAE is not set
+CONFIG_IDENT_STRING="gk7205v200"
+# CONFIG_PRE_CONSOLE_BUFFER is not set
+CONFIG_MMC=y
+# CONFIG_VIDEO is not set
+
+#
+# ARM debug
+#
+# CONFIG_DEBUG_LL is not set
+# CONFIG_AHCI is not set
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_DISTRO_DEFAULTS is not set
+CONFIG_SYS_MALLOC_F=y
+CONFIG_EXPERT=y
+CONFIG_SYS_MALLOC_CLEAR_ON_INIT=y
+# CONFIG_TOOLS_DEBUG is not set
+# CONFIG_PHYS_64BIT is not set
+
+#
+# Boot images
+#
+CONFIG_FIT=y
+# CONFIG_FIT_VERBOSE is not set
+# CONFIG_FIT_SIGNATURE is not set
+# CONFIG_FIT_BEST_MATCH is not set
+CONFIG_SYS_EXTRA_OPTIONS=""
+# CONFIG_SPL_LOAD_FIT is not set
+# CONFIG_SPL_DFU_SUPPORT is not set
+CONFIG_ARCH_FIXUP_FDT=y
+
+#
+# Boot timing
+#
+# CONFIG_BOOTSTAGE is not set
+CONFIG_BOOTSTAGE_USER_COUNT=20
+CONFIG_BOOTSTAGE_STASH_ADDR=0
+CONFIG_BOOTSTAGE_STASH_SIZE=4096
+
+#
+# Boot media
+#
+# CONFIG_NAND_BOOT is not set
+# CONFIG_ONENAND_BOOT is not set
+# CONFIG_QSPI_BOOT is not set
+# CONFIG_SATA_BOOT is not set
+# CONFIG_SD_BOOT is not set
+# CONFIG_SPI_BOOT is not set
+CONFIG_BOOTDELAY=2
+
+#
+# goke_setup
+#
+# CONFIG_GK_MC is not set
+# CONFIG_GK_SPIFLASH_SPEED is not set
+# CONFIG_GK_UPGRADE_BY_SEGMENT is not set
+# CONFIG_GK_DISABLE_CONSOLE is not set
+# CONFIG_GK_DISABLE_DOWNLOAD is not set
+
+#
+# Console
+#
+# CONFIG_CONSOLE_RECORD is not set
+# CONFIG_SILENT_CONSOLE is not set
+# CONFIG_CONSOLE_MUX is not set
+# CONFIG_SYS_CONSOLE_IS_IN_ENV is not set
+# CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE is not set
+# CONFIG_SYS_CONSOLE_ENV_OVERWRITE is not set
+# CONFIG_SYS_CONSOLE_INFO_QUIET is not set
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_DEFAULT_FDT_FILE=""
+CONFIG_KERNEL_LOAD_ADDR=0x42080000
+# CONFIG_SYS_NO_FLASH is not set
+# CONFIG_VERSION_VARIABLE is not set
+# CONFIG_DISPLAY_CPUINFO is not set
+# CONFIG_DISPLAY_BOARDINFO is not set
+# CONFIG_CMD_CREAD is not set
+
+#
+# SPL / TPL
+#
+
+#
+# Command line interface
+#
+CONFIG_CMDLINE=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="goke # "
+
+#
+# Autoboot options
+#
+CONFIG_AUTOBOOT=y
+# CONFIG_AUTOBOOT_KEYED is not set
+
+#
+# FASTBOOT
+#
+# CONFIG_FASTBOOT is not set
+
+#
+# Commands
+#
+
+#
+# Info commands
+#
+CONFIG_CMD_BDI=y
+CONFIG_CMD_CONSOLE=y
+# CONFIG_CMD_CPU is not set
+# CONFIG_CMD_LICENSE is not set
+
+#
+# Boot commands
+#
+CONFIG_CMD_BOOTD=y
+CONFIG_CMD_BOOTM=y
+# CONFIG_CMD_BOOTZ is not set
+CONFIG_CMD_ELF=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_RUN=y
+CONFIG_CMD_IMI=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_XIMG=y
+
+#
+# Environment commands
+#
+# CONFIG_CMD_ASKENV is not set
+CONFIG_CMD_EXPORTENV=y
+CONFIG_CMD_IMPORTENV=y
+CONFIG_CMD_EDITENV=y
+# CONFIG_CMD_GREPENV is not set
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_ENV_EXISTS=y
+
+#
+# Memory commands
+#
+CONFIG_CMD_MEMORY=y
+CONFIG_CMD_CRC32=y
+# CONFIG_LOOPW is not set
+# CONFIG_CMD_MEMTEST is not set
+# CONFIG_CMD_MX_CYCLIC is not set
+# CONFIG_CMD_MEMINFO is not set
+
+#
+# Device access commands
+#
+CONFIG_CMD_DM=y
+# CONFIG_CMD_DEMO is not set
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_LOADS=y
+CONFIG_CMD_FLASH=y
+# CONFIG_CMD_ARMFLASH is not set
+# CONFIG_CMD_MMC is not set
+# CONFIG_CMD_NAND is not set
+# CONFIG_CMD_SF is not set
+# CONFIG_CMD_SPI is not set
+# CONFIG_CMD_I2C is not set
+CONFIG_CMD_USB=y
+# CONFIG_CMD_DFU is not set
+# CONFIG_CMD_USB_MASS_STORAGE is not set
+CONFIG_CMD_FPGA=y
+# CONFIG_CMD_GPIO is not set
+
+#
+# Shell scripting commands
+#
+CONFIG_CMD_ECHO=y
+CONFIG_CMD_ITEST=y
+CONFIG_CMD_SOURCE=y
+CONFIG_CMD_SETEXPR=y
+
+#
+# Network commands
+#
+CONFIG_CMD_NET=y
+# CONFIG_CMD_TFTPPUT is not set
+# CONFIG_CMD_TFTPSRV is not set
+# CONFIG_CMD_RARP is not set
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_NFS=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+# CONFIG_CMD_CDP is not set
+# CONFIG_CMD_SNTP is not set
+# CONFIG_CMD_DNS is not set
+# CONFIG_CMD_LINK_LOCAL is not set
+
+#
+# Misc commands
+#
+CONFIG_CMD_CACHE=y
+# CONFIG_CMD_TIME is not set
+CONFIG_CMD_MISC=y
+# CONFIG_CMD_TIMER is not set
+# CONFIG_CMD_QFW is not set
+
+#
+# Power commands
+#
+
+#
+# Security commands
+#
+
+#
+# Firmware commands
+#
+
+#
+# Filesystem commands
+#
+# CONFIG_CMD_EXT2 is not set
+# CONFIG_CMD_EXT4 is not set
+# CONFIG_CMD_FAT is not set
+# CONFIG_CMD_FS_GENERIC is not set
+# CONFIG_CMD_UBI is not set
+CONFIG_SUPPORT_OF_CONTROL=y
+
+#
+# Device Tree Control
+#
+# CONFIG_OF_CONTROL is not set
+CONFIG_NET=y
+CONFIG_NET_RANDOM_ETHADDR=y
+# CONFIG_NETCONSOLE is not set
+CONFIG_NET_TFTP_VARS=y
+CONFIG_BOOTP_PXE_CLIENTARCH=0x15
+CONFIG_BOOTP_VCI_STRING="U-Boot.armv7"
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_DM=y
+CONFIG_DM_WARN=y
+CONFIG_DM_DEVICE_REMOVE=y
+CONFIG_DM_STDIO=y
+CONFIG_DM_SEQ_ALIAS=y
+# CONFIG_SPL_DM_SEQ_ALIAS is not set
+# CONFIG_REGMAP is not set
+# CONFIG_SPL_REGMAP is not set
+# CONFIG_DEVRES is not set
+# CONFIG_ADC is not set
+# CONFIG_ADC_EXYNOS is not set
+# CONFIG_ADC_SANDBOX is not set
+# CONFIG_BLK is not set
+# CONFIG_BLOCK_CACHE is not set
+
+#
+# Clock
+#
+# CONFIG_CLK is not set
+# CONFIG_CPU is not set
+
+#
+# Hardware crypto devices
+#
+# CONFIG_FSL_CAAM is not set
+
+#
+# Demo for driver model
+#
+# CONFIG_DM_DEMO is not set
+
+#
+# DFU support
+#
+
+#
+# DMA Support
+#
+# CONFIG_DMA is not set
+# CONFIG_TI_EDMA3 is not set
+
+#
+# FPGA support
+#
+# CONFIG_FPGA_XILINX is not set
+
+#
+# GPIO Support
+#
+# CONFIG_DM_GPIO is not set
+# CONFIG_INTEL_BROADWELL_GPIO is not set
+# CONFIG_LPC32XX_GPIO is not set
+# CONFIG_VYBRID_GPIO is not set
+
+#
+# I2C support
+#
+# CONFIG_DM_I2C is not set
+# CONFIG_DM_I2C_COMPAT is not set
+# CONFIG_SYS_I2C_DW is not set
+# CONFIG_DM_KEYBOARD is not set
+# CONFIG_CROS_EC_KEYB is not set
+
+#
+# LED Support
+#
+# CONFIG_LED is not set
+
+#
+# Mailbox Controller Support
+#
+
+#
+# Memory Controller drivers
+#
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MISC is not set
+# CONFIG_CROS_EC is not set
+# CONFIG_FSL_SEC_MON is not set
+# CONFIG_MXC_OCOTP is not set
+# CONFIG_NUVOTON_NCT6102D is not set
+# CONFIG_PWRSEQ is not set
+# CONFIG_PCA9551_LED is not set
+# CONFIG_WINBOND_W83627 is not set
+
+#
+# MMC Host controller Support
+#
+# CONFIG_DM_MMC is not set
+
+#
+# MTD Support
+#
+# CONFIG_MTD is not set
+CONFIG_FMC=y
+
+#
+# NAND Device Support
+#
+# CONFIG_NAND_DENALI is not set
+# CONFIG_NAND_VF610_NFC is not set
+# CONFIG_NAND_PXA3XX is not set
+# CONFIG_NAND_ARASAN is not set
+CONFIG_FMC_SPI_NAND=y
+# CONFIG_FMC_NAND is not set
+CONFIG_SPI_NAND_MAX_CHIP_NUM=1
+# CONFIG_FMC100_HARDWARE_PAGESIZE_ECC is not set
+CONFIG_FMC100_AUTO_PAGESIZE_ECC=y
+# CONFIG_FMC100_PAGESIZE_AUTO_ECC_NONE is not set
+
+#
+# Generic NAND options
+#
+
+#
+# SPI Flash Support
+#
+# CONFIG_SPI_FLASH is not set
+CONFIG_FMC_SPI_NOR=y
+# CONFIG_SPI_BLOCK_PROTECT is not set
+# CONFIG_DTR_MODE_SUPPORT is not set
+
+#
+# UBI support
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_DM_ETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NETDEVICES=y
+# CONFIG_E1000 is not set
+# CONFIG_ETH_DESIGNWARE is not set
+# CONFIG_ETHOC is not set
+# CONFIG_RTL8139 is not set
+# CONFIG_RTL8169 is not set
+CONFIG_NET_FEMAC=y
+# CONFIG_NET_GMACV300 is not set
+# CONFIG_PCI is not set
+# CONFIG_MVEBU_COMPHY_SUPPORT is not set
+CONFIG_PHY_VENDOR_USB=y
+
+#
+# Pin controllers
+#
+# CONFIG_PINCTRL is not set
+
+#
+# Power
+#
+
+#
+# Power Domain Support
+#
+# CONFIG_DM_PMIC is not set
+# CONFIG_DM_REGULATOR is not set
+# CONFIG_DM_PWM is not set
+# CONFIG_RAM is not set
+
+#
+# Remote Processor drivers
+#
+
+#
+# Reset Controller Support
+#
+
+#
+# Real Time Clock
+#
+# CONFIG_DM_RTC is not set
+
+#
+# Serial drivers
+#
+# CONFIG_DM_SERIAL is not set
+# CONFIG_DEBUG_UART is not set
+# CONFIG_DEBUG_UART_SKIP_INIT is not set
+# CONFIG_ATMEL_USART is not set
+# CONFIG_FSL_LPUART is not set
+# CONFIG_MVEBU_A3700_UART is not set
+# CONFIG_SYS_NS16550 is not set
+
+#
+# Sound support
+#
+# CONFIG_SOUND is not set
+
+#
+# SPI Support
+#
+# CONFIG_DM_SPI is not set
+# CONFIG_FSL_ESPI is not set
+# CONFIG_FSL_QSPI is not set
+# CONFIG_TI_QSPI is not set
+
+#
+# SPMI support
+#
+# CONFIG_SPMI is not set
+
+#
+# System reset device drivers
+#
+# CONFIG_SYSRESET is not set
+# CONFIG_DM_THERMAL is not set
+
+#
+# Timer Support
+#
+# CONFIG_TIMER is not set
+
+#
+# TPM support
+#
+CONFIG_USB=y
+# CONFIG_DM_USB is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_HOST=y
+CONFIG_USB_XHCI_HCD=y
+# CONFIG_USB_XHCI_DWC3 is not set
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_EHCI is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+
+#
+# MUSB Controller Driver
+#
+# CONFIG_USB_MUSB_HOST is not set
+# CONFIG_USB_MUSB_GADGET is not set
+
+#
+# ULPI drivers
+#
+
+#
+# USB peripherals
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_KEYBOARD is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# UFS Support
+#
+# CONFIG_UFS is not set
+
+#
+# Graphics support
+#
+# CONFIG_DM_VIDEO is not set
+
+#
+# TrueType Fonts
+#
+# CONFIG_VIDEO_VESA is not set
+# CONFIG_VIDEO_LCD_ANX9804 is not set
+# CONFIG_VIDEO_LCD_SSD2828 is not set
+# CONFIG_VIDEO_MVEBU is not set
+# CONFIG_DISPLAY is not set
+# CONFIG_VIDEO_BRIDGE is not set
+# CONFIG_LCD is not set
+# CONFIG_PHYS_TO_BUS is not set
+
+#
+# File systems
+#
+
+#
+# Library routines
+#
+# CONFIG_CC_OPTIMIZE_LIBS_FOR_SPEED is not set
+CONFIG_HAVE_PRIVATE_LIBGCC=y
+CONFIG_USE_PRIVATE_LIBGCC=y
+CONFIG_SYS_HZ=1000
+# CONFIG_USE_TINY_PRINTF is not set
+CONFIG_REGEX=y
+CONFIG_LIB_RAND=y
+# CONFIG_CMD_DHRYSTONE is not set
+# CONFIG_RSA is not set
+# CONFIG_TPM is not set
+
+#
+# Hashing Support
+#
+# CONFIG_SHA1 is not set
+# CONFIG_SHA256 is not set
+# CONFIG_SHA_HW_ACCEL is not set
+
+#
+# Compression Support
+#
+# CONFIG_LZ4 is not set
+# CONFIG_ERRNO_STR is not set
+# CONFIG_OF_LIBFDT is not set
+# CONFIG_OF_LIBFDT_OVERLAY is not set
+# CONFIG_SPL_OF_LIBFDT is not set
+
+#
+# System tables
+#
+CONFIG_HWDEC=y
+# CONFIG_OPTEE is not set
+CONFIG_OPTEE_LOAD_ADDR=0x00000000
+# CONFIG_BOOTM_OPTEE is not set
+# CONFIG_UNIT_TEST is not set
diff -uraN u-boot-2016.11/configs/gk7205v200_emmc_defconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/configs/gk7205v200_emmc_defconfig
--- u-boot-2016.11/configs/gk7205v200_emmc_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/configs/gk7205v200_emmc_defconfig	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,710 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# U-Boot 2016.11 Configuration
+#
+CONFIG_CREATE_ARCH_SYMLINK=y
+# CONFIG_ARC is not set
+CONFIG_ARM=y
+# CONFIG_AVR32 is not set
+# CONFIG_BLACKFIN is not set
+# CONFIG_M68K is not set
+# CONFIG_MICROBLAZE is not set
+# CONFIG_MIPS is not set
+# CONFIG_NDS32 is not set
+# CONFIG_NIOS2 is not set
+# CONFIG_OPENRISC is not set
+# CONFIG_PPC is not set
+# CONFIG_SANDBOX is not set
+# CONFIG_SH is not set
+# CONFIG_SPARC is not set
+# CONFIG_X86 is not set
+# CONFIG_XTENSA is not set
+CONFIG_SYS_ARCH="arm"
+CONFIG_SYS_CPU="armv7"
+CONFIG_SYS_SOC="gk7205v200"
+CONFIG_SYS_VENDOR="goke"
+CONFIG_SYS_BOARD="gk7205v200"
+CONFIG_SYS_CONFIG_NAME="gk7205v200"
+
+#
+# ARM architecture
+#
+# CONFIG_MINI_BOOT is not set
+CONFIG_HAS_VBAR=y
+CONFIG_HAS_THUMB2=y
+CONFIG_CPU_V7=y
+CONFIG_SYS_ARM_ARCH=7
+CONFIG_SYS_CACHE_SHIFT_6=y
+CONFIG_SYS_CACHELINE_SIZE=64
+# CONFIG_SEMIHOSTING is not set
+# CONFIG_SYS_L2CACHE_OFF is not set
+CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK=y
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_TARGET_EDB93XX is not set
+# CONFIG_TARGET_VCMA9 is not set
+# CONFIG_TARGET_SMDK2410 is not set
+# CONFIG_TARGET_ASPENITE is not set
+# CONFIG_TARGET_GPLUGD is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_KIRKWOOD is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_TARGET_DEVKIT3250 is not set
+# CONFIG_TARGET_WORK_92105 is not set
+# CONFIG_TARGET_MX25PDK is not set
+# CONFIG_TARGET_ZMX25 is not set
+# CONFIG_TARGET_APF27 is not set
+# CONFIG_TARGET_APX4DEVKIT is not set
+# CONFIG_TARGET_XFI3 is not set
+# CONFIG_TARGET_M28EVK is not set
+# CONFIG_TARGET_MX23EVK is not set
+# CONFIG_TARGET_MX28EVK is not set
+# CONFIG_TARGET_MX23_OLINUXINO is not set
+# CONFIG_TARGET_BG0900 is not set
+# CONFIG_TARGET_SANSA_FUZE_PLUS is not set
+# CONFIG_TARGET_SC_SPS_1 is not set
+# CONFIG_ORION5X is not set
+# CONFIG_TARGET_SPEAR300 is not set
+# CONFIG_TARGET_SPEAR310 is not set
+# CONFIG_TARGET_SPEAR320 is not set
+# CONFIG_TARGET_SPEAR600 is not set
+# CONFIG_TARGET_STV0991 is not set
+# CONFIG_TARGET_X600 is not set
+# CONFIG_TARGET_IMX31_PHYCORE is not set
+# CONFIG_TARGET_MX31ADS is not set
+# CONFIG_TARGET_MX31PDK is not set
+# CONFIG_TARGET_WOODBURN is not set
+# CONFIG_TARGET_WOODBURN_SD is not set
+# CONFIG_TARGET_FLEA3 is not set
+# CONFIG_TARGET_MX35PDK is not set
+# CONFIG_ARCH_BCM283X is not set
+# CONFIG_TARGET_VEXPRESS_CA15_TC2 is not set
+# CONFIG_TARGET_VEXPRESS_CA5X2 is not set
+# CONFIG_TARGET_VEXPRESS_CA9X4 is not set
+# CONFIG_TARGET_BRXRE1 is not set
+# CONFIG_TARGET_BRPPT1 is not set
+# CONFIG_TARGET_DRACO is not set
+# CONFIG_TARGET_THUBAN is not set
+# CONFIG_TARGET_RASTABAN is not set
+# CONFIG_TARGET_ETAMIN is not set
+# CONFIG_TARGET_PXM2 is not set
+# CONFIG_TARGET_RUT is not set
+# CONFIG_TARGET_TI814X_EVM is not set
+# CONFIG_TARGET_TI816X_EVM is not set
+# CONFIG_TARGET_BCM23550_W1D is not set
+# CONFIG_TARGET_BCM28155_AP is not set
+# CONFIG_TARGET_BCMCYGNUS is not set
+# CONFIG_TARGET_BCMNSP is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MX7 is not set
+# CONFIG_ARCH_MX6 is not set
+# CONFIG_ARCH_MX5 is not set
+# CONFIG_TARGET_M53EVK is not set
+# CONFIG_TARGET_MX51EVK is not set
+# CONFIG_TARGET_MX53ARD is not set
+# CONFIG_TARGET_MX53EVK is not set
+# CONFIG_TARGET_MX53LOCO is not set
+# CONFIG_TARGET_MX53SMD is not set
+# CONFIG_OMAP34XX is not set
+# CONFIG_OMAP44XX is not set
+# CONFIG_OMAP54XX is not set
+# CONFIG_AM43XX is not set
+# CONFIG_AM33XX is not set
+# CONFIG_ARCH_RMOBILE is not set
+# CONFIG_TARGET_S32V234EVB is not set
+# CONFIG_ARCH_SNAPDRAGON is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_TARGET_CM_T43 is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_TARGET_TS4800 is not set
+# CONFIG_TARGET_VF610TWR is not set
+# CONFIG_TARGET_COLIBRI_VF is not set
+# CONFIG_TARGET_PCM052 is not set
+# CONFIG_TARGET_BK4R1 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_ARCH_ZYNQMP is not set
+# CONFIG_TEGRA is not set
+# CONFIG_TARGET_VEXPRESS64_AEMV8A is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP_DRAM is not set
+# CONFIG_TARGET_VEXPRESS64_JUNO is not set
+# CONFIG_TARGET_LS2080A_EMU is not set
+# CONFIG_TARGET_LS2080A_SIMU is not set
+# CONFIG_TARGET_LS2080AQDS is not set
+# CONFIG_TARGET_LS2080ARDB is not set
+# CONFIG_TARGET_HIKEY is not set
+CONFIG_TARGET_GK7205V200=y
+# CONFIG_TARGET_GK7202V300 is not set
+# CONFIG_TARGET_GK7605V100 is not set
+# CONFIG_TARGET_GK7205V300 is not set
+# CONFIG_TARGET_LS1012AQDS is not set
+# CONFIG_TARGET_LS1012ARDB is not set
+# CONFIG_TARGET_LS1012AFRDM is not set
+# CONFIG_TARGET_LS1021AQDS is not set
+# CONFIG_TARGET_LS1021ATWR is not set
+# CONFIG_TARGET_LS1043AQDS is not set
+# CONFIG_TARGET_LS1043ARDB is not set
+# CONFIG_TARGET_LS1046AQDS is not set
+# CONFIG_TARGET_LS1046ARDB is not set
+# CONFIG_TARGET_H2200 is not set
+# CONFIG_TARGET_ZIPITZ2 is not set
+# CONFIG_TARGET_COLIBRI_PXA270 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_STM32 is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_TARGET_THUNDERX_88XX is not set
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_CPU_V7_HAS_NONSEC=y
+CONFIG_ARMV7_NONSEC=y
+CONFIG_ARMV7_BOOT_SEC_DEFAULT=y
+CONFIG_ARMV7_PSCI_NR_CPUS=4
+# CONFIG_ARMV7_LPAE is not set
+CONFIG_IDENT_STRING="gk7205v200"
+# CONFIG_PRE_CONSOLE_BUFFER is not set
+CONFIG_MMC=y
+# CONFIG_VIDEO is not set
+
+#
+# ARM debug
+#
+# CONFIG_DEBUG_LL is not set
+# CONFIG_AHCI is not set
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_DISTRO_DEFAULTS is not set
+CONFIG_SYS_MALLOC_F=y
+CONFIG_EXPERT=y
+CONFIG_SYS_MALLOC_CLEAR_ON_INIT=y
+# CONFIG_TOOLS_DEBUG is not set
+# CONFIG_PHYS_64BIT is not set
+
+#
+# Boot images
+#
+CONFIG_FIT=y
+# CONFIG_FIT_VERBOSE is not set
+# CONFIG_FIT_SIGNATURE is not set
+# CONFIG_FIT_BEST_MATCH is not set
+CONFIG_SYS_EXTRA_OPTIONS=""
+# CONFIG_SPL_LOAD_FIT is not set
+# CONFIG_SPL_DFU_SUPPORT is not set
+CONFIG_ARCH_FIXUP_FDT=y
+
+#
+# Boot timing
+#
+# CONFIG_BOOTSTAGE is not set
+CONFIG_BOOTSTAGE_USER_COUNT=20
+CONFIG_BOOTSTAGE_STASH_ADDR=0
+CONFIG_BOOTSTAGE_STASH_SIZE=4096
+
+#
+# Boot media
+#
+# CONFIG_NAND_BOOT is not set
+# CONFIG_ONENAND_BOOT is not set
+# CONFIG_QSPI_BOOT is not set
+# CONFIG_SATA_BOOT is not set
+# CONFIG_SD_BOOT is not set
+# CONFIG_SPI_BOOT is not set
+CONFIG_BOOTDELAY=2
+
+#
+# goke_setup
+#
+# CONFIG_GK_MC is not set
+# CONFIG_GK_UPGRADE_BY_SEGMENT is not set
+# CONFIG_GK_DISABLE_CONSOLE is not set
+# CONFIG_GK_DISABLE_DOWNLOAD is not set
+
+#
+# Console
+#
+# CONFIG_CONSOLE_RECORD is not set
+# CONFIG_SILENT_CONSOLE is not set
+# CONFIG_CONSOLE_MUX is not set
+# CONFIG_SYS_CONSOLE_IS_IN_ENV is not set
+# CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE is not set
+# CONFIG_SYS_CONSOLE_ENV_OVERWRITE is not set
+# CONFIG_SYS_CONSOLE_INFO_QUIET is not set
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_DEFAULT_FDT_FILE=""
+CONFIG_KERNEL_LOAD_ADDR=0x42080000
+# CONFIG_SYS_NO_FLASH is not set
+# CONFIG_VERSION_VARIABLE is not set
+# CONFIG_DISPLAY_CPUINFO is not set
+# CONFIG_DISPLAY_BOARDINFO is not set
+# CONFIG_CMD_CREAD is not set
+
+#
+# SPL / TPL
+#
+
+#
+# Command line interface
+#
+CONFIG_CMDLINE=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="goke # "
+
+#
+# Autoboot options
+#
+CONFIG_AUTOBOOT=y
+# CONFIG_AUTOBOOT_KEYED is not set
+
+#
+# FASTBOOT
+#
+# CONFIG_FASTBOOT is not set
+
+#
+# Commands
+#
+
+#
+# Info commands
+#
+CONFIG_CMD_BDI=y
+CONFIG_CMD_CONSOLE=y
+# CONFIG_CMD_CPU is not set
+# CONFIG_CMD_LICENSE is not set
+
+#
+# Boot commands
+#
+CONFIG_CMD_BOOTD=y
+CONFIG_CMD_BOOTM=y
+# CONFIG_CMD_BOOTZ is not set
+CONFIG_CMD_ELF=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_RUN=y
+CONFIG_CMD_IMI=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_XIMG=y
+
+#
+# Environment commands
+#
+# CONFIG_CMD_ASKENV is not set
+CONFIG_CMD_EXPORTENV=y
+CONFIG_CMD_IMPORTENV=y
+CONFIG_CMD_EDITENV=y
+# CONFIG_CMD_GREPENV is not set
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_ENV_EXISTS=y
+
+#
+# Memory commands
+#
+CONFIG_CMD_MEMORY=y
+CONFIG_CMD_CRC32=y
+# CONFIG_LOOPW is not set
+# CONFIG_CMD_MEMTEST is not set
+# CONFIG_CMD_MX_CYCLIC is not set
+# CONFIG_CMD_MEMINFO is not set
+
+#
+# Device access commands
+#
+CONFIG_CMD_DM=y
+# CONFIG_CMD_DEMO is not set
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_LOADS=y
+CONFIG_CMD_FLASH=y
+# CONFIG_CMD_ARMFLASH is not set
+# CONFIG_CMD_MMC is not set
+# CONFIG_CMD_NAND is not set
+# CONFIG_CMD_SF is not set
+# CONFIG_CMD_SPI is not set
+# CONFIG_CMD_I2C is not set
+CONFIG_CMD_USB=y
+# CONFIG_CMD_DFU is not set
+# CONFIG_CMD_USB_MASS_STORAGE is not set
+CONFIG_CMD_FPGA=y
+# CONFIG_CMD_GPIO is not set
+
+#
+# Shell scripting commands
+#
+CONFIG_CMD_ECHO=y
+CONFIG_CMD_ITEST=y
+CONFIG_CMD_SOURCE=y
+CONFIG_CMD_SETEXPR=y
+
+#
+# Network commands
+#
+CONFIG_CMD_NET=y
+# CONFIG_CMD_TFTPPUT is not set
+# CONFIG_CMD_TFTPSRV is not set
+# CONFIG_CMD_RARP is not set
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_NFS=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+# CONFIG_CMD_CDP is not set
+# CONFIG_CMD_SNTP is not set
+# CONFIG_CMD_DNS is not set
+# CONFIG_CMD_LINK_LOCAL is not set
+
+#
+# Misc commands
+#
+CONFIG_CMD_CACHE=y
+# CONFIG_CMD_TIME is not set
+CONFIG_CMD_MISC=y
+# CONFIG_CMD_TIMER is not set
+# CONFIG_CMD_QFW is not set
+
+#
+# Power commands
+#
+
+#
+# Security commands
+#
+
+#
+# Firmware commands
+#
+
+#
+# Filesystem commands
+#
+# CONFIG_CMD_EXT2 is not set
+# CONFIG_CMD_EXT4 is not set
+# CONFIG_CMD_FAT is not set
+# CONFIG_CMD_FS_GENERIC is not set
+# CONFIG_CMD_UBI is not set
+CONFIG_SUPPORT_OF_CONTROL=y
+
+#
+# Device Tree Control
+#
+# CONFIG_OF_CONTROL is not set
+CONFIG_NET=y
+CONFIG_NET_RANDOM_ETHADDR=y
+# CONFIG_NETCONSOLE is not set
+CONFIG_NET_TFTP_VARS=y
+CONFIG_BOOTP_PXE_CLIENTARCH=0x15
+CONFIG_BOOTP_VCI_STRING="U-Boot.armv7"
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_DM=y
+CONFIG_DM_WARN=y
+CONFIG_DM_DEVICE_REMOVE=y
+CONFIG_DM_STDIO=y
+CONFIG_DM_SEQ_ALIAS=y
+# CONFIG_SPL_DM_SEQ_ALIAS is not set
+# CONFIG_REGMAP is not set
+# CONFIG_SPL_REGMAP is not set
+# CONFIG_DEVRES is not set
+# CONFIG_ADC is not set
+# CONFIG_ADC_EXYNOS is not set
+# CONFIG_ADC_SANDBOX is not set
+# CONFIG_BLK is not set
+# CONFIG_BLOCK_CACHE is not set
+
+#
+# Clock
+#
+# CONFIG_CLK is not set
+# CONFIG_CPU is not set
+
+#
+# Hardware crypto devices
+#
+# CONFIG_FSL_CAAM is not set
+
+#
+# Demo for driver model
+#
+# CONFIG_DM_DEMO is not set
+
+#
+# DFU support
+#
+
+#
+# DMA Support
+#
+# CONFIG_DMA is not set
+# CONFIG_TI_EDMA3 is not set
+
+#
+# FPGA support
+#
+# CONFIG_FPGA_XILINX is not set
+
+#
+# GPIO Support
+#
+# CONFIG_DM_GPIO is not set
+# CONFIG_INTEL_BROADWELL_GPIO is not set
+# CONFIG_LPC32XX_GPIO is not set
+# CONFIG_VYBRID_GPIO is not set
+
+#
+# I2C support
+#
+# CONFIG_DM_I2C is not set
+# CONFIG_DM_I2C_COMPAT is not set
+# CONFIG_SYS_I2C_DW is not set
+# CONFIG_DM_KEYBOARD is not set
+# CONFIG_CROS_EC_KEYB is not set
+
+#
+# LED Support
+#
+# CONFIG_LED is not set
+
+#
+# Mailbox Controller Support
+#
+
+#
+# Memory Controller drivers
+#
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MISC is not set
+# CONFIG_CROS_EC is not set
+# CONFIG_FSL_SEC_MON is not set
+# CONFIG_MXC_OCOTP is not set
+# CONFIG_NUVOTON_NCT6102D is not set
+# CONFIG_PWRSEQ is not set
+# CONFIG_PCA9551_LED is not set
+# CONFIG_WINBOND_W83627 is not set
+
+#
+# MMC Host controller Support
+#
+# CONFIG_DM_MMC is not set
+
+#
+# MTD Support
+#
+# CONFIG_MTD is not set
+# CONFIG_FMC is not set
+
+#
+# NAND Device Support
+#
+# CONFIG_NAND_DENALI is not set
+# CONFIG_NAND_VF610_NFC is not set
+# CONFIG_NAND_PXA3XX is not set
+# CONFIG_NAND_ARASAN is not set
+
+#
+# Generic NAND options
+#
+
+#
+# SPI Flash Support
+#
+# CONFIG_SPI_FLASH is not set
+
+#
+# UBI support
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_DM_ETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NETDEVICES=y
+# CONFIG_E1000 is not set
+# CONFIG_ETH_DESIGNWARE is not set
+# CONFIG_ETHOC is not set
+# CONFIG_RTL8139 is not set
+# CONFIG_RTL8169 is not set
+CONFIG_NET_FEMAC=y
+# CONFIG_NET_GMACV300 is not set
+# CONFIG_PCI is not set
+# CONFIG_MVEBU_COMPHY_SUPPORT is not set
+CONFIG_PHY_VENDOR_USB=y
+
+#
+# Pin controllers
+#
+# CONFIG_PINCTRL is not set
+
+#
+# Power
+#
+
+#
+# Power Domain Support
+#
+# CONFIG_DM_PMIC is not set
+# CONFIG_DM_REGULATOR is not set
+# CONFIG_DM_PWM is not set
+# CONFIG_RAM is not set
+
+#
+# Remote Processor drivers
+#
+
+#
+# Reset Controller Support
+#
+
+#
+# Real Time Clock
+#
+# CONFIG_DM_RTC is not set
+
+#
+# Serial drivers
+#
+# CONFIG_DM_SERIAL is not set
+# CONFIG_DEBUG_UART is not set
+# CONFIG_DEBUG_UART_SKIP_INIT is not set
+# CONFIG_ATMEL_USART is not set
+# CONFIG_FSL_LPUART is not set
+# CONFIG_MVEBU_A3700_UART is not set
+# CONFIG_SYS_NS16550 is not set
+
+#
+# Sound support
+#
+# CONFIG_SOUND is not set
+
+#
+# SPI Support
+#
+# CONFIG_DM_SPI is not set
+# CONFIG_FSL_ESPI is not set
+# CONFIG_FSL_QSPI is not set
+# CONFIG_TI_QSPI is not set
+
+#
+# SPMI support
+#
+# CONFIG_SPMI is not set
+
+#
+# System reset device drivers
+#
+# CONFIG_SYSRESET is not set
+# CONFIG_DM_THERMAL is not set
+
+#
+# Timer Support
+#
+# CONFIG_TIMER is not set
+
+#
+# TPM support
+#
+CONFIG_USB=y
+# CONFIG_DM_USB is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_HOST=y
+CONFIG_USB_XHCI_HCD=y
+# CONFIG_USB_XHCI_DWC3 is not set
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_EHCI is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+
+#
+# MUSB Controller Driver
+#
+# CONFIG_USB_MUSB_HOST is not set
+# CONFIG_USB_MUSB_GADGET is not set
+
+#
+# ULPI drivers
+#
+
+#
+# USB peripherals
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_KEYBOARD is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# UFS Support
+#
+# CONFIG_UFS is not set
+
+#
+# Graphics support
+#
+# CONFIG_DM_VIDEO is not set
+
+#
+# TrueType Fonts
+#
+# CONFIG_VIDEO_VESA is not set
+# CONFIG_VIDEO_LCD_ANX9804 is not set
+# CONFIG_VIDEO_LCD_SSD2828 is not set
+# CONFIG_VIDEO_MVEBU is not set
+# CONFIG_DISPLAY is not set
+# CONFIG_VIDEO_BRIDGE is not set
+# CONFIG_LCD is not set
+# CONFIG_PHYS_TO_BUS is not set
+
+#
+# File systems
+#
+
+#
+# Library routines
+#
+# CONFIG_CC_OPTIMIZE_LIBS_FOR_SPEED is not set
+CONFIG_HAVE_PRIVATE_LIBGCC=y
+CONFIG_USE_PRIVATE_LIBGCC=y
+CONFIG_SYS_HZ=1000
+# CONFIG_USE_TINY_PRINTF is not set
+CONFIG_REGEX=y
+CONFIG_LIB_RAND=y
+# CONFIG_CMD_DHRYSTONE is not set
+# CONFIG_RSA is not set
+# CONFIG_TPM is not set
+
+#
+# Hashing Support
+#
+# CONFIG_SHA1 is not set
+# CONFIG_SHA256 is not set
+# CONFIG_SHA_HW_ACCEL is not set
+
+#
+# Compression Support
+#
+# CONFIG_LZ4 is not set
+# CONFIG_ERRNO_STR is not set
+# CONFIG_OF_LIBFDT is not set
+# CONFIG_OF_LIBFDT_OVERLAY is not set
+# CONFIG_SPL_OF_LIBFDT is not set
+
+#
+# System tables
+#
+CONFIG_HWDEC=y
+# CONFIG_OPTEE is not set
+CONFIG_OPTEE_LOAD_ADDR=0x00000000
+# CONFIG_BOOTM_OPTEE is not set
+# CONFIG_UNIT_TEST is not set
diff -uraN u-boot-2016.11/configs/gk7205v200_mini_defconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/configs/gk7205v200_mini_defconfig
--- u-boot-2016.11/configs/gk7205v200_mini_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/configs/gk7205v200_mini_defconfig	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,608 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# U-Boot 2016.11 Configuration
+#
+CONFIG_CREATE_ARCH_SYMLINK=y
+# CONFIG_ARC is not set
+CONFIG_ARM=y
+# CONFIG_AVR32 is not set
+# CONFIG_BLACKFIN is not set
+# CONFIG_M68K is not set
+# CONFIG_MICROBLAZE is not set
+# CONFIG_MIPS is not set
+# CONFIG_NDS32 is not set
+# CONFIG_NIOS2 is not set
+# CONFIG_OPENRISC is not set
+# CONFIG_PPC is not set
+# CONFIG_SANDBOX is not set
+# CONFIG_SH is not set
+# CONFIG_SPARC is not set
+# CONFIG_X86 is not set
+# CONFIG_XTENSA is not set
+CONFIG_SYS_ARCH="arm"
+CONFIG_SYS_CPU="armv7"
+CONFIG_SYS_SOC="gk7205v200"
+CONFIG_SYS_VENDOR="goke"
+CONFIG_SYS_BOARD="gk7205v200"
+CONFIG_SYS_CONFIG_NAME="gk7205v200"
+
+#
+# ARM architecture
+#
+CONFIG_MINI_BOOT=y
+CONFIG_HAS_VBAR=y
+CONFIG_CPU_V7=y
+CONFIG_SYS_ARM_ARCH=7
+CONFIG_SYS_CACHE_SHIFT_6=y
+CONFIG_SYS_CACHELINE_SIZE=64
+# CONFIG_SEMIHOSTING is not set
+# CONFIG_SYS_L2CACHE_OFF is not set
+# CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_TARGET_EDB93XX is not set
+# CONFIG_TARGET_VCMA9 is not set
+# CONFIG_TARGET_SMDK2410 is not set
+# CONFIG_TARGET_ASPENITE is not set
+# CONFIG_TARGET_GPLUGD is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_KIRKWOOD is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_TARGET_DEVKIT3250 is not set
+# CONFIG_TARGET_WORK_92105 is not set
+# CONFIG_TARGET_MX25PDK is not set
+# CONFIG_TARGET_ZMX25 is not set
+# CONFIG_TARGET_APF27 is not set
+# CONFIG_TARGET_APX4DEVKIT is not set
+# CONFIG_TARGET_XFI3 is not set
+# CONFIG_TARGET_M28EVK is not set
+# CONFIG_TARGET_MX23EVK is not set
+# CONFIG_TARGET_MX28EVK is not set
+# CONFIG_TARGET_MX23_OLINUXINO is not set
+# CONFIG_TARGET_BG0900 is not set
+# CONFIG_TARGET_SANSA_FUZE_PLUS is not set
+# CONFIG_TARGET_SC_SPS_1 is not set
+# CONFIG_ORION5X is not set
+# CONFIG_TARGET_SPEAR300 is not set
+# CONFIG_TARGET_SPEAR310 is not set
+# CONFIG_TARGET_SPEAR320 is not set
+# CONFIG_TARGET_SPEAR600 is not set
+# CONFIG_TARGET_STV0991 is not set
+# CONFIG_TARGET_X600 is not set
+# CONFIG_TARGET_IMX31_PHYCORE is not set
+# CONFIG_TARGET_MX31ADS is not set
+# CONFIG_TARGET_MX31PDK is not set
+# CONFIG_TARGET_WOODBURN is not set
+# CONFIG_TARGET_WOODBURN_SD is not set
+# CONFIG_TARGET_FLEA3 is not set
+# CONFIG_TARGET_MX35PDK is not set
+# CONFIG_ARCH_BCM283X is not set
+# CONFIG_TARGET_VEXPRESS_CA15_TC2 is not set
+# CONFIG_TARGET_VEXPRESS_CA5X2 is not set
+# CONFIG_TARGET_VEXPRESS_CA9X4 is not set
+# CONFIG_TARGET_BRXRE1 is not set
+# CONFIG_TARGET_BRPPT1 is not set
+# CONFIG_TARGET_DRACO is not set
+# CONFIG_TARGET_THUBAN is not set
+# CONFIG_TARGET_RASTABAN is not set
+# CONFIG_TARGET_ETAMIN is not set
+# CONFIG_TARGET_PXM2 is not set
+# CONFIG_TARGET_RUT is not set
+# CONFIG_TARGET_TI814X_EVM is not set
+# CONFIG_TARGET_TI816X_EVM is not set
+# CONFIG_TARGET_BCM23550_W1D is not set
+# CONFIG_TARGET_BCM28155_AP is not set
+# CONFIG_TARGET_BCMCYGNUS is not set
+# CONFIG_TARGET_BCMNSP is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MX7 is not set
+# CONFIG_ARCH_MX6 is not set
+# CONFIG_ARCH_MX5 is not set
+# CONFIG_TARGET_M53EVK is not set
+# CONFIG_TARGET_MX51EVK is not set
+# CONFIG_TARGET_MX53ARD is not set
+# CONFIG_TARGET_MX53EVK is not set
+# CONFIG_TARGET_MX53LOCO is not set
+# CONFIG_TARGET_MX53SMD is not set
+# CONFIG_OMAP34XX is not set
+# CONFIG_OMAP44XX is not set
+# CONFIG_OMAP54XX is not set
+# CONFIG_AM43XX is not set
+# CONFIG_AM33XX is not set
+# CONFIG_ARCH_RMOBILE is not set
+# CONFIG_TARGET_S32V234EVB is not set
+# CONFIG_ARCH_SNAPDRAGON is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_TARGET_CM_T43 is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_TARGET_TS4800 is not set
+# CONFIG_TARGET_VF610TWR is not set
+# CONFIG_TARGET_COLIBRI_VF is not set
+# CONFIG_TARGET_PCM052 is not set
+# CONFIG_TARGET_BK4R1 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_ARCH_ZYNQMP is not set
+# CONFIG_TEGRA is not set
+# CONFIG_TARGET_VEXPRESS64_AEMV8A is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP_DRAM is not set
+# CONFIG_TARGET_VEXPRESS64_JUNO is not set
+# CONFIG_TARGET_LS2080A_EMU is not set
+# CONFIG_TARGET_LS2080A_SIMU is not set
+# CONFIG_TARGET_LS2080AQDS is not set
+# CONFIG_TARGET_LS2080ARDB is not set
+# CONFIG_TARGET_HIKEY is not set
+CONFIG_TARGET_GK7205V200=y
+# CONFIG_TARGET_GK7202V300 is not set
+# CONFIG_TARGET_GK7605V100 is not set
+# CONFIG_TARGET_GK7205V300 is not set
+# CONFIG_TARGET_LS1012AQDS is not set
+# CONFIG_TARGET_LS1012ARDB is not set
+# CONFIG_TARGET_LS1012AFRDM is not set
+# CONFIG_TARGET_LS1021AQDS is not set
+# CONFIG_TARGET_LS1021ATWR is not set
+# CONFIG_TARGET_LS1043AQDS is not set
+# CONFIG_TARGET_LS1043ARDB is not set
+# CONFIG_TARGET_LS1046AQDS is not set
+# CONFIG_TARGET_LS1046ARDB is not set
+# CONFIG_TARGET_H2200 is not set
+# CONFIG_TARGET_ZIPITZ2 is not set
+# CONFIG_TARGET_COLIBRI_PXA270 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_STM32 is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_TARGET_THUNDERX_88XX is not set
+# CONFIG_ARMV7_LPAE is not set
+CONFIG_IDENT_STRING="gk7205v200"
+# CONFIG_PRE_CONSOLE_BUFFER is not set
+# CONFIG_MMC is not set
+# CONFIG_VIDEO is not set
+
+#
+# ARM debug
+#
+# CONFIG_DEBUG_LL is not set
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_DISTRO_DEFAULTS is not set
+# CONFIG_SYS_MALLOC_F is not set
+# CONFIG_EXPERT is not set
+# CONFIG_PHYS_64BIT is not set
+
+#
+# Boot images
+#
+# CONFIG_FIT is not set
+CONFIG_SYS_EXTRA_OPTIONS=""
+# CONFIG_ARCH_FIXUP_FDT is not set
+
+#
+# Boot timing
+#
+# CONFIG_BOOTSTAGE is not set
+CONFIG_BOOTSTAGE_USER_COUNT=20
+CONFIG_BOOTSTAGE_STASH_ADDR=0
+CONFIG_BOOTSTAGE_STASH_SIZE=4096
+
+#
+# Boot media
+#
+# CONFIG_NAND_BOOT is not set
+# CONFIG_ONENAND_BOOT is not set
+# CONFIG_QSPI_BOOT is not set
+# CONFIG_SATA_BOOT is not set
+# CONFIG_SD_BOOT is not set
+# CONFIG_SPI_BOOT is not set
+
+#
+# Console
+#
+# CONFIG_CONSOLE_RECORD is not set
+# CONFIG_SILENT_CONSOLE is not set
+# CONFIG_CONSOLE_MUX is not set
+# CONFIG_SYS_CONSOLE_IS_IN_ENV is not set
+# CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE is not set
+# CONFIG_SYS_CONSOLE_ENV_OVERWRITE is not set
+# CONFIG_SYS_CONSOLE_INFO_QUIET is not set
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_DEFAULT_FDT_FILE=""
+CONFIG_KERNEL_LOAD_ADDR=0x42080000
+# CONFIG_SYS_NO_FLASH is not set
+# CONFIG_VERSION_VARIABLE is not set
+# CONFIG_DISPLAY_CPUINFO is not set
+# CONFIG_DISPLAY_BOARDINFO is not set
+# CONFIG_CMD_CREAD is not set
+
+#
+# SPL / TPL
+#
+
+#
+# Command line interface
+#
+CONFIG_CMDLINE=y
+# CONFIG_HUSH_PARSER is not set
+CONFIG_SYS_PROMPT="goke # "
+
+#
+# Autoboot options
+#
+# CONFIG_AUTOBOOT is not set
+# CONFIG_AUTOBOOT_KEYED is not set
+
+#
+# FASTBOOT
+#
+# CONFIG_FASTBOOT is not set
+
+#
+# Commands
+#
+
+#
+# Info commands
+#
+# CONFIG_CMD_BDI is not set
+# CONFIG_CMD_CONSOLE is not set
+# CONFIG_CMD_CPU is not set
+# CONFIG_CMD_LICENSE is not set
+
+#
+# Boot commands
+#
+# CONFIG_CMD_BOOTD is not set
+# CONFIG_CMD_BOOTM is not set
+# CONFIG_CMD_BOOTZ is not set
+# CONFIG_CMD_ELF is not set
+# CONFIG_CMD_GO is not set
+# CONFIG_CMD_RUN is not set
+# CONFIG_CMD_IMI is not set
+# CONFIG_CMD_IMLS is not set
+# CONFIG_CMD_XIMG is not set
+
+#
+# Environment commands
+#
+# CONFIG_CMD_ASKENV is not set
+# CONFIG_CMD_EXPORTENV is not set
+# CONFIG_CMD_IMPORTENV is not set
+# CONFIG_CMD_EDITENV is not set
+# CONFIG_CMD_GREPENV is not set
+# CONFIG_CMD_SAVEENV is not set
+# CONFIG_CMD_ENV_EXISTS is not set
+
+#
+# Memory commands
+#
+# CONFIG_CMD_MEMORY is not set
+# CONFIG_CMD_CRC32 is not set
+# CONFIG_LOOPW is not set
+# CONFIG_CMD_MEMTEST is not set
+# CONFIG_CMD_MX_CYCLIC is not set
+# CONFIG_CMD_MEMINFO is not set
+
+#
+# Device access commands
+#
+# CONFIG_CMD_LOADB is not set
+# CONFIG_CMD_LOADS is not set
+# CONFIG_CMD_FLASH is not set
+# CONFIG_CMD_ARMFLASH is not set
+# CONFIG_CMD_MMC is not set
+# CONFIG_CMD_NAND is not set
+# CONFIG_CMD_SF is not set
+# CONFIG_CMD_SPI is not set
+# CONFIG_CMD_I2C is not set
+# CONFIG_CMD_USB is not set
+# CONFIG_CMD_DFU is not set
+# CONFIG_CMD_USB_MASS_STORAGE is not set
+# CONFIG_CMD_FPGA is not set
+# CONFIG_CMD_GPIO is not set
+
+#
+# Shell scripting commands
+#
+# CONFIG_CMD_ECHO is not set
+# CONFIG_CMD_ITEST is not set
+# CONFIG_CMD_SOURCE is not set
+# CONFIG_CMD_SETEXPR is not set
+
+#
+# Network commands
+#
+# CONFIG_CMD_NET is not set
+# CONFIG_CMD_TFTPPUT is not set
+# CONFIG_CMD_TFTPSRV is not set
+# CONFIG_CMD_RARP is not set
+# CONFIG_CMD_DHCP is not set
+# CONFIG_CMD_NFS is not set
+# CONFIG_CMD_MII is not set
+# CONFIG_CMD_PING is not set
+# CONFIG_CMD_CDP is not set
+# CONFIG_CMD_SNTP is not set
+# CONFIG_CMD_DNS is not set
+# CONFIG_CMD_LINK_LOCAL is not set
+
+#
+# Misc commands
+#
+# CONFIG_CMD_CACHE is not set
+# CONFIG_CMD_TIME is not set
+# CONFIG_CMD_MISC is not set
+# CONFIG_CMD_TIMER is not set
+# CONFIG_CMD_QFW is not set
+
+#
+# Power commands
+#
+
+#
+# Security commands
+#
+
+#
+# Firmware commands
+#
+
+#
+# Filesystem commands
+#
+# CONFIG_CMD_EXT2 is not set
+# CONFIG_CMD_EXT4 is not set
+# CONFIG_CMD_FAT is not set
+# CONFIG_CMD_FS_GENERIC is not set
+# CONFIG_CMD_UBI is not set
+CONFIG_SUPPORT_OF_CONTROL=y
+
+#
+# Device Tree Control
+#
+# CONFIG_OF_CONTROL is not set
+# CONFIG_NET is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_DM is not set
+# CONFIG_ADC is not set
+# CONFIG_ADC_EXYNOS is not set
+# CONFIG_ADC_SANDBOX is not set
+# CONFIG_BLOCK_CACHE is not set
+
+#
+# Clock
+#
+# CONFIG_CPU is not set
+
+#
+# Hardware crypto devices
+#
+# CONFIG_FSL_CAAM is not set
+
+#
+# Demo for driver model
+#
+
+#
+# DFU support
+#
+
+#
+# DMA Support
+#
+# CONFIG_TI_EDMA3 is not set
+
+#
+# FPGA support
+#
+# CONFIG_FPGA_XILINX is not set
+
+#
+# GPIO Support
+#
+
+#
+# I2C support
+#
+# CONFIG_SYS_I2C_DW is not set
+# CONFIG_CROS_EC_KEYB is not set
+
+#
+# LED Support
+#
+
+#
+# Mailbox Controller Support
+#
+
+#
+# Memory Controller drivers
+#
+
+#
+# Multifunction device drivers
+#
+# CONFIG_CROS_EC is not set
+# CONFIG_FSL_SEC_MON is not set
+# CONFIG_MXC_OCOTP is not set
+# CONFIG_NUVOTON_NCT6102D is not set
+# CONFIG_PCA9551_LED is not set
+# CONFIG_WINBOND_W83627 is not set
+
+#
+# MMC Host controller Support
+#
+
+#
+# MTD Support
+#
+CONFIG_FMC=y
+
+#
+# NAND Device Support
+#
+# CONFIG_NAND_DENALI is not set
+# CONFIG_NAND_VF610_NFC is not set
+# CONFIG_NAND_PXA3XX is not set
+# CONFIG_NAND_ARASAN is not set
+# CONFIG_FMC_SPI_NAND is not set
+# CONFIG_FMC_NAND is not set
+
+#
+# Generic NAND options
+#
+
+#
+# SPI Flash Support
+#
+# CONFIG_SPI_FLASH is not set
+CONFIG_FMC_SPI_NOR=y
+# CONFIG_SPI_BLOCK_PROTECT is not set
+# CONFIG_DTR_MODE_SUPPORT is not set
+
+#
+# UBI support
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_PCI is not set
+# CONFIG_MVEBU_COMPHY_SUPPORT is not set
+# CONFIG_PHY_VENDOR_USB is not set
+
+#
+# Pin controllers
+#
+
+#
+# Power
+#
+
+#
+# Power Domain Support
+#
+
+#
+# Remote Processor drivers
+#
+
+#
+# Reset Controller Support
+#
+
+#
+# Real Time Clock
+#
+
+#
+# Serial drivers
+#
+# CONFIG_DEBUG_UART is not set
+# CONFIG_DEBUG_UART_SKIP_INIT is not set
+# CONFIG_ATMEL_USART is not set
+# CONFIG_FSL_LPUART is not set
+# CONFIG_MVEBU_A3700_UART is not set
+# CONFIG_SYS_NS16550 is not set
+
+#
+# Sound support
+#
+# CONFIG_SOUND is not set
+
+#
+# SPI Support
+#
+# CONFIG_FSL_ESPI is not set
+# CONFIG_FSL_QSPI is not set
+# CONFIG_TI_QSPI is not set
+
+#
+# SPMI support
+#
+
+#
+# System reset device drivers
+#
+# CONFIG_DM_THERMAL is not set
+
+#
+# Timer Support
+#
+
+#
+# TPM support
+#
+# CONFIG_USB is not set
+
+#
+# UFS Support
+#
+# CONFIG_UFS is not set
+
+#
+# Graphics support
+#
+
+#
+# TrueType Fonts
+#
+# CONFIG_VIDEO_VESA is not set
+# CONFIG_VIDEO_LCD_ANX9804 is not set
+# CONFIG_VIDEO_LCD_SSD2828 is not set
+# CONFIG_VIDEO_MVEBU is not set
+# CONFIG_LCD is not set
+# CONFIG_PHYS_TO_BUS is not set
+
+#
+# File systems
+#
+
+#
+# Library routines
+#
+# CONFIG_CC_OPTIMIZE_LIBS_FOR_SPEED is not set
+CONFIG_HAVE_PRIVATE_LIBGCC=y
+# CONFIG_USE_PRIVATE_LIBGCC is not set
+CONFIG_SYS_HZ=1000
+# CONFIG_USE_TINY_PRINTF is not set
+# CONFIG_REGEX is not set
+# CONFIG_LIB_RAND is not set
+# CONFIG_CMD_DHRYSTONE is not set
+# CONFIG_RSA is not set
+
+#
+# Hashing Support
+#
+# CONFIG_SHA1 is not set
+# CONFIG_SHA256 is not set
+# CONFIG_SHA_HW_ACCEL is not set
+
+#
+# Compression Support
+#
+# CONFIG_LZ4 is not set
+# CONFIG_ERRNO_STR is not set
+# CONFIG_OF_LIBFDT is not set
+# CONFIG_OF_LIBFDT_OVERLAY is not set
+# CONFIG_SPL_OF_LIBFDT is not set
+
+#
+# System tables
+#
+CONFIG_HWDEC=y
+# CONFIG_OPTEE is not set
+CONFIG_OPTEE_LOAD_ADDR=0x00000000
+# CONFIG_BOOTM_OPTEE is not set
+# CONFIG_UNIT_TEST is not set
diff -uraN u-boot-2016.11/configs/gk7205v300_defconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/configs/gk7205v300_defconfig
--- u-boot-2016.11/configs/gk7205v300_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/configs/gk7205v300_defconfig	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,720 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# U-Boot 2016.11 Configuration
+#
+CONFIG_CREATE_ARCH_SYMLINK=y
+# CONFIG_ARC is not set
+CONFIG_ARM=y
+# CONFIG_AVR32 is not set
+# CONFIG_BLACKFIN is not set
+# CONFIG_M68K is not set
+# CONFIG_MICROBLAZE is not set
+# CONFIG_MIPS is not set
+# CONFIG_NDS32 is not set
+# CONFIG_NIOS2 is not set
+# CONFIG_OPENRISC is not set
+# CONFIG_PPC is not set
+# CONFIG_SANDBOX is not set
+# CONFIG_SH is not set
+# CONFIG_SPARC is not set
+# CONFIG_X86 is not set
+# CONFIG_XTENSA is not set
+CONFIG_SYS_ARCH="arm"
+CONFIG_SYS_CPU="armv7"
+CONFIG_SYS_SOC="gk7205v300"
+CONFIG_SYS_VENDOR="goke"
+CONFIG_SYS_BOARD="gk7205v300"
+CONFIG_SYS_CONFIG_NAME="gk7205v300"
+
+#
+# ARM architecture
+#
+# CONFIG_MINI_BOOT is not set
+CONFIG_HAS_VBAR=y
+CONFIG_HAS_THUMB2=y
+CONFIG_CPU_V7=y
+CONFIG_SYS_ARM_ARCH=7
+CONFIG_SYS_CACHE_SHIFT_6=y
+CONFIG_SYS_CACHELINE_SIZE=64
+# CONFIG_SEMIHOSTING is not set
+# CONFIG_SYS_L2CACHE_OFF is not set
+CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK=y
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_TARGET_EDB93XX is not set
+# CONFIG_TARGET_VCMA9 is not set
+# CONFIG_TARGET_SMDK2410 is not set
+# CONFIG_TARGET_ASPENITE is not set
+# CONFIG_TARGET_GPLUGD is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_KIRKWOOD is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_TARGET_DEVKIT3250 is not set
+# CONFIG_TARGET_WORK_92105 is not set
+# CONFIG_TARGET_MX25PDK is not set
+# CONFIG_TARGET_ZMX25 is not set
+# CONFIG_TARGET_APF27 is not set
+# CONFIG_TARGET_APX4DEVKIT is not set
+# CONFIG_TARGET_XFI3 is not set
+# CONFIG_TARGET_M28EVK is not set
+# CONFIG_TARGET_MX23EVK is not set
+# CONFIG_TARGET_MX28EVK is not set
+# CONFIG_TARGET_MX23_OLINUXINO is not set
+# CONFIG_TARGET_BG0900 is not set
+# CONFIG_TARGET_SANSA_FUZE_PLUS is not set
+# CONFIG_TARGET_SC_SPS_1 is not set
+# CONFIG_ORION5X is not set
+# CONFIG_TARGET_SPEAR300 is not set
+# CONFIG_TARGET_SPEAR310 is not set
+# CONFIG_TARGET_SPEAR320 is not set
+# CONFIG_TARGET_SPEAR600 is not set
+# CONFIG_TARGET_STV0991 is not set
+# CONFIG_TARGET_X600 is not set
+# CONFIG_TARGET_IMX31_PHYCORE is not set
+# CONFIG_TARGET_MX31ADS is not set
+# CONFIG_TARGET_MX31PDK is not set
+# CONFIG_TARGET_WOODBURN is not set
+# CONFIG_TARGET_WOODBURN_SD is not set
+# CONFIG_TARGET_FLEA3 is not set
+# CONFIG_TARGET_MX35PDK is not set
+# CONFIG_ARCH_BCM283X is not set
+# CONFIG_TARGET_VEXPRESS_CA15_TC2 is not set
+# CONFIG_TARGET_VEXPRESS_CA5X2 is not set
+# CONFIG_TARGET_VEXPRESS_CA9X4 is not set
+# CONFIG_TARGET_BRXRE1 is not set
+# CONFIG_TARGET_BRPPT1 is not set
+# CONFIG_TARGET_DRACO is not set
+# CONFIG_TARGET_THUBAN is not set
+# CONFIG_TARGET_RASTABAN is not set
+# CONFIG_TARGET_ETAMIN is not set
+# CONFIG_TARGET_PXM2 is not set
+# CONFIG_TARGET_RUT is not set
+# CONFIG_TARGET_TI814X_EVM is not set
+# CONFIG_TARGET_TI816X_EVM is not set
+# CONFIG_TARGET_BCM23550_W1D is not set
+# CONFIG_TARGET_BCM28155_AP is not set
+# CONFIG_TARGET_BCMCYGNUS is not set
+# CONFIG_TARGET_BCMNSP is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MX7 is not set
+# CONFIG_ARCH_MX6 is not set
+# CONFIG_ARCH_MX5 is not set
+# CONFIG_TARGET_M53EVK is not set
+# CONFIG_TARGET_MX51EVK is not set
+# CONFIG_TARGET_MX53ARD is not set
+# CONFIG_TARGET_MX53EVK is not set
+# CONFIG_TARGET_MX53LOCO is not set
+# CONFIG_TARGET_MX53SMD is not set
+# CONFIG_OMAP34XX is not set
+# CONFIG_OMAP44XX is not set
+# CONFIG_OMAP54XX is not set
+# CONFIG_AM43XX is not set
+# CONFIG_AM33XX is not set
+# CONFIG_ARCH_RMOBILE is not set
+# CONFIG_TARGET_S32V234EVB is not set
+# CONFIG_ARCH_SNAPDRAGON is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_TARGET_CM_T43 is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_TARGET_TS4800 is not set
+# CONFIG_TARGET_VF610TWR is not set
+# CONFIG_TARGET_COLIBRI_VF is not set
+# CONFIG_TARGET_PCM052 is not set
+# CONFIG_TARGET_BK4R1 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_ARCH_ZYNQMP is not set
+# CONFIG_TEGRA is not set
+# CONFIG_TARGET_VEXPRESS64_AEMV8A is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP_DRAM is not set
+# CONFIG_TARGET_VEXPRESS64_JUNO is not set
+# CONFIG_TARGET_LS2080A_EMU is not set
+# CONFIG_TARGET_LS2080A_SIMU is not set
+# CONFIG_TARGET_LS2080AQDS is not set
+# CONFIG_TARGET_LS2080ARDB is not set
+# CONFIG_TARGET_HIKEY is not set
+# CONFIG_TARGET_GK7205V200 is not set
+# CONFIG_TARGET_GK7202V300 is not set
+# CONFIG_TARGET_GK7605V100 is not set
+CONFIG_TARGET_GK7205V300=y
+# CONFIG_TARGET_LS1012AQDS is not set
+# CONFIG_TARGET_LS1012ARDB is not set
+# CONFIG_TARGET_LS1012AFRDM is not set
+# CONFIG_TARGET_LS1021AQDS is not set
+# CONFIG_TARGET_LS1021ATWR is not set
+# CONFIG_TARGET_LS1043AQDS is not set
+# CONFIG_TARGET_LS1043ARDB is not set
+# CONFIG_TARGET_LS1046AQDS is not set
+# CONFIG_TARGET_LS1046ARDB is not set
+# CONFIG_TARGET_H2200 is not set
+# CONFIG_TARGET_ZIPITZ2 is not set
+# CONFIG_TARGET_COLIBRI_PXA270 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_STM32 is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_TARGET_THUNDERX_88XX is not set
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_CPU_V7_HAS_NONSEC=y
+CONFIG_ARMV7_NONSEC=y
+CONFIG_ARMV7_BOOT_SEC_DEFAULT=y
+CONFIG_ARMV7_PSCI_NR_CPUS=4
+# CONFIG_ARMV7_LPAE is not set
+CONFIG_IDENT_STRING="gk7205v300"
+# CONFIG_PRE_CONSOLE_BUFFER is not set
+CONFIG_MMC=y
+# CONFIG_VIDEO is not set
+
+#
+# ARM debug
+#
+# CONFIG_DEBUG_LL is not set
+# CONFIG_AHCI is not set
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_DISTRO_DEFAULTS is not set
+CONFIG_SYS_MALLOC_F=y
+CONFIG_EXPERT=y
+CONFIG_SYS_MALLOC_CLEAR_ON_INIT=y
+# CONFIG_TOOLS_DEBUG is not set
+# CONFIG_PHYS_64BIT is not set
+
+#
+# Boot images
+#
+CONFIG_FIT=y
+# CONFIG_FIT_VERBOSE is not set
+# CONFIG_FIT_SIGNATURE is not set
+# CONFIG_FIT_BEST_MATCH is not set
+CONFIG_SYS_EXTRA_OPTIONS=""
+# CONFIG_SPL_LOAD_FIT is not set
+# CONFIG_SPL_DFU_SUPPORT is not set
+CONFIG_ARCH_FIXUP_FDT=y
+
+#
+# Boot timing
+#
+# CONFIG_BOOTSTAGE is not set
+CONFIG_BOOTSTAGE_USER_COUNT=20
+CONFIG_BOOTSTAGE_STASH_ADDR=0
+CONFIG_BOOTSTAGE_STASH_SIZE=4096
+
+#
+# Boot media
+#
+# CONFIG_NAND_BOOT is not set
+# CONFIG_ONENAND_BOOT is not set
+# CONFIG_QSPI_BOOT is not set
+# CONFIG_SATA_BOOT is not set
+# CONFIG_SD_BOOT is not set
+# CONFIG_SPI_BOOT is not set
+CONFIG_BOOTDELAY=2
+
+#
+# goke_setup
+#
+# CONFIG_GK_MC is not set
+# CONFIG_GK_SPIFLASH_SPEED is not set
+# CONFIG_GK_UPGRADE_BY_SEGMENT is not set
+# CONFIG_GK_DISABLE_CONSOLE is not set
+# CONFIG_GK_DISABLE_DOWNLOAD is not set
+
+#
+# Console
+#
+# CONFIG_CONSOLE_RECORD is not set
+# CONFIG_SILENT_CONSOLE is not set
+# CONFIG_CONSOLE_MUX is not set
+# CONFIG_SYS_CONSOLE_IS_IN_ENV is not set
+# CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE is not set
+# CONFIG_SYS_CONSOLE_ENV_OVERWRITE is not set
+# CONFIG_SYS_CONSOLE_INFO_QUIET is not set
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_DEFAULT_FDT_FILE=""
+CONFIG_KERNEL_LOAD_ADDR=0x42080000
+# CONFIG_SYS_NO_FLASH is not set
+# CONFIG_VERSION_VARIABLE is not set
+# CONFIG_DISPLAY_CPUINFO is not set
+# CONFIG_DISPLAY_BOARDINFO is not set
+# CONFIG_CMD_CREAD is not set
+
+#
+# SPL / TPL
+#
+
+#
+# Command line interface
+#
+CONFIG_CMDLINE=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="goke # "
+
+#
+# Autoboot options
+#
+CONFIG_AUTOBOOT=y
+# CONFIG_AUTOBOOT_KEYED is not set
+
+#
+# FASTBOOT
+#
+# CONFIG_FASTBOOT is not set
+
+#
+# Commands
+#
+
+#
+# Info commands
+#
+CONFIG_CMD_BDI=y
+CONFIG_CMD_CONSOLE=y
+# CONFIG_CMD_CPU is not set
+# CONFIG_CMD_LICENSE is not set
+
+#
+# Boot commands
+#
+CONFIG_CMD_BOOTD=y
+CONFIG_CMD_BOOTM=y
+# CONFIG_CMD_BOOTZ is not set
+CONFIG_CMD_ELF=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_RUN=y
+CONFIG_CMD_IMI=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_XIMG=y
+
+#
+# Environment commands
+#
+# CONFIG_CMD_ASKENV is not set
+CONFIG_CMD_EXPORTENV=y
+CONFIG_CMD_IMPORTENV=y
+CONFIG_CMD_EDITENV=y
+# CONFIG_CMD_GREPENV is not set
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_ENV_EXISTS=y
+
+#
+# Memory commands
+#
+CONFIG_CMD_MEMORY=y
+CONFIG_CMD_CRC32=y
+# CONFIG_LOOPW is not set
+# CONFIG_CMD_MEMTEST is not set
+# CONFIG_CMD_MX_CYCLIC is not set
+# CONFIG_CMD_MEMINFO is not set
+
+#
+# Device access commands
+#
+CONFIG_CMD_DM=y
+# CONFIG_CMD_DEMO is not set
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_LOADS=y
+CONFIG_CMD_FLASH=y
+# CONFIG_CMD_ARMFLASH is not set
+# CONFIG_CMD_MMC is not set
+# CONFIG_CMD_NAND is not set
+# CONFIG_CMD_SF is not set
+# CONFIG_CMD_SPI is not set
+# CONFIG_CMD_I2C is not set
+CONFIG_CMD_USB=y
+# CONFIG_CMD_DFU is not set
+# CONFIG_CMD_USB_MASS_STORAGE is not set
+CONFIG_CMD_FPGA=y
+# CONFIG_CMD_GPIO is not set
+
+#
+# Shell scripting commands
+#
+CONFIG_CMD_ECHO=y
+CONFIG_CMD_ITEST=y
+CONFIG_CMD_SOURCE=y
+CONFIG_CMD_SETEXPR=y
+
+#
+# Network commands
+#
+CONFIG_CMD_NET=y
+# CONFIG_CMD_TFTPPUT is not set
+# CONFIG_CMD_TFTPSRV is not set
+# CONFIG_CMD_RARP is not set
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_NFS=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+# CONFIG_CMD_CDP is not set
+# CONFIG_CMD_SNTP is not set
+# CONFIG_CMD_DNS is not set
+# CONFIG_CMD_LINK_LOCAL is not set
+
+#
+# Misc commands
+#
+CONFIG_CMD_CACHE=y
+# CONFIG_CMD_TIME is not set
+CONFIG_CMD_MISC=y
+# CONFIG_CMD_TIMER is not set
+# CONFIG_CMD_QFW is not set
+
+#
+# Power commands
+#
+
+#
+# Security commands
+#
+
+#
+# Firmware commands
+#
+
+#
+# Filesystem commands
+#
+# CONFIG_CMD_EXT2 is not set
+# CONFIG_CMD_EXT4 is not set
+# CONFIG_CMD_FAT is not set
+# CONFIG_CMD_FS_GENERIC is not set
+# CONFIG_CMD_UBI is not set
+CONFIG_SUPPORT_OF_CONTROL=y
+
+#
+# Device Tree Control
+#
+# CONFIG_OF_CONTROL is not set
+CONFIG_NET=y
+CONFIG_NET_RANDOM_ETHADDR=y
+# CONFIG_NETCONSOLE is not set
+CONFIG_NET_TFTP_VARS=y
+CONFIG_BOOTP_PXE_CLIENTARCH=0x15
+CONFIG_BOOTP_VCI_STRING="U-Boot.armv7"
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_DM=y
+CONFIG_DM_WARN=y
+CONFIG_DM_DEVICE_REMOVE=y
+CONFIG_DM_STDIO=y
+CONFIG_DM_SEQ_ALIAS=y
+# CONFIG_SPL_DM_SEQ_ALIAS is not set
+# CONFIG_REGMAP is not set
+# CONFIG_SPL_REGMAP is not set
+# CONFIG_DEVRES is not set
+# CONFIG_ADC is not set
+# CONFIG_ADC_EXYNOS is not set
+# CONFIG_ADC_SANDBOX is not set
+# CONFIG_BLK is not set
+# CONFIG_BLOCK_CACHE is not set
+
+#
+# Clock
+#
+# CONFIG_CLK is not set
+# CONFIG_CPU is not set
+
+#
+# Hardware crypto devices
+#
+# CONFIG_FSL_CAAM is not set
+
+#
+# Demo for driver model
+#
+# CONFIG_DM_DEMO is not set
+
+#
+# DFU support
+#
+
+#
+# DMA Support
+#
+# CONFIG_DMA is not set
+# CONFIG_TI_EDMA3 is not set
+
+#
+# FPGA support
+#
+# CONFIG_FPGA_XILINX is not set
+
+#
+# GPIO Support
+#
+# CONFIG_DM_GPIO is not set
+# CONFIG_INTEL_BROADWELL_GPIO is not set
+# CONFIG_LPC32XX_GPIO is not set
+# CONFIG_VYBRID_GPIO is not set
+
+#
+# I2C support
+#
+# CONFIG_DM_I2C is not set
+# CONFIG_DM_I2C_COMPAT is not set
+# CONFIG_SYS_I2C_DW is not set
+# CONFIG_DM_KEYBOARD is not set
+# CONFIG_CROS_EC_KEYB is not set
+
+#
+# LED Support
+#
+# CONFIG_LED is not set
+
+#
+# Mailbox Controller Support
+#
+
+#
+# Memory Controller drivers
+#
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MISC is not set
+# CONFIG_CROS_EC is not set
+# CONFIG_FSL_SEC_MON is not set
+# CONFIG_MXC_OCOTP is not set
+# CONFIG_NUVOTON_NCT6102D is not set
+# CONFIG_PWRSEQ is not set
+# CONFIG_PCA9551_LED is not set
+# CONFIG_WINBOND_W83627 is not set
+
+#
+# MMC Host controller Support
+#
+# CONFIG_DM_MMC is not set
+
+#
+# MTD Support
+#
+# CONFIG_MTD is not set
+CONFIG_FMC=y
+
+#
+# NAND Device Support
+#
+# CONFIG_NAND_DENALI is not set
+# CONFIG_NAND_VF610_NFC is not set
+# CONFIG_NAND_PXA3XX is not set
+# CONFIG_NAND_ARASAN is not set
+CONFIG_FMC_SPI_NAND=y
+# CONFIG_FMC_NAND is not set
+CONFIG_SPI_NAND_MAX_CHIP_NUM=1
+# CONFIG_FMC100_HARDWARE_PAGESIZE_ECC is not set
+CONFIG_FMC100_AUTO_PAGESIZE_ECC=y
+# CONFIG_FMC100_PAGESIZE_AUTO_ECC_NONE is not set
+
+#
+# Generic NAND options
+#
+
+#
+# SPI Flash Support
+#
+# CONFIG_SPI_FLASH is not set
+CONFIG_FMC_SPI_NOR=y
+# CONFIG_SPI_BLOCK_PROTECT is not set
+# CONFIG_DTR_MODE_SUPPORT is not set
+
+#
+# UBI support
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_DM_ETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NETDEVICES=y
+# CONFIG_E1000 is not set
+# CONFIG_ETH_DESIGNWARE is not set
+# CONFIG_ETHOC is not set
+# CONFIG_RTL8139 is not set
+# CONFIG_RTL8169 is not set
+CONFIG_NET_FEMAC=y
+# CONFIG_NET_GMACV300 is not set
+# CONFIG_PCI is not set
+# CONFIG_MVEBU_COMPHY_SUPPORT is not set
+CONFIG_PHY_VENDOR_USB=y
+
+#
+# Pin controllers
+#
+# CONFIG_PINCTRL is not set
+
+#
+# Power
+#
+
+#
+# Power Domain Support
+#
+# CONFIG_DM_PMIC is not set
+# CONFIG_DM_REGULATOR is not set
+# CONFIG_DM_PWM is not set
+# CONFIG_RAM is not set
+
+#
+# Remote Processor drivers
+#
+
+#
+# Reset Controller Support
+#
+
+#
+# Real Time Clock
+#
+# CONFIG_DM_RTC is not set
+
+#
+# Serial drivers
+#
+# CONFIG_DM_SERIAL is not set
+# CONFIG_DEBUG_UART is not set
+# CONFIG_DEBUG_UART_SKIP_INIT is not set
+# CONFIG_ATMEL_USART is not set
+# CONFIG_FSL_LPUART is not set
+# CONFIG_MVEBU_A3700_UART is not set
+# CONFIG_SYS_NS16550 is not set
+
+#
+# Sound support
+#
+# CONFIG_SOUND is not set
+
+#
+# SPI Support
+#
+# CONFIG_DM_SPI is not set
+# CONFIG_FSL_ESPI is not set
+# CONFIG_FSL_QSPI is not set
+# CONFIG_TI_QSPI is not set
+
+#
+# SPMI support
+#
+# CONFIG_SPMI is not set
+
+#
+# System reset device drivers
+#
+# CONFIG_SYSRESET is not set
+# CONFIG_DM_THERMAL is not set
+
+#
+# Timer Support
+#
+# CONFIG_TIMER is not set
+
+#
+# TPM support
+#
+CONFIG_USB=y
+# CONFIG_DM_USB is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_HOST=y
+CONFIG_USB_XHCI_HCD=y
+# CONFIG_USB_XHCI_DWC3 is not set
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_EHCI is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+
+#
+# MUSB Controller Driver
+#
+# CONFIG_USB_MUSB_HOST is not set
+# CONFIG_USB_MUSB_GADGET is not set
+
+#
+# ULPI drivers
+#
+
+#
+# USB peripherals
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_KEYBOARD is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# UFS Support
+#
+# CONFIG_UFS is not set
+
+#
+# Graphics support
+#
+# CONFIG_DM_VIDEO is not set
+
+#
+# TrueType Fonts
+#
+# CONFIG_VIDEO_VESA is not set
+# CONFIG_VIDEO_LCD_ANX9804 is not set
+# CONFIG_VIDEO_LCD_SSD2828 is not set
+# CONFIG_VIDEO_MVEBU is not set
+# CONFIG_DISPLAY is not set
+# CONFIG_VIDEO_BRIDGE is not set
+# CONFIG_LCD is not set
+# CONFIG_PHYS_TO_BUS is not set
+
+#
+# File systems
+#
+
+#
+# Library routines
+#
+# CONFIG_CC_OPTIMIZE_LIBS_FOR_SPEED is not set
+CONFIG_HAVE_PRIVATE_LIBGCC=y
+CONFIG_USE_PRIVATE_LIBGCC=y
+CONFIG_SYS_HZ=1000
+# CONFIG_USE_TINY_PRINTF is not set
+CONFIG_REGEX=y
+CONFIG_LIB_RAND=y
+# CONFIG_CMD_DHRYSTONE is not set
+# CONFIG_RSA is not set
+# CONFIG_TPM is not set
+
+#
+# Hashing Support
+#
+# CONFIG_SHA1 is not set
+# CONFIG_SHA256 is not set
+# CONFIG_SHA_HW_ACCEL is not set
+
+#
+# Compression Support
+#
+# CONFIG_LZ4 is not set
+# CONFIG_ERRNO_STR is not set
+# CONFIG_OF_LIBFDT is not set
+# CONFIG_OF_LIBFDT_OVERLAY is not set
+# CONFIG_SPL_OF_LIBFDT is not set
+
+#
+# System tables
+#
+CONFIG_HWDEC=y
+# CONFIG_OPTEE is not set
+CONFIG_OPTEE_LOAD_ADDR=0x00000000
+# CONFIG_BOOTM_OPTEE is not set
+# CONFIG_UNIT_TEST is not set
diff -uraN u-boot-2016.11/configs/gk7205v300_emmc_defconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/configs/gk7205v300_emmc_defconfig
--- u-boot-2016.11/configs/gk7205v300_emmc_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/configs/gk7205v300_emmc_defconfig	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,710 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# U-Boot 2016.11 Configuration
+#
+CONFIG_CREATE_ARCH_SYMLINK=y
+# CONFIG_ARC is not set
+CONFIG_ARM=y
+# CONFIG_AVR32 is not set
+# CONFIG_BLACKFIN is not set
+# CONFIG_M68K is not set
+# CONFIG_MICROBLAZE is not set
+# CONFIG_MIPS is not set
+# CONFIG_NDS32 is not set
+# CONFIG_NIOS2 is not set
+# CONFIG_OPENRISC is not set
+# CONFIG_PPC is not set
+# CONFIG_SANDBOX is not set
+# CONFIG_SH is not set
+# CONFIG_SPARC is not set
+# CONFIG_X86 is not set
+# CONFIG_XTENSA is not set
+CONFIG_SYS_ARCH="arm"
+CONFIG_SYS_CPU="armv7"
+CONFIG_SYS_SOC="gk7205v300"
+CONFIG_SYS_VENDOR="goke"
+CONFIG_SYS_BOARD="gk7205v300"
+CONFIG_SYS_CONFIG_NAME="gk7205v300"
+
+#
+# ARM architecture
+#
+# CONFIG_MINI_BOOT is not set
+CONFIG_HAS_VBAR=y
+CONFIG_HAS_THUMB2=y
+CONFIG_CPU_V7=y
+CONFIG_SYS_ARM_ARCH=7
+CONFIG_SYS_CACHE_SHIFT_6=y
+CONFIG_SYS_CACHELINE_SIZE=64
+# CONFIG_SEMIHOSTING is not set
+# CONFIG_SYS_L2CACHE_OFF is not set
+CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK=y
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_TARGET_EDB93XX is not set
+# CONFIG_TARGET_VCMA9 is not set
+# CONFIG_TARGET_SMDK2410 is not set
+# CONFIG_TARGET_ASPENITE is not set
+# CONFIG_TARGET_GPLUGD is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_KIRKWOOD is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_TARGET_DEVKIT3250 is not set
+# CONFIG_TARGET_WORK_92105 is not set
+# CONFIG_TARGET_MX25PDK is not set
+# CONFIG_TARGET_ZMX25 is not set
+# CONFIG_TARGET_APF27 is not set
+# CONFIG_TARGET_APX4DEVKIT is not set
+# CONFIG_TARGET_XFI3 is not set
+# CONFIG_TARGET_M28EVK is not set
+# CONFIG_TARGET_MX23EVK is not set
+# CONFIG_TARGET_MX28EVK is not set
+# CONFIG_TARGET_MX23_OLINUXINO is not set
+# CONFIG_TARGET_BG0900 is not set
+# CONFIG_TARGET_SANSA_FUZE_PLUS is not set
+# CONFIG_TARGET_SC_SPS_1 is not set
+# CONFIG_ORION5X is not set
+# CONFIG_TARGET_SPEAR300 is not set
+# CONFIG_TARGET_SPEAR310 is not set
+# CONFIG_TARGET_SPEAR320 is not set
+# CONFIG_TARGET_SPEAR600 is not set
+# CONFIG_TARGET_STV0991 is not set
+# CONFIG_TARGET_X600 is not set
+# CONFIG_TARGET_IMX31_PHYCORE is not set
+# CONFIG_TARGET_MX31ADS is not set
+# CONFIG_TARGET_MX31PDK is not set
+# CONFIG_TARGET_WOODBURN is not set
+# CONFIG_TARGET_WOODBURN_SD is not set
+# CONFIG_TARGET_FLEA3 is not set
+# CONFIG_TARGET_MX35PDK is not set
+# CONFIG_ARCH_BCM283X is not set
+# CONFIG_TARGET_VEXPRESS_CA15_TC2 is not set
+# CONFIG_TARGET_VEXPRESS_CA5X2 is not set
+# CONFIG_TARGET_VEXPRESS_CA9X4 is not set
+# CONFIG_TARGET_BRXRE1 is not set
+# CONFIG_TARGET_BRPPT1 is not set
+# CONFIG_TARGET_DRACO is not set
+# CONFIG_TARGET_THUBAN is not set
+# CONFIG_TARGET_RASTABAN is not set
+# CONFIG_TARGET_ETAMIN is not set
+# CONFIG_TARGET_PXM2 is not set
+# CONFIG_TARGET_RUT is not set
+# CONFIG_TARGET_TI814X_EVM is not set
+# CONFIG_TARGET_TI816X_EVM is not set
+# CONFIG_TARGET_BCM23550_W1D is not set
+# CONFIG_TARGET_BCM28155_AP is not set
+# CONFIG_TARGET_BCMCYGNUS is not set
+# CONFIG_TARGET_BCMNSP is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MX7 is not set
+# CONFIG_ARCH_MX6 is not set
+# CONFIG_ARCH_MX5 is not set
+# CONFIG_TARGET_M53EVK is not set
+# CONFIG_TARGET_MX51EVK is not set
+# CONFIG_TARGET_MX53ARD is not set
+# CONFIG_TARGET_MX53EVK is not set
+# CONFIG_TARGET_MX53LOCO is not set
+# CONFIG_TARGET_MX53SMD is not set
+# CONFIG_OMAP34XX is not set
+# CONFIG_OMAP44XX is not set
+# CONFIG_OMAP54XX is not set
+# CONFIG_AM43XX is not set
+# CONFIG_AM33XX is not set
+# CONFIG_ARCH_RMOBILE is not set
+# CONFIG_TARGET_S32V234EVB is not set
+# CONFIG_ARCH_SNAPDRAGON is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_TARGET_CM_T43 is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_TARGET_TS4800 is not set
+# CONFIG_TARGET_VF610TWR is not set
+# CONFIG_TARGET_COLIBRI_VF is not set
+# CONFIG_TARGET_PCM052 is not set
+# CONFIG_TARGET_BK4R1 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_ARCH_ZYNQMP is not set
+# CONFIG_TEGRA is not set
+# CONFIG_TARGET_VEXPRESS64_AEMV8A is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP_DRAM is not set
+# CONFIG_TARGET_VEXPRESS64_JUNO is not set
+# CONFIG_TARGET_LS2080A_EMU is not set
+# CONFIG_TARGET_LS2080A_SIMU is not set
+# CONFIG_TARGET_LS2080AQDS is not set
+# CONFIG_TARGET_LS2080ARDB is not set
+# CONFIG_TARGET_HIKEY is not set
+# CONFIG_TARGET_GK7205V200 is not set
+# CONFIG_TARGET_GK7202V300 is not set
+# CONFIG_TARGET_GK7605V100 is not set
+CONFIG_TARGET_GK7205V300=y
+# CONFIG_TARGET_LS1012AQDS is not set
+# CONFIG_TARGET_LS1012ARDB is not set
+# CONFIG_TARGET_LS1012AFRDM is not set
+# CONFIG_TARGET_LS1021AQDS is not set
+# CONFIG_TARGET_LS1021ATWR is not set
+# CONFIG_TARGET_LS1043AQDS is not set
+# CONFIG_TARGET_LS1043ARDB is not set
+# CONFIG_TARGET_LS1046AQDS is not set
+# CONFIG_TARGET_LS1046ARDB is not set
+# CONFIG_TARGET_H2200 is not set
+# CONFIG_TARGET_ZIPITZ2 is not set
+# CONFIG_TARGET_COLIBRI_PXA270 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_STM32 is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_TARGET_THUNDERX_88XX is not set
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_CPU_V7_HAS_NONSEC=y
+CONFIG_ARMV7_NONSEC=y
+CONFIG_ARMV7_BOOT_SEC_DEFAULT=y
+CONFIG_ARMV7_PSCI_NR_CPUS=4
+# CONFIG_ARMV7_LPAE is not set
+CONFIG_IDENT_STRING="gk7205v300"
+# CONFIG_PRE_CONSOLE_BUFFER is not set
+CONFIG_MMC=y
+# CONFIG_VIDEO is not set
+
+#
+# ARM debug
+#
+# CONFIG_DEBUG_LL is not set
+# CONFIG_AHCI is not set
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_DISTRO_DEFAULTS is not set
+CONFIG_SYS_MALLOC_F=y
+CONFIG_EXPERT=y
+CONFIG_SYS_MALLOC_CLEAR_ON_INIT=y
+# CONFIG_TOOLS_DEBUG is not set
+# CONFIG_PHYS_64BIT is not set
+
+#
+# Boot images
+#
+CONFIG_FIT=y
+# CONFIG_FIT_VERBOSE is not set
+# CONFIG_FIT_SIGNATURE is not set
+# CONFIG_FIT_BEST_MATCH is not set
+CONFIG_SYS_EXTRA_OPTIONS=""
+# CONFIG_SPL_LOAD_FIT is not set
+# CONFIG_SPL_DFU_SUPPORT is not set
+CONFIG_ARCH_FIXUP_FDT=y
+
+#
+# Boot timing
+#
+# CONFIG_BOOTSTAGE is not set
+CONFIG_BOOTSTAGE_USER_COUNT=20
+CONFIG_BOOTSTAGE_STASH_ADDR=0
+CONFIG_BOOTSTAGE_STASH_SIZE=4096
+
+#
+# Boot media
+#
+# CONFIG_NAND_BOOT is not set
+# CONFIG_ONENAND_BOOT is not set
+# CONFIG_QSPI_BOOT is not set
+# CONFIG_SATA_BOOT is not set
+# CONFIG_SD_BOOT is not set
+# CONFIG_SPI_BOOT is not set
+CONFIG_BOOTDELAY=2
+
+#
+# goke_setup
+#
+# CONFIG_GK_MC is not set
+# CONFIG_GK_UPGRADE_BY_SEGMENT is not set
+# CONFIG_GK_DISABLE_CONSOLE is not set
+# CONFIG_GK_DISABLE_DOWNLOAD is not set
+
+#
+# Console
+#
+# CONFIG_CONSOLE_RECORD is not set
+# CONFIG_SILENT_CONSOLE is not set
+# CONFIG_CONSOLE_MUX is not set
+# CONFIG_SYS_CONSOLE_IS_IN_ENV is not set
+# CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE is not set
+# CONFIG_SYS_CONSOLE_ENV_OVERWRITE is not set
+# CONFIG_SYS_CONSOLE_INFO_QUIET is not set
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_DEFAULT_FDT_FILE=""
+CONFIG_KERNEL_LOAD_ADDR=0x42080000
+# CONFIG_SYS_NO_FLASH is not set
+# CONFIG_VERSION_VARIABLE is not set
+# CONFIG_DISPLAY_CPUINFO is not set
+# CONFIG_DISPLAY_BOARDINFO is not set
+# CONFIG_CMD_CREAD is not set
+
+#
+# SPL / TPL
+#
+
+#
+# Command line interface
+#
+CONFIG_CMDLINE=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="goke # "
+
+#
+# Autoboot options
+#
+CONFIG_AUTOBOOT=y
+# CONFIG_AUTOBOOT_KEYED is not set
+
+#
+# FASTBOOT
+#
+# CONFIG_FASTBOOT is not set
+
+#
+# Commands
+#
+
+#
+# Info commands
+#
+CONFIG_CMD_BDI=y
+CONFIG_CMD_CONSOLE=y
+# CONFIG_CMD_CPU is not set
+# CONFIG_CMD_LICENSE is not set
+
+#
+# Boot commands
+#
+CONFIG_CMD_BOOTD=y
+CONFIG_CMD_BOOTM=y
+# CONFIG_CMD_BOOTZ is not set
+CONFIG_CMD_ELF=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_RUN=y
+CONFIG_CMD_IMI=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_XIMG=y
+
+#
+# Environment commands
+#
+# CONFIG_CMD_ASKENV is not set
+CONFIG_CMD_EXPORTENV=y
+CONFIG_CMD_IMPORTENV=y
+CONFIG_CMD_EDITENV=y
+# CONFIG_CMD_GREPENV is not set
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_ENV_EXISTS=y
+
+#
+# Memory commands
+#
+CONFIG_CMD_MEMORY=y
+CONFIG_CMD_CRC32=y
+# CONFIG_LOOPW is not set
+# CONFIG_CMD_MEMTEST is not set
+# CONFIG_CMD_MX_CYCLIC is not set
+# CONFIG_CMD_MEMINFO is not set
+
+#
+# Device access commands
+#
+CONFIG_CMD_DM=y
+# CONFIG_CMD_DEMO is not set
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_LOADS=y
+CONFIG_CMD_FLASH=y
+# CONFIG_CMD_ARMFLASH is not set
+# CONFIG_CMD_MMC is not set
+# CONFIG_CMD_NAND is not set
+# CONFIG_CMD_SF is not set
+# CONFIG_CMD_SPI is not set
+# CONFIG_CMD_I2C is not set
+CONFIG_CMD_USB=y
+# CONFIG_CMD_DFU is not set
+# CONFIG_CMD_USB_MASS_STORAGE is not set
+CONFIG_CMD_FPGA=y
+# CONFIG_CMD_GPIO is not set
+
+#
+# Shell scripting commands
+#
+CONFIG_CMD_ECHO=y
+CONFIG_CMD_ITEST=y
+CONFIG_CMD_SOURCE=y
+CONFIG_CMD_SETEXPR=y
+
+#
+# Network commands
+#
+CONFIG_CMD_NET=y
+# CONFIG_CMD_TFTPPUT is not set
+# CONFIG_CMD_TFTPSRV is not set
+# CONFIG_CMD_RARP is not set
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_NFS=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+# CONFIG_CMD_CDP is not set
+# CONFIG_CMD_SNTP is not set
+# CONFIG_CMD_DNS is not set
+# CONFIG_CMD_LINK_LOCAL is not set
+
+#
+# Misc commands
+#
+CONFIG_CMD_CACHE=y
+# CONFIG_CMD_TIME is not set
+CONFIG_CMD_MISC=y
+# CONFIG_CMD_TIMER is not set
+# CONFIG_CMD_QFW is not set
+
+#
+# Power commands
+#
+
+#
+# Security commands
+#
+
+#
+# Firmware commands
+#
+
+#
+# Filesystem commands
+#
+# CONFIG_CMD_EXT2 is not set
+# CONFIG_CMD_EXT4 is not set
+# CONFIG_CMD_FAT is not set
+# CONFIG_CMD_FS_GENERIC is not set
+# CONFIG_CMD_UBI is not set
+CONFIG_SUPPORT_OF_CONTROL=y
+
+#
+# Device Tree Control
+#
+# CONFIG_OF_CONTROL is not set
+CONFIG_NET=y
+CONFIG_NET_RANDOM_ETHADDR=y
+# CONFIG_NETCONSOLE is not set
+CONFIG_NET_TFTP_VARS=y
+CONFIG_BOOTP_PXE_CLIENTARCH=0x15
+CONFIG_BOOTP_VCI_STRING="U-Boot.armv7"
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_DM=y
+CONFIG_DM_WARN=y
+CONFIG_DM_DEVICE_REMOVE=y
+CONFIG_DM_STDIO=y
+CONFIG_DM_SEQ_ALIAS=y
+# CONFIG_SPL_DM_SEQ_ALIAS is not set
+# CONFIG_REGMAP is not set
+# CONFIG_SPL_REGMAP is not set
+# CONFIG_DEVRES is not set
+# CONFIG_ADC is not set
+# CONFIG_ADC_EXYNOS is not set
+# CONFIG_ADC_SANDBOX is not set
+# CONFIG_BLK is not set
+# CONFIG_BLOCK_CACHE is not set
+
+#
+# Clock
+#
+# CONFIG_CLK is not set
+# CONFIG_CPU is not set
+
+#
+# Hardware crypto devices
+#
+# CONFIG_FSL_CAAM is not set
+
+#
+# Demo for driver model
+#
+# CONFIG_DM_DEMO is not set
+
+#
+# DFU support
+#
+
+#
+# DMA Support
+#
+# CONFIG_DMA is not set
+# CONFIG_TI_EDMA3 is not set
+
+#
+# FPGA support
+#
+# CONFIG_FPGA_XILINX is not set
+
+#
+# GPIO Support
+#
+# CONFIG_DM_GPIO is not set
+# CONFIG_INTEL_BROADWELL_GPIO is not set
+# CONFIG_LPC32XX_GPIO is not set
+# CONFIG_VYBRID_GPIO is not set
+
+#
+# I2C support
+#
+# CONFIG_DM_I2C is not set
+# CONFIG_DM_I2C_COMPAT is not set
+# CONFIG_SYS_I2C_DW is not set
+# CONFIG_DM_KEYBOARD is not set
+# CONFIG_CROS_EC_KEYB is not set
+
+#
+# LED Support
+#
+# CONFIG_LED is not set
+
+#
+# Mailbox Controller Support
+#
+
+#
+# Memory Controller drivers
+#
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MISC is not set
+# CONFIG_CROS_EC is not set
+# CONFIG_FSL_SEC_MON is not set
+# CONFIG_MXC_OCOTP is not set
+# CONFIG_NUVOTON_NCT6102D is not set
+# CONFIG_PWRSEQ is not set
+# CONFIG_PCA9551_LED is not set
+# CONFIG_WINBOND_W83627 is not set
+
+#
+# MMC Host controller Support
+#
+# CONFIG_DM_MMC is not set
+
+#
+# MTD Support
+#
+# CONFIG_MTD is not set
+# CONFIG_FMC is not set
+
+#
+# NAND Device Support
+#
+# CONFIG_NAND_DENALI is not set
+# CONFIG_NAND_VF610_NFC is not set
+# CONFIG_NAND_PXA3XX is not set
+# CONFIG_NAND_ARASAN is not set
+
+#
+# Generic NAND options
+#
+
+#
+# SPI Flash Support
+#
+# CONFIG_SPI_FLASH is not set
+
+#
+# UBI support
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_DM_ETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NETDEVICES=y
+# CONFIG_E1000 is not set
+# CONFIG_ETH_DESIGNWARE is not set
+# CONFIG_ETHOC is not set
+# CONFIG_RTL8139 is not set
+# CONFIG_RTL8169 is not set
+CONFIG_NET_FEMAC=y
+# CONFIG_NET_GMACV300 is not set
+# CONFIG_PCI is not set
+# CONFIG_MVEBU_COMPHY_SUPPORT is not set
+CONFIG_PHY_VENDOR_USB=y
+
+#
+# Pin controllers
+#
+# CONFIG_PINCTRL is not set
+
+#
+# Power
+#
+
+#
+# Power Domain Support
+#
+# CONFIG_DM_PMIC is not set
+# CONFIG_DM_REGULATOR is not set
+# CONFIG_DM_PWM is not set
+# CONFIG_RAM is not set
+
+#
+# Remote Processor drivers
+#
+
+#
+# Reset Controller Support
+#
+
+#
+# Real Time Clock
+#
+# CONFIG_DM_RTC is not set
+
+#
+# Serial drivers
+#
+# CONFIG_DM_SERIAL is not set
+# CONFIG_DEBUG_UART is not set
+# CONFIG_DEBUG_UART_SKIP_INIT is not set
+# CONFIG_ATMEL_USART is not set
+# CONFIG_FSL_LPUART is not set
+# CONFIG_MVEBU_A3700_UART is not set
+# CONFIG_SYS_NS16550 is not set
+
+#
+# Sound support
+#
+# CONFIG_SOUND is not set
+
+#
+# SPI Support
+#
+# CONFIG_DM_SPI is not set
+# CONFIG_FSL_ESPI is not set
+# CONFIG_FSL_QSPI is not set
+# CONFIG_TI_QSPI is not set
+
+#
+# SPMI support
+#
+# CONFIG_SPMI is not set
+
+#
+# System reset device drivers
+#
+# CONFIG_SYSRESET is not set
+# CONFIG_DM_THERMAL is not set
+
+#
+# Timer Support
+#
+# CONFIG_TIMER is not set
+
+#
+# TPM support
+#
+CONFIG_USB=y
+# CONFIG_DM_USB is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_HOST=y
+CONFIG_USB_XHCI_HCD=y
+# CONFIG_USB_XHCI_DWC3 is not set
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_EHCI is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+
+#
+# MUSB Controller Driver
+#
+# CONFIG_USB_MUSB_HOST is not set
+# CONFIG_USB_MUSB_GADGET is not set
+
+#
+# ULPI drivers
+#
+
+#
+# USB peripherals
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_KEYBOARD is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# UFS Support
+#
+# CONFIG_UFS is not set
+
+#
+# Graphics support
+#
+# CONFIG_DM_VIDEO is not set
+
+#
+# TrueType Fonts
+#
+# CONFIG_VIDEO_VESA is not set
+# CONFIG_VIDEO_LCD_ANX9804 is not set
+# CONFIG_VIDEO_LCD_SSD2828 is not set
+# CONFIG_VIDEO_MVEBU is not set
+# CONFIG_DISPLAY is not set
+# CONFIG_VIDEO_BRIDGE is not set
+# CONFIG_LCD is not set
+# CONFIG_PHYS_TO_BUS is not set
+
+#
+# File systems
+#
+
+#
+# Library routines
+#
+# CONFIG_CC_OPTIMIZE_LIBS_FOR_SPEED is not set
+CONFIG_HAVE_PRIVATE_LIBGCC=y
+CONFIG_USE_PRIVATE_LIBGCC=y
+CONFIG_SYS_HZ=1000
+# CONFIG_USE_TINY_PRINTF is not set
+CONFIG_REGEX=y
+CONFIG_LIB_RAND=y
+# CONFIG_CMD_DHRYSTONE is not set
+# CONFIG_RSA is not set
+# CONFIG_TPM is not set
+
+#
+# Hashing Support
+#
+# CONFIG_SHA1 is not set
+# CONFIG_SHA256 is not set
+# CONFIG_SHA_HW_ACCEL is not set
+
+#
+# Compression Support
+#
+# CONFIG_LZ4 is not set
+# CONFIG_ERRNO_STR is not set
+# CONFIG_OF_LIBFDT is not set
+# CONFIG_OF_LIBFDT_OVERLAY is not set
+# CONFIG_SPL_OF_LIBFDT is not set
+
+#
+# System tables
+#
+CONFIG_HWDEC=y
+# CONFIG_OPTEE is not set
+CONFIG_OPTEE_LOAD_ADDR=0x00000000
+# CONFIG_BOOTM_OPTEE is not set
+# CONFIG_UNIT_TEST is not set
diff -uraN u-boot-2016.11/configs/gk7605v100_defconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/configs/gk7605v100_defconfig
--- u-boot-2016.11/configs/gk7605v100_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/configs/gk7605v100_defconfig	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,720 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# U-Boot 2016.11 Configuration
+#
+CONFIG_CREATE_ARCH_SYMLINK=y
+# CONFIG_ARC is not set
+CONFIG_ARM=y
+# CONFIG_AVR32 is not set
+# CONFIG_BLACKFIN is not set
+# CONFIG_M68K is not set
+# CONFIG_MICROBLAZE is not set
+# CONFIG_MIPS is not set
+# CONFIG_NDS32 is not set
+# CONFIG_NIOS2 is not set
+# CONFIG_OPENRISC is not set
+# CONFIG_PPC is not set
+# CONFIG_SANDBOX is not set
+# CONFIG_SH is not set
+# CONFIG_SPARC is not set
+# CONFIG_X86 is not set
+# CONFIG_XTENSA is not set
+CONFIG_SYS_ARCH="arm"
+CONFIG_SYS_CPU="armv7"
+CONFIG_SYS_SOC="gk7605v100"
+CONFIG_SYS_VENDOR="goke"
+CONFIG_SYS_BOARD="gk7605v100"
+CONFIG_SYS_CONFIG_NAME="gk7605v100"
+
+#
+# ARM architecture
+#
+# CONFIG_MINI_BOOT is not set
+CONFIG_HAS_VBAR=y
+CONFIG_HAS_THUMB2=y
+CONFIG_CPU_V7=y
+CONFIG_SYS_ARM_ARCH=7
+CONFIG_SYS_CACHE_SHIFT_6=y
+CONFIG_SYS_CACHELINE_SIZE=64
+# CONFIG_SEMIHOSTING is not set
+# CONFIG_SYS_L2CACHE_OFF is not set
+CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK=y
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_TARGET_EDB93XX is not set
+# CONFIG_TARGET_VCMA9 is not set
+# CONFIG_TARGET_SMDK2410 is not set
+# CONFIG_TARGET_ASPENITE is not set
+# CONFIG_TARGET_GPLUGD is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_KIRKWOOD is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_TARGET_DEVKIT3250 is not set
+# CONFIG_TARGET_WORK_92105 is not set
+# CONFIG_TARGET_MX25PDK is not set
+# CONFIG_TARGET_ZMX25 is not set
+# CONFIG_TARGET_APF27 is not set
+# CONFIG_TARGET_APX4DEVKIT is not set
+# CONFIG_TARGET_XFI3 is not set
+# CONFIG_TARGET_M28EVK is not set
+# CONFIG_TARGET_MX23EVK is not set
+# CONFIG_TARGET_MX28EVK is not set
+# CONFIG_TARGET_MX23_OLINUXINO is not set
+# CONFIG_TARGET_BG0900 is not set
+# CONFIG_TARGET_SANSA_FUZE_PLUS is not set
+# CONFIG_TARGET_SC_SPS_1 is not set
+# CONFIG_ORION5X is not set
+# CONFIG_TARGET_SPEAR300 is not set
+# CONFIG_TARGET_SPEAR310 is not set
+# CONFIG_TARGET_SPEAR320 is not set
+# CONFIG_TARGET_SPEAR600 is not set
+# CONFIG_TARGET_STV0991 is not set
+# CONFIG_TARGET_X600 is not set
+# CONFIG_TARGET_IMX31_PHYCORE is not set
+# CONFIG_TARGET_MX31ADS is not set
+# CONFIG_TARGET_MX31PDK is not set
+# CONFIG_TARGET_WOODBURN is not set
+# CONFIG_TARGET_WOODBURN_SD is not set
+# CONFIG_TARGET_FLEA3 is not set
+# CONFIG_TARGET_MX35PDK is not set
+# CONFIG_ARCH_BCM283X is not set
+# CONFIG_TARGET_VEXPRESS_CA15_TC2 is not set
+# CONFIG_TARGET_VEXPRESS_CA5X2 is not set
+# CONFIG_TARGET_VEXPRESS_CA9X4 is not set
+# CONFIG_TARGET_BRXRE1 is not set
+# CONFIG_TARGET_BRPPT1 is not set
+# CONFIG_TARGET_DRACO is not set
+# CONFIG_TARGET_THUBAN is not set
+# CONFIG_TARGET_RASTABAN is not set
+# CONFIG_TARGET_ETAMIN is not set
+# CONFIG_TARGET_PXM2 is not set
+# CONFIG_TARGET_RUT is not set
+# CONFIG_TARGET_TI814X_EVM is not set
+# CONFIG_TARGET_TI816X_EVM is not set
+# CONFIG_TARGET_BCM23550_W1D is not set
+# CONFIG_TARGET_BCM28155_AP is not set
+# CONFIG_TARGET_BCMCYGNUS is not set
+# CONFIG_TARGET_BCMNSP is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MX7 is not set
+# CONFIG_ARCH_MX6 is not set
+# CONFIG_ARCH_MX5 is not set
+# CONFIG_TARGET_M53EVK is not set
+# CONFIG_TARGET_MX51EVK is not set
+# CONFIG_TARGET_MX53ARD is not set
+# CONFIG_TARGET_MX53EVK is not set
+# CONFIG_TARGET_MX53LOCO is not set
+# CONFIG_TARGET_MX53SMD is not set
+# CONFIG_OMAP34XX is not set
+# CONFIG_OMAP44XX is not set
+# CONFIG_OMAP54XX is not set
+# CONFIG_AM43XX is not set
+# CONFIG_AM33XX is not set
+# CONFIG_ARCH_RMOBILE is not set
+# CONFIG_TARGET_S32V234EVB is not set
+# CONFIG_ARCH_SNAPDRAGON is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_TARGET_CM_T43 is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_TARGET_TS4800 is not set
+# CONFIG_TARGET_VF610TWR is not set
+# CONFIG_TARGET_COLIBRI_VF is not set
+# CONFIG_TARGET_PCM052 is not set
+# CONFIG_TARGET_BK4R1 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_ARCH_ZYNQMP is not set
+# CONFIG_TEGRA is not set
+# CONFIG_TARGET_VEXPRESS64_AEMV8A is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP_DRAM is not set
+# CONFIG_TARGET_VEXPRESS64_JUNO is not set
+# CONFIG_TARGET_LS2080A_EMU is not set
+# CONFIG_TARGET_LS2080A_SIMU is not set
+# CONFIG_TARGET_LS2080AQDS is not set
+# CONFIG_TARGET_LS2080ARDB is not set
+# CONFIG_TARGET_HIKEY is not set
+# CONFIG_TARGET_GK7205V200 is not set
+# CONFIG_TARGET_GK7202V300 is not set
+CONFIG_TARGET_GK7605V100=y
+# CONFIG_TARGET_GK7205V300 is not set
+# CONFIG_TARGET_LS1012AQDS is not set
+# CONFIG_TARGET_LS1012ARDB is not set
+# CONFIG_TARGET_LS1012AFRDM is not set
+# CONFIG_TARGET_LS1021AQDS is not set
+# CONFIG_TARGET_LS1021ATWR is not set
+# CONFIG_TARGET_LS1043AQDS is not set
+# CONFIG_TARGET_LS1043ARDB is not set
+# CONFIG_TARGET_LS1046AQDS is not set
+# CONFIG_TARGET_LS1046ARDB is not set
+# CONFIG_TARGET_H2200 is not set
+# CONFIG_TARGET_ZIPITZ2 is not set
+# CONFIG_TARGET_COLIBRI_PXA270 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_STM32 is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_TARGET_THUNDERX_88XX is not set
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_CPU_V7_HAS_NONSEC=y
+CONFIG_ARMV7_NONSEC=y
+CONFIG_ARMV7_BOOT_SEC_DEFAULT=y
+CONFIG_ARMV7_PSCI_NR_CPUS=4
+# CONFIG_ARMV7_LPAE is not set
+CONFIG_IDENT_STRING="gk7605v100"
+# CONFIG_PRE_CONSOLE_BUFFER is not set
+CONFIG_MMC=y
+# CONFIG_VIDEO is not set
+
+#
+# ARM debug
+#
+# CONFIG_DEBUG_LL is not set
+# CONFIG_AHCI is not set
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_DISTRO_DEFAULTS is not set
+CONFIG_SYS_MALLOC_F=y
+CONFIG_EXPERT=y
+CONFIG_SYS_MALLOC_CLEAR_ON_INIT=y
+# CONFIG_TOOLS_DEBUG is not set
+# CONFIG_PHYS_64BIT is not set
+
+#
+# Boot images
+#
+CONFIG_FIT=y
+# CONFIG_FIT_VERBOSE is not set
+# CONFIG_FIT_SIGNATURE is not set
+# CONFIG_FIT_BEST_MATCH is not set
+CONFIG_SYS_EXTRA_OPTIONS=""
+# CONFIG_SPL_LOAD_FIT is not set
+# CONFIG_SPL_DFU_SUPPORT is not set
+CONFIG_ARCH_FIXUP_FDT=y
+
+#
+# Boot timing
+#
+# CONFIG_BOOTSTAGE is not set
+CONFIG_BOOTSTAGE_USER_COUNT=20
+CONFIG_BOOTSTAGE_STASH_ADDR=0
+CONFIG_BOOTSTAGE_STASH_SIZE=4096
+
+#
+# Boot media
+#
+# CONFIG_NAND_BOOT is not set
+# CONFIG_ONENAND_BOOT is not set
+# CONFIG_QSPI_BOOT is not set
+# CONFIG_SATA_BOOT is not set
+# CONFIG_SD_BOOT is not set
+# CONFIG_SPI_BOOT is not set
+CONFIG_BOOTDELAY=2
+
+#
+# goke_setup
+#
+# CONFIG_GK_MC is not set
+# CONFIG_GK_SPIFLASH_SPEED is not set
+# CONFIG_GK_UPGRADE_BY_SEGMENT is not set
+# CONFIG_GK_DISABLE_CONSOLE is not set
+# CONFIG_GK_DISABLE_DOWNLOAD is not set
+
+#
+# Console
+#
+# CONFIG_CONSOLE_RECORD is not set
+# CONFIG_SILENT_CONSOLE is not set
+# CONFIG_CONSOLE_MUX is not set
+# CONFIG_SYS_CONSOLE_IS_IN_ENV is not set
+# CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE is not set
+# CONFIG_SYS_CONSOLE_ENV_OVERWRITE is not set
+# CONFIG_SYS_CONSOLE_INFO_QUIET is not set
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_DEFAULT_FDT_FILE=""
+CONFIG_KERNEL_LOAD_ADDR=0x42080000
+# CONFIG_SYS_NO_FLASH is not set
+# CONFIG_VERSION_VARIABLE is not set
+# CONFIG_DISPLAY_CPUINFO is not set
+# CONFIG_DISPLAY_BOARDINFO is not set
+# CONFIG_CMD_CREAD is not set
+
+#
+# SPL / TPL
+#
+
+#
+# Command line interface
+#
+CONFIG_CMDLINE=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="goke # "
+
+#
+# Autoboot options
+#
+CONFIG_AUTOBOOT=y
+# CONFIG_AUTOBOOT_KEYED is not set
+
+#
+# FASTBOOT
+#
+# CONFIG_FASTBOOT is not set
+
+#
+# Commands
+#
+
+#
+# Info commands
+#
+CONFIG_CMD_BDI=y
+CONFIG_CMD_CONSOLE=y
+# CONFIG_CMD_CPU is not set
+# CONFIG_CMD_LICENSE is not set
+
+#
+# Boot commands
+#
+CONFIG_CMD_BOOTD=y
+CONFIG_CMD_BOOTM=y
+# CONFIG_CMD_BOOTZ is not set
+CONFIG_CMD_ELF=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_RUN=y
+CONFIG_CMD_IMI=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_XIMG=y
+
+#
+# Environment commands
+#
+# CONFIG_CMD_ASKENV is not set
+CONFIG_CMD_EXPORTENV=y
+CONFIG_CMD_IMPORTENV=y
+CONFIG_CMD_EDITENV=y
+# CONFIG_CMD_GREPENV is not set
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_ENV_EXISTS=y
+
+#
+# Memory commands
+#
+CONFIG_CMD_MEMORY=y
+CONFIG_CMD_CRC32=y
+# CONFIG_LOOPW is not set
+# CONFIG_CMD_MEMTEST is not set
+# CONFIG_CMD_MX_CYCLIC is not set
+# CONFIG_CMD_MEMINFO is not set
+
+#
+# Device access commands
+#
+CONFIG_CMD_DM=y
+# CONFIG_CMD_DEMO is not set
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_LOADS=y
+CONFIG_CMD_FLASH=y
+# CONFIG_CMD_ARMFLASH is not set
+# CONFIG_CMD_MMC is not set
+# CONFIG_CMD_NAND is not set
+# CONFIG_CMD_SF is not set
+# CONFIG_CMD_SPI is not set
+# CONFIG_CMD_I2C is not set
+CONFIG_CMD_USB=y
+# CONFIG_CMD_DFU is not set
+# CONFIG_CMD_USB_MASS_STORAGE is not set
+CONFIG_CMD_FPGA=y
+# CONFIG_CMD_GPIO is not set
+
+#
+# Shell scripting commands
+#
+CONFIG_CMD_ECHO=y
+CONFIG_CMD_ITEST=y
+CONFIG_CMD_SOURCE=y
+CONFIG_CMD_SETEXPR=y
+
+#
+# Network commands
+#
+CONFIG_CMD_NET=y
+# CONFIG_CMD_TFTPPUT is not set
+# CONFIG_CMD_TFTPSRV is not set
+# CONFIG_CMD_RARP is not set
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_NFS=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+# CONFIG_CMD_CDP is not set
+# CONFIG_CMD_SNTP is not set
+# CONFIG_CMD_DNS is not set
+# CONFIG_CMD_LINK_LOCAL is not set
+
+#
+# Misc commands
+#
+CONFIG_CMD_CACHE=y
+# CONFIG_CMD_TIME is not set
+CONFIG_CMD_MISC=y
+# CONFIG_CMD_TIMER is not set
+# CONFIG_CMD_QFW is not set
+
+#
+# Power commands
+#
+
+#
+# Security commands
+#
+
+#
+# Firmware commands
+#
+
+#
+# Filesystem commands
+#
+# CONFIG_CMD_EXT2 is not set
+# CONFIG_CMD_EXT4 is not set
+# CONFIG_CMD_FAT is not set
+# CONFIG_CMD_FS_GENERIC is not set
+# CONFIG_CMD_UBI is not set
+CONFIG_SUPPORT_OF_CONTROL=y
+
+#
+# Device Tree Control
+#
+# CONFIG_OF_CONTROL is not set
+CONFIG_NET=y
+CONFIG_NET_RANDOM_ETHADDR=y
+# CONFIG_NETCONSOLE is not set
+CONFIG_NET_TFTP_VARS=y
+CONFIG_BOOTP_PXE_CLIENTARCH=0x15
+CONFIG_BOOTP_VCI_STRING="U-Boot.armv7"
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_DM=y
+CONFIG_DM_WARN=y
+CONFIG_DM_DEVICE_REMOVE=y
+CONFIG_DM_STDIO=y
+CONFIG_DM_SEQ_ALIAS=y
+# CONFIG_SPL_DM_SEQ_ALIAS is not set
+# CONFIG_REGMAP is not set
+# CONFIG_SPL_REGMAP is not set
+# CONFIG_DEVRES is not set
+# CONFIG_ADC is not set
+# CONFIG_ADC_EXYNOS is not set
+# CONFIG_ADC_SANDBOX is not set
+# CONFIG_BLK is not set
+# CONFIG_BLOCK_CACHE is not set
+
+#
+# Clock
+#
+# CONFIG_CLK is not set
+# CONFIG_CPU is not set
+
+#
+# Hardware crypto devices
+#
+# CONFIG_FSL_CAAM is not set
+
+#
+# Demo for driver model
+#
+# CONFIG_DM_DEMO is not set
+
+#
+# DFU support
+#
+
+#
+# DMA Support
+#
+# CONFIG_DMA is not set
+# CONFIG_TI_EDMA3 is not set
+
+#
+# FPGA support
+#
+# CONFIG_FPGA_XILINX is not set
+
+#
+# GPIO Support
+#
+# CONFIG_DM_GPIO is not set
+# CONFIG_INTEL_BROADWELL_GPIO is not set
+# CONFIG_LPC32XX_GPIO is not set
+# CONFIG_VYBRID_GPIO is not set
+
+#
+# I2C support
+#
+# CONFIG_DM_I2C is not set
+# CONFIG_DM_I2C_COMPAT is not set
+# CONFIG_SYS_I2C_DW is not set
+# CONFIG_DM_KEYBOARD is not set
+# CONFIG_CROS_EC_KEYB is not set
+
+#
+# LED Support
+#
+# CONFIG_LED is not set
+
+#
+# Mailbox Controller Support
+#
+
+#
+# Memory Controller drivers
+#
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MISC is not set
+# CONFIG_CROS_EC is not set
+# CONFIG_FSL_SEC_MON is not set
+# CONFIG_MXC_OCOTP is not set
+# CONFIG_NUVOTON_NCT6102D is not set
+# CONFIG_PWRSEQ is not set
+# CONFIG_PCA9551_LED is not set
+# CONFIG_WINBOND_W83627 is not set
+
+#
+# MMC Host controller Support
+#
+# CONFIG_DM_MMC is not set
+
+#
+# MTD Support
+#
+# CONFIG_MTD is not set
+CONFIG_FMC=y
+
+#
+# NAND Device Support
+#
+# CONFIG_NAND_DENALI is not set
+# CONFIG_NAND_VF610_NFC is not set
+# CONFIG_NAND_PXA3XX is not set
+# CONFIG_NAND_ARASAN is not set
+CONFIG_FMC_SPI_NAND=y
+# CONFIG_FMC_NAND is not set
+CONFIG_SPI_NAND_MAX_CHIP_NUM=1
+# CONFIG_FMC100_HARDWARE_PAGESIZE_ECC is not set
+CONFIG_FMC100_AUTO_PAGESIZE_ECC=y
+# CONFIG_FMC100_PAGESIZE_AUTO_ECC_NONE is not set
+
+#
+# Generic NAND options
+#
+
+#
+# SPI Flash Support
+#
+# CONFIG_SPI_FLASH is not set
+CONFIG_FMC_SPI_NOR=y
+# CONFIG_SPI_BLOCK_PROTECT is not set
+# CONFIG_DTR_MODE_SUPPORT is not set
+
+#
+# UBI support
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_DM_ETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NETDEVICES=y
+# CONFIG_E1000 is not set
+# CONFIG_ETH_DESIGNWARE is not set
+# CONFIG_ETHOC is not set
+# CONFIG_RTL8139 is not set
+# CONFIG_RTL8169 is not set
+CONFIG_NET_FEMAC=y
+# CONFIG_NET_GMACV300 is not set
+# CONFIG_PCI is not set
+# CONFIG_MVEBU_COMPHY_SUPPORT is not set
+CONFIG_PHY_VENDOR_USB=y
+
+#
+# Pin controllers
+#
+# CONFIG_PINCTRL is not set
+
+#
+# Power
+#
+
+#
+# Power Domain Support
+#
+# CONFIG_DM_PMIC is not set
+# CONFIG_DM_REGULATOR is not set
+# CONFIG_DM_PWM is not set
+# CONFIG_RAM is not set
+
+#
+# Remote Processor drivers
+#
+
+#
+# Reset Controller Support
+#
+
+#
+# Real Time Clock
+#
+# CONFIG_DM_RTC is not set
+
+#
+# Serial drivers
+#
+# CONFIG_DM_SERIAL is not set
+# CONFIG_DEBUG_UART is not set
+# CONFIG_DEBUG_UART_SKIP_INIT is not set
+# CONFIG_ATMEL_USART is not set
+# CONFIG_FSL_LPUART is not set
+# CONFIG_MVEBU_A3700_UART is not set
+# CONFIG_SYS_NS16550 is not set
+
+#
+# Sound support
+#
+# CONFIG_SOUND is not set
+
+#
+# SPI Support
+#
+# CONFIG_DM_SPI is not set
+# CONFIG_FSL_ESPI is not set
+# CONFIG_FSL_QSPI is not set
+# CONFIG_TI_QSPI is not set
+
+#
+# SPMI support
+#
+# CONFIG_SPMI is not set
+
+#
+# System reset device drivers
+#
+# CONFIG_SYSRESET is not set
+# CONFIG_DM_THERMAL is not set
+
+#
+# Timer Support
+#
+# CONFIG_TIMER is not set
+
+#
+# TPM support
+#
+CONFIG_USB=y
+# CONFIG_DM_USB is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_HOST=y
+CONFIG_USB_XHCI_HCD=y
+# CONFIG_USB_XHCI_DWC3 is not set
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_EHCI is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+
+#
+# MUSB Controller Driver
+#
+# CONFIG_USB_MUSB_HOST is not set
+# CONFIG_USB_MUSB_GADGET is not set
+
+#
+# ULPI drivers
+#
+
+#
+# USB peripherals
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_KEYBOARD is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# UFS Support
+#
+# CONFIG_UFS is not set
+
+#
+# Graphics support
+#
+# CONFIG_DM_VIDEO is not set
+
+#
+# TrueType Fonts
+#
+# CONFIG_VIDEO_VESA is not set
+# CONFIG_VIDEO_LCD_ANX9804 is not set
+# CONFIG_VIDEO_LCD_SSD2828 is not set
+# CONFIG_VIDEO_MVEBU is not set
+# CONFIG_DISPLAY is not set
+# CONFIG_VIDEO_BRIDGE is not set
+# CONFIG_LCD is not set
+# CONFIG_PHYS_TO_BUS is not set
+
+#
+# File systems
+#
+
+#
+# Library routines
+#
+# CONFIG_CC_OPTIMIZE_LIBS_FOR_SPEED is not set
+CONFIG_HAVE_PRIVATE_LIBGCC=y
+CONFIG_USE_PRIVATE_LIBGCC=y
+CONFIG_SYS_HZ=1000
+# CONFIG_USE_TINY_PRINTF is not set
+CONFIG_REGEX=y
+CONFIG_LIB_RAND=y
+# CONFIG_CMD_DHRYSTONE is not set
+# CONFIG_RSA is not set
+# CONFIG_TPM is not set
+
+#
+# Hashing Support
+#
+# CONFIG_SHA1 is not set
+# CONFIG_SHA256 is not set
+# CONFIG_SHA_HW_ACCEL is not set
+
+#
+# Compression Support
+#
+# CONFIG_LZ4 is not set
+# CONFIG_ERRNO_STR is not set
+# CONFIG_OF_LIBFDT is not set
+# CONFIG_OF_LIBFDT_OVERLAY is not set
+# CONFIG_SPL_OF_LIBFDT is not set
+
+#
+# System tables
+#
+CONFIG_HWDEC=y
+# CONFIG_OPTEE is not set
+CONFIG_OPTEE_LOAD_ADDR=0x00000000
+# CONFIG_BOOTM_OPTEE is not set
+# CONFIG_UNIT_TEST is not set
diff -uraN u-boot-2016.11/configs/gk7605v100_emmc_defconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/configs/gk7605v100_emmc_defconfig
--- u-boot-2016.11/configs/gk7605v100_emmc_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/configs/gk7605v100_emmc_defconfig	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,710 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# U-Boot 2016.11 Configuration
+#
+CONFIG_CREATE_ARCH_SYMLINK=y
+# CONFIG_ARC is not set
+CONFIG_ARM=y
+# CONFIG_AVR32 is not set
+# CONFIG_BLACKFIN is not set
+# CONFIG_M68K is not set
+# CONFIG_MICROBLAZE is not set
+# CONFIG_MIPS is not set
+# CONFIG_NDS32 is not set
+# CONFIG_NIOS2 is not set
+# CONFIG_OPENRISC is not set
+# CONFIG_PPC is not set
+# CONFIG_SANDBOX is not set
+# CONFIG_SH is not set
+# CONFIG_SPARC is not set
+# CONFIG_X86 is not set
+# CONFIG_XTENSA is not set
+CONFIG_SYS_ARCH="arm"
+CONFIG_SYS_CPU="armv7"
+CONFIG_SYS_SOC="gk7605v100"
+CONFIG_SYS_VENDOR="goke"
+CONFIG_SYS_BOARD="gk7605v100"
+CONFIG_SYS_CONFIG_NAME="gk7605v100"
+
+#
+# ARM architecture
+#
+# CONFIG_MINI_BOOT is not set
+CONFIG_HAS_VBAR=y
+CONFIG_HAS_THUMB2=y
+CONFIG_CPU_V7=y
+CONFIG_SYS_ARM_ARCH=7
+CONFIG_SYS_CACHE_SHIFT_6=y
+CONFIG_SYS_CACHELINE_SIZE=64
+# CONFIG_SEMIHOSTING is not set
+# CONFIG_SYS_L2CACHE_OFF is not set
+CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK=y
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_TARGET_EDB93XX is not set
+# CONFIG_TARGET_VCMA9 is not set
+# CONFIG_TARGET_SMDK2410 is not set
+# CONFIG_TARGET_ASPENITE is not set
+# CONFIG_TARGET_GPLUGD is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_KIRKWOOD is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_TARGET_DEVKIT3250 is not set
+# CONFIG_TARGET_WORK_92105 is not set
+# CONFIG_TARGET_MX25PDK is not set
+# CONFIG_TARGET_ZMX25 is not set
+# CONFIG_TARGET_APF27 is not set
+# CONFIG_TARGET_APX4DEVKIT is not set
+# CONFIG_TARGET_XFI3 is not set
+# CONFIG_TARGET_M28EVK is not set
+# CONFIG_TARGET_MX23EVK is not set
+# CONFIG_TARGET_MX28EVK is not set
+# CONFIG_TARGET_MX23_OLINUXINO is not set
+# CONFIG_TARGET_BG0900 is not set
+# CONFIG_TARGET_SANSA_FUZE_PLUS is not set
+# CONFIG_TARGET_SC_SPS_1 is not set
+# CONFIG_ORION5X is not set
+# CONFIG_TARGET_SPEAR300 is not set
+# CONFIG_TARGET_SPEAR310 is not set
+# CONFIG_TARGET_SPEAR320 is not set
+# CONFIG_TARGET_SPEAR600 is not set
+# CONFIG_TARGET_STV0991 is not set
+# CONFIG_TARGET_X600 is not set
+# CONFIG_TARGET_IMX31_PHYCORE is not set
+# CONFIG_TARGET_MX31ADS is not set
+# CONFIG_TARGET_MX31PDK is not set
+# CONFIG_TARGET_WOODBURN is not set
+# CONFIG_TARGET_WOODBURN_SD is not set
+# CONFIG_TARGET_FLEA3 is not set
+# CONFIG_TARGET_MX35PDK is not set
+# CONFIG_ARCH_BCM283X is not set
+# CONFIG_TARGET_VEXPRESS_CA15_TC2 is not set
+# CONFIG_TARGET_VEXPRESS_CA5X2 is not set
+# CONFIG_TARGET_VEXPRESS_CA9X4 is not set
+# CONFIG_TARGET_BRXRE1 is not set
+# CONFIG_TARGET_BRPPT1 is not set
+# CONFIG_TARGET_DRACO is not set
+# CONFIG_TARGET_THUBAN is not set
+# CONFIG_TARGET_RASTABAN is not set
+# CONFIG_TARGET_ETAMIN is not set
+# CONFIG_TARGET_PXM2 is not set
+# CONFIG_TARGET_RUT is not set
+# CONFIG_TARGET_TI814X_EVM is not set
+# CONFIG_TARGET_TI816X_EVM is not set
+# CONFIG_TARGET_BCM23550_W1D is not set
+# CONFIG_TARGET_BCM28155_AP is not set
+# CONFIG_TARGET_BCMCYGNUS is not set
+# CONFIG_TARGET_BCMNSP is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MX7 is not set
+# CONFIG_ARCH_MX6 is not set
+# CONFIG_ARCH_MX5 is not set
+# CONFIG_TARGET_M53EVK is not set
+# CONFIG_TARGET_MX51EVK is not set
+# CONFIG_TARGET_MX53ARD is not set
+# CONFIG_TARGET_MX53EVK is not set
+# CONFIG_TARGET_MX53LOCO is not set
+# CONFIG_TARGET_MX53SMD is not set
+# CONFIG_OMAP34XX is not set
+# CONFIG_OMAP44XX is not set
+# CONFIG_OMAP54XX is not set
+# CONFIG_AM43XX is not set
+# CONFIG_AM33XX is not set
+# CONFIG_ARCH_RMOBILE is not set
+# CONFIG_TARGET_S32V234EVB is not set
+# CONFIG_ARCH_SNAPDRAGON is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_TARGET_CM_T43 is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_TARGET_TS4800 is not set
+# CONFIG_TARGET_VF610TWR is not set
+# CONFIG_TARGET_COLIBRI_VF is not set
+# CONFIG_TARGET_PCM052 is not set
+# CONFIG_TARGET_BK4R1 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_ARCH_ZYNQMP is not set
+# CONFIG_TEGRA is not set
+# CONFIG_TARGET_VEXPRESS64_AEMV8A is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP_DRAM is not set
+# CONFIG_TARGET_VEXPRESS64_JUNO is not set
+# CONFIG_TARGET_LS2080A_EMU is not set
+# CONFIG_TARGET_LS2080A_SIMU is not set
+# CONFIG_TARGET_LS2080AQDS is not set
+# CONFIG_TARGET_LS2080ARDB is not set
+# CONFIG_TARGET_HIKEY is not set
+# CONFIG_TARGET_GK7205V200 is not set
+# CONFIG_TARGET_GK7202V300 is not set
+CONFIG_TARGET_GK7605V100=y
+# CONFIG_TARGET_GK7205V300 is not set
+# CONFIG_TARGET_LS1012AQDS is not set
+# CONFIG_TARGET_LS1012ARDB is not set
+# CONFIG_TARGET_LS1012AFRDM is not set
+# CONFIG_TARGET_LS1021AQDS is not set
+# CONFIG_TARGET_LS1021ATWR is not set
+# CONFIG_TARGET_LS1043AQDS is not set
+# CONFIG_TARGET_LS1043ARDB is not set
+# CONFIG_TARGET_LS1046AQDS is not set
+# CONFIG_TARGET_LS1046ARDB is not set
+# CONFIG_TARGET_H2200 is not set
+# CONFIG_TARGET_ZIPITZ2 is not set
+# CONFIG_TARGET_COLIBRI_PXA270 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_STM32 is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_TARGET_THUNDERX_88XX is not set
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_CPU_V7_HAS_NONSEC=y
+CONFIG_ARMV7_NONSEC=y
+CONFIG_ARMV7_BOOT_SEC_DEFAULT=y
+CONFIG_ARMV7_PSCI_NR_CPUS=4
+# CONFIG_ARMV7_LPAE is not set
+CONFIG_IDENT_STRING="gk7605v100"
+# CONFIG_PRE_CONSOLE_BUFFER is not set
+CONFIG_MMC=y
+# CONFIG_VIDEO is not set
+
+#
+# ARM debug
+#
+# CONFIG_DEBUG_LL is not set
+# CONFIG_AHCI is not set
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_DISTRO_DEFAULTS is not set
+CONFIG_SYS_MALLOC_F=y
+CONFIG_EXPERT=y
+CONFIG_SYS_MALLOC_CLEAR_ON_INIT=y
+# CONFIG_TOOLS_DEBUG is not set
+# CONFIG_PHYS_64BIT is not set
+
+#
+# Boot images
+#
+CONFIG_FIT=y
+# CONFIG_FIT_VERBOSE is not set
+# CONFIG_FIT_SIGNATURE is not set
+# CONFIG_FIT_BEST_MATCH is not set
+CONFIG_SYS_EXTRA_OPTIONS=""
+# CONFIG_SPL_LOAD_FIT is not set
+# CONFIG_SPL_DFU_SUPPORT is not set
+CONFIG_ARCH_FIXUP_FDT=y
+
+#
+# Boot timing
+#
+# CONFIG_BOOTSTAGE is not set
+CONFIG_BOOTSTAGE_USER_COUNT=20
+CONFIG_BOOTSTAGE_STASH_ADDR=0
+CONFIG_BOOTSTAGE_STASH_SIZE=4096
+
+#
+# Boot media
+#
+# CONFIG_NAND_BOOT is not set
+# CONFIG_ONENAND_BOOT is not set
+# CONFIG_QSPI_BOOT is not set
+# CONFIG_SATA_BOOT is not set
+# CONFIG_SD_BOOT is not set
+# CONFIG_SPI_BOOT is not set
+CONFIG_BOOTDELAY=2
+
+#
+# goke_setup
+#
+# CONFIG_GK_MC is not set
+# CONFIG_GK_UPGRADE_BY_SEGMENT is not set
+# CONFIG_GK_DISABLE_CONSOLE is not set
+# CONFIG_GK_DISABLE_DOWNLOAD is not set
+
+#
+# Console
+#
+# CONFIG_CONSOLE_RECORD is not set
+# CONFIG_SILENT_CONSOLE is not set
+# CONFIG_CONSOLE_MUX is not set
+# CONFIG_SYS_CONSOLE_IS_IN_ENV is not set
+# CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE is not set
+# CONFIG_SYS_CONSOLE_ENV_OVERWRITE is not set
+# CONFIG_SYS_CONSOLE_INFO_QUIET is not set
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_DEFAULT_FDT_FILE=""
+CONFIG_KERNEL_LOAD_ADDR=0x42080000
+# CONFIG_SYS_NO_FLASH is not set
+# CONFIG_VERSION_VARIABLE is not set
+# CONFIG_DISPLAY_CPUINFO is not set
+# CONFIG_DISPLAY_BOARDINFO is not set
+# CONFIG_CMD_CREAD is not set
+
+#
+# SPL / TPL
+#
+
+#
+# Command line interface
+#
+CONFIG_CMDLINE=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="goke # "
+
+#
+# Autoboot options
+#
+CONFIG_AUTOBOOT=y
+# CONFIG_AUTOBOOT_KEYED is not set
+
+#
+# FASTBOOT
+#
+# CONFIG_FASTBOOT is not set
+
+#
+# Commands
+#
+
+#
+# Info commands
+#
+CONFIG_CMD_BDI=y
+CONFIG_CMD_CONSOLE=y
+# CONFIG_CMD_CPU is not set
+# CONFIG_CMD_LICENSE is not set
+
+#
+# Boot commands
+#
+CONFIG_CMD_BOOTD=y
+CONFIG_CMD_BOOTM=y
+# CONFIG_CMD_BOOTZ is not set
+CONFIG_CMD_ELF=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_RUN=y
+CONFIG_CMD_IMI=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_XIMG=y
+
+#
+# Environment commands
+#
+# CONFIG_CMD_ASKENV is not set
+CONFIG_CMD_EXPORTENV=y
+CONFIG_CMD_IMPORTENV=y
+CONFIG_CMD_EDITENV=y
+# CONFIG_CMD_GREPENV is not set
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_ENV_EXISTS=y
+
+#
+# Memory commands
+#
+CONFIG_CMD_MEMORY=y
+CONFIG_CMD_CRC32=y
+# CONFIG_LOOPW is not set
+# CONFIG_CMD_MEMTEST is not set
+# CONFIG_CMD_MX_CYCLIC is not set
+# CONFIG_CMD_MEMINFO is not set
+
+#
+# Device access commands
+#
+CONFIG_CMD_DM=y
+# CONFIG_CMD_DEMO is not set
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_LOADS=y
+CONFIG_CMD_FLASH=y
+# CONFIG_CMD_ARMFLASH is not set
+# CONFIG_CMD_MMC is not set
+# CONFIG_CMD_NAND is not set
+# CONFIG_CMD_SF is not set
+# CONFIG_CMD_SPI is not set
+# CONFIG_CMD_I2C is not set
+CONFIG_CMD_USB=y
+# CONFIG_CMD_DFU is not set
+# CONFIG_CMD_USB_MASS_STORAGE is not set
+CONFIG_CMD_FPGA=y
+# CONFIG_CMD_GPIO is not set
+
+#
+# Shell scripting commands
+#
+CONFIG_CMD_ECHO=y
+CONFIG_CMD_ITEST=y
+CONFIG_CMD_SOURCE=y
+CONFIG_CMD_SETEXPR=y
+
+#
+# Network commands
+#
+CONFIG_CMD_NET=y
+# CONFIG_CMD_TFTPPUT is not set
+# CONFIG_CMD_TFTPSRV is not set
+# CONFIG_CMD_RARP is not set
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_NFS=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+# CONFIG_CMD_CDP is not set
+# CONFIG_CMD_SNTP is not set
+# CONFIG_CMD_DNS is not set
+# CONFIG_CMD_LINK_LOCAL is not set
+
+#
+# Misc commands
+#
+CONFIG_CMD_CACHE=y
+# CONFIG_CMD_TIME is not set
+CONFIG_CMD_MISC=y
+# CONFIG_CMD_TIMER is not set
+# CONFIG_CMD_QFW is not set
+
+#
+# Power commands
+#
+
+#
+# Security commands
+#
+
+#
+# Firmware commands
+#
+
+#
+# Filesystem commands
+#
+# CONFIG_CMD_EXT2 is not set
+# CONFIG_CMD_EXT4 is not set
+# CONFIG_CMD_FAT is not set
+# CONFIG_CMD_FS_GENERIC is not set
+# CONFIG_CMD_UBI is not set
+CONFIG_SUPPORT_OF_CONTROL=y
+
+#
+# Device Tree Control
+#
+# CONFIG_OF_CONTROL is not set
+CONFIG_NET=y
+CONFIG_NET_RANDOM_ETHADDR=y
+# CONFIG_NETCONSOLE is not set
+CONFIG_NET_TFTP_VARS=y
+CONFIG_BOOTP_PXE_CLIENTARCH=0x15
+CONFIG_BOOTP_VCI_STRING="U-Boot.armv7"
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_DM=y
+CONFIG_DM_WARN=y
+CONFIG_DM_DEVICE_REMOVE=y
+CONFIG_DM_STDIO=y
+CONFIG_DM_SEQ_ALIAS=y
+# CONFIG_SPL_DM_SEQ_ALIAS is not set
+# CONFIG_REGMAP is not set
+# CONFIG_SPL_REGMAP is not set
+# CONFIG_DEVRES is not set
+# CONFIG_ADC is not set
+# CONFIG_ADC_EXYNOS is not set
+# CONFIG_ADC_SANDBOX is not set
+# CONFIG_BLK is not set
+# CONFIG_BLOCK_CACHE is not set
+
+#
+# Clock
+#
+# CONFIG_CLK is not set
+# CONFIG_CPU is not set
+
+#
+# Hardware crypto devices
+#
+# CONFIG_FSL_CAAM is not set
+
+#
+# Demo for driver model
+#
+# CONFIG_DM_DEMO is not set
+
+#
+# DFU support
+#
+
+#
+# DMA Support
+#
+# CONFIG_DMA is not set
+# CONFIG_TI_EDMA3 is not set
+
+#
+# FPGA support
+#
+# CONFIG_FPGA_XILINX is not set
+
+#
+# GPIO Support
+#
+# CONFIG_DM_GPIO is not set
+# CONFIG_INTEL_BROADWELL_GPIO is not set
+# CONFIG_LPC32XX_GPIO is not set
+# CONFIG_VYBRID_GPIO is not set
+
+#
+# I2C support
+#
+# CONFIG_DM_I2C is not set
+# CONFIG_DM_I2C_COMPAT is not set
+# CONFIG_SYS_I2C_DW is not set
+# CONFIG_DM_KEYBOARD is not set
+# CONFIG_CROS_EC_KEYB is not set
+
+#
+# LED Support
+#
+# CONFIG_LED is not set
+
+#
+# Mailbox Controller Support
+#
+
+#
+# Memory Controller drivers
+#
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MISC is not set
+# CONFIG_CROS_EC is not set
+# CONFIG_FSL_SEC_MON is not set
+# CONFIG_MXC_OCOTP is not set
+# CONFIG_NUVOTON_NCT6102D is not set
+# CONFIG_PWRSEQ is not set
+# CONFIG_PCA9551_LED is not set
+# CONFIG_WINBOND_W83627 is not set
+
+#
+# MMC Host controller Support
+#
+# CONFIG_DM_MMC is not set
+
+#
+# MTD Support
+#
+# CONFIG_MTD is not set
+# CONFIG_FMC is not set
+
+#
+# NAND Device Support
+#
+# CONFIG_NAND_DENALI is not set
+# CONFIG_NAND_VF610_NFC is not set
+# CONFIG_NAND_PXA3XX is not set
+# CONFIG_NAND_ARASAN is not set
+
+#
+# Generic NAND options
+#
+
+#
+# SPI Flash Support
+#
+# CONFIG_SPI_FLASH is not set
+
+#
+# UBI support
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_DM_ETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NETDEVICES=y
+# CONFIG_E1000 is not set
+# CONFIG_ETH_DESIGNWARE is not set
+# CONFIG_ETHOC is not set
+# CONFIG_RTL8139 is not set
+# CONFIG_RTL8169 is not set
+CONFIG_NET_FEMAC=y
+# CONFIG_NET_GMACV300 is not set
+# CONFIG_PCI is not set
+# CONFIG_MVEBU_COMPHY_SUPPORT is not set
+CONFIG_PHY_VENDOR_USB=y
+
+#
+# Pin controllers
+#
+# CONFIG_PINCTRL is not set
+
+#
+# Power
+#
+
+#
+# Power Domain Support
+#
+# CONFIG_DM_PMIC is not set
+# CONFIG_DM_REGULATOR is not set
+# CONFIG_DM_PWM is not set
+# CONFIG_RAM is not set
+
+#
+# Remote Processor drivers
+#
+
+#
+# Reset Controller Support
+#
+
+#
+# Real Time Clock
+#
+# CONFIG_DM_RTC is not set
+
+#
+# Serial drivers
+#
+# CONFIG_DM_SERIAL is not set
+# CONFIG_DEBUG_UART is not set
+# CONFIG_DEBUG_UART_SKIP_INIT is not set
+# CONFIG_ATMEL_USART is not set
+# CONFIG_FSL_LPUART is not set
+# CONFIG_MVEBU_A3700_UART is not set
+# CONFIG_SYS_NS16550 is not set
+
+#
+# Sound support
+#
+# CONFIG_SOUND is not set
+
+#
+# SPI Support
+#
+# CONFIG_DM_SPI is not set
+# CONFIG_FSL_ESPI is not set
+# CONFIG_FSL_QSPI is not set
+# CONFIG_TI_QSPI is not set
+
+#
+# SPMI support
+#
+# CONFIG_SPMI is not set
+
+#
+# System reset device drivers
+#
+# CONFIG_SYSRESET is not set
+# CONFIG_DM_THERMAL is not set
+
+#
+# Timer Support
+#
+# CONFIG_TIMER is not set
+
+#
+# TPM support
+#
+CONFIG_USB=y
+# CONFIG_DM_USB is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_HOST=y
+CONFIG_USB_XHCI_HCD=y
+# CONFIG_USB_XHCI_DWC3 is not set
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_EHCI is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+
+#
+# MUSB Controller Driver
+#
+# CONFIG_USB_MUSB_HOST is not set
+# CONFIG_USB_MUSB_GADGET is not set
+
+#
+# ULPI drivers
+#
+
+#
+# USB peripherals
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_KEYBOARD is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# UFS Support
+#
+# CONFIG_UFS is not set
+
+#
+# Graphics support
+#
+# CONFIG_DM_VIDEO is not set
+
+#
+# TrueType Fonts
+#
+# CONFIG_VIDEO_VESA is not set
+# CONFIG_VIDEO_LCD_ANX9804 is not set
+# CONFIG_VIDEO_LCD_SSD2828 is not set
+# CONFIG_VIDEO_MVEBU is not set
+# CONFIG_DISPLAY is not set
+# CONFIG_VIDEO_BRIDGE is not set
+# CONFIG_LCD is not set
+# CONFIG_PHYS_TO_BUS is not set
+
+#
+# File systems
+#
+
+#
+# Library routines
+#
+# CONFIG_CC_OPTIMIZE_LIBS_FOR_SPEED is not set
+CONFIG_HAVE_PRIVATE_LIBGCC=y
+CONFIG_USE_PRIVATE_LIBGCC=y
+CONFIG_SYS_HZ=1000
+# CONFIG_USE_TINY_PRINTF is not set
+CONFIG_REGEX=y
+CONFIG_LIB_RAND=y
+# CONFIG_CMD_DHRYSTONE is not set
+# CONFIG_RSA is not set
+# CONFIG_TPM is not set
+
+#
+# Hashing Support
+#
+# CONFIG_SHA1 is not set
+# CONFIG_SHA256 is not set
+# CONFIG_SHA_HW_ACCEL is not set
+
+#
+# Compression Support
+#
+# CONFIG_LZ4 is not set
+# CONFIG_ERRNO_STR is not set
+# CONFIG_OF_LIBFDT is not set
+# CONFIG_OF_LIBFDT_OVERLAY is not set
+# CONFIG_SPL_OF_LIBFDT is not set
+
+#
+# System tables
+#
+CONFIG_HWDEC=y
+# CONFIG_OPTEE is not set
+CONFIG_OPTEE_LOAD_ADDR=0x00000000
+# CONFIG_BOOTM_OPTEE is not set
+# CONFIG_UNIT_TEST is not set
diff -uraN u-boot-2016.11/disk/part_dos.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/disk/part_dos.c
--- u-boot-2016.11/disk/part_dos.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/disk/part_dos.c	2021-06-07 13:01:32.000000000 +0300
@@ -24,6 +24,10 @@
 
 #define DOS_PART_DEFAULT_SECTOR 512
 
+/* should this be configurable? It looks like it's not very common at all
+ * to use large numbers of partitions */
+#define MAX_EXT_PARTS 256
+
 /* Convert char[4] in little endian format to the host format integer
  */
 static inline unsigned int le32_to_int(unsigned char *le32)
@@ -59,7 +63,7 @@
 		(is_extended(p->sys_ind) ? " Extd" : ""),
 		(is_bootable(p) ? " Boot" : ""));
 }
-
+#if 0
 static int test_block_type(unsigned char *buffer)
 {
 	int slot;
@@ -85,19 +89,79 @@
 	}
 	return DOS_MBR;	    /* Is MBR */
 }
+#endif
+static int test_block_type(unsigned char *buffer)
+{
+	int slot;
+	struct dos_partition *p;
+    int checkpbr = 0;
+
+	if((buffer[DOS_PART_MAGIC_OFFSET + 0] != 0x55) ||
+	    (buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) ) {
+		return (-1);
+	} /* no DOS Signature at all */
+	p = (struct dos_partition *)&buffer[DOS_PART_TBL_OFFSET];
+	for (slot = 0; slot < 3; slot++) {
+        if(p->boot_ind != 0 && p->boot_ind != 0x80){
+            //not valid mbr,need check PBR
+            checkpbr = 1;
+        }else if(p->boot_ind == 0){  //some cases MBR's DOS_PART_TBL_OFFSET value is 0, but paration is valid
+            if(p->size4[0] == 0 && p->size4[1] == 0 && p->size4[2] == 0 && p->size4[3] == 0)
+            {
+                //not valid mbr paratition size, check PBR
+                checkpbr = 1;
+            }else{
+                checkpbr = 0;
+            }
+        }else{
+            checkpbr = 0;
+        }
+
+        if(checkpbr){
+			if (!slot &&
+			    (strncmp((char *)&buffer[DOS_PBR_FSTYPE_OFFSET],
+				     "FAT", 3) == 0 ||
+			     strncmp((char *)&buffer[DOS_PBR32_FSTYPE_OFFSET],
+				     "FAT32", 5) == 0)) {
+				return DOS_PBR; /* is PBR */
+			} else {
+				return -1;
+			}
+		}
+	}
+	return DOS_MBR;	    /* Is MBR */
+}
+
 
 
 static int part_test_dos(struct blk_desc *dev_desc)
 {
 	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
+    int ret = -1;
+    lbaint_t start = 0;
 
-	if (blk_dread(dev_desc, 0, 1, (ulong *)buffer) != 1)
-		return -1;
+#if (CONFIG_AUTO_UPDATE == 1)
+#ifdef CONFIG_EMMC
+    extern int target_dev;
+    extern unsigned int dos_start_lba;
+    if(dev_desc->devnum == target_dev){
+        start = dos_start_lba;
+    }
+#endif
+#endif
 
-	if (test_block_type(buffer) != DOS_MBR)
+	if (blk_dread(dev_desc, start, 1, (ulong *)buffer) != 1)
 		return -1;
 
-	return 0;
+	/*if (test_block_type(buffer) != DOS_MBR)
+		return -1;*/
+
+    ret = test_block_type(buffer);
+    if((ret==DOS_PBR)||(ret==DOS_MBR)){
+        return 0;
+    }else{
+        return -1;
+    }
 }
 
 /*  Print a partition that is relative to its Extended partition table
@@ -110,6 +174,24 @@
 	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
 	dos_partition_t *pt;
 	int i;
+    lbaint_t start_sector = 0;
+
+	/* set a maximum recursion level */
+	if (part_num > MAX_EXT_PARTS)
+	{
+		printf("** Nested DOS partitions detected, stopping **\n");
+		return;
+	}
+
+#if (CONFIG_AUTO_UPDATE == 1)
+#ifdef CONFIG_EMMC
+        extern int target_dev;
+        extern unsigned int dos_start_lba;
+        if(dev_desc->devnum == target_dev){
+            start_sector = dos_start_lba;
+        }
+#endif
+#endif
 
 	if (blk_dread(dev_desc, ext_part_sector, 1, (ulong *)buffer) != 1) {
 		printf ("** Can't read partition table on %d:" LBAFU " **\n",
@@ -141,7 +223,7 @@
 		}
 
 		/* Reverse engr the fdisk part# assignment rule! */
-		if ((ext_part_sector == 0) ||
+		if ((ext_part_sector == start_sector) ||
 		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
 			part_num++;
 		}
@@ -155,7 +237,7 @@
 				= le32_to_int (pt->start4) + relative;
 
 			print_partition_extended(dev_desc, lba_start,
-				ext_part_sector == 0  ? lba_start : relative,
+				ext_part_sector == start_sector  ? lba_start : relative,
 				part_num, disksig);
 		}
 	}
@@ -175,7 +257,24 @@
 	dos_partition_t *pt;
 	int i;
 	int dos_type;
+    lbaint_t start_sector = 0;
+
+	/* set a maximum recursion level */
+	if (part_num > MAX_EXT_PARTS)
+	{
+		printf("** Nested DOS partitions detected, stopping **\n");
+		return -1;
+	}
 
+#if (CONFIG_AUTO_UPDATE == 1)
+#ifdef CONFIG_EMMC
+    extern int target_dev;
+    extern unsigned int dos_start_lba;
+    if(dev_desc->devnum == target_dev){
+        start_sector = dos_start_lba;
+    }
+#endif
+#endif
 	if (blk_dread(dev_desc, ext_part_sector, 1, (ulong *)buffer) != 1) {
 		printf ("** Can't read partition table on %d:" LBAFU " **\n",
 			dev_desc->devnum, ext_part_sector);
@@ -221,7 +320,7 @@
 		}
 
 		/* Reverse engr the fdisk part# assignment rule! */
-		if ((ext_part_sector == 0) ||
+		if ((ext_part_sector == start_sector) ||
 		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
 			part_num++;
 		}
@@ -235,7 +334,7 @@
 				= le32_to_int (pt->start4) + relative;
 
 			return part_get_info_extended(dev_desc, lba_start,
-				 ext_part_sector == 0 ? lba_start : relative,
+				 ext_part_sector == start_sector ? lba_start : relative,
 				 part_num, which_part, info, disksig);
 		}
 	}
@@ -244,7 +343,7 @@
 	dos_type = test_block_type(buffer);
 
 	if (dos_type == DOS_PBR) {
-		info->start = 0;
+		info->start = ext_part_sector;
 		info->size = dev_desc->lba;
 		info->blksz = DOS_PART_DEFAULT_SECTOR;
 		info->bootable = 0;
@@ -261,13 +360,35 @@
 void part_print_dos(struct blk_desc *dev_desc)
 {
 	printf("Part\tStart Sector\tNum Sectors\tUUID\t\tType\n");
-	print_partition_extended(dev_desc, 0, 0, 1, 0);
+    lbaint_t start_sector = 0;
+
+#if (CONFIG_AUTO_UPDATE == 1)
+#ifdef CONFIG_EMMC
+    extern int target_dev;
+    extern unsigned int dos_start_lba;
+    if(dev_desc->devnum == target_dev){
+        start_sector = dos_start_lba;
+    }
+#endif
+#endif
+	print_partition_extended(dev_desc, start_sector, 0, 1, 0);
 }
 
 int part_get_info_dos(struct blk_desc *dev_desc, int part,
 		      disk_partition_t *info)
 {
-	return part_get_info_extended(dev_desc, 0, 0, 1, part, info, 0);
+    lbaint_t start_sector = 0;
+
+#if (CONFIG_AUTO_UPDATE == 1)
+#ifdef CONFIG_EMMC
+    extern int target_dev;
+    extern unsigned int dos_start_lba;
+    if(dev_desc->devnum == target_dev){
+        start_sector = dos_start_lba;
+    }
+#endif
+#endif
+	return part_get_info_extended(dev_desc, start_sector, 0, 1, part, info, 0);
 }
 
 int is_valid_dos_buf(void *buf)
@@ -280,8 +401,19 @@
 	if (is_valid_dos_buf(buf))
 		return -1;
 
+    lbaint_t start_sector = 0;
+
+#if (CONFIG_AUTO_UPDATE == 1)
+#ifdef CONFIG_EMMC
+        extern int target_dev;
+        extern unsigned int dos_start_lba;
+        if(dev_desc->devnum == target_dev){
+            start_sector = dos_start_lba;
+        }
+#endif
+#endif
 	/* write MBR */
-	if (blk_dwrite(dev_desc, 0, 1, buf) != 1) {
+	if (blk_dwrite(dev_desc, start_sector, 1, buf) != 1) {
 		printf("%s: failed writing '%s' (1 blks at 0x0)\n",
 		       __func__, "MBR");
 		return 1;
diff -uraN u-boot-2016.11/disk/part_iso.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/disk/part_iso.c
--- u-boot-2016.11/disk/part_iso.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/disk/part_iso.c	2021-06-07 13:01:32.000000000 +0300
@@ -9,6 +9,7 @@
 #include <command.h>
 #include <asm/unaligned.h>
 #include "part_iso.h"
+#include <memalign.h>
 
 #ifdef HAVE_BLOCK_DEVICE
 
diff -uraN u-boot-2016.11/doc/DocBook/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/doc/DocBook/.gitignore
--- u-boot-2016.11/doc/DocBook/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/doc/DocBook/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1,15 +0,0 @@
-*.xml
-*.ps
-*.pdf
-*.html
-*.9.gz
-*.9
-*.aux
-*.dvi
-*.log
-*.out
-*.png
-*.gif
-*.svg
-media-indices.tmpl
-media-entities.tmpl
diff -uraN u-boot-2016.11/drivers/ddr/goke/default/cmd_bin/cmd_entry_32.S gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/cmd_bin/cmd_entry_32.S
--- u-boot-2016.11/drivers/ddr/goke/default/cmd_bin/cmd_entry_32.S	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/cmd_bin/cmd_entry_32.S	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+.section .text
+.type _start, %function
+.globl _start
+_start:
+	push	{r0 - r10}
+	b	flying
+
+. = 0x10
+_CMD_TEXT_BASE:
+	.word CMD_TEXT_BASE
+
+_arm_start:
+	.word _start
+_flying:
+	.word flying
+_STACK_POINT:
+	.word STACK_POINT
+
+.globl _bss_start
+_bss_start: .word __bss_start
+.globl _bss_end
+_bss_end:   .word _end
+
+_real_start:
+	.word real_start
+flying:
+	mov	r2, pc
+	sub	r2, r2, #8
+	ldr	r1, _arm_start
+	ldr	r0, _flying
+	sub	r1, r0, r1
+	sub	r0, r2, r1
+	ldr	r1, _CMD_TEXT_BASE
+	cmp	r0, r1
+	beq	real_start
+
+	/* need relocation */
+	ldr	r2, _arm_start
+	ldr	r3, _bss_start
+	sub	r2, r3, r2
+	add	r2, r0, r2
+self_move:
+	ldmia	r0!, {r3 - r10}
+	stmia	r1!, {r3 - r10}
+	cmp	r0,  r2
+	ble	self_move
+	ldr	pc, _real_start
+
+real_start:
+	ldr	r0, _bss_start
+	ldr	r1, _bss_end
+	mov	r2, #0x00000000
+
+clear_bss_loop:
+	str	r2, [r0]
+	cmp	r0, r1
+	add	r0, r0, #4
+	bne	clear_bss_loop
+
+	ldr	r4, =_lr
+	str	lr, [r4]
+	pop	{r0 - r10}
+
+	ldr	lr, =_sp
+	str	sp, [lr]
+	ldr	sp, _STACK_POINT
+
+	bl	ddr_training_cmd_entry
+
+	ldr	lr, =_sp
+	ldr	sp, [lr]
+
+	ldr	lr, =_lr
+	ldr	pc, [lr]
+
+.section .data
+_lr:	.word 0
+_sp:	.word 0
diff -uraN u-boot-2016.11/drivers/ddr/goke/default/cmd_bin/ddr_cmd_32.lds gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/cmd_bin/ddr_cmd_32.lds
--- u-boot-2016.11/drivers/ddr/goke/default/cmd_bin/ddr_cmd_32.lds	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/cmd_bin/ddr_cmd_32.lds	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,28 @@
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text	: {
+		cmd_entry_32.o (.text)
+		*(.text)
+		}
+
+	. = ALIGN(4);
+	.rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -uraN u-boot-2016.11/drivers/ddr/goke/default/cmd_bin/ddr_cmd.bin gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/cmd_bin/ddr_cmd.bin
--- u-boot-2016.11/drivers/ddr/goke/default/cmd_bin/ddr_cmd.bin	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/cmd_bin/ddr_cmd.bin	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,84 @@
+-            , OOt  B(( @ B< P  
+D <0 C  PP\ \     P $@  c    OO0     /  @   P   /@-   P@- @4  	 P0 7 A q/p@-p@pP f _KDOD   b  ^    \    W (@ U  Q $ p@N O@-$@$ F   C $ @? O// -H1s@- 0P S)   `[ @D Q    ] [  `] 00    P   p@/   | % P  
+k@P0@X S  
+x S   g0    mY WO|NNNNNNN/0@-t  ^0`@	-P0\ S4 <@,# G?0 0   R  A/ 0@ dP E$  !"! ^   !   !0  | | /P0@-  @D D0  R   8 \   0(  0  \  P  @P@UDzI//p@-pP @H`<! 08H   Q)  
+   Q+  
+   Q  
+ Q$  
+ P   Q'  
+ Q p@ Q&  
+  @ Q   
+ Q p@ Q  
+Q p@{  &	  P   P p p@	 p@l p  Pl  p@  p@  p@ @ ?  	  P y   P 6 'ND P<NC  7M- @  M0HP0' 0 7  '| t7t'  \d \7\'  <X O   	 P0W)   P
+  X0< T 2,  S   0 S)  X 	 6  0 0$06$  0 R *02<00?C0000 0,03       Q	-  <0
+a4,`@b `<b`8b
+S  X Y S  X K S   X d 0< 00(0  
+,00,00	=000	=000, 2 R:$00$00=00,0% 0$0[0xux@080A=0040  4  00(`_C@ 00V  :0` P$u0  S  
+ 0 0 8P
+ U80#nt P50` Z  0 `p U  0!n `p U  0 `lp U  0l `Lp U  X4 ` U  0o< `p U  0	} `p U  Jo  % 0#H`  @0# 040  80 `   0p U  '~X ` U  u_|cM   0l#(S      (0 	 0 @(00(0 S80P      !  1 00`V   0 !  Pg   0 A 
+ `d   1
+ p	 0 0D0`    D0  p 
+  pR   0 A 
+ f`O   0 A 
+ [`L   0 pA 
+ P`G   1
+ p	 0 C0D0` v   D0  p 
+  45 h  0 A 
+ *`2 ]  0 A 
+ `G S  0 pA 
+ `B 0  S@   
+   
+  PPODL .L ZL P<RpLDLlDLLLL	M MCM[MwMMMMMMMN` @T0P % P     /30" 2  R R R, S$ S( S< /  /  /0@  Q   /  0 S   /p0  S   
+^	 @ A- PH0 @``0<p0H0\0   R   5#dP P0 0D L0 `@-00 @0 ,  0  4  8 0x   S000h y80` T 0T0000 0H0n40@ ( 0400,0 0(0c  lK!DK  K  0<00 0,000/ 3 0S  3 0S  /    P07@- S  @  `0@T 3003` @ T  3@P0l 0T0d!%0D Q@010@ T'>3@ ?0T0'3 @0 @0   @ T'>3@ ?0T0'3 @0 @0   @010@ T'>3@ ?0T0'38 @0 @0   D ~.F]O  A-` @Pp!@00  S  U  
+,0 UZZ@0 wL vJ@   M- `Q@@00P    0 p `8!8
+000)  
+\0<  00 S    Z  
+   0 P(#0 0 02P0  
+ u  z0     P P0P 0   0  S
+0 `P 008 _0   u   SJEFJD,JYJ@-H 0   
+ 0`     ? ;DK\0M-`<Pc#  @p X  
+ \ 0` 100H0  P   m A- @ P`<p<0 S   \@ @0@0 `  /7@-<0\ P@#!  0 Sd0t   !1d 00011 0H01@ ,  040`0 SD `00`00  xDNNp0'7p p00)9 0O/A-@D`dp@PR (00p000000"  
+   R   a0 0(008p00040\0,100`040 OR  
+R A,0 00  p@- DP@@  50 (00p0,0  d000(0,040`0p Op  @- T`0X P5@  ^@0   T!>? ! @"  | T?">-T`0PX  ^50	   \!>?@!  0   \?">` @0p@-? @T 5PM `#  #T`0@ #%  " " P Px x X` `   VT`0@ #%  " " P   pJDJP0A- S @PT @0`!  ?csWppA\0< C#0 S  h d @0T ?@ A0h`0 `?5TSHTEP    P/@-   JD0s@- S @0P    `Pv00 &h P(`  0$   0 @  0< 0pP  00     DKD@-x  @  !  @@- ``Pp U P  D0P `0P   S$ S2  P 0]D0R! @P0S20C60200 W     80  C00 0000000p0t t  0 0l0;O00\< d0##`00000 00 00IE  3mmmmUUI!E  31@-  O A    \   0   =     \
+ P'  
+%   r  
+ 13 R0B1"!x 1!3      q 
+ 1340!1 r        3@B I/E` 3l0p@- S  d0 @TP  p`0 UPE 0 X   P  L0
+00X      `p S  
+    p  p  3DHEM- `(P@J @1  X	  
+ X  
+ Xp p  P   @  P	      P  
+p
+ T V
+   
+ P0   `
+pM- PT8M @p Q1P 0 0 XP00T0X`a$  ,     PL  
+8  0  0"0 @,0 <"004E,0 s9  ! 01 0 0 "50 0a& Xi    [PE  
+  Xc  0! 0
+0"$ 0
+ @@ OP UP0 S  0`!@0?5#@ 5  8,8 0  " @W0  Q
+  A 0 %  P
+00000, 8 0 " @B4~ Q
+   4x   P
+400C40 n004  @(! (`  P 00T 8 v`  S000 1 gHEHHEHp@- 0 1PP0 @ S2  `0  S R 1^ , pM-M p0P0 S2  `0  S0 X `P@1@! X  :  P0P 0T0 @  z
+ [  ` V   
+@ `0P:OHFA- @P `@0 RT?'>` S 5 ?P ST0P$  U E    P0  0T0 p  B X  *0  P0t 0T0 P  X 2 A   0P0 S20  `0  S00 U*;FNN[FOM-M @PT  Q@0  
+ Q   ? cV`P 000
+ S  `?5cVdPp  W  7 P  H Ppp0p S S"  T0<!<M@ P @p@  @p`p@ T0/#pR   @   7 X0H X00P0 S	   [P PEU	  : PT0    [PE P U ( h T0  7  P  
+  /T04  ` 00GbE=E]GGGGA-` @? PP  `0  0D00d00@0 0\0}h0  S  
+p\<0d 0#00 U  :  T 7 P 
+  H P   P0   0T0[   <PGE<GvEE- ` @pP<\0d 2#00 S    U  
+P0X  PT  0@08   T  ` P IE`00@-GM @ 0D00d00@0 0\0d 0A/P0  R 0A/P0  P H  0    G0*IE0@-<M @  P P  ( $  s0 h0l0 P S <0\0< p@- @#@P`S 0"  S    p@`#`#0 M-@M@PtpH`0  W  V 0 p^  
+\0< @# 0@0   `0  S N  
+ @0 ^U  \0< C#0 S  d 2d0dH0H0 p 
+0
+H0 p H p  p  p  010010 p  p 010 p  00 p  p ~ K\ B(@ / Q
+ 0`#@TT < "$rD0M$pPt( HM PP,   L $0 RP  RR,0  $ p 4   ( R 8 $    X00 R !X0 SLH0pG @0Ct p,040C8L|P0r0CL00C 000C H$0 00($2<0T  DE 2 peM- @MX ` <0 S  X  \   0P(p@0tp0 S$   PP
+ U\0)   U  < `C#4p P0 ZU  `@ \0<P   p0 S_   0 t00<`00b#  0G < @`P!  PH  @   !@ ` H000H00 Z 00\0"  C(@0?  \   U    P   Q@ ^TP0\   Q// A@   `0P` 00R#0  FI`0E-]M @"0PD00d00@00\0 0P0+`0@ d?0\< d ! "!0     Q.  A/ l SP0 S `p<=  
+\0< `C# D0`0q0B0s   R `Wup<\0d 2#00 S,   W T   0 S  
+l {`P  0 \||x< T   R  
+l a`\0d 2#00 S p`<\0d 2#00 S  `0 @ <\ d0#"   Q  :l  ] lT  +p `P 0P R3  0" " "<  "" `}OhF0@-<M @$P w lP )  P P  PP 1 P   P  0 P0' P  <0@-  Z  OzF@-  Q  IF@-  H  FF@-  ?  kJF@-  6  `IF@-  -  JF0@- @@ <M [  	  
+@0   0 @ L  P  P  P  
+   P  & : $ P q0 h0 P0 ,   P i  <0,KC<NC0@-|M    |  p  
+l   P R pP @  @	  w |0(  p @       @-    JC-|M , |@-    ZNCddr_mpr_training_func ddr_training_console ddr_training_boot_func ddr_pcode_training_func ddr_mpr_training_func ddr_training_cfg_set_dmc ddr_training_cfg_set_rank ddr_training_check_bypass ddr_ddrt_get_test_addr dump_result ddr_training_switch_axi ddr_training_easr dump_result_by_rank ddr_phy_get_byte_num ddr_training_cmd_func ddr_rdqs_sync_rank_rdq ddr_training_cmd_entry ddr_get_rank_size ddr_ddrt_init ddr_ddrt_test ddr_adjust_trend_check ddr_rdqs_sync ddr_adjust_move_win ddr_adjust_byte ddr_adjust_dataeye ddr_dataeye_check_dq ddr_dataeye_find_dq ddr_dataeye_deskew ddr_dataeye_process ddr_dataeye_training ddr_hw_training_process ddr_hw_training_by_rank ddr_vref_set ddr_vref_get ddr_vref_find_best ddr_vref_cal ddr_vref_training ddr_wl_func ddr_gating_func ddr_ac_training_func ddr_lpca_training_func ddr_dcc_training_func ddr_pcode_training Not support DDR AC training. DDR dataeye adjust PHY[%x][%x] DMC[%x][%x] Rank[%x] Byte[%x] mode[%x] win on middle. byte[%x] bdl[%x] middle[%x] accel[%x] rdqs[%x] Move byte[%x] window to middle suc Byte[%x] deskew fail, restore[%x] Move byte[%x] to middle fail. value[%x] Byte[%x] mode[%x] set value[%x] Rank number[%x] not need sync another rank DDR dataeye dq check type not set. DQ[%x] def[%x] nok, find new value[%x] DQ[%x] not found dq. restore[%x] DQ[%x] range: left[%x] right[%x] best[%x] mode[%x] rank[%x] Byte[%x] DQ[%x] no win. PHY[%x] mode[%x] dataeye training fail DDR dataeye training PHY[%x][%x] DMC[%x][%x] Rank[%x] Not support DCC training. DDRT test address[%x] out of range[%x, %x] rank size[%x] DDRT ADDR[%x = %x] DDRT wait timeout. Not support DDR gate training. PHY[%x][%x] Rank[%x] itme[%x] base_phy[%x] itme[%x] Phy[%x] hw[%x] failed[%x] SREF wait timeout. HWR wait timeout. Not support LPDDR CA training. Not support DDR pcode training. get byte num fail Before sync rank[%x] byte[%x] dq[%x = %x][%x = %x] offset[%x] After sync rank[%x] byte[%x] dq[%x = %x][%x = %x] PHY[%x] hw gating fail. phy[0] total_byte_num[%x] dram_type[%x] Rank number PHY0 [%x] HW training item PHY0[%x = %x][%x = %x] SW training item Rank0[%x = %x] Rank1[%x = %x] DDR training [%x] is disable, rank[%x] cfg[%x] DDR Training Version: V2.1.6 20181228 DDR training command entry. Sysctl[%x = %x] Rank1 Sysctl[%x = %x] PHY[%x] RANK[%x]: Byte[%x] Write[%x][%x] Read[%x][%x] CA[%x] Range[%x] [%x = %x] WDQS Byte(%x)  [%x = %x] WDQ Phase Byte(%x) [%x = %x] WDQ BDL DQ(%x-%x) [%x = %x] WDM Byte(%x) [%x = %x] Write DQ/DQS OE Byte(%x) [%x = %x] RDQS Byte(%x) [%x = %x] RDQ BDL DQ(%x-%x) [%x = %x] Gate Byte(%x) [%x = %x] CS [%x = %x] CLK [%x = %x] Host Vref Byte(%x) [%x = %x] DRAM Vref Byte(%x) [%x = %x] CA Phase [%x = %x] ACADDRBDL(%x) DDR training result[%x] DDR training cmd[%x] Not support DDR MPR training. Not support DDR training console. INFO DEBUG WARNING ERROR FATAL 0x 
+ AXI region0[%x = %x] AXI region1[%x = %x] byte[%x] mode[%x] get vref [%x] byte[%x] default vref[%x] win[%x][%x] mode[%x] byte[%x] best vref[%x] mode[%x] byte[%x] vref[%x] win[%x] mode[%x] byte[%x] mode[%x] set vref [%x] DDR Vref[%x] training PHY[%x][%x] DMC[%x][%x] Rank[%x] Not support DDR WL training.            
\ No newline at end of file
diff -uraN u-boot-2016.11/drivers/ddr/goke/default/cmd_bin/ddr_training_cmd.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/cmd_bin/ddr_training_cmd.c
--- u-boot-2016.11/drivers/ddr/goke/default/cmd_bin/ddr_training_cmd.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/cmd_bin/ddr_training_cmd.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,490 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <stdarg.h>
+#include <command.h>
+#include "ddr_interface.h"
+#include "ddr_training_impl.h"
+
+/* ddr training cmd result */
+struct ddr_training_result_st ddrt_result_sram;
+static unsigned int ddr_training_addr_start;
+static unsigned int ddr_training_addr_end;
+static int ddr_print_level = DDR_LOG_ERROR;
+
+#ifdef DDR_TRAINING_LOG_CONFIG
+
+/* Log ddr training info. */
+void ddr_training_log(const char *func, int level, const char *fmt, ...)
+{
+	va_list args;
+
+	if (ddr_print_level > level)
+		return;
+
+	DDR_PUTC('[');
+	switch (level) {
+	case DDR_LOG_INFO:
+		DDR_PUTS("INFO");
+		break;
+	case DDR_LOG_DEBUG:
+		DDR_PUTS("DEBUG");
+		break;
+	case DDR_LOG_WARNING:
+		DDR_PUTS("WARNING");
+		break;
+	case DDR_LOG_ERROR:
+		DDR_PUTS("ERROR");
+		break;
+	case DDR_LOG_FATAL:
+		DDR_PUTS("FATAL");
+		break;
+	default:
+		break;
+	}
+	DDR_PUTC(']');
+	DDR_PUTC('[');
+	DDR_PUTS(func);
+	DDR_PUTC(']');
+
+	va_start(args, fmt);
+	while (*fmt != '\0') {
+		if (*fmt != '%') {
+			DDR_PUTC(*fmt);
+		} else {
+			fmt++;
+			switch (*fmt) {
+			case 'x':
+			case 'X':
+				DDR_PUTS("0x");
+				DDR_PUT_HEX(va_arg(args, int));
+				break;
+			default:
+				DDR_PUTC('%');
+				DDR_PUTC(*fmt);
+				break;
+			} /* switch */
+		}
+		fmt++;
+	} /* while */
+	va_end(args);
+	DDR_PUTS("\r\n");
+}
+
+/* Nothing to do in DDR command when defined DDR_TRAINING_LOG_CONFIG. */
+void ddr_training_error(unsigned int mask, unsigned int phy, int byte, int dq)
+{
+	return;
+}
+#else
+/* Display DDR training error. */
+void ddr_training_error(unsigned int mask, unsigned int phy, int byte, int dq)
+{
+	switch (mask) {
+	case DDR_ERR_WL:
+		DDR_PUTS("WL");
+		break;
+	case DDR_ERR_HW_GATING:
+		DDR_PUTS("HW Gate");
+		break;
+	case DDR_ERR_GATING:
+		DDR_PUTS("Gate");
+		break;
+	case DDR_ERR_DDRT_TIME_OUT:
+		DDR_PUTS("DDRT");
+		break;
+	case DDR_ERR_HW_RD_DATAEYE:
+		DDR_PUTS("HW Dataeye");
+		break;
+	case DDR_ERR_MPR:
+		DDR_PUTS("MPR");
+		break;
+	case DDR_ERR_DATAEYE:
+		DDR_PUTS("Dataeye");
+		break;
+	case DDR_ERR_LPCA:
+		DDR_PUTS("LPCA");
+		break;
+	default:
+		break;
+	}
+
+	DDR_PUTS(" Err:");
+
+	if (phy != 0) {
+		DDR_PUTS(" Phy:");
+		DDR_PUT_HEX(phy);
+	}
+
+	if (byte != -1) {
+		DDR_PUTS(" Byte:");
+		DDR_PUT_HEX(byte);
+	}
+
+	if (dq != -1) {
+		DDR_PUTS(" DQ:");
+		DDR_PUT_HEX(dq);
+	}
+
+	DDR_PUTS("\r\n");
+}
+#endif
+
+/* Inint ddr training cmd result */
+static void ddr_training_result_init(struct ddr_cfg_st *cfg, struct ddr_training_result_st *ddrtr_res)
+{
+	int i, j;
+
+	ddrtr_memset(ddrtr_res, 0, sizeof(struct ddr_training_result_st));
+	ddrtr_res->phy_num = cfg->phy_num;
+	for (i = 0; i < cfg->phy_num; i++) {
+		ddrtr_res->phy_st[i].rank_num = cfg->phy[i].rank_num;
+
+		for (j = 0; j < cfg->phy[i].rank_num; j++) {
+			ddrtr_res->phy_st[i].rank_st[j].item = cfg->phy[i].rank[j].item;
+			ddrtr_res->phy_st[i].rank_st[j].ddrtr_data.base_phy = cfg->phy[i].addr;
+			ddrtr_res->phy_st[i].rank_st[j].ddrtr_data.byte_num = cfg->phy[i].total_byte_num;
+			ddrtr_res->phy_st[i].rank_st[j].ddrtr_data.rank_idx = j;
+		}
+	}
+}
+
+/* Save ddr training cmd result */
+void ddr_result_data_save(struct ddr_cfg_st *cfg, struct training_data *training)
+{
+	unsigned int i;
+	unsigned int offset;
+	struct training_data *dest = NULL;
+	struct ddr_training_result_st *ddrtr_res = (struct ddr_training_result_st *)cfg->res_st;
+
+	if (!ddrtr_res)
+		return;
+
+	if (cfg->cur_mode == DDR_MODE_READ)
+		dest = &ddrtr_res->phy_st[cfg->phy_idx].rank_st[cfg->rank_idx].ddrtr_data.read;
+	else
+		dest = &ddrtr_res->phy_st[cfg->phy_idx].rank_st[cfg->rank_idx].ddrtr_data.write;
+
+	if (cfg->phy[cfg->phy_idx].dmc_num == 1)
+		ddrtr_memcpy(dest, training, sizeof(struct training_data));
+	else {
+		/* dmc[0] + dmc[1] */
+		offset = cfg->dmc_idx << 4;
+		for (i = 0; i < GET_BYTE_NUM(cfg) << 3; i++) {
+			dest->ddr_bit_result[i + offset] = training->ddr_bit_result[i + offset];
+			dest->ddr_bit_best[i + offset]   = training->ddr_bit_best[i + offset];
+		}
+		dest->ddr_win_sum  += training->ddr_win_sum;
+	}
+}
+
+/* Save lpca training data */
+void ddr_lpca_data_save(struct ca_data_st *data)
+{
+
+#if 0
+	unsigned int index;
+	struct ddr_training_result_st *result_st
+		= (struct ddr_training_result_st *)ddrtr_result;
+	struct ddr_training_data_st *tr_data;
+
+	for (index = 0; index < DDR_SUPPORT_PHY_MAX; index++) {
+		if (result_st->ddrtr_data[index].base_phy == data->base_phy)
+			break;
+	}
+
+	tr_data = &result_st->ddrtr_data[index];
+
+	for (index = 0; index < DDR_PHY_CA_MAX; index++)
+		tr_data->ca_addr[index] = (data->left[index]
+			<< DDR_DATAEYE_RESULT_BIT) | data->right[index];
+#endif
+
+}
+
+/* Get DDRT test addrress */
+unsigned int ddr_ddrt_get_test_addr(void)
+{
+	if (ddr_training_addr_start <= DDRT_CFG_TEST_ADDR_CMD
+	&&	ddr_training_addr_end >= DDRT_CFG_TEST_ADDR_CMD) {
+		return DDRT_CFG_TEST_ADDR_CMD;
+	} else {
+		DDR_ERROR("DDRT test address[%x] out of range[%x, %x]",
+			  DDRT_CFG_TEST_ADDR_CMD,
+			  ddr_training_addr_start,
+			  ddr_training_addr_end);
+		return ddr_training_addr_start;
+	}
+}
+
+/* Nothing to do in DDR command */
+void ddr_training_suc(void) { return; }
+
+/* Nothing to do in DDR command */
+void ddr_training_start(void) { return; }
+
+static void dump_result(struct ddr_training_data_st *ddrtr_data)
+{
+	unsigned int i;
+	unsigned int base_phy = ddrtr_data->base_phy;
+	unsigned int byte_num = ddrtr_data->byte_num;
+	unsigned int rank = ddrtr_data->rank_idx;
+	unsigned int ACPHYCTL7;
+
+	/* Static register have to read two times to get the right value. */
+	ACPHYCTL7 = ddr_read(base_phy + DDR_PHY_ACPHYCTL7);
+	ACPHYCTL7 = ddr_read(base_phy + DDR_PHY_ACPHYCTL7);
+
+	for (i = 0; i < ddrtr_data->byte_num << 3; i++) {
+		DDR_INFO("Byte[%x] Write[%x][%x] Read[%x][%x]",
+			 i, ddrtr_data->write.ddr_bit_result[i], ddrtr_data->write.ddr_bit_best[i],
+			 ddrtr_data->read.ddr_bit_result[i], ddrtr_data->read.ddr_bit_best[i]);
+	}
+
+	for (i = 0; i < DDR_PHY_CA_MAX; i++) {
+		if (ddrtr_data->ca_addr[i] != 0)
+			DDR_INFO("CA[%x] Range[%x]", i, ddrtr_data->ca_addr[i]);
+	}
+
+	/* WDQS */
+	for (i = 0; i < byte_num; i++) {
+		DDR_INFO("[%x = %x] WDQS Byte(%x) ",
+			 base_phy + DDR_PHY_DXWDQSDLY(rank, i),
+			 ddr_read(base_phy + DDR_PHY_DXWDQSDLY(rank, i)), i);
+	}
+
+	/* WDQ Phase */
+	for (i = 0; i < byte_num; i++) {
+		DDR_INFO("[%x = %x] WDQ Phase Byte(%x)",
+			 base_phy + DDR_PHY_DXNWDQDLY(rank, i),
+			 ddr_read(base_phy + DDR_PHY_DXNWDQDLY(rank, i)), i);
+	}
+
+	/* WDQ BDL */
+	for (i = 0; i < byte_num; i++) {
+		/* DQ0-DQ3 */
+		DDR_INFO("[%x = %x] WDQ BDL DQ(%x-%x)",
+			 base_phy + DDR_PHY_DXNWDQNBDL0(rank, i),
+			 ddr_read(base_phy + DDR_PHY_DXNWDQNBDL0(rank, i)),
+			 (i << 3), ((i << 3) + 3));
+
+		/* DQ4-DQ7 */
+		DDR_INFO("[%x = %x] WDQ BDL DQ(%x-%x)",
+			 base_phy + DDR_PHY_DXNWDQNBDL1(rank, i),
+			 ddr_read(base_phy + DDR_PHY_DXNWDQNBDL1(rank, i)),
+			 ((i << 3) + 4), ((i << 3) + 7));
+	}
+
+	/* WDM */
+	for (i = 0; i < byte_num; i++) {
+		DDR_INFO("[%x = %x] WDM Byte(%x)",
+			 base_phy + DDR_PHY_DXNWDQNBDL2(rank, i),
+			 ddr_read(base_phy + DDR_PHY_DXNWDQNBDL2(rank, i)), i);
+	}
+
+	/* Write DO/DOS OE */
+	for (i = 0; i < byte_num; i++) {
+		DDR_INFO("[%x = %x] Write DQ/DQS OE Byte(%x)",
+			 base_phy + DDR_PHY_DXNOEBDL(rank, i),
+			 ddr_read(base_phy + DDR_PHY_DXNOEBDL(rank, i)), i);
+	}
+
+	/* RDQS */
+	for (i = 0; i < byte_num; i++) {
+		DDR_INFO("[%x = %x] RDQS Byte(%x)",
+			 base_phy + DDR_PHY_DXNRDQSDLY(i),
+			 ddr_read(base_phy + DDR_PHY_DXNRDQSDLY(i)), i);
+	}
+
+	/* RDQ BDL */
+	for (i = 0; i < byte_num; i++) {
+		/* DQ0-DQ3 */
+		DDR_INFO("[%x = %x] RDQ BDL DQ(%x-%x)",
+			 base_phy + DDR_PHY_DXNRDQNBDL0(rank, i),
+			 ddr_read(base_phy + DDR_PHY_DXNRDQNBDL0(rank, i)),
+			 (i << 3), ((i << 3) + 3));
+
+		/* DQ4-DQ7 */
+		DDR_INFO("[%x = %x] RDQ BDL DQ(%x-%x)",
+			 base_phy + DDR_PHY_DXNRDQNBDL1(rank, i),
+			 ddr_read(base_phy + DDR_PHY_DXNRDQNBDL1(rank, i)),
+			 ((i << 3) + 4), ((i << 3) + 7));
+	}
+
+	/* Gate */
+	for (i = 0; i < byte_num; i++) {
+		DDR_INFO("[%x = %x] Gate Byte(%x)",
+			 base_phy + DDR_PHY_DXNRDQSGDLY(rank, i),
+			 ddr_read(base_phy + DDR_PHY_DXNRDQSGDLY(rank, i)), i);
+	}
+
+	DDR_INFO("[%x = %x] CS",
+		 base_phy + DDR_PHY_ACCMDBDL2,
+		 ddr_read(base_phy + DDR_PHY_ACCMDBDL2));
+
+	DDR_INFO("[%x = %x] CLK",
+		 base_phy + DDR_PHY_ACPHYCTL7, ACPHYCTL7);
+
+	DDR_PHY_SWITCH_RANK(base_phy, rank);
+
+	/* HOST Vref */
+	DDR_PHY_VREF_HOST_DISPLAY_CMD(base_phy, rank, byte_num);
+
+	/* DRAM Vref */
+	DDR_PHY_VREF_DRAM_DISPLAY_CMD(base_phy, byte_num);
+
+	/* Addr Phase */
+	DDR_PHY_ADDRPH_DISPLAY_CMD(base_phy);
+
+	/* Addr BDL */
+	DDR_PHY_ADDRBDL_DISPLAY_CMD(base_phy);
+
+	/* DCC */
+	DDR_PHY_DCC_DISPLAY_CMD(base_phy);
+}
+
+static void dump_result_by_rank(struct ddr_training_result_st *ddrtr_result,
+				unsigned int phy_index, unsigned int rank_index)
+{
+	unsigned int mask = 1 << phy_index; /* DDR_BYPASS_PHY0_MASK DDR_BYPASS_PHY1_MASK */
+	struct rank_data_st *rank_st = &ddrtr_result->phy_st[phy_index].rank_st[rank_index];
+
+	if (rank_st->item & mask)
+		return;
+
+	DDR_INFO("PHY[%x] RANK[%x]:", phy_index, rank_index);
+	dump_result(&rank_st->ddrtr_data);
+}
+
+static void dump_result_by_phy(struct ddr_training_result_st *ddrtr_result,
+			       unsigned int phy_index)
+{
+	int i;
+	struct phy_data_st *phy_st = &ddrtr_result->phy_st[phy_index];
+
+	for (i = 0; i < phy_st->rank_num; i++) {
+		dump_result_by_rank(ddrtr_result, phy_index, i);
+	}
+}
+
+/* Display ddr training result before return to DDR */
+static void dump_result_all(struct ddr_training_result_st *ddrtr_result)
+{
+	int i;
+	for (i = 0; i < ddrtr_result->phy_num; i++) {
+		dump_result_by_phy(ddrtr_result, i);
+	}
+}
+
+int ddr_training_cmd_func(struct ddr_cfg_st *cfg)
+{
+	int result = 0;
+	struct ddr_cmd_st *cmd_st = (struct ddr_cmd_st *)cfg->cmd_st;
+	unsigned int item = cfg->cur_item;
+
+	DDR_DEBUG("DDR training cmd[%x]", cmd_st->cmd);
+
+	switch (cmd_st->cmd) {
+	case DDR_TRAINING_CMD_SW:
+		/* todo */
+		result = ddr_dataeye_training_func(cfg);
+		result += ddr_vref_training_func(cfg);
+		break;
+	case DDR_TRAINING_CMD_DATAEYE:
+		result = ddr_dataeye_training_func(cfg);
+		break;
+	case DDR_TRAINING_CMD_HW:
+		result = ddr_hw_training_if();
+		break;
+	case DDR_TRAINING_CMD_MPR:
+		result = ddr_mpr_training_func(cfg);
+		break;
+	case DDR_TRAINING_CMD_WL:
+		result = ddr_wl_func(cfg);
+		break;
+	case DDR_TRAINING_CMD_GATE:
+		result = ddr_gating_func(cfg);
+		break;
+	case DDR_TRAINING_CMD_VREF:
+		result = ddr_vref_training_func(cfg);
+		break;
+	case DDR_TRAINING_CMD_AC:
+		result = ddr_ac_training_func(cfg);
+		break;
+	case DDR_TRAINING_CMD_LPCA:
+		result = ddr_lpca_training_func(cfg);
+		break;
+	case DDR_TRAINING_CMD_SW_NO_WL:
+		/* wl bypass */
+		ddr_write(item | DDR_BYPASS_WL_MASK,
+			  DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_CFG);
+		result = ddr_dataeye_training_func(cfg);
+		result += ddr_vref_training_func(cfg);
+		/* restore cfg */
+		ddr_write(item,
+			  DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_CFG);
+		break;
+	case DDR_TRAINING_CMD_CONSOLE:
+		result = ddr_training_console_if((void *)&ddrt_result_sram);
+		break;
+	default:
+		result = -1;
+		break;
+	}
+
+	return result;
+}
+
+/* DDR training command entry. Call by cmd_ddr_handle(). */
+struct ddr_training_result_st *ddr_training_cmd_entry(
+		struct ddr_cmd_st *cmd_st)
+{
+	int result = 0;
+
+	struct ddr_cfg_st ddr_cfg;
+	struct ddr_cfg_st *cfg = &ddr_cfg;
+	struct ddr_cmd_st cmd_in_sram;
+
+	ddr_training_addr_start = cmd_st->start;
+	ddr_training_addr_end   = cmd_st->start + cmd_st->length;
+	ddr_print_level         = cmd_st->level;
+
+	DDR_INFO("DDR Training Version: "DDR_TRAINING_VER);
+	DDR_DEBUG("DDR training command entry. Sysctl[%x = %x]",
+		(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_CFG),
+		ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_CFG));
+
+#ifdef SYSCTRL_DDR_TRAINING_CFG_SEC
+	DDR_DEBUG("Rank1 Sysctl[%x = %x]",
+		(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_CFG_SEC),
+		ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_CFG_SEC));
+#endif
+
+	ddr_training_cfg_init(cfg);
+	ddrtr_memcpy(&cmd_in_sram, cmd_st, sizeof(struct ddr_cmd_st));
+	cfg->cmd_st = (void *)&cmd_in_sram;
+	cfg->res_st = (void *)&ddrt_result_sram;
+
+	ddr_training_result_init(cfg, &ddrt_result_sram);
+
+	if (cmd_st->cmd == DDR_TRAINING_CMD_HW)
+		result = ddr_hw_training(cfg);
+	else if (cmd_st->cmd == DDR_TRAINING_CMD_PCODE)
+		result = ddr_pcode_training(cfg);
+	else if (cmd_st->cmd == DDR_TRAINING_CMD_DCC)
+		result = ddr_dcc_training_func(cfg);
+	else if (cmd_st->cmd == DDR_TRAINING_CMD_CONSOLE)
+		result = ddr_training_console_if((void *)&ddrt_result_sram);
+	else
+		result = ddr_training_all(cfg);
+
+	dump_result_all(&ddrt_result_sram);
+
+	if (!result) {
+		return &ddrt_result_sram;
+	} else {
+		DDR_DEBUG("DDR training result[%x]", result);
+		return 0;
+	}
+}
diff -uraN u-boot-2016.11/drivers/ddr/goke/default/cmd_bin/ddr_training_uart.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/cmd_bin/ddr_training_uart.c
--- u-boot-2016.11/drivers/ddr/goke/default/cmd_bin/ddr_training_uart.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/cmd_bin/ddr_training_uart.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "ddr_training_custom.h"
+
+#define UART_PL01x_DR				   0x00	 /*  Data read or written from the interface. */
+#define UART_PL01x_FR				   0x18	 /*  Flag register (Read only). */
+#define UART_PL01x_FR_TXFF			  0x20
+
+#define IO_WRITE(addr, val) (*(volatile unsigned int *)(addr) = (val))
+#define IO_READ(addr) (*(volatile unsigned int *)(addr))
+
+void uart_early_putc(const char c)
+{
+	/* Wait until there is space in the FIFO */
+	while (IO_READ (DDR_REG_BASE_UART0 + UART_PL01x_FR) & UART_PL01x_FR_TXFF);
+
+	/* Send the character */
+	IO_WRITE (DDR_REG_BASE_UART0 + UART_PL01x_DR, c);
+}
+
+void uart_early_puts(const char *s)
+{
+	while (*s)
+		uart_early_putc (*s++);
+}
+
+void uart_early_put_hex(const unsigned int hex)
+{
+	int i;
+	char c;
+
+	for (i = 28; i >= 0; i -= 4) {
+		c = (hex >> (unsigned int)i) & 0x0F;
+		if (c < 10)
+			c += '0';
+		else
+			c += 'A' - 10;
+		uart_early_putc(c);
+	}
+}
diff -uraN u-boot-2016.11/drivers/ddr/goke/default/cmd_bin/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/cmd_bin/Makefile
--- u-boot-2016.11/drivers/ddr/goke/default/cmd_bin/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/cmd_bin/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,60 @@
+sinclude $(TOPDIR)/arch/arm/cpu/$(CPU)/config.mk       # include architecture dependend rules
+################################################################################
+
+PWD      := $(shell pwd)
+OPPDIR   := $(subst $(TOPDIR),,$(PWD))
+
+CC       := $(CROSS_COMPILE)gcc
+AR       := $(CROSS_COMPILE)ar
+LD       := $(CROSS_COMPILE)ld
+OBJCOPY  := $(CROSS_COMPILE)objcopy
+OBJDUMP  := $(CROSS_COMPILE)objdump
+
+
+################################################################################
+DDR_CMD     := ddr_cmd
+
+CMD_TEXT_BASE := $(shell grep '^\#define.*DDR_TRAINING_RUN_STACK' $(TOPDIR)/drivers/ddr/goke/$(SOC)/ddr_training_custom.h|awk '{print $$3}')
+STACK_POINT   := $(CMD_TEXT_BASE)
+
+COBJS       := ddr_training_uart.o ddr_training_custom.o ddr_training_cmd.o ddr_training_impl.o ddr_training_ctl.o ddr_training_console.o
+DEPS        := $(COBJS:.o=.d) $(START:.o=.d)
+
+CFLAGS   := -Os -pipe  \
+	-DCMD_TEXT_BASE=$(CMD_TEXT_BASE) -DSTACK_POINT=$(STACK_POINT) \
+	-fno-builtin -ffreestanding -I./ -I$(TOPDIR)/../../../source/bootloader/u-boot/include -I../ \
+	-DDDR_TRAINING_CMD -I$(TOPDIR)/drivers/ddr/goke/$(SOC)/
+
+CFLAGS += $(PLATFORM_RELFLAGS) $(PLATFORM_CPPFLAGS)
+
+START       := cmd_entry_32.o
+LDS_SCRIPT  := ddr_cmd_32.lds
+################################################################################
+
+.PHONY: $(DDR_CMD).bin
+all: $(DDR_CMD).bin
+
+$(DDR_CMD).bin: $(DDR_CMD).elf
+	$(OBJCOPY) -O srec $(PWD)/$(DDR_CMD).elf $(DDR_CMD).srec
+	$(OBJCOPY) --gap-fill=0xff -O binary $(PWD)/$(DDR_CMD).elf $@
+
+$(DDR_CMD).elf: $(START) $(COBJS) $(LDS_SCRIPT)
+	$(LD) -Bstatic -T $(LDS_SCRIPT) -Ttext $(CMD_TEXT_BASE) $(START) \
+		$(COBJS) -Map $(DDR_CMD).map -o $@
+
+%.o : %.S
+	$(CC) -D__ASSEMBLY__ $(CFLAGS) -o $@ -c $*.S
+
+%.o : %.c
+	$(CC) $(CFLAGS) -Wall -Wstrict-prototypes -fno-stack-protector \
+		-o $@ -c $*.c
+
+ifneq ("$(MAKECMDGOALS)","clean")
+sinclude $(DEPS)
+endif
+
+%.d : %.c
+	set -e; $(CC) $(CFLAGS) -MM $< | sed 's,$*.o:,$*.o $*.d:,g' > $@
+
+%.d : %.S
+	set -e; $(CC) $(CFLAGS) -MM $< | sed 's,$*.o:,$*.o $*.d:,g' > $@
diff -uraN u-boot-2016.11/drivers/ddr/goke/default/cmd_ddr_training_v2.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/cmd_ddr_training_v2.c
--- u-boot-2016.11/drivers/ddr/goke/default/cmd_ddr_training_v2.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/cmd_ddr_training_v2.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,286 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <common.h>
+#include <command.h>
+#include "ddr_interface.h"
+
+#ifndef TEXT_BASE
+#define TEXT_BASE (CONFIG_SYS_TEXT_BASE) /* for arm64 u-boot-2016.11 */
+#endif
+
+#define DDR_TRAINING_ENV            "ddrtr"
+#define DDR_TRAINING_ENV_UN         "unddrtr"
+
+#define DDR_TRAINING_DDRT_START_OFFSET  0x400000  /* 4M */
+#define DDR_TRAINING_DDRT_LENGTH  0x400000  /* 4M  at lease 0x8000 */
+
+#define DDR_CMD_SW_STR              "training"
+#define DDR_CMD_TR_STR              "tr"
+#define DDR_CMD_HW_STR              "hw"
+#define DDR_CMD_MPR_STR             "mpr"
+#define DDR_CMD_WL_STR              "wl"
+#define DDR_CMD_GATE_STR            "gate"
+#define DDR_CMD_DATAEYE_STR         "dataeye"
+#define DDR_CMD_VREF_STR            "vref"
+#define DDR_CMD_DCC_STR             "dcc"
+#define DDR_CMD_PCODE_STR           "pcode"
+#define DDR_CMD_AC_STR              "ac"
+#define DDR_CMD_LPCA_STR            "lpca"
+#define DDR_CMD_LOG_STR             "log"
+#define DDR_CMD_BOOT_STR            "boot"
+#define DDR_CMD_CONSOLE_STR         "console"
+
+static struct ddr_training_result_st ddrtr_result_st; /* DDR training result */
+static int ddr_log_level = DDR_LOG_ERROR;       /* DDR training log level */
+
+#ifdef CONFIG_DDR_TRAINING_BOOTENV
+extern int do_saveenv(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
+#endif
+#ifdef DDR_TRAINING_EXEC_TIME
+/**
+ * Start timer for calculate DDR training execute time.
+ * NOTE: Just only for debug.
+ */
+static void cmd_exec_timer_start(void)
+{
+	/* timer start */
+	ddr_write(0, 0xF8002000); /* REG_BASE_TIMER01 + REG_TIMER_RELOAD */
+	/* TIMER_EN  | TIMER_MODE |TIMER_PRE | TIMER_SIZE, REG_TIMER_CONTROL */
+	ddr_write(0xc2, 0xF8002008);
+	ddr_write(0xffffffff, 0xF8002000);
+}
+
+/**
+ * Stop timer for calculate DDR training execute time.
+ * NOTE: Just only for debug.
+ */
+static void cmd_exec_timer_stop(void)
+{
+	/* timer stop */
+	ddr_write(0, 0xF8002008); /* REG_TIMER_CONTROL */
+	/* REG_TIMER_VALUE, 24MHz */
+	printf("DDR training execute time: [%d]us\n",
+		(0xffffffff - ddr_read(0xF8002004)) / 24);
+}
+#endif
+
+/**
+ * Match string command.
+ * NOTE: Write leveling not support run repeatedly,
+ * so limit WL only run one time.
+ */
+static int cmd_ddr_match(const char *str, int *cmd)
+{
+	static int wl_done;  /* Write leveling control */
+
+	if (!strncmp(str, DDR_CMD_SW_STR, sizeof(DDR_CMD_SW_STR))) {
+		*cmd = DDR_TRAINING_CMD_SW_NO_WL;
+	} else if (!strncmp(str, DDR_CMD_TR_STR, sizeof(DDR_CMD_TR_STR))) {
+		if (wl_done) {
+			*cmd = DDR_TRAINING_CMD_SW_NO_WL;
+		} else {
+			wl_done++;
+			*cmd = DDR_TRAINING_CMD_SW;
+		}
+	} else if (!strncmp(str, DDR_CMD_HW_STR, sizeof(DDR_CMD_HW_STR))) {
+		*cmd = DDR_TRAINING_CMD_HW;
+	} else if (!strncmp(str, DDR_CMD_MPR_STR, sizeof(DDR_CMD_MPR_STR))) {
+		*cmd = DDR_TRAINING_CMD_MPR;
+	} else if (!strncmp(str, DDR_CMD_WL_STR, sizeof(DDR_CMD_WL_STR))) {
+		if (wl_done) {
+			printf("WL not support run repeatedly. %s",
+				"Already done once, can not do again.\n");
+			return -1;
+		} else {
+			*cmd = DDR_TRAINING_CMD_WL;
+			wl_done++;
+		}
+	} else if (!strncmp(str, DDR_CMD_GATE_STR, sizeof(DDR_CMD_GATE_STR))) {
+		*cmd = DDR_TRAINING_CMD_GATE;
+	} else if (!strncmp(str, DDR_CMD_DATAEYE_STR,
+				sizeof(DDR_CMD_DATAEYE_STR))) {
+		*cmd = DDR_TRAINING_CMD_DATAEYE;
+	} else if (!strncmp(str, DDR_CMD_VREF_STR, sizeof(DDR_CMD_VREF_STR))) {
+		*cmd = DDR_TRAINING_CMD_VREF;
+	} else if (!strncmp(str, DDR_CMD_AC_STR, sizeof(DDR_CMD_AC_STR))) {
+		*cmd = DDR_TRAINING_CMD_AC;
+	} else if (!strncmp(str, DDR_CMD_LPCA_STR, sizeof(DDR_CMD_LPCA_STR))) {
+		*cmd = DDR_TRAINING_CMD_LPCA;
+	} else if (!strncmp(str, DDR_CMD_DCC_STR, sizeof(DDR_CMD_DCC_STR))) {
+		*cmd = DDR_TRAINING_CMD_DCC;
+	} else if (!strncmp(str, DDR_CMD_PCODE_STR, sizeof(DDR_CMD_PCODE_STR))) {
+		*cmd = DDR_TRAINING_CMD_PCODE;
+	} else if (!strncmp(str, DDR_CMD_CONSOLE_STR, sizeof(DDR_CMD_CONSOLE_STR))) {
+		*cmd = DDR_TRAINING_CMD_CONSOLE;
+	} else {
+		printf("Command [ddr %s] is unsupport.\n", str);
+		return -1;
+	}
+
+	return 0;
+}
+
+/**
+ * Handle DDR training.
+ * Copy training codes from DDR to SRAM.
+ */
+static int cmd_ddr_handle(int cmd)
+{
+	struct ddr_training_result_st *result_st = NULL;
+	struct ddr_cmd_st cmd_st;
+
+	cmd_st.cmd = cmd;
+	cmd_st.level = ddr_log_level;
+	cmd_st.start = TEXT_BASE + DDR_TRAINING_DDRT_START_OFFSET;
+	cmd_st.length = DDR_TRAINING_DDRT_LENGTH;
+
+	printf("DDR training area: 0x%08X - 0x%08X\n",
+		   cmd_st.start, cmd_st.start + cmd_st.length);
+
+#ifdef DDR_TRAINING_EXEC_TIME
+	cmd_exec_timer_start();
+#endif
+
+	result_st = ddr_cmd_training_if(&cmd_st);
+
+#ifdef DDR_TRAINING_EXEC_TIME
+	cmd_exec_timer_stop();
+#endif
+
+	if (!result_st)
+		return -1;
+
+	if (sizeof(ddrtr_result_st) != sizeof(*result_st))
+		return -1;
+
+	/* copy training result from SRAM to DDR */
+	memcpy((void *)&ddrtr_result_st, result_st,
+			sizeof(*result_st));
+	printf("DDR training finished.\n");
+
+	return 0;
+}
+
+/* DDR training cmd dispatch */
+static int cmd_ddr_dispatch(int cmd)
+{
+	int result = 0;
+
+	result = cmd_ddr_handle(cmd);
+	switch (cmd) {
+	case DDR_TRAINING_CMD_SW:
+	case DDR_TRAINING_CMD_SW_NO_WL:
+	case DDR_TRAINING_CMD_CONSOLE:
+		ddr_cmd_result_display(&ddrtr_result_st,
+			DDR_TRAINING_CMD_DATAEYE
+			| DDR_TRAINING_CMD_LPCA);
+		break;
+	case DDR_TRAINING_CMD_DATAEYE:
+	case DDR_TRAINING_CMD_VREF:
+		ddr_cmd_result_display(&ddrtr_result_st,
+			DDR_TRAINING_CMD_DATAEYE);
+		break;
+	case DDR_TRAINING_CMD_WL:
+	case DDR_TRAINING_CMD_GATE:
+	case DDR_TRAINING_CMD_HW:
+	case DDR_TRAINING_CMD_DCC:
+	case DDR_TRAINING_CMD_PCODE:
+		break;
+	case DDR_TRAINING_CMD_LPCA:
+		ddr_cmd_result_display(&ddrtr_result_st,
+			DDR_TRAINING_CMD_LPCA);
+		break;
+	default:
+		break;
+	}
+
+	ddr_reg_result_display(&ddrtr_result_st);
+	return result;
+}
+
+/* Set DDR training log level */
+int cmd_ddr_set_log_level(char * const argv[])
+{
+	int level;
+	const char *str;
+
+	str = argv[1];
+	if (strncmp(str, DDR_CMD_LOG_STR, sizeof(DDR_CMD_LOG_STR))) {
+		printf("Command [ddr %s] is unsupport.\n", str);
+		return -1;
+	}
+
+	str = argv[2];
+	if (!strncmp(str, DDR_LOG_INFO_STR, sizeof(DDR_LOG_INFO_STR))) {
+		level = DDR_LOG_INFO;
+	} else if (!strncmp(str, DDR_LOG_DEBUG_STR,
+				sizeof(DDR_LOG_DEBUG_STR))) {
+		level = DDR_LOG_DEBUG;
+	} else if (!strncmp(str, DDR_LOG_WARNING_STR,
+				sizeof(DDR_LOG_WARNING_STR))) {
+		level = DDR_LOG_WARNING;
+	} else if (!strncmp(str, DDR_LOG_ERROR_STR,
+				sizeof(DDR_LOG_ERROR_STR))) {
+		level = DDR_LOG_ERROR;
+	} else if (!strncmp(str, DDR_LOG_FATAL_STR,
+				sizeof(DDR_LOG_FATAL_STR))) {
+		level = DDR_LOG_FATAL;
+	} else {
+		printf("Command [ddr log %s] is unsupport.\n", str);
+		return -1;
+	}
+
+	ddr_log_level = level;
+	printf("Set DDR training log level [%s] suc.\n", str);
+
+	return 0;
+}
+
+/**
+ * Accept DDR training cmd.
+ * Set training result to env without save.
+ */
+static int do_ddr_training(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	const char *str = NULL;
+	int cmd;
+
+	if (argc < 2 || argc > 3) {
+		/* cmd_usage(cmdtp); */
+		return -1;
+	} else if (argc == 3) {
+		return cmd_ddr_set_log_level(argv);
+	}
+
+	str = argv[1];
+
+	if (cmd_ddr_match(str, &cmd))
+		return -1;
+
+	if (cmd_ddr_dispatch(cmd))
+		return -1;
+
+	return 0;
+}
+
+
+U_BOOT_CMD(
+	ddr, CONFIG_SYS_MAXARGS, 1,	do_ddr_training,
+	"ddr training function",
+	"training    - DDR sofeware(Gate/Dataeye/Vref) training.\n"
+	"ddr tr          - DDR sofeware(WL/Gate/Dataeye/Vref) training.\n"
+	"ddr wl          - DDR Write leveling training.\n"
+	"ddr gate        - DDR gate training.\n"
+	"ddr dataeye     - DDR dataeye training and display training result.\n"
+	"ddr vref        - DDR vref training.\n"
+	"ddr hw          - DDR hardware training.\n"
+	"ddr mpr         - DDR Multi-Purpose Register training.\n"
+	"ddr ac          - DDR address command training.\n"
+	"ddr lpca        - LPDDR command address training.\n"
+	"ddr dcc         - DDR Duty Correction Control training.\n"
+	"ddr pcode       - DDR io pcode training.\n"
+	"ddr console     - DDR do training in SRAM.\n"
+	"ddr log [level] - DDR log level. [info,debug,warning,error,fatal]\n"
+);
diff -uraN u-boot-2016.11/drivers/ddr/goke/default/ddr_cmd_ctl.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/ddr_cmd_ctl.c
--- u-boot-2016.11/drivers/ddr/goke/default/ddr_cmd_ctl.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/ddr_cmd_ctl.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,591 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <common.h>
+#include "ddr_interface.h"
+#include "ddr_training_impl.h"
+
+unsigned int ddr_read(unsigned addr)
+{
+	return (*(volatile unsigned int *)((uintptr_t)(addr)));
+}
+
+void ddr_write(unsigned val, unsigned addr)
+{
+	(*(volatile unsigned int *)((uintptr_t)(addr))) = (val);
+}
+
+#if PHY_DQ_BDL_LEVEL == 32
+#define PRINT_DATAEYE_WIN(dq_num, range, dqs, dq, win) \
+	do {\
+		printf("%-4u", dq_num);\
+		for (k = 0; k < PHY_DQ_BDL_LEVEL; k++) {\
+			if (k >= (range >> DDR_DATAEYE_RESULT_BIT)\
+				&& k <= (range & DDR_DATAEYE_RESULT_MASK)) {\
+				printf("%-3s", "-");\
+			} else {\
+				printf("%-3s", "X");\
+			} \
+		} \
+		printf(" 0x%08x  0x%-4x%-4u%-4u\n", range, dqs, dq, win); \
+	} while (0)
+
+#define PRINT_DATAEYE_TITLE(phase) \
+	do { \
+		printf("%-4s", "DQ"); \
+		for (k = 0; k < PHY_DQ_BDL_LEVEL; k++) { \
+			printf("%-3u", k); \
+		} \
+		printf(" %-10s  %-6s%-4s%-4s\n", \
+			"RANGE", phase, "DQ", "WIN"); \
+	} while (0)
+#else
+#define PRINT_DATAEYE_WIN(dq_num, range, dqs, dq, win) \
+	do {\
+		printf("%-4u", dq_num); \
+		for (k = 0; k < PHY_DQ_BDL_LEVEL; k++) { \
+			if (k >= (range >> DDR_DATAEYE_RESULT_BIT)\
+				&& k <= (range & DDR_DATAEYE_RESULT_MASK)) {\
+				printf("%-1s", "-"); \
+			} else {\
+				printf("%-1s", "X"); \
+			} \
+		} \
+		printf(" 0x%08x  0x%-4x%-4u%-4u\n", range, dqs, dq, win); \
+	} while (0)
+
+#define PRINT_DATAEYE_TITLE(phase) \
+	do { \
+		printf("%-4s", "DQ");\
+		for (k = 0; k < PHY_DQ_BDL_LEVEL; k++) { \
+			if (0 == k % 4) \
+				printf("%-4u", k); \
+		} \
+		printf(" %-10s  %-6s%-4s%-4s\n", \
+			"RANGE", phase, "DQ", "WIN"); \
+	} while (0)
+#endif
+
+#ifndef CONFIG_MINI_BOOT
+extern char ddr_training_cmd_start[];  /* DDR training code start address */
+extern char ddr_training_cmd_end[];    /* DDR training code end address */
+#endif
+
+static struct ddr_reg_val_st training_reg_val_rank0[] = {
+	/* rank, byte, offset, value, name */
+	{0, 0, DDR_PHY_DXWDQSDLY(0, 0), 0, "WDQS Byte0"},
+	{0, 1, DDR_PHY_DXWDQSDLY(0, 1), 0, "WDQS Byte1"},
+	{0, 2, DDR_PHY_DXWDQSDLY(0, 2), 0, "WDQS Byte2"},
+	{0, 3, DDR_PHY_DXWDQSDLY(0, 3), 0, "WDQS Byte3"},
+	{0, 0, DDR_PHY_DXNWDQDLY(0, 0), 0, "WDQ Phase Byte0"},
+	{0, 1, DDR_PHY_DXNWDQDLY(0, 1), 0, "WDQ Phase Byte1"},
+	{0, 2, DDR_PHY_DXNWDQDLY(0, 2), 0, "WDQ Phase Byte2"},
+	{0, 3, DDR_PHY_DXNWDQDLY(0, 3), 0, "WDQ Phase Byte3"},
+	{0, 0, DDR_PHY_DXNWDQNBDL0(0, 0), 0, "WDQ BDL DQ0-DQ3"},
+	{0, 0, DDR_PHY_DXNWDQNBDL1(0, 0), 0, "WDQ BDL DQ4-DQ7"},
+	{0, 1, DDR_PHY_DXNWDQNBDL0(0, 1), 0, "WDQ BDL DQ8-DQ11"},
+	{0, 1, DDR_PHY_DXNWDQNBDL1(0, 1), 0, "WDQ BDL DQ12-DQ15"},
+	{0, 2, DDR_PHY_DXNWDQNBDL0(0, 2), 0, "WDQ BDL DQ16-DQ19"},
+	{0, 2, DDR_PHY_DXNWDQNBDL1(0, 2), 0, "WDQ BDL DQ20-DQ23"},
+	{0, 3, DDR_PHY_DXNWDQNBDL0(0, 3), 0, "WDQ BDL DQ24-DQ27"},
+	{0, 3, DDR_PHY_DXNWDQNBDL1(0, 3), 0, "WDQ BDL DQ28-DQ31"},
+	{0, 0, DDR_PHY_DXNWDQNBDL2(0, 0), 0, "WDM Byte0"},
+	{0, 1, DDR_PHY_DXNWDQNBDL2(0, 1), 0, "WDM Byte1"},
+	{0, 2, DDR_PHY_DXNWDQNBDL2(0, 2), 0, "WDM Byte2"},
+	{0, 3, DDR_PHY_DXNWDQNBDL2(0, 3), 0, "WDM Byte3"},
+	{0, 0, DDR_PHY_DXNOEBDL(0, 0), 0, "Write DQ/DQS OE Byte0"},
+	{0, 1, DDR_PHY_DXNOEBDL(0, 1), 0, "Write DQ/DQS OE Byte1"},
+	{0, 2, DDR_PHY_DXNOEBDL(0, 2), 0, "Write DQ/DQS OE Byte2"},
+	{0, 3, DDR_PHY_DXNOEBDL(0, 3), 0, "Write DQ/DQS OE Byte3"},
+	{0, 0, DDR_PHY_DXNRDQSDLY(0), 0, "RDQS Byte0"},
+	{0, 1, DDR_PHY_DXNRDQSDLY(1), 0, "RDQS Byte1"},
+	{0, 2, DDR_PHY_DXNRDQSDLY(2), 0, "RDQS Byte2"},
+	{0, 3, DDR_PHY_DXNRDQSDLY(3), 0, "RDQS Byte3"},
+	{0, 0, DDR_PHY_DXNRDQNBDL0(0, 0), 0, "RDQ BDL DQ0-DQ3"},
+	{0, 0, DDR_PHY_DXNRDQNBDL1(0, 0), 0, "RDQ BDL DQ4-DQ7"},
+	{0, 1, DDR_PHY_DXNRDQNBDL0(0, 1), 0, "RDQ BDL DQ8-DQ11"},
+	{0, 1, DDR_PHY_DXNRDQNBDL1(0, 1), 0, "RDQ BDL DQ12-DQ15"},
+	{0, 2, DDR_PHY_DXNRDQNBDL0(0, 2), 0, "RDQ BDL DQ16-DQ19"},
+	{0, 2, DDR_PHY_DXNRDQNBDL1(0, 2), 0, "RDQ BDL DQ20-DQ23"},
+	{0, 3, DDR_PHY_DXNRDQNBDL0(0, 3), 0, "RDQ BDL DQ24-DQ27"},
+	{0, 3, DDR_PHY_DXNRDQNBDL1(0, 3), 0, "RDQ BDL DQ28-DQ31"},
+	{0, 0, DDR_PHY_DXNRDQSGDLY(0, 0), 0, "Gate Byte0"},
+	{0, 1, DDR_PHY_DXNRDQSGDLY(0, 1), 0, "Gate Byte1"},
+	{0, 2, DDR_PHY_DXNRDQSGDLY(0, 2), 0, "Gate Byte2"},
+	{0, 3, DDR_PHY_DXNRDQSGDLY(0, 3), 0, "Gate Byte3"},
+	{0, 0, DDR_PHY_ACCMDBDL2, 0, "CS"},
+	{0, 0, DDR_PHY_ACPHYCTL7, 0, "CLK"},
+	DDR_PHY_VREF_HOST_DISPLAY
+	DDR_PHY_VREF_DRAM_DISPLAY
+	DDR_PHY_ADDRPH_DISPLAY
+	DDR_PHY_ADDRBDL_DISPLAY
+	DDR_PHY_DCC_DISPLAY
+};
+
+
+/* rank 1*/
+static struct ddr_reg_val_st training_reg_val_rank1[] = {
+	{1, 0, DDR_PHY_DXWDQSDLY(1, 0), 0, "WDQS Byte0"},
+	{1, 1, DDR_PHY_DXWDQSDLY(1, 1), 0, "WDQS Byte1"},
+	{1, 2, DDR_PHY_DXWDQSDLY(1, 2), 0, "WDQS Byte2"},
+	{1, 3, DDR_PHY_DXWDQSDLY(1, 3), 0, "WDQS Byte3"},
+	{1, 0, DDR_PHY_DXNWDQDLY(1, 0), 0, "WDQ Phase Byte0"},
+	{1, 1, DDR_PHY_DXNWDQDLY(1, 1), 0, "WDQ Phase Byte1"},
+	{1, 2, DDR_PHY_DXNWDQDLY(1, 2), 0, "WDQ Phase Byte2"},
+	{1, 3, DDR_PHY_DXNWDQDLY(1, 3), 0, "WDQ Phase Byte3"},
+	{1, 0, DDR_PHY_DXNWDQNBDL0(1, 0), 0, "WDQ BDL DQ0-DQ3"},
+	{1, 0, DDR_PHY_DXNWDQNBDL1(1, 0), 0, "WDQ BDL DQ4-DQ7"},
+	{1, 1, DDR_PHY_DXNWDQNBDL0(1, 1), 0, "WDQ BDL DQ8-DQ11"},
+	{1, 1, DDR_PHY_DXNWDQNBDL1(1, 1), 0, "WDQ BDL DQ12-DQ15"},
+	{1, 2, DDR_PHY_DXNWDQNBDL0(1, 2), 0, "WDQ BDL DQ16-DQ19"},
+	{1, 2, DDR_PHY_DXNWDQNBDL1(1, 2), 0, "WDQ BDL DQ20-DQ23"},
+	{1, 3, DDR_PHY_DXNWDQNBDL0(1, 3), 0, "WDQ BDL DQ24-DQ27"},
+	{1, 3, DDR_PHY_DXNWDQNBDL1(1, 3), 0, "WDQ BDL DQ28-DQ31"},
+	{1, 0, DDR_PHY_DXNWDQNBDL2(1, 0), 0, "WDM Byte0"},
+	{1, 1, DDR_PHY_DXNWDQNBDL2(1, 1), 0, "WDM Byte1"},
+	{1, 2, DDR_PHY_DXNWDQNBDL2(1, 2), 0, "WDM Byte2"},
+	{1, 3, DDR_PHY_DXNWDQNBDL2(1, 3), 0, "WDM Byte3"},
+	{1, 0, DDR_PHY_DXNOEBDL(1, 0), 0, "Write DQ/DQS OE Byte0"},
+	{1, 1, DDR_PHY_DXNOEBDL(1, 1), 0, "Write DQ/DQS OE Byte1"},
+	{1, 2, DDR_PHY_DXNOEBDL(1, 2), 0, "Write DQ/DQS OE Byte2"},
+	{1, 3, DDR_PHY_DXNOEBDL(1, 3), 0, "Write DQ/DQS OE Byte3"},
+
+	{1, 0, DDR_PHY_DXNRDQSDLY(0), 0, "RDQS Byte0"},
+	{1, 1, DDR_PHY_DXNRDQSDLY(1), 0, "RDQS Byte1"},
+	{1, 2, DDR_PHY_DXNRDQSDLY(2), 0, "RDQS Byte2"},
+	{1, 3, DDR_PHY_DXNRDQSDLY(3), 0, "RDQS Byte3"},
+
+	{1, 0, DDR_PHY_DXNRDQNBDL0(1, 0), 0, "RDQ BDL DQ0-DQ3"},
+	{1, 0, DDR_PHY_DXNRDQNBDL1(1, 0), 0, "RDQ BDL DQ4-DQ7"},
+	{1, 1, DDR_PHY_DXNRDQNBDL0(1, 1), 0, "RDQ BDL DQ8-DQ11"},
+	{1, 1, DDR_PHY_DXNRDQNBDL1(1, 1), 0, "RDQ BDL DQ12-DQ15"},
+	{1, 2, DDR_PHY_DXNRDQNBDL0(1, 2), 0, "RDQ BDL DQ16-DQ19"},
+	{1, 2, DDR_PHY_DXNRDQNBDL1(1, 2), 0, "RDQ BDL DQ20-DQ23"},
+	{1, 3, DDR_PHY_DXNRDQNBDL0(1, 3), 0, "RDQ BDL DQ24-DQ27"},
+	{1, 3, DDR_PHY_DXNRDQNBDL1(1, 3), 0, "RDQ BDL DQ28-DQ31"},
+	{1, 0, DDR_PHY_DXNRDQSGDLY(1, 0), 0, "Gate Byte0"},
+	{1, 1, DDR_PHY_DXNRDQSGDLY(1, 1), 0, "Gate Byte1"},
+	{1, 2, DDR_PHY_DXNRDQSGDLY(1, 2), 0, "Gate Byte2"},
+	{1, 3, DDR_PHY_DXNRDQSGDLY(1, 3), 0, "Gate Byte3"},
+	{1, 0, DDR_PHY_ACCMDBDL2, 0, "CS"},
+	{1, 0, DDR_PHY_ACPHYCTL7, 0, "CLK"},
+
+	DDR_PHY_VREF_HOST_DISPLAY_RANK1
+	DDR_PHY_VREF_DRAM_DISPLAY
+	DDR_PHY_ADDRPH_DISPLAY
+	DDR_PHY_ADDRBDL_DISPLAY
+	DDR_PHY_DCC_DISPLAY
+};
+
+/**
+ * ddr_cmd_result_print_dataeye
+ * @ddrtr_data
+ *
+ *
+ */
+static void ddr_cmd_result_print_dataeye(
+	struct ddr_training_data_st *ddrtr_data)
+{
+	unsigned int i, k, j;
+	unsigned int dq_num, dqs, dq, win, win_min, win_max, win_sum;
+
+	win_min = PHY_DQ_BDL_LEVEL;
+	win_max = 0;
+	win_sum = 0;
+	printf("Write window of prebit-deskew:\n");
+	printf("--------------------------------------------------------\n");
+	PRINT_DATAEYE_TITLE("DQPH");
+	for (j = 0; j < ddrtr_data->byte_num; j++) {
+		dqs = (ddr_read(ddrtr_data->base_phy + DDR_PHY_DXNWDQDLY(ddrtr_data->rank_idx, j))
+				>> PHY_WDQ_PHASE_BIT) & PHY_WDQ_PHASE_MASK;
+		for (i = 0; i < DDR_PHY_BIT_NUM; i++) {
+			dq_num = (j << 3) + i;
+			win = ddrtr_data->write.ddr_bit_best[dq_num]
+				>> DDR_DATAEYE_RESULT_BIT;
+			if (win < win_min)
+				win_min = win;
+			if (win > win_max)
+				win_max = win;
+			win_sum += win;
+			dq =  ddrtr_data->write.ddr_bit_best[dq_num]
+				& DDR_DATAEYE_RESULT_MASK;
+			PRINT_DATAEYE_WIN(dq_num,
+					ddrtr_data->write.ddr_bit_result[dq_num],
+					dqs, dq, win);
+		}
+	}
+	printf("--------------------------------------------------------\n");
+	printf("Sum WIN: %u. Avg WIN: %u\n", win_sum,
+		win_sum / (ddrtr_data->byte_num * DDR_PHY_BIT_NUM));
+	printf("Min WIN: %u. DQ Index: ", win_min);
+	for (i = 0; i < DDR_PHY_BIT_MAX; i++) {
+		win = ddrtr_data->write.ddr_bit_best[i]
+			>> DDR_DATAEYE_RESULT_BIT;
+		if (win == win_min)
+			printf("%u ", i);
+	}
+	printf("\nMax WIN: %u. DQ Index: ", win_max);
+	for (i = 0; i < DDR_PHY_BIT_MAX; i++) {
+		win = ddrtr_data->write.ddr_bit_best[i]
+			>> DDR_DATAEYE_RESULT_BIT;
+		if (win == win_max)
+			printf("%u ", i);
+	}
+	printf("\n\n");
+
+	win_min = PHY_DQ_BDL_LEVEL;
+	win_max = 0;
+	win_sum = 0;
+	printf("Read window of prebit-deskew:\n");
+	printf("--------------------------------------------------------\n");
+	PRINT_DATAEYE_TITLE("DQS");
+	for (j = 0; j < ddrtr_data->byte_num; j++) {
+		dqs = ddr_read(ddrtr_data->base_phy + DDR_PHY_DXNRDQSDLY(j))
+				& PHY_RDQS_BDL_MASK;
+		for (i = 0; i < DDR_PHY_BIT_NUM; i++) {
+			dq_num = (j << 3) + i;
+			win = ddrtr_data->read.ddr_bit_best[dq_num]
+				>> DDR_DATAEYE_RESULT_BIT;
+			if (win < win_min)
+				win_min = win;
+			if (win > win_max)
+				win_max = win;
+			win_sum += win;
+			dq =  ddrtr_data->read.ddr_bit_best[dq_num]
+				& DDR_DATAEYE_RESULT_MASK;
+			PRINT_DATAEYE_WIN(dq_num,
+					ddrtr_data->read.ddr_bit_result[dq_num],
+					dqs, dq, win);
+		}
+	}
+	printf("--------------------------------------------------------\n");
+	printf("Sum WIN: %u. Avg WIN: %u\n", win_sum,
+		win_sum / (ddrtr_data->byte_num * DDR_PHY_BIT_NUM));
+	printf("Min WIN: %u. DQ Index: ", win_min);
+	for (i = 0; i < DDR_PHY_BIT_MAX; i++) {
+		win = ddrtr_data->read.ddr_bit_best[i]
+			>> DDR_DATAEYE_RESULT_BIT;
+		if (win == win_min)
+			printf("%u ", i);
+	}
+	printf("\nMax WIN: %u. DQ Index: ", win_max);
+	for (i = 0; i < DDR_PHY_BIT_MAX; i++) {
+		win = ddrtr_data->read.ddr_bit_best[i]
+			>> DDR_DATAEYE_RESULT_BIT;
+		if (win == win_max)
+			printf("%u ", i);
+	}
+	printf("\n\n");
+}
+
+static void ddr_cmd_result_print_ca(struct ddr_training_data_st *ddrtr_data)
+{
+	unsigned int i, j;
+	unsigned int left, right, mid, win, min, max, sum;
+
+	for (i = 0; i < DDR_PHY_CA_MAX; i++) {
+		if (0 != ddrtr_data->ca_addr[i])
+			break;
+		if (i == (DDR_PHY_CA_MAX - 1))
+			return; /* no result to print */
+	}
+
+	min = PHY_DQ_BDL_LEVEL;
+	max = 0;
+	sum = 0;
+
+	printf("Command address window:\n");
+	printf("--------------------------------------------------------\n");
+
+	/* title */
+	printf("%-4s", "CA");
+	for (i = 0; i < PHY_DQ_BDL_LEVEL; i++) {
+		if (0 == i % 4)
+			printf("%-4u", i);
+	}
+	printf(" %-10s  %-6s%-4s\n", "RANGE", "BDL", "WIN");
+
+	/* data */
+	for (i = 0; i < DDR_PHY_CA_MAX; i++) {
+		left = ddrtr_data->ca_addr[i] >> DDR_DATAEYE_RESULT_BIT;
+		right = ddrtr_data->ca_addr[i] & DDR_DATAEYE_RESULT_MASK;
+		mid = (left + right) >> 1;
+		win = right - left + 1;
+
+		printf("%-4u", i);
+		for (j = 0; j < PHY_DQ_BDL_LEVEL; j++) {
+			if (j >= left && j <= right)
+				printf("%-1s", "-");
+			else
+				printf("%-1s", "X");
+		}
+		printf(" 0x%08x  %-6u%-4u\n",
+			ddrtr_data->ca_addr[i], mid, win);
+
+		if (win < min)
+			min = win;
+		if (win > max)
+			max = win;
+		sum += win;
+	}
+	printf("--------------------------------------------------------\n");
+
+	printf("Sum WIN: %u. Avg WIN: %u\n", sum, sum / DDR_PHY_CA_MAX);
+	printf("Min WIN: %u. CA Index: ", min);
+	for (i = 0; i < DDR_PHY_CA_MAX; i++) {
+		win = (ddrtr_data->ca_addr[i] & DDR_DATAEYE_RESULT_MASK)
+			- (ddrtr_data->ca_addr[i] >> DDR_DATAEYE_RESULT_BIT)
+			+ 1;
+		if (win == min)
+			printf("%u ", i);
+	}
+	printf("\nMax WIN: %u. CA Index: ", max);
+	for (i = 0; i < DDR_PHY_CA_MAX; i++) {
+		win = (ddrtr_data->ca_addr[i] & DDR_DATAEYE_RESULT_MASK)
+			- (ddrtr_data->ca_addr[i] >> DDR_DATAEYE_RESULT_BIT)
+			+ 1;
+		if (win == max)
+			printf("%u ", i);
+	}
+	printf("\n\n");
+}
+
+static void ddr_cmd_result_print_by_rank(struct ddr_training_result_st *ddrtr_result,
+					 unsigned int cmd, unsigned int phy_index,
+					 unsigned int rank_index)
+{
+	unsigned int mask = 1 << phy_index ; /* DDR_BYPASS_PHY0_MASK DDR_BYPASS_PHY1_MASK */
+	struct rank_data_st *rank_st = &ddrtr_result->phy_st[phy_index].rank_st[rank_index];
+
+	if (rank_st->item & mask)
+		return;
+
+	printf("\r\n[PHY%u][RANK%u]:\r\n", phy_index, rank_index);
+	if (DDR_TRAINING_CMD_DATAEYE & cmd)
+		ddr_cmd_result_print_dataeye(&rank_st->ddrtr_data);
+
+	if (DDR_TRAINING_CMD_LPCA & cmd)
+		ddr_cmd_result_print_ca(&rank_st->ddrtr_data);
+}
+
+static void ddr_cmd_result_print_by_phy(struct ddr_training_result_st *ddrtr_result,
+					unsigned int cmd, unsigned int phy_index)
+{
+	int i;
+
+	for (i = 0; i < ddrtr_result->phy_st[phy_index].rank_num; i++) {
+		ddr_cmd_result_print_by_rank(ddrtr_result, cmd, phy_index, i);
+	}
+}
+
+void ddr_cmd_result_display(struct ddr_training_result_st *ddrtr_result,
+			    unsigned int cmd)
+{
+	int i;
+
+	for (i = 0; i < ddrtr_result->phy_num; i++) {
+		ddr_cmd_result_print_by_phy(ddrtr_result, cmd, i);
+	}
+}
+
+void ddr_reg_result_display_by_rank(struct ddr_training_result_st *ddrtr_result,
+				    unsigned int phy_index, unsigned int rank_index)
+{
+	int i;
+	unsigned int base_phy = ddrtr_result->phy_st[phy_index].rank_st[rank_index].ddrtr_data.base_phy;
+	unsigned int num;
+	unsigned int byte_num = ddrtr_result->phy_st[phy_index].rank_st[rank_index].ddrtr_data.byte_num;
+	unsigned int rank_num = ddrtr_result->phy_st[phy_index].rank_num;
+	struct ddr_reg_val_st *ddr_reg = NULL;
+
+
+	if (0 == rank_index) {
+		num = sizeof(training_reg_val_rank0) / sizeof(struct ddr_reg_val_st);
+		ddr_reg = &training_reg_val_rank0[0];
+	} else {
+		num = sizeof(training_reg_val_rank1) / sizeof(struct ddr_reg_val_st);
+		ddr_reg = &training_reg_val_rank1[0];
+	}
+
+	printf("\r\n[PHY%u][RANK%u]:\r\n", phy_index, rank_index);
+	for (i = 0; i < num; i++) {
+		if (i != 0)
+			ddr_reg++;
+
+		if (0 == ddr_reg->offset)
+			continue;
+
+		if (ddr_reg->byte_index >= byte_num)
+			continue;
+
+		if (ddr_reg->rank_index >= rank_num)
+			continue;
+
+		ddr_reg->val = ddr_read(base_phy + ddr_reg->offset);
+
+		printf("[0x%08x = 0x%08x] %-32s", base_phy + ddr_reg->offset,
+				ddr_reg->val, ddr_reg->name);
+
+		if (0 == (i + 1) % 2)
+			printf("\r\n");
+	}
+}
+
+
+void ddr_reg_result_display_by_phy(struct ddr_training_result_st *ddrtr_result,
+				   unsigned int phy_index)
+{
+	unsigned int i;
+	unsigned int mask = 1 << phy_index; /* DDR_BYPASS_PHY0_MASK or DDR_BYPASS_PHY1_MASK */
+	unsigned int item;
+	unsigned int enable = 0;
+	unsigned int rank_num = ddrtr_result->phy_st[phy_index].rank_num;
+
+	/* check rank0 and rank1 training item */
+	for (i = 0; i < rank_num; i++) {
+		item = ddrtr_result->phy_st[phy_index].rank_st[i].item;
+		if (!(item & mask))
+			enable = 1;
+	}
+
+	if (!enable)
+		return;
+
+	for (i = 0; i < rank_num; i++) {
+		DDR_PHY_SWITCH_RANK((unsigned int)ddrtr_result->phy_st[phy_index].rank_st[i].ddrtr_data.base_phy, i);
+		ddr_reg_result_display_by_rank(ddrtr_result, phy_index, i);
+	}
+}
+
+/* Display DDR training register */
+void ddr_reg_result_display(struct ddr_training_result_st *ddrtr_result)
+{
+	int i;
+
+	for (i = 0; i < ddrtr_result->phy_num; i++) {
+		ddr_reg_result_display_by_phy(ddrtr_result, i);
+	}
+	printf("\r\n");
+}
+
+#ifndef CONFIG_MINI_BOOT
+static int ddr_cmd_is_disable(void)
+{
+	unsigned int cfg;
+	unsigned int mask;
+	unsigned int i;
+	unsigned int disable = 1;
+
+	cfg = ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_CFG);
+	for (i = 0; i < DDR_PHY_NUM; i++) {
+		mask = 1 << i;
+		if (!(cfg & mask))
+			disable = 0;
+	}
+
+#ifdef SYSCTRL_DDR_TRAINING_CFG_SEC
+	cfg = ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_CFG_SEC);
+	for (i = 0; i < DDR_PHY_NUM; i++) {
+		mask = 1 << i;
+		if (!(cfg & mask))
+			disable = 0;
+	}
+#endif
+
+	return disable;
+}
+
+/* Get DDR training command function entry address */
+void *ddr_cmd_get_entry(void)
+{
+	char *src_ptr = 0;
+	char *dst_ptr;
+	unsigned int length = 0;
+
+	src_ptr = ddr_training_cmd_start;
+	dst_ptr = (char *)(DDR_TRAINING_RUN_STACK);
+	length  = (uintptr_t)ddr_training_cmd_end - (uintptr_t)src_ptr;
+
+	if (!src_ptr || !length) {
+		printf("DDR training is unsupport.\n");
+		return 0;
+	}
+
+	printf("DDR training cmd entry[0x%08X] size[%u]byte cfg[0x%08X = 0x%08X]",
+		DDR_TRAINING_RUN_STACK, length,
+		(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_CFG),
+		ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_CFG));
+
+#ifdef SYSCTRL_DDR_TRAINING_CFG_SEC
+	printf("[0x%08X = 0x%08X]",
+		(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_CFG_SEC),
+		ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_CFG_SEC));
+#endif
+	printf("\n");
+
+	if (ddr_cmd_is_disable()) {
+		printf("Please config DDR training item. Bypass bit:\n"
+			"[0]PHY0            : 0x1\n"
+			"[1]PHY1            : 0x2\n"
+			"[4]Write Leveling  : 0x10\n"
+			"[8]Gate            : 0x100\n"
+			"[16]Dataeye        : 0x10000\n"
+			"[18]Pcode          : 0x40000\n"
+			"[20]HW             : 0x100000\n"
+			"[21]MPR            : 0x200000\n"
+			"[22]AC             : 0x400000\n"
+			"[23]LPCA           : 0x800000\n"
+			"[24]Host Vref      : 0x1000000\n"
+			"[25]Dram Vref      : 0x2000000\n"
+			"[27]DCC            : 0x8000000\n"
+			"[28]Dataeye Adjust : 0x10000000\n"
+			"[29]WL Write Adjust: 0x20000000\n"
+			"[30]HW Read Adjust : 0x40000000\n");
+		return 0;
+	}
+
+	ddr_cmd_prepare_copy();
+	memcpy(dst_ptr, src_ptr, length);
+	return (void *) dst_ptr;
+}
+
+/* Copy training codes from DDR to SRAM and do ddr training */
+struct ddr_training_result_st *ddr_cmd_training_if(struct ddr_cmd_st *cmd_st)
+{
+	ddr_cmd_entry_func entry;
+	struct ddr_training_result_st *result_st = NULL;
+	struct tr_relate_reg reg;
+
+	entry = (ddr_cmd_entry_func)ddr_cmd_get_entry();
+	if (!entry)
+		return 0;
+
+#ifdef CONFIG_ARM64
+	asm("isb");
+	asm("dsb sy");
+#else
+	asm("mcr p15, 0, r0, c7, c5, 0");  /* instruction cache invalidate all to PoU */
+	asm("mcr p15, 0, r0, c7, c10, 4"); /* data synchronization barrier operation */
+#endif
+
+	ddr_boot_cmd_save_func(&reg);
+	/* save site before execute cmd */
+	ddr_cmd_site_save();
+
+	/* entry = ddr_training_cmd_entry() */
+	result_st = entry(cmd_st);
+
+	/* restore site before execute cmd */
+	ddr_cmd_site_restore();
+
+	ddr_boot_cmd_restore_func(&reg);
+
+	if (!result_st) {
+		printf("DDR training fail\n");
+		return 0;
+	}
+
+	return result_st;
+}
+#endif
diff -uraN u-boot-2016.11/drivers/ddr/goke/default/ddr_cmd_loc.S gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/ddr_cmd_loc.S
--- u-boot-2016.11/drivers/ddr/goke/default/ddr_cmd_loc.S	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/ddr_cmd_loc.S	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,11 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+.section .image,#alloc
+
+.globl ddr_training_cmd_start
+ddr_training_cmd_start:
+.incbin "drivers/ddr/goke/default/cmd_bin/ddr_cmd.bin"
+.globl ddr_training_cmd_end
+ddr_training_cmd_end:
diff -uraN u-boot-2016.11/drivers/ddr/goke/default/ddr_ddrc.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/ddr_ddrc.h
--- u-boot-2016.11/drivers/ddr/goke/default/ddr_ddrc.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/ddr_ddrc.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,240 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+/******** DMC **************************/
+/* base address: DDR_REG_BASE_DMC0 DDR_REG_BASE_DMC1 */
+/* register offset address */
+#define DDR_DMC_CTRL_SREF		0X0     /* DDRC self-refresh control. */
+#define DDR_DMC_CFG_SREF		0x20    /* DDRC self-refresh config. */
+#define DDR_DMC_CFG_PD			0x28   /* PowerDown */
+#define DDR_DMC_CFG_DDRMODE		0x50
+#define DDR_DMC_CFG_SCRAMB		0x58   /* DDR scramb config */
+#define DDR_DMC_CFG_RNKVOL(n)	(0x60 + ((n) << 2))
+#define DDR_DMC_CFG_EMRS01		0xf0
+#define DDR_DMC_TIMING2			0x108
+#define DDR_DMC_SFCREQ			0xc
+#define DDR_DMC_SFCCMD			0x210
+#define DDR_DMC_SFCADDR			0x214   /* read col and row */
+#define DDR_DMC_SFCBANK			0x218
+#define DDR_DMC_CURR_FUNC		0x294
+#ifndef DDR_DMC_SFC_RDATA0
+#define DDR_DMC_SFC_RDATA0		0x4A8   /* SFC read data[31:0] */
+#endif
+#ifndef DDR_DMC_SFC_RDATA1
+#define DDR_DMC_SFC_RDATA1		0x4AC   /* SFC read data[63:32] */
+#endif
+#ifndef DDR_DMC_SFC_RDATA2
+#define DDR_DMC_SFC_RDATA2		0x4B0   /* SFC read data[95:64] */
+#endif
+#ifndef DDR_DMC_SFC_RDATA3
+#define DDR_DMC_SFC_RDATA3		0x4B4   /* SFC read data[127:96] */
+#endif
+#ifndef DDR_DMC_SFC_RDATA4
+#define DDR_DMC_SFC_RDATA4		0x4B8   /* SFC read data[159:128] */
+#endif
+#ifndef DDR_DMC_SFC_RDATA5
+#define DDR_DMC_SFC_RDATA5		0x4BC   /* SFC read data[191:160] */
+#endif
+#ifndef DDR_DMC_SFC_RDATA6
+#define DDR_DMC_SFC_RDATA6		0x4C0   /* SFC read data[223:192] */
+#endif
+#ifndef DDR_DMC_SFC_RDATA7
+#define DDR_DMC_SFC_RDATA7		0x4C4   /* SFC read data[255:224] */
+#endif
+
+/* register mask */
+#define DMC_CMD_MRS_MASK		0xffff
+/* storing data bus width. [00]8bit, [01]16bit, [10]32bit, [11]64bit */
+#define DMC_MEM_WIDTH_MASK		0x3
+#define DMC_MRS_MASK			0xffff  /* [15:0] Mode Register mask */
+#define DMC_MR0_BL_MASK			0x3
+#define DMC_CFG_DRAM_TYPE_MASK	0xf /* [3:0]101:DDR2, 110:DDR3, 111:DDR4 */
+#define DMC_CFG_MEM_BG_MASK		0x3 /* [11:10]0:1, 1:2, 2:4 Bank Group */
+#define DMC_CURR_FUNC_IN_SREF_MASK		0x1
+#define DMC_RNKVOL_MEM_BANK_MASK	0x3  /* [9:8] */
+#define DMC_RNKVOL_MEM_ROW_MASK		0x7  /* [6:4] */
+#define DMC_RNKVOL_MEM_COL_MASK		0x7  /* [2:0] */
+#define DMC_CFG_INIT_XSREF_PD_MASK	0xc  /* [3:2] */
+
+/* register bit */
+#define DMC_MEM_WIDTH_BIT		4       /* storing data bus width */
+/* [CUSTOM] precharge disable/enable bit */
+#define DMC_SFC_PRE_DIS_BIT		30
+/* [CUSTOM] [29:12]config MR when LMR command */
+#define DMC_SFC_CMD_MRS_BIT		12
+#define DMC_SFC_RANK_BIT		16      /* [CUSTOM] [31:16]sfc_rank */
+#define DMC_CFG_MEM_BG_BIT		10      /* [11:10] mem_bankgroup */
+#define DMC_RNKVOL_MEM_BANK_BIT	8       /* [9:8] */
+#define DMC_RNKVOL_MEM_ROW_BIT	4       /* [6:4] */
+
+
+/* register value */
+#define DMC_BANK_MR1			1
+#define DMC_BANK_MR3			0x3
+#define DMC_CMD_TYPE_LMR		0x2
+#define DMC_CMD_TYPE_READ		0x5      /* read  */
+#define DMC_CMD_TYPE_PRECHARGE_ALL	0x6      /* precharge all */
+#define DMC_CMD_MRS_MR3			0x4      /* MR3 = 0x4 */
+#define DMC_CMD_MRS_A7			0x80
+/* value 1 means exexute command. cmd_rank[0] control DDR RANK0 */
+#define DMC_CMD_RANK0			0x1
+#define DMC_MR0_BL_BUST8		0x0      /* BC8 (fixed) */
+#define DMC_MR0_BL_BUST4		0x2      /* BC4 (fixed) */
+#define DMC_AUTO_TIMING_DIS		0xfffff000 /* auto refresh disable */
+#define DMC_POWER_DOWN_DIS		0xfffffffe /* powerDown disable */
+#define DMC_SCRAMB_DIS			0xffffbfff /* [14] scramb disable */
+/* [4] scramb_seed_type, [2:0] scramb_seed_sort */
+#define DMC_SCRAMB_CFG			0xffffffe8
+#define DMC_CFG_DRAM_TYPE_DDR4	0x7        /* DDR4 */
+#define DMC_CFG_DRAM_TYPE_LPDDR4	0x8        /* LPDDR4 */
+#define DMC_CFG_MEM_2BG			0x1        /* 2 Bank Group */
+#define DMC_CFG_INIT_XSREF_PD	0xc        /* LPDDR4:Exit Auto-self refresh enter powerdown */
+#define DMC_CTRL_SREF_ENTER		0x1        /* 1 Enter Auto-self refresh */
+#define DMC_CTRL_SREF_EXIT		0x2        /* 2 Exit Auto-self refresh */
+#define DMC_RNKVOL_MEM_ROW_11	0x0       /* 000: 11 bit */
+
+#ifndef DDR_PHY_NUM
+#define DDR_PHY_NUM              2 /* phy number */
+#endif
+
+#ifndef DDR_DMC_PER_PHY_MAX
+#define DDR_DMC_PER_PHY_MAX      2
+#endif
+
+#ifndef DDR_AXI_SWITCH_NUM
+#define DDR_AXI_SWITCH_NUM       4 /* ddr training axi switch number */
+#endif
+
+#ifndef DDR_RANK_NUM
+#define DDR_RANK_NUM             2 /* rank number */
+#endif
+
+#define DMC_SFC_CMD_WRITE(sfc_cmd, addr) \
+		ddr_write(sfc_cmd | (1 << DMC_SFC_PRE_DIS_BIT), addr)
+#define DMC_SFC_BANK_WRITE(sfc_bank, addr) \
+		ddr_write(sfc_bank | (DMC_CMD_RANK0 << DMC_SFC_RANK_BIT), addr)
+
+#define DMC_MPR_CHECK_BIT_0_127(cfg) \
+		ddr_mpr_extract(cfg, \
+			DDR_DMC_SFC_RDATA3, DDR_DMC_SFC_RDATA2, \
+			DDR_DMC_SFC_RDATA1, DDR_DMC_SFC_RDATA0)
+#define DMC_MPR_CHECK_BIT_128_255(cfg) \
+		ddr_mpr_extract(cfg, \
+			DDR_DMC_SFC_RDATA7, DDR_DMC_SFC_RDATA6, \
+			DDR_DMC_SFC_RDATA5, DDR_DMC_SFC_RDATA4)
+
+/* dmc scramb */
+#define DMC_SAVE_SCRAMB(relate_reg, i, base_dmc) \
+	do { \
+		relate_reg->dmc_scramb[i] = \
+			ddr_read(base_dmc + DDR_DMC_CFG_DDRMODE); \
+		relate_reg->dmc_scramb_cfg[i] = \
+			ddr_read(base_dmc + DDR_DMC_CFG_SCRAMB); \
+	} while (0)
+
+#define DMC_DISABLE_SCRAMB(relate_reg, i, base_dmc) \
+	do { \
+		ddr_write(relate_reg->dmc_scramb[i] & DMC_SCRAMB_DIS, \
+			base_dmc + DDR_DMC_CFG_DDRMODE); \
+		ddr_write(relate_reg->dmc_scramb_cfg[i] & DMC_SCRAMB_CFG, \
+			base_dmc + DDR_DMC_CFG_SCRAMB); \
+	} while (0)
+
+#define DMC_RESTORE_SCRAMB(relate_reg, i, base_dmc) \
+	do { \
+		ddr_write(relate_reg->dmc_scramb[i], \
+			base_dmc + DDR_DMC_CFG_DDRMODE); \
+		ddr_write(relate_reg->dmc_scramb_cfg[i], \
+			base_dmc + DDR_DMC_CFG_SCRAMB); \
+	} while (0)
+
+/******** AXI **************************/
+/**
+ *              DMC -- PHY
+ *             /
+ * DDRT -- AXI
+ *             \
+ *              DMC -- PHY
+ */
+/* base address: DDR_REG_BASE_AXI */
+/* register offset address */
+#define DDR_AXI_REGION_ATTRIB0           0x104  /* region 0 */
+#define DDR_AXI_REGION_ATTRIB1           0x114  /* region 1 */
+
+/* register mask */
+#define AXI_REGION_ATTRIB_CH_MASK        0xfffffff0 /* channel mask */
+
+/* register value */
+/* Map to the single channel, independent address */
+#define AXI_RNG_ATTR_CH_MODE             0x4
+#define AXI_RNG_ATTR_CH_START_0          0x0
+#define AXI_RNG_ATTR_CH_START_1          0x1
+#define AXI_RNG_ATTR_CH_START_2          0x2
+#define AXI_RNG_ATTR_CH_START_3          0x3
+#define AXI_RNG_NUM			             2   /* region number */
+
+/********data define************************************/
+struct ddr_ddrc_data {
+	unsigned int region_attrib[AXI_RNG_NUM];
+	unsigned int rnkvol;
+};
+
+#define DDR_AXI_SAVE_FUNC(relate_reg) \
+	do { \
+		relate_reg->ddrc.region_attrib[0]   = \
+			ddr_read(DDR_REG_BASE_AXI + DDR_AXI_REGION_ATTRIB0); \
+		relate_reg->ddrc.region_attrib[1]   = \
+			ddr_read(DDR_REG_BASE_AXI + DDR_AXI_REGION_ATTRIB1); \
+	} while (0)
+
+#define DDR_AXI_RESTORE_FUNC(relate_reg) \
+	do { \
+		ddr_write(relate_reg->ddrc.region_attrib[0], \
+			DDR_REG_BASE_AXI + DDR_AXI_REGION_ATTRIB0); \
+		ddr_write(relate_reg->ddrc.region_attrib[1], \
+			DDR_REG_BASE_AXI + DDR_AXI_REGION_ATTRIB1); \
+	} while (0)
+
+/*
+ch_start value:
+#define AXI_RNG_ATTR_CH_START_0          0x0
+#define AXI_RNG_ATTR_CH_START_1          0x1
+#define AXI_RNG_ATTR_CH_START_2          0x2
+#define AXI_RNG_ATTR_CH_START_3          0x3
+ */
+#define DDR_AXI_SWITCH_FUNC(cfg) \
+	do { \
+		unsigned int ch_start = cfg->phy_idx; \
+		if (PHY_DRAMCFG_TYPE_LPDDR4 == cfg->phy[cfg->phy_idx].dram_type) \
+			ch_start = (cfg->phy_idx << 1) + cfg->dmc_idx; \
+		ddr_write((ddr_read(DDR_REG_BASE_AXI + DDR_AXI_REGION_ATTRIB0) \
+			& AXI_REGION_ATTRIB_CH_MASK) \
+			| AXI_RNG_ATTR_CH_MODE | ch_start, \
+			DDR_REG_BASE_AXI + DDR_AXI_REGION_ATTRIB0); \
+		ddr_write((ddr_read(DDR_REG_BASE_AXI + DDR_AXI_REGION_ATTRIB1) \
+			& AXI_REGION_ATTRIB_CH_MASK) \
+			| AXI_RNG_ATTR_CH_MODE | ch_start, \
+			DDR_REG_BASE_AXI + DDR_AXI_REGION_ATTRIB1); \
+		DDR_DEBUG("AXI region0[%x = %x]", \
+			(DDR_REG_BASE_AXI + DDR_AXI_REGION_ATTRIB0), \
+			ddr_read(DDR_REG_BASE_AXI + DDR_AXI_REGION_ATTRIB0)); \
+		DDR_DEBUG("AXI region1[%x = %x]", \
+			(DDR_REG_BASE_AXI + DDR_AXI_REGION_ATTRIB1), \
+			ddr_read(DDR_REG_BASE_AXI + DDR_AXI_REGION_ATTRIB1)); \
+	} while (0)
+
+/* save rank0 for ddrt address */
+#define DDR_RNKVOL_SAVE_FUNC(relate_reg, base_dmc) \
+		relate_reg->ddrc.rnkvol = ddr_read(base_dmc + DDR_DMC_CFG_RNKVOL(0));
+
+#define DDR_RNKVOL_RESTORE_FUNC(relate_reg, base_dmc) \
+		ddr_write(relate_reg->ddrc.rnkvol, base_dmc + DDR_DMC_CFG_RNKVOL(0));
+
+/* set mem_row to 0 */
+#define DDR_RNKVOL_SET_FUNC(cfg) \
+	do { \
+			if (1 == cfg->rank_idx) { \
+				ddr_write(ddr_read(cfg->cur_dmc + DDR_DMC_CFG_RNKVOL(0)) & (~DMC_RNKVOL_MEM_ROW_MASK), cfg->cur_dmc + DDR_DMC_CFG_RNKVOL(0)); \
+			} \
+	} while (0)
diff -uraN u-boot-2016.11/drivers/ddr/goke/default/ddr_ddrt_v2_0_shf1.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/ddr_ddrt_v2_0_shf1.h
--- u-boot-2016.11/drivers/ddr/goke/default/ddr_ddrt_v2_0_shf1.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/ddr_ddrt_v2_0_shf1.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+/* register offset address */
+/* base address: DDR_REG_BASE_DDRT */
+#define DDRT_OP			0x0	/* DDRT operation config */
+#define DDRT_STATUS		0x4	/* DDRT status indicating */
+#define DDRT_BURST_CONFIG	0x8	/* DDRT burst transfer config */
+#define DDRT_MEM_CONFIG		0xc	/* DDRT SDRAM config */
+#define DDRT_BURST_NUM		0x10	/* DDRT burst number config */
+/* DDRT burst number config register while testing address */
+#define DDRT_ADDR_NUM		0x14
+#define DDRT_LOOP_NUM		0x18	/* DDRT loop number config */
+/* This register specified the system DDR starting address */
+#define DDRT_DDR_BASE_ADDR	0x1c
+#define DDRT_ADDR		0x20	/* DDRT test start address config  */
+#define DDRT_REVERSED_DQ	0x30	/* DDRT reversed DQ indicating */
+#define DDRT_SEED		0x38	/* DDRT starting random seed */
+#define DDRT_KDATA		0x3c	/* DDRT kdata config */
+#define DDRT_DATA0		0x40	/* DDRT PRBS7 data config register0 */
+#define DDRT_DATA1		0x44	/* DDRT PRBS7 data config register1 */
+#define DDRT_DATA2		0x48	/* DDRT PRBS7 data config register2 */
+#define DDRT_DATA3		0x4c	/* DDRT PRBS7 data config register3 */
+
+/* DQ3~DQ0 error number indicator, every 8bit for each DQ */
+#define DDRT_DQ_ERR_CNT(n)	(0x60 + ((n) << 2))
+/* DQ31~DQ0 error number overflow indicator, every bit for each DQ. */
+#define DDRT_DQ_ERR_OVFL	0x80
+
+/* register mask */
+#define DDRT_TEST_MODE_MASK	0x300	/* DDRT Test Mode */
+#define DDRT_TEST_DONE_MASK	0x1	/* [0] DDRT operation finish signal.*/
+/* [1] DDRT Test result indicator. No error occurred, test pass. */
+#define DDRT_TEST_PASS_MASK	0x2
+
+/* register bit */
+#define DDRT_DDR_MEM_WIDTH	12	/* SDRAM total width */
+
+/* register value */
+#define DDRT_CFG_START		0x1
+#define DDRT_CFG_BURST_CFG_DATAEYE	0x4f
+#define DDRT_CFG_BURST_CFG_GATE	0x43
+#ifdef CFG_EDA_VERIFY
+#define DDRT_CFG_BURST_NUM 0x5 /* ddrt test number */
+#else
+#define DDRT_CFG_BURST_NUM 0x7f /* ddrt test number */
+#endif
+#define DDRT_CFG_SEED		0x6d6d6d6d
+#define DDRT_CFG_REVERSED	0x55aa55aa
+#ifndef DDRT_CFG_BASE_ADDR
+/* [CUSTOM] DDR training start address. MEM_BASE_DDR */
+#define DDRT_CFG_BASE_ADDR	0x0
+#endif
+/* [CUSTOM] DDRT test address. 0x800000 = 8M */
+#define DDRT_CFG_TEST_ADDR_CMD	(DDRT_CFG_BASE_ADDR + 0x800000)
+/* [CUSTOM] DDRT test start address. */
+#define DDRT_CFG_TEST_ADDR_BOOT	DDRT_CFG_BASE_ADDR
+#define DDRT_CFG_ADDR_NUM	0xffffffff
+#define DDRT_CFG_LOOP_NUM	0x0
+
+/* [2:0]000:8 bit; 001:9 bit; 010:10 bit; 011:11 bit; 100:12 bit.
+single SDRAM column number.*/
+#define DDRT_DDR_COL_WIDTH	0x2
+/* [6:4]000:11 bit; 001:12 bit; 010:13 bit; 011:14 bit; 100:15 bit; 101:16 bit.
+single SDRAM row number */
+#define DDRT_DDR_ROW_WIDTH	0x50
+/* [8]0:4 Bank; 1:8 Bank. single SDRAM bank number */
+#define DDRT_DDR_BANK_WIDTH	0x100
+
+
+#define DDRT_WR_COMPRARE_MODE	(0<<8)	/* Write read & compare mode */
+#define DDRT_WRITE_ONLY_MODE	(1<<8)	/* Write only mode */
+#define DDRT_READ_ONLY_MODE	(2<<8)	/* Read only mode */
+#define DDRT_RANDOM_WR_MODE	(3<<8)	/* Random write & read mode */
+
+#define DDRT_PATTERM_PRBS9	(0<<12)
+#define DDRT_PATTERM_PRBS7	(1<<12)
+#define DDRT_PATTERM_PRBS11	(2<<12)
+#define DDRT_PATTERM_K28_5	(3<<12)
+
+/* other */
+#define DDRT_WAIT_TIMEOUT	(1000000)
+#define DDRT_READ_TIMEOUT	(20)
+#define DDRT_PCODE_WAIT_TIMEOUT	(100000)
+
+/* DDRT test DDR using space */
+#define DDRT_GET_TEST_ADDR(addr) ((addr)>>1)
diff -uraN u-boot-2016.11/drivers/ddr/goke/default/ddr_interface.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/ddr_interface.h
--- u-boot-2016.11/drivers/ddr/goke/default/ddr_interface.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/ddr_interface.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,144 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef DDR_INTERFACE_H
+#define DDR_INTERFACE_H
+
+#define DDR_PHY_BYTE_MAX                  4
+#define DDR_PHY_BIT_NUM                   8
+/* support max bit 32*/
+#define DDR_PHY_BIT_MAX                   (DDR_PHY_BYTE_MAX * DDR_PHY_BIT_NUM)
+
+#define DDR_REG_NAME_MAX              32       /* register name */
+#define DDR_CA_ADDR_MAX               10
+
+#define DDR_SUPPORT_PHY_MAX           2        /* support max phy number */
+#define DDR_SUPPORT_RANK_MAX          2       /* support max rank number */
+#define DDR_SUPPORT_DMC_MAX           4        /* support max dmc number */
+#define DDR_CK_RESULT_MAX             2        /* DCC CK result number */
+
+
+/**
+ * DDR training register number:
+ * WDQS              4
+ * WDQ Phase         4
+ * WDQ BDL           8
+ * WDM               4
+ * Write DQ/DQS OE   4
+ * RDQS              4
+ * RDQ BDL           8
+ * Gate              4
+ * CS                1
+ * CLK               1
+ * Host Vref         4
+ * DRAM Vref         4
+ * CA Phase          1
+ * CA BDL            5
+ * -------------------
+ *                  60
+ */
+#define DDR_TRAINING_REG_NUM          60
+/* register max. */
+#define DDR_TRAINING_REG_MAX        (DDR_TRAINING_REG_NUM * DDR_SUPPORT_PHY_MAX)
+
+#define DDR_TRAINING_CMD_SW         (1 << 0)
+#define DDR_TRAINING_CMD_HW         (1 << 1)
+#define DDR_TRAINING_CMD_MPR        (1 << 2)
+#define DDR_TRAINING_CMD_WL         (1 << 3)
+#define DDR_TRAINING_CMD_GATE       (1 << 4)
+#define DDR_TRAINING_CMD_DATAEYE    (1 << 5)
+#define DDR_TRAINING_CMD_VREF       (1 << 6)
+#define DDR_TRAINING_CMD_AC         (1 << 7)
+#define DDR_TRAINING_CMD_LPCA       (1 << 8)
+#define DDR_TRAINING_CMD_SW_NO_WL   (1 << 9)
+#define DDR_TRAINING_CMD_CONSOLE    (1 << 10)
+#define DDR_TRAINING_CMD_DCC        (1 << 11)
+#define DDR_TRAINING_CMD_PCODE      (1 << 12)
+
+/*******log level ********************/
+#define DDR_LOG_INFO_STR              "info"
+#define DDR_LOG_DEBUG_STR             "debug"
+#define DDR_LOG_WARNING_STR           "warning"
+#define DDR_LOG_ERROR_STR             "error"
+#define DDR_LOG_FATAL_STR             "fatal"
+
+#define DDR_LOG_INFO                  (1 << 0)
+#define DDR_LOG_DEBUG                 (1 << 1)
+#define DDR_LOG_WARNING               (1 << 2)
+#define DDR_LOG_ERROR                 (1 << 3)
+#define DDR_LOG_FATAL                 (1 << 4)
+
+#define DDR_TRAINING_BOOT_RESULT_ADDR (TEXT_BASE + 0x1000000)  /* boot + 16M */
+
+#define DDR_TRAINING_VER "V2.1.6 20181228"
+#define DDR_VERSION    0x216
+struct training_data {
+	unsigned int ddr_bit_result[DDR_PHY_BIT_MAX];
+	unsigned int ddr_bit_best[DDR_PHY_BIT_MAX];
+	unsigned int ddr_win_sum;
+};
+
+struct ddr_training_data_st {
+	unsigned int base_phy;
+	unsigned int byte_num;
+	unsigned int rank_idx;
+	struct training_data read;
+	struct training_data write;
+	unsigned int ca_addr[DDR_CA_ADDR_MAX];
+};
+
+struct rank_data_st {
+	unsigned int item;
+	struct ddr_training_data_st ddrtr_data;
+};
+
+struct phy_data_st {
+	unsigned int rank_num;
+	struct rank_data_st rank_st[DDR_SUPPORT_RANK_MAX];
+};
+
+struct ddr_training_result_st {
+	unsigned int phy_num;
+	struct phy_data_st phy_st[DDR_SUPPORT_PHY_MAX];
+};
+
+struct ddr_reg_val_st {
+	unsigned int rank_index;
+	unsigned int byte_index;
+	unsigned int offset;
+	unsigned int val;
+	char name[DDR_REG_NAME_MAX];
+};
+
+struct ddr_cmd_st {
+	unsigned int cmd;
+	unsigned int level;
+	unsigned int start;
+	unsigned int length;
+};
+
+typedef struct ddr_training_result_st * (*ddr_cmd_entry_func)
+				(struct ddr_cmd_st *cmd_st);
+
+/* DDR training interface before boot */
+int ddr_pcode_training_if(void);
+int ddr_sw_training_if(void);
+int ddr_hw_training_if(void);
+int ddr_training_console_if(void *args);
+
+/* DDR training check interface when boot */
+struct ddr_training_result_st *ddr_cmd_training_if(struct ddr_cmd_st *cmd_st);
+int check_ddr_training(void);
+
+/* DDR training command interface after boot */
+void ddr_reg_result_display(struct ddr_training_result_st *ddrtr_result);
+void ddr_cmd_result_display(struct ddr_training_result_st *ddrtr_result,
+	unsigned int cmd);
+void *ddr_cmd_get_entry(void);
+void ddr_cmd_prepare_copy(void);
+void ddr_cmd_site_save(void);
+void ddr_cmd_site_restore(void);
+
+#endif /* DDR_INTERFACE_H */
+
diff -uraN u-boot-2016.11/drivers/ddr/goke/default/ddr_phy.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/ddr_phy.h
--- u-boot-2016.11/drivers/ddr/goke/default/ddr_phy.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/ddr_phy.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,458 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+/* register offset address */
+/* base address: DDR_REG_BASE_PHY0 DDR_REG_BASE_PHY1 */
+/* control the initialization of the PHY */
+#define DDR_PHY_PHYINITCTRL	0x4
+#define DDR_PHY_PHYINITSTATUS	0x8	/* Read Data Eye Calibration Error*/
+#define DDR_PHY_IMPSTATUS	0x28    /* This register specify the ZQ calibration result. */
+#define DDR_PHY_DRAMCFG		0x2c    /* DRAM config register */
+#define DDR_PHY_TRAINCTRL0  0x48   /* hw training control */
+#define DDR_PHY_MODEREG01	0x64	/* Extend Mode Register 01 */
+#define DDR_PHY_MODEREG23	0x68	/* Extend Mode Register 23 */
+/* update delay setting in registers to PHY */
+#define DDR_PHY_MISC		0x70
+#define DDR_PHY_DMSEL       0x84    /* DM Swap Selection */
+#define DDR_PHY_SWTMODE		0xa0	/* S/W training mode */
+/* issue one DQS pulse from PHY to DRAM */
+#define DDR_PHY_SWTWLDQS	0xa4
+#define DDR_PHY_SWTRLT		0xa8	/* S/W training result*/
+/* Host vref. [5:0]range [17:12]refsel */
+#define DDR_PHY_PHYRSCTRL	0xB0    /* PHY Register Slice Contrl */
+#define DDR_PHY_IOCTL2		0xB4
+#define DDR_PHY_VREFTCTRL	0xc0    /* VREF Training Control Register. */
+#define DDR_PHY_DVRFTCTRL	0xC4    /* DRAM VREF Training */
+#define DDR_PHY_ACADDRBDL(n) (0x140 + ((n) << 2))
+#define DDR_PHY_IMP_CTRL1	0x170   /* AC/DX ZQ selection */
+#define DDR_PHY_IMP_STATUS1	0x174   /* AC ZCAL status */
+#define DDR_PHY_CATSWAPINDEX 0x01B8 /* CA SWAP index register */
+#define DDR_PHY_CATSWAPSEL	0x01BC /* CA SWAP select register*/
+#define DDR_PHY_CATCONFIG	0x1C8   /* CA Training Configuration */
+#define DDR_PHY_PHYDQRESULT 0x1D0 /* SW CA Training DQ result from PHY */
+#define DDR_PHY_ADDRPHBOUND 0x1D4 /* CA Training addr phase boundary */
+#define DDR_PHY_SWCATPATTERN_P 0x1D8 /* pattern for positive CK edge */
+#define DDR_PHY_SWCATPATTERN_N 0x1DC /* pattern for negative CK edge */
+/* AC command bit delay line setting */
+#define DDR_PHY_ACCMDBDL2		0x128
+
+/* WR DQ0-DQ3 [6:0] [14:8] [22:16] [30:24] delay value of the bit delay line
+on write path */
+#define DDR_PHY_DXNWDQNBDL0(m, n)	(0x210 + ((m) << 10) + ((n) << 7))
+/* WR DQ4-DQ7 [6:0] [14:8] [22:16] [30:24] */
+#define DDR_PHY_DXNWDQNBDL1(m, n)	(0x214 + ((m) << 10) + ((n) << 7))
+/* WR DM [6:0] the delay value of the bit delay line on DQM */
+#define DDR_PHY_DXNWDQNBDL2(m, n)	(0x218 + ((m) << 10) + ((n) << 7))
+/* RD DQ0-DQ3 [6:0] [14:8] [22:16] [30:24] delay value of the bit delay line
+ on read path */
+#define DDR_PHY_DXNRDQNBDL0(m, n)	(0x21C + ((m) << 10) + ((n) << 7))
+/* RD DQ4-DQ7 [6:0] [14:8] [22:16] [30:24] delay value of the bit delay line
+ on read path */
+#define DDR_PHY_DXNRDQNBDL1(m, n)	(0x220 + ((m) << 10) + ((n) << 7))
+/* [6:0]RD DM*/
+#define DDR_PHY_DXNRDQNBDL2(m, n)	(0x224 + ((m) << 10) + ((n) << 7))
+
+
+/* [CUSTOM] */
+#define DDR_PHY_DXNOEBDL(m, n)	(0x228 + ((m) << 10) + ((n) << 7))
+/* [8:0] rdqs_bdl [24:16]rdqs_cyc.
+phase shift of the Read DQS to create 90 degree delays*/
+#define DDR_PHY_DXNRDQSDLY(n)	(0x22C + ((n) << 7))
+/* [6:0] the delay value of delay applied on WDQS for write leveling */
+#define DDR_PHY_DXWDQSDLY(m, n)	(0x230 + ((m) << 10) + ((n) << 7))
+/* WR DQ phase BIT 12:8 */
+#define DDR_PHY_DXNWDQDLY(m, n)	(0x234 + ((m) << 10) + ((n) << 7))
+/* [CUSTOM] rddqs gating*/
+#define DDR_PHY_DXNRDQSGDLY(m, n)	(0x240 + ((m) << 10) + ((n) << 7))
+/* read boundary  right 8:0 left 24:16 */
+#define DDR_PHY_DXNRDBOUND(n)	(0x250 + ((n) << 7))
+/* write boundary  right 4:0 left 20:16 */
+#define DDR_PHY_DXNWDBOUND(n)	(0x254 + ((n) << 7))
+/* [5:0] DRAM VREF(DQ) training result */
+#define DDR_PHY_DVREFT_STATUS(n)	(0x270 + ((n) << 7))
+/* [4:0] Host PHY VREF(DQ) training result */
+#define DDR_PHY_HVREFT_STATUS(m, n)	(0x274 + ((m) << 10) + ((n) << 7))
+
+/* DDRPHY AC static register */
+#define DDR_PHY_CORNER_DETECTOR 0x104C  /* cfg of corner detector */
+#define DDR_PHY_ACPHYCTL4		0x1064  /* AC block PHY control register*/
+#define DDR_PHY_ACPHYCTL7		0x1070
+
+#define DDR_VREF_HOST_VAL_MAX             (0x1f)        /* 78.75%*VDDIO */
+#define DDR_VREF_HOST_VAL_MIN             (0x0)         /* 40.00%*VDDIO */
+
+/* register mask */
+#define PHY_BDL_MASK			0x7f	/* [6:0] */
+#define PHY_WDQS_PHASE_MASK		0xf     /* [11:8] */
+#define PHY_RDQS_BDL_MASK		0x1ff	/* [CUSTOM] [8:0] rdqsbdl*/
+#define PHY_RDQSG_PHASE_MASK	0x3f	/* [14:9] rdqsgphase */
+#define PHY_RDM_BDL_MASK		0x7f	/* [6:0] */
+/* hardware gate training result */
+#define PHY_INITSTATUS_GT_MASK		0x20
+#define PHY_SWTRLT_WL_MASK		0xf
+#define PHY_SWTRLT_GATE_MASK	0xf
+#define PHY_WDQ_PHASE_MASK		0x1f
+#define PHY_PHYINITCTRL_MASK		0x1	/* [15:0] all stat */
+/* Read Data Eye Calibration Error */
+#define PHY_PHYINITSTATUS_RDET_ERR	0x100
+#define PHY_ACPHY_DCLK_MASK		0x7	/* cp1p_dclk0 mask */
+#define PHY_ACPHY_DRAMCLK_MASK		0x1	/* halft_dramclk0 mask */
+#define PHY_VRFTRES_DVREF_MASK	0x3f /* [5:0] */
+#define PHY_VRFTRES_HVREF_MASK	0x1f /* [4:0] */
+#define PHY_VRFTRES_RXDIFFCAL_MASK	0xf /* [24:21] */
+#define PHY_ADDRPH_MASK         0x1f /* [20:16] */
+#define PHY_ACADDR_BDL_MASK		0x7f /* [6:0] */
+#define PHY_CATSWAPSEL_BIT_MASK  0xff
+#define PHY_CAT_PATTERN_MASK  0x3ff
+#define PHY_TRAINCTRL0_MASK		0xf /* [3:0] */
+#define PHY_DRAMCFG_TYPE_MASK   0xf /* [3:0] */
+#define PHY_OSC_START_MASK		0x1 /* [0] */
+#define PHY_OSC_RPT_VLD_MASK	0x1 /* [15] */
+#define PHY_OSC_CNT_RDATA_MASK	0xffff /* [31:16] */
+#define PHY_ZCODE_PDRV_MASK		0x3f   /* [21:16] */
+#define PHY_ACCTL_PDRV_LATCH_MASK	0x3f   /* [29:24] */
+
+/* register bit */
+#define PHY_MISC_UPDATE_BIT	19	/* [CUSTOM] delay config update bit */
+#define PHY_PHYCONN_RST_BIT	15	/* issue reset signal to PHY counter */
+#define PHY_RDQSG_PHASE_BIT	9	/* [CUSTOM] */
+#define PHY_RDQSG_TX_BDL_BIT	16	/* [22:16] rdqsgtxbdl */
+#define PHY_WDQS_PHASE_BIT	8
+#define PHY_WDQS_BDL_BIT	0
+#define PHY_WDQ_PHASE_BIT	8
+#define PHY_WDM_BDL_BIT		0
+/* [22:16] Write DQS Output Enable Delay Control */
+#define PHY_WDQSOE_BDL_BIT	16
+#define PHY_OEN_BDL_BIT		0
+/* Mode Register 1. Defines the MR3/MR9 of the mode register */
+#define PHY_MODEREG01_MR1_BIT	16
+/* Bit delay line setting of CS1 */
+#define PHY_ACCMD_CS0_BIT		0
+#define PHY_ACCMD_CS1_BIT		16
+#define PHY_ACPHY_DCLK0_BIT		6	/* [8:6] cp1p_dclk0 */
+#define PHY_ACPHY_DCLK1_BIT		9	/* [11:9] ck2p_dclk1 */
+#define PHY_ACPHY_DRAMCLK0_BIT		25	/* [25] halft_dramclk0 */
+#define PHY_ACPHY_DRAMCLK1_BIT		24	/* [24] halft_dramclk1 */
+#define PHY_ACPHY_DRAMCLK_EXT_BIT	3 /* [3] halft_dramclk0 */
+#define PHY_SWTMODE_SW_GTMODE_BIT	1 /* [1] SW gate training */
+#define PHY_ACADDRBDL_ADDR1_BIT	16 /* [16] ADDR1 delay line */
+#define PHY_VREFS_MRS_ENTER_BIT		31 /* [31] */
+#define PHY_OSC_RPT_VLD				15 /* [15] */
+#define PHY_OSC_CNT_RDATA_BIT		16 /* [31:16] */
+#define PHY_ZCODE_PDRV_BIT			16 /* [21:16] */
+#define PHY_ACCTL_PDRV_LATCH_BIT	24 /* [29:24] */
+#define PHY_AC_VDDQ_CAL_EN_BIT		8  /* [8] AC ZQ calibration enable */
+#define PHY_CFG_RX_AGE_COMPST_EN_BIT 31 /* Enable rdqs age compensation function */
+/* BDL register bit */
+#define PHY_BDL_DQ_BIT    0
+#define PHY_BDL_DQ0_BIT   0
+#define PHY_BDL_DQ1_BIT   8
+#define PHY_BDL_DQ2_BIT   16
+#define PHY_BDL_DQ3_BIT   24
+#define PHY_RDM_BDL_BIT   0
+#define PHY_RDQS_BDL_BIT  0
+
+/* value */
+#define PHY_PHYINITCTRL_DVREFT_SYNC	0x40000 /* DRAM VREF Synchronize */
+/* hw training item defined in PHYINITCTRL */
+#define PHY_PHYINITCTRL_CTL_CKE_BYPASS      (1 << 31)	/* PACK's CKE bypass function enable. */
+#define PHY_PHYINITCTRL_PIC_PHYUPD_REQ      (1 << 30)	/* PACK's DFI PHY UPDATAE request by SW. */
+#define PHY_PHYINITCTRL_PIC_TDQSST          (1 << 28)	/* TDQSS training Enable. */
+#define PHY_PHYINITCTRL_CFG_LPBK_COMPST_EN  (1 << 27)	/* RDQS/CK loopback delay compensate enable. */
+#define PHY_PHYINITCTRL_PIC_REFRET_SFT      (1 << 26)	/* Update delay line(switch op_sel) during tRFC. */
+#define PHY_PHYINITCTRL_PIC_REFRET_WR       (1 << 25)	/* Retraining with MPC write during tRFC. */
+#define PHY_PHYINITCTRL_PIC_REFRET_RD       (1 << 24)	/* Retraining with MPC read during tRFC. */
+#define PHY_PHYINITCTRL_JTMT_EN             (1 << 23)	/* PLL Jitter Meter Enable. */
+#define PHY_PHYINITCTRL_CST_EN              (1 << 22)	/* HW CS Traninig Enable. */
+#define PHY_PHYINITCTRL_ACDVREFS_EN         (1 << 21)	/* DRAM VREF(AC) Synchronize Operations. */
+#define PHY_PHYINITCTRL_ACHVREFT_EN         (1 << 20)	/* Host VREF(AC) Training Enable. */
+#define PHY_PHYINITCTRL_ACDVREFT_EN         (1 << 19)	/* DRAM VREF(AC) Training Enable. */
+#define PHY_PHYINITCTRL_DXDVREFS_EN         (1 << 18)	/* DRAM VREF(DQ) Synchronize Operations. */
+#define PHY_PHYINITCTRL_HVREFT_EN           (1 << 17)	/* Host VREF(DQ) Training Enable. */
+#define PHY_PHYINITCTRL_DVREFT_EN           (1 << 16)	/* DRAM VREF(DQ) Training Enable. */
+#define PHY_PHYINITCTRL_PHYCONN_RST         (1 << 15)	/* PHY Counter Reset. */
+#define PHY_PHYINITCTRL_PACK_RST            (1 << 14)	/* PACK Reset. */
+#define PHY_PHYINITCTRL_PHY_RST             (1 << 13)	/* PHY Reset. */
+#define PHY_PHYINITCTRL_DRAM_RST            (1 << 12)	/* DRAM Reset. */
+#define PHY_PHYINITCTRL_CAT_EN              (1 << 11)	/* HW CA Traninig Enable. */
+#define PHY_PHYINITCTRL_DRAM_INIT_EN        (1 << 10)	/* DRAM Initialization Enable. */
+#define PHY_PHYINITCTRL_WDET_EN             (1 << 9)	/* Write Data Eye Training Enable. */
+#define PHY_PHYINITCTRL_RDET_EN             (1 << 8)	/* Read Data Eye Training Enable. */
+#define PHY_PHYINITCTRL_WL2_EN              (1 << 7)	/* Second Write Leveling Enable. */
+#define PHY_PHYINITCTRL_GDST_EN             (1 << 6)	/* PHY Read Data Latch Train Enable. */
+#define PHY_PHYINITCTRL_GT_EN               (1 << 5)	/* Gate Training Enable. */
+#define PHY_PHYINITCTRL_WL_EN               (1 << 4)	/* Write Leveling Enable. */
+#define PHY_PHYINITCTRL_ZCAL_EN             (1 << 3)	/* Impedance Calibration Enable. */
+#define PHY_PHYINITCTRL_DLYMEAS_EN          (1 << 2)	/* Delay Measurement Enable. */
+#define PHY_PHYINITCTRL_PLL_INIT_EN         (1 << 1)	/* PLL Initialization Enable. */
+#define PHY_PHYINITCTRL_INIT_EN             (1 << 0)	/* PHY Initialization Enable. */
+
+#define PHY_HW_GP_PHY_RESET			(PHY_PHYINITCTRL_PHY_RST)
+#define PHY_HW_GP_CNT_RESET_START	(PHY_PHYINITCTRL_PHYCONN_RST)
+#define PHY_HW_GP_PLL				(PHY_PHYINITCTRL_PLL_INIT_EN | PHY_PHYINITCTRL_ZCAL_EN | PHY_PHYINITCTRL_DLYMEAS_EN)
+#define PHY_HW_GP_DRAM_RESET		(PHY_PHYINITCTRL_DRAM_RST | PHY_PHYINITCTRL_DRAM_INIT_EN)
+#define PHY_HW_GP_VREF_AC			(PHY_PHYINITCTRL_ACDVREFS_EN)
+#define PHY_HW_GP_CS				(PHY_PHYINITCTRL_CST_EN)
+#define PHY_HW_GP_VREF_DQ			(PHY_PHYINITCTRL_DVREFT_SYNC)
+#define PHY_HW_GP_NORMAL			(PHY_PHYINITCTRL_WL_EN \
+									| PHY_PHYINITCTRL_GT_EN \
+									| PHY_PHYINITCTRL_GDST_EN \
+									| PHY_PHYINITCTRL_WL2_EN \
+									| PHY_PHYINITCTRL_RDET_EN \
+									| PHY_PHYINITCTRL_WDET_EN \
+									| PHY_PHYINITCTRL_DVREFT_EN \
+									| PHY_PHYINITCTRL_HVREFT_EN \
+									| PHY_PHYINITCTRL_PIC_TDQSST)
+#define PHY_HW_GP_CNT_RESET_END	(PHY_PHYINITCTRL_PHYCONN_RST)
+
+/* RDQS range[0, 0x7f], middle value is 0x40, but it affected by
+   temperature, so middle value change to 0x30 */
+#define PHY_RDQS_MIDDLE_VAL		0x30
+/* DQ range[0, 0x7f],  middle value is 0x40, but it affected by
+   temperature, so middle value change to 0x30 */
+#define PHY_DQ_MIDDLE_VAL		0x30303030
+#define PHY_MISC_SCRAMB_DIS		0xfffeffff	/* scrambler disable */
+#define PHY_GATE_BDL_MAX        0xfe /* [6:0]rdqsg_bdl + [22:16]rdqsgtxbdl */
+#define PHY_DVRFTCTRL_PDAEN_EN	0x80000000 /* pda enable */
+/* [5] two cycle on address or command.(2T timing) */
+#define PHY_DRAMCFG_MA2T		0x20
+
+#define PHY_DRAMCFG_TYPE_DDR1 0x0     /* [2:0] 000 DDR1  */
+#define PHY_DRAMCFG_TYPE_DDR2 0x1     /* [2:0] 001 DDR2 */
+#define PHY_DRAMCFG_TYPE_DDR3 0x2     /* [2:0] 010 DDR3 */
+#define PHY_DRAMCFG_TYPE_DDR3L 0x3    /* [2:0] 011 DDR3L */
+#define PHY_DRAMCFG_TYPE_LPDDR1 0x4   /* [2:0] 100 LPDDR1 */
+#define PHY_DRAMCFG_TYPE_LPDDR2 0x5   /* [2:0] 101 LPDDR2 */
+#define PHY_DRAMCFG_TYPE_LPDDR3 0x5   /* [2:0] 101 LPDDR3 */
+#define PHY_DRAMCFG_TYPE_LPDDR4 0x6   /* [2:0] 110 LPDDR4 */
+#define PHY_DRAMCFG_TYPE_DDR4 0xa     /* [3] 1010 DDR4 */
+
+#define PHY_DMSEL_SWAPDFIBYTE   0xf8ffffff /* [24:26] No Swap */
+/* other */
+#define PHY_RDQSG_PHASE_STEP		2       /* gate training phase step. */
+#define PHY_GATE_PHASE_MARGIN		8       /* gate phase margin */
+#define PHY_DQ_BDL_LEVEL		128     /* [CUSTOM] DQ BDL range */
+#define PHY_DQ_BDL_MIDDLE		64 /* special middle DQ BDL value */
+#define PHY_RDQSG_PHASE_MAX		0x3c    /* RDQSG phase max value */
+#define PHY_ACPHY_CLK_MAX		0xf /* halft_dramclk0 + cp1p_dclk0 */
+#define PHY_PCODE_MIN			0x14
+#define PHY_PCODE_MAX			0x24
+/**
+ * DDR_BDL_PHASE_REL Calculation Method:
+ * 1. Calculation How many picosecond to one phase.
+ *    PICOSECOND : 1 second is (1000 * 1000 * 1000) picosecond
+ *    WAVE       : 1 cycle is 2
+ *    RATE       : DDR rate is 1600 Mbps, is (1600 * 1000) bps
+ *    PHASE      : 1 wave is 12 phase
+ *    phase = (((PICOSECOND * WAVE) / RATE) / PHASE)
+ *          = (((1000 * 1000 * 1000 * 2) / (1600 * 1000)) / 12)
+ *          = 104.17 ps.
+ * 2. Calculation How many bdl to one phase.
+ *    one BDL is 6 ps.
+ *    result = phase/bdl = 104.17 / 6 = 17.36 approximately equal to 17 ~= 16
+ * 3. 16 = 1 << 4, so the relation is 4.
+ */
+#ifndef DDR_BDL_PHASE_TRANSFORM
+/* [CUSTOM] one Phase equal how much BDL. 1 phase = 16 bdl */
+#define DDR_BDL_PHASE_TRANSFORM		16
+#endif
+#ifndef DDR_BDL_PHASE_REL
+/* [CUSTOM] relation between BDL and Phase. 1 phase = 16 bdl, 16 = 1 << 4 */
+#define DDR_BDL_PHASE_REL		4
+#endif
+
+#define DDR_VARIABLE_DECLARE(var) \
+	unsigned int var;
+
+#define DDR_VREF_GET_HOST_MAX(rank, val) \
+	do { \
+		if (0 == rank) \
+			val = PHY_VRFTRES_HVREF_MASK; \
+		else \
+			val = PHY_VRFTRES_RXDIFFCAL_MASK; \
+	} while (0)
+
+/* PHY t28 all byte use a same value */
+#define DDR_PHY_VREF_HOST_SET(base_phy, rank, bytenum, byte_index, val) \
+	do { \
+		unsigned int hvreft; \
+		hvreft = ddr_read(base_phy + DDR_PHY_HVREFT_STATUS(rank, byte_index)) \
+			& (~PHY_VRFTRES_HVREF_MASK); \
+		ddr_write(hvreft | val, base_phy + DDR_PHY_HVREFT_STATUS(rank, byte_index)); \
+		ddr_write(hvreft | val, base_phy + DDR_PHY_HVREFT_STATUS(rank, byte_index + 1)); \
+	} while (0)
+
+#define DDR_PHY_VREF_HOST_GET(base_phy, rank, byte_index, val) \
+	do { \
+		val = ddr_read(base_phy + DDR_PHY_HVREFT_STATUS(rank, byte_index)) \
+			& PHY_VRFTRES_HVREF_MASK; \
+	} while (0)
+
+#define DDR_PHY_VREF_HOST_DISPLAY \
+	{0, 0, DDR_PHY_HVREFT_STATUS(0, 0), 0, "Host Vref Byte0"}, \
+	{0, 1, DDR_PHY_HVREFT_STATUS(0, 1), 0, "Host Vref Byte1"}, \
+	{0, 2, DDR_PHY_HVREFT_STATUS(0, 2), 0, "Host Vref Byte2"}, \
+	{0, 3, DDR_PHY_HVREFT_STATUS(0, 3), 0, "Host Vref Byte3"},
+
+#define DDR_PHY_VREF_HOST_DISPLAY_RANK1 \
+	{1, 0, DDR_PHY_HVREFT_STATUS(1, 0), 0, "Host Vref Byte0"}, \
+	{1, 1, DDR_PHY_HVREFT_STATUS(1, 1), 0, "Host Vref Byte1"}, \
+	{1, 2, DDR_PHY_HVREFT_STATUS(1, 2), 0, "Host Vref Byte2"}, \
+	{1, 3, DDR_PHY_HVREFT_STATUS(1, 3), 0, "Host Vref Byte3"},
+
+#define DDR_PHY_VREF_HOST_DISPLAY_CMD(base_phy, rank, byte_num) \
+	do { \
+		unsigned int _i; \
+		for (_i = 0; _i < byte_num; _i++) { \
+			DDR_INFO("[%x = %x] Host Vref Byte(%x)", \
+				base_phy + DDR_PHY_HVREFT_STATUS(rank, _i), \
+				ddr_read(base_phy \
+				+ DDR_PHY_HVREFT_STATUS(rank, _i)), _i); \
+		} \
+	} while (0)
+
+/* DRAM vref operations */
+#define DDR_PHY_VREF_DRAM_SET(base_phy, val, byte_index) \
+	do { \
+		unsigned int dvrftctrl = \
+			ddr_read(base_phy + DDR_PHY_DVRFTCTRL); \
+		unsigned int dvreft = ddr_read(base_phy \
+			+ DDR_PHY_DVREFT_STATUS(byte_index)) \
+			& (~PHY_VRFTRES_DVREF_MASK); \
+		ddr_write(dvrftctrl | PHY_DVRFTCTRL_PDAEN_EN, \
+			base_phy + DDR_PHY_DVRFTCTRL); \
+		ddr_write(dvreft | val, \
+			base_phy + DDR_PHY_DVREFT_STATUS(byte_index)); \
+		ddr_write(PHY_PHYINITCTRL_DVREFT_SYNC \
+			| PHY_PHYINITCTRL_INIT_EN, \
+			base_phy + DDR_PHY_PHYINITCTRL); \
+		while (1) { \
+			if (!(ddr_read(base_phy + DDR_PHY_PHYINITCTRL) \
+				& PHY_PHYINITCTRL_INIT_EN)) \
+				break; \
+		} \
+		ddr_write(dvrftctrl & (~PHY_DVRFTCTRL_PDAEN_EN), \
+			base_phy + DDR_PHY_DVRFTCTRL); \
+	} while (0)
+
+#define DDR_PHY_VREF_DRAM_GET(base_phy, val, byte_index) \
+	{ \
+		val = ddr_read(base_phy + DDR_PHY_DVREFT_STATUS(byte_index)) \
+			& PHY_VRFTRES_DVREF_MASK; \
+	}
+
+#define DDR_PHY_VREF_DRAM_DISPLAY \
+	{0, 0, DDR_PHY_DVREFT_STATUS(0), 0, "DRAM Vref Byte0"}, \
+	{0, 1, DDR_PHY_DVREFT_STATUS(1), 0, "DRAM Vref Byte1"}, \
+	{0, 2, DDR_PHY_DVREFT_STATUS(2), 0, "DRAM Vref Byte2"}, \
+	{0, 3, DDR_PHY_DVREFT_STATUS(3), 0, "DRAM Vref Byte3"},
+
+#define DDR_PHY_VREF_DRAM_DISPLAY_CMD(base_phy, byte_num) \
+	do { \
+		unsigned int _i; \
+		for (_i = 0; _i < byte_num; _i++) { \
+			DDR_INFO("[%x = %x] DRAM Vref Byte(%x)", \
+				base_phy + DDR_PHY_DVREFT_STATUS(_i), \
+				ddr_read(base_phy \
+				+ DDR_PHY_DVREFT_STATUS(_i)), _i); \
+		} \
+	} while (0)
+
+/* phy t28 not support DCC training */
+#define DDR_PHY_DCC_DISPLAY
+#define DDR_PHY_DCC_DISPLAY_CMD(base_phy)
+
+/* lowpower ddr ca operations */
+#define DDR_PHY_ADDRPH_DISPLAY \
+	{0, 0, DDR_PHY_ADDRPHBOUND, 0, "CA Phase"},
+
+#define DDR_PHY_ADDRBDL_DISPLAY \
+	{0, 0, DDR_PHY_ACADDRBDL(0), 0, "CA BDL(0)"}, \
+	{0, 0, DDR_PHY_ACADDRBDL(1), 0, "CA BDL(1)"}, \
+	{0, 0, DDR_PHY_ACADDRBDL(2), 0, "CA BDL(2)"}, \
+	{0, 0, DDR_PHY_ACADDRBDL(3), 0, "CA BDL(3)"}, \
+	{0, 0, DDR_PHY_ACADDRBDL(4), 0, "CA BDL(4)"},
+
+#define DDR_PHY_ADDRPH_DISPLAY_CMD(base_phy) \
+	DDR_INFO("[%x = %x] CA Phase", \
+		base_phy + DDR_PHY_ADDRPHBOUND, \
+		ddr_read(base_phy + DDR_PHY_ADDRPHBOUND));
+
+#define DDR_PHY_ADDRBDL_DISPLAY_CMD(base_phy) \
+	do { \
+		unsigned int _i; \
+		for (_i = 0; _i < DDR_PHY_CA_REG_MAX; _i++) { \
+			DDR_INFO("[%x = %x] ACADDRBDL(%x)", \
+				base_phy + DDR_PHY_ACADDRBDL(_i), \
+				ddr_read(base_phy \
+				+ DDR_PHY_ACADDRBDL(_i)), _i); \
+		} \
+	} while (0)
+
+/* PHY t28 DDR4 RDQS synchronize to RDM */
+#define DDR_PHY_RDQS_SYNC_RDM(cfg, val) \
+	ddr_rdqs_sync(cfg, val)
+
+/* dqs swap */
+#define DDR_DQSSWAP_SAVE_FUNC(swapdfibyte_en, base_phy) \
+	do { \
+		swapdfibyte_en = \
+			ddr_read(base_phy + DDR_PHY_DMSEL); \
+		ddr_write(swapdfibyte_en & PHY_DMSEL_SWAPDFIBYTE, \
+			base_phy + DDR_PHY_DMSEL); \
+	} while (0)
+
+#define DDR_DQSSWAP_RESTORE_FUNC(swapdfibyte_en, base_phy) \
+	ddr_write(swapdfibyte_en, base_phy + DDR_PHY_DMSEL);
+
+
+#define DDR_PHY_SWITCH_RANK(base_phy, val) \
+	do { \
+		ddr_write((ddr_read(base_phy + DDR_PHY_TRAINCTRL0) & (~PHY_TRAINCTRL0_MASK)) | val, base_phy + DDR_PHY_TRAINCTRL0); \
+	} while (0)
+
+/* Define the union U_PHY_CATCONFIG */
+union U_PHY_CATCONFIG {
+	/* Define the struct bits */
+	struct {
+		unsigned int	ca_samp_num_bdl:4;   /* [3:0] */
+		unsigned int	ca_samp_num_ph:4;    /* [7:4] */
+		unsigned int	ca_trysamp_num:4;    /* [11:8] */
+		unsigned int	cat_rb_backtap:4;    /* [15:12] */
+		unsigned int	reserved:1;          /* [16] */
+		unsigned int	cat_openeye_en:1;    /* [17] */
+		unsigned int	cat_cat_phydq_sel:1; /* [18] */
+		unsigned int	cat_restore_en:1;    /* [19] */
+		unsigned int	cat_lb_backtap:4;    /* [23:20] */
+		unsigned int	sw_cat_mrw42:1;      /* [24] */
+		unsigned int	sw_cat_mrw48:1;      /* [25] */
+		unsigned int	sw_cat_mrw41:1;      /* [26] */
+		unsigned int	sw_cat_strobe:1;     /* [27] */
+		unsigned int	sw_cat_cke_high:1;   /* [28] */
+		unsigned int	sw_cat_cke_low:1;    /* [29] */
+		unsigned int	sw_cat_dqvalid:1;    /* [30] */
+		unsigned int	sw_cat_en:1;         /* [31] */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int	u32;
+};
+
+/* Define the union U_PHY_ADDRPHBOUND */
+union U_PHY_ADDRPHBOUND {
+	/* Define the struct bits */
+	struct {
+		unsigned int	addrph_a_right:5; /* [4:0] */
+		unsigned int	reserved0:3;      /* [7:5] */
+		unsigned int	addrph_a_left:5;  /* [12:8] */
+		unsigned int	reserved1:3;      /* [15:13] */
+		unsigned int	addrph_a:5;       /* [20:16] */
+		unsigned int	reserved2:3;      /* [23:21] */
+		unsigned int	addrph_a_ori:5;   /* [28:24] */
+		unsigned int	reserved3:3;      /* [31:29] */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int	u32;
+};
diff -uraN u-boot-2016.11/drivers/ddr/goke/default/ddr_training_boot.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/ddr_training_boot.c
--- u-boot-2016.11/drivers/ddr/goke/default/ddr_training_boot.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/ddr_training_boot.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,245 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "ddr_training_impl.h"
+#include "ddr_interface.h"
+
+#ifdef DDR_TRAINING_UART_CONFIG
+extern void uart_early_put_hex(int hex);
+extern void uart_early_putc(int chr);
+#endif
+
+/* Save DDR tarining result */
+void ddr_result_data_save(struct ddr_cfg_st *cfg, struct training_data *training)
+{
+	/* nothing to do when ddr training on power up */
+}
+
+void ddr_lpca_data_save(struct ca_data_st *data)
+{
+	/* nothing to do when ddr training on power up */
+}
+
+/* Get DDRT test address */
+unsigned int ddr_ddrt_get_test_addr(void)
+{
+	return DDRT_CFG_TEST_ADDR_BOOT;
+}
+
+#ifdef DDR_TRAINING_UART_CONFIG
+#ifdef DDR_TRAINING_MINI_LOG_CONFIG
+/* Display DDR training error when boot */
+void ddr_training_error(unsigned int mask, unsigned int phy, int byte, int dq)
+{
+	uart_early_putc('E');
+	uart_early_put_hex(mask);
+	uart_early_putc('P');
+	uart_early_put_hex(phy);
+	uart_early_putc('B');
+	uart_early_put_hex(byte);
+	uart_early_putc('D');
+	uart_early_put_hex(dq);
+}
+void ddr_training_start(void)
+{
+	uart_early_putc('D');
+	uart_early_putc('D');
+	uart_early_putc('R');
+}
+void ddr_training_suc(void)
+{
+	uart_early_putc('S');
+}
+#else
+/* Define string to print */
+void ddr_training_local_str(void)
+{
+	asm volatile(
+		"str_wl:\n\t"
+		".asciz \"WL\"\n\t"
+		".align 2\n\t"
+
+		"str_hwg:\n\t"
+		".asciz \"HWG\"\n\t"
+		".align 2\n\t"
+
+		"str_gate:\n\t"
+		".asciz \"Gate\"\n\t"
+		".align 2\n\t"
+
+		"str_ddrt:\n\t"
+		".asciz \"DDRT\"\n\t"
+		".align 2\n\t"
+
+		"str_hwrd:\n\t"
+		".asciz \"HWRD\"\n\t"
+		".align 2\n\t"
+
+		"str_mpr:\n\t"
+		".asciz \"MPR\"\n\t"
+		".align 2\n\t"
+
+		"str_dataeye:\n\t"
+		".asciz \"Dataeye\"\n\t"
+		".align 2\n\t"
+
+		"str_lpca:\n\t"
+		".asciz \"LPCA\"\n\t"
+		".align 2\n\t"
+
+		"str_err:\n\t"
+		".asciz \" Err:\"\n\t"
+		".align 2\n\t"
+
+		"str_phy:\n\t"
+		".asciz \"Phy\"\n\t"
+		".align 2\n\t"
+
+		"str_byte:\n\t"
+		".asciz \"Byte\"\n\t"
+		".align 2\n\t"
+
+		"str_dq:\n\t"
+		".asciz \"DQ\"\n\t"
+		".align 2\n\t"
+
+		"str_ddrtr_start:\n\t"
+		".asciz \"\r\\nDDRTR \"\n\t"
+		".align 2\n\t"
+
+		"str_ddrtr_suc:\n\t"
+		".asciz \"Suc\"\n\t"
+		".align 2\n\t"
+		);
+}
+
+/* Display DDR training error when boot */
+void ddr_training_error(unsigned int mask, unsigned int phy, int byte, int dq)
+{
+	uart_early_putc('\r');
+	uart_early_putc('\n');
+	/* error type */
+	switch (mask) {
+	case DDR_ERR_WL:
+		asm volatile(
+				"adr	r0, str_wl\n\t"
+				"bl	uart_early_puts"
+			    );
+		break;
+	case DDR_ERR_HW_GATING:
+		asm volatile(
+				"adr	r0, str_hwg\n\t"
+				"bl	uart_early_puts"
+			    );
+		break;
+	case DDR_ERR_GATING:
+		asm volatile(
+				"adr	r0, str_gate\n\t"
+				"bl	uart_early_puts"
+			    );
+		break;
+	case DDR_ERR_DDRT_TIME_OUT:
+		asm volatile(
+				"adr	r0, str_ddrt\n\t"
+				"bl	uart_early_puts"
+			    );
+		break;
+	case DDR_ERR_HW_RD_DATAEYE:
+		asm volatile(
+				"adr	r0, str_hwrd\n\t"
+				"bl	uart_early_puts"
+			    );
+		break;
+	case DDR_ERR_MPR:
+		asm volatile(
+				"adr	r0, str_mpr\n\t"
+				"bl	uart_early_puts"
+			    );
+		break;
+	case DDR_ERR_DATAEYE:
+		asm volatile(
+				"adr	r0, str_dataeye\n\t"
+				"bl	uart_early_puts"
+			    );
+		break;
+	case DDR_ERR_LPCA:
+		asm volatile(
+				"adr	r0, str_lpca\n\t"
+				"bl	uart_early_puts"
+			    );
+		break;
+	default:
+		break;
+	}
+
+	/* error string */
+	asm volatile(
+			"adr	r0, str_err\n\t"
+			"bl	uart_early_puts"
+		    );
+
+	/* error phy */
+	if (0 != phy) {
+		asm volatile(
+				"adr	r0, str_phy\n\t"
+				"bl	uart_early_puts"
+			    );
+		uart_early_put_hex(phy);
+	}
+
+	/* error byte */
+	if (-1 != byte) {
+		asm volatile(
+				"adr	r0, str_byte\n\t"
+				"bl	uart_early_puts"
+			    );
+		uart_early_put_hex(byte);
+	}
+
+	/* error dq */
+	if (-1 != dq) {
+		asm volatile(
+				"adr	r0, str_dq\n\t"
+				"bl	uart_early_puts"
+			    );
+		uart_early_put_hex(dq);
+	}
+}
+
+/* Display DDR training start when boot */
+void ddr_training_start(void)
+{
+	asm volatile(
+			"push	{lr}\n\t"
+			"adr	r0, str_ddrtr_start\n\t"
+			"bl	uart_early_puts\n\t"
+			"pop	{lr}"
+		    );
+}
+
+/* Display DDR training result when boot */
+void ddr_training_suc(void)
+{
+	asm volatile(
+			"push	{lr}\n\t"
+			"adr	r0, str_ddrtr_suc\n\t"
+			"bl	uart_early_puts\n\t"
+			"pop	{lr}"
+		    );
+}
+#endif /* DDR_TRAINING_CUT_CODE_CONFIG */
+#else
+void ddr_training_error(unsigned int mask, unsigned int phy, int byte, int dq)
+{
+	return;
+}
+void ddr_training_suc(void)
+{
+	return;
+}
+void ddr_training_start(void)
+{
+	return;
+}
+#endif /* DDR_TRAINING_UART_CONFIG */
diff -uraN u-boot-2016.11/drivers/ddr/goke/default/ddr_training_console.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/ddr_training_console.c
--- u-boot-2016.11/drivers/ddr/goke/default/ddr_training_console.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/ddr_training_console.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,254 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#include "ddr_interface.h"
+#include "ddr_training_impl.h"
+
+#define __ddr_training_console__
+#ifdef DDR_TRAINING_CONSOLE_CONFIG
+
+#define DDR_UART_BASE_REG               0x12090000
+#define UART_PL01x_FR                   0x18	 /*  Flag register (Read only). */
+#define UART_PL01x_FR_RXFE              0x10
+#define UART_PL01x_DR                   0x00	 /*  Data read or written from the interface. */
+#define UART_PL01x_ECR                  0x04	 /*  Error clear register (Write). */
+
+#define isprint(c)  ((c) >= ' ' && (c) <= '~')
+#define isspace(c)  ((c) == ' ' || ((c) >= '\t' && (c) <= '\r'))
+#define isdigit(c)  ((c) >= '0' && (c) <= '9')
+#define isxdigit(c)	(isdigit(c) \
+			  || ((c) >= 'A' && (c) <= 'F') \
+			  || ((c) >= 'a' && (c) <= 'f'))
+#define CMD(_p, _c0, _c1, _do_cmd) \
+	if (_p[0] == _c0 && _p[1] == _c1) { \
+		if (!_do_cmd(_p + 2)) \
+			continue; \
+	}
+
+/* DDR console get char */
+static int ddr_console_getc(void)
+{
+	unsigned int data;
+
+	/* Wait until there is data in the FIFO */
+	while (ddr_read(DDR_UART_BASE_REG + UART_PL01x_FR) & UART_PL01x_FR_RXFE) {
+	}
+
+	data = ddr_read(DDR_UART_BASE_REG + UART_PL01x_DR);
+
+	/* Check for an error flag */
+	if (data & 0xFFFFFF00) {
+		/* Clear the error */
+		ddr_write(0xFFFFFFFF, DDR_UART_BASE_REG + UART_PL01x_ECR);
+		return -1;
+	}
+	return (int) data;
+}
+
+/* DDR read line */
+static char *ddr_readline(char *str, int len)
+{
+	unsigned int c;
+	char *p = str;
+	while (len > 0) {
+		c = ddr_console_getc();
+		switch (c) {
+		case '\r':
+		case '\n':
+			*p = '\0';
+			DDR_PUTC('\r');
+			DDR_PUTC('\n');
+			return str;
+		case 0x08:
+		case 0x7F:
+			if (p > str) {
+				p--;
+				len++;
+				DDR_PUTC('\b');
+				DDR_PUTC(' ');
+				DDR_PUTC('\b');
+			}
+			break;
+		default:
+			if (isprint(c)) {
+				(*p++) = (char)c;
+				len--;
+				DDR_PUTC(c);
+			}
+			break;
+		}
+	}
+	(*--p) = '\0';
+	return str;
+}
+
+/* HEX to INT */
+static int hex2int(char **ss, unsigned int *n)
+{
+	unsigned char *s = (unsigned char *)(*ss);
+
+	while (isspace(*s)) s++;
+
+	if (!(*s))
+		return -1;
+
+	if (s[0] == '0' && (s[1] == 'x' || s[1] == 'X'))
+		s += 2;
+
+	for ((*n) = 0; isxdigit(*s); s++) {
+		(*n) = ((*n) << 4);
+		if ((*s) >= '0' && (*s) <= '9')
+			(*n) |= ((*s) - '0');
+		else if ((*s) >= 'a' && (*s) <= 'f')
+			(*n) |= ((*s) + 10 - 'a');
+		else if ((*s) >= 'A' && (*s) <= 'F')
+			(*n) |= ((*s) + 10 - 'A');
+	}
+
+	if (isspace(*s) || !(*s)) {
+		while (isspace(*s)) s++;
+		(*ss) = (char *)s;
+		return 0;
+	}
+
+	return -2;
+}
+/**
+ * DDR do memory write.
+ * mw address value [count]
+ */
+static int ddr_do_memory_write(char *cmd)
+{
+	unsigned int address;
+	unsigned int value;
+	unsigned int count = 4;
+
+	if (hex2int(&cmd, &address))
+		return -1;
+
+	if (hex2int(&cmd, &value))
+		return -1;
+
+	if ((*cmd) && hex2int(&cmd, &count))
+		return -1;
+
+	if (address & 0x03 || count & 0x03) {
+		DDR_INFO("parameter should align with 4 bytes.\n");
+		return -1;
+	}
+	for (;count > 0; count -= 4, address += 4)
+		ddr_write(value, address);
+	return 0;
+}
+/**
+ * DDR do memory display.
+ * md address [count]
+ */
+static int ddr_do_memory_display(char *cmd)
+{
+	unsigned int ix;
+	unsigned int loop;
+	unsigned int address;
+	unsigned int count = 64;
+
+	if (hex2int(&cmd, &address))
+		return -1;
+
+	if ((*cmd) && hex2int(&cmd, &count))
+		return -1;
+
+	if (count < 4)
+		count = 4;
+
+	address &= ~0x03;
+	loop = (count & ~0x03);
+
+	while (loop > 0) {
+
+		DDR_PUTC('0');
+		DDR_PUTC('x');
+		DDR_PUT_HEX(address);
+		DDR_PUTC(':');
+
+		for (ix = 0;
+			ix < 4 && loop > 0;
+			ix++, loop -= 4, address += 4) {
+
+			DDR_PUTC(' '); DDR_PUT_HEX(ddr_read(address));
+		}
+		DDR_PUTC('\r');
+		DDR_PUTC('\n');
+	}
+	return 0;
+}
+
+#ifdef DDR_TRAINING_CMD
+extern struct ddr_training_result_st ddrt_result_sram;
+#endif
+static int ddr_do_sw_training(char *cmd)
+{
+	int result;
+	struct ddr_cfg_st ddr_cfg;
+	struct ddr_cfg_st *cfg = &ddr_cfg;
+
+	ddr_training_cfg_init(cfg);
+#ifdef DDR_TRAINING_CMD
+	cfg->res_st = (void *)&ddrt_result_sram;
+#endif
+	result = ddr_training_all(cfg);
+
+	result += ddr_dcc_training_func(cfg);
+
+	return 0;
+}
+
+static int ddr_do_hw_training(char *cmd)
+{
+	int result;
+
+	result = ddr_hw_training_func();
+
+	return 0;
+}
+
+/* Do DDR training console if sw training or hw training fail */
+static int ddr_training_console(void *args)
+{
+	char str[256];
+	char *p = NULL;
+	unsigned int cmd=0;
+
+	while (1) {
+		DDR_PUTC('d');
+		DDR_PUTC('d');
+		DDR_PUTC('r');
+		DDR_PUTC('#');
+
+		p = ddr_readline(str, sizeof(str));
+
+		while (isspace(*p)) p++;
+		if (p[0] == 'q')
+			break;
+		CMD(p, 'm', 'w', ddr_do_memory_write) else
+		CMD(p, 'm', 'd', ddr_do_memory_display) else
+		CMD(p, 's', 'w', ddr_do_sw_training) else
+		CMD(p, 'h', 'w', ddr_do_hw_training)
+
+	}
+
+	return 0;
+}
+#else
+static int ddr_training_console(void *args)
+{
+	DDR_WARNING("Not support DDR training console.");
+	return 0;
+}
+#endif /* DDR_TRAINING_CONSOLE_CONFIG */
+
+int ddr_training_console_if(void *args)
+{
+	return DDR_TRAINING_CONSOLE(args);
+}
diff -uraN u-boot-2016.11/drivers/ddr/goke/default/ddr_training_ctl.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/ddr_training_ctl.c
--- u-boot-2016.11/drivers/ddr/goke/default/ddr_training_ctl.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/ddr_training_ctl.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,305 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "ddr_interface.h"
+#include "ddr_training_impl.h"
+
+#ifdef DDR_SW_TRAINING_FUNC_PUBLIC
+#ifdef DDR_TRAINING_CUT_CODE_CONFIG
+/**
+ * Cut ddr training control code for less SRAM.
+ * Support DDRC500.
+ * Support DDRC510 with one PHY.
+ */
+int ddr_sw_training_func(void)
+{
+	struct ddr_cfg_st ddr_cfg;
+	struct ddr_cfg_st *cfg = &ddr_cfg;
+
+	unsigned int base_dmc = DDR_REG_BASE_DMC0;
+	unsigned int base_phy = DDR_REG_BASE_PHY0;
+	int result = 0;
+	unsigned int auto_ref_timing = ddr_read(base_dmc + DDR_DMC_TIMING2);
+	unsigned int misc_scramb = ddr_read(base_phy + DDR_PHY_MISC);
+	unsigned int dramcfg_ma2t = ddr_read(base_phy + DDR_PHY_DRAMCFG)
+		& PHY_DRAMCFG_MA2T;
+	unsigned int acphyctl;
+
+	/* Static register have to read two times to get the right value. */
+	acphyctl = ddr_read(base_phy + DDR_PHY_ACPHYCTL4);
+	acphyctl = ddr_read(base_phy + DDR_PHY_ACPHYCTL4);
+
+	DDR_VARIABLE_DECLARE(swapdfibyte_en);
+
+	/* check sw ddr training enable */
+	if (DDR_BYPASS_ALL_MASK == ddr_read(DDR_REG_BASE_SYSCTRL
+		+ SYSCTRL_DDR_TRAINING_CFG))
+		return 0;
+
+	ddr_training_start();
+	ddr_training_cfg_init(cfg);
+
+#ifdef DDR_TRAINING_STAT_CONFIG
+	/* clear stat register */
+	ddr_write(0x0, DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_STAT);
+#endif
+
+	/* disable scramb */
+	ddr_write(misc_scramb & PHY_MISC_SCRAMB_DIS,
+		base_phy + DDR_PHY_MISC);
+
+	/* disable rdqs swap */
+	DDR_DQSSWAP_SAVE_FUNC(swapdfibyte_en, base_phy);
+
+	/* check hardware gating */
+	if (ddr_read(base_phy + DDR_PHY_PHYINITSTATUS)
+		& PHY_INITSTATUS_GT_MASK) {
+		DDR_FATAL("PHY[%x] hw gating fail.", base_phy);
+		ddr_training_stat(DDR_ERR_HW_GATING,
+			base_phy, -1, -1);
+	}
+
+#ifdef DDR_LPCA_TRAINING_CONFIG
+	/* lpca */
+	if (!ddr_training_check_bypass(cfg, DDR_BYPASS_LPCA_MASK)
+		&& (PHY_DRAMCFG_TYPE_LPDDR3 ==
+		(ddr_read(base_phy + DDR_PHY_DRAMCFG)
+		& PHY_DRAMCFG_TYPE_LPDDR3))) {
+		/* disable auto refresh */
+		ddr_training_set_timing(base_dmc,
+			auto_ref_timing & DMC_AUTO_TIMING_DIS);
+
+		result += ddr_lpca_training(cfg);
+
+		/* enable auto refresh */
+		ddr_training_set_timing(base_dmc, auto_ref_timing);
+	}
+#endif
+
+#ifdef DDR_WL_TRAINING_CONFIG
+	/* write leveling */
+	if (!ddr_training_check_bypass(cfg, DDR_BYPASS_WL_MASK)) {
+		/* disable auto refresh */
+		ddr_training_set_timing(base_dmc,
+			auto_ref_timing & DMC_AUTO_TIMING_DIS);
+		result += ddr_write_leveling(cfg);
+		/* enable auto refresh */
+		ddr_training_set_timing(base_dmc, auto_ref_timing);
+	}
+#endif
+
+#ifdef DDR_DATAEYE_TRAINING_CONFIG
+	/* dataeye */
+	if (!ddr_training_check_bypass(cfg, DDR_BYPASS_DATAEYE_MASK)) {
+		ddr_training_switch_axi(cfg);
+		ddr_ddrt_init(cfg, DDR_DDRT_MODE_DATAEYE);
+		result += ddr_dataeye_training(cfg);
+	}
+#endif
+
+#ifdef DDR_HW_TRAINING_CONFIG
+	/* hardware read */
+	if (result && !ddr_training_check_bypass(cfg, DDR_BYPASS_HW_MASK)) {
+		if (!dramcfg_ma2t) /* set 1T */
+			ddr_write(0x0, base_phy + DDR_PHY_ACPHYCTL4);
+
+		result = ddr_hw_dataeye_read(cfg);
+		if (!dramcfg_ma2t) /* restore */
+			ddr_write(acphyctl, base_phy + DDR_PHY_ACPHYCTL4);
+
+		result += ddr_dataeye_training(cfg);
+	}
+#endif
+
+#ifdef DDR_MPR_TRAINING_CONFIG
+	/* mpr */
+	if (result && !ddr_training_check_bypass(cfg, DDR_BYPASS_MPR_MASK)) {
+		result = ddr_mpr_training(cfg);
+		result += ddr_dataeye_training(cfg);
+	}
+#endif
+
+#ifdef DDR_GATE_TRAINING_CONFIG
+	/* gate */
+	if (!ddr_training_check_bypass(cfg, DDR_BYPASS_GATE_MASK)) {
+		ddr_training_switch_axi(cfg);
+		ddr_ddrt_init(cfg, DDR_DDRT_MODE_GATE);
+		/* disable auto refresh */
+		ddr_training_set_timing(base_dmc,
+			auto_ref_timing & DMC_AUTO_TIMING_DIS);
+
+		if (!dramcfg_ma2t) /* set 1T */
+			ddr_write(0x0, base_phy + DDR_PHY_ACPHYCTL4);
+
+		result += ddr_gate_training(cfg);
+
+		/* enable auto refresh */
+		ddr_training_set_timing(base_dmc, auto_ref_timing);
+
+		if (!dramcfg_ma2t) /* restore */
+			ddr_write(acphyctl, base_phy + DDR_PHY_ACPHYCTL4);
+	}
+#endif
+
+#ifdef DDR_VREF_TRAINING_CONFIG
+	if (!ddr_training_check_bypass(cfg, DDR_BYPASS_VREF_MASK)) {
+		ddr_training_switch_axi(cfg);
+		ddr_ddrt_init(cfg, DDR_DDRT_MODE_DATAEYE);
+		result += ddr_vref_training(cfg);
+	}
+#endif
+
+	/* restore scramb */
+	ddr_write(misc_scramb, base_phy + DDR_PHY_MISC);
+
+	/* restore rdqs swap */
+	DDR_DQSSWAP_RESTORE_FUNC(swapdfibyte_en, base_phy);
+
+	if (!result)
+		ddr_training_suc();
+	return result;
+}
+#else
+int ddr_training_boot_func(struct ddr_cfg_st *cfg)
+{
+	int result = 0;
+
+	/* check hardware gating */
+	if (ddr_read(cfg->cur_phy + DDR_PHY_PHYINITSTATUS)
+		& PHY_INITSTATUS_GT_MASK) {
+		DDR_FATAL("PHY[%x] hw gating fail.", cfg->cur_phy);
+		ddr_training_stat(DDR_ERR_HW_GATING,
+			cfg->cur_phy, -1, -1);
+	}
+
+	/* lpca */
+	result = ddr_lpca_training_func(cfg);
+	/* write leveling */
+	result += ddr_wl_func(cfg);
+	/* dataeye/gate/vref need switch axi */
+	/* dataeye */
+	result += ddr_dataeye_training_func(cfg);
+#ifdef DDR_HW_TRAINING_CONFIG
+	/* hardware read */
+	if (result && !ddr_training_check_bypass(cfg, DDR_BYPASS_HW_MASK)) {
+		struct tr_relate_reg relate_reg_ac;
+		ddr_training_save_reg(cfg, &relate_reg_ac,
+			DDR_BYPASS_HW_MASK);
+		result = ddr_hw_dataeye_read(cfg);
+		ddr_training_restore_reg(cfg, &relate_reg_ac);
+		cfg->adjust = DDR_DATAEYE_ABNORMAL_ADJUST;
+		result += ddr_dataeye_training(cfg);
+	}
+#endif
+	/* mpr */
+	result += ddr_mpr_training_func(cfg);
+	/* gate */
+	result += ddr_gating_func(cfg);
+	/* vref */
+	result += ddr_vref_training_func(cfg);
+
+	return result;
+}
+
+/* Support DDRC510 with two PHY */
+int ddr_sw_training_func(void)
+{
+	struct ddr_cfg_st ddr_cfg;
+	struct ddr_cfg_st *cfg = &ddr_cfg;
+	struct tr_relate_reg reg;
+	int result = 0;
+
+#ifdef SYSCTRL_DDR_TRAINING_VERSION_FLAG
+	/* DDR training version flag */
+	unsigned int tmp_reg = ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_VERSION_FLAG);
+	tmp_reg = (tmp_reg & 0xffff0000) | DDR_VERSION;
+	ddr_write(tmp_reg, DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_VERSION_FLAG);
+#endif
+
+	/* check sw ddr training enable */
+	if (DDR_BYPASS_ALL_MASK == ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_CFG)
+#ifdef SYSCTRL_DDR_TRAINING_CFG_SEC
+	&& DDR_BYPASS_ALL_MASK == ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_CFG_SEC)
+#endif
+	)
+		return 0;
+
+	ddr_training_start();
+
+	/* save customer reg */
+	ddr_boot_cmd_save_func(&reg);
+
+#ifdef DDR_TRAINING_STAT_CONFIG
+	/* clear stat register */
+	ddr_write(0x0, DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_STAT);
+#endif
+
+	ddr_training_cfg_init(cfg);
+	cfg->cmd_st = 0;
+
+	result = ddr_training_all(cfg);
+	result += ddr_dcc_training_func(cfg);
+
+	if (!result)
+		ddr_training_suc();
+	else
+		ddr_training_console_if(0);
+
+	/* restore customer reg */
+	ddr_boot_cmd_restore_func(&reg);
+
+	return result;
+}
+#endif /* DDR_TRAINING_CUT_CODE_CONFIG */
+#endif /* DDR_SW_TRAINING_FUNC_PUBLIC */
+
+#ifdef DDR_PCODE_TRAINING_CONFIG
+int ddr_pcode_training_func(void)
+{
+	struct ddr_cfg_st ddr_cfg;
+	struct ddr_cfg_st *cfg = &ddr_cfg;
+
+	ddr_training_cfg_init(cfg);
+	return ddr_pcode_training(cfg);
+}
+#else
+int ddr_pcode_training_func(void)
+{
+	DDR_WARNING("Not support DDR pcode training.");
+	return 0;
+}
+#endif
+
+#ifdef DDR_HW_TRAINING_CONFIG
+int ddr_hw_training_func(void)
+{
+	struct ddr_cfg_st ddr_cfg;
+	struct ddr_cfg_st *cfg = &ddr_cfg;
+
+	ddr_training_cfg_init(cfg);
+	return ddr_hw_training(cfg);
+}
+#else
+int ddr_hw_training_func(void)
+{
+	DDR_WARNING("Not support DDR HW training.");
+	return 0;
+}
+#endif /* DDR_HW_TRAINING_CONFIG */
+
+int ddr_sw_training_if(void)
+{
+	return DDR_SW_TRAINING_FUNC();
+}
+
+int ddr_hw_training_if(void)
+{
+	return DDR_HW_TRAINING_FUNC();
+}
+
+int ddr_pcode_training_if(void)
+{
+	return DDR_PCODE_TRAINING_FUNC();
+}
+
diff -uraN u-boot-2016.11/drivers/ddr/goke/default/ddr_training_impl.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/ddr_training_impl.c
--- u-boot-2016.11/drivers/ddr/goke/default/ddr_training_impl.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/ddr_training_impl.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,4372 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "ddr_training_impl.h"
+#include "ddr_interface.h"
+#include <stdint.h>
+
+#define __common__
+
+unsigned int ddr_read(unsigned addr)
+{
+	return (*(volatile unsigned int *)((uintptr_t)(addr)));
+}
+
+void ddr_write(unsigned val, unsigned addr)
+{
+	(*(volatile unsigned int *)((uintptr_t)(addr))) = (val);
+}
+
+void* ddrtr_memcpy(void *dst, const void *src, unsigned int len)
+{
+	const char *s = src;
+	char *d = dst;
+
+	while (len--)
+		*d++ = *s++;
+	return dst;
+}
+
+void* ddrtr_memset(void *b, int c, unsigned int len)
+{
+	char *bp = b;
+
+	while (len--)
+		*bp++ = (unsigned char)c;
+	return b;
+}
+
+int ddr_training_by_dmc(struct ddr_cfg_st *cfg)
+{
+	if (cfg->cmd_st) {
+#ifdef DDR_TRAINING_CMD
+		return ddr_training_cmd_func(cfg);
+#endif
+	} else {
+		return ddr_training_boot_func(cfg);
+	}
+	return 0;
+}
+
+int ddr_training_by_rank(struct ddr_cfg_st *cfg)
+{
+	int result = 0;
+	int i;
+
+	DDR_PHY_SWITCH_RANK(cfg->cur_phy, cfg->rank_idx);
+
+	for (i = 0; i < cfg->phy[cfg->phy_idx].dmc_num; i++) {
+		cfg->dmc_idx = i;
+		cfg->cur_dmc = cfg->phy[cfg->phy_idx].dmc[i].addr;
+		cfg->cur_pattern = cfg->phy[cfg->phy_idx].dmc[i].ddrt_pattern;
+		result += ddr_training_by_dmc(cfg);
+	}
+	return result;
+}
+
+int ddr_training_by_phy(struct ddr_cfg_st *cfg)
+{
+	int result = 0;
+	int i;
+	unsigned int phy_mask = 1 << (cfg->phy_idx);
+	unsigned int rank_num = cfg->phy[cfg->phy_idx].rank_num;
+	for (i = 0; i < rank_num; i++) {
+		cfg->rank_idx = i;
+		cfg->cur_item = cfg->phy[cfg->phy_idx].rank[i].item;
+		if (ddr_training_check_bypass(cfg, phy_mask))
+			continue;
+		result += ddr_training_by_rank(cfg);
+	}
+	return result;
+}
+
+int ddr_training_all(struct ddr_cfg_st *cfg)
+{
+	int result = 0;
+	int i;
+	for (i = 0; i < cfg->phy_num; i++) {
+		cfg->phy_idx = i;
+		cfg->cur_phy = cfg->phy[i].addr;
+		result += ddr_training_by_phy(cfg);
+	}
+	return result;
+}
+
+/* DDR training phy/dmc/dram_type config init */
+void ddr_training_cfg_set_dmc(struct ddr_cfg_st *cfg)
+{
+	unsigned int ddrt_pattern;
+
+	if (PHY_DRAMCFG_TYPE_LPDDR4 == cfg->phy[0].dram_type) {
+		cfg->phy[0].dmc_num = 2;
+		ddrt_pattern = ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDRT_PATTERN);
+		cfg->phy[0].dmc[0].addr = DDR_REG_BASE_DMC0;
+		cfg->phy[0].dmc[0].ddrt_pattern = ddrt_pattern & 0xffff;
+		cfg->phy[0].dmc[0].byte_num = ddr_phy_get_byte_num(DDR_REG_BASE_DMC0);
+		cfg->phy[0].dmc[1].addr = DDR_REG_BASE_DMC1;
+		cfg->phy[0].dmc[1].ddrt_pattern = ddrt_pattern >> 16;
+		cfg->phy[0].dmc[1].byte_num = ddr_phy_get_byte_num(DDR_REG_BASE_DMC1);
+		cfg->phy[0].total_byte_num = cfg->phy[0].dmc[0].byte_num + cfg->phy[0].dmc[1].byte_num;
+	} else {
+		cfg->phy[0].dmc_num = 1;
+		cfg->phy[0].dmc[0].addr = DDR_REG_BASE_DMC0;
+		cfg->phy[0].dmc[0].ddrt_pattern = ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDRT_PATTERN);
+		cfg->phy[0].dmc[0].byte_num = ddr_phy_get_byte_num(DDR_REG_BASE_DMC0);
+		cfg->phy[0].total_byte_num = cfg->phy[0].dmc[0].byte_num;
+	}
+	DDR_INFO("phy[0] total_byte_num[%x] dram_type[%x]", cfg->phy[0].total_byte_num, cfg->phy[0].dram_type);
+
+#ifdef DDR_REG_BASE_PHY1
+	if (PHY_DRAMCFG_TYPE_LPDDR4 == cfg->phy[1].dram_type) {
+		cfg->phy[1].dmc_num = 2;
+		ddrt_pattern = ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDRT_PATTERN_SEC);
+		cfg->phy[1].dmc[0].addr = DDR_REG_BASE_DMC2;
+		cfg->phy[1].dmc[0].ddrt_pattern = ddrt_pattern & 0xffff;
+		cfg->phy[1].dmc[0].byte_num = ddr_phy_get_byte_num(DDR_REG_BASE_DMC2);
+		cfg->phy[1].dmc[1].addr = DDR_REG_BASE_DMC3;
+		cfg->phy[1].dmc[1].ddrt_pattern = ddrt_pattern >> 16;
+		cfg->phy[1].dmc[1].byte_num = ddr_phy_get_byte_num(DDR_REG_BASE_DMC3);
+		cfg->phy[1].total_byte_num = cfg->phy[1].dmc[0].byte_num + cfg->phy[1].dmc[1].byte_num;
+	} else {
+		cfg->phy[1].dmc_num = 1;
+		cfg->phy[1].dmc[0].addr = DDR_REG_BASE_DMC1;
+		cfg->phy[1].dmc[0].ddrt_pattern = ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDRT_PATTERN_SEC);
+		cfg->phy[1].dmc[0].byte_num = ddr_phy_get_byte_num(DDR_REG_BASE_DMC1);
+		cfg->phy[1].total_byte_num = cfg->phy[1].dmc[0].byte_num;
+	}
+	DDR_INFO("phy[1] total_byte_num[%x] dram_type[%x]", cfg->phy[1].total_byte_num, cfg->phy[1].dram_type);
+#endif
+}
+void ddr_training_cfg_set_rank(struct ddr_cfg_st *cfg)
+{
+	cfg->phy[0].rank_num = 1;
+	cfg->phy[0].rank[0].item = ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_CFG);
+	cfg->phy[0].rank[0].item_hw = ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_HW_PHY0_RANK0);
+
+	cfg->phy[0].rank[1].item = ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_CFG_SEC);
+	cfg->phy[0].rank[1].item_hw = ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_HW_PHY0_RANK1);
+
+	if (ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_HW_PHY0_RANK1)) {
+		cfg->phy[0].rank_num = 2;
+	}
+
+	DDR_INFO("Rank number PHY0 [%x]", cfg->phy[0].rank_num);
+	DDR_INFO("HW training item PHY0[%x = %x][%x = %x]",
+		(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_HW_PHY0_RANK0), cfg->phy[0].rank[0].item_hw,
+		(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_HW_PHY0_RANK1), cfg->phy[0].rank[1].item_hw);
+
+#ifdef DDR_REG_BASE_PHY1
+	cfg->phy[1].rank_num = 1;
+	cfg->phy[1].rank[0].item = ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_CFG);
+	cfg->phy[1].rank[0].item_hw = ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_HW_PHY1_RANK0);
+
+	cfg->phy[1].rank[1].item = ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_CFG_SEC);
+	cfg->phy[1].rank[1].item_hw = ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_HW_PHY1_RANK1);
+
+
+	if (ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_HW_PHY1_RANK1)) {
+		cfg->phy[1].rank_num = 2;
+	}
+
+	DDR_INFO("Rank number PHY1[%x]", cfg->phy[1].rank_num);
+	DDR_INFO("HW training item PHY1[%x = %x][%x = %x]",
+		(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_HW_PHY1_RANK0), cfg->phy[1].rank[0].item_hw,
+		(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_HW_PHY1_RANK1), cfg->phy[1].rank[1].item_hw);
+#endif
+
+	DDR_INFO("SW training item Rank0[%x = %x] Rank1[%x = %x]",
+		(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_CFG), cfg->phy[0].rank[0].item,
+		(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_CFG_SEC), cfg->phy[0].rank[1].item);
+}
+
+void ddr_training_cfg_set_phy(struct ddr_cfg_st *cfg)
+{
+	cfg->phy_num = DDR_PHY_NUM;
+	cfg->phy[0].addr = DDR_REG_BASE_PHY0;
+	cfg->phy[0].dram_type = ddr_read(DDR_REG_BASE_PHY0 + DDR_PHY_DRAMCFG)
+		& PHY_DRAMCFG_TYPE_MASK;
+#ifdef DDR_REG_BASE_PHY1
+	cfg->phy[1].addr = DDR_REG_BASE_PHY1;
+	cfg->phy[1].dram_type = ddr_read(DDR_REG_BASE_PHY1 + DDR_PHY_DRAMCFG)
+		& PHY_DRAMCFG_TYPE_MASK;
+#endif
+}
+
+void ddr_training_cfg_init(struct ddr_cfg_st *cfg)
+{
+	ddrtr_memset(cfg, 0, sizeof(struct ddr_cfg_st));
+	ddr_training_cfg_set_phy(cfg);
+	ddr_training_cfg_set_dmc(cfg);
+	ddr_training_cfg_set_rank(cfg);
+}
+
+/* 2GHz CPU run 2000 "nop" in 1 ns */
+static inline void ddr_training_delay(unsigned int cnt)
+{
+	while (cnt--)
+		asm("nop");
+}
+
+/* set auto refresh */
+void ddr_training_set_timing(unsigned int base_dmc, unsigned int timing)
+{
+	ddr_training_delay(DDR_AUTO_TIMING_DELAY);
+	ddr_write(timing, base_dmc + DDR_DMC_TIMING2);
+	/* need to delay 1 ns */
+	ddr_training_delay(DDR_AUTO_TIMING_DELAY);
+}
+
+#ifdef DDR_TRAINING_STAT_CONFIG
+/* Save training result in stat register */
+static void ddr_training_save(unsigned int mask, unsigned int phy,
+			      int byte, int dq)
+{
+	unsigned int stat;
+	unsigned int phy_index;
+
+	stat = ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_STAT);
+	/* only record the first error */
+	if (stat)
+		return;
+
+	stat = mask;
+
+	if (0 != phy) {
+		phy_index = (DDR_REG_BASE_PHY0 == phy ?
+			DDR_ERR_PHY0 : DDR_ERR_PHY1);
+		stat |= phy_index;
+	}
+
+	if (-1 != byte)
+		stat |= ((unsigned int)byte << DDR_ERR_BYTE_BIT);
+
+	if (-1 != dq)
+		stat |= ((unsigned int)dq << DDR_ERR_DQ_BIT);
+
+	ddr_write(stat, DDR_REG_BASE_SYSCTRL + SYSCTRL_DDR_TRAINING_STAT);
+}
+#endif
+
+/* Record error code in register */
+void ddr_training_stat(unsigned int mask, unsigned int phy, int byte, int dq)
+{
+	ddr_training_error(mask, phy, byte, dq);
+#ifdef DDR_TRAINING_STAT_CONFIG
+	ddr_training_save(mask, phy, byte, dq);
+#endif
+}
+
+/* Check DDR training item whether by pass */
+int ddr_training_check_bypass(struct ddr_cfg_st *cfg, unsigned int mask)
+{
+	/* training item disable */
+	if ((cfg->cur_item) & mask) {
+		DDR_DEBUG("DDR training [%x] is disable, rank[%x] cfg[%x]",
+			mask, cfg->rank_idx, cfg->cur_item);
+		return DDR_TRUE;
+	} else {
+		return DDR_FALSE;
+	}
+}
+
+#if !defined(DDR_TRAINING_CUT_CODE_CONFIG) || defined(DDR_TRAINING_CMD)
+/**
+ * Check PHY whether disable.
+ * DDR_TRUE: PHY is disable.
+ * DDR_FALSE: PHY is not disable.
+ */
+int ddr_training_phy_disable(int index)
+{
+	return 0;
+}
+
+/* Save register value before training */
+void ddr_training_save_reg(struct ddr_cfg_st *cfg,
+			   struct tr_relate_reg *relate_reg, unsigned int mask)
+{
+	unsigned int base_dmc = cfg->cur_dmc;
+	unsigned int base_phy = cfg->cur_phy;
+
+	/* save reg value */
+	relate_reg->auto_ref_timing =
+		ddr_read(base_dmc + DDR_DMC_TIMING2);
+	relate_reg->power_down =
+		ddr_read(base_dmc + DDR_DMC_CFG_PD);
+	relate_reg->misc_scramb = ddr_read(base_phy + DDR_PHY_MISC);
+	/* Static register have to read two times to get the right value. */
+	relate_reg->ac_phy_ctl =
+		ddr_read(base_phy + DDR_PHY_ACPHYCTL4);
+	relate_reg->ac_phy_ctl =
+		ddr_read(base_phy + DDR_PHY_ACPHYCTL4);
+
+	/* set new value */
+	switch (mask) {
+	case DDR_BYPASS_WL_MASK:
+	case DDR_BYPASS_LPCA_MASK:
+		/* disable auto refresh */
+		ddr_training_set_timing(base_dmc,
+			relate_reg->auto_ref_timing & DMC_AUTO_TIMING_DIS);
+		break;
+	case DDR_BYPASS_GATE_MASK:
+		/* disable auto refresh */
+		ddr_training_set_timing(base_dmc,
+			relate_reg->auto_ref_timing & DMC_AUTO_TIMING_DIS);
+
+		if (!(ddr_read(base_phy + DDR_PHY_DRAMCFG) & PHY_DRAMCFG_MA2T)) /* set 1T */
+			ddr_write(0x0, base_phy + DDR_PHY_ACPHYCTL4);
+		break;
+	case DDR_BYPASS_HW_MASK:
+		if (!(ddr_read(base_phy + DDR_PHY_DRAMCFG) & PHY_DRAMCFG_MA2T)) /* set 1T */
+			ddr_write(0x0, base_phy + DDR_PHY_ACPHYCTL4);
+		break;
+	default:
+		break;
+	}
+
+	ddr_write(relate_reg->power_down & DMC_POWER_DOWN_DIS,
+		base_dmc + DDR_DMC_CFG_PD);
+	ddr_write(relate_reg->misc_scramb & PHY_MISC_SCRAMB_DIS,
+		base_phy + DDR_PHY_MISC);
+
+	DDR_DQSSWAP_SAVE_FUNC(relate_reg->swapdfibyte_en, base_phy);
+
+	DDR_AXI_SAVE_FUNC(relate_reg);
+
+	DDR_RNKVOL_SAVE_FUNC(relate_reg, base_dmc);
+
+	/* save customer reg */
+	DDR_TRAINING_SAVE_REG_FUNC((void *)relate_reg, mask);
+
+	ddr_phy_cfg_update(base_phy);
+
+	DDR_ASM_DSB();
+}
+
+/* Restore register value after training */
+void ddr_training_restore_reg(struct ddr_cfg_st *cfg,
+			      struct tr_relate_reg *relate_reg)
+{
+	unsigned int base_dmc = cfg->cur_dmc;
+	unsigned int base_phy = cfg->cur_phy;
+
+	/* enable auto refresh */
+	ddr_training_set_timing(base_dmc, relate_reg->auto_ref_timing);
+	ddr_write(relate_reg->power_down, base_dmc + DDR_DMC_CFG_PD);
+	ddr_write(relate_reg->misc_scramb, base_phy + DDR_PHY_MISC);
+	if (!(ddr_read(base_phy + DDR_PHY_DRAMCFG) & PHY_DRAMCFG_MA2T))
+		ddr_write(relate_reg->ac_phy_ctl, base_phy + DDR_PHY_ACPHYCTL4);
+
+	DDR_DQSSWAP_RESTORE_FUNC(relate_reg->swapdfibyte_en, base_phy);
+
+	DDR_AXI_RESTORE_FUNC(relate_reg);
+
+	DDR_RNKVOL_RESTORE_FUNC(relate_reg, base_dmc);
+
+	/* restore customer reg */
+	DDR_TRAINING_RESTORE_REG_FUNC((void *)relate_reg);
+
+	ddr_phy_cfg_update(base_phy);
+
+	DDR_ASM_DSB();
+}
+
+/* Switch AXI to DMC0/DMC1/DMC2/DMC3 for DDRT test */
+void ddr_training_switch_axi(struct ddr_cfg_st *cfg)
+{
+	DDR_AXI_SWITCH_FUNC(cfg);
+
+	DDR_RNKVOL_SET_FUNC(cfg);
+}
+#endif
+
+#if defined(DDR_WL_TRAINING_CONFIG) || defined(DDR_MPR_TRAINING_CONFIG)
+
+/* Excute DMC sfc command */
+static void ddr_dmc_sfc_cmd(unsigned int base_dmc, unsigned int sfc_cmd,
+			    unsigned int sfc_addr, unsigned int sfc_bank)
+{
+	unsigned int count = 0;
+
+	/* set sfc cmd */
+	DMC_SFC_CMD_WRITE(sfc_cmd, base_dmc + DDR_DMC_SFCCMD);
+	/* set col and row */
+	ddr_write(sfc_addr, base_dmc + DDR_DMC_SFCADDR);
+	/* set bank */
+	DMC_SFC_BANK_WRITE(sfc_bank, base_dmc + DDR_DMC_SFCBANK);
+	/* excute cmd */
+	ddr_write(0x1, base_dmc + DDR_DMC_SFCREQ);
+
+	DDR_ASM_DSB();
+
+	while (count < DDR_SFC_WAIT_TIMEOUT) { /* wait command finished */
+		if (!(ddr_read(base_dmc + DDR_DMC_SFCREQ) & 0x1))
+			break;
+
+		count++;
+	}
+
+	if (count >= DDR_HWR_WAIT_TIMEOUT)
+		DDR_ERROR("SFC cmd wait timeout.");
+}
+#endif
+
+#if defined(DDR_HW_TRAINING_CONFIG) || defined(DDR_DCC_TRAINING_CONFIG)
+
+/* Exit or enter auto self-refresh */
+static int ddr_training_easr(unsigned int base_dmc, unsigned int sref_req)
+{
+	unsigned int count = DDR_HWR_WAIT_TIMEOUT;
+	if (DDR_EXIT_SREF == sref_req) {
+		/* Exit Auto-self refresh */
+		ddr_write(DMC_CTRL_SREF_EXIT, base_dmc + DDR_DMC_CTRL_SREF);
+
+		while (count--) {
+			if (!(ddr_read(base_dmc + DDR_DMC_CURR_FUNC)
+				& DMC_CURR_FUNC_IN_SREF_MASK))
+				break;
+		}
+	} else if (DDR_ENTER_SREF == sref_req) {
+		/* Enter Auto-self refresh */
+		ddr_write(DMC_CTRL_SREF_ENTER, base_dmc + DDR_DMC_CTRL_SREF);
+
+		while (count--) {
+			if (ddr_read(base_dmc + DDR_DMC_CURR_FUNC)
+				& DMC_CURR_FUNC_IN_SREF_MASK)
+				break;
+		}
+	}
+
+	if (count == 0xffffffff) {
+		DDR_FATAL("SREF wait timeout.");
+		ddr_training_stat(DDR_ERR_HW_RD_DATAEYE, -1, -1, -1);
+		return -1;
+	}
+	return 0;
+}
+
+/* DDR hw/dcc training exit or enter auto self-refresh */
+static int ddr_training_ctrl_easr(struct ddr_cfg_st *cfg, unsigned int sref_req)
+{
+	int result = 0;
+	int i;
+	struct ddr_phy_st *phy_st =  &cfg->phy[cfg->phy_idx];
+
+	for (i = 0; i < phy_st->dmc_num; i++) {
+		result += ddr_training_easr(phy_st->dmc[i].addr, sref_req);
+	}
+
+	return result;
+}
+
+static void ddr_training_save_timing(struct ddr_cfg_st *cfg, struct ddr_timing_st *timing_st)
+{
+	int i;
+	struct ddr_phy_st *phy_st =  &cfg->phy[cfg->phy_idx];
+
+	for (i = 0; i < phy_st->dmc_num; i++) {
+
+		timing_st->val[i] = ddr_read(phy_st->dmc[i].addr + DDR_DMC_TIMING2);
+		/* disable auto refresh */
+		ddr_training_set_timing(phy_st->dmc[i].addr, timing_st->val[i] & DMC_AUTO_TIMING_DIS);
+	}
+}
+
+static void ddr_training_restore_timing(struct ddr_cfg_st *cfg, struct ddr_timing_st *timing_st)
+{
+	int i;
+	struct ddr_phy_st *phy_st =  &cfg->phy[cfg->phy_idx];
+	for (i = 0; i < phy_st->dmc_num; i++) {
+		ddr_training_set_timing(phy_st->dmc[i].addr, timing_st->val[i]);
+	}
+}
+#endif /* DDR_HW_TRAINING_CONFIG ||  DDR_DCC_TRAINING_CONFIG*/
+
+/**
+ * Update delay setting in registers to PHY immediately.
+ * Make delay setting take effect.
+ */
+void ddr_phy_cfg_update(unsigned int base_phy)
+{
+	unsigned int tmp;
+
+	tmp = ddr_read(base_phy + DDR_PHY_MISC);
+	tmp |= (1 << PHY_MISC_UPDATE_BIT);
+	/* update new config to PHY */
+	ddr_write(tmp, base_phy + DDR_PHY_MISC);
+	tmp &= ~(1 << PHY_MISC_UPDATE_BIT);
+	ddr_write(tmp, base_phy + DDR_PHY_MISC);
+	tmp = ddr_read(base_phy + DDR_PHY_PHYINITCTRL);
+	/* set 1 to issue PHY counter reset signal */
+	tmp |= (1 << PHY_PHYCONN_RST_BIT);
+	ddr_write(tmp, base_phy + DDR_PHY_PHYINITCTRL);
+	/* set 0 to end the reset signal */
+	tmp &= ~(1 << PHY_PHYCONN_RST_BIT);
+	ddr_write(tmp, base_phy + DDR_PHY_PHYINITCTRL);
+
+	DDR_ASM_DSB();
+}
+
+/* Set delay value of the bit delay line of the DATA block */
+void ddr_phy_set_dq_bdl(struct ddr_cfg_st *cfg, unsigned int value)
+{
+	unsigned int val;
+	unsigned int offset;
+	unsigned int dq;
+	unsigned int base_phy = cfg->cur_phy;
+	unsigned int byte_index = cfg->cur_byte;
+	unsigned int rank = cfg->rank_idx;
+
+	dq = cfg->cur_dq & 0x7;
+	if (DDR_MODE_WRITE == cfg->cur_mode) {
+		if (dq < 4)
+			offset = DDR_PHY_DXNWDQNBDL0(rank, byte_index);
+		else
+			offset = DDR_PHY_DXNWDQNBDL1(rank, byte_index);
+	} else {
+		if (dq < 4)
+			offset = DDR_PHY_DXNRDQNBDL0(rank, byte_index);
+		else
+			offset = DDR_PHY_DXNRDQNBDL1(rank, byte_index);
+	}
+
+	dq &= 0x3;
+	val = ddr_read(base_phy + offset);
+	val &= ~(0xFF << (dq << 3));
+	val |= ((PHY_BDL_MASK & value) << ((dq << 3) + PHY_BDL_DQ_BIT));
+	ddr_write(val, base_phy + offset);
+
+	ddr_phy_cfg_update(base_phy);
+}
+
+/* Get PHY DQ value */
+unsigned int ddr_phy_get_dq_bdl(struct ddr_cfg_st *cfg)
+{
+	unsigned int val;
+	unsigned int offset;
+	unsigned int dq;
+	unsigned int byte_index = cfg->cur_byte;
+	unsigned int rank = cfg->rank_idx;
+
+	dq = cfg->cur_dq & 0x7;
+	if (DDR_MODE_WRITE == cfg->cur_mode) {
+		if (dq < 4)
+			offset = DDR_PHY_DXNWDQNBDL0(rank, byte_index);
+		else
+			offset = DDR_PHY_DXNWDQNBDL1(rank, byte_index);
+	} else {
+		if (dq < 4)
+			offset = DDR_PHY_DXNRDQNBDL0(rank, byte_index);
+		else
+			offset = DDR_PHY_DXNRDQNBDL1(rank, byte_index);
+	}
+
+	dq &= 0x3;
+	val = (ddr_read(cfg->cur_phy + offset) >> ((dq << 3) + PHY_BDL_DQ_BIT)) & PHY_BDL_MASK;
+
+	return val;
+}
+
+/* Get byte number */
+unsigned int ddr_phy_get_byte_num(unsigned int base_dmc)
+{
+	unsigned int byte_num;
+
+	/* memery width -> byte number */
+	byte_num = ((ddr_read(base_dmc + DDR_DMC_CFG_DDRMODE)
+		>> DMC_MEM_WIDTH_BIT) & DMC_MEM_WIDTH_MASK) << 1;
+
+	/* for codedex */
+	if (byte_num > DDR_PHY_BYTE_MAX) {
+		byte_num = DDR_PHY_BYTE_MAX;
+		DDR_ERROR("get byte num fail");
+	}
+
+	return byte_num;
+}
+
+
+static void ddr_rdqs_sync_rdm(struct ddr_cfg_st *cfg, int offset)
+{
+	unsigned int rdqnbdl;
+	int rdm;
+
+	rdqnbdl = ddr_read(cfg->cur_phy + DDR_PHY_DXNRDQNBDL2(cfg->rank_idx, cfg->cur_byte));
+	rdm = (rdqnbdl >> PHY_RDM_BDL_BIT) & PHY_RDM_BDL_MASK;
+	rdm += offset;
+	rdm = (rdm < 0 ? 0 : rdm);
+	rdm = (rdm > PHY_RDM_BDL_MASK ? PHY_RDM_BDL_MASK : rdm);
+	rdqnbdl = rdqnbdl & (~(PHY_RDM_BDL_MASK << PHY_RDM_BDL_BIT));
+	ddr_write(rdqnbdl | ((unsigned int)rdm << PHY_RDM_BDL_BIT), cfg->cur_phy + DDR_PHY_DXNRDQNBDL2(cfg->rank_idx, cfg->cur_byte));
+}
+
+static void ddr_rdqs_sync_rank_rdq(struct ddr_cfg_st *cfg, int offset)
+{
+	int dq_val;
+	int i;
+
+	/* sync other rank rdm */
+	ddr_rdqs_sync_rdm(cfg, offset);
+
+	/* sync other rank rdq */
+	DDR_DEBUG("Before sync rank[%x] byte[%x] dq[%x = %x][%x = %x] offset[%x]",
+		cfg->rank_idx, cfg->cur_byte,
+		cfg->cur_phy + DDR_PHY_DXNRDQNBDL0(cfg->rank_idx, cfg->cur_byte),
+		ddr_read(cfg->cur_phy + DDR_PHY_DXNRDQNBDL0(cfg->rank_idx, cfg->cur_byte)),
+		cfg->cur_phy + DDR_PHY_DXNRDQNBDL1(cfg->rank_idx, cfg->cur_byte),
+		ddr_read(cfg->cur_phy + DDR_PHY_DXNRDQNBDL1(cfg->rank_idx, cfg->cur_byte)), offset);
+
+	for (i = 0; i < DDR_PHY_BIT_NUM; i++) {
+		cfg->cur_dq = i;
+		dq_val = (int)ddr_phy_get_dq_bdl(cfg);
+		dq_val += offset;
+		dq_val = (dq_val < 0 ? 0 : dq_val);
+		dq_val = (dq_val > PHY_BDL_MASK ? PHY_BDL_MASK : dq_val);
+		ddr_phy_set_dq_bdl(cfg, dq_val);
+	}
+
+	DDR_DEBUG("After sync rank[%x] byte[%x] dq[%x = %x][%x = %x]",
+		cfg->rank_idx, cfg->cur_byte,
+		cfg->cur_phy + DDR_PHY_DXNRDQNBDL0(cfg->rank_idx, cfg->cur_byte),
+		ddr_read(cfg->cur_phy + DDR_PHY_DXNRDQNBDL0(cfg->rank_idx, cfg->cur_byte)),
+		cfg->cur_phy + DDR_PHY_DXNRDQNBDL1(cfg->rank_idx, cfg->cur_byte),
+		ddr_read(cfg->cur_phy + DDR_PHY_DXNRDQNBDL1(cfg->rank_idx, cfg->cur_byte)));
+}
+
+static void ddr_bdl_adj(struct ddr_cfg_st *cfg)
+{
+	int i;
+	int value_num = 10;
+	unsigned int rank = cfg->rank_idx;
+	unsigned int base_phy = cfg->cur_phy;
+	unsigned int byte_idx = cfg->cur_byte;
+	unsigned int bdl[value_num];
+	unsigned int min = 0xffffffff;
+	unsigned int dq03, dq47, rdm, rdqs;
+
+	dq03 = ddr_read(base_phy + DDR_PHY_DXNRDQNBDL0(rank, byte_idx));
+	dq47 = ddr_read(base_phy + DDR_PHY_DXNRDQNBDL1(rank, byte_idx));
+	rdm = ddr_read(base_phy + DDR_PHY_DXNRDQNBDL2(rank, byte_idx));
+	rdqs = ddr_read(base_phy + DDR_PHY_DXNRDQSDLY(byte_idx));
+
+	bdl[0] = (dq03 >> PHY_BDL_DQ0_BIT) & PHY_BDL_MASK;
+	bdl[1] = (dq03 >> PHY_BDL_DQ1_BIT) & PHY_BDL_MASK;
+	bdl[2] = (dq03 >> PHY_BDL_DQ2_BIT) & PHY_BDL_MASK;
+	bdl[3] = (dq03 >> PHY_BDL_DQ3_BIT) & PHY_BDL_MASK;
+	bdl[4] = (dq47 >> PHY_BDL_DQ0_BIT) & PHY_BDL_MASK;
+	bdl[5] = (dq47 >> PHY_BDL_DQ1_BIT) & PHY_BDL_MASK;
+	bdl[6] = (dq47 >> PHY_BDL_DQ2_BIT) & PHY_BDL_MASK;
+	bdl[7] = (dq47 >> PHY_BDL_DQ3_BIT) & PHY_BDL_MASK;
+	bdl[8] = (rdm >> PHY_RDM_BDL_BIT) & PHY_RDM_BDL_MASK;
+	bdl[9] = (rdqs >> PHY_RDQS_BDL_BIT) & PHY_RDQS_BDL_MASK;
+
+	for (i = 0; i < value_num; i++) {
+		if (bdl[i] < min)
+			min = bdl[i];
+	}
+
+	dq03 = ((bdl[0] - min) << PHY_BDL_DQ0_BIT) | ((bdl[1] - min) << PHY_BDL_DQ1_BIT) |
+			((bdl[2] - min) << PHY_BDL_DQ2_BIT) | ((bdl[3] - min) << PHY_BDL_DQ3_BIT);
+	dq47 = ((bdl[4] - min) << PHY_BDL_DQ0_BIT) | ((bdl[5] - min) << PHY_BDL_DQ1_BIT) |
+			((bdl[6] - min) << PHY_BDL_DQ2_BIT) | ((bdl[7] - min) << PHY_BDL_DQ3_BIT);
+	rdm = (rdm & (~(PHY_RDM_BDL_MASK << PHY_RDM_BDL_BIT))) | ((bdl[8] - min) << PHY_RDM_BDL_BIT);
+	rdqs = (rdqs & (~(PHY_RDQS_BDL_MASK << PHY_RDQS_BDL_BIT))) | ((bdl[9] - min) << PHY_RDQS_BDL_BIT);
+
+	ddr_write(dq03, base_phy + DDR_PHY_DXNRDQNBDL0(rank, byte_idx));
+	ddr_write(dq47, base_phy + DDR_PHY_DXNRDQNBDL1(rank, byte_idx));
+	ddr_write(rdm, base_phy + DDR_PHY_DXNRDQNBDL2(rank, byte_idx));
+	ddr_write(rdqs, base_phy + DDR_PHY_DXNRDQSDLY(byte_idx));
+}
+
+#define __ddrt__
+#ifdef DDR_DDRT_SPECIAL_CONFIG
+/* Some special DDRT need read register repeatedly */
+static unsigned int ddr_ddrt_read(unsigned int addr)
+{
+	int times = 0;
+	unsigned int data0, data1, data2;
+	do {
+		data0 = ddr_read(addr);
+		data1 = ddr_read(addr);
+		data2 = ddr_read(addr);
+		times++;
+	} while (((data0 != data1) || (data1 != data2))
+			&& (times < DDRT_READ_TIMEOUT));
+
+	if (times >= DDRT_READ_TIMEOUT) {
+		DDR_FATAL("DDRT wait timeout.");
+		ddr_training_stat(DDR_ERR_DDRT_TIME_OUT, 0, -1, -1);
+	}
+
+	return data0;
+}
+
+/* Some special DDRT need write twice register */
+static void ddr_ddrt_write(unsigned int data, unsigned int addr)
+{
+	unsigned int tmp;
+	tmp = ddr_read(addr);
+	ddr_write(data, addr);
+	ddr_write(data, addr);
+}
+#endif /* DDR_DDRT_SPECIAL_CONFIG */
+
+static unsigned int ddr_get_rank_size(struct ddr_cfg_st *cfg)
+{
+	unsigned int base_dmc = cfg->cur_dmc;
+	unsigned int rnkvol;
+	unsigned int mem_bank, mem_row, mem_col, mem_width;
+	unsigned int size;
+
+	mem_width = (ddr_read(base_dmc + DDR_DMC_CFG_DDRMODE) >> DMC_MEM_WIDTH_BIT) & DMC_MEM_WIDTH_MASK;
+	rnkvol = ddr_read(base_dmc + DDR_DMC_CFG_RNKVOL(0));
+	mem_bank = (rnkvol >> DMC_RNKVOL_MEM_BANK_BIT) & DMC_RNKVOL_MEM_BANK_MASK;
+	mem_row = (rnkvol >> DMC_RNKVOL_MEM_ROW_BIT) & DMC_RNKVOL_MEM_ROW_MASK;
+	mem_col = rnkvol & DMC_RNKVOL_MEM_COL_MASK;
+
+	size = 1UL << ((mem_bank + 2) + (mem_row + 11) + (mem_col + 8) + mem_width);
+	DDR_DEBUG("rank size[%x]", size);
+
+	return size;
+}
+
+/* Init DDRT register before DDRT test */
+void ddr_ddrt_init(struct ddr_cfg_st *cfg, unsigned int mode)
+{
+	unsigned int mem_width;
+	unsigned int mem_config;
+	unsigned int offset = 0;
+
+	if (1 == cfg->rank_idx)
+		offset = ddr_get_rank_size(cfg);
+
+	DDR_TRAINING_DDRT_PREPARE_FUNC();
+
+	mem_width = ((ddr_read(cfg->cur_dmc + DDR_DMC_CFG_DDRMODE)
+				>> DMC_MEM_WIDTH_BIT) & DMC_MEM_WIDTH_MASK);
+	mem_config = ((mem_width - 1) << DDRT_DDR_MEM_WIDTH)
+				| DDRT_DDR_COL_WIDTH | DDRT_DDR_ROW_WIDTH
+				| DDRT_DDR_BANK_WIDTH;
+	/* DDRT SDRAM config */
+	DDRT_REG_WRITE(mem_config, DDR_REG_BASE_DDRT + DDRT_MEM_CONFIG);
+	/* DDR Address Base */
+	DDRT_REG_WRITE(DDRT_GET_TEST_ADDR(DDRT_CFG_BASE_ADDR),
+		DDR_REG_BASE_DDRT + DDRT_DDR_BASE_ADDR);
+	/* DDRT test DDR using space */
+	DDRT_REG_WRITE(DDRT_GET_TEST_ADDR(ddr_ddrt_get_test_addr() + offset),
+		DDR_REG_BASE_DDRT + DDRT_ADDR);
+	DDRT_REG_WRITE(DDRT_CFG_SEED, DDR_REG_BASE_DDRT + DDRT_SEED);
+
+	if (DDR_DDRT_MODE_GATE == mode) {
+		/* Read or Write Once */
+		DDRT_REG_WRITE(DDRT_CFG_BURST_CFG_GATE,
+			DDR_REG_BASE_DDRT + DDRT_BURST_CONFIG);
+		DDRT_REG_WRITE(0x0,  DDR_REG_BASE_DDRT + DDRT_BURST_NUM);
+		DDRT_REG_WRITE(0x0,  DDR_REG_BASE_DDRT + DDRT_ADDR_NUM);
+		DDRT_REG_WRITE(0x0,  DDR_REG_BASE_DDRT + DDRT_LOOP_NUM);
+		DDRT_REG_WRITE(DDRT_CFG_REVERSED,
+			DDR_REG_BASE_DDRT + DDRT_REVERSED_DQ);
+	} else {
+		/* reversed data form register init table */
+		/* 128bit BURST4 */
+		DDRT_REG_WRITE(DDRT_CFG_BURST_CFG_DATAEYE,
+			DDR_REG_BASE_DDRT + DDRT_BURST_CONFIG);
+		DDRT_REG_WRITE(cfg->phy[cfg->phy_idx].dmc[cfg->dmc_idx].ddrt_pattern,
+			DDR_REG_BASE_DDRT + DDRT_REVERSED_DQ);
+		DDRT_REG_WRITE(DDRT_CFG_BURST_NUM,
+			DDR_REG_BASE_DDRT + DDRT_BURST_NUM);
+		DDRT_REG_WRITE(DDRT_CFG_ADDR_NUM,
+			DDR_REG_BASE_DDRT + DDRT_ADDR_NUM);
+		DDRT_REG_WRITE(DDRT_CFG_LOOP_NUM,
+			DDR_REG_BASE_DDRT + DDRT_LOOP_NUM);
+	}
+
+	DDR_DEBUG("DDRT ADDR[%x = %x]", (DDR_REG_BASE_DDRT + DDRT_ADDR),
+		ddr_read(DDR_REG_BASE_DDRT + DDRT_ADDR));
+}
+
+/**
+ * ddr_ddrt_test
+ * @mask : DDRT option mask.
+ * @byte : DDR byte index.
+ * @dq   : DDR dq index.
+ *
+ * DDRT test. Support read_only mode and write_read_compare mode.
+ * Success return 0, fail return -1.
+ */
+int ddr_ddrt_test(unsigned int mask, int byte, int dq)
+{
+	unsigned int regval;
+	unsigned int err_ovfl;
+	unsigned int err_cnt;
+	unsigned int dq_num;
+	unsigned int dq_tmp;
+	unsigned int times = 0;
+
+	DDRT_REG_WRITE(mask | DDRT_CFG_START, DDR_REG_BASE_DDRT + DDRT_OP);
+	DDRT_REG_WRITE(0, DDR_REG_BASE_DDRT + DDRT_STATUS);
+
+	DDR_ASM_DSB();
+
+	do {
+		regval = DDRT_REG_READ(DDR_REG_BASE_DDRT + DDRT_STATUS);
+		times++;
+	} while ((!(regval & DDRT_TEST_DONE_MASK))
+			&& (times < DDRT_WAIT_TIMEOUT));
+
+	if (times >= DDRT_WAIT_TIMEOUT) {
+		DDR_FATAL("DDRT wait timeout.");
+		ddr_training_stat(DDR_ERR_DDRT_TIME_OUT, 0, -1, -1);
+		return -1;
+	}
+
+	/* DDRT_READ_ONLY_MODE */
+	if (DDRT_READ_ONLY_MODE == (mask & DDRT_TEST_MODE_MASK))
+		return 0;   /* return when DDRT finish */
+
+	/* DDRT_WR_COMPRARE_MODE No error occurred, test pass. */
+	if (regval & DDRT_TEST_PASS_MASK)
+		return 0;
+
+	if (-1 != dq) { /* check for dq */
+		dq_num = ((unsigned int)byte << 3) + dq;
+		err_ovfl = DDRT_REG_READ(DDR_REG_BASE_DDRT
+			+ DDRT_DQ_ERR_OVFL) & (1 << dq_num);
+		if (err_ovfl)
+			return -1;
+
+		if (dq > 3)
+			dq_tmp = (unsigned int)(dq - 4) << 3;
+		else
+			dq_tmp = (unsigned int)dq << 3;
+		err_cnt = DDRT_REG_READ(DDR_REG_BASE_DDRT
+			+ DDRT_DQ_ERR_CNT(((unsigned int)byte << 1) + ((unsigned int)dq >> 2)));
+		err_cnt = err_cnt & (0xff << dq_tmp);
+		if (err_cnt)
+			return -1;
+	} else if (-1 != byte) { /* check for byte */
+		err_ovfl = DDRT_REG_READ(DDR_REG_BASE_DDRT
+			+ DDRT_DQ_ERR_OVFL) & (0xff << ((unsigned int)byte << 3));
+		if (err_ovfl)
+			return -1;
+
+		err_cnt  = DDRT_REG_READ(DDR_REG_BASE_DDRT
+				+ DDRT_DQ_ERR_CNT((unsigned int)byte << 1));
+		err_cnt += DDRT_REG_READ(DDR_REG_BASE_DDRT
+				+ DDRT_DQ_ERR_CNT(((unsigned int)byte << 1) + 1));
+		if (err_cnt)
+			return -1;
+	}
+
+	return 0;
+}
+
+/* Check ddrt test result. Success return 0, fail return -1 */
+static int ddr_ddrt_check(struct ddr_cfg_st *cfg)
+{
+	unsigned int byte_index_to_dmc = cfg->cur_byte;
+
+	/* ddrt test the byte relate to dmc, make sure not overflow */
+	if (cfg->cur_byte >= (cfg->dmc_idx << 1))
+		byte_index_to_dmc = cfg->cur_byte - (cfg->dmc_idx << 1);
+
+	DDRT_REG_WRITE(0, DDR_REG_BASE_DDRT + DDRT_REVERSED_DQ);
+	if (ddr_ddrt_test(DDRT_WR_COMPRARE_MODE | DDRT_PATTERM_PRBS9,
+		byte_index_to_dmc, cfg->cur_dq))
+		return -1;
+
+	DDRT_REG_WRITE(cfg->cur_pattern, DDR_REG_BASE_DDRT + DDRT_REVERSED_DQ);
+	if (ddr_ddrt_test(DDRT_WR_COMPRARE_MODE | DDRT_PATTERM_PRBS11,
+		byte_index_to_dmc, cfg->cur_dq))
+		return -1;
+
+	return 0;
+}
+
+#define __dataeye_adjust__
+#ifdef DDR_TRAINING_ADJUST_CONFIG
+static unsigned int ddr_adjust_get_average(struct ddr_cfg_st *cfg)
+{
+	unsigned int dq0_3, dq4_7, val;
+	unsigned int base_phy = cfg->cur_phy;
+	unsigned int byte_index = cfg->cur_byte;
+	unsigned int rank = cfg->rank_idx;
+
+	if (DDR_MODE_WRITE == cfg->cur_mode)
+		return (ddr_read(base_phy + DDR_PHY_DXNWDQNBDL2(rank, byte_index))
+			>> PHY_WDM_BDL_BIT) & PHY_BDL_MASK;
+
+	/* read */
+	dq0_3 = ddr_read(base_phy + DDR_PHY_DXNRDQNBDL0(rank, byte_index));
+	dq4_7 = ddr_read(base_phy + DDR_PHY_DXNRDQNBDL1(rank, byte_index));
+
+	val = ((dq0_3 >> PHY_BDL_DQ0_BIT) & PHY_BDL_MASK)
+		+ ((dq0_3 >> PHY_BDL_DQ1_BIT) & PHY_BDL_MASK)
+		+ ((dq0_3 >> PHY_BDL_DQ2_BIT) & PHY_BDL_MASK)
+		+ ((dq0_3 >> PHY_BDL_DQ3_BIT) & PHY_BDL_MASK)
+		+ ((dq4_7 >> PHY_BDL_DQ0_BIT) & PHY_BDL_MASK)
+		+ ((dq4_7 >> PHY_BDL_DQ1_BIT) & PHY_BDL_MASK)
+		+ ((dq4_7 >> PHY_BDL_DQ2_BIT) & PHY_BDL_MASK)
+		+ ((dq4_7 >> PHY_BDL_DQ3_BIT) & PHY_BDL_MASK);
+
+	val = val >> 3;
+	return val;
+}
+
+/**
+ * ddr_adjust_trend_check
+ * @accel : Return a value to adjust quickly.
+ *
+ * Check dataeye DQ window on left or right or middle.
+ */
+static unsigned int ddr_adjust_trend_check(struct ddr_cfg_st *cfg, int *accel)
+{
+	unsigned int dq_bdl = 0;
+	unsigned int size;
+
+	/* 32 BDL middle[13, 17]. 128 BDL middle[40, 56] */
+	/* 1 Phase = (DDR_BDL_PHASE_TRANSFORM) BDL */
+	size = DDR_BDL_PHASE_TRANSFORM >> 1;
+
+	dq_bdl =  ddr_adjust_get_average(cfg);
+
+	/* increase adjust step to accelerate */
+	if (accel) {
+		if (dq_bdl > PHY_DQ_BDL_MIDDLE)
+			*accel = dq_bdl - PHY_DQ_BDL_MIDDLE;
+		else if (dq_bdl < PHY_DQ_BDL_MIDDLE)
+			*accel = PHY_DQ_BDL_MIDDLE - dq_bdl;
+
+		DDR_INFO("byte[%x] bdl[%x] middle[%x] accel[%x] rdqs[%x]",
+			cfg->cur_byte, dq_bdl, PHY_DQ_BDL_MIDDLE, *accel,
+			(ddr_read(cfg->cur_phy + DDR_PHY_DXNRDQSDLY(cfg->cur_byte))
+			>> PHY_RDQS_BDL_BIT) & PHY_RDQS_BDL_MASK);
+	}
+
+	/* window on left */
+	if (dq_bdl < (PHY_DQ_BDL_MIDDLE - size))
+		return DDR_WIN_LEFT;
+	/* on right */
+	else if (dq_bdl > (PHY_DQ_BDL_MIDDLE + size))
+		return DDR_WIN_RIGHT;
+	else
+		return DDR_WIN_MIDDLE;
+}
+
+/* Check adjust value whether valid */
+static int ddr_adjust_check_val(int val, unsigned int mode)
+{
+	if (DDR_MODE_READ == mode) {
+		if (val < 0 || val > PHY_RDQS_BDL_MASK)
+			return DDR_FALSE;
+	} else {
+		if (val < 0 || val > PHY_WDQ_PHASE_MASK)
+			return DDR_FALSE;
+	}
+
+	return DDR_TRUE;
+}
+
+/* Get value which need to adjust */
+static int ddr_adjust_get_val(struct ddr_cfg_st *cfg)
+{
+	if (DDR_MODE_READ == cfg->cur_mode)
+		return (ddr_read(cfg->cur_phy + DDR_PHY_DXNRDQSDLY(cfg->cur_byte))
+		>> PHY_RDQS_BDL_BIT) & PHY_RDQS_BDL_MASK;
+	else
+		return (ddr_read(cfg->cur_phy + DDR_PHY_DXNWDQDLY(cfg->rank_idx, cfg->cur_byte))
+		>> PHY_WDQ_PHASE_BIT) & PHY_WDQ_PHASE_MASK;
+}
+
+static void ddr_rdqs_sync(struct ddr_cfg_st *cfg, int val)
+{
+	unsigned int rdqsdly;
+	unsigned int cur_rank = cfg->rank_idx;
+	int old, offset;
+
+	rdqsdly = ddr_read(cfg->cur_phy + DDR_PHY_DXNRDQSDLY(cfg->cur_byte));
+	old = (rdqsdly >> PHY_RDQS_BDL_BIT) & PHY_RDQS_BDL_MASK;
+	offset = val - old;
+
+	/* sync rdm */
+	ddr_rdqs_sync_rank_rdq(cfg, offset);
+
+	if (1 == cfg->phy[cfg->phy_idx].rank_num) {
+		DDR_DEBUG("Rank number[%x] not need sync another rank", cfg->phy[cfg->phy_idx].rank_num);
+		return;
+	}
+
+	/* sync other rank rdm and rdq */
+	cfg->rank_idx = DDR_SUPPORT_RANK_MAX - 1 - cur_rank; /* switch to another rank */
+	ddr_rdqs_sync_rank_rdq(cfg, offset);
+	cfg->rank_idx = cur_rank; /* resotre to cur rank */
+}
+
+static void ddr_set_rdqs(struct ddr_cfg_st *cfg, int val)
+{
+	unsigned int delay;
+	delay = ddr_read(cfg->cur_phy + DDR_PHY_DXNRDQSDLY(cfg->cur_byte));
+
+	DDR_PHY_RDQS_SYNC_RDM(cfg, val);
+
+	/* clear rdqs bdl */
+	delay = delay & (~(PHY_RDQS_BDL_MASK << PHY_RDQS_BDL_BIT));
+
+	ddr_write(delay | ((unsigned int)val << PHY_RDQS_BDL_BIT),
+		cfg->cur_phy + DDR_PHY_DXNRDQSDLY(cfg->cur_byte));
+}
+
+/* Set value which need to adjust */
+static void ddr_adjust_set_val(struct ddr_cfg_st *cfg, int val)
+{
+	unsigned int delay;
+	if (DDR_MODE_READ == cfg->cur_mode) {
+		ddr_set_rdqs(cfg, val);
+	} else {
+		delay = ddr_read(cfg->cur_phy + DDR_PHY_DXNWDQDLY(cfg->rank_idx, cfg->cur_byte));
+		/* clear wdq phase */
+		delay = delay & (~(PHY_WDQ_PHASE_MASK << PHY_WDQ_PHASE_BIT));
+
+		ddr_write(delay | ((unsigned int)val << PHY_WDQ_PHASE_BIT),
+			cfg->cur_phy + DDR_PHY_DXNWDQDLY(cfg->rank_idx, cfg->cur_byte));
+	}
+
+	ddr_phy_cfg_update(cfg->cur_phy);
+}
+
+/* Add or delete value to adjust */
+static void ddr_adjust_change_val(unsigned int dir, int *val,
+				  int step, unsigned int mode)
+{
+	if (DDR_MODE_READ == mode) {
+		if (DDR_WIN_RIGHT == dir)
+			(*val) = (*val) + step;
+		else
+			(*val) = (*val) - step;
+	} else {
+		/* decrease wdq phase, window move to right */
+		if (DDR_WIN_RIGHT == dir)
+				(*val) = (*val) - step;
+			else
+				(*val) = (*val) + step;
+	}
+}
+
+/**
+ * ddr_adjust_move_win
+ * @dir : move direction. DDR_TRUE move to right, DDR_FALSE move to left.
+ *
+ * Move window to specified direction until the best DQ bdl beyond the midline.
+ */
+static void ddr_adjust_move_win(struct ddr_cfg_st *cfg,
+				struct training_data *training,
+				int step, unsigned int dir)
+{
+	int cur_val, def_val;
+	int i;
+	int accel;
+	int trend;
+	unsigned int max_value;
+
+	max_value = (DDR_MODE_WRITE == cfg->cur_mode ?
+		PHY_WDQ_PHASE_MASK : PHY_RDQS_BDL_MASK);
+
+	def_val = ddr_adjust_get_val(cfg);
+	cur_val = def_val;
+	for (i = 0; i <= max_value; i++) {
+		accel = step;
+		/* write mode no need to accelerate */
+		if (DDR_MODE_WRITE == cfg->cur_mode)
+			trend = ddr_adjust_trend_check(cfg, 0);
+		else
+			trend = ddr_adjust_trend_check(cfg, &accel);
+
+		if (DDR_WIN_MIDDLE == trend || dir == trend) {
+			DDR_DEBUG("Move byte[%x] window to middle suc", cfg->cur_byte);
+			break;
+		}
+
+		ddr_adjust_change_val(dir, &cur_val, accel, cfg->cur_mode);
+		if (DDR_FALSE == ddr_adjust_check_val(cur_val, cfg->cur_mode)) {
+			DDR_WARNING("Move byte[%x] to middle fail. value[%x]",
+						cfg->cur_byte, cur_val);
+			break;
+		}
+
+		DDR_DEBUG("Byte[%x] mode[%x] set value[%x]",
+			cfg->cur_byte, cfg->cur_mode, cur_val);
+		ddr_adjust_set_val(cfg, cur_val);
+		if (ddr_dataeye_deskew(cfg, training)) {
+			ddr_adjust_set_val(cfg, def_val);
+			/* MUST deskew dataeye after restore rdqs */
+			ddr_dataeye_deskew(cfg, training);
+			DDR_ERROR("Byte[%x] deskew fail, restore[%x]",
+					cfg->cur_byte, def_val);
+			break;
+		}
+	}
+}
+
+/* Adjust specified byte winodw to middle */
+static void ddr_adjust_byte(struct ddr_cfg_st *cfg, struct training_data *training)
+{
+	unsigned int trend = ddr_adjust_trend_check(cfg, 0);
+
+	/* window on left, move to right */
+	if (DDR_WIN_LEFT == trend)
+		ddr_adjust_move_win(cfg, training, DDR_DQS_ADJ_STEP, DDR_WIN_RIGHT);
+	/* window on right, move to left */
+	else if (DDR_WIN_RIGHT == trend)
+		ddr_adjust_move_win(cfg, training, DDR_DQS_ADJ_STEP, DDR_WIN_LEFT);
+	/* window on middle, no need to move */
+	else
+		DDR_DEBUG("Byte[%x] mode[%x] win on middle.",
+			cfg->cur_byte, cfg->cur_mode);
+}
+
+/**
+ * Adjust PHY dataeye. On normal case,
+ * read dateeye window on left after read dataeye hardware training,
+ * write dataeye window on left after write leveling training.
+ *
+ */
+void ddr_adjust_dataeye(struct ddr_cfg_st *cfg, struct training_data *training)
+{
+	int i;
+
+	/* dataeye adjust disable */
+	if (ddr_training_check_bypass(cfg, DDR_BYPASS_DATAEYE_ADJ_MASK))
+		return;
+
+	DDR_DEBUG("DDR dataeye adjust PHY[%x][%x] DMC[%x][%x] Rank[%x]",
+		cfg->phy_idx, cfg->cur_phy, cfg->dmc_idx, cfg->cur_dmc, cfg->rank_idx);
+
+	if (DDR_FALSE == cfg->adjust)
+		return;
+
+	for (i = 0; i < GET_BYTE_NUM(cfg); i++) {
+		cfg->cur_byte = i + (cfg->dmc_idx << 1); /* byte index accord to phy */
+		ddr_adjust_byte(cfg, training);
+	}
+}
+#else
+#define ddr_adjust_dataeye(cfg, training)
+#endif /* DDR_TRAINING_ADJUST_CONFIG */
+
+#define __dataeye_training__
+#ifdef DDR_DATAEYE_TRAINING_CONFIG
+/* Check dataeye dq */
+int ddr_dataeye_check_dq(struct ddr_cfg_st *cfg)
+{
+	if (DDR_CHECK_TYPE_DDRT == cfg->dq_check_type)
+		return ddr_ddrt_check(cfg);
+	else if (DDR_CHECK_TYPE_MPR == cfg->dq_check_type)
+		return ddr_mpr_check(cfg);
+	else
+		DDR_ERROR("DDR dataeye dq check type not set.");
+
+	return 0;
+}
+
+/* Check dq whether valid and set mask to reduce search time */
+static int ddr_dataeye_check_dir(unsigned int direction, unsigned int left,
+				 unsigned int right, unsigned int *mask,
+				 struct ddr_cfg_st *cfg)
+{
+	int result = 0;
+
+	result = ddr_dataeye_check_dq(cfg);
+	switch (direction) {
+	case DDR_FIND_DQ_BOTH:
+		*mask = DDR_FIND_DQ_LEFT | DDR_FIND_DQ_RIGHT;
+		break;
+	case DDR_FIND_DQ_LEFT:
+		if (result) {
+			/* ddr test error, search opposite side */
+			*mask = DDR_FIND_DQ_RIGHT;
+		} else {		/* ddr test ok */
+			ddr_phy_set_dq_bdl(cfg, left);
+			if (!ddr_dataeye_check_dq(cfg))
+				/* test ok, go on search this side */
+				*mask = DDR_FIND_DQ_LEFT;
+		}
+		break;
+	case DDR_FIND_DQ_RIGHT:
+		if (result) {  /* ddr test error, search opposite side */
+			*mask = DDR_FIND_DQ_LEFT;
+		} else {		/* ddr test ok */
+			ddr_phy_set_dq_bdl(cfg, right);
+			if (!ddr_dataeye_check_dq(cfg))
+				/* test OK, go on search this side */
+				*mask = DDR_FIND_DQ_RIGHT;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return result;
+}
+
+/* Binary search the valid dq bdl */
+static void ddr_dataeye_search_dq(unsigned int left, unsigned int right,
+				  int *target, unsigned int direction,
+				  struct ddr_cfg_st *cfg)
+
+{
+	unsigned int middle;
+	unsigned int mask = 0;
+
+	middle = left + ((right - left) >> 1);
+
+	ddr_phy_set_dq_bdl(cfg, middle);
+	if (!ddr_dataeye_check_dir(direction, left, right, &mask, cfg)) { /* test ok */
+		*target = (int)middle;
+		return;
+	}
+
+	if (left == middle || middle == right)  /* not found */
+		return;
+
+	/* find left side */
+	if (DDR_FIND_DQ_LEFT & mask)
+		ddr_dataeye_search_dq(left, middle, target, direction, cfg);
+
+	/* find right side */
+	if (DDR_FIND_DQ_RIGHT & mask)
+		ddr_dataeye_search_dq(middle, right, target, direction, cfg);
+
+	return;
+}
+
+/* Find DQ valid range */
+static void ddr_dataeye_find_dq(struct ddr_cfg_st *cfg,
+				struct training_data *training)
+{
+	int cur_dq, left_dq, right_dq, def_dq;
+	unsigned int dq_num;
+	unsigned int win_num;
+
+	dq_num = (cfg->cur_byte << 3) + cfg->cur_dq;
+	def_dq = (int)ddr_phy_get_dq_bdl(cfg);
+	cur_dq = def_dq;
+
+	/* check default dq */
+	if (ddr_dataeye_check_dq(cfg)) {
+		/* test error */
+		cur_dq = -1;
+		ddr_dataeye_search_dq(0, PHY_BDL_MASK, &cur_dq,
+			DDR_FIND_DQ_BOTH, cfg);
+		DDR_DEBUG("DQ[%x] def[%x] nok, find new value[%x]",
+			dq_num, def_dq, cur_dq);
+		if (-1 == cur_dq) {  /* no valid dq */
+			training->ddr_bit_result[dq_num] = 0;
+			training->ddr_bit_best[dq_num]   = 0;
+			/* restore default value */
+			ddr_phy_set_dq_bdl(cfg, def_dq);
+			DDR_WARNING("DQ[%x] not found dq. restore[%x]", dq_num, def_dq);
+			return;
+		}
+	}
+
+	/* find the left boundary */
+	left_dq = cur_dq;
+	ddr_dataeye_search_dq(0, cur_dq, &left_dq,
+		DDR_FIND_DQ_LEFT, cfg);
+	while (left_dq > 0) {
+		left_dq--;
+		ddr_phy_set_dq_bdl(cfg, left_dq);
+		if (ddr_dataeye_check_dq(cfg)) {
+			/* test error */
+			left_dq++;
+			break;
+		}
+	}
+
+	/* find the right boundary */
+	right_dq = cur_dq;
+	ddr_dataeye_search_dq(cur_dq, PHY_BDL_MASK, &right_dq,
+		DDR_FIND_DQ_RIGHT, cfg);
+	while (right_dq < PHY_BDL_MASK) {
+		right_dq++;
+		ddr_phy_set_dq_bdl(cfg, right_dq);
+		if (ddr_dataeye_check_dq(cfg)) {
+			/* test error */
+			right_dq--;
+			break;
+		}
+	}
+
+	/* reset dq */
+	ddr_phy_set_dq_bdl(cfg, def_dq);
+
+	/**
+	 * 0 1 2 3 4 5 6 7 8 9
+	 * x x - - - - - x x x
+	 *     |       |
+	 * left_dq   right_dq
+	 *
+	 * so left_dq = 2, right_dq = 6
+	 */
+	/* set result */
+	win_num = right_dq - left_dq + 1;
+	training->ddr_bit_result[dq_num] = ((unsigned int)left_dq << DDR_DATAEYE_RESULT_BIT
+		| (unsigned int)right_dq);
+	training->ddr_bit_best[dq_num] = (win_num << DDR_DATAEYE_RESULT_BIT)
+		| ((win_num >> 1) + (unsigned int)left_dq);
+
+	DDR_INFO("DQ[%x] range: left[%x] right[%x] best[%x] mode[%x] rank[%x]", dq_num,
+		left_dq, right_dq, training->ddr_bit_best[dq_num], cfg->cur_mode, cfg->rank_idx);
+}
+
+/* DDR dataeye training one byte */
+int ddr_dataeye_deskew(struct ddr_cfg_st *cfg, struct training_data *training)
+{
+	unsigned int dq_num;
+	unsigned int loop_times = 0;
+	unsigned int win_num, dq_sum;
+	unsigned int def_dq, best_dq;
+	int i;
+	unsigned int byte_index = cfg->cur_byte;
+
+	dq_sum = 0;
+	training->ddr_win_sum = 0;
+	for (i = 0; i < DDR_PHY_BIT_NUM; i++) {
+		cfg->cur_dq = i;
+		dq_num = (byte_index << 3) + i;
+		def_dq = ddr_phy_get_dq_bdl(cfg);
+		ddr_dataeye_find_dq(cfg, training);
+		win_num = training->ddr_bit_best[dq_num] >> DDR_DATAEYE_RESULT_BIT;
+		best_dq = training->ddr_bit_best[dq_num] & DDR_DATAEYE_RESULT_MASK;
+		/* check window number */
+		if (win_num < DDR_DATAEYE_WIN_NUM) {
+			if (loop_times < DDR_LOOP_TIMES_LMT) {
+				loop_times++;
+				i--;
+				continue;
+			} else {
+				if (win_num == 0) {
+					DDR_WARNING("Byte[%x] DQ[%x] no win.", byte_index, dq_num);
+					/* restore default value */
+					ddr_phy_set_dq_bdl(cfg, def_dq);
+					ddr_training_stat(DDR_ERR_DATAEYE, cfg->cur_phy, byte_index, i);
+					continue;
+				}
+			}
+		}
+
+		loop_times = 0;
+		ddr_phy_set_dq_bdl(cfg, best_dq);
+		dq_sum = dq_sum + best_dq;
+		training->ddr_win_sum = training->ddr_win_sum + win_num;
+	}
+
+	dq_sum = dq_sum >> 3;
+
+	/* only DDR_MODE_WRITE need to set */
+	if (DDR_MODE_WRITE == cfg->cur_mode)
+		ddr_write((dq_sum & PHY_BDL_MASK) << PHY_WDM_BDL_BIT, cfg->cur_phy
+			+ DDR_PHY_DXNWDQNBDL2(cfg->rank_idx, byte_index));
+
+	ddr_phy_cfg_update(cfg->cur_phy);
+	return 0;
+}
+
+/* DDR write or read dataeye training */
+static int ddr_dataeye_process(struct ddr_cfg_st *cfg,
+			       struct training_data *training)
+{
+	int result = 0;
+	int i;
+
+	/* dataeye training */
+	for (i = 0; i < GET_BYTE_NUM(cfg); i++) {
+		cfg->cur_byte = i + (cfg->dmc_idx << 1); /* byte index accord to phy */
+		result += ddr_dataeye_deskew(cfg, training);
+	}
+
+	if (result) {
+		result = -1;
+		DDR_ERROR("PHY[%x] mode[%x] dataeye training fail", cfg->cur_phy, cfg->cur_mode);
+	} else {
+		/* dataeye training result adjust */
+		ddr_adjust_dataeye(cfg, training);
+	}
+
+	/* save training result to printf */
+	ddr_result_data_save(cfg, training);
+
+	return result;
+}
+
+/* DDR dataeye training */
+int ddr_dataeye_training(struct ddr_cfg_st *cfg)
+{
+	struct training_data tmp_result;
+	struct training_data *training = &tmp_result;
+	int result_read, result_write;
+
+	DDR_DEBUG("DDR dataeye training PHY[%x][%x] DMC[%x][%x] Rank[%x]",
+		cfg->phy_idx, cfg->cur_phy, cfg->dmc_idx, cfg->cur_dmc, cfg->rank_idx);
+
+	/* write dataeye training */
+	cfg->cur_mode = DDR_MODE_WRITE;
+	ddrtr_memset(training, 0, sizeof(struct training_data));
+	result_write = ddr_dataeye_process(cfg, training);
+
+	/* read dataeye training */
+	cfg->cur_mode = DDR_MODE_READ;
+	ddrtr_memset(training, 0, sizeof(struct training_data));
+	result_read = ddr_dataeye_process(cfg, training);
+
+	if (result_read || result_write)
+		return -1;
+	else
+		return 0;
+}
+
+int ddr_dataeye_training_func(struct ddr_cfg_st *cfg)
+{
+	struct tr_relate_reg relate_reg;
+	int result;
+
+	/* dataeye training disable */
+	if (ddr_training_check_bypass(cfg, DDR_BYPASS_DATAEYE_MASK))
+		return 0;
+
+	ddr_training_save_reg(cfg, &relate_reg, DDR_BYPASS_DATAEYE_MASK);
+	ddr_training_switch_axi(cfg);
+	ddr_ddrt_init(cfg, DDR_DDRT_MODE_DATAEYE);
+	cfg->adjust = DDR_DATAEYE_NORMAL_ADJUST;
+	cfg->dq_check_type = DDR_CHECK_TYPE_DDRT;
+	result = ddr_dataeye_training(cfg);
+	ddr_training_restore_reg(cfg, &relate_reg);
+
+	return result;
+}
+#else
+int ddr_dataeye_training_func(struct ddr_cfg_st *cfg)
+{
+	DDR_WARNING("Not support DDR dataeye training.");
+	return 0;
+}
+#endif  /* DDR_DATAEYE_TRAINING_CONFIG */
+
+#define __hardware_training__
+#ifdef DDR_HW_TRAINING_CONFIG
+#ifdef DDR_HW_READ_ADJ_CONFIG
+/**
+ * Adjust rdqs and dq after hw read training.
+ * When define DDR_TRAINING_ADJUST_DISABLE, MUST define DDR_HW_READ_ADJ_CONFIG.
+ */
+static void ddr_hw_read_adj(struct ddr_cfg_st *cfg)
+{
+	int i;
+	unsigned int base_phy = cfg->cur_phy;
+	unsigned int byte_num = cfg->phy[cfg->phy_idx].total_byte_num;
+
+	DDR_DEBUG("DDR hw read adjust.");
+	/* check hw read adjust bypass bit */
+	if (ddr_training_check_bypass(cfg, DDR_BYPASS_HW_ADJ_MASK))
+		return;
+
+	/* assume read dataeye window on left */
+	for (i = 0; i < byte_num; i++) {
+		ddr_write(ddr_read(base_phy + DDR_PHY_DXNRDQNBDL0(cfg->rank_idx, i))
+			+ (PHY_DQ_MIDDLE_VAL << PHY_BDL_DQ_BIT),
+			base_phy + DDR_PHY_DXNRDQNBDL0(cfg->rank_idx, i));
+		ddr_write(ddr_read(base_phy + DDR_PHY_DXNRDQNBDL1(cfg->rank_idx, i))
+			+ (PHY_DQ_MIDDLE_VAL << PHY_BDL_DQ_BIT),
+			base_phy + DDR_PHY_DXNRDQNBDL1(cfg->rank_idx, i));
+		ddr_write(ddr_read(base_phy + DDR_PHY_DXNRDQSDLY(i))
+			+ (PHY_RDQS_MIDDLE_VAL << PHY_RDQS_BDL_BIT),
+			base_phy + DDR_PHY_DXNRDQSDLY(i));
+	}
+}
+#else
+static void ddr_hw_read_adj(struct ddr_cfg_st *cfg) {}
+#endif /* DDR_HW_READ_ADJ_CONFIG */
+
+static void ddr_training_get_rdqs(struct ddr_cfg_st *cfg, struct ddr_bdl_st *rdqs)
+{
+	unsigned int i;
+	unsigned int byte_num = cfg->phy[cfg->phy_idx].total_byte_num;
+	unsigned int base_phy = cfg->cur_phy;
+
+	for(i = 0; i < byte_num; i++) {
+		rdqs->bdl[i] = ddr_read(base_phy + DDR_PHY_DXNRDQSDLY(i));
+	}
+}
+
+static void ddr_training_set_rdqs(struct ddr_cfg_st *cfg, struct ddr_bdl_st *rdqs)
+{
+	unsigned int i;
+	unsigned int byte_num = cfg->phy[cfg->phy_idx].total_byte_num;
+	unsigned int base_phy = cfg->cur_phy;
+
+	for (i = 0; i < byte_num; i++) {
+		ddr_write(rdqs->bdl[i], base_phy + DDR_PHY_DXNRDQSDLY(i));
+	}
+}
+
+static void ddr_hw_training_adjust_rdqs(struct ddr_cfg_st *cfg, struct rdqs_data_st *rdqs_st)
+{
+	unsigned int i;
+	unsigned int byte_num = cfg->phy[cfg->phy_idx].total_byte_num;
+	unsigned int rdqs_rank0, rdqs_rank1;
+	unsigned int cur_rank = cfg->rank_idx;
+	int offset;
+
+	for (i = 0; i < byte_num; i++) {
+		/* struct rdqs_data_st store the whole register value */
+		rdqs_rank0 = (rdqs_st->rank[0].bdl[i] >> PHY_RDQS_BDL_BIT) & PHY_RDQS_BDL_MASK;
+		rdqs_rank1 = (rdqs_st->rank[1].bdl[i] >> PHY_RDQS_BDL_BIT) & PHY_RDQS_BDL_MASK;
+
+		cfg->cur_byte = i;
+		if (rdqs_rank0 > rdqs_rank1) {
+			offset = rdqs_rank0 - rdqs_rank1;
+			ddr_write(rdqs_st->rank[0].bdl[i], cfg->cur_phy+ DDR_PHY_DXNRDQSDLY(i));
+			cfg->rank_idx = 1; /* switch to rank1 for sync rank1 rdq */
+		} else {
+			offset = rdqs_rank1 - rdqs_rank0;
+			ddr_write(rdqs_st->rank[1].bdl[i], cfg->cur_phy+ DDR_PHY_DXNRDQSDLY(i));
+			cfg->rank_idx = 0; /* switch to rank0 for sync rank0 rdq */
+		}
+		ddr_rdqs_sync_rank_rdq(cfg, offset);
+	}
+
+	cfg->rank_idx = cur_rank; /* restore to current rank */
+
+	ddr_phy_cfg_update(cfg->cur_phy);
+}
+
+/* DDR HW training process */
+static int ddr_hw_training_process(struct ddr_cfg_st *cfg, unsigned int item)
+{
+	unsigned int count = DDR_HWR_WAIT_TIMEOUT;
+	unsigned int base_phy = cfg->cur_phy;
+	unsigned int init_ctrl = ddr_read(base_phy + DDR_PHY_PHYINITCTRL);
+
+	if (!item)
+		return 0;
+
+	DDR_DEBUG("base_phy[%x] itme[%x]", base_phy, item);
+	/* hardware training enable */
+	ddr_write(item | PHY_PHYINITCTRL_INIT_EN | init_ctrl, base_phy + DDR_PHY_PHYINITCTRL);
+
+	if (item & PHY_PHYINITCTRL_DRAM_RST) {
+		if (ddr_training_ctrl_easr(cfg, DDR_EXIT_SREF))
+			return -1;
+	}
+
+	count = DDR_HWR_WAIT_TIMEOUT;
+	/* auto cleared to 0 after training finished */
+	while (count--) {
+		if (!(ddr_read(base_phy + DDR_PHY_PHYINITCTRL)
+			& PHY_PHYINITCTRL_MASK))
+			break;
+	}
+
+	if (count == 0xffffffff) {
+		DDR_FATAL("HWR wait timeout.");
+		ddr_training_stat(DDR_ERR_HW_RD_DATAEYE, base_phy, item, ddr_read(base_phy + DDR_PHY_PHYINITSTATUS)); /* TODO: */
+		return -1;
+	}
+
+	if (ddr_read(base_phy + DDR_PHY_PHYINITSTATUS)) {
+		DDR_FATAL("Phy[%x] hw[%x] failed[%x]", base_phy, item, ddr_read(base_phy + DDR_PHY_PHYINITSTATUS));
+		ddr_training_stat(DDR_ERR_HW_RD_DATAEYE, base_phy, item, ddr_read(base_phy + DDR_PHY_PHYINITSTATUS)); /* TODO: */
+		return -1;
+	}
+	return 0;
+}
+
+/* Dataeye hardware training */
+int ddr_hw_dataeye_read(struct ddr_cfg_st *cfg)
+{
+	unsigned int base_phy = cfg->cur_phy;
+	unsigned int byte_num = cfg->phy[cfg->phy_idx].total_byte_num;
+
+	unsigned int i;
+	int result;
+
+	ddr_training_cfg_init(cfg);
+	/* clear */
+	for (i = 0; i < byte_num; i++) {
+		ddr_write(0, base_phy + DDR_PHY_DXNRDQNBDL0(cfg->rank_idx, i));
+		ddr_write(0, base_phy + DDR_PHY_DXNRDQNBDL1(cfg->rank_idx, i));
+		ddr_write(0, base_phy + DDR_PHY_DXNRDQSDLY(i));
+	}
+
+	ddr_phy_cfg_update(base_phy);
+
+	result = ddr_hw_training_process(cfg, PHY_PHYINITCTRL_RDET_EN);
+
+	ddr_hw_read_adj(cfg);
+
+	return result;
+}
+
+/* DDR HW training control */
+int ddr_hw_training_ctl(struct ddr_cfg_st *cfg)
+{
+	int byte_idx;
+	int result = 0;
+	unsigned int temp = 0;
+	unsigned int item = cfg->cur_item;
+	unsigned int base_phy = cfg->cur_phy;
+	unsigned int byte_num = cfg->phy[cfg->phy_idx].total_byte_num;
+	unsigned int dvrft_ctrl = ddr_read(base_phy + DDR_PHY_DVRFTCTRL);
+	struct rdqs_data_st *rdqs_st = (struct rdqs_data_st *)cfg->res_st;
+
+	if (!item || !rdqs_st)
+		return 0;
+
+	ddr_phy_cfg_update(base_phy);
+	/* NOTE: not support array when boot */
+	result += ddr_hw_training_process(cfg, item & PHY_HW_GP_CNT_RESET_START);
+	result += ddr_hw_training_process(cfg, item & PHY_HW_GP_PLL);
+
+	/* save rdqs bdl after PHY_PHYINITCTRL_DLYMEAS_EN */
+	if (0 == cfg->rank_idx)
+		ddr_training_get_rdqs(cfg, &rdqs_st->origin);
+
+	for (byte_idx = 0; byte_idx < byte_num; byte_idx++) {
+		cfg->cur_byte = byte_idx;
+		ddr_bdl_adj(cfg);
+	}
+
+	if (PHY_DRAMCFG_TYPE_LPDDR4 == cfg->phy[cfg->phy_idx].dram_type) {
+		temp = ddr_read(base_phy + 0x64);
+		ddr_write(temp & 0x0fffffff, base_phy + 0x64); /* ca odt disable */
+
+		result += ddr_hw_training_process(cfg, item & PHY_HW_GP_DRAM_RESET);
+		ddr_write(temp, base_phy + 0x64); /* restore */
+
+		temp = ddr_read(base_phy + 0x48);
+		ddr_write(temp & 0xfffffffe, base_phy + 0x48); /* todo rank0 */
+
+		result += ddr_hw_training_process(cfg, item & PHY_HW_GP_VREF_AC);
+
+		ddr_write(temp | 0x1, base_phy + 0x48); /* rank1 */
+
+		result += ddr_hw_training_process(cfg, item & PHY_HW_GP_VREF_AC);
+
+		ddr_write(temp, base_phy + 0x48); /* restore */
+
+		/* ddr_training_delay(10000); */
+		result += ddr_hw_training_process(cfg, item & PHY_PHYINITCTRL_DRAM_INIT_EN);
+	} else {
+#ifdef DDR_WRITE_DM_DISABLE
+		if (PHY_DRAMCFG_TYPE_DDR4 == cfg->phy[cfg->phy_idx].dram_type) {
+			temp = ddr_read(base_phy + 0xe0);
+			ddr_write((temp & 0xFBFFFFFF) | 0x8000000, base_phy + 0xe0); /* write dm disable */
+		}
+#endif
+		result += ddr_hw_training_process(cfg, item & PHY_HW_GP_DRAM_RESET);
+	}
+	result += ddr_hw_training_process(cfg, item & PHY_PHYINITCTRL_CAT_EN);
+
+	result += ddr_hw_training_process(cfg, item & PHY_HW_GP_CS);
+
+	ddr_write(dvrft_ctrl & (~PHY_DVRFTCTRL_PDAEN_EN),
+		base_phy + DDR_PHY_DVRFTCTRL);
+	/* DDR_PHY_VREFTCTRL 31bit:1 do vref dram set twice */
+	ddr_write((ddr_read(base_phy + DDR_PHY_VREFTCTRL)
+		& (~(0x1 << PHY_VREFS_MRS_ENTER_BIT)))
+		| (0x1 << PHY_VREFS_MRS_ENTER_BIT),
+		base_phy + DDR_PHY_VREFTCTRL);
+	result += ddr_hw_training_process(cfg, item & PHY_HW_GP_VREF_DQ);
+	result += ddr_hw_training_process(cfg, item & PHY_HW_GP_VREF_DQ);
+	/* DDR_PHY_VREFTCTRL 31bit:0 do vref dram set once */
+	ddr_write(ddr_read(base_phy + DDR_PHY_VREFTCTRL)
+		& (~(0x1 << PHY_VREFS_MRS_ENTER_BIT)),
+		base_phy + DDR_PHY_VREFTCTRL);
+	result += ddr_hw_training_process(cfg, item & PHY_HW_GP_VREF_DQ);
+	ddr_write(dvrft_ctrl, base_phy + DDR_PHY_DVRFTCTRL);
+
+	result += ddr_hw_training_process(cfg, item & PHY_HW_GP_NORMAL);
+
+#ifdef DDR_WRITE_DM_DISABLE
+	unsigned int temp1 = 0;
+	if (PHY_DRAMCFG_TYPE_DDR4 == cfg->phy[cfg->phy_idx].dram_type) {
+		ddr_write(temp, base_phy + 0xe0); /* restore */
+		temp = ddr_read(base_phy + 0x1e0);
+		temp1 = ddr_read(base_phy + 0x2c);
+		ddr_write(0x05555555, base_phy + 0x1e0); /* inti MR5 */
+		ddr_write(temp1 | 0x00004000 , base_phy + 0x2c); /* write dm disable */
+		result += ddr_hw_training_process(cfg, item & PHY_PHYINITCTRL_DRAM_INIT_EN);
+		ddr_write(temp, base_phy + 0x1e0); /* restore */
+		ddr_write(temp1, base_phy + 0x2c); /* restore */
+	}
+#endif
+	ddr_phy_cfg_update(base_phy);
+
+	return result;
+}
+
+static int ddr_hw_training_by_rank(struct ddr_cfg_st *cfg)
+{
+	DDR_DEBUG("PHY[%x][%x] Rank[%x] itme[%x]",
+		cfg->phy_idx, cfg->cur_phy, cfg->rank_idx, cfg->cur_item);
+
+	/* 0:PHY_TRAINCTRL0_DTR_RANK0, 1:PHY_TRAINCTRL0_DTR_RANK1 */
+	DDR_PHY_SWITCH_RANK(cfg->cur_phy, cfg->rank_idx);
+	return ddr_hw_training_ctl(cfg);
+}
+
+static int ddr_hw_training_by_phy(struct ddr_cfg_st *cfg)
+{
+	int result = 0;
+	int i;
+	struct rdqs_data_st rdqs_data;
+	struct rdqs_data_st *rdqs_st = &rdqs_data;
+	struct ddr_timing_st timing_st;
+	unsigned int rank_num = cfg->phy[cfg->phy_idx].rank_num;
+
+	cfg->res_st = rdqs_st;
+
+	/* disable auto refresh */
+	ddr_training_save_timing(cfg, &timing_st);
+
+	for (i = 0; i < rank_num; i++) {
+		cfg->rank_idx = i;
+		cfg->cur_item = cfg->phy[cfg->phy_idx].rank[i].item_hw;
+
+		result += ddr_hw_training_by_rank(cfg);
+
+		if (DDR_SUPPORT_RANK_MAX != rank_num)
+			break;
+
+		/* save rank rdqs bdl */
+		ddr_training_get_rdqs(cfg, &(rdqs_st->rank[i]));
+
+		/* restore PHY_PHYINITCTRL_DLYMEAS_EN rdqs before training next rank */
+		if ((rank_num - 1) != i)
+			ddr_training_set_rdqs(cfg, &(rdqs_st->origin));
+	}
+
+	if (DDR_SUPPORT_RANK_MAX == rank_num) {
+		ddr_hw_training_adjust_rdqs(cfg, rdqs_st);
+	}
+
+	/* restore auto refresh */
+	ddr_training_restore_timing(cfg, &timing_st);
+
+	cfg->res_st = 0;
+
+	return result;
+}
+
+/* DDR hardware training */
+int ddr_hw_training(struct ddr_cfg_st *cfg)
+{
+	int result = 0;
+	int i;
+	struct tr_relate_reg reg;
+
+	/* save customer reg */
+	DDR_TRAINING_SAVE_REG_FUNC(&reg, 0x1);
+	ddr_boot_cmd_save_func(&reg);
+
+	for (i = 0; i < cfg->phy_num; i++) {
+		cfg->phy_idx = i;
+		cfg->cur_phy = cfg->phy[i].addr;
+		result += ddr_hw_training_by_phy(cfg);
+	}
+	/* restore customer reg */
+	DDR_TRAINING_RESTORE_REG_FUNC(&reg);
+	ddr_boot_cmd_restore_func(&reg);
+
+	return result;
+}
+#endif /* DDR_HW_TRAINING_CONFIG */
+
+#define __mpr_training__
+#ifdef DDR_MPR_TRAINING_CONFIG
+/* Switch MPR function */
+static void ddr_mpr_switch(unsigned int base_dmc, int val)
+{
+	unsigned int sfc_cmd;
+	if (DDR_TRUE == val)
+		sfc_cmd = (DMC_CMD_MRS_MR3 << DMC_SFC_CMD_MRS_BIT)
+			| DMC_CMD_TYPE_LMR;
+	else
+		sfc_cmd = DMC_CMD_TYPE_LMR;
+
+	ddr_dmc_sfc_cmd(base_dmc, sfc_cmd, 0x0, DMC_BANK_MR3);
+
+	/* clear */
+	if (DDR_FALSE == val) {
+		ddr_write(0x0, base_dmc + DDR_DMC_SFCBANK);
+		ddr_write(0x0, base_dmc + DDR_DMC_SFCREQ);
+	}
+}
+
+/* Judge MPR data */
+static int ddr_mpr_judge(unsigned int data1, unsigned int data2,
+			 unsigned int data3, unsigned int data4,
+			 unsigned int dq_index)
+{
+	/* check byte */
+	if (-1 == dq_index) {
+		if (DDR_MPR_BYTE_MASK == data1 && 0x0 == data2
+			&& DDR_MPR_BYTE_MASK == data3 && 0x0 == data4)
+			return 0;
+		else
+			return -1;
+	} else {
+		/* check DQ */
+		data1 = (data1 >> dq_index) & DDR_MPR_BIT_MASK;
+		data2 = (data2 >> dq_index) & DDR_MPR_BIT_MASK;
+		data3 = (data3 >> dq_index) & DDR_MPR_BIT_MASK;
+		data4 = (data4 >> dq_index) & DDR_MPR_BIT_MASK;
+		if (DDR_MPR_BIT_MASK == data1 && 0x0 == data2
+			&& DDR_MPR_BIT_MASK == data3 && 0x0 == data4)
+			return 0;
+		else
+			return -1;
+	}
+}
+
+/* Extract MPR read data to judge */
+static int ddr_mpr_extract(struct ddr_cfg_st *cfg,
+			   unsigned int offset0, unsigned int offset1,
+			   unsigned int offset2, unsigned int offset3)
+{
+	unsigned int data1, data2, data3, data4;
+	unsigned int base_dmc = cfg->cur_dmc;
+	unsigned int byte_index = cfg->cur_byte;
+
+	data1 = ddr_read(base_dmc + offset0);  /* [127:96] or [255:224] */
+	data2 = ddr_read(base_dmc + offset1);  /* [95:64] or [223:192] */
+	data3 = ddr_read(base_dmc + offset2);  /* [63:32] or [191:160] */
+	data4 = ddr_read(base_dmc + offset3);  /* [31:0] or [159:128] */
+
+	DDR_INFO("byte[%x] data[%x=%x][%x=%x][%x=%x][%x=%x]",
+		byte_index,
+		base_dmc + offset0, data1, base_dmc + offset1, data2,
+		base_dmc + offset2, data3, base_dmc + offset3, data4);
+
+	if (DDR_PHY_BYTE_MAX == GET_BYTE_NUM(cfg)) {
+		/* four byte: data1[0xFFFFFFFF] data2[0x00000000]
+		data3[0xFFFFFFFF] data4[0x00000000] */
+		data1 = (data1 >> (byte_index << 3)) & DDR_MPR_BYTE_MASK;
+		data2 = (data2 >> (byte_index << 3)) & DDR_MPR_BYTE_MASK;
+		data3 = (data3 >> (byte_index << 3)) & DDR_MPR_BYTE_MASK;
+		data4 = (data4 >> (byte_index << 3)) & DDR_MPR_BYTE_MASK;
+	} else {
+		/* two byte: data1[0xFFFF0000] data2[0xFFFF0000]
+		data3[0xFFFF0000] data4[0xFFFF0000] */
+		data1 = ((data1 >> DDR_MPR_BYTE_BIT) >> (byte_index << 3))
+				& DDR_MPR_BYTE_MASK;
+		data2 = (data2 >> (byte_index << 3)) & DDR_MPR_BYTE_MASK;
+		data3 = ((data3 >> DDR_MPR_BYTE_BIT) >> (byte_index << 3))
+				& DDR_MPR_BYTE_MASK;
+		data4 = (data4 >> (byte_index << 3)) & DDR_MPR_BYTE_MASK;
+		if (ddr_mpr_judge(data1, data2, data3, data4, cfg->cur_dq))
+			return -1;
+
+		/* two byte need to swap data and check again */
+		data1 = ((ddr_read(base_dmc + DDR_DMC_SFC_RDATA1)
+				>> DDR_MPR_BYTE_BIT) >> (byte_index << 3))
+				& DDR_MPR_BYTE_MASK;
+		data2 = (ddr_read(base_dmc + DDR_DMC_SFC_RDATA0)
+				>> (byte_index << 3)) & DDR_MPR_BYTE_MASK;
+		data3 = ((ddr_read(base_dmc + DDR_DMC_SFC_RDATA3)
+			>> DDR_MPR_BYTE_BIT) >> (byte_index << 3))
+			& DDR_MPR_BYTE_MASK;
+		data4 = (ddr_read(base_dmc + DDR_DMC_SFC_RDATA2)
+			>> (byte_index << 3)) & DDR_MPR_BYTE_MASK;
+	}
+
+	return ddr_mpr_judge(data1, data2, data3, data4, cfg->cur_dq);
+}
+
+/* Check MPR read data */
+int ddr_mpr_check(struct ddr_cfg_st *cfg)
+{
+	/* read data */
+	ddr_dmc_sfc_cmd(cfg->cur_dmc, DMC_CMD_TYPE_READ, 0x0, 0x0);
+	return DMC_MPR_CHECK_BIT_0_127(cfg);
+}
+
+/* Find RDQ via MPR */
+static int ddr_mpr_find_rdq(struct ddr_cfg_st *cfg)
+{
+	struct training_data tmp_result;
+	struct training_data *training = &tmp_result;
+	unsigned int dq_num;
+	unsigned int win_num;
+	unsigned int def_dq, best_dq;
+	unsigned int byte_index, dq_index;
+
+	/* find rdq via mpr */
+	cfg->dq_check_type = DDR_CHECK_TYPE_MPR;
+
+	/* find rdq */
+	for (byte_index = 0;
+		byte_index < GET_BYTE_NUM(cfg); byte_index++) {
+		for (dq_index = 0; dq_index < DDR_PHY_BIT_NUM; dq_index++) {
+			dq_num = (byte_index << 3) + dq_index;
+			def_dq = ddr_phy_get_dq_bdl(cfg);
+			ddr_dataeye_find_dq(cfg, training);
+			win_num = training->ddr_bit_best[dq_num]
+				>> DDR_DATAEYE_RESULT_BIT;
+			best_dq = training->ddr_bit_best[dq_num]
+				& DDR_DATAEYE_RESULT_MASK;
+			if (win_num > 0)
+				ddr_phy_set_dq_bdl(cfg, best_dq);
+			else {
+				/* In normal case, not reach here */
+				/* restore default value */
+				ddr_phy_set_dq_bdl(cfg, def_dq);
+
+				DDR_FATAL("PHY[%x] Byte[%x] DQ[%x] MPR fail",
+					cfg->cur_phy, byte_index, dq_index);
+				ddr_training_stat(DDR_ERR_MPR, cfg->cur_phy,
+					byte_index, dq_index);
+				return -1;
+			}
+		}
+	}
+
+	return 0;
+
+}
+
+/* Find RDQS via MPR */
+static int ddr_mpr_find_rdqs(struct ddr_cfg_st *cfg)
+{
+	unsigned int rdqs_start = 0;
+	unsigned int rdqs_end   = PHY_RDQS_BDL_MASK;
+	unsigned int rdqs_mid;
+	unsigned int val, delay;
+	unsigned int count = 0;
+	int found = DDR_FALSE;
+	unsigned int base_phy = cfg->cur_phy;
+	unsigned int byte_index = cfg->cur_byte;
+
+	/* set rdq to middle value */
+	ddr_write(PHY_DQ_MIDDLE_VAL << PHY_BDL_DQ_BIT, base_phy + DDR_PHY_DXNRDQNBDL0(cfg->rank_idx, byte_index));
+	ddr_write(PHY_DQ_MIDDLE_VAL << PHY_BDL_DQ_BIT, base_phy + DDR_PHY_DXNRDQNBDL1(cfg->rank_idx, byte_index));
+
+	/* clear rdqs */
+	delay    = ddr_read(base_phy + DDR_PHY_DXNRDQSDLY(byte_index)) >> PHY_RDQS_BDL_BIT;
+	rdqs_mid = delay;   /* if not found, restore default value */
+	delay    = delay & (~PHY_RDQS_BDL_MASK);
+
+	/* find rdqs */
+	for (val = 0; val <= PHY_RDQS_BDL_MASK; val++) {
+		ddr_write(delay | (val << PHY_RDQS_BDL_BIT),
+			base_phy + DDR_PHY_DXNRDQSDLY(byte_index));
+		ddr_phy_cfg_update(base_phy);
+		/* check ok */
+		if (!ddr_mpr_check(cfg)) {
+			if (DDR_FALSE == found) {
+				rdqs_start = val; /* found start value */
+				count++;
+				if (DDR_MPR_RDQS_FIND_TIMES == count)
+					found = DDR_TRUE;
+			}
+		} else {
+			if (DDR_TRUE == found) {
+				rdqs_end = val;  /* found end value */
+				break;
+			}
+		}
+	}
+
+	if (DDR_TRUE == found) {
+		rdqs_mid = ((rdqs_end - rdqs_start) >> 1) + rdqs_start;
+		DDR_INFO("PHY[%x] Byte[%x] rdqs_middle[%x]",
+				base_phy, byte_index, rdqs_mid);
+		DDR_INFO("rdqs_start[%x] rdqs_end[%x]",
+				rdqs_start, rdqs_end);
+	} else {
+		DDR_FATAL("PHY[%x] Byte[%x] not find RDQS, restore.",
+			base_phy, byte_index);
+		ddr_training_stat(DDR_ERR_MPR, base_phy,
+					byte_index, -1);
+	}
+
+	ddr_write(delay | (rdqs_mid << PHY_RDQS_BDL_BIT), base_phy + DDR_PHY_DXNRDQSDLY(byte_index));
+	ddr_phy_cfg_update(base_phy);
+
+	return ((DDR_TRUE == found) ? 0 : -1);
+}
+
+/* Multi Purpose Register(MPR) */
+int ddr_mpr_training(struct ddr_cfg_st *cfg)
+{
+	int i;
+	int result = 0;
+	unsigned int byte_num = GET_BYTE_NUM(cfg);
+	unsigned int mr0;
+	unsigned int sfc_cmd;
+	unsigned int base_dmc = cfg->cur_dmc;
+	unsigned int base_phy = cfg->cur_phy;
+
+	DDR_DEBUG("DDR MPR training.");
+
+	/* set DDR bust */
+	if (DDR_PHY_BYTE_MAX == byte_num) {
+		mr0 = (ddr_read(base_phy + DDR_PHY_MODEREG01)
+			& DMC_MRS_MASK)
+			& (~DMC_MR0_BL_MASK);
+		sfc_cmd = ((mr0 | DMC_MR0_BL_BUST4)
+			<< DMC_SFC_CMD_MRS_BIT)
+			| DMC_CMD_TYPE_LMR;
+		ddr_dmc_sfc_cmd(base_dmc, sfc_cmd, 0x0, 0x0);
+	}
+
+	/* precharge all */
+	ddr_dmc_sfc_cmd(base_dmc, DMC_CMD_TYPE_PRECHARGE_ALL, 0x0, 0x0);
+
+	/* enable MPR */
+	ddr_mpr_switch(base_dmc, DDR_TRUE);
+
+	/* find rdqs */
+	for (i = 0; i < byte_num; i++)
+		result += ddr_mpr_find_rdqs(cfg);
+
+	/* find rdq */
+	if (!result)
+		result = ddr_mpr_find_rdq(cfg);
+
+	/* disable MPR */
+	ddr_mpr_switch(base_dmc, DDR_FALSE);
+
+	/* restore DDR bust */
+	if (DDR_PHY_BYTE_MAX == byte_num) {
+		mr0 = (ddr_read(base_phy + DDR_PHY_MODEREG01)
+			& DMC_MRS_MASK);
+		sfc_cmd = (mr0 << DMC_SFC_CMD_MRS_BIT)
+			| DMC_CMD_TYPE_LMR;
+		ddr_dmc_sfc_cmd(base_dmc, sfc_cmd, 0x0, 0x0);
+	}
+	return result;
+}
+
+int ddr_mpr_training_func(struct ddr_cfg_st *cfg)
+{
+	struct tr_relate_reg relate_reg;
+	int result = 0;
+
+	/* MPR training disable */
+	if (ddr_training_check_bypass(cfg, DDR_BYPASS_MPR_MASK))
+		return 0;
+
+	ddr_training_save_reg(cfg, &relate_reg, DDR_BYPASS_MPR_MASK);
+	result = ddr_mpr_training(cfg);
+	ddr_training_restore_reg(cfg, &relate_reg);
+
+	return result;
+}
+#endif /* DDR_MPR_TRAINING_CONFIG */
+
+#define __vref_training__
+#ifdef DDR_VREF_TRAINING_CONFIG
+#ifdef DDR_VREF_WITHOUT_BDL_CONFIG
+/* Save dataeye dq bdl before vref training */
+static void ddr_vref_save_bdl(struct ddr_cfg_st *cfg, struct tr_dq_data *dq_data)
+{
+	int i;
+	unsigned int base_phy = cfg->cur_phy;
+	unsigned int rank = cfg->rank_idx;
+	unsigned int byte_index;
+
+	for (i = 0; i < GET_BYTE_NUM(cfg); i++) {
+		byte_index = i + (cfg->dmc_idx << 1); /* byte index accord to phy */
+		if (DDR_MODE_WRITE == cfg->cur_mode) {
+			dq_data->dq03[i] = ddr_read(base_phy + DDR_PHY_DXNWDQNBDL0(rank, byte_index));
+			dq_data->dq47[i] = ddr_read(base_phy + DDR_PHY_DXNWDQNBDL1(rank, byte_index));
+			dq_data->wdm[i] = ddr_read(base_phy + DDR_PHY_DXNWDQNBDL2(rank, byte_index));
+		} else {
+			dq_data->dq03[i] = ddr_read(base_phy + DDR_PHY_DXNRDQNBDL0(rank, byte_index));
+			dq_data->dq47[i] = ddr_read(base_phy + DDR_PHY_DXNRDQNBDL1(rank, byte_index));
+		}
+	}
+}
+
+/* Restore dataeye dq bdl after vref training */
+static void ddr_vref_restore_bdl(struct ddr_cfg_st *cfg, struct tr_dq_data *dq_data)
+{
+	int i;
+	unsigned int base_phy = cfg->cur_phy;
+	unsigned int rank = cfg->rank_idx;
+	unsigned int byte_index;
+
+	for (i = 0; i < GET_BYTE_NUM(cfg); i++) {
+		byte_index = i + (cfg->dmc_idx << 1); /* byte index accord to phy */
+		if (DDR_MODE_WRITE == cfg->cur_mode) {
+			ddr_write(dq_data->dq03[i], base_phy + DDR_PHY_DXNWDQNBDL0(rank, byte_index));
+			ddr_write(dq_data->dq47[i], base_phy + DDR_PHY_DXNWDQNBDL1(rank, byte_index));
+			ddr_write(dq_data->wdm[i], base_phy + DDR_PHY_DXNWDQNBDL2(rank, byte_index));
+		} else {
+			ddr_write(dq_data->dq03[i], base_phy + DDR_PHY_DXNRDQNBDL0(rank, byte_index));
+			ddr_write(dq_data->dq47[i], base_phy + DDR_PHY_DXNRDQNBDL1(rank, byte_index));
+		}
+	}
+}
+#else
+static void ddr_vref_save_bdl(struct ddr_cfg_st *cfg, struct tr_dq_data *dq_data)
+{
+}
+static void ddr_vref_restore_bdl(struct ddr_cfg_st *cfg, struct tr_dq_data *dq_data)
+{
+}
+#endif /* DDR_VREF_WITHOUT_BDL_CONFIG */
+
+/* Set DDR Vref value */
+static void ddr_vref_set(struct ddr_cfg_st *cfg, unsigned int val)
+{
+	if (DDR_MODE_READ == cfg->cur_mode) { /* HOST vref */
+		DDR_PHY_VREF_HOST_SET(cfg->cur_phy, cfg->rank_idx, GET_BYTE_NUM(cfg), cfg->cur_byte, val); /* TODO */
+	} else {	  /* DRAM vref */
+		unsigned int auto_ref_timing =
+			ddr_read(cfg->cur_dmc + DDR_DMC_TIMING2);
+		/* disable auto refresh */
+		ddr_training_set_timing(cfg->cur_dmc,
+			auto_ref_timing & DMC_AUTO_TIMING_DIS);
+
+		/* DDR_PHY_VREFTCTRL 31bit:1 do vref dram set twice */
+		ddr_write((ddr_read(cfg->cur_phy + DDR_PHY_VREFTCTRL)
+			& (~(0x1 << PHY_VREFS_MRS_ENTER_BIT)))
+			| (0x1 << PHY_VREFS_MRS_ENTER_BIT),
+			cfg->cur_phy + DDR_PHY_VREFTCTRL);
+		DDR_PHY_VREF_DRAM_SET(cfg->cur_phy, val, cfg->cur_byte);
+		DDR_PHY_VREF_DRAM_SET(cfg->cur_phy, val, cfg->cur_byte);
+		/* DDR_PHY_VREFTCTRL 31bit:0 do vref dram set once */
+		ddr_write(ddr_read(cfg->cur_phy + DDR_PHY_VREFTCTRL)
+			& (~(0x1 << PHY_VREFS_MRS_ENTER_BIT)),
+			cfg->cur_phy + DDR_PHY_VREFTCTRL);
+		DDR_PHY_VREF_DRAM_SET(cfg->cur_phy, val, cfg->cur_byte);
+
+		/* enable auto refresh */
+		ddr_training_set_timing(cfg->cur_dmc, auto_ref_timing);
+	}
+	DDR_INFO("byte[%x] mode[%x] set vref [%x]", cfg->cur_byte, cfg->cur_mode, val);
+}
+
+/* Get DDR Vref value */
+static unsigned int ddr_vref_get(struct ddr_cfg_st *cfg)
+{
+	unsigned int val = 0;
+
+	if (DDR_MODE_READ == cfg->cur_mode) {	/* HOST vref */
+		DDR_PHY_VREF_HOST_GET(cfg->cur_phy, cfg->rank_idx, cfg->cur_byte, val);
+	} else {      /* DRAM vref */
+		DDR_PHY_VREF_DRAM_GET(cfg->cur_phy, val, cfg->cur_byte);
+	}
+	DDR_INFO("byte[%x] mode[%x] get vref [%x]", cfg->cur_byte, cfg->cur_mode, val);
+	return val;
+}
+
+/* Get totol win number of training result */
+static unsigned int ddr_vref_get_win(struct ddr_cfg_st *cfg,
+	struct training_data *training, int vref)
+{
+	unsigned int vref_min = 0;
+	unsigned int vref_max = DDR_VREF_DRAM_VAL_MAX;
+	int vref_set;
+
+	training->ddr_win_sum = 0;
+
+    if (DDR_MODE_READ == cfg->cur_mode) {
+		DDR_VREF_GET_HOST_MAX(cfg->rank_idx, vref_max);
+    }
+
+	if (vref < vref_min)
+		vref_set = vref_min;
+	else if (vref > vref_max)
+		vref_set = vref_max;
+	else
+		vref_set = vref;
+
+	ddr_vref_set(cfg, vref_set);
+
+	ddr_dataeye_deskew(cfg, training);
+
+	return training->ddr_win_sum;
+}
+
+/* Find the best vref which win number is max */
+static unsigned int ddr_vref_find_best(struct ddr_cfg_st *cfg,
+	struct training_data *training, unsigned int vref, int step)
+{
+	int cur_vref;
+	unsigned int best_vref;
+	unsigned int cur_win;
+	unsigned int max_win;
+	unsigned int lower_times = 0;
+	unsigned int vref_min = 0;
+	unsigned int vref_max = DDR_VREF_DRAM_VAL_MAX;
+
+    if (DDR_MODE_READ == cfg->cur_mode) {
+		DDR_VREF_GET_HOST_MAX(cfg->rank_idx, vref_max);
+    }
+
+	max_win   = 0;
+	cur_vref  = vref + step;
+
+	if (vref < vref_min)
+		best_vref = vref_min;
+	else if (vref > vref_max)
+		best_vref = vref_max;
+	else
+		best_vref = vref;
+
+	/* find parabola vertex */
+	while (cur_vref >= vref_min
+		&& cur_vref <= vref_max) {
+		cur_win = ddr_vref_get_win(cfg, training, cur_vref);
+		DDR_DEBUG("byte[%x] vref[%x] win[%x] mode[%x]",
+			cfg->cur_byte, cur_vref, cur_win, cfg->cur_mode);
+		if (cur_win < max_win) {
+			lower_times++;
+			if (DDR_VREF_COMPARE_TIMES == lower_times) {
+				/* Continuous decline, mean found vertex */
+				break;
+			}
+		} else {
+			lower_times = 0;
+			max_win =  cur_win;
+			best_vref = cur_vref;
+		}
+		cur_vref = cur_vref + step;
+	}
+
+	return best_vref;
+}
+
+/* DDR Vref calibrate and set the best value */
+static void ddr_vref_cal(struct ddr_cfg_st *cfg, struct training_data *training)
+{
+	unsigned int def_vref;
+	unsigned int best_vref;
+	unsigned int left_win;
+	unsigned int right_win;
+
+	def_vref  = ddr_vref_get(cfg);
+	left_win  = ddr_vref_get_win(cfg, training, def_vref - DDR_VREF_COMPARE_STEP);
+	right_win = ddr_vref_get_win(cfg, training, def_vref + DDR_VREF_COMPARE_STEP);
+
+	DDR_DEBUG("byte[%x] default vref[%x] win[%x][%x] mode[%x]",
+		cfg->cur_byte, def_vref, left_win, right_win, cfg->cur_mode);
+
+	/* With vref increments, WIN number is a parabola.
+	   So firstly determine the result on left or right. */
+	/* parabola vertex */
+	if (left_win < right_win) { /* the result on right */
+		best_vref = ddr_vref_find_best(cfg, training, def_vref, 1);
+	} else if (left_win > right_win) { /* the result on left */
+		best_vref = ddr_vref_find_best(cfg, training, def_vref, -1);
+	} else {
+		/* when (left_win == right_win), check def_vref */
+        unsigned int vref_max = DDR_VREF_DRAM_VAL_MAX;
+        if (DDR_MODE_READ == cfg->cur_mode) {
+            DDR_VREF_GET_HOST_MAX(cfg->rank_idx, vref_max);
+        }
+
+		if (def_vref < (vref_max >> 1))
+			best_vref = ddr_vref_find_best(cfg, training, def_vref, 1);
+		else
+			best_vref = ddr_vref_find_best(cfg, training, def_vref, -1);
+	}
+
+
+	DDR_DEBUG("byte[%x] best vref[%x] mode[%x]",
+		cfg->cur_byte, best_vref, cfg->cur_mode);
+	ddr_vref_set(cfg, best_vref);
+}
+
+int ddr_vref_training(struct ddr_cfg_st *cfg)
+{
+	struct training_data tmp_result;
+	struct training_data *training = &tmp_result;
+	struct tr_dq_data dq_data;
+	int result = 0;
+	int i;
+
+	DDR_DEBUG("DDR Vref[%x] training PHY[%x][%x] DMC[%x][%x] Rank[%x]",
+		cfg->cur_mode, cfg->phy_idx, cfg->cur_phy, cfg->dmc_idx,
+		cfg->cur_dmc, cfg->rank_idx);
+
+	ddr_vref_save_bdl(cfg, &dq_data);
+	ddrtr_memset(training, 0, sizeof(struct training_data));
+
+	/* vref calibrate */
+	if (DDR_MODE_READ == cfg->cur_mode) {
+		/* only training byte0 and byte2 */
+		for (i = 0; i < GET_BYTE_NUM(cfg); i++) {
+			cfg->cur_byte = i + (cfg->dmc_idx << 1); /* byte index accord to phy */
+			if (1 == cfg->cur_byte || 3 == cfg->cur_byte)
+				continue;
+
+			ddr_vref_cal(cfg, training);
+		}
+	} else {
+		unsigned int dram_type = cfg->phy[cfg->phy_idx].dram_type;
+		unsigned int bank_group = (ddr_read(cfg->cur_dmc
+					+ DDR_DMC_CFG_RNKVOL(cfg->rank_idx)) >> DMC_CFG_MEM_BG_BIT)
+					& DMC_CFG_MEM_BG_MASK;
+
+		if (PHY_DRAMCFG_TYPE_LPDDR4 != dram_type
+		&& PHY_DRAMCFG_TYPE_DDR4 != dram_type)
+			return 0;
+
+		if (PHY_DRAMCFG_TYPE_LPDDR4 == dram_type)
+			bank_group = DMC_CFG_MEM_2BG; /* lpddr4 not training byte1 byte3 */
+
+		for (i = 0; i < GET_BYTE_NUM(cfg); i++) {
+			cfg->cur_byte = i + (cfg->dmc_idx << 1); /* byte index accord to phy */
+			/* byte1 and byte3 bypass when 2 Bank Group */
+			if ((DMC_CFG_MEM_2BG == bank_group)
+				&& ((1 == i) || (3 == i)))
+				continue;
+
+			ddr_vref_cal(cfg, training);
+		}
+	}
+
+#if !defined(DDR_VREF_WITHOUT_BDL_CONFIG) || defined(DDR_TRAINING_CMD)
+	/* dataeye deskew again on best vref. */
+	for (i = 0; i < GET_BYTE_NUM(cfg); i++) {
+		cfg->cur_byte = i + (cfg->dmc_idx << 1); /* byte index accord to phy */
+		result += ddr_dataeye_deskew(cfg, training);
+	}
+#endif
+
+	ddr_vref_restore_bdl(cfg, &dq_data);
+
+	ddr_result_data_save(cfg, training);
+
+	return result;
+}
+
+int ddr_vref_training_func(struct ddr_cfg_st *cfg)
+{
+	struct tr_relate_reg relate_reg;
+	int result = 0;
+
+	ddr_training_save_reg(cfg, &relate_reg, DDR_BYPASS_VREF_HOST_MASK);
+	ddr_training_switch_axi(cfg);
+	ddr_ddrt_init(cfg, DDR_DDRT_MODE_DATAEYE);
+	cfg->dq_check_type = DDR_CHECK_TYPE_DDRT;
+
+	/* host vref training disable */
+	if (!ddr_training_check_bypass(cfg, DDR_BYPASS_VREF_HOST_MASK)) {
+		cfg->cur_mode = DDR_MODE_READ;
+		result += ddr_vref_training(cfg);
+	}
+
+	/* dram vref training enable && DDR4 */
+	if (!ddr_training_check_bypass(cfg, DDR_BYPASS_VREF_DRAM_MASK)) {
+		cfg->cur_mode = DDR_MODE_WRITE;
+		result += ddr_vref_training(cfg);
+	}
+	ddr_training_restore_reg(cfg, &relate_reg);
+
+	return result;
+}
+#else
+int ddr_vref_training_func(struct ddr_cfg_st *cfg)
+{
+	DDR_WARNING("Not support DDR vref training.");
+	return 0;
+}
+#endif /* DDR_VREF_TRAINING_CONFIG */
+
+#define __write_leveling__
+#ifdef DDR_WL_TRAINING_CONFIG
+static void ddr_bdl_add(unsigned int *raw, unsigned int val)
+{
+	if (((*raw) + val) > PHY_BDL_MASK)
+		*raw = PHY_BDL_MASK;
+	else
+		*raw += val;
+}
+
+static void ddr_bdl_sub(unsigned int *raw, unsigned int val)
+{
+	if ((*raw) > val)
+		*raw -= val;
+	else
+		*raw = 0;
+}
+
+/* DDR PHY DQ phase increase */
+static void ddr_phase_inc(unsigned int *raw)
+{
+#if defined (DDR_PHY_T28_CONFIG) || defined(DDR_PHY_T16_CONFIG) \
+		|| defined (DDR_PHY_T12_V100_CONFIG) || defined (DDR_PHY_T12_V101_CONFIG)
+	if ((*raw) < (PHY_WDQS_PHASE_MASK - 1)) {
+		if (((*raw) & 0x3) == 0x2)
+			*raw += 0x2;
+		else
+			*raw += 0x1;
+	}
+#else
+	if ((*raw) < PHY_WDQS_PHASE_MASK)
+		*raw += 0x1;
+#endif
+}
+
+/* DDR PHY DQ phase decrease */
+static void ddr_phase_dec(unsigned int *raw)
+{
+#if defined (DDR_PHY_T28_CONFIG) || defined(DDR_PHY_T16_CONFIG) \
+		|| defined (DDR_PHY_T12_V100_CONFIG) || defined (DDR_PHY_T12_V101_CONFIG)
+	if ((*raw) > 0x1) {
+		if (((*raw) & 0x3) == 0x3)
+			*raw -= 0x2;
+		else
+			*raw -= 0x1;
+	}
+#else
+	if ((*raw) > 0x0)
+		*raw -= 0x1;
+#endif
+}
+
+/* DQ bdl add or sub */
+static void ddr_dq_bdl_operate(unsigned int base_phy,
+	unsigned int addr_offset, unsigned int val, unsigned int is_add)
+{
+	unsigned int tmp;
+	unsigned int dq_bdl[DDR_PHY_REG_DQ_NUM];
+	int i;
+
+	tmp = ddr_read(base_phy + addr_offset);
+	dq_bdl[0] = (tmp >> PHY_BDL_DQ0_BIT)  & PHY_BDL_MASK;
+	dq_bdl[1] = (tmp >> PHY_BDL_DQ1_BIT)  & PHY_BDL_MASK;
+	dq_bdl[2] = (tmp >> PHY_BDL_DQ2_BIT) & PHY_BDL_MASK;
+	dq_bdl[3] = (tmp >> PHY_BDL_DQ3_BIT) & PHY_BDL_MASK;
+
+	for (i = 0; i < DDR_PHY_REG_DQ_NUM; i++) {
+		if (is_add)
+			ddr_bdl_add(&dq_bdl[i], val);
+		else
+			ddr_bdl_sub(&dq_bdl[i], val);
+	}
+
+	tmp = (dq_bdl[3] << PHY_BDL_DQ3_BIT) + (dq_bdl[2] << PHY_BDL_DQ2_BIT)
+		+ (dq_bdl[1] << PHY_BDL_DQ1_BIT)  + (dq_bdl[0] << PHY_BDL_DQ0_BIT);
+	ddr_write(tmp, base_phy + addr_offset);
+}
+
+/* Disable or enable DDR write leveling mode */
+static void ddr_wl_switch(unsigned int base_dmc, unsigned int base_phy,
+			int val)
+{
+	unsigned int mr1_raw;
+	unsigned int sfc_cmd;
+	unsigned int sfc_bank;
+
+	/* Set Rank = 0, Cmd = MRS, No Precharch CMD */
+	mr1_raw = ddr_read(base_phy + DDR_PHY_MODEREG01)
+		>> PHY_MODEREG01_MR1_BIT;
+	sfc_cmd  = DMC_CMD_TYPE_LMR;
+	sfc_bank = DMC_BANK_MR1;
+
+	if (DDR_TRUE == val) { /* enable DDR wl */
+		/* Set A7 = 1 */
+		sfc_cmd  += (mr1_raw | DMC_CMD_MRS_A7) << DMC_SFC_CMD_MRS_BIT;
+	} else {
+
+		/* Set A7 = 0 */
+		sfc_cmd  += (mr1_raw & ((~DMC_CMD_MRS_A7) & DMC_CMD_MRS_MASK))
+					<< DMC_SFC_CMD_MRS_BIT;
+	}
+
+	ddr_dmc_sfc_cmd(base_dmc, sfc_cmd, 0x0, sfc_bank);
+
+	/* clear */
+	if (DDR_FALSE == val) {
+		ddr_write(0x0, base_dmc + DDR_DMC_SFCBANK);
+		ddr_write(0x0, base_dmc + DDR_DMC_SFCREQ);
+	}
+
+	/* phy sw write leveling mode */
+	ddr_write(val, base_phy + DDR_PHY_SWTMODE);
+}
+
+#ifdef DDR_WL_DATAEYE_ADJUST_CONFIG
+/* Adjust dataeye WDQ after Write leveling */
+static void ddr_wl_wdq_adjust(struct ddr_cfg_st *cfg,
+	struct ddr_delay_st *wdqs_new, struct ddr_delay_st *wdqs_old)
+{
+	unsigned int val;
+	int i;
+	unsigned int phase_adj, bdl_adj = 0;  /* for write dataeye */
+	unsigned int wdm_bdl;
+	unsigned int wdq_phase;
+	unsigned int base_phy = cfg->cur_phy;
+	unsigned int byte_num = GET_BYTE_NUM(cfg);
+	unsigned int rank_index = cfg->rank_idx;
+
+	DDR_DEBUG("DDR WL write adjust.");
+
+	/* check wl write adjust bypass bit */
+	if (ddr_training_check_bypass(cfg, DDR_BYPASS_WL_ADJ_MASK))
+		return;
+
+	/* adjust wdq phase, wdq bdl, wdm bdl */
+	for (i = 0; i < byte_num; i++) {
+		if (wdqs_new->phase[i] == wdqs_old->phase[i]
+		 && wdqs_new->bdl[i]   == wdqs_old->bdl[i]) {
+			continue;
+		}
+
+		phase_adj = 0;
+		wdq_phase = (ddr_read(base_phy + DDR_PHY_DXNWDQDLY(rank_index, i))
+					>> PHY_WDQ_PHASE_BIT)
+					& PHY_WDQ_PHASE_MASK;
+		wdm_bdl  = (ddr_read(base_phy + DDR_PHY_DXNWDQNBDL2(rank_index, i))
+					>> PHY_WDM_BDL_BIT)
+					& PHY_BDL_MASK;
+
+		if (wdqs_new->bdl[i] > wdqs_old->bdl[i]) {
+			val = wdqs_new->bdl[i] - wdqs_old->bdl[i];
+			phase_adj = val >> DDR_BDL_PHASE_REL;
+			wdq_phase  = wdq_phase + phase_adj;
+
+			if (wdq_phase > PHY_WDQ_PHASE_MASK)
+				wdq_phase = PHY_WDQ_PHASE_MASK;
+
+			/* adjust wdq bdl and dm bdl in opposite direction */
+			bdl_adj  = phase_adj << DDR_BDL_PHASE_REL;
+			ddr_dq_bdl_operate(base_phy, DDR_PHY_DXNWDQNBDL0(rank_index, i),
+				bdl_adj, DDR_FALSE);
+			ddr_dq_bdl_operate(base_phy, DDR_PHY_DXNWDQNBDL1(rank_index, i),
+				bdl_adj, DDR_FALSE);
+			ddr_bdl_sub(&wdm_bdl, bdl_adj);
+
+		} else if (wdqs_new->bdl[i] < wdqs_old->bdl[i]) {
+			val = wdqs_old->bdl[i] - wdqs_new->bdl[i];
+			phase_adj = val >> DDR_BDL_PHASE_REL;
+			wdq_phase = (wdq_phase > phase_adj)
+				? (wdq_phase - phase_adj) : 0;
+
+			/* adjust wdq bdl and dm bdl in opposite direction */
+			bdl_adj  = phase_adj << DDR_BDL_PHASE_REL;
+			ddr_dq_bdl_operate(base_phy, DDR_PHY_DXNWDQNBDL0(rank_index, i),
+				bdl_adj, DDR_TRUE);
+			ddr_dq_bdl_operate(base_phy, DDR_PHY_DXNWDQNBDL1(rank_index, i),
+				bdl_adj, DDR_TRUE);
+			ddr_bdl_add(&wdm_bdl, bdl_adj);
+		}
+
+		DDR_INFO("Byte[%x] WDQ adjust phase[%x] bdl[%x]",
+			i, phase_adj, bdl_adj);
+
+		ddr_write(wdq_phase << PHY_WDQ_PHASE_BIT,
+					base_phy + DDR_PHY_DXNWDQDLY(rank_index, i));
+		ddr_write(wdm_bdl << PHY_WDM_BDL_BIT, base_phy + DDR_PHY_DXNWDQNBDL2(rank_index, i));
+	}
+
+	ddr_phy_cfg_update(base_phy);
+}
+#endif /* DDR_WL_DATAEYE_ADJUST_CONFIG */
+
+/* Sync WDQ phase, WDQ bdl, WDM bdl, OEN bdl, WDQ SOE bdl by WDQS value */
+static void ddr_wl_bdl_sync(struct ddr_cfg_st *cfg,
+	struct ddr_delay_st *wdqs_new, struct ddr_delay_st *wdqs_old)
+{
+	unsigned int tmp;
+	unsigned int val;
+	int i;
+
+	unsigned int oen_bdl, wdqsoe_bdl, wdm_bdl;
+	unsigned int wdq_phase;
+	unsigned int base_phy = cfg->cur_phy;
+	unsigned int byte_num = GET_BYTE_NUM(cfg);
+	unsigned int rank_index = cfg->rank_idx;
+
+	/* sync wdq phase, wdq bdl, wdm bdl, oen bdl, wdq soe bdl */
+	for (i = 0; i < byte_num; i++) {
+		if (wdqs_new->phase[i] == wdqs_old->phase[i]
+		 && wdqs_new->bdl[i]   == wdqs_old->bdl[i]) {
+			continue;
+		}
+
+		DDR_DEBUG("Byte[%x] new[%x][%x] old[%x][%x]", i,
+			wdqs_new->phase[i],	wdqs_new->bdl[i],
+			wdqs_old->phase[i], wdqs_old->bdl[i]);
+
+		/* wdq phase */
+		wdq_phase = (ddr_read(base_phy + DDR_PHY_DXNWDQDLY(rank_index, i))
+					>> PHY_WDQ_PHASE_BIT)
+					& PHY_WDQ_PHASE_MASK;
+		/* always new_phase >= old_phase */
+		wdq_phase = wdq_phase
+			+ (wdqs_new->phase[i] - wdqs_old->phase[i]);
+
+		/* bdl */
+		tmp = ddr_read(base_phy + DDR_PHY_DXNOEBDL(rank_index, i));
+		oen_bdl	 = (tmp >> PHY_OEN_BDL_BIT) & PHY_BDL_MASK;
+		wdqsoe_bdl = (tmp >> PHY_WDQSOE_BDL_BIT) & PHY_BDL_MASK;
+		wdm_bdl	 = (ddr_read(base_phy + DDR_PHY_DXNWDQNBDL2(rank_index, i))
+			>> PHY_WDM_BDL_BIT) & PHY_BDL_MASK;
+
+		if (wdqs_new->bdl[i] > wdqs_old->bdl[i]) {
+			val = wdqs_new->bdl[i] - wdqs_old->bdl[i];
+			ddr_dq_bdl_operate(base_phy,
+				DDR_PHY_DXNWDQNBDL0(rank_index, i), val, DDR_TRUE);
+			ddr_dq_bdl_operate(base_phy,
+				DDR_PHY_DXNWDQNBDL1(rank_index, i), val, DDR_TRUE);
+			ddr_bdl_add(&oen_bdl, val);
+			ddr_bdl_add(&wdqsoe_bdl, val);
+			ddr_bdl_add(&wdm_bdl, val);
+		} else if (wdqs_new->bdl[i] < wdqs_old->bdl[i]) {
+			val = wdqs_old->bdl[i] - wdqs_new->bdl[i];
+			ddr_dq_bdl_operate(base_phy, DDR_PHY_DXNWDQNBDL0(rank_index, i),
+						val, DDR_FALSE);
+			ddr_dq_bdl_operate(base_phy, DDR_PHY_DXNWDQNBDL1(rank_index, i),
+						val, DDR_FALSE);
+			ddr_bdl_sub(&oen_bdl, val);
+			ddr_bdl_sub(&wdqsoe_bdl, val);
+			ddr_bdl_sub(&wdm_bdl, val);
+		}
+
+		if (wdq_phase > PHY_WDQ_PHASE_MASK)
+			wdq_phase = PHY_WDQ_PHASE_MASK;
+
+		ddr_write(wdq_phase << PHY_WDQ_PHASE_BIT,
+			base_phy + DDR_PHY_DXNWDQDLY(rank_index, i));
+		ddr_write((wdqsoe_bdl << PHY_WDQSOE_BDL_BIT) + (oen_bdl << PHY_OEN_BDL_BIT),
+			base_phy + DDR_PHY_DXNOEBDL(rank_index, i));
+		ddr_write((wdm_bdl << PHY_WDM_BDL_BIT), base_phy + DDR_PHY_DXNWDQNBDL2(rank_index, i));
+	}
+
+	ddr_phy_cfg_update(base_phy);
+}
+
+/**
+ * Write leveling process.
+ * WL depend default WDQS phase value in register init table.
+ */
+static int ddr_wl_process(struct ddr_cfg_st *cfg,
+		unsigned int type, struct ddr_delay_st *wdqs)
+{
+	int i, j;
+	unsigned int wl_result = 0;
+	unsigned int length;
+	unsigned int base_phy = cfg->cur_phy;
+	unsigned int byte_num = GET_BYTE_NUM(cfg);
+
+	if (DDR_DELAY_PHASE == type)
+		length = PHY_WDQS_PHASE_MASK;
+	else
+		length = PHY_BDL_MASK;
+
+	/* find WDQS phase or bdl, assume CLK Delay > DQS Delay */
+	for (i = 0; i <= length; i++) {
+		ddr_phy_cfg_update(base_phy);
+		ddr_write(0x1, base_phy + DDR_PHY_SWTWLDQS);
+		DDR_ASM_DSB();
+		wl_result = ddr_read(base_phy + DDR_PHY_SWTRLT)
+				& PHY_SWTRLT_WL_MASK;
+		ddr_write(0x0, base_phy + DDR_PHY_SWTWLDQS);
+
+		if ((wl_result & ((1 << byte_num) - 1)) == ((1 << byte_num) - 1))
+			break;
+
+		for (j = 0; j < byte_num; j++) {
+			DDR_INFO("type[0x%x] byte[0x%x] phase[0x%x] bdl[0x%x] wl_result[0x%x]",
+				type, j, wdqs->phase[j], wdqs->bdl[j], wl_result);
+			if (!(wl_result & (1 << j))) {
+				if (DDR_DELAY_PHASE == type)
+					ddr_phase_inc(&wdqs->phase[j]);
+				else
+					wdqs->bdl[j] += DDR_WL_BDL_STEP;
+
+			ddr_write((wdqs->phase[j] << PHY_WDQS_PHASE_BIT)
+					+ (wdqs->bdl[j] << PHY_WDQS_BDL_BIT),
+					base_phy + DDR_PHY_DXWDQSDLY(cfg->rank_idx, j));
+			}
+		}
+	}
+
+	if (i > length) {   /* wl error, not find wdqs delay */
+		if (DDR_DELAY_BDL == type) {
+			DDR_FATAL("PHY[%x] WL fail, result[%x]",
+					base_phy, wl_result);
+			for (j = 0; j < byte_num; j++)
+				if (!(wl_result & (1 << j)))
+					ddr_training_stat(DDR_ERR_WL,
+						base_phy, j, -1);
+
+		} else
+			DDR_DEBUG("PHY[%x] WL not found phase, result[%x]",
+					base_phy, wl_result);
+
+		return -1;
+	} else
+		return 0;
+}
+
+/**
+ * Find WDQS delay, sync to WDQ delay and OE delay.
+ * WL depend default WDQS phase value in register init table.
+ */
+int ddr_write_leveling(struct ddr_cfg_st *cfg)
+{
+	unsigned int i, tmp;
+	struct ddr_delay_st wdqs_old;
+	struct ddr_delay_st wdqs_new;
+	int result = 0;
+
+	unsigned int base_phy = cfg->cur_phy;
+	unsigned int base_dmc = cfg->cur_dmc;
+	unsigned int byte_num = GET_BYTE_NUM(cfg);
+	unsigned int rank_index = cfg->rank_idx;
+
+	DDR_DEBUG("DDR Write Leveling training.");
+
+	/* init wdqs */
+	for (i = 0; i < byte_num; i++) {
+		tmp = ddr_read(base_phy + DDR_PHY_DXWDQSDLY(rank_index, i));
+
+		wdqs_old.phase[i] = (tmp >> PHY_WDQS_PHASE_BIT)
+					& PHY_WDQS_PHASE_MASK;
+		wdqs_old.bdl[i] = (tmp >> PHY_WDQS_BDL_BIT) & PHY_BDL_MASK;
+
+		wdqs_new.phase[i] = wdqs_old.phase[i];
+		wdqs_new.bdl[i] = 0;
+
+		/* clear wdqs bdl */
+		ddr_write(wdqs_new.phase[i] << PHY_WDQS_PHASE_BIT,
+				base_phy + DDR_PHY_DXWDQSDLY(rank_index, i));
+	}
+
+	/* enable sw write leveling mode */
+	ddr_wl_switch(base_dmc, base_phy, DDR_TRUE);
+
+	/* find first WDQS phase, assume CLK delay > DQS delay. */
+	result = ddr_wl_process(cfg, DDR_DELAY_PHASE, &wdqs_new);
+
+	/* check phase result */
+	for (i = 0; i < byte_num; i++) {
+		/* find phase error, keep max value to find bdl. */
+		/* find phase ok, decrease to find bdl. */
+		if (!result)
+			ddr_phase_dec(&wdqs_new.phase[i]);
+
+		ddr_write(wdqs_new.phase[i] << PHY_WDQS_PHASE_BIT,
+			base_phy + DDR_PHY_DXWDQSDLY(rank_index, i));
+	}
+
+	/* find WDQS bdl */
+	result = ddr_wl_process(cfg, DDR_DELAY_BDL, &wdqs_new);
+
+	/* disable sw write leveling mode */
+	ddr_wl_switch(base_dmc, base_phy, DDR_FALSE);
+
+	if (result) {
+		/* restore default value when find WDQS fail */
+		for (i = 0; i < byte_num; i++) {
+			tmp = (wdqs_old.phase[i] << PHY_WDQS_PHASE_BIT)
+				+ (wdqs_old.bdl[i] << PHY_WDQS_BDL_BIT);
+			ddr_write(tmp, base_phy + DDR_PHY_DXWDQSDLY(rank_index, i));
+		}
+		ddr_phy_cfg_update(base_phy);
+		return -1;
+	}
+
+	/* sync delay */
+	ddr_wl_bdl_sync(cfg, &wdqs_new, &wdqs_old);
+
+#ifdef DDR_WL_DATAEYE_ADJUST_CONFIG
+	/* adjust WDQ for dataeye */
+	ddr_wl_wdq_adjust(cfg, &wdqs_new, &wdqs_old);
+#endif
+	return 0;
+}
+
+int ddr_wl_func(struct ddr_cfg_st *cfg)
+{
+	struct tr_relate_reg relate_reg;
+	int result = 0;
+
+	/* write leveling disable */
+	if (ddr_training_check_bypass(cfg, DDR_BYPASS_WL_MASK))
+		return 0;
+
+	ddr_training_save_reg(cfg, &relate_reg, DDR_BYPASS_WL_MASK);
+
+	result += ddr_write_leveling(cfg);
+
+	ddr_training_restore_reg(cfg, &relate_reg);
+
+	return result;
+}
+#else
+int ddr_wl_func(struct ddr_cfg_st *cfg)
+{
+	DDR_WARNING("Not support DDR WL training.");
+	return 0;
+}
+ #endif /* DDR_WL_TRAINING_CONFIG */
+
+#define __gate_training__
+#ifdef DDR_GATE_TRAINING_CONFIG
+/* Find gate phase */
+static int ddr_gate_find_phase(struct ddr_cfg_st *cfg,
+						struct ddr_delay_st *rdqsg)
+{
+	int i;
+	unsigned int base_phy = cfg->cur_phy;
+
+	for (i = 0; i < GET_BYTE_NUM(cfg); i++) {
+		for (rdqsg->phase[i] = PHY_RDQSG_PHASE_MAX;
+			rdqsg->phase[i] > PHY_GATE_PHASE_MARGIN;
+			rdqsg->phase[i] -= PHY_RDQSG_PHASE_STEP) {
+			ddr_write(rdqsg->phase[i] << PHY_RDQSG_PHASE_BIT,
+				base_phy + DDR_PHY_DXNRDQSGDLY(cfg->rank_idx, i));
+			ddr_phy_cfg_update(base_phy);
+			if (0 == ddr_ddrt_test(DDRT_WR_COMPRARE_MODE, i, -1))
+				break;
+		}
+		if (rdqsg->phase[i] <= PHY_GATE_PHASE_MARGIN) {
+			/* find gate phase fail */
+			DDR_FATAL("find gate phase[%x] fail.",
+				rdqsg->phase[i]);
+			ddr_training_stat(DDR_ERR_GATING, base_phy, -1, -1);
+			return -1;
+		} else {
+			/* decrease one setp to find bdl */
+			rdqsg->phase[i] -= PHY_RDQSG_PHASE_STEP;
+			ddr_write(rdqsg->phase[i] << PHY_RDQSG_PHASE_BIT,
+				base_phy + DDR_PHY_DXNRDQSGDLY(cfg->rank_idx, i));
+		}
+	}
+
+	ddr_phy_cfg_update(base_phy);
+	return 0;
+}
+
+static int ddr_gate_find_bdl(struct ddr_cfg_st *cfg,
+	struct ddr_delay_st *rdqsg)
+{
+	int i, j;
+	unsigned int gate_result;
+	unsigned int tmp;
+	unsigned int base_phy = cfg->cur_phy;
+	unsigned int byte_num = GET_BYTE_NUM(cfg);
+
+	unsigned int swtmode = ddr_read(base_phy + DDR_PHY_SWTMODE);
+
+	for (i = 0; i < byte_num; i++)
+		rdqsg->bdl[i] = 0;
+
+	/* enable phy sw gate training mode */
+	ddr_write(swtmode | (1 << PHY_SWTMODE_SW_GTMODE_BIT),
+		base_phy + DDR_PHY_SWTMODE);
+
+	for (i = 0; i < PHY_GATE_BDL_MAX; i++) {
+		ddr_phy_cfg_update(base_phy);
+		ddr_ddrt_test(DDRT_READ_ONLY_MODE, -1, -1);
+		gate_result = (ddr_read(base_phy + DDR_PHY_SWTRLT) >> 8)
+					& PHY_SWTRLT_GATE_MASK;
+		if (gate_result == ((1 << byte_num) - 1))
+			break;
+
+		for (j = 0; j < byte_num; j++) {
+			if (!(gate_result & (1 << j))) {
+				rdqsg->bdl[j] += DDR_GATE_BDL_STEP;
+				if (rdqsg->bdl[j] > PHY_BDL_MASK) {
+					tmp = ((rdqsg->bdl[j]
+						- PHY_BDL_MASK - 1)
+						<< PHY_RDQSG_TX_BDL_BIT)
+						+ (rdqsg->phase[j]
+						<< PHY_RDQSG_PHASE_BIT)
+						+ (PHY_BDL_MASK - 1);
+				} else {
+					tmp = (rdqsg->phase[j]
+						<< PHY_RDQSG_PHASE_BIT)
+						+ rdqsg->bdl[j];
+				}
+				ddr_write(tmp,
+					base_phy + DDR_PHY_DXNRDQSGDLY(cfg->rank_idx, j));
+			}
+		}
+	}
+
+	/* disable phy sw gate training mode */
+	ddr_write(swtmode & (~(1 << PHY_SWTMODE_SW_GTMODE_BIT)),
+		base_phy + DDR_PHY_SWTMODE);
+
+	if (i == PHY_GATE_BDL_MAX) {  /* find gate bdl fail */
+		DDR_FATAL("PHY[%x] find gate bdl fail. result[%x]",
+				base_phy, gate_result);
+		for (j = 0; j < byte_num; j++)
+			if (!(gate_result & (1 << j)))
+				ddr_training_stat(DDR_ERR_GATING,
+					base_phy, j, -1);
+		return -1;
+	} else
+		return 0;
+}
+
+int ddr_gate_training(struct ddr_cfg_st *cfg)
+{
+	unsigned int i, tmp;
+	unsigned int byte_num;
+	struct ddr_delay_st rdqsg;
+	unsigned int def_delay[DDR_PHY_BYTE_MAX];
+	int result;
+	unsigned int base_phy = cfg->cur_phy;
+
+	DDR_DEBUG("DDR Gate training.");
+
+	byte_num = GET_BYTE_NUM(cfg);
+
+	for (i = 0; i < byte_num; i++)
+		def_delay[i] = ddr_read(base_phy + DDR_PHY_DXNRDQSGDLY(cfg->rank_idx, i));
+
+	/* find phase first */
+	result = ddr_gate_find_phase(cfg, &rdqsg);
+
+	/* find bdl */
+	if (!result)
+		result = ddr_gate_find_bdl(cfg, &rdqsg);
+
+	/* set new phase */
+	if (!result) {
+		for (i = 0; i < byte_num; i++) {
+			rdqsg.phase[i] -= PHY_GATE_PHASE_MARGIN;
+			tmp = ddr_read(base_phy + DDR_PHY_DXNRDQSGDLY(cfg->rank_idx, i));
+			tmp &= ~(PHY_RDQSG_PHASE_MASK << PHY_RDQSG_PHASE_BIT);
+			tmp |= rdqsg.phase[i] << PHY_RDQSG_PHASE_BIT;
+			ddr_write(tmp, base_phy + DDR_PHY_DXNRDQSGDLY(cfg->rank_idx, i));
+		}
+	} else {
+		/* restore default value */
+		for (i = 0; i < byte_num; i++)
+			ddr_write(def_delay[i],
+			base_phy + DDR_PHY_DXNRDQSGDLY(cfg->rank_idx, i));
+	}
+
+	ddr_phy_cfg_update(base_phy);
+	return 0; /* use default value and not reset */
+}
+
+int ddr_gating_func(struct ddr_cfg_st *cfg)
+{
+	struct tr_relate_reg relate_reg;
+	int result = 0;
+
+	/* gate training disable */
+	if (ddr_training_check_bypass(cfg, DDR_BYPASS_GATE_MASK)) {
+		/* check hardware gating */
+		if (ddr_read(cfg->cur_phy + DDR_PHY_PHYINITSTATUS)
+			& PHY_INITSTATUS_GT_MASK) {
+			DDR_FATAL("PHY[%x] hw gating fail.", cfg->cur_phy);
+			ddr_training_stat(DDR_ERR_HW_GATING,
+				cfg->cur_phy, -1, -1);
+			return -1;
+		}
+		return 0;
+	}
+
+	ddr_training_save_reg(cfg, &relate_reg, DDR_BYPASS_GATE_MASK);
+
+	ddr_training_switch_axi(cfg);
+	ddr_ddrt_init(cfg, DDR_DDRT_MODE_GATE);
+	result += ddr_gate_training(cfg);
+
+	ddr_training_restore_reg(cfg, &relate_reg);
+
+	return result;
+}
+#else
+int ddr_gating_func(struct ddr_cfg_st *cfg)
+{
+	DDR_WARNING("Not support DDR gate training.");
+	return 0;
+}
+#endif /* DDR_GATE_TRAINING_CONFIG */
+
+#define __ac_training__
+#ifdef DDR_AC_TRAINING_CONFIG
+/**
+ * Get clk value.
+ * Assume clk0 and clk1 is the same.
+ */
+static int ddr_ac_get_clk(unsigned int base_phy)
+{
+	unsigned int val;
+	unsigned int ac_phy_ctl;
+	/* Static register have to read two times to get the right value. */
+	ac_phy_ctl = ddr_read(base_phy + DDR_PHY_ACPHYCTL7);
+	ac_phy_ctl = ddr_read(base_phy + DDR_PHY_ACPHYCTL7);
+	/* halft_dramclk0 */
+	val = (ac_phy_ctl >> PHY_ACPHY_DRAMCLK0_BIT)
+		& PHY_ACPHY_DRAMCLK_MASK;
+	val = (val << PHY_ACPHY_DRAMCLK_EXT_BIT)
+		| ((ac_phy_ctl >> PHY_ACPHY_DCLK0_BIT)
+			& PHY_ACPHY_DCLK_MASK);
+	return val;
+}
+
+/* Set clk0 and clk1 the same value */
+static void ddr_ac_set_clk(unsigned int base_phy, unsigned int val)
+{
+	unsigned int ac_phy_ctl, dramclk, dclk;
+	dclk       = val & PHY_ACPHY_DCLK_MASK;
+	dramclk    = (val >> PHY_ACPHY_DRAMCLK_EXT_BIT)
+		& PHY_ACPHY_DRAMCLK_MASK;
+	/* Static register have to read two times to get the right value. */
+	ac_phy_ctl = ddr_read(base_phy + DDR_PHY_ACPHYCTL7);
+	ac_phy_ctl = ddr_read(base_phy + DDR_PHY_ACPHYCTL7);
+	/* clear cp1p_dclk0 */
+	ac_phy_ctl &= (~(PHY_ACPHY_DCLK_MASK << PHY_ACPHY_DCLK0_BIT));
+	/* clear ck2p_dclk1 */
+	ac_phy_ctl &= (~(PHY_ACPHY_DCLK_MASK << PHY_ACPHY_DCLK1_BIT));
+	/* clear halft_dramclk0 */
+	ac_phy_ctl &= (~(PHY_ACPHY_DRAMCLK_MASK << PHY_ACPHY_DRAMCLK0_BIT));
+	/* clear halft_dramclk1 */
+	ac_phy_ctl &= (~(PHY_ACPHY_DRAMCLK_MASK << PHY_ACPHY_DRAMCLK1_BIT));
+
+	ac_phy_ctl |= (dclk << PHY_ACPHY_DCLK0_BIT);  /* set cp1p_dclk0 */
+	ac_phy_ctl |= (dclk << PHY_ACPHY_DCLK1_BIT);  /* set cp2p_dclk1 */
+	/* set halft_dramclk0 */
+	ac_phy_ctl |= (dramclk << PHY_ACPHY_DRAMCLK0_BIT);
+	/* set halft_dramclk1 */
+	ac_phy_ctl |= (dramclk << PHY_ACPHY_DRAMCLK1_BIT);
+	ddr_write(ac_phy_ctl, base_phy + DDR_PHY_ACPHYCTL7);
+}
+
+/**
+ * Get cs bdl value.
+ * Assume cs0 and cs 1 is the same.
+ */
+static int ddr_ac_get_cs(unsigned int base_phy)
+{
+	return (ddr_read(base_phy + DDR_PHY_ACCMDBDL2) >> 1) & PHY_BDL_MASK;
+}
+
+/* Set CS value */
+static void ddr_ac_set_cs(unsigned int base_phy, unsigned int val)
+{
+	unsigned int ac_cmd_bdl;
+	ac_cmd_bdl = ddr_read(base_phy + DDR_PHY_ACCMDBDL2);
+	ac_cmd_bdl &= (~(PHY_BDL_MASK << PHY_ACCMD_CS0_BIT)); /* clear cs0_bdl */
+	ac_cmd_bdl &= (~(PHY_BDL_MASK << PHY_ACCMD_CS1_BIT)); /* clear cs1_bdl */
+	ac_cmd_bdl |= (val << PHY_ACCMD_CS0_BIT); /* set cs0_bdl */
+	ac_cmd_bdl |= (val << PHY_ACCMD_CS1_BIT); /* set cs1_bdl */
+	ddr_write(ac_cmd_bdl, base_phy + DDR_PHY_ACCMDBDL2);
+}
+
+static int ddr_ac_ddrt_test(unsigned int mask, unsigned int base_phy)
+{
+	unsigned int regval;
+	unsigned int times = 0;
+
+	DDRT_REG_WRITE(mask | DDRT_CFG_START, DDR_REG_BASE_DDRT + DDRT_OP);
+	DDRT_REG_WRITE(0, DDR_REG_BASE_DDRT + DDRT_STATUS);
+
+	do {
+		regval = DDRT_REG_READ(DDR_REG_BASE_DDRT + DDRT_STATUS);
+		times++;
+	} while ((!(regval & DDRT_TEST_DONE_MASK))
+			&& (times < DDRT_WAIT_TIMEOUT));
+
+	if (times >= DDRT_WAIT_TIMEOUT) {
+		DDR_FATAL("DDRT wait timeout.");
+		ddr_training_stat(DDR_ERR_DDRT_TIME_OUT, base_phy, -1, -1);
+		return -1;
+	}
+
+	/* DDRT_WRITE_ONLY_MODE */
+	if (DDRT_WRITE_ONLY_MODE == (mask & DDRT_TEST_MODE_MASK))
+		return 0;
+
+	/* DDRT_READ_ONLY_MODE */
+	if (regval & DDRT_TEST_PASS_MASK) /* No error occurred, test pass. */
+		return 0;
+	else
+		return -1;
+
+}
+
+/* Check CS value */
+static int ddr_ac_check_cs(unsigned int base_phy, unsigned int def_cs,
+	unsigned int step)
+{
+	ddr_ac_set_cs(base_phy, def_cs + step);
+	ddr_phy_cfg_update(base_phy);
+
+	ddr_ac_ddrt_test(DDRT_WRITE_ONLY_MODE, base_phy);
+
+	ddr_ac_set_cs(base_phy, def_cs); /* restore default to check */
+	ddr_phy_cfg_update(base_phy);
+
+	return ddr_ac_ddrt_test(DDRT_READ_ONLY_MODE, base_phy);
+}
+
+/* Check CLK value */
+static int ddr_ac_check_clk(struct ddr_cfg_st *cfg, unsigned int def_clk,
+	struct ddr_delay_st *def_phase,
+	unsigned int step)
+{
+	int i;
+	unsigned int wdqs_phase_range, wdq_phase_range, phase_range;
+	unsigned int base_phy = cfg->cur_phy;
+	unsigned int byte_num = GET_BYTE_NUM(cfg);
+
+	/* set new value */
+	ddr_ac_set_clk(base_phy, def_clk + step);
+	for (i = 0; i < byte_num; i++) {
+		wdqs_phase_range = PHY_WDQS_PHASE_MASK
+			- ((def_phase->phase[i] >> PHY_WDQS_PHASE_BIT)
+				& PHY_WDQS_PHASE_MASK);
+		wdq_phase_range  = PHY_WDQ_PHASE_MASK
+			- ((def_phase->bdl[i] >> PHY_WDQ_PHASE_BIT)
+				& PHY_WDQ_PHASE_MASK);
+		phase_range = (wdqs_phase_range < wdq_phase_range)
+			? wdqs_phase_range : wdq_phase_range;
+		phase_range = (phase_range < step) ? phase_range : step;
+
+		ddr_write(def_phase->phase[i]
+				+ (phase_range << PHY_WDQS_PHASE_BIT),
+				base_phy + DDR_PHY_DXWDQSDLY(cfg->rank_idx, i));
+		ddr_write(def_phase->bdl[i]
+				+ (phase_range << PHY_WDQ_PHASE_BIT),
+				base_phy + DDR_PHY_DXNWDQDLY(cfg->rank_idx, i));
+	}
+	ddr_phy_cfg_update(base_phy);
+
+	ddr_ac_ddrt_test(DDRT_WRITE_ONLY_MODE, base_phy);
+
+	/* restore default to check */
+	ddr_ac_set_clk(base_phy, def_clk);
+	for (i = 0; i < byte_num; i++) {
+		ddr_write(def_phase->phase[i],
+			base_phy + DDR_PHY_DXWDQSDLY(cfg->rank_idx, i));
+		ddr_write(def_phase->bdl[i],
+			base_phy + DDR_PHY_DXNWDQDLY(cfg->rank_idx, i));
+	}
+	ddr_phy_cfg_update(base_phy);
+
+	return ddr_ac_ddrt_test(DDRT_READ_ONLY_MODE, base_phy);
+}
+
+/* Find CS difference */
+static int ddr_ac_find_cs(unsigned int base_phy)
+{
+	unsigned int def_cs, step;
+
+	def_cs = ddr_ac_get_cs(base_phy);
+	for (step = 1; step <= (PHY_BDL_MASK - def_cs); step++) {
+		if (ddr_ac_check_cs(base_phy, def_cs, step)) {
+			DDR_DEBUG("PHY[%x] default cs[%x], find diff_cs[%x]",
+					base_phy, def_cs, step);
+			break;
+		}
+	}
+
+	return step;
+}
+
+/* Find CLK difference */
+static int ddr_ac_find_clk(struct ddr_cfg_st *cfg)
+{
+	int i;
+	unsigned int def_clk, step;
+	struct ddr_delay_st def_phase;
+	unsigned int base_phy = cfg->cur_phy;
+	unsigned int byte_num = GET_BYTE_NUM(cfg);
+
+	def_clk = ddr_ac_get_clk(base_phy);
+	for (i = 0; i < byte_num; i++) {
+		/* WDQS phase */
+		def_phase.phase[i] = ddr_read(base_phy + DDR_PHY_DXWDQSDLY(cfg->rank_idx, i));
+		/* WDQ phase */
+		def_phase.bdl[i]   = ddr_read(base_phy + DDR_PHY_DXNWDQDLY(cfg->rank_idx, i));
+	}
+
+	for (step = 1; step <= (PHY_ACPHY_CLK_MAX - def_clk); step++) {
+		if (ddr_ac_check_clk(cfg, def_clk, &def_phase, step)) {
+			DDR_DEBUG("PHY[%x] default clk[%x], find diff_clk[%x]",
+				base_phy, def_clk, step);
+			break;
+		}
+	}
+
+	return step;
+}
+
+/* DDR AC training */
+int ddr_ac_training(struct ddr_cfg_st *cfg)
+{
+	unsigned int diff_cs, diff_clk;
+	unsigned int clk_phase, cs_bdl, phase_tmp;
+	unsigned int byte_num;
+	unsigned int wdqs_phase, wdq_phase;
+	unsigned int wdqs_phase_range, wdq_phase_range, phase_range;
+	unsigned int def_clk, def_cs;
+	int i;
+	unsigned int base_phy = cfg->cur_phy;
+
+	DDR_DEBUG("DDR AC training.");
+
+	byte_num = GET_BYTE_NUM(cfg);
+
+	diff_cs  = ddr_ac_find_cs(base_phy);            /* setup time(bdl) */
+	diff_clk = ddr_ac_find_clk(cfg);                /* hold time(phase) */
+	/* cs bdl transform to clk phase */
+	phase_tmp = diff_cs >> DDR_BDL_PHASE_REL;
+
+	if (diff_clk > phase_tmp) {
+		clk_phase = (diff_clk - phase_tmp) >> 1;
+		def_clk = ddr_ac_get_clk(base_phy);
+
+		/* set new value */
+		ddr_ac_set_clk(base_phy, def_clk + clk_phase);
+		for (i = 0; i < byte_num; i++) {
+			wdqs_phase = ddr_read(base_phy + DDR_PHY_DXWDQSDLY(cfg->rank_idx, i));
+			wdq_phase  = ddr_read(base_phy + DDR_PHY_DXNWDQDLY(cfg->rank_idx, i));
+
+			wdqs_phase_range = PHY_WDQS_PHASE_MASK
+				- ((wdqs_phase >> PHY_WDQS_PHASE_BIT)
+					& PHY_WDQS_PHASE_MASK);
+			wdq_phase_range  = PHY_WDQ_PHASE_MASK
+				- ((wdq_phase >> PHY_WDQ_PHASE_BIT)
+					& PHY_WDQ_PHASE_MASK);
+			phase_range = (wdqs_phase_range < wdq_phase_range)
+				? wdqs_phase_range : wdq_phase_range;
+			phase_range = (phase_range < clk_phase)
+				? phase_range : clk_phase;
+			ddr_write(wdqs_phase
+					+ (phase_range << PHY_WDQS_PHASE_BIT),
+					base_phy + DDR_PHY_DXWDQSDLY(cfg->rank_idx, i));
+			ddr_write(wdq_phase
+					+ (phase_range << PHY_WDQ_PHASE_BIT),
+					base_phy + DDR_PHY_DXNWDQDLY(cfg->rank_idx, i));
+		}
+		DDR_DEBUG("PHY[%x] def clk[%x] add phase[%x]",
+			base_phy, def_clk, clk_phase);
+	} else {
+		def_cs = ddr_ac_get_cs(base_phy);
+		cs_bdl = 0;
+		if (diff_cs > (diff_clk << DDR_BDL_PHASE_REL))
+			cs_bdl = diff_cs - (diff_clk << DDR_BDL_PHASE_REL);
+
+		ddr_ac_set_cs(base_phy, def_cs + cs_bdl);
+		DDR_DEBUG("PHY[%x] def cs[%x] add bdl[%x]",
+			base_phy, def_cs, cs_bdl);
+	}
+
+	ddr_phy_cfg_update(base_phy);
+	return 0;
+}
+
+int ddr_ac_training_func(struct ddr_cfg_st *cfg)
+{
+	int result = 0;
+	struct tr_relate_reg relate_reg;
+
+	/* AC training disable */
+	if (ddr_training_check_bypass(cfg, DDR_BYPASS_AC_MASK))
+		return 0;
+
+	ddr_training_save_reg(cfg, &relate_reg, DDR_BYPASS_AC_MASK);
+
+	ddr_training_switch_axi(cfg);
+	ddr_ddrt_init(cfg, DDR_DDRT_MODE_DATAEYE);
+	result += ddr_ac_training(cfg);
+
+	ddr_training_restore_reg(cfg, &relate_reg);
+
+	return result;
+}
+#else
+int ddr_ac_training_func(struct ddr_cfg_st *cfg)
+{
+	DDR_WARNING("Not support DDR AC training.");
+	return 0;
+}
+#endif /* DDR_AC_TRAINING_CONFIG */
+
+#define __lpca_training__
+#ifdef DDR_LPCA_TRAINING_CONFIG
+/* Reset address bdl training data */
+static void ddr_lpca_reset(struct ca_data_st *data)
+{
+	unsigned int index;
+	for (index = 0; index < DDR_PHY_CA_MAX; index++) {
+		data->left[index] = -1;
+		data->right[index] = -1;
+	}
+
+	data->min = PHY_ACADDR_BDL_MASK;
+	data->max = 0;
+	data->done = 0;
+}
+
+/* Get ca bit relation */
+static void ddr_lpca_get_bit(struct ca_data_st *data)
+{
+	unsigned int index;
+	//unsigned int swap_sel;
+
+	/* get ca bit in four register  */
+	#if 0
+	for (index = 0; index < (DDR_PHY_CA_REG_MAX - 1); index++) {
+		ddr_write(index + 1, data->base_phy + DDR_PHY_CATSWAPINDEX);
+		swap_sel = ddr_read(data->base_phy + DDR_PHY_CATSWAPSEL);
+
+		data->bits[index * 2].bit_p =
+			swap_sel & PHY_CATSWAPSEL_BIT_MASK;
+		data->bits[index * 2].bit_n =
+			(swap_sel >> 8) & PHY_CATSWAPSEL_BIT_MASK;
+		data->bits[index * 2 + 1].bit_p =
+			(swap_sel >> 16) & PHY_CATSWAPSEL_BIT_MASK;
+		data->bits[index * 2 + 1].bit_n =
+			(swap_sel >> 24) & PHY_CATSWAPSEL_BIT_MASK;
+	}
+	#else
+	for (index = 0; index < (DDR_PHY_CA_REG_MAX - 1); index++) {
+		data->bits[index * 2].bit_p =index*4+ 0;
+		data->bits[index * 2].bit_n =index*4+ 1;
+		data->bits[index * 2 + 1].bit_p =index*4+ 2;
+		data->bits[index * 2 + 1].bit_n =index*4+ 3;
+	}
+	#endif
+
+	/**
+	 * set ca bit for ca4 and ca9
+	 * ca4 = ca0, ca9 = ca5
+	 */
+	for (index = 8; index > 4; index--) {
+		data->bits[index].bit_p = data->bits[index - 1].bit_p;
+		data->bits[index].bit_n = data->bits[index - 1].bit_n;
+	}
+
+	data->bits[4].bit_p = data->bits[0].bit_p;
+	data->bits[4].bit_n = data->bits[0].bit_n;
+	data->bits[9].bit_p = data->bits[5].bit_p;
+	data->bits[9].bit_n = data->bits[5].bit_n;
+
+#if defined(DDR_TRAINING_CMD)
+	for (index = 0; index < DDR_PHY_CA_MAX; index++) {
+		DDR_INFO("CA[%x] bit_p[%x]", index, data->bits[index].bit_p);
+		DDR_INFO("CA[%x] bit_n[%x]", index, data->bits[index].bit_n);
+	}
+#endif
+}
+
+/* Get address bdl default value */
+static void ddr_lpca_get_def(struct ca_data_st *data)
+{
+	unsigned int index;
+
+	for (index = 0; index < DDR_PHY_CA_REG_MAX; index++)
+		data->def[index] = ddr_read(data->base_phy
+			+ DDR_PHY_ACADDRBDL(index));
+}
+
+/* Restore address bdl default value */
+static void ddr_lpca_restore_def(struct ca_data_st *data)
+{
+	unsigned int index;
+
+	for (index = 0; index < DDR_PHY_CA_REG_MAX; index++)
+		ddr_write(data->def[index], data->base_phy
+			+ DDR_PHY_ACADDRBDL(index));
+
+	ddr_phy_cfg_update(data->base_phy);
+}
+
+/* Set address bdl value */
+static void ddr_lpca_set_bdl(unsigned int base_phy, unsigned int bdl)
+{
+	unsigned int index;
+	for (index = 0; index < DDR_PHY_CA_REG_MAX; index++)
+		ddr_write(bdl | (bdl << PHY_ACADDRBDL_ADDR1_BIT),
+			base_phy + DDR_PHY_ACADDRBDL(index));
+
+	ddr_phy_cfg_update(base_phy);
+}
+
+/* Update address bdl value with training result */
+static void ddr_lpca_update_bdl(struct ca_data_st *data)
+{
+	unsigned int index;
+	unsigned int addr0, addr1;
+
+	for (index = 0; index < DDR_PHY_CA_REG_MAX; index++) {
+		addr0 = (data->left[index * 2] + data->right[index * 2]) >> 1;
+		addr1 = (data->left[index * 2 + 1]
+			+ data->right[index * 2 + 1]) >> 1;
+		ddr_write(addr0 | (addr1 << PHY_ACADDRBDL_ADDR1_BIT),
+			data->base_phy + DDR_PHY_ACADDRBDL(index));
+	}
+
+	ddr_phy_cfg_update(data->base_phy);
+}
+
+/* Init data before training */
+static void ddr_lpca_init(unsigned int base_dmc, unsigned int base_phy,
+	struct ca_data_st *data)
+{
+	data->base_dmc = base_dmc;
+	data->base_phy = base_phy;
+
+	/* gat ca bit relation */
+	ddr_lpca_get_bit(data);
+
+	/* get ac addr bdl default value */
+	ddr_lpca_get_def(data);
+
+	/* reset training data */
+	ddr_lpca_reset(data);
+}
+
+/* Display training result */
+static void ddr_lpca_display(struct ca_data_st *data)
+{
+#if defined(DDR_TRAINING_CMD)
+	unsigned int index;
+
+	DDR_DEBUG("CA phase[%x = %x]",
+			data->base_phy + DDR_PHY_ADDRPHBOUND,
+			ddr_read(data->base_phy + DDR_PHY_ADDRPHBOUND));
+
+	for (index = 0; index < DDR_PHY_CA_MAX; index++)
+		DDR_DEBUG("CA[%x] left[%x] right[%x]",
+			index, data->left[index], data->right[index]);
+
+	DDR_DEBUG("min[%x] max[%x] done[%x]",
+		data->min, data->max, data->done);
+#endif
+}
+
+/* Wait lpca command done */
+static void ddr_lpca_wait(volatile union U_PHY_CATCONFIG *ca)
+{
+	unsigned int count = 0;
+	while (count < DDR_LPCA_WAIT_TIMEOUT) {
+		if (1 == ca->bits.sw_cat_dqvalid) {
+			ca->bits.sw_cat_dqvalid = 0; /* clear */
+			break;
+		}
+
+		count++;
+	}
+
+	/* generally, count is 0 */
+	if (count >= DDR_LPCA_WAIT_TIMEOUT)
+		DDR_ERROR("LPCA wait timeout.");
+}
+
+/* Compare dq result and pattern */
+static int ddr_lpca_compare(struct ca_bit_st *ca_bit,
+	unsigned int dq_result, unsigned int pattern_p,
+	unsigned int pattern_n, unsigned int index)
+{
+	if (((dq_result >> ca_bit->bit_p) & 0x1)
+		!= ((pattern_p >> index) & 0x1))
+		return -1;
+
+	if (((dq_result >> ca_bit->bit_n) & 0x1)
+		!= ((pattern_n >> index) & 0x1))
+		return -1;
+
+	return 0;
+}
+
+/* Check each CA whether pass */
+static void ddr_lpca_check(struct ca_data_st *data, unsigned int bdl,
+	unsigned int is_ca49)
+{
+	unsigned int dq_result = ddr_read(data->base_phy + DDR_PHY_PHYDQRESULT);
+	unsigned int pattern_p = ddr_read(data->base_phy
+		+ DDR_PHY_SWCATPATTERN_P) & PHY_CAT_PATTERN_MASK;
+	unsigned int pattern_n = ddr_read(data->base_phy
+		+ DDR_PHY_SWCATPATTERN_N) & PHY_CAT_PATTERN_MASK;
+	unsigned int index;
+
+	for (index = 0; index < DDR_PHY_CA_MAX; index++) {
+		if (is_ca49) {
+			if (4 != index && 9 != index)
+				continue;
+		} else {
+			if (4 == index || 9 == index)
+				continue;
+		}
+
+		/* compare result and pattern */
+		if (!ddr_lpca_compare(&data->bits[index],
+				dq_result, pattern_p, pattern_n, index)) {
+			/* pass */
+			if (-1 == data->left[index]) {
+				data->left[index] = bdl;
+				/* set min left bound */
+				if (bdl < data->min)
+					data->min = bdl;
+			}
+
+			/* unstable border value or abnormal value */
+			if ((-1 != data->right[index])
+				&& ((bdl - data->right[index]) > 1))
+				DDR_WARNING("CA[%x] bdl[%x] right[%x] ph[%x]",
+					index, bdl, data->right[index],
+					ddr_read(data->base_phy
+					+ DDR_PHY_ADDRPHBOUND));
+
+			data->right[index] = bdl;
+			data->done |= (0x1 << index);
+
+			/* set max right bound */
+			if (data->right[index] > data->max)
+				data->max = data->right[index];
+		}
+	}
+}
+
+/* Excute lpca command and check result */
+static void ddr_lpca_excute(struct ca_data_st *data, unsigned int bdl,
+	unsigned int is_ca49)
+{
+	volatile union U_PHY_CATCONFIG *ca = (union U_PHY_CATCONFIG *)
+		(data->base_phy + DDR_PHY_CATCONFIG);
+
+	if (is_ca49)
+		ca->bits.sw_cat_mrw48 = 1;
+	else
+		ca->bits.sw_cat_mrw41 = 1;
+
+	ddr_lpca_wait(ca);
+	ca->bits.sw_cat_cke_low = 1;
+	ddr_lpca_wait(ca);
+	ca->bits.sw_cat_strobe = 1;
+	ddr_lpca_wait(ca);
+
+	/* check PHYDQRESULT */
+	ddr_lpca_check(data, bdl, is_ca49);
+
+	ca->bits.sw_cat_cke_high = 1;
+	ddr_lpca_wait(ca);
+	ca->bits.sw_cat_mrw42 = 1;
+	ddr_lpca_wait(ca);
+}
+
+/* Find address bdl */
+static int ddr_lpca_find_bdl(struct ca_data_st *data)
+{
+	unsigned int bdl;
+
+	for (bdl = 0; bdl <= PHY_ACADDR_BDL_MASK; bdl++) {
+		/* update bdl */
+		ddr_lpca_set_bdl(data->base_phy, bdl);
+
+		/* ca0~ca3, ca5~ca8 */
+		ddr_lpca_excute(data, bdl, DDR_FALSE);
+
+		/* ca4, ca9 */
+		ddr_lpca_excute(data, bdl, DDR_TRUE);
+	}
+
+	if (PHY_CAT_PATTERN_MASK == data->done)
+		return 0;
+
+	return -1;
+}
+
+/* Loop phase to find valid bdl and phase */
+static int ddr_lpca_loop_phase(struct ca_data_st *data, int step)
+{
+	volatile union U_PHY_ADDRPHBOUND *ph = (union U_PHY_ADDRPHBOUND *)
+		(data->base_phy + DDR_PHY_ADDRPHBOUND);
+	unsigned int phase;
+	unsigned int addrph_def = ph->bits.addrph_a;
+	int addrph = addrph_def;
+
+	for (phase = 0; phase <= PHY_ADDRPH_MASK; phase++) {
+		/* reset ca training data */
+		ddr_lpca_reset(data);
+
+		/* find bdl */
+		if (!ddr_lpca_find_bdl(data))
+			return 0;
+
+		addrph += step;
+		if (addrph < 0 || addrph > PHY_ADDRPH_MASK)
+			break;
+
+		ph->bits.addrph_a = addrph;
+		ddr_phy_cfg_update(data->base_phy);
+	}
+
+	/* restore default value */
+	DDR_DEBUG("current phase[%x = %x], restore default[%x]",
+		ph, *ph, addrph_def);
+	ph->bits.addrph_a = addrph_def;
+	return -1;
+}
+
+/* Find a valid phase */
+static int ddr_lpca_find_phase(struct ca_data_st *data)
+{
+	/* increase default value to find */
+	if (!ddr_lpca_loop_phase(data, 1))
+		return 0;
+
+	/* decrease default value to find */
+	if (!ddr_lpca_loop_phase(data, -1))
+		return 0;
+
+	return -1;
+}
+
+/* Set step to adjust address window */
+static int ddr_lpca_set_step(struct ca_data_st *data)
+{
+	/* max window, no need to found */
+	if (0 == data->min && PHY_ACADDR_BDL_MASK == data->max)
+		return 0;
+
+	if (0 == data->min)
+		return -1; /* window on left, move to right */
+	else
+		return 1; /* window on right, move to left */
+}
+
+/**
+ * Adjust address window via change phase.
+ * Increase phase, window will move to left.
+ */
+static void ddr_lpca_adjust(struct ca_data_st *data)
+{
+	int step = 0;
+	volatile union U_PHY_ADDRPHBOUND *ph = (union U_PHY_ADDRPHBOUND *)
+		(data->base_phy + DDR_PHY_ADDRPHBOUND);
+	unsigned int phase;
+	unsigned int addrph_last = ph->bits.addrph_a;
+	int addrph_cur = addrph_last;
+
+	/* set step to increase or decrease phase */
+	step = ddr_lpca_set_step(data);
+
+	if (!step)
+		return;
+
+	for (phase = 0; phase <= PHY_ADDRPH_MASK; phase++) {
+		addrph_cur += step;
+		if (addrph_cur < 0 || addrph_cur > PHY_ADDRPH_MASK)
+			return;
+
+		ph->bits.addrph_a = addrph_cur;
+		ddr_phy_cfg_update(data->base_phy);
+
+		/* reset ca training data */
+		ddr_lpca_reset(data);
+
+		if (ddr_lpca_find_bdl(data)) {
+			/* not find bdl, restore last value */
+			addrph_cur -= step;
+			ddr_lpca_find_bdl(data);
+			return;
+		}
+
+		/* max window: ------- */
+		if (0 == data->min && PHY_ACADDR_BDL_MASK == data->max)
+			return;
+
+		/* last window: -----xx */
+		if (0 == data->min && 1 == step) {
+			/* last value is best */
+			addrph_cur -= step;
+			ph->bits.addrph_a = addrph_cur;
+			ddr_phy_cfg_update(data->base_phy);
+			ddr_lpca_reset(data);
+			ddr_lpca_find_bdl(data);
+			return;
+		}
+
+		/* best window: x-----x */
+		if (0 < data->min && -1 == step)
+			return;
+	}
+}
+
+/* Low power DDR CA training */
+int ddr_lpca_training(struct ddr_cfg_st *cfg)
+{
+	volatile union U_PHY_CATCONFIG *ca = (union U_PHY_CATCONFIG *)
+		(cfg->cur_phy + DDR_PHY_CATCONFIG);
+
+	struct ca_data_st data;
+	int ret = -1;
+
+	DDR_DEBUG("DDR LPCA training.");
+
+	/* init data */
+	ddr_lpca_init(cfg->cur_dmc, cfg->cur_phy, &data);
+
+	/* enable sw ca training, wait 62.5ns */
+	ca->bits.sw_cat_en = 1;
+
+	/* find a valid phase first */
+	ret = ddr_lpca_find_phase(&data);
+
+	/* display training result */
+	ddr_lpca_display(&data);
+
+	if (ret) {
+		/* restore default value when fail */
+		ddr_lpca_restore_def(&data);
+		DDR_ERROR("PHY[%x] found phase fail, result[%x].",
+			cfg->cur_phy, data.done);
+		ddr_training_stat(DDR_ERR_LPCA, cfg->cur_phy, -1, -1);
+	} else {
+		/* adjust window via phase */
+		ddr_lpca_adjust(&data);
+		ddr_lpca_display(&data);
+		/* set training result */
+		ddr_lpca_update_bdl(&data);
+	}
+
+	/* disable sw ca training */
+	ca->bits.sw_cat_en = 0;
+
+	/* save lpca result data to printf */
+	ddr_lpca_data_save(&data);
+
+	return ret;
+}
+
+int ddr_lpca_training_func(struct ddr_cfg_st *cfg)
+{
+	int result = 0;
+	struct tr_relate_reg relate_reg;
+
+	/* LPCA training disable */
+	if (ddr_training_check_bypass(cfg, DDR_BYPASS_LPCA_MASK))
+		return 0;
+
+	ddr_training_save_reg(cfg, &relate_reg, DDR_BYPASS_LPCA_MASK);
+
+	/* only lowpower ddr3 support */
+	if (PHY_DRAMCFG_TYPE_LPDDR3 ==
+		(ddr_read(cfg->cur_phy + DDR_PHY_DRAMCFG)
+		& PHY_DRAMCFG_TYPE_LPDDR3))
+		result += ddr_lpca_training(cfg);
+
+	ddr_training_restore_reg(cfg, &relate_reg);
+
+	return result;
+}
+#else
+int ddr_lpca_training_func(struct ddr_cfg_st *cfg)
+{
+	DDR_WARNING("Not support LPDDR CA training.");
+	return 0;
+}
+#endif /* DDR_LPCA_TRAINING_CONFIG */
+
+/* s40/t28/t16 not support dcc training */
+#define __dcc_training__
+#ifdef DDR_DCC_TRAINING_CONFIG
+/* Save two rank RDET result */
+static void ddr_save_two_rank_bdl(struct ddr_cfg_st *cfg, struct dcc_data_st *dcc_data)
+{
+	unsigned int byte_idx;
+	unsigned int base_phy = cfg->cur_phy;
+	unsigned int rank_idx = cfg->rank_idx;
+	unsigned int byte_num = cfg->phy[cfg->phy_idx].total_byte_num;
+
+	for (byte_idx = 0; byte_idx < byte_num; byte_idx++) {
+		dcc_data->rank[rank_idx].dq03[byte_idx] = ddr_read(base_phy + DDR_PHY_DXNRDQNBDL0(rank_idx, byte_idx));
+		dcc_data->rank[rank_idx].dq47[byte_idx] = ddr_read(base_phy + DDR_PHY_DXNRDQNBDL1(rank_idx, byte_idx));
+		dcc_data->rank[rank_idx].rdm[byte_idx] = ddr_read(base_phy + DDR_PHY_DXNRDQNBDL2(rank_idx, byte_idx));
+		dcc_data->rank[rank_idx].rdqs[byte_idx] = ddr_read(base_phy + DDR_PHY_DXNRDQSDLY(byte_idx));
+
+		DDR_DEBUG("rank[%x] dq03[%x] dq47[%x] rdm[%x] rdqs[%x]", rank_idx,
+			dcc_data->rank[rank_idx].dq03[byte_idx],
+			dcc_data->rank[rank_idx].dq47[byte_idx],
+			dcc_data->rank[rank_idx].rdm[byte_idx],
+			dcc_data->rank[rank_idx].rdqs[byte_idx]);
+	}
+}
+
+/* Restore two rank RDET result */
+static void ddr_restore_two_rank_bdl(struct ddr_cfg_st *cfg, struct dcc_data_st *dcc_data)
+{
+	unsigned int byte_idx;
+	unsigned int base_phy = cfg->cur_phy;
+	unsigned int rank_idx = cfg->rank_idx;
+	unsigned int byte_num = cfg->phy[cfg->phy_idx].total_byte_num;
+
+	for (byte_idx = 0; byte_idx < byte_num; byte_idx++) {
+		ddr_write(dcc_data->rank[rank_idx].dq03[byte_idx], base_phy + DDR_PHY_DXNRDQNBDL0(rank_idx, byte_idx));
+		ddr_write(dcc_data->rank[rank_idx].dq47[byte_idx], base_phy + DDR_PHY_DXNRDQNBDL1(rank_idx, byte_idx));
+		ddr_write(dcc_data->rank[rank_idx].rdm[byte_idx], base_phy + DDR_PHY_DXNRDQNBDL2(rank_idx, byte_idx));
+		ddr_write(dcc_data->rank[rank_idx].rdqs[byte_idx], base_phy + DDR_PHY_DXNRDQSDLY(byte_idx));
+	}
+}
+
+/* DMC_CFG_SREF exit self-refresa enter powerdown */
+static void ddr_exit_sref_enter_pd(struct ddr_cfg_st *cfg, struct dmc_cfg_sref_st *cfg_sref)
+{
+	int i;
+	struct ddr_phy_st *phy_st =  &cfg->phy[cfg->phy_idx];
+
+	for (i = 0; i < phy_st->dmc_num; i++) {
+		cfg_sref->val[i] = ddr_read(phy_st->dmc[i].addr + DDR_DMC_CFG_SREF);
+		ddr_write((cfg_sref->val[i] & (~DMC_CFG_INIT_XSREF_PD_MASK)) | DMC_CFG_INIT_XSREF_PD,
+			phy_st->dmc[i].addr + DDR_DMC_CFG_SREF);
+	}
+}
+
+/* Restore DMC_CFG_SREF config */
+static void ddr_restore_sref_cfg(struct ddr_cfg_st *cfg, struct dmc_cfg_sref_st *cfg_sref)
+{
+	int i;
+	struct ddr_phy_st *phy_st = &cfg->phy[cfg->phy_idx];
+
+	for (i = 0; i < phy_st->dmc_num; i++) {
+		ddr_write(cfg_sref->val[i], phy_st->dmc[i].addr + DDR_DMC_CFG_SREF);
+	}
+}
+
+/* DCC RDET training */
+static int ddr_dcc_dataeye_read(struct ddr_cfg_st *cfg)
+{
+	/* 0:PHY_TRAINCTRL0_DTR_RANK0, 1:PHY_TRAINCTRL0_DTR_RANK1 */
+	DDR_PHY_SWITCH_RANK(cfg->cur_phy, cfg->rank_idx);
+	return ddr_hw_training_process(cfg, PHY_PHYINITCTRL_RDET_EN);
+}
+
+/* Duty direction ctl */
+static int ddr_dcc_ck_ctl(struct ddr_cfg_st *cfg, unsigned int ioctl21_def, unsigned int ctl_index)
+{
+	unsigned int ioctl21;
+	if (PHY_DRAMCFG_TYPE_LPDDR4 == cfg->phy[cfg->phy_idx].dram_type) {
+		ioctl21 = (ioctl21_def & (~(1 << PHY_ACIOCTL21_CTL0_BIT))
+							& (~(1 << PHY_ACIOCTL21_CTL1_BIT)))
+							| (ctl_index << PHY_ACIOCTL21_CTL0_BIT)
+							| (ctl_index << PHY_ACIOCTL21_CTL1_BIT);
+		ddr_write(ioctl21, cfg->cur_phy + DDR_PHY_ACIOCTL21);
+	} else {
+		ioctl21 = (ioctl21_def & (~(1 << PHY_ACIOCTL21_CTL0_BIT)))
+							| (ctl_index << PHY_ACIOCTL21_CTL0_BIT);
+		ddr_write(ioctl21, cfg->cur_phy + DDR_PHY_ACIOCTL21);
+	}
+	return ioctl21;
+}
+
+/* Duty Correction */
+static int ddr_dcc_correct_duty(struct ddr_cfg_st *cfg, unsigned int cur_duty, unsigned int duty_def)
+{
+	unsigned int ioctl21;
+	if (PHY_DRAMCFG_TYPE_LPDDR4 == cfg->phy[cfg->phy_idx].dram_type) {
+		/* Correct CK0 & CK1 duty */
+		ioctl21 = (duty_def & (~(PHY_ACIOCTL21_MASK << PHY_ACIOCTL21_CK0_BIT))
+							& (~(PHY_ACIOCTL21_MASK << PHY_ACIOCTL21_CK1_BIT)))
+							| (cur_duty << PHY_ACIOCTL21_CK0_BIT)
+							| (cur_duty << PHY_ACIOCTL21_CK1_BIT);
+		ddr_write(ioctl21, cfg->cur_phy + DDR_PHY_ACIOCTL21);
+	} else {
+		/* Correct CK0 duty */
+		ioctl21 = (duty_def & (~(PHY_ACIOCTL21_MASK << PHY_ACIOCTL21_CK0_BIT)))
+							| (cur_duty << PHY_ACIOCTL21_CK0_BIT);
+		ddr_write(ioctl21, cfg->cur_phy + DDR_PHY_ACIOCTL21);
+	}
+
+	return ioctl21;
+}
+
+/* Duty Correction Control get win data */
+static int ddr_dcc_get_win(struct dcc_data_st *dcc_data, int ck_index, int val_index)
+{
+	unsigned int win;
+	unsigned int rdqsbdl_right;
+	unsigned int rdqsbdl_left;
+	rdqsbdl_right = dcc_data->ck[ck_index].val[val_index] >> PHY_DXNRDBOUND_RIGHT_BIT & PHY_DXNRDBOUND_MASK;
+	rdqsbdl_left = dcc_data->ck[ck_index].val[val_index] >> PHY_DXNRDBOUND_LEFT_BIT & PHY_DXNRDBOUND_MASK;
+	win = rdqsbdl_right - rdqsbdl_left;
+	return win;
+}
+
+/* Duty Correction Control get the min win of two byte */
+static int ddr_dcc_get_min_win(struct dcc_data_st *dcc_data, int ck_index)
+{
+	int i;
+	unsigned int win_min;
+	unsigned int cur_win;
+	win_min = ddr_dcc_get_win(dcc_data, ck_index, 0);
+	for (i = 0; i < DDR_CK_RESULT_MAX; i++) {
+		cur_win = ddr_dcc_get_win(dcc_data, ck_index, i);
+		DDR_DEBUG("CK win[%x] = [%x]", i, cur_win);
+		if (cur_win < win_min) {
+			win_min = cur_win;
+		}
+	}
+	return win_min;
+}
+
+/* Duty Correction Control get ck0 min win */
+static int ddr_dcc_get_ck0_win(struct ddr_cfg_st *cfg, struct dcc_data_st *dcc_data,
+	int rank_index, unsigned int ck0_win_min)
+{
+	int ck_index = 0;
+	unsigned int byte_index;
+	unsigned int ck0_win;
+	unsigned int byte_num = cfg->phy[cfg->phy_idx].total_byte_num;
+
+	for (byte_index = 0; byte_index < (byte_num/2); byte_index++) {
+		dcc_data->ck[ck_index].val[byte_index] = ddr_read(cfg->cur_phy + DDR_PHY_DXNRDBOUND(byte_index));
+	}
+
+	ck0_win = ddr_dcc_get_min_win(dcc_data, ck_index);
+
+	if (ck0_win < ck0_win_min)
+		ck0_win_min = ck0_win;
+
+	return ck0_win_min;
+}
+
+/* Duty Correction Control get ck1 min win */
+static int ddr_dcc_get_ck1_win(struct ddr_cfg_st *cfg, struct dcc_data_st *dcc_data,
+	int rank_index, unsigned int ck1_win_min)
+{
+	int ck_index = 1;
+	unsigned int byte_index;
+	unsigned int ck1_win;
+	unsigned int byte_num = cfg->phy[cfg->phy_idx].total_byte_num;
+
+	for (byte_index = 2; byte_index < byte_num; byte_index++) {
+		dcc_data->ck[ck_index].val[byte_index - 2] = ddr_read(cfg->cur_phy + DDR_PHY_DXNRDBOUND(byte_index));
+	}
+
+	ck1_win = ddr_dcc_get_min_win(dcc_data, ck_index);
+
+	if (ck1_win < ck1_win_min)
+		ck1_win_min = ck1_win;
+
+	return ck1_win_min;
+}
+
+static void dcc_data_init(struct dcc_data_st *dcc_data)
+{
+	dcc_data->ck[0].win_min_ctl = 0xffffffff;
+	dcc_data->ck[0].win_max_ctl = 0x0;
+	dcc_data->ck[1].win_min_ctl = 0xffffffff;
+	dcc_data->ck[1].win_max_ctl = 0x0;
+	dcc_data->ck[0].idx_duty = 0;
+	dcc_data->ck[0].idx_duty_ctl = 0;
+	dcc_data->ck[0].idx_ctl = 0;
+	dcc_data->ck[1].idx_duty = 0;
+	dcc_data->ck[1].idx_duty_ctl = 0;
+	dcc_data->ck[1].idx_ctl = 0;
+	dcc_data->ck[0].BYPASS_CK_BIT = PHY_BYPASS_CK0_BIT;
+	dcc_data->ck[0].ACIOCTL21_CTL_BIT = PHY_ACIOCTL21_CTL0_BIT;
+	dcc_data->ck[0].ACIOCTL21_CK_BIT = PHY_ACIOCTL21_CK0_BIT;
+	dcc_data->ck[1].BYPASS_CK_BIT = PHY_BYPASS_CK1_BIT;
+	dcc_data->ck[1].ACIOCTL21_CTL_BIT = PHY_ACIOCTL21_CTL1_BIT;
+	dcc_data->ck[1].ACIOCTL21_CK_BIT = PHY_ACIOCTL21_CK1_BIT;
+}
+
+/* dcc training get window by rank */
+static int ddr_dcc_get_win_by_rank(struct ddr_cfg_st *cfg, struct dcc_data_st *dcc_data)
+{
+	int i;
+	int result = 0;
+	unsigned int rank_num = cfg->phy[cfg->phy_idx].rank_num;
+	for (i = 0; i < rank_num; i++) {
+		DDR_DEBUG("cur_rank = [%x]", i);
+		cfg->rank_idx = i;
+		/* RDET */
+		result += ddr_dcc_dataeye_read(cfg);
+
+		/* Get win */
+		dcc_data->ck[0].win = ddr_dcc_get_ck0_win(cfg, dcc_data, i, dcc_data->ck[0].win);
+		DDR_DEBUG("ck0 win = [%x]", dcc_data->ck[0].win);
+
+		if (PHY_DRAMCFG_TYPE_LPDDR4 == cfg->phy[cfg->phy_idx].dram_type) {
+			dcc_data->ck[1].win = ddr_dcc_get_ck1_win(cfg, dcc_data, i, dcc_data->ck[1].win);
+			DDR_DEBUG("ck1 win = [%x]", dcc_data->ck[1].win);
+		}
+
+		/* Restore two rank bdl */
+		ddr_restore_two_rank_bdl(cfg, dcc_data);
+	}
+	return result;
+}
+
+/* ddr dcc training compare result */
+static void ddr_dcc_compare_result(struct dcc_data_st *dcc_data, int ck_num,
+	unsigned int base_phy, unsigned int gated_bypass_def, unsigned int ioctl21_def)
+{
+	int ck_idx;
+
+	for (ck_idx = 0; ck_idx < ck_num; ck_idx++) {
+		/* Config ck0 duty */
+		if (dcc_data->ck[ck_idx].win_max_ctl - dcc_data->ck[ck_idx].win_min_ctl <= 2) {
+			dcc_data->ck[ck_idx].def_bp = gated_bypass_def >> dcc_data->ck[ck_idx].BYPASS_CK_BIT & 0x1;
+			dcc_data->ck[ck_idx].def_ctl = ioctl21_def >> dcc_data->ck[ck_idx].ACIOCTL21_CTL_BIT & 0x1;
+			dcc_data->ck[ck_idx].def_duty = ioctl21_def >> dcc_data->ck[ck_idx].ACIOCTL21_CK_BIT & PHY_ACIOCTL21_MASK;
+
+			gated_bypass_def = (gated_bypass_def & (~(1 << dcc_data->ck[ck_idx].BYPASS_CK_BIT)))
+								| (dcc_data->ck[ck_idx].def_bp << dcc_data->ck[ck_idx].BYPASS_CK_BIT);
+			ddr_write(gated_bypass_def, base_phy + DDR_PHY_AC_GATED_BYPASS);
+
+			ioctl21_def = (ioctl21_def & (~(1 << dcc_data->ck[ck_idx].ACIOCTL21_CTL_BIT))
+							& (~(PHY_ACIOCTL21_MASK << dcc_data->ck[ck_idx].ACIOCTL21_CK_BIT)))
+							| (dcc_data->ck[ck_idx].def_ctl << dcc_data->ck[ck_idx].ACIOCTL21_CTL_BIT)
+							| (dcc_data->ck[ck_idx].def_duty << dcc_data->ck[ck_idx].ACIOCTL21_CK_BIT);
+			ddr_write(ioctl21_def, base_phy + DDR_PHY_ACIOCTL21);
+
+			DDR_DEBUG("ck[%x] Final AC_GATED_BYPASS[%x]", ck_idx, gated_bypass_def);
+			DDR_DEBUG("ck[%x] Final ACIOCTL21[%x]", ck_idx, ioctl21_def);
+		} else {
+			ioctl21_def = (ioctl21_def & (~(1 << dcc_data->ck[ck_idx].ACIOCTL21_CTL_BIT))
+							& (~(PHY_ACIOCTL21_MASK << dcc_data->ck[ck_idx].ACIOCTL21_CK_BIT)))
+							| (dcc_data->ck[ck_idx].idx_ctl << dcc_data->ck[ck_idx].ACIOCTL21_CTL_BIT)
+							| (dcc_data->ck[ck_idx].idx_duty_ctl << dcc_data->ck[ck_idx].ACIOCTL21_CK_BIT);
+			ddr_write(ioctl21_def, base_phy + DDR_PHY_ACIOCTL21);
+
+			DDR_DEBUG("ck[%x] Final ACIOCTL21[%x]", ck_idx, ioctl21_def);
+		}
+	}
+}
+
+static int ddr_dcc_get_best_duty(struct ddr_cfg_st *cfg,
+	struct dmc_cfg_sref_st *cfg_sref, struct dcc_data_st *dcc_data)
+{
+	int ck_idx;
+	int ck_num;
+	int result = 0;
+	unsigned int cur_ctl;
+	unsigned int cur_duty;
+	unsigned int base_phy = cfg->cur_phy;
+	unsigned int ioctl21_def;
+	unsigned int gated_bypass_def, gated_bypass_temp;
+
+	if (PHY_DRAMCFG_TYPE_LPDDR4 == cfg->phy[cfg->phy_idx].dram_type)
+		ck_num = 2;
+	else
+		ck_num = 1;
+
+	dcc_data_init(dcc_data);
+
+	/* Save ck duty default config. Read two times to get the right static register value. */
+	gated_bypass_def = ddr_read(base_phy + DDR_PHY_AC_GATED_BYPASS);
+	gated_bypass_def = ddr_read(base_phy + DDR_PHY_AC_GATED_BYPASS);
+	ioctl21_def = ddr_read(base_phy + DDR_PHY_ACIOCTL21);
+	ioctl21_def = ddr_read(base_phy + DDR_PHY_ACIOCTL21);
+
+	DDR_DEBUG("gated_bypass_def[%x] ioctl21_def[%x]", gated_bypass_def, ioctl21_def);
+
+	/* DCC training exit self-refresa enter powerdown. */
+	if (PHY_DRAMCFG_TYPE_LPDDR4 == cfg->phy[cfg->phy_idx].dram_type)
+		ddr_exit_sref_enter_pd(cfg, cfg_sref);
+
+	/* DDR dcc training enter auto self-refresh. */
+	if (ddr_training_ctrl_easr(cfg, DDR_ENTER_SREF))
+		return -1;
+
+	/* Enable ck0 & ck1 duty. */
+	if (PHY_DRAMCFG_TYPE_LPDDR4 == cfg->phy[cfg->phy_idx].dram_type) {
+		gated_bypass_temp = gated_bypass_def | PHY_CK1_IOCTL_DUTY_EN | PHY_CK_IOCTL_DUTY_EN;
+		ddr_write(gated_bypass_temp, base_phy + DDR_PHY_AC_GATED_BYPASS);
+	} else {
+		gated_bypass_temp = gated_bypass_def | PHY_CK_IOCTL_DUTY_EN;
+		ddr_write(gated_bypass_temp, base_phy + DDR_PHY_AC_GATED_BYPASS);
+	}
+	DDR_DEBUG("Cur GATED_BYPASS[%x]", gated_bypass_temp);
+
+	if (ddr_training_ctrl_easr(cfg, DDR_EXIT_SREF))
+		return -1;
+
+	for (cur_ctl = 0; cur_ctl < DDR_DUTY_CTL_NUM; cur_ctl++) {
+		dcc_data->ck[0].win_min_duty = 0xffffffff;
+		dcc_data->ck[0].win_max_duty = 0x0;
+		dcc_data->ck[1].win_min_duty = 0xffffffff;
+		dcc_data->ck[1].win_max_duty = 0x0;
+
+		DDR_DEBUG("cur_ctl = [%x]", cur_ctl);
+
+		if (ddr_training_ctrl_easr(cfg, DDR_ENTER_SREF))
+			return -1;
+
+		/* Correct CK duty dirrection control */
+		dcc_data->ioctl21_tmp = ddr_dcc_ck_ctl(cfg, ioctl21_def, cur_ctl);
+
+		if (ddr_training_ctrl_easr(cfg, DDR_EXIT_SREF))
+			return -1;
+
+		for (cur_duty = 0; cur_duty < DDR_DUTY_NUM; cur_duty += PHY_AC_IOCTL21_STEP) {
+			dcc_data->ck[0].win = 0xffffffff;
+			dcc_data->ck[1].win = 0xffffffff;
+
+			DDR_DEBUG("cur_duty = [%x]", cur_duty);
+			/* Correct ck0 and ck1 duty */
+			if (ddr_training_ctrl_easr(cfg, DDR_ENTER_SREF))
+				return -1;
+			dcc_data->ioctl21_tmp = ddr_dcc_correct_duty(cfg, cur_duty, dcc_data->ioctl21_tmp);
+			if (ddr_training_ctrl_easr(cfg, DDR_EXIT_SREF))
+				return -1;
+			DDR_DEBUG("Cur ACIOCTL21[%x]", dcc_data->ioctl21_tmp);
+
+			result = ddr_dcc_get_win_by_rank(cfg, dcc_data);
+
+			/* Get ck0/ck1 duty_win_min/duty_win_max/duty_index */
+			for (ck_idx = 0; ck_idx < ck_num; ck_idx++) {
+				if (dcc_data->ck[ck_idx].win < dcc_data->ck[ck_idx].win_min_duty)
+					dcc_data->ck[ck_idx].win_min_duty = dcc_data->ck[ck_idx].win;
+
+				if (dcc_data->ck[ck_idx].win > dcc_data->ck[ck_idx].win_max_duty) {
+					dcc_data->ck[ck_idx].win_max_duty = dcc_data->ck[ck_idx].win;
+					dcc_data->ck[ck_idx].idx_duty = cur_duty;
+				}
+				DDR_DEBUG("ck[%x] duty_win_min[%x] duty_win_max[%x] duty_index[%x]", ck_idx,
+					dcc_data->ck[ck_idx].win_min_duty,
+					dcc_data->ck[ck_idx].win_max_duty,
+					dcc_data->ck[ck_idx].idx_duty);
+			}
+		}
+
+		for (ck_idx = 0; ck_idx < ck_num; ck_idx++) {
+		/* Get ck0/ck1 duty_win_min/duty_win_max/duty_index */
+			if (dcc_data->ck[ck_idx].win_min_duty < dcc_data->ck[ck_idx].win_min_ctl)
+				dcc_data->ck[ck_idx].win_min_ctl = dcc_data->ck[ck_idx].win_min_duty;
+
+			if (dcc_data->ck[ck_idx].win_max_duty > dcc_data->ck[ck_idx].win_max_ctl) {
+				dcc_data->ck[ck_idx].win_max_ctl = dcc_data->ck[ck_idx].win_max_duty;
+				dcc_data->ck[ck_idx].idx_duty_ctl = dcc_data->ck[ck_idx].idx_duty;
+				dcc_data->ck[ck_idx].idx_ctl = cur_ctl;
+			}
+			DDR_DEBUG("ck[%x] win_min_ctl[%x] win_max_ctl[%x] ctl_index0[%x] duty_ctl_idx0[%x]", ck_idx,
+				dcc_data->ck[ck_idx].win_min_ctl,
+				dcc_data->ck[ck_idx].win_max_ctl,
+				dcc_data->ck[ck_idx].idx_ctl,
+				dcc_data->ck[ck_idx].idx_duty_ctl);
+		}
+	}
+
+	/* Config ck duty */
+	/* DCC training exit self-refresa enter powerdown. */
+	if (PHY_DRAMCFG_TYPE_LPDDR4 == cfg->phy[cfg->phy_idx].dram_type)
+		ddr_exit_sref_enter_pd(cfg, cfg_sref);
+
+	/* DDR dcc training enter auto self-refresh. */
+	if (ddr_training_ctrl_easr(cfg, DDR_ENTER_SREF))
+		return -1;
+
+	/* DDR dcc training compare result. */
+	ddr_dcc_compare_result(dcc_data, ck_num, base_phy, gated_bypass_def, ioctl21_def);
+
+	/* DDR dcc training exit auto self-refresh. */
+	if (ddr_training_ctrl_easr(cfg, DDR_EXIT_SREF))
+		return -1;
+
+	return result;
+}
+
+#ifdef DDR_TRAINING_DEBUG
+#define DDR_TRINING_BREAK_POINT(name) ddr_training_break_point(name)
+#else
+#define DDR_TRINING_BREAK_POINT(name)
+#endif
+
+void ddr_training_break_point(const char* name)
+{
+	DDR_INFO(name);
+	ddr_training_console_if(0);
+}
+
+int ddr_dcc_training(struct ddr_cfg_st *cfg)
+{
+	int i;
+	int result = 0;
+	unsigned int rank_num = cfg->phy[cfg->phy_idx].rank_num;
+
+	struct dmc_cfg_sref_st cfg_sref;
+	struct ddr_timing_st timing_st;
+	struct dcc_data_st dcc_st;
+	struct dcc_data_st *dcc_data = &dcc_st;
+
+	DDR_DEBUG("dram_type[%x]", cfg->phy[cfg->phy_idx].dram_type);
+
+	DDR_DEBUG("rank num[%x]", rank_num);
+
+	/* Save two rank DERT default result: rdq/rdqs/rdm/ bdl */
+	for (i = 0; i < rank_num; i++) {
+		cfg->rank_idx = i;
+		ddr_save_two_rank_bdl(cfg, dcc_data);
+	}
+
+	/* Disable auto refresh */
+	ddr_training_save_timing(cfg, &timing_st);
+
+	/* Duty Correction Control training. */
+	result += ddr_dcc_get_best_duty(cfg, &cfg_sref, dcc_data);
+
+	/* Do DERT training again */
+	for (i = 0; i < rank_num; i++) {
+		cfg->rank_idx = i;
+		dcc_data->item[i] = cfg->phy[cfg->phy_idx].rank[i].item_hw;
+		cfg->phy[cfg->phy_idx].rank[i].item_hw = PHY_PHYINITCTRL_HVREFT_EN;
+		DDR_DEBUG("item_hw[%x]=[%x]", i, cfg->phy[cfg->phy_idx].rank[i].item_hw);
+	}
+
+	result += ddr_hw_training_by_phy(cfg);
+
+	for (i = 0; i < rank_num; i++) {
+		cfg->rank_idx = i;
+		cfg->phy[cfg->phy_idx].rank[i].item_hw = dcc_data->item[i];
+	}
+
+	/* Enable auto refresh */
+	ddr_training_restore_timing(cfg, &timing_st);
+
+	if (PHY_DRAMCFG_TYPE_LPDDR4 == cfg->phy[cfg->phy_idx].dram_type) {
+		/* DCC restore DMC_CFG_SREF config. */
+		ddr_restore_sref_cfg(cfg, &cfg_sref);
+	}
+
+	return result;
+}
+
+int ddr_dcc_training_func(struct ddr_cfg_st *cfg)
+{
+	int i;
+	int result = 0;
+
+	for (i = 0; i < cfg->phy_num; i++) {
+		cfg->phy_idx = i;
+		cfg->cur_phy = cfg->phy[i].addr;
+		cfg->cur_item = cfg->phy[i].rank[0].item;
+
+		if (ddr_training_check_bypass(cfg, 1 << (cfg->phy_idx)))
+			continue;
+
+		/* dpmc training disable */
+		if (!ddr_training_check_bypass(cfg, DDR_BYPASS_DCC_MASK))
+			result += ddr_dcc_training(cfg);
+	}
+	return result;
+}
+
+#else
+int ddr_dcc_training_func(struct ddr_cfg_st *cfg)
+{
+	DDR_WARNING("Not support DCC training.");
+	return 0;
+}
+#endif /* DDR_DCC_TRAINING_CONFIG */
+
+#define __pcode_training__
+#ifdef DDR_PCODE_TRAINING_CONFIG
+/* Set pcode value to register IMPSTATUS and DDR_PHY_IMP_STATUS1 */
+static void ddr_pcode_set_value(unsigned int base_phy, unsigned int pcode_value)
+{
+	unsigned int imp_ctrl1;
+
+	ddr_write((ddr_read(base_phy + DDR_PHY_IMPSTATUS)
+				& (~(PHY_ZCODE_PDRV_MASK << PHY_ZCODE_PDRV_BIT)))
+				| (pcode_value << PHY_ZCODE_PDRV_BIT), base_phy + DDR_PHY_IMPSTATUS);
+	DDR_DEBUG("cur IMPSTATUS [%x] = [%x]",
+			base_phy + DDR_PHY_IMPSTATUS, ddr_read(base_phy + DDR_PHY_IMPSTATUS));
+
+	imp_ctrl1 = ddr_read(base_phy + DDR_PHY_IMP_CTRL1);
+	/* ac_vddq_cal_en set 0 */
+	ddr_write(imp_ctrl1 & (~(0x1 << PHY_AC_VDDQ_CAL_EN_BIT)), base_phy + DDR_PHY_IMP_CTRL1);
+
+	ddr_write((ddr_read(base_phy + DDR_PHY_IMP_STATUS1)
+				& (~(PHY_ACCTL_PDRV_LATCH_MASK << PHY_ACCTL_PDRV_LATCH_BIT)))
+				| (pcode_value << PHY_ACCTL_PDRV_LATCH_BIT), base_phy + DDR_PHY_IMP_STATUS1);
+	DDR_DEBUG("cur IMP_STATUS1 [%x] = [%x]",
+			base_phy + DDR_PHY_IMP_STATUS1, ddr_read(base_phy + DDR_PHY_IMP_STATUS1));
+
+	/* restore ac_vddq_cal_en */
+	ddr_write(imp_ctrl1, base_phy + DDR_PHY_IMP_CTRL1);
+}
+
+static int ddr_pcode_trainig_by_phy(struct ddr_cfg_st *cfg)
+{
+	unsigned int times = 0;
+	unsigned int base_phy = cfg->cur_phy;
+	unsigned int pcode_value;
+	unsigned int osc_rpt_vld;
+	unsigned int osc_cnt_rdata;
+	int ddr_freq;
+
+	/* test start */
+	ddr_write(ddr_read(base_phy + DDR_PHY_CORNER_DETECTOR) | PHY_OSC_START_MASK,
+					base_phy + DDR_PHY_CORNER_DETECTOR);
+
+	do {
+		osc_rpt_vld = (ddr_read(base_phy + DDR_PHY_CORNER_DETECTOR)
+							>> PHY_OSC_RPT_VLD) & PHY_OSC_RPT_VLD_MASK;
+		times++;
+	} while ((!osc_rpt_vld)
+			&& (times < DDRT_PCODE_WAIT_TIMEOUT));
+
+	if (times >= DDRT_PCODE_WAIT_TIMEOUT) {
+		DDR_FATAL("IO pcode training wait timeout.");
+		return -1;
+	}
+
+	osc_cnt_rdata = (ddr_read(base_phy + DDR_PHY_CORNER_DETECTOR)
+						>> PHY_OSC_CNT_RDATA_BIT)
+						& PHY_OSC_CNT_RDATA_MASK;
+
+	/* test stop */
+	ddr_write(ddr_read(base_phy + DDR_PHY_CORNER_DETECTOR)
+				& (~PHY_OSC_START_MASK), base_phy + DDR_PHY_CORNER_DETECTOR);
+
+	ddr_freq = ddr_get_cksel();
+	/* get pcode value */
+	pcode_value = (490960 - (89 * osc_cnt_rdata * ddr_freq) / 300) / 10000;
+
+	DDR_DEBUG("pcode value[%x]", pcode_value);
+	if (pcode_value < PHY_PCODE_MIN) {
+		pcode_value = PHY_PCODE_MIN;
+	} else if (pcode_value > PHY_PCODE_MAX) {
+		pcode_value = PHY_PCODE_MAX;
+	}
+
+	/* set pcode value */
+	ddr_pcode_set_value(base_phy, pcode_value);
+	return 0;
+}
+
+int ddr_pcode_training(struct ddr_cfg_st *cfg)
+{
+	struct tr_relate_reg relate_reg;
+	int result = 0;
+	int i;
+
+	for (i = 0; i < cfg->phy_num; i++) {
+		cfg->phy_idx = i;
+		cfg->cur_phy = cfg->phy[i].addr;
+		cfg->cur_item = cfg->phy[i].rank[0].item;
+
+		if (ddr_training_check_bypass(cfg, 1 << (cfg->phy_idx)))
+			continue;
+
+		/* pcode training disable */
+		if (ddr_training_check_bypass(cfg, DDR_BYPASS_PCODE_MASK))
+			continue;
+
+		ddr_training_save_reg(cfg, &relate_reg, DDR_BYPASS_PCODE_MASK);
+		result += ddr_pcode_trainig_by_phy(cfg);
+		ddr_training_restore_reg(cfg, &relate_reg);
+	}
+
+	return result;
+}
+#else
+int ddr_pcode_training(struct ddr_cfg_st *cfg)
+{
+	DDR_WARNING("Not support DDR pcode training.");
+	return 0;
+}
+#endif
diff -uraN u-boot-2016.11/drivers/ddr/goke/default/ddr_training_impl.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/ddr_training_impl.h
--- u-boot-2016.11/drivers/ddr/goke/default/ddr_training_impl.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/ddr_training_impl.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,454 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef DDR_TRAINING_IMPL_H
+#define DDR_TRAINING_IMPL_H
+
+#ifndef __ASSEMBLY__
+
+#include "ddr_training_custom.h"
+#include "ddr_training_internal_config.h"
+#include "ddr_interface.h"
+
+/****** special config define*******************************************/
+#ifdef DDR_DATAEYE_NORMAL_NOT_ADJ_CONFIG
+/* Adjust dataeye window consume a lot of time, disable it will make boot
+ * faster.
+ * NOTE: The WDQ Phase and RDQS MUST be config a good value in the init table
+ * to avoid window trend to one side.
+ */
+#define DDR_DATAEYE_NORMAL_ADJUST   (DDR_FALSE)
+#else
+#define DDR_DATAEYE_NORMAL_ADJUST   (DDR_TRUE)
+#endif
+/* MUST adjust dataeye window after HW or MPR training */
+#define DDR_DATAEYE_ABNORMAL_ADJUST       (DDR_TRUE)
+
+/****** ddr training item bypass mask define ****************************/
+#define DDR_BYPASS_PHY0_MASK        0x1 /* [0]PHY0 training */
+#define DDR_BYPASS_PHY1_MASK        0x2 /* [1]PHY1 training */
+#define DDR_BYPASS_WL_MASK          0x10 /* [4]Write leveling */
+#define DDR_BYPASS_GATE_MASK        0x100 /* [8]Gate training */
+#define DDR_BYPASS_DATAEYE_MASK     0x10000 /* [16]Dataeye training */
+#define DDR_BYPASS_PCODE_MASK       0x40000 /* [18]Pcode training */
+#define DDR_BYPASS_HW_MASK          0x100000 /* [20]Hardware read training */
+#define DDR_BYPASS_MPR_MASK         0x200000 /* [21]MPR training */
+#define DDR_BYPASS_AC_MASK          0x400000 /* [22]AC training */
+#define DDR_BYPASS_LPCA_MASK        0x800000 /* [23]LPDDR CA training */
+#define DDR_BYPASS_VREF_HOST_MASK   0x1000000 /* [24]Host Vref training */
+#define DDR_BYPASS_VREF_DRAM_MASK   0x2000000 /* [25]DRAM Vref training */
+#define DDR_BYPASS_DCC_MASK         0x08000000 /* [27]DCC training */
+#define DDR_BYPASS_DATAEYE_ADJ_MASK 0x10000000 /* [28]Dataeye adjust */
+#define DDR_BYPASS_WL_ADJ_MASK      0x20000000 /* [29]WL write adjust */
+#define DDR_BYPASS_HW_ADJ_MASK      0x40000000 /* [30]HW read adjust */
+#define DDR_BYPASS_ALL_MASK         0xffffffff /* all bypass */
+
+/****** ddr read/write define **********************************************/
+unsigned int ddr_read(unsigned addr);
+void ddr_write(unsigned val, unsigned addr);
+
+/****** common define **********************************************/
+/* special ddrt need special read and write register */
+#ifdef DDR_DDRT_SPECIAL_CONFIG
+#define DDRT_REG_READ(addr)        ddr_ddrt_read(addr)
+#define DDRT_REG_WRITE(val, addr)  ddr_ddrt_write(val, addr)
+#else
+#define DDRT_REG_READ(addr)        ddr_read(addr)
+#define DDRT_REG_WRITE(val, addr)  ddr_write(val, addr)
+#endif
+
+#define DDR_MODE_READ                     (1 << 0)
+#define DDR_MODE_WRITE                    (1 << 1)
+
+#define DDR_ENTER_SREF                    (1 << 0)
+#define DDR_EXIT_SREF                     (1 << 1)
+
+/* DSB to make sure the operation is complete */
+#ifndef DDR_ASM_DSB
+#if (__LINUX_ARM_ARCH__ >= 8)
+#define DDR_ASM_DSB()                     { __asm__ __volatile__("dsb sy"); }
+#else
+#define DDR_ASM_DSB()                     { __asm__ __volatile__("dsb"); }
+#endif
+#endif
+
+#define DDR_HWR_WAIT_TIMEOUT	          0xffffffff
+#define DDR_SFC_WAIT_TIMEOUT	          (1000)
+#define DDR_LPCA_WAIT_TIMEOUT	          (1000)
+
+#ifdef CFG_EDA_VERIFY
+#define DDR_AUTO_TIMING_DELAY	          (1)
+#else
+#define DDR_AUTO_TIMING_DELAY	          (1000)
+#endif
+
+#define DDR_FIND_DQ_BOTH                  (1 << 0) /* find a valid value*/
+/* x is valid, (x-1) is invalid*/
+#define DDR_FIND_DQ_LEFT                  (1 << 1)
+/* x is valid, (x+1) is invalid*/
+#define DDR_FIND_DQ_RIGHT                 (1 << 2)
+
+#define DDR_VREF_DRAM_VAL_MAX             (0x32)        /* 92.50%*VDDIO */
+#define DDR_VREF_DRAM_VAL_MIN             (0x0)         /* 60.00%*VDDIO */
+
+#define DDR_PHY_REG_DQ_NUM                4  /* one register has 4 DQ BDL */
+
+#define DDR_PHY_CA_MAX                    10
+#define DDR_PHY_CA_REG_MAX                (DDR_PHY_CA_MAX >> 1)
+
+#define DDR_TRUE                          1
+#define DDR_FALSE                         0
+
+#define DDR_WIN_MIDDLE                    (1 << 0)
+#define DDR_WIN_LEFT                      (1 << 1)
+#define DDR_WIN_RIGHT                     (1 << 2)
+
+#define DDR_DELAY_PHASE                   1
+#define DDR_DELAY_BDL                     2
+
+#ifndef DDR_DATAEYE_WIN_NUM
+/* Dateeye window number. More bigger more slower when Vref training. */
+#define DDR_DATAEYE_WIN_NUM               8
+#endif
+#ifndef DDR_LOOP_TIMES_LMT
+/* Dataeye DQ deskew times for best result. More bigger more slower. */
+#define DDR_LOOP_TIMES_LMT                1
+#endif
+#ifndef DDR_VREF_COMPARE_TIMES
+/* Compare times when find best vref value. More bigger more slower. */
+#define DDR_VREF_COMPARE_TIMES            3
+#endif
+#ifndef DDR_MPR_RDQS_FIND_TIMES
+/* MPR Find first start rdqs times. More bigger, start rdqs more bigger. */
+#define DDR_MPR_RDQS_FIND_TIMES           3
+#endif
+#ifndef DDR_VREF_COMPARE_STEP
+/* Compare step when begin to find. More bigger, more mistake, more stable. */
+#define DDR_VREF_COMPARE_STEP             3
+#endif
+
+#define DDR_DATAEYE_RESULT_MASK           0xffff
+#define DDR_DATAEYE_RESULT_BIT            16
+
+#define DDR_WL_BDL_STEP                   2 /* wl bdl step */
+#define DDR_GATE_BDL_STEP                 2 /* gate bdl step */
+#define DDR_DQS_ADJ_STEP                  1 /* WR/RD DQS adjust step */
+
+#define DDR_DDRT_MODE_GATE                (1 << 0)
+#define DDR_DDRT_MODE_DATAEYE             (1 << 1)
+
+#define DDR_CHECK_TYPE_DDRT               (1 << 0)
+#define DDR_CHECK_TYPE_MPR                (1 << 1)
+
+#define DDR_MPR_BYTE_MASK                 0xff
+#define DDR_MPR_BIT_MASK                  0x1
+#define DDR_MPR_BYTE_BIT                  16          /* 16 bit (2 byte) */
+
+#define DDR_PHY_AC_TEST_VAL0              0x0
+#define DDR_PHY_AC_TEST_VAL1              0xffffffff
+#define DDR_PHY_AC_TEST_VAL2              0x55555555
+#define DDR_PHY_AC_TEST_VAL3              0xaaaaaaaa
+
+/*******log define ***********************************************/
+#if defined(DDR_TRAINING_CMD) && defined(DDR_TRAINING_LOG_CONFIG)
+#define DDR_INFO(fmt...)     ddr_training_log(__func__, DDR_LOG_INFO, fmt)
+#define DDR_DEBUG(fmt...)    ddr_training_log(__func__, DDR_LOG_DEBUG, fmt)
+#define DDR_WARNING(fmt...)  ddr_training_log(__func__, DDR_LOG_WARNING, fmt)
+#define DDR_ERROR(fmt...)    ddr_training_log(__func__, DDR_LOG_ERROR, fmt)
+#define DDR_FATAL(fmt...)    ddr_training_log(__func__, DDR_LOG_FATAL, fmt)
+#else
+#define DDR_INFO(fmt...)
+#define DDR_DEBUG(fmt...)
+#define DDR_WARNING(fmt...)
+#define DDR_ERROR(fmt...)
+#define DDR_FATAL(fmt...)
+#endif /* DDR_TRAINING_CMD && DDR_TRAINING_LOG_CONFIG */
+
+/* [11:0] Error type */
+/* 0x00000001 Write Leveling error */
+#define DDR_ERR_WL                        (1 << 0)
+/* 0x00000002 Hardware Gatining error */
+#define DDR_ERR_HW_GATING                 (1 << 1)
+/* 0x00000004 Sofeware Gatining error */
+#define DDR_ERR_GATING                    (1 << 2)
+/* 0x00000008 DDRT test time out */
+#define DDR_ERR_DDRT_TIME_OUT             (1 << 3)
+/* 0x00000010 Hardware read dataeye error */
+#define DDR_ERR_HW_RD_DATAEYE			  (1 << 4)
+/* 0x00000020 MPR error */
+#define DDR_ERR_MPR                       (1 << 5)
+/* 0x00000040 Dataeye error */
+#define DDR_ERR_DATAEYE                   (1 << 6)
+/* 0x00000080 LPDDR CA error */
+#define DDR_ERR_LPCA                      (1 << 7)
+
+/* [13:12] Error phy */
+/* 0x00001000 PHY0 training error */
+#define DDR_ERR_PHY0                      (1 << 12)
+/* 0x00002000 PHY1 training error */
+#define DDR_ERR_PHY1                      (1 << 13)
+
+#define DDR_ERR_BYTE_BIT                  24 /* [28:24] Error DQ0-31 */
+#define DDR_ERR_DQ_BIT                    20 /* [22:20] Error Byte0-3 */
+
+/*******data define*********************************************/
+#define GET_BYTE_NUM(cfg)  (cfg->phy[cfg->phy_idx].dmc[cfg->dmc_idx].byte_num)
+
+
+#ifndef DDR_RELATE_REG_DECLARE
+struct tr_custom_reg {
+};
+#endif
+
+struct dmc_cfg_sref_st {
+	unsigned int val[DDR_DMC_PER_PHY_MAX];
+};
+
+struct ddr_bdl_st {
+	unsigned int bdl[DDR_PHY_BYTE_MAX];
+};
+
+struct ddr_timing_st {
+	unsigned int val[DDR_DMC_PER_PHY_MAX];
+};
+
+struct rdqs_data_st {
+	struct ddr_bdl_st origin;
+	struct ddr_bdl_st rank[DDR_RANK_NUM];
+};
+
+struct ddr_delay_st {
+	unsigned int phase[DDR_PHY_BYTE_MAX];
+	unsigned int bdl[DDR_PHY_BYTE_MAX];
+};
+
+struct tr_relate_reg {
+	unsigned int auto_ref_timing;
+	unsigned int power_down;
+	unsigned int dmc_scramb;
+	unsigned int dmc_scramb_cfg;
+	unsigned int misc_scramb;
+	unsigned int ac_phy_ctl;
+	unsigned int swapdfibyte_en;
+	struct tr_custom_reg custom;
+	struct ddr_ddrc_data ddrc;
+};
+
+struct tr_dq_data {
+	unsigned int dq03[DDR_PHY_BYTE_MAX]; /* DQ0-DQ3 BDL */
+	unsigned int dq47[DDR_PHY_BYTE_MAX]; /* DQ4-DQ7 BDL */
+	unsigned int rdqs[DDR_PHY_BYTE_MAX];  /* RDQS */
+	unsigned int rdm[DDR_PHY_BYTE_MAX];  /* RDM */
+	unsigned int wdm[DDR_PHY_BYTE_MAX];  /* WDM */
+};
+
+struct ca_bit_st {
+	unsigned int bit_p;
+	unsigned int bit_n;
+};
+
+struct ca_data_st {
+	unsigned int base_dmc;
+	unsigned int base_phy;
+	unsigned int done; /* whether all ca found bdl range */
+	unsigned int min; /* min left bound */
+	unsigned int max; /* max right bound */
+	unsigned def[DDR_PHY_CA_REG_MAX];
+	int left[DDR_PHY_CA_MAX];
+	int right[DDR_PHY_CA_MAX];
+	struct ca_bit_st bits[DDR_PHY_CA_MAX];
+};
+
+struct ddr_dmc_st {
+	unsigned int addr;
+	unsigned int byte_num;
+	unsigned int ddrt_pattern; /* ddrt reversed data */
+};
+
+struct ddr_rank_st {
+	unsigned int item;    /* software training item */
+	unsigned int item_hw; /* hardware training item */
+};
+
+struct ddr_phy_st {
+	unsigned int addr;
+	unsigned int dram_type;
+	unsigned int dmc_num;
+	unsigned int rank_num;
+	unsigned int total_byte_num;
+	struct ddr_dmc_st dmc[DDR_DMC_PER_PHY_MAX];
+	struct ddr_rank_st rank[DDR_RANK_NUM];
+};
+
+struct ddr_cfg_st {
+	struct ddr_phy_st phy[DDR_PHY_NUM];
+	unsigned int phy_num;
+	unsigned int cur_phy; /* current training phy addr */
+	unsigned int cur_dmc; /* current training dmc addr */
+	unsigned int cur_item;  /* current SW or HW training item */
+	unsigned int cur_pattern;  /* current ddrt pattern */
+	unsigned int cur_mode;  /* read or write */
+	unsigned int cur_byte; /* current training byte index */
+	unsigned int cur_dq; /* current training dq index */
+	unsigned int phy_idx; /* current training phy index */
+	unsigned int rank_idx; /* current training rank index */
+	unsigned int dmc_idx; /* current training dmc index */
+	unsigned int adjust; /* whether need to adjust dataeye window */
+	unsigned int dq_check_type; /* ddrt or mpr */
+	void *cmd_st; /* struct ddr_cmd_st */
+	void *res_st; /* SW: struct ddr_training_result_st, HW: struct rdqs_data_st */
+};
+
+struct dcc_ck_st {
+	unsigned int val[DDR_CK_RESULT_MAX];
+	unsigned int win;
+	unsigned int win_min_ctl;
+	unsigned int win_max_ctl;
+	unsigned int win_min_duty;
+	unsigned int win_max_duty;
+	unsigned int def_bp;
+	unsigned int def_ctl;
+	unsigned int def_duty;
+	unsigned int idx_duty;
+	unsigned int idx_duty_ctl;
+	unsigned int idx_ctl;
+	unsigned int BYPASS_CK_BIT;
+	unsigned int ACIOCTL21_CTL_BIT;
+	unsigned int ACIOCTL21_CK_BIT;
+};
+
+#ifdef DDR_DCC_TRAINING_CONFIG
+struct dcc_data_st {
+	struct tr_dq_data rank[DDR_RANK_NUM];
+	struct dcc_ck_st ck[DDR_CK_NUM];
+	unsigned int item[DDR_CK_NUM];
+	unsigned int ioctl21_tmp;
+};
+#endif
+/*******Uart early function ***********************************************/
+#ifndef DDR_PUTS
+#define DDR_PUTS        uart_early_puts
+#endif
+#ifndef DDR_PUT_HEX
+#define DDR_PUT_HEX     uart_early_put_hex
+#endif
+#ifndef DDR_PUTC
+#define DDR_PUTC        uart_early_putc
+#endif
+
+#if defined(DDR_TRAINING_UART_CONFIG) || defined(DDR_TRAINING_LOG_CONFIG)
+extern void uart_early_puts(const char *s);
+extern void uart_early_put_hex(int hex);
+extern void uart_early_putc(int chr);
+#else
+#undef DDR_PUTS
+#undef DDR_PUT_HEX
+#undef DDR_PUTC
+#endif
+/*******function interface define*********************************************/
+#ifndef DDR_SW_TRAINING_FUNC
+#define DDR_SW_TRAINING_FUNC_PUBLIC
+#define DDR_SW_TRAINING_FUNC        ddr_sw_training_func
+#endif
+
+#ifndef DDR_HW_TRAINING_FUNC
+#define DDR_HW_TRAINING_FUNC_PUBLIC
+#define DDR_HW_TRAINING_FUNC        ddr_hw_training_func
+#endif
+
+#ifndef DDR_PCODE_TRAINING_FUNC
+#define DDR_PCODE_TRAINING_FUNC     ddr_pcode_training_func
+#endif
+
+#ifndef DDR_TRAINING_CONSOLE
+#define DDR_TRAINING_CONSOLE_PUBLIC
+#define DDR_TRAINING_CONSOLE        ddr_training_console
+#endif
+/*******Custom function ***********************************************/
+#ifndef DDR_TRAINING_DDRT_PREPARE_FUNC
+#define DDR_TRAINING_DDRT_PREPARE_FUNC()
+#endif
+#ifndef DDR_TRAINING_SAVE_REG_FUNC
+#define DDR_TRAINING_SAVE_REG_FUNC(relate_reg, mask)
+#endif
+#ifndef DDR_TRAINING_RESTORE_REG_FUNC
+#define DDR_TRAINING_RESTORE_REG_FUNC(relate_reg)
+#endif
+#ifndef ddr_boot_cmd_save_func
+#define ddr_boot_cmd_save_func(relate_reg) ((void)(relate_reg))
+#endif
+#ifndef ddr_boot_cmd_restore_func
+#define ddr_boot_cmd_restore_func(relate_reg) ((void)(relate_reg))
+#endif
+/*******function define*********************************************/
+int ddr_sw_training_func(void);
+int ddr_training_boot_func(struct ddr_cfg_st *cfg);
+int ddr_training_cmd_func(struct ddr_cfg_st *cfg);
+
+void* ddrtr_memset(void *b, int c, unsigned int len);
+void* ddrtr_memcpy(void *dst, const void *src, unsigned int len);
+void ddr_training_cfg_init(struct ddr_cfg_st *cfg);
+int ddr_training_by_dmc(struct ddr_cfg_st *cfg);
+int ddr_training_by_rank(struct ddr_cfg_st *cfg);
+int ddr_training_by_phy(struct ddr_cfg_st *cfg);
+int ddr_training_all(struct ddr_cfg_st *cfg);
+int ddr_dataeye_training_func(struct ddr_cfg_st *cfg);
+int ddr_vref_training_func(struct ddr_cfg_st *cfg);
+int ddr_wl_func(struct ddr_cfg_st *cfg);
+int ddr_gating_func(struct ddr_cfg_st *cfg);
+int ddr_ac_training_func(struct ddr_cfg_st *cfg);
+int ddr_lpca_training_func(struct ddr_cfg_st *cfg);
+int ddr_dcc_training_func(struct ddr_cfg_st *cfg);
+
+void ddr_phy_cfg_update(unsigned int base_phy);
+void ddr_phy_set_dq_bdl(struct ddr_cfg_st *cfg, unsigned int value);
+int ddr_hw_training(struct ddr_cfg_st *cfg);
+int ddr_pcode_training(struct ddr_cfg_st *cfg);
+
+int ddr_mpr_training(struct ddr_cfg_st *cfg);
+int ddr_write_leveling(struct ddr_cfg_st *cfg);
+int ddr_gate_training(struct ddr_cfg_st *cfg);
+int ddr_dataeye_training(struct ddr_cfg_st *cfg);
+int ddr_vref_training(struct ddr_cfg_st *cfg);
+int ddr_ac_training(struct ddr_cfg_st *cfg);
+int ddr_lpca_training(struct ddr_cfg_st *cfg);
+int ddr_dataeye_deskew(struct ddr_cfg_st *cfg, struct training_data *training);
+void ddr_adjust_dataeye(struct ddr_cfg_st *cfg, struct training_data *training);
+void ddr_result_data_save(struct ddr_cfg_st *cfg, struct training_data *training);
+void ddr_lpca_data_save(struct ca_data_st *data);
+unsigned int ddr_ddrt_get_test_addr(void);
+int ddr_ddrt_test(unsigned int mask, int byte, int dq);
+int ddr_dataeye_check_dq(struct ddr_cfg_st *cfg);
+void ddr_ddrt_init(struct ddr_cfg_st *cfg, unsigned int mode);
+int ddr_training_check_bypass(struct ddr_cfg_st *cfg, unsigned int mask);
+int ddr_training_phy_disable(int index);
+void ddr_training_save_reg(struct ddr_cfg_st *cfg, struct tr_relate_reg *relate_reg,
+			   unsigned int mask);
+void ddr_training_restore_reg(struct ddr_cfg_st *cfg, struct tr_relate_reg *relate_reg);
+void ddr_training_get_base(int index, unsigned int *base_dmc,
+			   unsigned int *base_phy);
+void ddr_training_switch_axi(struct ddr_cfg_st *cfg);
+void ddr_training_log(const char *func, int level, const char *fmt, ...);
+void ddr_training_stat(unsigned int mask, unsigned int phy, int byte, int dq);
+void ddr_training_error(unsigned int mask, unsigned int phy, int byte, int dq);
+void ddr_training_start(void);
+void ddr_training_suc(void);
+unsigned int ddr_phy_get_byte_num(unsigned int base_dmc);
+void ddr_training_set_timing(unsigned int base_dmc, unsigned int timing);
+int ddr_hw_dataeye_read(struct ddr_cfg_st *cfg);
+
+#ifdef DDR_MPR_TRAINING_CONFIG
+int ddr_mpr_training_func(struct ddr_cfg_st *cfg);
+int ddr_mpr_check(struct ddr_cfg_st *cfg);
+#else
+static inline int ddr_mpr_training_func(struct ddr_cfg_st *cfg)
+{
+	DDR_WARNING("Not support DDR MPR training.");
+	return 0;
+}
+static inline int ddr_mpr_check(struct ddr_cfg_st *cfg) { return 0;}
+#endif
+
+#endif /* __ASSEMBLY__ */
+#endif /* DDR_TRAINING_IMPL_H */
diff -uraN u-boot-2016.11/drivers/ddr/goke/default/ddr_training_internal_config.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/ddr_training_internal_config.h
--- u-boot-2016.11/drivers/ddr/goke/default/ddr_training_internal_config.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/ddr_training_internal_config.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,132 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef DDR_TRAINING_INTERNAL_CONFIG_H
+#define DDR_TRAINING_INTERNAL_CONFIG_H
+
+/****** include ddrc,phy,dmc define files *******************/
+#include "ddr_ddrc.h"
+
+#include "ddr_phy.h"
+
+#include "ddr_ddrt_v2_0_shf1.h"
+
+/****** training item define *******************/
+/* enable all config by default */
+#define DDR_WL_TRAINING_CONFIG
+#define DDR_GATE_TRAINING_CONFIG
+#define DDR_DATAEYE_TRAINING_CONFIG
+#define DDR_HW_TRAINING_CONFIG
+#define DDR_TRAINING_ADJUST_CONFIG
+#define DDR_TRAINING_LOG_CONFIG
+#define DDR_TRAINING_UART_CONFIG
+#define DDR_TRAINING_STAT_CONFIG
+
+/* defined in ddr_training_custom.h to disable this item */
+#ifdef DDR_VREF_TRAINING_DISABLE
+#undef DDR_VREF_TRAINING_CONFIG
+#endif
+
+#ifdef DDR_WL_TRAINING_DISABLE
+#undef DDR_WL_TRAINING_CONFIG
+#endif
+
+#ifdef DDR_GATE_TRAINING_DISABLE
+#undef DDR_GATE_TRAINING_CONFIG
+#endif
+
+#ifdef DDR_DATAEYE_TRAINING_DISABLE
+#undef DDR_DATAEYE_TRAINING_CONFIG
+#endif
+
+#ifdef DDR_HW_TRAINING_DISABLE
+#undef DDR_HW_TRAINING_CONFIG
+#endif
+
+#ifdef DDR_MPR_TRAINING_DISABLE
+#undef DDR_MPR_TRAINING_CONFIG
+#endif
+
+#ifdef DDR_TRAINING_ADJUST_DISABLE
+#undef DDR_TRAINING_ADJUST_CONFIG
+#endif
+
+#ifdef DDR_TRAINING_LOG_DISABLE
+#undef DDR_TRAINING_LOG_CONFIG
+#endif
+
+#ifdef DDR_TRAINING_UART_DISABLE
+#undef DDR_TRAINING_UART_CONFIG
+#endif
+
+#ifdef DDR_TRAINING_STAT_DISABLE
+#undef DDR_TRAINING_STAT_CONFIG
+#endif
+
+/* for training cmd */
+#ifdef DDR_TRAINING_CMD
+	/* defined in ddr_training_custom.h to disable this item */
+    #ifdef DDR_VREF_TRAINING_CMD_DISABLE
+    #undef DDR_VREF_TRAINING_CONFIG
+    #endif
+
+    #ifdef DDR_WL_TRAINING_CMD_DISABLE
+    #undef DDR_WL_TRAINING_CONFIG
+    #endif
+
+    #ifdef DDR_GATE_TRAINING_CMD_DISABLE
+    #undef DDR_GATE_TRAINING_CONFIG
+    #endif
+
+	#ifdef DDR_DATAEYE_TRAINING_CMD_DISABLE
+    #undef DDR_DATAEYE_TRAINING_CONFIG
+    #endif
+
+	#ifdef DDR_HW_TRAINING_CMD_DISABLE
+    #undef DDR_HW_TRAINING_CONFIG
+    #endif
+
+	#ifdef DDR_MPR_TRAINING_CMD_DISABLE
+    #undef DDR_MPR_TRAINING_CONFIG
+    #endif
+
+    #ifdef DDR_TRAINING_ADJUST_CMD_DISABLE
+    #undef DDR_TRAINING_ADJUST_CONFIG
+    #endif
+
+	#ifdef DDR_TRAINING_LOG_CMD_DISABLE
+    #undef DDR_TRAINING_LOG_CONFIG
+    #endif
+#endif /* DDR_TRAINING_CMD */
+
+/* check config */
+#if defined(DDR_TRAINING_ADJUST_DISABLE) && defined(DDR_HW_TRAINING_CONFIG) \
+	&& !defined(DDR_HW_READ_ADJ_CONFIG)
+#error when defined DDR_TRAINING_ADJUST_DISABLE, \
+	MUST define DDR_HW_READ_ADJ_CONFIG.
+#endif
+
+#if (defined(DDR_HW_TRAINING_CONFIG) || defined(DDR_MPR_TRAINING_CONFIG) \
+	|| defined(DDR_VREF_TRAINING_CONFIG) \
+	|| defined(DDR_TRAINING_ADJUST_CONFIG)) \
+	&& !defined(DDR_DATAEYE_TRAINING_CONFIG)
+#error when enable HW/GATE/VREF training or dataeye adjust, \
+	MUST define DDR_DATAEYE_TRAINING_CONFIG.
+#endif
+
+/* reserve config */
+/* DDR_WL_DATAEYE_ADJUST_CONFIG: Adjust WDQ phase/bdl after WL training. */
+/* DDR_VREF_TRAINING_CONFIG    : DDR Vref training. */
+/* DDR_MPR_TRAINING_CONFIG     : DDR MPR training. */
+/* DDR_AC_TRAINING_CONFIG      : DDR AC training. */
+/* DDR_LPCA_TRAINING_CONFIG    : LPDDR CA training. */
+/* DDR_DDRT_SPECIAL_CONFIG     : DDRT read and write special operate. */
+/* DDR_DDR4_CONFIG             : DDR4 special operate. */
+/* DDR_TRAINING_CUT_CODE_CONFIG: Cut code for small SRAM. */
+/* DDR_TRAINING_MINI_LOG_CONFIG: Less code to log */
+/* DDR_HW_READ_ADJ_CONFIG      : Adjust read dataeye after hw read training */
+/* DDR_VREF_WITHOUT_BDL_CONFIG : Vref not modify DQ bdl */
+/* DDR_DATAEYE_NORMAL_NOT_ADJ_CONFIG : Do not adjust window on normal case */
+
+#endif /* DDR_TRAINING_INTERNAL_CONFIG_H */
diff -uraN u-boot-2016.11/drivers/ddr/goke/default/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/Makefile
--- u-boot-2016.11/drivers/ddr/goke/default/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/default/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,17 @@
+ccflags-y += -Idrivers/ddr/goke/default -Idrivers/ddr/goke/$(SOC)
+
+ifndef CONFIG_MINI_BOOT
+obj-y += ddr_cmd_loc.o ddr_cmd_ctl.o cmd_ddr_training_v2.o
+else
+obj-y += ddr_cmd_ctl.o
+endif
+
+extra-y += ddr_training_impl.o ddr_training_ctl.o ddr_training_boot.o ddr_training_console.o
+
+ifndef CONFIG_MINI_BOOT
+$(obj)/ddr_cmd_loc.S: ddr_training_cmd_bin
+
+ddr_training_cmd_bin:
+	$(MAKE) -C $(CURDIR)/drivers/ddr/goke/default/cmd_bin TOPDIR=$(CURDIR) CROSS_COMPILE=$(CROSS_COMPILE) CPU=$(CPU) SOC=$(SOC)
+
+endif
diff -uraN u-boot-2016.11/drivers/ddr/goke/gk7202v300/ddr_training_custom.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/gk7202v300/ddr_training_custom.c
--- u-boot-2016.11/drivers/ddr/goke/gk7202v300/ddr_training_custom.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/gk7202v300/ddr_training_custom.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "ddr_interface.h"
+#include "ddr_training_impl.h"
+
+#define CRG_REG_BASE            0x12010000U
+#define PERI_CRG_DDRT           0x198U
+#define PERI_CRG_DDRCKSEL       0x80U
+/* [SYSCTRL]RAM Retention control register 0 */
+#define SYSCTRL_MISC_CTRL4      0x8010U
+
+static struct tr_relate_reg relate_reg;
+static struct tr_relate_reg *reg = &relate_reg;
+
+/**
+ * Do some prepare before copy code from DDR to SRAM.
+ * Keep empty when nothing to do.
+ */
+void ddr_cmd_prepare_copy(void) { return; }
+
+/**
+ * Save site before DDR training command execute .
+ * Keep empty when nothing to do.
+ */
+void ddr_cmd_site_save(void)
+{
+	/* select ddrt bus path */
+	reg->custom.ive_ddrt_mst_sel = ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_MISC_CTRL4);
+	ddr_write(reg->custom.ive_ddrt_mst_sel & 0xffffffdf, DDR_REG_BASE_SYSCTRL + SYSCTRL_MISC_CTRL4);
+
+	/* turn on ddrt clock */
+	reg->custom.ddrt_clk_reg = ddr_read(CRG_REG_BASE + PERI_CRG_DDRT);
+	/* enable ddrt0 clock */
+	ddr_write(reg->custom.ddrt_clk_reg | (1U << 1), CRG_REG_BASE + PERI_CRG_DDRT);
+	__asm__ __volatile__("nop");
+	/* disable ddrt0 soft reset */
+	ddr_write(ddr_read(CRG_REG_BASE + PERI_CRG_DDRT) & (~(1U << 0)), CRG_REG_BASE + PERI_CRG_DDRT);
+
+	/* disable rdqs anti-aging */
+	reg->custom.phy0_age_compst_en = ddr_read(DDR_REG_BASE_PHY0 + DDR_PHY_PHYRSCTRL);
+	ddr_write((reg->custom.phy0_age_compst_en & 0x7fffffff), DDR_REG_BASE_PHY0 + DDR_PHY_PHYRSCTRL);
+#ifdef DDR_REG_BASE_PHY1
+	reg->custom.phy1_age_compst_en = ddr_read(DDR_REG_BASE_PHY1 + DDR_PHY_PHYRSCTRL);
+	ddr_write((reg->custom.phy1_age_compst_en & 0x7fffffff), DDR_REG_BASE_PHY1 + DDR_PHY_PHYRSCTRL);
+#endif
+}
+
+/**
+ * Restore site after DDR training command execute.
+ * Keep empty when nothing to do.
+ */
+void ddr_cmd_site_restore(void)
+{
+	/* restore ddrt bus path */
+	ddr_write(reg->custom.ive_ddrt_mst_sel, DDR_REG_BASE_SYSCTRL + SYSCTRL_MISC_CTRL4);
+
+	/* restore ddrt clock */
+	ddr_write(reg->custom.ddrt_clk_reg, CRG_REG_BASE + PERI_CRG_DDRT);
+
+	/* restore rdqs anti-aging */
+	ddr_write(reg->custom.phy0_age_compst_en, DDR_REG_BASE_PHY0 + DDR_PHY_PHYRSCTRL);
+#ifdef DDR_REG_BASE_PHY1
+	ddr_write(reg->custom.phy1_age_compst_en, DDR_REG_BASE_PHY1 + DDR_PHY_PHYRSCTRL);
+#endif
+}
+
+void ddr_training_save_reg_custom(void *reg, unsigned int mask) { return; }
+void ddr_training_restore_reg_custom(void *reg) { return; }
+
+/**
+ * DDR clock select.
+ * For ddr osc training.
+ */
+#ifdef DDR_PCODE_TRAINING_CONFIG
+int ddr_get_cksel(void)
+{
+	int freq;
+	unsigned int ddr_cksel;
+	ddr_cksel = (ddr_read(CRG_REG_BASE + PERI_CRG_DDRCKSEL) >> 0x3) & 0x7;
+	switch (ddr_cksel) {
+	case 0x000:
+		/* 24MHz */
+		freq = 24;
+		break;
+	case 0x001:
+		/* 450MHz */
+		freq = 450;
+		break;
+	case 0x011:
+		/* 300MHz */
+		freq = 300;
+		break;
+	case 0x100:
+		/* 297MHz */
+		freq = 297;
+		break;
+	default:
+		freq = 300;
+		break;
+	}
+	return freq;
+}
+#endif
diff -uraN u-boot-2016.11/drivers/ddr/goke/gk7202v300/ddr_training_custom.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/gk7202v300/ddr_training_custom.h
--- u-boot-2016.11/drivers/ddr/goke/gk7202v300/ddr_training_custom.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/gk7202v300/ddr_training_custom.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef DDR_TRAINING_CUSTOM_H
+#define DDR_TRAINING_CUSTOM_H
+
+/* config DDRC, PHY, DDRT typte */
+#define DDR_DDRC_V520_CONFIG
+#define DDR_PHY_T28_CONFIG
+#define DDR_DDRT_V2_0_SHF1_CONFIG
+
+/* config special item */
+#define DDR_VREF_TRAINING_CONFIG
+#define DDR_VREF_WITHOUT_BDL_CONFIG
+//#define DDR_PCODE_TRAINING_CONFIG
+
+#define DDR_WL_TRAINING_DISABLE
+#define DDR_GATE_TRAINING_DISABLE
+#define DDR_TRAINING_UART_DISABLE
+
+/* Disable write dm
+#define DDR_WRITE_DM_DISABLE */
+
+#define DDR_PHY_NUM              1 /* phy number */
+
+#define DDR_DMC_PER_PHY_MAX      2 /* dmc number per phy max */
+
+#define DDR_AXI_SWITCH_NUM       4 /* ddr training axi switch number */
+
+/* config DDRC, PHY, DDRT base address */
+/* [CUSTOM] DDR PHY0 base register */
+#define DDR_REG_BASE_PHY0		0x120dc000
+/* [CUSTOM] DDR PHY1 base register
+#define DDR_REG_BASE_PHY1		0x120de000 */
+/* [CUSTOM] DDR DMC0 base register */
+#define DDR_REG_BASE_DMC0		0x120d8000
+/* [CUSTOM] DDR DMC1 base register */
+#define DDR_REG_BASE_DMC1		0x120d8000
+
+#ifdef DDR_REG_BASE_PHY1
+/* [CUSTOM] DDR DMC2 base register */
+#define DDR_REG_BASE_DMC2		0x120d9000
+/* [CUSTOM] DDR DMC3 base register */
+#define DDR_REG_BASE_DMC3		0x120d9000
+#endif
+
+/* [CUSTOM] DDR DDRT base register */
+#define DDR_REG_BASE_DDRT		0x11330000
+/* [CUSTOM] DDR training item system control */
+#define DDR_REG_BASE_SYSCTRL		0x12020000
+#define DDR_REG_BASE_AXI		0x120d0000
+/* Serial Configuration */
+#define DDR_REG_BASE_UART0		0x12040000
+
+/* config offset address */
+/* Assume sysctrl offset address for DDR training as follows,
+if not please define. */
+/* [CUSTOM] ddrt reversed data */
+#define SYSCTRL_DDRT_PATTERN			0xa8
+/* [CUSTOM] PHY2 ddrt reversed data
+#define SYSCTRL_DDRT_PATTERN_SEC		0xac */
+/* [CUSTOM] ddr training item */
+#define SYSCTRL_DDR_TRAINING_CFG		0xa0
+#define SYSCTRL_DDR_TRAINING_CFG_SEC		0xa4
+/* [CUSTOM] ddr training version flag */
+#define SYSCTRL_DDR_TRAINING_VERSION_FLAG	0xb4
+/* [CUSTOM] ddr training stat */
+#define SYSCTRL_DDR_TRAINING_STAT		0xb0
+
+/* [CUSTOM] ddr hw training item */
+#define SYSCTRL_DDR_HW_PHY0_RANK0		0x90
+#define SYSCTRL_DDR_HW_PHY0_RANK1		0x94
+#if 0
+/* PHY1 hw training item */
+#define SYSCTRL_DDR_HW_PHY1_RANK0		0x98
+#define SYSCTRL_DDR_HW_PHY1_RANK1		0x9c
+#endif
+
+/* config other special */
+/* [CUSTOM] DDR training start address. MEM_BASE_DDR */
+#define DDRT_CFG_BASE_ADDR		0x40000000
+/* [CUSTOM] SRAM start address.
+NOTE: Makefile will parse it, plase define it as Hex. eg: 0xFFFF0C00 */
+#define DDR_TRAINING_RUN_STACK		0x04010c00
+
+#define DDR_RELATE_REG_DECLARE
+#define DDR_TRAINING_SAVE_REG_FUNC(relate_reg, mask) \
+	ddr_training_save_reg_custom(relate_reg, mask)
+
+#define DDR_TRAINING_RESTORE_REG_FUNC(relate_reg) \
+	ddr_training_restore_reg_custom(relate_reg)
+
+struct tr_custom_reg {
+	unsigned int ive_ddrt_mst_sel;
+	unsigned int ddrt_clk_reg;
+	unsigned int phy0_age_compst_en;
+	unsigned int phy1_age_compst_en;
+};
+void ddr_training_save_reg_custom(void *relate_reg, unsigned int mask);
+void ddr_training_restore_reg_custom(void *relate_reg);
+int ddr_get_cksel(void);
+#endif /* DDR_TRAINING_CUSTOM_H */
diff -uraN u-boot-2016.11/drivers/ddr/goke/gk7202v300/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/gk7202v300/Makefile
--- u-boot-2016.11/drivers/ddr/goke/gk7202v300/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/gk7202v300/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,4 @@
+ccflags-y += -Idrivers/ddr/goke/default -Idrivers/ddr/goke/$(SOC)
+obj-y += ddr_training_custom.o
+
+obj-y += ../default/
diff -uraN u-boot-2016.11/drivers/ddr/goke/gk7205v200/ddr_training_custom.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/gk7205v200/ddr_training_custom.c
--- u-boot-2016.11/drivers/ddr/goke/gk7205v200/ddr_training_custom.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/gk7205v200/ddr_training_custom.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "ddr_interface.h"
+#include "ddr_training_impl.h"
+
+#define CRG_REG_BASE            0x12010000U
+#define PERI_CRG_DDRT           0x198U
+#define PERI_CRG_DDRCKSEL       0x80U
+/* [SYSCTRL]RAM Retention control register 0 */
+#define SYSCTRL_MISC_CTRL4      0x8010U
+
+static struct tr_relate_reg relate_reg;
+static struct tr_relate_reg *reg = &relate_reg;
+
+/**
+ * Do some prepare before copy code from DDR to SRAM.
+ * Keep empty when nothing to do.
+ */
+void ddr_cmd_prepare_copy(void) { return; }
+
+/**
+ * Save site before DDR training command execute .
+ * Keep empty when nothing to do.
+ */
+void ddr_cmd_site_save(void)
+{
+	/* select ddrt bus path */
+	reg->custom.ive_ddrt_mst_sel = ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_MISC_CTRL4);
+	ddr_write(reg->custom.ive_ddrt_mst_sel & 0xffffffdf, DDR_REG_BASE_SYSCTRL + SYSCTRL_MISC_CTRL4);
+
+	/* turn on ddrt clock */
+	reg->custom.ddrt_clk_reg = ddr_read(CRG_REG_BASE + PERI_CRG_DDRT);
+	/* enable ddrt0 clock */
+	ddr_write(reg->custom.ddrt_clk_reg | (1U << 1), CRG_REG_BASE + PERI_CRG_DDRT);
+	__asm__ __volatile__("nop");
+	/* disable ddrt0 soft reset */
+	ddr_write(ddr_read(CRG_REG_BASE + PERI_CRG_DDRT) & (~(1U << 0)), CRG_REG_BASE + PERI_CRG_DDRT);
+
+	/* disable rdqs anti-aging */
+	reg->custom.phy0_age_compst_en = ddr_read(DDR_REG_BASE_PHY0 + DDR_PHY_PHYRSCTRL);
+	ddr_write((reg->custom.phy0_age_compst_en & 0x7fffffff), DDR_REG_BASE_PHY0 + DDR_PHY_PHYRSCTRL);
+#ifdef DDR_REG_BASE_PHY1
+	reg->custom.phy1_age_compst_en = ddr_read(DDR_REG_BASE_PHY1 + DDR_PHY_PHYRSCTRL);
+	ddr_write((reg->custom.phy1_age_compst_en & 0x7fffffff), DDR_REG_BASE_PHY1 + DDR_PHY_PHYRSCTRL);
+#endif
+}
+
+/**
+ * Restore site after DDR training command execute.
+ * Keep empty when nothing to do.
+ */
+void ddr_cmd_site_restore(void)
+{
+	/* restore ddrt bus path */
+	ddr_write(reg->custom.ive_ddrt_mst_sel, DDR_REG_BASE_SYSCTRL + SYSCTRL_MISC_CTRL4);
+
+	/* restore ddrt clock */
+	ddr_write(reg->custom.ddrt_clk_reg, CRG_REG_BASE + PERI_CRG_DDRT);
+
+	/* restore rdqs anti-aging */
+	ddr_write(reg->custom.phy0_age_compst_en, DDR_REG_BASE_PHY0 + DDR_PHY_PHYRSCTRL);
+#ifdef DDR_REG_BASE_PHY1
+	ddr_write(reg->custom.phy1_age_compst_en, DDR_REG_BASE_PHY1 + DDR_PHY_PHYRSCTRL);
+#endif
+}
+
+void ddr_training_save_reg_custom(void *reg, unsigned int mask) { return; }
+void ddr_training_restore_reg_custom(void *reg) { return; }
+
+/**
+ * DDR clock select.
+ * For ddr osc training.
+ */
+#ifdef DDR_PCODE_TRAINING_CONFIG
+int ddr_get_cksel(void)
+{
+	int freq;
+	unsigned int ddr_cksel;
+	ddr_cksel = (ddr_read(CRG_REG_BASE + PERI_CRG_DDRCKSEL) >> 0x3) & 0x7;
+	switch (ddr_cksel) {
+	case 0x000:
+		/* 24MHz */
+		freq = 24;
+		break;
+	case 0x001:
+		/* 450MHz */
+		freq = 450;
+		break;
+	case 0x011:
+		/* 300MHz */
+		freq = 300;
+		break;
+	case 0x100:
+		/* 297MHz */
+		freq = 297;
+		break;
+	default:
+		freq = 300;
+		break;
+	}
+	return freq;
+}
+#endif
diff -uraN u-boot-2016.11/drivers/ddr/goke/gk7205v200/ddr_training_custom.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/gk7205v200/ddr_training_custom.h
--- u-boot-2016.11/drivers/ddr/goke/gk7205v200/ddr_training_custom.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/gk7205v200/ddr_training_custom.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef DDR_TRAINING_CUSTOM_H
+#define DDR_TRAINING_CUSTOM_H
+
+/* config DDRC, PHY, DDRT typte */
+#define DDR_DDRC_V520_CONFIG
+#define DDR_PHY_T28_CONFIG
+#define DDR_DDRT_V2_0_SHF1_CONFIG
+
+/* config special item */
+#define DDR_VREF_TRAINING_CONFIG
+#define DDR_VREF_WITHOUT_BDL_CONFIG
+//#define DDR_PCODE_TRAINING_CONFIG
+
+#define DDR_WL_TRAINING_DISABLE
+#define DDR_GATE_TRAINING_DISABLE
+#define DDR_TRAINING_UART_DISABLE
+
+/* Disable write dm
+#define DDR_WRITE_DM_DISABLE */
+
+#define DDR_PHY_NUM              1 /* phy number */
+
+#define DDR_DMC_PER_PHY_MAX      2 /* dmc number per phy max */
+
+#define DDR_AXI_SWITCH_NUM       4 /* ddr training axi switch number */
+
+/* config DDRC, PHY, DDRT base address */
+/* [CUSTOM] DDR PHY0 base register */
+#define DDR_REG_BASE_PHY0		0x120dc000
+/* [CUSTOM] DDR PHY1 base register
+#define DDR_REG_BASE_PHY1		0x120de000 */
+/* [CUSTOM] DDR DMC0 base register */
+#define DDR_REG_BASE_DMC0		0x120d8000
+/* [CUSTOM] DDR DMC1 base register */
+#define DDR_REG_BASE_DMC1		0x120d8000
+
+#ifdef DDR_REG_BASE_PHY1
+/* [CUSTOM] DDR DMC2 base register */
+#define DDR_REG_BASE_DMC2		0x120d9000
+/* [CUSTOM] DDR DMC3 base register */
+#define DDR_REG_BASE_DMC3		0x120d9000
+#endif
+
+/* [CUSTOM] DDR DDRT base register */
+#define DDR_REG_BASE_DDRT		0x11330000
+/* [CUSTOM] DDR training item system control */
+#define DDR_REG_BASE_SYSCTRL		0x12020000
+#define DDR_REG_BASE_AXI		0x120d0000
+/* Serial Configuration */
+#define DDR_REG_BASE_UART0		0x12040000
+
+/* config offset address */
+/* Assume sysctrl offset address for DDR training as follows,
+if not please define. */
+/* [CUSTOM] ddrt reversed data */
+#define SYSCTRL_DDRT_PATTERN			0xa8
+/* [CUSTOM] PHY2 ddrt reversed data
+#define SYSCTRL_DDRT_PATTERN_SEC		0xac */
+/* [CUSTOM] ddr training item */
+#define SYSCTRL_DDR_TRAINING_CFG		0xa0
+#define SYSCTRL_DDR_TRAINING_CFG_SEC		0xa4
+/* [CUSTOM] ddr training version flag */
+#define SYSCTRL_DDR_TRAINING_VERSION_FLAG	0xb4
+/* [CUSTOM] ddr training stat */
+#define SYSCTRL_DDR_TRAINING_STAT		0xb0
+
+/* [CUSTOM] ddr hw training item */
+#define SYSCTRL_DDR_HW_PHY0_RANK0		0x90
+#define SYSCTRL_DDR_HW_PHY0_RANK1		0x94
+#if 0
+/* PHY1 hw training item */
+#define SYSCTRL_DDR_HW_PHY1_RANK0		0x98
+#define SYSCTRL_DDR_HW_PHY1_RANK1		0x9c
+#endif
+
+/* config other special */
+/* [CUSTOM] DDR training start address. MEM_BASE_DDR */
+#define DDRT_CFG_BASE_ADDR		0x40000000
+/* [CUSTOM] SRAM start address.
+NOTE: Makefile will parse it, plase define it as Hex. eg: 0xFFFF0C00 */
+#define DDR_TRAINING_RUN_STACK		0x04010c00
+
+#define DDR_RELATE_REG_DECLARE
+#define DDR_TRAINING_SAVE_REG_FUNC(relate_reg, mask) \
+	ddr_training_save_reg_custom(relate_reg, mask)
+
+#define DDR_TRAINING_RESTORE_REG_FUNC(relate_reg) \
+	ddr_training_restore_reg_custom(relate_reg)
+
+struct tr_custom_reg {
+	unsigned int ive_ddrt_mst_sel;
+	unsigned int ddrt_clk_reg;
+	unsigned int phy0_age_compst_en;
+	unsigned int phy1_age_compst_en;
+};
+void ddr_training_save_reg_custom(void *relate_reg, unsigned int mask);
+void ddr_training_restore_reg_custom(void *relate_reg);
+int ddr_get_cksel(void);
+#endif /* DDR_TRAINING_CUSTOM_H */
diff -uraN u-boot-2016.11/drivers/ddr/goke/gk7205v200/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/gk7205v200/Makefile
--- u-boot-2016.11/drivers/ddr/goke/gk7205v200/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/gk7205v200/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,4 @@
+ccflags-y += -Idrivers/ddr/goke/default -Idrivers/ddr/goke/$(SOC)
+obj-y += ddr_training_custom.o
+
+obj-y += ../default/
diff -uraN u-boot-2016.11/drivers/ddr/goke/gk7205v300/ddr_training_custom.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/gk7205v300/ddr_training_custom.c
--- u-boot-2016.11/drivers/ddr/goke/gk7205v300/ddr_training_custom.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/gk7205v300/ddr_training_custom.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "ddr_interface.h"
+#include "ddr_training_impl.h"
+
+#define CRG_REG_BASE            0x12010000U
+#define PERI_CRG_DDRT           0x198U
+#define PERI_CRG_DDRCKSEL       0x80U
+/* [SYSCTRL]RAM Retention control register 0 */
+#define SYSCTRL_MISC_CTRL4      0x8010U
+
+static struct tr_relate_reg relate_reg;
+static struct tr_relate_reg *reg = &relate_reg;
+
+/**
+ * Do some prepare before copy code from DDR to SRAM.
+ * Keep empty when nothing to do.
+ */
+void ddr_cmd_prepare_copy(void) { return; }
+
+/**
+ * Save site before DDR training command execute .
+ * Keep empty when nothing to do.
+ */
+void ddr_cmd_site_save(void)
+{
+	/* select ddrt bus path */
+	reg->custom.ive_ddrt_mst_sel = ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_MISC_CTRL4);
+	ddr_write(reg->custom.ive_ddrt_mst_sel & 0xffffffdf, DDR_REG_BASE_SYSCTRL + SYSCTRL_MISC_CTRL4);
+
+	/* turn on ddrt clock */
+	reg->custom.ddrt_clk_reg = ddr_read(CRG_REG_BASE + PERI_CRG_DDRT);
+	/* enable ddrt0 clock */
+	ddr_write(reg->custom.ddrt_clk_reg | (1U << 1), CRG_REG_BASE + PERI_CRG_DDRT);
+	__asm__ __volatile__("nop");
+	/* disable ddrt0 soft reset */
+	ddr_write(ddr_read(CRG_REG_BASE + PERI_CRG_DDRT) & (~(1U << 0)), CRG_REG_BASE + PERI_CRG_DDRT);
+
+	/* disable rdqs anti-aging */
+	reg->custom.phy0_age_compst_en = ddr_read(DDR_REG_BASE_PHY0 + DDR_PHY_PHYRSCTRL);
+	ddr_write((reg->custom.phy0_age_compst_en & 0x7fffffff), DDR_REG_BASE_PHY0 + DDR_PHY_PHYRSCTRL);
+#ifdef DDR_REG_BASE_PHY1
+	reg->custom.phy1_age_compst_en = ddr_read(DDR_REG_BASE_PHY1 + DDR_PHY_PHYRSCTRL);
+	ddr_write((reg->custom.phy1_age_compst_en & 0x7fffffff), DDR_REG_BASE_PHY1 + DDR_PHY_PHYRSCTRL);
+#endif
+}
+
+/**
+ * Restore site after DDR training command execute.
+ * Keep empty when nothing to do.
+ */
+void ddr_cmd_site_restore(void)
+{
+	/* restore ddrt bus path */
+	ddr_write(reg->custom.ive_ddrt_mst_sel, DDR_REG_BASE_SYSCTRL + SYSCTRL_MISC_CTRL4);
+
+	/* restore ddrt clock */
+	ddr_write(reg->custom.ddrt_clk_reg, CRG_REG_BASE + PERI_CRG_DDRT);
+
+	/* restore rdqs anti-aging */
+	ddr_write(reg->custom.phy0_age_compst_en, DDR_REG_BASE_PHY0 + DDR_PHY_PHYRSCTRL);
+#ifdef DDR_REG_BASE_PHY1
+	ddr_write(reg->custom.phy1_age_compst_en, DDR_REG_BASE_PHY1 + DDR_PHY_PHYRSCTRL);
+#endif
+}
+
+void ddr_training_save_reg_custom(void *reg, unsigned int mask) { return; }
+void ddr_training_restore_reg_custom(void *reg) { return; }
+
+/**
+ * DDR clock select.
+ * For ddr osc training.
+ */
+#ifdef DDR_PCODE_TRAINING_CONFIG
+int ddr_get_cksel(void)
+{
+	int freq;
+	unsigned int ddr_cksel;
+	ddr_cksel = (ddr_read(CRG_REG_BASE + PERI_CRG_DDRCKSEL) >> 0x3) & 0x7;
+	switch (ddr_cksel) {
+	case 0x000:
+		/* 24MHz */
+		freq = 24;
+		break;
+	case 0x001:
+		/* 450MHz */
+		freq = 450;
+		break;
+	case 0x011:
+		/* 300MHz */
+		freq = 300;
+		break;
+	case 0x100:
+		/* 297MHz */
+		freq = 297;
+		break;
+	default:
+		freq = 300;
+		break;
+	}
+	return freq;
+}
+#endif
diff -uraN u-boot-2016.11/drivers/ddr/goke/gk7205v300/ddr_training_custom.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/gk7205v300/ddr_training_custom.h
--- u-boot-2016.11/drivers/ddr/goke/gk7205v300/ddr_training_custom.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/gk7205v300/ddr_training_custom.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef DDR_TRAINING_CUSTOM_H
+#define DDR_TRAINING_CUSTOM_H
+
+/* config DDRC, PHY, DDRT typte */
+#define DDR_DDRC_V520_CONFIG
+#define DDR_PHY_T28_CONFIG
+#define DDR_DDRT_V2_0_SHF1_CONFIG
+
+/* config special item */
+#define DDR_VREF_TRAINING_CONFIG
+#define DDR_VREF_WITHOUT_BDL_CONFIG
+//#define DDR_PCODE_TRAINING_CONFIG
+
+#define DDR_WL_TRAINING_DISABLE
+#define DDR_GATE_TRAINING_DISABLE
+#define DDR_TRAINING_UART_DISABLE
+
+/* Disable write dm
+#define DDR_WRITE_DM_DISABLE */
+
+#define DDR_PHY_NUM              1 /* phy number */
+
+#define DDR_DMC_PER_PHY_MAX      2 /* dmc number per phy max */
+
+#define DDR_AXI_SWITCH_NUM       4 /* ddr training axi switch number */
+
+/* config DDRC, PHY, DDRT base address */
+/* [CUSTOM] DDR PHY0 base register */
+#define DDR_REG_BASE_PHY0		0x120dc000
+/* [CUSTOM] DDR PHY1 base register
+#define DDR_REG_BASE_PHY1		0x120de000 */
+/* [CUSTOM] DDR DMC0 base register */
+#define DDR_REG_BASE_DMC0		0x120d8000
+/* [CUSTOM] DDR DMC1 base register */
+#define DDR_REG_BASE_DMC1		0x120d8000
+
+#ifdef DDR_REG_BASE_PHY1
+/* [CUSTOM] DDR DMC2 base register */
+#define DDR_REG_BASE_DMC2		0x120d9000
+/* [CUSTOM] DDR DMC3 base register */
+#define DDR_REG_BASE_DMC3		0x120d9000
+#endif
+
+/* [CUSTOM] DDR DDRT base register */
+#define DDR_REG_BASE_DDRT		0x11330000
+/* [CUSTOM] DDR training item system control */
+#define DDR_REG_BASE_SYSCTRL		0x12020000
+#define DDR_REG_BASE_AXI		0x120d0000
+/* Serial Configuration */
+#define DDR_REG_BASE_UART0		0x12040000
+
+/* config offset address */
+/* Assume sysctrl offset address for DDR training as follows,
+if not please define. */
+/* [CUSTOM] ddrt reversed data */
+#define SYSCTRL_DDRT_PATTERN			0xa8
+/* [CUSTOM] PHY2 ddrt reversed data
+#define SYSCTRL_DDRT_PATTERN_SEC		0xac */
+/* [CUSTOM] ddr training item */
+#define SYSCTRL_DDR_TRAINING_CFG		0xa0
+#define SYSCTRL_DDR_TRAINING_CFG_SEC		0xa4
+/* [CUSTOM] ddr training version flag */
+#define SYSCTRL_DDR_TRAINING_VERSION_FLAG	0xb4
+/* [CUSTOM] ddr training stat */
+#define SYSCTRL_DDR_TRAINING_STAT		0xb0
+
+/* [CUSTOM] ddr hw training item */
+#define SYSCTRL_DDR_HW_PHY0_RANK0		0x90
+#define SYSCTRL_DDR_HW_PHY0_RANK1		0x94
+#if 0
+/* PHY1 hw training item */
+#define SYSCTRL_DDR_HW_PHY1_RANK0		0x98
+#define SYSCTRL_DDR_HW_PHY1_RANK1		0x9c
+#endif
+
+/* config other special */
+/* [CUSTOM] DDR training start address. MEM_BASE_DDR */
+#define DDRT_CFG_BASE_ADDR		0x40000000
+/* [CUSTOM] SRAM start address.
+NOTE: Makefile will parse it, plase define it as Hex. eg: 0xFFFF0C00 */
+#define DDR_TRAINING_RUN_STACK		0x04010c00
+
+#define DDR_RELATE_REG_DECLARE
+#define DDR_TRAINING_SAVE_REG_FUNC(relate_reg, mask) \
+	ddr_training_save_reg_custom(relate_reg, mask)
+
+#define DDR_TRAINING_RESTORE_REG_FUNC(relate_reg) \
+	ddr_training_restore_reg_custom(relate_reg)
+
+struct tr_custom_reg {
+	unsigned int ive_ddrt_mst_sel;
+	unsigned int ddrt_clk_reg;
+	unsigned int phy0_age_compst_en;
+	unsigned int phy1_age_compst_en;
+};
+void ddr_training_save_reg_custom(void *relate_reg, unsigned int mask);
+void ddr_training_restore_reg_custom(void *relate_reg);
+int ddr_get_cksel(void);
+#endif /* DDR_TRAINING_CUSTOM_H */
diff -uraN u-boot-2016.11/drivers/ddr/goke/gk7205v300/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/gk7205v300/Makefile
--- u-boot-2016.11/drivers/ddr/goke/gk7205v300/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/gk7205v300/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,4 @@
+ccflags-y += -Idrivers/ddr/goke/default -Idrivers/ddr/goke/$(SOC)
+obj-y += ddr_training_custom.o
+
+obj-y += ../default/
diff -uraN u-boot-2016.11/drivers/ddr/goke/gk7605v100/ddr_training_custom.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/gk7605v100/ddr_training_custom.c
--- u-boot-2016.11/drivers/ddr/goke/gk7605v100/ddr_training_custom.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/gk7605v100/ddr_training_custom.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "ddr_interface.h"
+#include "ddr_training_impl.h"
+
+#define CRG_REG_BASE            0x12010000U
+#define PERI_CRG_DDRT           0x198U
+#define PERI_CRG_DDRCKSEL       0x80U
+/* [SYSCTRL]RAM Retention control register 0 */
+#define SYSCTRL_MISC_CTRL4      0x8010U
+
+static struct tr_relate_reg relate_reg;
+static struct tr_relate_reg *reg = &relate_reg;
+
+/**
+ * Do some prepare before copy code from DDR to SRAM.
+ * Keep empty when nothing to do.
+ */
+void ddr_cmd_prepare_copy(void) { return; }
+
+/**
+ * Save site before DDR training command execute .
+ * Keep empty when nothing to do.
+ */
+void ddr_cmd_site_save(void)
+{
+	/* select ddrt bus path */
+	reg->custom.ive_ddrt_mst_sel = ddr_read(DDR_REG_BASE_SYSCTRL + SYSCTRL_MISC_CTRL4);
+	ddr_write(reg->custom.ive_ddrt_mst_sel & 0xffffffdf, DDR_REG_BASE_SYSCTRL + SYSCTRL_MISC_CTRL4);
+
+	/* turn on ddrt clock */
+	reg->custom.ddrt_clk_reg = ddr_read(CRG_REG_BASE + PERI_CRG_DDRT);
+	/* enable ddrt0 clock */
+	ddr_write(reg->custom.ddrt_clk_reg | (1U << 1), CRG_REG_BASE + PERI_CRG_DDRT);
+	__asm__ __volatile__("nop");
+	/* disable ddrt0 soft reset */
+	ddr_write(ddr_read(CRG_REG_BASE + PERI_CRG_DDRT) & (~(1U << 0)), CRG_REG_BASE + PERI_CRG_DDRT);
+
+	/* disable rdqs anti-aging */
+	reg->custom.phy0_age_compst_en = ddr_read(DDR_REG_BASE_PHY0 + DDR_PHY_PHYRSCTRL);
+	ddr_write((reg->custom.phy0_age_compst_en & 0x7fffffff), DDR_REG_BASE_PHY0 + DDR_PHY_PHYRSCTRL);
+#ifdef DDR_REG_BASE_PHY1
+	reg->custom.phy1_age_compst_en = ddr_read(DDR_REG_BASE_PHY1 + DDR_PHY_PHYRSCTRL);
+	ddr_write((reg->custom.phy1_age_compst_en & 0x7fffffff), DDR_REG_BASE_PHY1 + DDR_PHY_PHYRSCTRL);
+#endif
+}
+
+/**
+ * Restore site after DDR training command execute.
+ * Keep empty when nothing to do.
+ */
+void ddr_cmd_site_restore(void)
+{
+	/* restore ddrt bus path */
+	ddr_write(reg->custom.ive_ddrt_mst_sel, DDR_REG_BASE_SYSCTRL + SYSCTRL_MISC_CTRL4);
+
+	/* restore ddrt clock */
+	ddr_write(reg->custom.ddrt_clk_reg, CRG_REG_BASE + PERI_CRG_DDRT);
+
+	/* restore rdqs anti-aging */
+	ddr_write(reg->custom.phy0_age_compst_en, DDR_REG_BASE_PHY0 + DDR_PHY_PHYRSCTRL);
+#ifdef DDR_REG_BASE_PHY1
+	ddr_write(reg->custom.phy1_age_compst_en, DDR_REG_BASE_PHY1 + DDR_PHY_PHYRSCTRL);
+#endif
+}
+
+void ddr_training_save_reg_custom(void *reg, unsigned int mask) { return; }
+void ddr_training_restore_reg_custom(void *reg) { return; }
+
+/**
+ * DDR clock select.
+ * For ddr osc training.
+ */
+#ifdef DDR_PCODE_TRAINING_CONFIG
+int ddr_get_cksel(void)
+{
+	int freq;
+	unsigned int ddr_cksel;
+	ddr_cksel = (ddr_read(CRG_REG_BASE + PERI_CRG_DDRCKSEL) >> 0x3) & 0x7;
+	switch (ddr_cksel) {
+	case 0x000:
+		/* 24MHz */
+		freq = 24;
+		break;
+	case 0x001:
+		/* 450MHz */
+		freq = 450;
+		break;
+	case 0x011:
+		/* 300MHz */
+		freq = 300;
+		break;
+	case 0x100:
+		/* 297MHz */
+		freq = 297;
+		break;
+	default:
+		freq = 300;
+		break;
+	}
+	return freq;
+}
+#endif
diff -uraN u-boot-2016.11/drivers/ddr/goke/gk7605v100/ddr_training_custom.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/gk7605v100/ddr_training_custom.h
--- u-boot-2016.11/drivers/ddr/goke/gk7605v100/ddr_training_custom.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/gk7605v100/ddr_training_custom.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef DDR_TRAINING_CUSTOM_H
+#define DDR_TRAINING_CUSTOM_H
+
+/* config DDRC, PHY, DDRT typte */
+#define DDR_DDRC_V520_CONFIG
+#define DDR_PHY_T28_CONFIG
+#define DDR_DDRT_V2_0_SHF1_CONFIG
+
+/* config special item */
+#define DDR_VREF_TRAINING_CONFIG
+#define DDR_VREF_WITHOUT_BDL_CONFIG
+//#define DDR_PCODE_TRAINING_CONFIG
+
+#define DDR_WL_TRAINING_DISABLE
+#define DDR_GATE_TRAINING_DISABLE
+#define DDR_TRAINING_UART_DISABLE
+
+/* Disable write dm
+#define DDR_WRITE_DM_DISABLE */
+
+#define DDR_PHY_NUM              1 /* phy number */
+
+#define DDR_DMC_PER_PHY_MAX      2 /* dmc number per phy max */
+
+#define DDR_AXI_SWITCH_NUM       4 /* ddr training axi switch number */
+
+/* config DDRC, PHY, DDRT base address */
+/* [CUSTOM] DDR PHY0 base register */
+#define DDR_REG_BASE_PHY0		0x120dc000
+/* [CUSTOM] DDR PHY1 base register
+#define DDR_REG_BASE_PHY1		0x120de000 */
+/* [CUSTOM] DDR DMC0 base register */
+#define DDR_REG_BASE_DMC0		0x120d8000
+/* [CUSTOM] DDR DMC1 base register */
+#define DDR_REG_BASE_DMC1		0x120d8000
+
+#ifdef DDR_REG_BASE_PHY1
+/* [CUSTOM] DDR DMC2 base register */
+#define DDR_REG_BASE_DMC2		0x120d9000
+/* [CUSTOM] DDR DMC3 base register */
+#define DDR_REG_BASE_DMC3		0x120d9000
+#endif
+
+/* [CUSTOM] DDR DDRT base register */
+#define DDR_REG_BASE_DDRT		0x11330000
+/* [CUSTOM] DDR training item system control */
+#define DDR_REG_BASE_SYSCTRL		0x12020000
+#define DDR_REG_BASE_AXI		0x120d0000
+/* Serial Configuration */
+#define DDR_REG_BASE_UART0		0x12040000
+
+/* config offset address */
+/* Assume sysctrl offset address for DDR training as follows,
+if not please define. */
+/* [CUSTOM] ddrt reversed data */
+#define SYSCTRL_DDRT_PATTERN			0xa8
+/* [CUSTOM] PHY2 ddrt reversed data
+#define SYSCTRL_DDRT_PATTERN_SEC		0xac */
+/* [CUSTOM] ddr training item */
+#define SYSCTRL_DDR_TRAINING_CFG		0xa0
+#define SYSCTRL_DDR_TRAINING_CFG_SEC		0xa4
+/* [CUSTOM] ddr training version flag */
+#define SYSCTRL_DDR_TRAINING_VERSION_FLAG	0xb4
+/* [CUSTOM] ddr training stat */
+#define SYSCTRL_DDR_TRAINING_STAT		0xb0
+
+/* [CUSTOM] ddr hw training item */
+#define SYSCTRL_DDR_HW_PHY0_RANK0		0x90
+#define SYSCTRL_DDR_HW_PHY0_RANK1		0x94
+#if 0
+/* PHY1 hw training item */
+#define SYSCTRL_DDR_HW_PHY1_RANK0		0x98
+#define SYSCTRL_DDR_HW_PHY1_RANK1		0x9c
+#endif
+
+/* config other special */
+/* [CUSTOM] DDR training start address. MEM_BASE_DDR */
+#define DDRT_CFG_BASE_ADDR		0x40000000
+/* [CUSTOM] SRAM start address.
+NOTE: Makefile will parse it, plase define it as Hex. eg: 0xFFFF0C00 */
+#define DDR_TRAINING_RUN_STACK		0x04010c00
+
+#define DDR_RELATE_REG_DECLARE
+#define DDR_TRAINING_SAVE_REG_FUNC(relate_reg, mask) \
+	ddr_training_save_reg_custom(relate_reg, mask)
+
+#define DDR_TRAINING_RESTORE_REG_FUNC(relate_reg) \
+	ddr_training_restore_reg_custom(relate_reg)
+
+struct tr_custom_reg {
+	unsigned int ive_ddrt_mst_sel;
+	unsigned int ddrt_clk_reg;
+	unsigned int phy0_age_compst_en;
+	unsigned int phy1_age_compst_en;
+};
+void ddr_training_save_reg_custom(void *relate_reg, unsigned int mask);
+void ddr_training_restore_reg_custom(void *relate_reg);
+int ddr_get_cksel(void);
+#endif /* DDR_TRAINING_CUSTOM_H */
diff -uraN u-boot-2016.11/drivers/ddr/goke/gk7605v100/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/gk7605v100/Makefile
--- u-boot-2016.11/drivers/ddr/goke/gk7605v100/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/ddr/goke/gk7605v100/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,4 @@
+ccflags-y += -Idrivers/ddr/goke/default -Idrivers/ddr/goke/$(SOC)
+obj-y += ddr_training_custom.o
+
+obj-y += ../default/
diff -uraN u-boot-2016.11/drivers/Kconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/Kconfig
--- u-boot-2016.11/drivers/Kconfig	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/Kconfig	2021-06-07 13:01:32.000000000 +0300
@@ -50,6 +50,8 @@
 
 source "drivers/phy/marvell/Kconfig"
 
+source "drivers/phy/goke/Kconfig"
+
 source "drivers/pinctrl/Kconfig"
 
 source "drivers/power/Kconfig"
diff -uraN u-boot-2016.11/drivers/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/Makefile
--- u-boot-2016.11/drivers/Makefile	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -56,7 +56,7 @@
 endif
 
 ifeq ($(CONFIG_SPL_BUILD)$(CONFIG_TPL_BUILD),)
-
+ifndef CONFIG_MINI_BOOT
 obj-y += adc/
 obj-$(CONFIG_DM_DEMO) += demo/
 obj-$(CONFIG_BIOSEMU) += bios_emulator/
@@ -71,6 +71,7 @@
 obj-y += dfu/
 obj-$(CONFIG_X86) += pch/
 obj-y += phy/marvell/
+obj-y += phy/goke/
 obj-y += rtc/
 obj-y += sound/
 obj-y += spmi/
@@ -94,3 +95,4 @@
 
 obj-$(CONFIG_MACH_PIC32) += ddr/microchip/
 endif
+endif
diff -uraN u-boot-2016.11/drivers/mmc/bsp_sdhci.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mmc/bsp_sdhci.c
--- u-boot-2016.11/drivers/mmc/bsp_sdhci.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mmc/bsp_sdhci.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,402 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+static void bsp_enable_card_clk(struct sdhci_host *host)
+{
+	u16 clk;
+
+	clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
+	clk |= SDHCI_CLOCK_CARD_EN;
+	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
+}
+
+static void bsp_disable_card_clk(struct sdhci_host *host)
+{
+	u16 clk;
+
+	clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
+	clk &= ~SDHCI_CLOCK_CARD_EN;
+	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
+}
+
+static void bsp_enable_internal_clk(struct sdhci_host *host)
+{
+	u16 clk;
+	u16 timeout = 20;
+
+	clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
+	clk |= SDHCI_CLOCK_INT_EN | SDHCI_CLOCK_PLL_EN;
+	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
+
+	/* Wait max 20 ms */
+	clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
+	while (!(clk & SDHCI_CLOCK_INT_STABLE)) {
+		if (timeout == 0) {
+			printf("%s: Internal clock never stabilised.\n",
+					__func__);
+			return;
+		}
+		timeout--;
+		udelay(1000); /* delay 1000us */
+		clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
+	}
+}
+
+static void __maybe_unused bsp_disable_internal_clk(struct sdhci_host *host)
+{
+	u16 clk;
+
+	clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
+	clk &= ~SDHCI_CLOCK_INT_EN;
+	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
+}
+
+static void bsp_set_drv_phase(struct sdhci_host *host, unsigned int phase)
+{
+	uintptr_t crg_addr;
+	unsigned int reg;
+
+	crg_addr = host->type == MMC_TYPE_MMC ?
+		REG_EMMC_DRV_DLL_CTRL : REG_SDIO0_DRV_DLL_CTRL;
+	reg = readl(crg_addr);
+	reg &= ~SDIO_DRV_PHASE_SEL_MASK;
+	reg |= sdio_drv_sel(phase);
+	writel(reg, crg_addr);
+}
+
+static void bsp_enable_sample(struct sdhci_host *host)
+{
+	unsigned int reg;
+
+	reg = sdhci_readl(host, SDHCI_AT_CTRL);
+	reg |= SDHCI_SAMPLE_EN;
+	sdhci_writel(host, reg, SDHCI_AT_CTRL);
+}
+
+static void bsp_set_sampl_phase(struct sdhci_host *host, unsigned int phase)
+{
+	unsigned int reg;
+
+	reg = sdhci_readl(host, SDHCI_AT_STAT);
+	reg &= ~SDHCI_PHASE_SEL_MASK;
+	reg |= phase;
+	sdhci_writel(host, reg, SDHCI_AT_STAT);
+}
+
+static void bsp_wait_sampl_dll_slave_ready(struct sdhci_host *host)
+{
+	unsigned int reg;
+	unsigned int timeout = 20;
+	uintptr_t reg_addr;
+
+	reg_addr = host->type == MMC_TYPE_MMC ?
+		REG_EMMC_SAMPL_DLL_STATUS : REG_SDIO0_SAMPL_DLL_STATUS;
+	do {
+		reg = readl(reg_addr);
+		if (reg & SDIO_SAMPL_DLL_SLAVE_READY)
+			return;
+
+		udelay(1000); /* delay 1000us */
+		timeout--;
+	} while (timeout > 0);
+
+	printf("sdhci: SAMPL DLL slave not ready.\n");
+}
+
+static void bsp_enable_edge_tuning(struct sdhci_host *host)
+{
+	unsigned int reg;
+
+	reg = readl(REG_EMMC_SAMPLB_DLL_CTRL);
+	reg &= ~SDIO_SAMPLB_DLL_CLK_MASK;
+	reg |= sdio_samplb_sel(8); /* sel 8 */
+	writel(reg, REG_EMMC_SAMPLB_DLL_CTRL);
+
+	reg = sdhci_readl(host, SDHCI_MULTI_CYCLE);
+	reg |= SDHCI_EDGE_DETECT_EN;
+	sdhci_writel(host, reg, SDHCI_MULTI_CYCLE);
+}
+
+static void bsp_disable_edge_tuning(struct sdhci_host *host)
+{
+	unsigned int reg;
+
+	reg = sdhci_readl(host, SDHCI_MULTI_CYCLE);
+	reg &= ~SDHCI_EDGE_DETECT_EN;
+	sdhci_writel(host, reg, SDHCI_MULTI_CYCLE);
+}
+
+static void bsp_select_sampl_phase(struct sdhci_host *host, unsigned int phase)
+{
+	bsp_disable_card_clk(host);
+	bsp_set_sampl_phase(host, phase);
+	bsp_wait_sampl_dll_slave_ready(host);
+	bsp_enable_card_clk(host);
+	udelay(1);
+}
+
+static int bsp_send_tuning(struct sdhci_host *host, u32 opcode)
+{
+	int count, err;
+	const int tuning_num = 1;
+
+	count = 0;
+	do {
+		err = mmc_send_tuning(host->mmc, opcode);
+		if (err)
+			break;
+
+		count++;
+	} while (count < tuning_num);
+
+	return err;
+}
+
+static int bsp_mmc_exec_tuning(struct sdhci_host *host, unsigned int opcode)
+{
+	unsigned int index, val;
+	unsigned int edge_p2f, edge_f2p, start, end, phase;
+	unsigned int fall, rise, fall_updat_flag;
+	unsigned int found;
+	unsigned int prev_found = 0;
+	int err;
+	int prev_err = 0;
+	unsigned short ctrl;
+
+	bsp_wait_drv_dll_lock(host);
+	bsp_enable_sampl_dll_slave(host);
+	bsp_enable_sample(host);
+	bsp_enable_edge_tuning(host);
+	host->is_tuning = 1;
+
+	start = 0;
+	end = PHASE_SCALE / EDGE_TUNING_PHASE_STEP;
+
+	edge_p2f = start;
+	edge_f2p = end;
+	for (index = 0; index <= end; index++) {
+		bsp_select_sampl_phase(host, index * EDGE_TUNING_PHASE_STEP);
+
+		err = mmc_send_tuning(host->mmc, opcode);
+		if (!err) {
+			val = sdhci_readl(host, SDHCI_MULTI_CYCLE);
+			found = val & SDHCI_FOUND_EDGE;
+		} else {
+			found = 1;
+		}
+
+		if (prev_found && !found)
+			edge_f2p = index;
+		else if (!prev_found && found)
+			edge_p2f = index;
+
+		if ((edge_p2f != start) && (edge_f2p != end))
+			break;
+
+		prev_found = found;
+	}
+
+	if ((edge_p2f == start) && (edge_f2p == end)) {
+		printf("sdhci: tuning failed! can not found edge!\n");
+		return -1;
+	}
+
+	bsp_disable_edge_tuning(host);
+
+	start = edge_p2f * EDGE_TUNING_PHASE_STEP;
+	end = edge_f2p * EDGE_TUNING_PHASE_STEP;
+	if (end <= start)
+		end += PHASE_SCALE;
+
+	fall = start;
+	rise = end;
+	fall_updat_flag = 0;
+	for (index = start; index <= end; index++) {
+		bsp_select_sampl_phase(host, index % PHASE_SCALE);
+
+		err = bsp_send_tuning(host, opcode);
+		if (err)
+			debug("sdhci: send tuning CMD%u fail! phase:%u err:%d\n",
+				opcode, index, err);
+
+		if (err && index == start) {
+			if (!fall_updat_flag) {
+				fall_updat_flag = 1;
+				fall = start;
+			}
+		} else {
+			if (!prev_err && err) {
+				if (!fall_updat_flag) {
+					fall_updat_flag = 1;
+					fall = index;
+				}
+			}
+		}
+
+		if (prev_err && !err)
+			rise = index;
+
+		if (err && index == end)
+			rise = end;
+
+		prev_err = err;
+	}
+
+	phase = ((fall + rise) / 2 + PHASE_SCALE / 2) % PHASE_SCALE; /* 2 for cal average */
+
+	printf("sdhci: tuning done! valid phase shift [%u, %u] Final Phase:%u\n",
+			rise % PHASE_SCALE, fall % PHASE_SCALE, phase);
+
+	host->tuning_phase = phase;
+	bsp_select_sampl_phase(host, phase);
+
+	ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	ctrl |= SDHCI_CTRL_TUNED_CLK;
+	sdhci_writew(host, ctrl, SDHCI_HOST_CONTROL2);
+	host->is_tuning = 0;
+
+	return 0;
+}
+
+void sdhci_set_host_caps(struct sdhci_host *host)
+{
+	host->host_caps = MMC_MODE_HS | MMC_MODE_HS_52MHz |
+			  MMC_MODE_HS200_1_8V | MMC_MODE_4BIT;
+
+#if !(defined(CONFIG_TARGET_GK7205V200) || defined(CONFIG_TARGET_GK7202V300))
+	host->host_caps |= MMC_MODE_HS400ES | MMC_MODE_HS400_1_8V |
+			   MMC_MODE_8BIT;
+#endif
+}
+
+int sdhci_add_port(int index, uintptr_t regbase, u32 type)
+{
+	struct sdhci_host *host = NULL;
+
+	if (type == MMC_TYPE_MMC)
+		emmc_hardware_init();
+	else
+		sd_hardware_init();
+
+	host = calloc(1, sizeof(struct sdhci_host));
+	if (host == NULL) {
+		puts("sdhci_host malloc fail!\n");
+		return -ENOMEM;
+	}
+
+	host->name = "sdhci";
+	host->index = index;
+	host->type = type;
+	host->ioaddr = (void *)regbase;
+	host->quirks = 0;
+	host->set_clock = bsp_mmc_set_clk;
+	host->priv_init = bsp_mmc_priv_init;
+	host->set_control_reg = bsp_mmc_set_ioconfig;
+	host->execute_tuning = bsp_mmc_exec_tuning;
+	sdhci_set_host_caps(host);
+#ifdef CONFIG_SDHCI_ADMA
+	host->max_segs = 512; /* max seg 512 */
+	host->max_seg_size = 65536; /* max seg size 65536 */
+#if CONFIG_PHYS_64BIT
+	host->desc_sz = sizeof(struct sdhci_adma2_64_desc);
+#else
+	host->desc_sz = sizeof(struct sdhci_adma2_32_desc);
+#endif
+	host->adma_table_sz = (host->max_segs + 2) * host->desc_sz; /* adma tables need 2 extra desc */
+	host->adma_table = malloc(ALIGN(host->adma_table_sz, CONFIG_SYS_CACHELINE_SIZE));
+	if (!host->adma_table) {
+		puts("adma table malloc fail!\n");
+		free(host);
+		return -ENOMEM;
+	}
+	host->adma_table += CONFIG_SYS_CACHELINE_SIZE -
+			    ((uintptr_t)host->adma_table &
+			    (CONFIG_SYS_CACHELINE_SIZE - 1));
+#endif
+	add_sdhci(host, CONFIG_GK_SDHCI_MAX_FREQ, MIN_FREQ);
+	return 0;
+}
+
+void sdhci_hs400_enhanced_stobe(struct mmc *mmc, bool enable)
+{
+	struct sdhci_host *host = mmc->priv;
+	u32 ctrl;
+
+	ctrl = sdhci_readl(host, SDHCI_EMMC_CTRL);
+	if (enable)
+		ctrl |= SDHCI_ENH_STROBE_EN;
+	else
+		ctrl &= ~SDHCI_ENH_STROBE_EN;
+
+	sdhci_writel(host, ctrl, SDHCI_EMMC_CTRL);
+
+#if defined(CONFIG_TARGET_GK7605V100) || defined(CONFIG_TARGET_GK7205V300)
+	ctrl  = sdhci_readl(host, SDHCI_MULTI_CYCLE);
+	if (enable)
+		ctrl |= SDHCI_CMD_DLY_EN;
+	else
+		ctrl &= ~SDHCI_CMD_DLY_EN;
+
+	sdhci_writel(host, ctrl, SDHCI_MULTI_CYCLE);
+#endif
+}
+
+static void print_mmcinfo(struct mmc *mmc)
+{
+	printf("MMC/SD Card:\n");
+	printf("    MID:         0x%x\n", mmc->cid[0] >> 24); /* bit24 - 31 */
+	printf("    Read Block:  %d Bytes\n", mmc->read_bl_len);
+	printf("    Write Block: %d Bytes\n", mmc->write_bl_len);
+	printf("    Chip Size:   %s Bytes (%s)\n",
+			ultohstr(mmc->capacity),
+			mmc->high_capacity ? "High Capacity" : "Low Capacity");
+	printf("    Name:        \"%c%c%c%c%c\"\n",
+			mmc->cid[0] & 0xff,           /* bit0   -  7 */
+			(mmc->cid[1] >> 24),          /* bit24 - 32 */
+			(mmc->cid[1] >> 16) & 0xff,   /* bit16 - 23 */
+			(mmc->cid[1] >> 8) & 0xff,    /* bit8   - 15 */
+			mmc->cid[1] & 0xff);          /* bit0   -  7 */
+
+	printf("    Chip Type:   %s\n"
+			"    Version:     %d.%d\n",
+			IS_SD(mmc) ? "SD" : "MMC",
+			EXTRACT_SDMMC_MAJOR_VERSION(mmc->version),
+			EXTRACT_SDMMC_MINOR_VERSION(mmc->version));
+
+	printf("    Speed:       %sHz\n", ultohstr(mmc->clock));
+	printf("    Bus Width:   %dbit\n", mmc->bus_width);
+	printf("    Mode:        %s\n", mmc->strobe_enhanced ? "HS400ES" :
+			mmc->timing == MMC_TIMING_MMC_HS400 ? "HS400" :
+			mmc->timing == MMC_TIMING_MMC_HS200 ? "HS200" : "HS");
+}
+
+int bsp_mmc_init(int dev_num)
+{
+	struct mmc *mmc = find_mmc_device(dev_num);
+	int ret;
+
+	if (mmc == NULL) {
+		printf("mmc device not found!!\n");
+		return -EINVAL;
+	}
+
+	ret = mmc_init(mmc);
+	if (ret)
+		return ret;
+
+	if (!IS_SD(mmc)) {
+		print_mmcinfo(mmc);
+		return mmc_set_boot_config(mmc);
+	}
+
+	return 0;
+}
+
+void printf_mmc(int dev_num)
+{
+	struct mmc *mmc = find_mmc_device(dev_num);
+
+	if (mmc != NULL)
+		print_mmcinfo(mmc);
+}
diff -uraN u-boot-2016.11/drivers/mmc/gk7202v300.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mmc/gk7202v300.c
--- u-boot-2016.11/drivers/mmc/gk7202v300.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mmc/gk7202v300.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,437 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <asm/arch-gk7202v300/platform.h>
+#include <common.h>
+#include <malloc.h>
+#include <sdhci.h>
+#include "mmc_private.h"
+
+#ifdef CONFIG_GK_SDHCI
+#define MIN_FREQ	400000
+#define NOT_FOUND	(-1)
+#define PHASE_SCALE	32
+#define EDGE_TUNING_PHASE_STEP	4
+
+#define SDIO_DRV_DLL_SRST_REQ		(0x1 << 29)
+#define SDIO_CLK_EN			(0x1 << 28)
+#define SDIO_SRST_REQ			(0x1 << 27)
+#define SDIO_CLK_SEL			(0x7 << 24)
+#define SDIO_CLK_SEL_400K		(0x1 << 24)
+
+#define REG_EMMC_DRV_DLL_STATUS		(CRG_REG_BASE + 0x210)
+#define REG_SDIO0_DRV_DLL_STATUS	REG_EMMC_DRV_DLL_STATUS
+#define REG_SDIO1_DRV_DLL_STATUS	(CRG_REG_BASE + 0x228)
+#define SDIO_DRV_DLL_LOCK		BIT(15)
+#define SDIO_DRV_DLL_READY		BIT(14)
+
+#define REG_EMMC_SAMPL_DLL_STATUS	(CRG_REG_BASE + 0x208)
+#define REG_SDIO0_SAMPL_DLL_STATUS	REG_EMMC_SAMPL_DLL_STATUS
+#define REG_SDIO1_SAMPL_DLL_STATUS	(CRG_REG_BASE + 0x224)
+#define SDIO_SAMPL_DLL_SLAVE_READY	BIT(0)
+
+#define REG_EMMC_SAMPL_DLL_CTRL		(CRG_REG_BASE + 0x1f4)
+#define REG_SDIO0_SAMPL_DLL_CTRL	REG_EMMC_SAMPL_DLL_CTRL
+#define REG_SDIO1_SAMPL_DLL_CTRL	(CRG_REG_BASE + 0x22c)
+#define SDIO_SAMPL_DLL_SLAVE_EN		BIT(16)
+
+#define REG_EMMC_SAMPLB_DLL_CTRL	(CRG_REG_BASE + 0x1f8)
+#define REG_SDIO0_SAMPLB_DLL_CTRL	REG_EMMC_SAMPLB_DLL_CTRL
+#define REG_SDIO1_SAMPLB_DLL_CTRL	(CRG_REG_BASE + 0x21c)
+#define SDIO_SAMPLB_DLL_CLK_MASK	(0x1f << 0)
+#define sdio_samplb_sel(phase)		((phase) << 0)
+
+#define REG_EMMC_DRV_DLL_CTRL		(CRG_REG_BASE + 0x1fc)
+#define REG_SDIO0_DRV_DLL_CTRL		REG_EMMC_DRV_DLL_CTRL
+#define REG_SDIO1_DRV_DLL_CTRL		(CRG_REG_BASE + 0x220)
+#define SDIO_DRV_PHASE_SEL_MASK		(0x1f << 24)
+#define sdio_drv_sel(phase)		((phase) << 24)
+
+#define REG_EMMC_DS_DLL_CTRL		(CRG_REG_BASE + 0x200)
+#define EMMC_DS_DLL_MODE_SSEL		BIT(13)
+#define EMMC_DS_DLL_SSEL_MASK		0x7f
+
+#define REG_EMMC_DS180_DLL_CTRL		(CRG_REG_BASE + 0x204)
+#define EMMC_DS180_DLL_BYPASS		BIT(15)
+#define REG_EMMC_DS180_DLL_STATUS	(CRG_REG_BASE + 0x218)
+#define EMMC_DS180_DLL_READY		BIT(0)
+
+#define IO_CFG_SR			BIT(10)
+#define IO_CFG_PULL_DOWN		BIT(9)
+#define IO_CFG_PULL_UP			BIT(8)
+#define IO_CFG_DRV_STR_MASK		(0xf << 4)
+#define io_cfg_drv_str_sel(str)		((str) << 4)
+
+#define REG_IO_CFG_BASE			0x100C0000
+/* EMMC_IOCFG */
+#define IO_CFG_EMMC_DATA_LINE_COUNT	4
+#define REG_CTRL_EMMC_CLK		0x0014
+#define REG_CTRL_EMMC_CMD		0x0018
+#define REG_CTRL_EMMC_DATA0		0x001c
+#define REG_CTRL_EMMC_DATA1		0x0028
+#define REG_CTRL_EMMC_DATA2		0x0024
+#define REG_CTRL_EMMC_DATA3		0x0020
+#define REG_CTRL_EMMC_DS		0x0058
+#define REG_CTRL_EMMC_RST		0x005c
+static unsigned int io_emmc_data_reg[IO_CFG_EMMC_DATA_LINE_COUNT] = {
+	REG_CTRL_EMMC_DATA0, REG_CTRL_EMMC_DATA1,
+	REG_CTRL_EMMC_DATA2, REG_CTRL_EMMC_DATA3
+};
+
+#define IO_CFG_SDIO0_DATA_LINE_COUNT	4
+#define REG_CTRL_SDIO0_CLK		0x0040
+#define REG_CTRL_SDIO0_CMD		0x0044
+#define REG_CTRL_SDIO0_DATA0		0x0048
+#define REG_CTRL_SDIO0_DATA1		0x004C
+#define REG_CTRL_SDIO0_DATA2		0x0050
+#define REG_CTRL_SDIO0_DATA3		0x0054
+static unsigned int io_sdio0_data_reg[IO_CFG_SDIO0_DATA_LINE_COUNT] = {
+	REG_CTRL_SDIO0_DATA0, REG_CTRL_SDIO0_DATA1,
+	REG_CTRL_SDIO0_DATA2, REG_CTRL_SDIO0_DATA3
+};
+
+#define CLK_100K	100000
+#define CLK_400K	400000
+#define CLK_25M		25000000
+#define CLK_50M		50000000
+#define CLK_90M		90000000
+#define CLK_112M	112000000
+#define CLK_150M	150000000
+#define CLK_198M	198000000
+
+static void bsp_enable_sample(struct sdhci_host *host);
+static void bsp_set_drv_phase(struct sdhci_host *host,	unsigned int phase);
+static void bsp_set_sampl_phase(struct sdhci_host *host, unsigned int phase);
+static void bsp_wait_sampl_dll_slave_ready(struct sdhci_host *host);
+static void bsp_enable_card_clk(struct sdhci_host *host);
+static void bsp_disable_card_clk(struct sdhci_host *host);
+static void bsp_enable_internal_clk(struct sdhci_host *host);
+static void bsp_disable_internal_clk(struct sdhci_host *host);
+static int bsp_mmc_exec_tuning(struct sdhci_host *host, unsigned int opcode);
+
+static void bsp_dll_reset_assert(struct sdhci_host *host)
+{
+	uintptr_t crg_addr;
+	unsigned int reg;
+
+	crg_addr = REG_EMMC_CRG;
+	reg = readl(crg_addr);
+	reg |= SDIO_DRV_DLL_SRST_REQ;
+	writel(reg, crg_addr);
+}
+
+static void bsp_dll_reset_deassert(struct sdhci_host *host)
+{
+	uintptr_t crg_addr;
+	unsigned int reg;
+
+	crg_addr = REG_EMMC_CRG;
+	reg = readl(crg_addr);
+	reg &= ~SDIO_DRV_DLL_SRST_REQ;
+	writel(reg, crg_addr);
+}
+
+static void bsp_set_crg(struct sdhci_host *host, unsigned int clk)
+{
+	uintptr_t crg_addr;
+	unsigned int sel, reg;
+	unsigned int clk_mux[] = {
+		CLK_100K, CLK_400K, CLK_25M, CLK_50M,
+		CLK_90M, CLK_112M, CLK_150M, CLK_198M
+	};
+
+	crg_addr = REG_EMMC_CRG;
+	reg = readl(crg_addr);
+	reg &= ~MMC_CLK_SEL_MASK;
+
+	if (clk <= MIN_FREQ) {
+		sel = 1;
+	} else {
+		for (sel = 0x6; sel > 0; sel--) {
+			if (clk >= clk_mux[sel])
+				break;
+		}
+	}
+
+	reg |= mmc_clk_sel(sel);
+	writel(reg, crg_addr);
+}
+
+static void bsp_wait_ds180_dll_ready(void)
+{
+	unsigned int reg;
+	unsigned int timeout = 20;
+
+	do {
+		reg = readl(REG_EMMC_DS180_DLL_STATUS);
+		if (reg & EMMC_DS180_DLL_READY)
+			return;
+
+		udelay(1000); /* delay 1000us */
+		timeout--;
+	} while (timeout > 0);
+
+	printf("DS180 DLL master not ready.\n");
+}
+
+static void bsp_mmc_priv_init(struct sdhci_host *host)
+{
+	unsigned short ctrl;
+	unsigned int reg;
+
+	ctrl = sdhci_readw(host, SDHCI_MSHC_CTRL);
+	ctrl &= ~SDHCI_CMD_CONFLIT_CHECK;
+	sdhci_writew(host, ctrl, SDHCI_MSHC_CTRL);
+
+	reg = sdhci_readl(host, SDHCI_AXI_MBIIU_CTRL);
+	reg |= SDHCI_GM_WR_OSRC_LMT | SDHCI_GM_RD_OSRC_LMT;
+	reg &= ~SDHCI_UNDEFL_INCR_EN;
+	sdhci_writel(host, reg, SDHCI_AXI_MBIIU_CTRL);
+
+	reg  = sdhci_readl(host, SDHCI_MULTI_CYCLE);
+	reg &= ~SDHCI_CMD_DLY_EN;
+	reg |= SDHCI_EDGE_DETECT_EN | SDHCI_DATA_DLY_EN;
+	sdhci_writel(host, reg, SDHCI_MULTI_CYCLE);
+}
+
+static void bsp_set_drv_str(unsigned int offset, unsigned int pull_up,
+				unsigned int pull_down, unsigned int sr,
+				unsigned int drv_str)
+{
+	unsigned int reg;
+	const uintptr_t crg_addr = REG_IO_CFG_BASE + offset;
+
+	reg = readl(crg_addr);
+	reg &= ~(IO_CFG_PULL_UP | IO_CFG_PULL_DOWN |
+		 IO_CFG_DRV_STR_MASK | IO_CFG_SR);
+	reg |= (pull_up ? IO_CFG_PULL_UP : 0);
+	reg |= (pull_down ? IO_CFG_PULL_DOWN : 0);
+	reg |= (sr ? IO_CFG_SR : 0);
+	reg |= io_cfg_drv_str_sel(drv_str);
+	writel(reg, crg_addr);
+}
+
+static int sd_hardware_init(void)
+{
+	unsigned int reg;
+
+	/* clk enable */
+	reg = readl(REG_EMMC_CRG);
+	reg |= SDIO_CLK_EN;
+	writel(reg, REG_EMMC_CRG);
+
+	/* reset assert */
+	reg = readl(REG_EMMC_CRG);
+	reg |= SDIO_SRST_REQ | SDIO_DRV_DLL_SRST_REQ;
+	writel(reg, REG_EMMC_CRG);
+	udelay(25); /* delay 25us */
+
+	/* reset deassert */
+	reg &= ~SDIO_SRST_REQ;
+	writel(reg, REG_EMMC_CRG);
+	udelay(1); /* delay 1us */
+
+	udelay(5000); /* delay 5000us */
+
+	return 0;
+}
+
+static int emmc_hardware_init(void)
+{
+	unsigned int reg;
+
+	/* eMMC clk enable */
+	reg = readl(REG_EMMC_CRG);
+	reg |= SDIO_CLK_EN;
+	writel(reg, REG_EMMC_CRG);
+
+	/* eMMC reset assert */
+	reg = readl(REG_EMMC_CRG);
+	reg |= SDIO_SRST_REQ | SDIO_DRV_DLL_SRST_REQ;
+	writel(reg, REG_EMMC_CRG);
+	udelay(25); /* delay 25us */
+
+	/* select 400K clk */
+	reg = readl(REG_EMMC_CRG);
+	reg &= ~SDIO_CLK_SEL;
+	reg |= SDIO_CLK_SEL_400K;
+	writel(reg, REG_EMMC_CRG);
+	udelay(25); /* delay 25us */
+
+	/* eMMC reset deassert */
+	reg = readl(REG_EMMC_CRG);
+	reg &= ~SDIO_SRST_REQ;
+	writel(reg, REG_EMMC_CRG);
+	udelay(1); /* delay 1us */
+
+	return 0;
+}
+
+static void bsp_mmc_set_ioconfig(struct sdhci_host *host)
+{
+	unsigned int reg;
+	int i;
+
+	if (host->type == MMC_TYPE_MMC) {
+		reg = sdhci_readw(host, SDHCI_EMMC_CTRL);
+		reg |= SDHCI_CARD_IS_EMMC;
+		sdhci_writew(host, reg, SDHCI_EMMC_CTRL);
+
+		switch (host->mmc->timing) {
+		case MMC_TIMING_MMC_HS400:
+			bsp_set_drv_str(REG_CTRL_EMMC_CLK, 0, 1, 0, 0x3);  /* set drv level 3 */
+			bsp_set_drv_str(REG_CTRL_EMMC_CMD, 1, 0, 0, 0x5);  /* set drv level 5 */
+			for (i = 0; i < IO_CFG_EMMC_DATA_LINE_COUNT; i++)
+				bsp_set_drv_str(
+					io_emmc_data_reg[i], 1, 0, 0, 0x5); /* set drv level 5 */
+
+			bsp_set_drv_str(REG_CTRL_EMMC_DS, 0, 1, 1, 0x3);   /* set drv level 3 */
+			bsp_set_drv_str(REG_CTRL_EMMC_RST, 1, 0, 1, 0x3);  /* set drv level 3 */
+			break;
+		case MMC_TIMING_MMC_HS200:
+			bsp_set_drv_str(REG_CTRL_EMMC_CLK, 0, 1, 0, 0x2);  /* set drv level 2 */
+			bsp_set_drv_str(REG_CTRL_EMMC_CMD, 1, 0, 1, 0x4);  /* set drv level 4 */
+			for (i = 0; i < IO_CFG_EMMC_DATA_LINE_COUNT; i++)
+				bsp_set_drv_str(
+					io_emmc_data_reg[i], 1, 0, 1, 0x4); /* set drv level 4 */
+
+			bsp_set_drv_str(REG_CTRL_EMMC_RST, 1, 0, 1, 0x3);  /* set drv level 3 */
+			break;
+		case MMC_TIMING_MMC_HS:
+			bsp_set_drv_str(REG_CTRL_EMMC_CLK, 0, 1, 1, 0x4);  /* set drv level 4 */
+			bsp_set_drv_str(REG_CTRL_EMMC_CMD, 1, 0, 1, 0x6);  /* set drv level 6 */
+			for (i = 0; i < IO_CFG_EMMC_DATA_LINE_COUNT; i++)
+				bsp_set_drv_str(
+					io_emmc_data_reg[i], 1, 0, 1, 0x6); /* set drv level 6 */
+
+			bsp_set_drv_str(REG_CTRL_EMMC_RST, 1, 0, 1, 0x3);  /* set drv level 3 */
+			break;
+		case MMC_TIMING_LEGACY:
+		case MMC_TIMING_MMC_DDR52:
+		default:
+			bsp_set_drv_str(REG_CTRL_EMMC_CLK, 0, 1, 1, 0x5);  /* set drv level 5 */
+			bsp_set_drv_str(REG_CTRL_EMMC_CMD, 1, 0, 1, 0x6);  /* set drv level 6 */
+			for (i = 0; i < IO_CFG_EMMC_DATA_LINE_COUNT; i++)
+				bsp_set_drv_str(
+					io_emmc_data_reg[i], 1, 0, 1, 0x6); /* set drv level 6 */
+
+			bsp_set_drv_str(REG_CTRL_EMMC_RST, 1, 0, 1, 0x3);  /* set drv level 3 */
+			break;
+		}
+	} else {
+		switch (host->mmc->timing) {
+		case MMC_TIMING_SD_HS:
+			bsp_set_drv_str(REG_CTRL_SDIO0_CLK, 0, 1, 1, 0x5);  /* set drv level 5 */
+			bsp_set_drv_str(REG_CTRL_SDIO0_CMD, 1, 0, 1, 0x7);  /* set drv level 7 */
+			for (i = 0; i < IO_CFG_SDIO0_DATA_LINE_COUNT; i++)
+				bsp_set_drv_str(
+					io_sdio0_data_reg[i], 1, 0, 1, 0x7); /* set drv level 7 */
+			break;
+		case MMC_TIMING_LEGACY:
+		default:
+			bsp_set_drv_str(REG_CTRL_SDIO0_CLK, 0, 1, 1, 0x5);  /* set drv level 5 */
+			bsp_set_drv_str(REG_CTRL_SDIO0_CMD, 1, 0, 1, 0x7);  /* set drv level 7 */
+			for (i = 0; i < IO_CFG_SDIO0_DATA_LINE_COUNT; i++)
+				bsp_set_drv_str(
+					io_sdio0_data_reg[i], 1, 0, 1, 0x7); /* set drv level 7 */
+			break;
+		}
+	}
+}
+
+static void bsp_set_phase(struct sdhci_host *host)
+{
+	unsigned int drv_phase, sample_phase;
+
+	if (host->mmc->timing == MMC_TIMING_MMC_HS400) {
+		drv_phase = 9;   /* 9 for 101.25 degree */
+		sample_phase = host->tuning_phase;
+	} else if (host->mmc->timing == MMC_TIMING_MMC_HS200) {
+		drv_phase = 23;   /* 23 for 258.75 degree */
+		sample_phase = host->tuning_phase;
+	} else if (host->mmc->timing == MMC_TIMING_MMC_HS) {
+		drv_phase = 16;   /* 16 for 180 degree */
+		sample_phase = 4; /* 4 for 45 degree */
+	} else if (host->mmc->timing == MMC_TIMING_SD_HS) {
+		drv_phase = 20;   /* 20 for 225 degree */
+		sample_phase = 4; /* 4 for 45 degree */
+	} else if (host->mmc->timing == MMC_TIMING_MMC_DDR52) {
+		drv_phase = 8;    /* 8 for 90 degree */
+		sample_phase = host->tuning_phase;
+	} else if (host->mmc->timing == MMC_TIMING_LEGACY) {
+		drv_phase = 16;   /* 16 for 180 degree */
+		sample_phase = 0; /* 0 for degree */
+	} else {
+		drv_phase = 16;   /* 16 for 180 degree */
+		sample_phase = 0; /* 0 for degree */
+	}
+
+	bsp_set_drv_phase(host, drv_phase);
+	bsp_enable_sample(host);
+	bsp_set_sampl_phase(host, sample_phase);
+
+	udelay(25); /* delay 25us */
+}
+
+static void bsp_wait_drv_dll_lock(struct sdhci_host *host)
+{
+	unsigned int timeout = 20;
+	unsigned int reg;
+	uintptr_t reg_addr;
+
+	reg_addr = host->type == MMC_TYPE_MMC ?
+		REG_EMMC_DRV_DLL_STATUS : REG_SDIO0_DRV_DLL_STATUS;
+	do {
+		reg = readl(reg_addr);
+		if (reg & SDIO_DRV_DLL_LOCK)
+			return;
+
+		udelay(1000); /* delay 1000us */
+		timeout--;
+	} while (timeout > 0);
+
+	printf("sdhci: DRV DLL master not locked.\n");
+}
+
+static void bsp_enable_sampl_dll_slave(struct sdhci_host *host)
+{
+	unsigned int reg;
+	uintptr_t reg_addr;
+
+	reg_addr = host->type == MMC_TYPE_MMC ?
+		REG_EMMC_SAMPL_DLL_CTRL : REG_SDIO0_SAMPL_DLL_CTRL;
+	reg = readl(reg_addr);
+	reg |= SDIO_SAMPL_DLL_SLAVE_EN;
+	writel(reg, reg_addr);
+}
+
+static int bsp_mmc_set_clk(struct sdhci_host *host, unsigned int clk)
+{
+	bsp_dll_reset_assert(host);
+	udelay(25); /* delay 25us */
+	bsp_set_crg(host, clk);
+	bsp_set_phase(host);
+	udelay(25); /* delay 25us */
+
+	if (clk > MMC_HIGH_52_MAX_DTR) {
+		bsp_enable_sampl_dll_slave(host);
+		bsp_dll_reset_deassert(host);
+	}
+
+	bsp_enable_internal_clk(host);
+
+	if (clk > MMC_HIGH_52_MAX_DTR) {
+		bsp_wait_drv_dll_lock(host);
+		bsp_wait_sampl_dll_slave_ready(host);
+		bsp_wait_ds180_dll_ready();
+	}
+
+	bsp_enable_card_clk(host);
+	udelay(100); /* delay 100us */
+
+	return 0;
+}
+
+#include "bsp_sdhci.c"
+#endif
\ No newline at end of file
diff -uraN u-boot-2016.11/drivers/mmc/gk7205v200.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mmc/gk7205v200.c
--- u-boot-2016.11/drivers/mmc/gk7205v200.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mmc/gk7205v200.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,437 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <asm/arch-gk7205v200/platform.h>
+#include <common.h>
+#include <malloc.h>
+#include <sdhci.h>
+#include "mmc_private.h"
+
+#ifdef CONFIG_GK_SDHCI
+#define MIN_FREQ	400000
+#define NOT_FOUND	(-1)
+#define PHASE_SCALE	32
+#define EDGE_TUNING_PHASE_STEP	4
+
+#define SDIO_DRV_DLL_SRST_REQ		(0x1 << 29)
+#define SDIO_CLK_EN			(0x1 << 28)
+#define SDIO_SRST_REQ			(0x1 << 27)
+#define SDIO_CLK_SEL			(0x7 << 24)
+#define SDIO_CLK_SEL_400K		(0x1 << 24)
+
+#define REG_EMMC_DRV_DLL_STATUS		(CRG_REG_BASE + 0x210)
+#define REG_SDIO0_DRV_DLL_STATUS	REG_EMMC_DRV_DLL_STATUS
+#define REG_SDIO1_DRV_DLL_STATUS	(CRG_REG_BASE + 0x228)
+#define SDIO_DRV_DLL_LOCK		BIT(15)
+#define SDIO_DRV_DLL_READY		BIT(14)
+
+#define REG_EMMC_SAMPL_DLL_STATUS	(CRG_REG_BASE + 0x208)
+#define REG_SDIO0_SAMPL_DLL_STATUS	REG_EMMC_SAMPL_DLL_STATUS
+#define REG_SDIO1_SAMPL_DLL_STATUS	(CRG_REG_BASE + 0x224)
+#define SDIO_SAMPL_DLL_SLAVE_READY	BIT(0)
+
+#define REG_EMMC_SAMPL_DLL_CTRL		(CRG_REG_BASE + 0x1f4)
+#define REG_SDIO0_SAMPL_DLL_CTRL	REG_EMMC_SAMPL_DLL_CTRL
+#define REG_SDIO1_SAMPL_DLL_CTRL	(CRG_REG_BASE + 0x22c)
+#define SDIO_SAMPL_DLL_SLAVE_EN		BIT(16)
+
+#define REG_EMMC_SAMPLB_DLL_CTRL	(CRG_REG_BASE + 0x1f8)
+#define REG_SDIO0_SAMPLB_DLL_CTRL	REG_EMMC_SAMPLB_DLL_CTRL
+#define REG_SDIO1_SAMPLB_DLL_CTRL	(CRG_REG_BASE + 0x21c)
+#define SDIO_SAMPLB_DLL_CLK_MASK	(0x1f << 0)
+#define sdio_samplb_sel(phase)		((phase) << 0)
+
+#define REG_EMMC_DRV_DLL_CTRL		(CRG_REG_BASE + 0x1fc)
+#define REG_SDIO0_DRV_DLL_CTRL		REG_EMMC_DRV_DLL_CTRL
+#define REG_SDIO1_DRV_DLL_CTRL		(CRG_REG_BASE + 0x220)
+#define SDIO_DRV_PHASE_SEL_MASK		(0x1f << 24)
+#define sdio_drv_sel(phase)		((phase) << 24)
+
+#define REG_EMMC_DS_DLL_CTRL		(CRG_REG_BASE + 0x200)
+#define EMMC_DS_DLL_MODE_SSEL		BIT(13)
+#define EMMC_DS_DLL_SSEL_MASK		0x7f
+
+#define REG_EMMC_DS180_DLL_CTRL		(CRG_REG_BASE + 0x204)
+#define EMMC_DS180_DLL_BYPASS		BIT(15)
+#define REG_EMMC_DS180_DLL_STATUS	(CRG_REG_BASE + 0x218)
+#define EMMC_DS180_DLL_READY		BIT(0)
+
+#define IO_CFG_SR			BIT(10)
+#define IO_CFG_PULL_DOWN		BIT(9)
+#define IO_CFG_PULL_UP			BIT(8)
+#define IO_CFG_DRV_STR_MASK		(0xf << 4)
+#define io_cfg_drv_str_sel(str)		((str) << 4)
+
+#define REG_IO_CFG_BASE			0x100C0000
+/* EMMC_IOCFG */
+#define IO_CFG_EMMC_DATA_LINE_COUNT	4
+#define REG_CTRL_EMMC_CLK		0x0014
+#define REG_CTRL_EMMC_CMD		0x0018
+#define REG_CTRL_EMMC_DATA0		0x001c
+#define REG_CTRL_EMMC_DATA1		0x0028
+#define REG_CTRL_EMMC_DATA2		0x0024
+#define REG_CTRL_EMMC_DATA3		0x0020
+#define REG_CTRL_EMMC_DS		0x0058
+#define REG_CTRL_EMMC_RST		0x005c
+static unsigned int io_emmc_data_reg[IO_CFG_EMMC_DATA_LINE_COUNT] = {
+	REG_CTRL_EMMC_DATA0, REG_CTRL_EMMC_DATA1,
+	REG_CTRL_EMMC_DATA2, REG_CTRL_EMMC_DATA3
+};
+
+#define IO_CFG_SDIO0_DATA_LINE_COUNT	4
+#define REG_CTRL_SDIO0_CLK		0x0040
+#define REG_CTRL_SDIO0_CMD		0x0044
+#define REG_CTRL_SDIO0_DATA0		0x0048
+#define REG_CTRL_SDIO0_DATA1		0x004C
+#define REG_CTRL_SDIO0_DATA2		0x0050
+#define REG_CTRL_SDIO0_DATA3		0x0054
+static unsigned int io_sdio0_data_reg[IO_CFG_SDIO0_DATA_LINE_COUNT] = {
+	REG_CTRL_SDIO0_DATA0, REG_CTRL_SDIO0_DATA1,
+	REG_CTRL_SDIO0_DATA2, REG_CTRL_SDIO0_DATA3
+};
+
+#define CLK_100K	100000
+#define CLK_400K	400000
+#define CLK_25M		25000000
+#define CLK_50M		50000000
+#define CLK_90M		90000000
+#define CLK_112M	112000000
+#define CLK_150M	150000000
+#define CLK_198M	198000000
+
+static void bsp_enable_sample(struct sdhci_host *host);
+static void bsp_set_drv_phase(struct sdhci_host *host,	unsigned int phase);
+static void bsp_set_sampl_phase(struct sdhci_host *host, unsigned int phase);
+static void bsp_wait_sampl_dll_slave_ready(struct sdhci_host *host);
+static void bsp_enable_card_clk(struct sdhci_host *host);
+static void bsp_disable_card_clk(struct sdhci_host *host);
+static void bsp_enable_internal_clk(struct sdhci_host *host);
+static void bsp_disable_internal_clk(struct sdhci_host *host);
+static int bsp_mmc_exec_tuning(struct sdhci_host *host, unsigned int opcode);
+
+static void bsp_dll_reset_assert(struct sdhci_host *host)
+{
+	uintptr_t crg_addr;
+	unsigned int reg;
+
+	crg_addr = REG_EMMC_CRG;
+	reg = readl(crg_addr);
+	reg |= SDIO_DRV_DLL_SRST_REQ;
+	writel(reg, crg_addr);
+}
+
+static void bsp_dll_reset_deassert(struct sdhci_host *host)
+{
+	uintptr_t crg_addr;
+	unsigned int reg;
+
+	crg_addr = REG_EMMC_CRG;
+	reg = readl(crg_addr);
+	reg &= ~SDIO_DRV_DLL_SRST_REQ;
+	writel(reg, crg_addr);
+}
+
+static void bsp_set_crg(struct sdhci_host *host, unsigned int clk)
+{
+	uintptr_t crg_addr;
+	unsigned int sel, reg;
+	unsigned int clk_mux[] = {
+		CLK_100K, CLK_400K, CLK_25M, CLK_50M,
+		CLK_90M, CLK_112M, CLK_150M, CLK_198M
+	};
+
+	crg_addr = REG_EMMC_CRG;
+	reg = readl(crg_addr);
+	reg &= ~MMC_CLK_SEL_MASK;
+
+	if (clk <= MIN_FREQ) {
+		sel = 1;
+	} else {
+		for (sel = 0x6; sel > 0; sel--) {
+			if (clk >= clk_mux[sel])
+				break;
+		}
+	}
+
+	reg |= mmc_clk_sel(sel);
+	writel(reg, crg_addr);
+}
+
+static void bsp_wait_ds180_dll_ready(void)
+{
+	unsigned int reg;
+	unsigned int timeout = 20;
+
+	do {
+		reg = readl(REG_EMMC_DS180_DLL_STATUS);
+		if (reg & EMMC_DS180_DLL_READY)
+			return;
+
+		udelay(1000); /* delay 1000us */
+		timeout--;
+	} while (timeout > 0);
+
+	printf("DS180 DLL master not ready.\n");
+}
+
+static void bsp_mmc_priv_init(struct sdhci_host *host)
+{
+	unsigned short ctrl;
+	unsigned int reg;
+
+	ctrl = sdhci_readw(host, SDHCI_MSHC_CTRL);
+	ctrl &= ~SDHCI_CMD_CONFLIT_CHECK;
+	sdhci_writew(host, ctrl, SDHCI_MSHC_CTRL);
+
+	reg = sdhci_readl(host, SDHCI_AXI_MBIIU_CTRL);
+	reg |= SDHCI_GM_WR_OSRC_LMT | SDHCI_GM_RD_OSRC_LMT;
+	reg &= ~SDHCI_UNDEFL_INCR_EN;
+	sdhci_writel(host, reg, SDHCI_AXI_MBIIU_CTRL);
+
+	reg  = sdhci_readl(host, SDHCI_MULTI_CYCLE);
+	reg &= ~SDHCI_CMD_DLY_EN;
+	reg |= SDHCI_EDGE_DETECT_EN | SDHCI_DATA_DLY_EN;
+	sdhci_writel(host, reg, SDHCI_MULTI_CYCLE);
+}
+
+static void bsp_set_drv_str(unsigned int offset, unsigned int pull_up,
+				unsigned int pull_down, unsigned int sr,
+				unsigned int drv_str)
+{
+	unsigned int reg;
+	const uintptr_t crg_addr = REG_IO_CFG_BASE + offset;
+
+	reg = readl(crg_addr);
+	reg &= ~(IO_CFG_PULL_UP | IO_CFG_PULL_DOWN |
+		 IO_CFG_DRV_STR_MASK | IO_CFG_SR);
+	reg |= (pull_up ? IO_CFG_PULL_UP : 0);
+	reg |= (pull_down ? IO_CFG_PULL_DOWN : 0);
+	reg |= (sr ? IO_CFG_SR : 0);
+	reg |= io_cfg_drv_str_sel(drv_str);
+	writel(reg, crg_addr);
+}
+
+static int sd_hardware_init(void)
+{
+	unsigned int reg;
+
+	/* clk enable */
+	reg = readl(REG_EMMC_CRG);
+	reg |= SDIO_CLK_EN;
+	writel(reg, REG_EMMC_CRG);
+
+	/* reset assert */
+	reg = readl(REG_EMMC_CRG);
+	reg |= SDIO_SRST_REQ | SDIO_DRV_DLL_SRST_REQ;
+	writel(reg, REG_EMMC_CRG);
+	udelay(25); /* delay 25us */
+
+	/* reset deassert */
+	reg &= ~SDIO_SRST_REQ;
+	writel(reg, REG_EMMC_CRG);
+	udelay(1); /* delay 1us */
+
+	udelay(5000); /* delay 5000us */
+
+	return 0;
+}
+
+static int emmc_hardware_init(void)
+{
+	unsigned int reg;
+
+	/* eMMC clk enable */
+	reg = readl(REG_EMMC_CRG);
+	reg |= SDIO_CLK_EN;
+	writel(reg, REG_EMMC_CRG);
+
+	/* eMMC reset assert */
+	reg = readl(REG_EMMC_CRG);
+	reg |= SDIO_SRST_REQ | SDIO_DRV_DLL_SRST_REQ;
+	writel(reg, REG_EMMC_CRG);
+	udelay(25); /* delay 25us */
+
+	/* select 400K clk */
+	reg = readl(REG_EMMC_CRG);
+	reg &= ~SDIO_CLK_SEL;
+	reg |= SDIO_CLK_SEL_400K;
+	writel(reg, REG_EMMC_CRG);
+	udelay(25); /* delay 25us */
+
+	/* eMMC reset deassert */
+	reg = readl(REG_EMMC_CRG);
+	reg &= ~SDIO_SRST_REQ;
+	writel(reg, REG_EMMC_CRG);
+	udelay(1); /* delay 1us */
+
+	return 0;
+}
+
+static void bsp_mmc_set_ioconfig(struct sdhci_host *host)
+{
+	unsigned int reg;
+	int i;
+
+	if (host->type == MMC_TYPE_MMC) {
+		reg = sdhci_readw(host, SDHCI_EMMC_CTRL);
+		reg |= SDHCI_CARD_IS_EMMC;
+		sdhci_writew(host, reg, SDHCI_EMMC_CTRL);
+
+		switch (host->mmc->timing) {
+		case MMC_TIMING_MMC_HS400:
+			bsp_set_drv_str(REG_CTRL_EMMC_CLK, 0, 1, 0, 0x3);  /* set drv level 3 */
+			bsp_set_drv_str(REG_CTRL_EMMC_CMD, 1, 0, 0, 0x5);  /* set drv level 5 */
+			for (i = 0; i < IO_CFG_EMMC_DATA_LINE_COUNT; i++)
+				bsp_set_drv_str(
+					io_emmc_data_reg[i], 1, 0, 0, 0x5); /* set drv level 5 */
+
+			bsp_set_drv_str(REG_CTRL_EMMC_DS, 0, 1, 1, 0x3);   /* set drv level 3 */
+			bsp_set_drv_str(REG_CTRL_EMMC_RST, 1, 0, 1, 0x3);  /* set drv level 3 */
+			break;
+		case MMC_TIMING_MMC_HS200:
+			bsp_set_drv_str(REG_CTRL_EMMC_CLK, 0, 1, 0, 0x2);  /* set drv level 2 */
+			bsp_set_drv_str(REG_CTRL_EMMC_CMD, 1, 0, 1, 0x4);  /* set drv level 4 */
+			for (i = 0; i < IO_CFG_EMMC_DATA_LINE_COUNT; i++)
+				bsp_set_drv_str(
+					io_emmc_data_reg[i], 1, 0, 1, 0x4); /* set drv level 4 */
+
+			bsp_set_drv_str(REG_CTRL_EMMC_RST, 1, 0, 1, 0x3);  /* set drv level 3 */
+			break;
+		case MMC_TIMING_MMC_HS:
+			bsp_set_drv_str(REG_CTRL_EMMC_CLK, 0, 1, 1, 0x4);  /* set drv level 4 */
+			bsp_set_drv_str(REG_CTRL_EMMC_CMD, 1, 0, 1, 0x6);  /* set drv level 6 */
+			for (i = 0; i < IO_CFG_EMMC_DATA_LINE_COUNT; i++)
+				bsp_set_drv_str(
+					io_emmc_data_reg[i], 1, 0, 1, 0x6); /* set drv level 6 */
+
+			bsp_set_drv_str(REG_CTRL_EMMC_RST, 1, 0, 1, 0x3);  /* set drv level 3 */
+			break;
+		case MMC_TIMING_LEGACY:
+		case MMC_TIMING_MMC_DDR52:
+		default:
+			bsp_set_drv_str(REG_CTRL_EMMC_CLK, 0, 1, 1, 0x5);  /* set drv level 5 */
+			bsp_set_drv_str(REG_CTRL_EMMC_CMD, 1, 0, 1, 0x6);  /* set drv level 6 */
+			for (i = 0; i < IO_CFG_EMMC_DATA_LINE_COUNT; i++)
+				bsp_set_drv_str(
+					io_emmc_data_reg[i], 1, 0, 1, 0x6); /* set drv level 6 */
+
+			bsp_set_drv_str(REG_CTRL_EMMC_RST, 1, 0, 1, 0x3);  /* set drv level 3 */
+			break;
+		}
+	} else {
+		switch (host->mmc->timing) {
+		case MMC_TIMING_SD_HS:
+			bsp_set_drv_str(REG_CTRL_SDIO0_CLK, 0, 1, 1, 0x5);  /* set drv level 5 */
+			bsp_set_drv_str(REG_CTRL_SDIO0_CMD, 1, 0, 1, 0x7);  /* set drv level 7 */
+			for (i = 0; i < IO_CFG_SDIO0_DATA_LINE_COUNT; i++)
+				bsp_set_drv_str(
+					io_sdio0_data_reg[i], 1, 0, 1, 0x7); /* set drv level 7 */
+			break;
+		case MMC_TIMING_LEGACY:
+		default:
+			bsp_set_drv_str(REG_CTRL_SDIO0_CLK, 0, 1, 1, 0x5);  /* set drv level 5 */
+			bsp_set_drv_str(REG_CTRL_SDIO0_CMD, 1, 0, 1, 0x7);  /* set drv level 7 */
+			for (i = 0; i < IO_CFG_SDIO0_DATA_LINE_COUNT; i++)
+				bsp_set_drv_str(
+					io_sdio0_data_reg[i], 1, 0, 1, 0x7); /* set drv level 7 */
+			break;
+		}
+	}
+}
+
+static void bsp_set_phase(struct sdhci_host *host)
+{
+	unsigned int drv_phase, sample_phase;
+
+	if (host->mmc->timing == MMC_TIMING_MMC_HS400) {
+		drv_phase = 9;   /* 9 for 101.25 degree */
+		sample_phase = host->tuning_phase;
+	} else if (host->mmc->timing == MMC_TIMING_MMC_HS200) {
+		drv_phase = 23;   /* 23 for 258.75 degree */
+		sample_phase = host->tuning_phase;
+	} else if (host->mmc->timing == MMC_TIMING_MMC_HS) {
+		drv_phase = 16;   /* 16 for 180 degree */
+		sample_phase = 4; /* 4 for 45 degree */
+	} else if (host->mmc->timing == MMC_TIMING_SD_HS) {
+		drv_phase = 20;   /* 20 for 225 degree */
+		sample_phase = 4; /* 4 for 45 degree */
+	} else if (host->mmc->timing == MMC_TIMING_MMC_DDR52) {
+		drv_phase = 8;    /* 8 for 90 degree */
+		sample_phase = host->tuning_phase;
+	} else if (host->mmc->timing == MMC_TIMING_LEGACY) {
+		drv_phase = 16;   /* 16 for 180 degree */
+		sample_phase = 0; /* 0 for degree */
+	} else {
+		drv_phase = 16;   /* 16 for 180 degree */
+		sample_phase = 0; /* 0 for degree */
+	}
+
+	bsp_set_drv_phase(host, drv_phase);
+	bsp_enable_sample(host);
+	bsp_set_sampl_phase(host, sample_phase);
+
+	udelay(25); /* delay 25us */
+}
+
+static void bsp_wait_drv_dll_lock(struct sdhci_host *host)
+{
+	unsigned int timeout = 20;
+	unsigned int reg;
+	uintptr_t reg_addr;
+
+	reg_addr = host->type == MMC_TYPE_MMC ?
+		REG_EMMC_DRV_DLL_STATUS : REG_SDIO0_DRV_DLL_STATUS;
+	do {
+		reg = readl(reg_addr);
+		if (reg & SDIO_DRV_DLL_LOCK)
+			return;
+
+		udelay(1000); /* delay 1000us */
+		timeout--;
+	} while (timeout > 0);
+
+	printf("sdhci: DRV DLL master not locked.\n");
+}
+
+static void bsp_enable_sampl_dll_slave(struct sdhci_host *host)
+{
+	unsigned int reg;
+	uintptr_t reg_addr;
+
+	reg_addr = host->type == MMC_TYPE_MMC ?
+		REG_EMMC_SAMPL_DLL_CTRL : REG_SDIO0_SAMPL_DLL_CTRL;
+	reg = readl(reg_addr);
+	reg |= SDIO_SAMPL_DLL_SLAVE_EN;
+	writel(reg, reg_addr);
+}
+
+static int bsp_mmc_set_clk(struct sdhci_host *host, unsigned int clk)
+{
+	bsp_dll_reset_assert(host);
+	udelay(25); /* delay 25us */
+	bsp_set_crg(host, clk);
+	bsp_set_phase(host);
+	udelay(25); /* delay 25us */
+
+	if (clk > MMC_HIGH_52_MAX_DTR) {
+		bsp_enable_sampl_dll_slave(host);
+		bsp_dll_reset_deassert(host);
+	}
+
+	bsp_enable_internal_clk(host);
+
+	if (clk > MMC_HIGH_52_MAX_DTR) {
+		bsp_wait_drv_dll_lock(host);
+		bsp_wait_sampl_dll_slave_ready(host);
+		bsp_wait_ds180_dll_ready();
+	}
+
+	bsp_enable_card_clk(host);
+	udelay(100); /* delay 100us */
+
+	return 0;
+}
+
+#include "bsp_sdhci.c"
+#endif
\ No newline at end of file
diff -uraN u-boot-2016.11/drivers/mmc/gk7205v300.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mmc/gk7205v300.c
--- u-boot-2016.11/drivers/mmc/gk7205v300.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mmc/gk7205v300.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,443 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <asm/arch-gk7205v300/platform.h>
+#include <common.h>
+#include <malloc.h>
+#include <sdhci.h>
+#include "mmc_private.h"
+
+#ifdef CONFIG_GK_SDHCI
+#define MIN_FREQ	400000
+#define NOT_FOUND	(-1)
+#define PHASE_SCALE	32
+#define EDGE_TUNING_PHASE_STEP	4
+
+#define SDIO_DRV_DLL_SRST_REQ		(0x1 << 29)
+#define SDIO_CLK_EN			(0x1 << 28)
+#define SDIO_SRST_REQ			(0x1 << 27)
+#define SDIO_CLK_SEL			(0x7 << 24)
+#define SDIO_CLK_SEL_400K		(0x1 << 24)
+
+#define REG_EMMC_DRV_DLL_STATUS		(CRG_REG_BASE + 0x210)
+#define REG_SDIO0_DRV_DLL_STATUS	REG_EMMC_DRV_DLL_STATUS
+#define REG_SDIO1_DRV_DLL_STATUS	(CRG_REG_BASE + 0x228)
+#define SDIO_DRV_DLL_LOCK		BIT(15)
+#define SDIO_DRV_DLL_READY		BIT(14)
+
+#define REG_EMMC_SAMPL_DLL_STATUS	(CRG_REG_BASE + 0x208)
+#define REG_SDIO0_SAMPL_DLL_STATUS	REG_EMMC_SAMPL_DLL_STATUS
+#define REG_SDIO1_SAMPL_DLL_STATUS	(CRG_REG_BASE + 0x224)
+#define SDIO_SAMPL_DLL_SLAVE_READY	BIT(0)
+
+#define REG_EMMC_SAMPL_DLL_CTRL		(CRG_REG_BASE + 0x1f4)
+#define REG_SDIO0_SAMPL_DLL_CTRL	REG_EMMC_SAMPL_DLL_CTRL
+#define REG_SDIO1_SAMPL_DLL_CTRL	(CRG_REG_BASE + 0x22c)
+#define SDIO_SAMPL_DLL_SLAVE_EN		BIT(16)
+
+#define REG_EMMC_SAMPLB_DLL_CTRL	(CRG_REG_BASE + 0x1f8)
+#define REG_SDIO0_SAMPLB_DLL_CTRL	REG_EMMC_SAMPLB_DLL_CTRL
+#define REG_SDIO1_SAMPLB_DLL_CTRL	(CRG_REG_BASE + 0x21c)
+#define SDIO_SAMPLB_DLL_CLK_MASK	(0x1f << 0)
+#define sdio_samplb_sel(phase)		((phase) << 0)
+
+#define REG_EMMC_DRV_DLL_CTRL		(CRG_REG_BASE + 0x1fc)
+#define REG_SDIO0_DRV_DLL_CTRL		REG_EMMC_DRV_DLL_CTRL
+#define REG_SDIO1_DRV_DLL_CTRL		(CRG_REG_BASE + 0x220)
+#define SDIO_DRV_PHASE_SEL_MASK		(0x1f << 24)
+#define sdio_drv_sel(phase)		((phase) << 24)
+
+#define REG_EMMC_DS_DLL_CTRL		(CRG_REG_BASE + 0x200)
+#define EMMC_DS_DLL_MODE_SSEL		BIT(13)
+#define EMMC_DS_DLL_SSEL_MASK		0x7f
+
+#define REG_EMMC_DS180_DLL_CTRL		(CRG_REG_BASE + 0x204)
+#define EMMC_DS180_DLL_BYPASS		BIT(15)
+#define REG_EMMC_DS180_DLL_STATUS	(CRG_REG_BASE + 0x218)
+#define EMMC_DS180_DLL_READY		BIT(0)
+
+#define IO_CFG_SR			BIT(10)
+#define IO_CFG_PULL_DOWN		BIT(9)
+#define IO_CFG_PULL_UP			BIT(8)
+#define IO_CFG_DRV_STR_MASK		(0xf << 4)
+#define io_cfg_drv_str_sel(str)		((str) << 4)
+
+#define REG_IO_CFG_BASE			0x100C0000
+/* EMMC_IOCFG */
+#define IO_CFG_EMMC_DATA_LINE_COUNT	8
+#define REG_CTRL_EMMC_CLK		0x0014
+#define REG_CTRL_EMMC_CMD		0x0018
+#define REG_CTRL_EMMC_DATA0		0x001c
+#define REG_CTRL_EMMC_DATA1		0x0028
+#define REG_CTRL_EMMC_DATA2		0x0024
+#define REG_CTRL_EMMC_DATA3		0x0020
+#define REG_CTRL_EMMC_DATA4		0x0030
+#define REG_CTRL_EMMC_DATA5		0x0034
+#define REG_CTRL_EMMC_DATA6		0x0038
+#define REG_CTRL_EMMC_DATA7		0x003c
+#define REG_CTRL_EMMC_DS		0x0058
+#define REG_CTRL_EMMC_RST		0x005c
+static unsigned int io_emmc_data_reg[IO_CFG_EMMC_DATA_LINE_COUNT] = {
+	REG_CTRL_EMMC_DATA0, REG_CTRL_EMMC_DATA1,
+	REG_CTRL_EMMC_DATA2, REG_CTRL_EMMC_DATA3,
+	REG_CTRL_EMMC_DATA4, REG_CTRL_EMMC_DATA5,
+	REG_CTRL_EMMC_DATA6, REG_CTRL_EMMC_DATA7
+};
+
+#define IO_CFG_SDIO0_DATA_LINE_COUNT	4
+#define REG_CTRL_SDIO0_CLK		0x0040
+#define REG_CTRL_SDIO0_CMD		0x0044
+#define REG_CTRL_SDIO0_DATA0		0x0048
+#define REG_CTRL_SDIO0_DATA1		0x004C
+#define REG_CTRL_SDIO0_DATA2		0x0050
+#define REG_CTRL_SDIO0_DATA3		0x0054
+static unsigned int io_sdio0_data_reg[IO_CFG_SDIO0_DATA_LINE_COUNT] = {
+	REG_CTRL_SDIO0_DATA0, REG_CTRL_SDIO0_DATA1,
+	REG_CTRL_SDIO0_DATA2, REG_CTRL_SDIO0_DATA3
+};
+
+#define CLK_100K	100000
+#define CLK_400K	400000
+#define CLK_25M		25000000
+#define CLK_50M		50000000
+#define CLK_90M		90000000
+#define CLK_112M	112000000
+#define CLK_150M	150000000
+#define CLK_198M	198000000
+
+static void bsp_enable_sample(struct sdhci_host *host);
+static void bsp_set_drv_phase(struct sdhci_host *host,	unsigned int phase);
+static void bsp_set_sampl_phase(struct sdhci_host *host, unsigned int phase);
+static void bsp_wait_sampl_dll_slave_ready(struct sdhci_host *host);
+static void bsp_enable_card_clk(struct sdhci_host *host);
+static void bsp_disable_card_clk(struct sdhci_host *host);
+static void bsp_enable_internal_clk(struct sdhci_host *host);
+static void bsp_disable_internal_clk(struct sdhci_host *host);
+static int bsp_mmc_exec_tuning(struct sdhci_host *host, unsigned int opcode);
+
+static void bsp_dll_reset_assert(struct sdhci_host *host)
+{
+	uintptr_t crg_addr;
+	unsigned int reg;
+
+	crg_addr = REG_EMMC_CRG;
+	reg = readl(crg_addr);
+	reg |= SDIO_DRV_DLL_SRST_REQ;
+	writel(reg, crg_addr);
+}
+
+static void bsp_dll_reset_deassert(struct sdhci_host *host)
+{
+	uintptr_t crg_addr;
+	unsigned int reg;
+
+	crg_addr = REG_EMMC_CRG;
+	reg = readl(crg_addr);
+	reg &= ~SDIO_DRV_DLL_SRST_REQ;
+	writel(reg, crg_addr);
+}
+
+static void bsp_set_crg(struct sdhci_host *host, unsigned int clk)
+{
+	uintptr_t crg_addr;
+	unsigned int sel, reg;
+	unsigned int clk_mux[] = {
+		CLK_100K, CLK_400K, CLK_25M, CLK_50M,
+		CLK_90M, CLK_112M, CLK_150M, CLK_198M
+	};
+
+	crg_addr = REG_EMMC_CRG;
+	reg = readl(crg_addr);
+	reg &= ~MMC_CLK_SEL_MASK;
+
+	if (clk <= MIN_FREQ) {
+		sel = 1;
+	} else {
+		for (sel = 0x6; sel > 0; sel--) {
+			if (clk >= clk_mux[sel])
+				break;
+		}
+	}
+
+	reg |= mmc_clk_sel(sel);
+	writel(reg, crg_addr);
+}
+
+static void bsp_wait_ds180_dll_ready(void)
+{
+	unsigned int reg;
+	unsigned int timeout = 20;
+
+	do {
+		reg = readl(REG_EMMC_DS180_DLL_STATUS);
+		if (reg & EMMC_DS180_DLL_READY)
+			return;
+
+		udelay(1000); /* delay 1000us */
+		timeout--;
+	} while (timeout > 0);
+
+	printf("DS180 DLL master not ready.\n");
+}
+
+static void bsp_mmc_priv_init(struct sdhci_host *host)
+{
+	unsigned short ctrl;
+	unsigned int reg;
+
+	ctrl = sdhci_readw(host, SDHCI_MSHC_CTRL);
+	ctrl &= ~SDHCI_CMD_CONFLIT_CHECK;
+	sdhci_writew(host, ctrl, SDHCI_MSHC_CTRL);
+
+	reg = sdhci_readl(host, SDHCI_AXI_MBIIU_CTRL);
+	reg |= SDHCI_GM_WR_OSRC_LMT | SDHCI_GM_RD_OSRC_LMT;
+	reg &= ~SDHCI_UNDEFL_INCR_EN;
+	sdhci_writel(host, reg, SDHCI_AXI_MBIIU_CTRL);
+
+	reg  = sdhci_readl(host, SDHCI_MULTI_CYCLE);
+	reg &= ~SDHCI_CMD_DLY_EN;
+	reg |= SDHCI_EDGE_DETECT_EN | SDHCI_DATA_DLY_EN;
+	sdhci_writel(host, reg, SDHCI_MULTI_CYCLE);
+}
+
+static void bsp_set_drv_str(unsigned int offset, unsigned int pull_up,
+				unsigned int pull_down, unsigned int sr,
+				unsigned int drv_str)
+{
+	unsigned int reg;
+	const uintptr_t crg_addr = REG_IO_CFG_BASE + offset;
+
+	reg = readl(crg_addr);
+	reg &= ~(IO_CFG_PULL_UP | IO_CFG_PULL_DOWN |
+		 IO_CFG_DRV_STR_MASK | IO_CFG_SR);
+	reg |= (pull_up ? IO_CFG_PULL_UP : 0);
+	reg |= (pull_down ? IO_CFG_PULL_DOWN : 0);
+	reg |= (sr ? IO_CFG_SR : 0);
+	reg |= io_cfg_drv_str_sel(drv_str);
+	writel(reg, crg_addr);
+}
+
+static int sd_hardware_init(void)
+{
+	unsigned int reg;
+
+	/* clk enable */
+	reg = readl(REG_EMMC_CRG);
+	reg |= SDIO_CLK_EN;
+	writel(reg, REG_EMMC_CRG);
+
+	/* reset assert */
+	reg = readl(REG_EMMC_CRG);
+	reg |= SDIO_SRST_REQ | SDIO_DRV_DLL_SRST_REQ;
+	writel(reg, REG_EMMC_CRG);
+	udelay(25); /* delay 25us */
+
+	/* reset deassert */
+	reg &= ~SDIO_SRST_REQ;
+	writel(reg, REG_EMMC_CRG);
+	udelay(1); /* delay 1us */
+
+	udelay(5000); /* delay 5000us */
+
+	return 0;
+}
+
+static int emmc_hardware_init(void)
+{
+	unsigned int reg;
+
+	/* eMMC clk enable */
+	reg = readl(REG_EMMC_CRG);
+	reg |= SDIO_CLK_EN;
+	writel(reg, REG_EMMC_CRG);
+
+	/* eMMC reset assert */
+	reg = readl(REG_EMMC_CRG);
+	reg |= SDIO_SRST_REQ | SDIO_DRV_DLL_SRST_REQ;
+	writel(reg, REG_EMMC_CRG);
+	udelay(25); /* delay 25us */
+
+	/* select 400K clk */
+	reg = readl(REG_EMMC_CRG);
+	reg &= ~SDIO_CLK_SEL;
+	reg |= SDIO_CLK_SEL_400K;
+	writel(reg, REG_EMMC_CRG);
+	udelay(25); /* delay 25us */
+
+	/* eMMC reset deassert */
+	reg = readl(REG_EMMC_CRG);
+	reg &= ~SDIO_SRST_REQ;
+	writel(reg, REG_EMMC_CRG);
+	udelay(1); /* delay 25us */
+
+	return 0;
+}
+
+static void bsp_mmc_set_ioconfig(struct sdhci_host *host)
+{
+	unsigned int reg;
+	int i;
+
+	if (host->type == MMC_TYPE_MMC) {
+		reg = sdhci_readw(host, SDHCI_EMMC_CTRL);
+		reg |= SDHCI_CARD_IS_EMMC;
+		sdhci_writew(host, reg, SDHCI_EMMC_CTRL);
+
+		switch (host->mmc->timing) {
+		case MMC_TIMING_MMC_HS400:
+			bsp_set_drv_str(REG_CTRL_EMMC_CLK, 0, 1, 0, 0x3);  /* set drv level 3 */
+			bsp_set_drv_str(REG_CTRL_EMMC_CMD, 1, 0, 0, 0x5);  /* set drv level 5 */
+			for (i = 0; i < IO_CFG_EMMC_DATA_LINE_COUNT; i++)
+				bsp_set_drv_str(
+					io_emmc_data_reg[i], 1, 0, 0, 0x5); /* set drv level 5 */
+
+			bsp_set_drv_str(REG_CTRL_EMMC_DS, 0, 1, 1, 0x3);   /* set drv level 3 */
+			bsp_set_drv_str(REG_CTRL_EMMC_RST, 1, 0, 1, 0x3);  /* set drv level 3 */
+			break;
+		case MMC_TIMING_MMC_HS200:
+			bsp_set_drv_str(REG_CTRL_EMMC_CLK, 0, 1, 0, 0x2);  /* set drv level 2 */
+			bsp_set_drv_str(REG_CTRL_EMMC_CMD, 1, 0, 1, 0x4);  /* set drv level 4 */
+			for (i = 0; i < IO_CFG_EMMC_DATA_LINE_COUNT; i++)
+				bsp_set_drv_str(
+					io_emmc_data_reg[i], 1, 0, 1, 0x4); /* set drv level 4 */
+
+			bsp_set_drv_str(REG_CTRL_EMMC_RST, 1, 0, 1, 0x3);  /* set drv level 3 */
+			break;
+		case MMC_TIMING_MMC_HS:
+			bsp_set_drv_str(REG_CTRL_EMMC_CLK, 0, 1, 1, 0x4);  /* set drv level 4 */
+			bsp_set_drv_str(REG_CTRL_EMMC_CMD, 1, 0, 1, 0x6);  /* set drv level 6 */
+			for (i = 0; i < IO_CFG_EMMC_DATA_LINE_COUNT; i++)
+				bsp_set_drv_str(
+					io_emmc_data_reg[i], 1, 0, 1, 0x6); /* set drv level 6 */
+
+			bsp_set_drv_str(REG_CTRL_EMMC_RST, 1, 0, 1, 0x3);  /* set drv level 3 */
+			break;
+		case MMC_TIMING_LEGACY:
+		case MMC_TIMING_MMC_DDR52:
+		default:
+			bsp_set_drv_str(REG_CTRL_EMMC_CLK, 0, 1, 1, 0x5);  /* set drv level 5 */
+			bsp_set_drv_str(REG_CTRL_EMMC_CMD, 1, 0, 1, 0x6);  /* set drv level 6 */
+			for (i = 0; i < IO_CFG_EMMC_DATA_LINE_COUNT; i++)
+				bsp_set_drv_str(
+					io_emmc_data_reg[i], 1, 0, 1, 0x6); /* set drv level 6 */
+
+			bsp_set_drv_str(REG_CTRL_EMMC_RST, 1, 0, 1, 0x3);  /* set drv level 3 */
+			break;
+		}
+	} else {
+		switch (host->mmc->timing) {
+		case MMC_TIMING_SD_HS:
+			bsp_set_drv_str(REG_CTRL_SDIO0_CLK, 0, 1, 1, 0x5);  /* set drv level 5 */
+			bsp_set_drv_str(REG_CTRL_SDIO0_CMD, 1, 0, 1, 0x7);  /* set drv level 7 */
+			for (i = 0; i < IO_CFG_SDIO0_DATA_LINE_COUNT; i++)
+				bsp_set_drv_str(
+					io_sdio0_data_reg[i], 1, 0, 1, 0x7); /* set drv level 7 */
+			break;
+		case MMC_TIMING_LEGACY:
+		default:
+			bsp_set_drv_str(REG_CTRL_SDIO0_CLK, 0, 1, 1, 0x5);  /* set drv level 5 */
+			bsp_set_drv_str(REG_CTRL_SDIO0_CMD, 1, 0, 1, 0x7);  /* set drv level 7 */
+			for (i = 0; i < IO_CFG_SDIO0_DATA_LINE_COUNT; i++)
+				bsp_set_drv_str(
+					io_sdio0_data_reg[i], 1, 0, 1, 0x7); /* set drv level 7 */
+			break;
+		}
+	}
+}
+
+static void bsp_set_phase(struct sdhci_host *host)
+{
+	unsigned int drv_phase, sample_phase;
+
+	if (host->mmc->timing == MMC_TIMING_MMC_HS400) {
+		drv_phase = 9;   /* 9 for 101.25 degree */
+		sample_phase = host->tuning_phase;
+	} else if (host->mmc->timing == MMC_TIMING_MMC_HS200) {
+		drv_phase = 23;   /* 23 for 258.75 degree */
+		sample_phase = host->tuning_phase;
+	} else if (host->mmc->timing == MMC_TIMING_MMC_HS) {
+		drv_phase = 16;   /* 16 for 180 degree */
+		sample_phase = 4; /* 4 for 45 degree */
+	} else if (host->mmc->timing == MMC_TIMING_SD_HS) {
+		drv_phase = 20;   /* 20 for 225 degree */
+		sample_phase = 4; /* 4 for 45 degree */
+	} else if (host->mmc->timing == MMC_TIMING_MMC_DDR52) {
+		drv_phase = 8;    /* 8 for 90 degree */
+		sample_phase = host->tuning_phase;
+	} else if (host->mmc->timing == MMC_TIMING_LEGACY) {
+		drv_phase = 16;   /* 16 for 180 degree */
+		sample_phase = 0; /* 0 for degree */
+	} else {
+		drv_phase = 16;   /* 16 for 180 degree */
+		sample_phase = 0; /* 0 for degree */
+	}
+
+	bsp_set_drv_phase(host, drv_phase);
+	bsp_enable_sample(host);
+	bsp_set_sampl_phase(host, sample_phase);
+
+	udelay(25); /* delay 25us */
+}
+
+static void bsp_wait_drv_dll_lock(struct sdhci_host *host)
+{
+	unsigned int timeout = 20;
+	unsigned int reg;
+	uintptr_t reg_addr;
+
+	reg_addr = host->type == MMC_TYPE_MMC ?
+		REG_EMMC_DRV_DLL_STATUS : REG_SDIO0_DRV_DLL_STATUS;
+	do {
+		reg = readl(reg_addr);
+		if (reg & SDIO_DRV_DLL_LOCK)
+			return;
+
+		udelay(1000); /* delay 1000us */
+		timeout--;
+	} while (timeout > 0);
+
+	printf("sdhci: DRV DLL master not locked.\n");
+}
+
+static void bsp_enable_sampl_dll_slave(struct sdhci_host *host)
+{
+	unsigned int reg;
+	uintptr_t reg_addr;
+
+	reg_addr = host->type == MMC_TYPE_MMC ?
+		REG_EMMC_SAMPL_DLL_CTRL : REG_SDIO0_SAMPL_DLL_CTRL;
+	reg = readl(reg_addr);
+	reg |= SDIO_SAMPL_DLL_SLAVE_EN;
+	writel(reg, reg_addr);
+}
+
+static int bsp_mmc_set_clk(struct sdhci_host *host, unsigned int clk)
+{
+	bsp_dll_reset_assert(host);
+	udelay(25); /* delay 25us */
+	bsp_set_crg(host, clk);
+	bsp_set_phase(host);
+	udelay(25); /* delay 25us */
+
+	if (clk > MMC_HIGH_52_MAX_DTR) {
+		bsp_enable_sampl_dll_slave(host);
+		bsp_dll_reset_deassert(host);
+	}
+
+	bsp_enable_internal_clk(host);
+
+	if (clk > MMC_HIGH_52_MAX_DTR) {
+		bsp_wait_drv_dll_lock(host);
+		bsp_wait_sampl_dll_slave_ready(host);
+		bsp_wait_ds180_dll_ready();
+	}
+
+	bsp_enable_card_clk(host);
+	udelay(100); /* delay 100us */
+
+	return 0;
+}
+
+#include "bsp_sdhci.c"
+#endif
\ No newline at end of file
diff -uraN u-boot-2016.11/drivers/mmc/gk7605v100.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mmc/gk7605v100.c
--- u-boot-2016.11/drivers/mmc/gk7605v100.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mmc/gk7605v100.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,443 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <asm/arch-gk7605v100/platform.h>
+#include <common.h>
+#include <malloc.h>
+#include <sdhci.h>
+#include "mmc_private.h"
+
+#ifdef CONFIG_GK_SDHCI
+#define MIN_FREQ	400000
+#define NOT_FOUND	(-1)
+#define PHASE_SCALE	32
+#define EDGE_TUNING_PHASE_STEP	4
+
+#define SDIO_DRV_DLL_SRST_REQ		(0x1 << 29)
+#define SDIO_CLK_EN			(0x1 << 28)
+#define SDIO_SRST_REQ			(0x1 << 27)
+#define SDIO_CLK_SEL			(0x7 << 24)
+#define SDIO_CLK_SEL_400K		(0x1 << 24)
+
+#define REG_EMMC_DRV_DLL_STATUS		(CRG_REG_BASE + 0x210)
+#define REG_SDIO0_DRV_DLL_STATUS	REG_EMMC_DRV_DLL_STATUS
+#define REG_SDIO1_DRV_DLL_STATUS	(CRG_REG_BASE + 0x228)
+#define SDIO_DRV_DLL_LOCK		BIT(15)
+#define SDIO_DRV_DLL_READY		BIT(14)
+
+#define REG_EMMC_SAMPL_DLL_STATUS	(CRG_REG_BASE + 0x208)
+#define REG_SDIO0_SAMPL_DLL_STATUS	REG_EMMC_SAMPL_DLL_STATUS
+#define REG_SDIO1_SAMPL_DLL_STATUS	(CRG_REG_BASE + 0x224)
+#define SDIO_SAMPL_DLL_SLAVE_READY	BIT(0)
+
+#define REG_EMMC_SAMPL_DLL_CTRL		(CRG_REG_BASE + 0x1f4)
+#define REG_SDIO0_SAMPL_DLL_CTRL	REG_EMMC_SAMPL_DLL_CTRL
+#define REG_SDIO1_SAMPL_DLL_CTRL	(CRG_REG_BASE + 0x22c)
+#define SDIO_SAMPL_DLL_SLAVE_EN		BIT(16)
+
+#define REG_EMMC_SAMPLB_DLL_CTRL	(CRG_REG_BASE + 0x1f8)
+#define REG_SDIO0_SAMPLB_DLL_CTRL	REG_EMMC_SAMPLB_DLL_CTRL
+#define REG_SDIO1_SAMPLB_DLL_CTRL	(CRG_REG_BASE + 0x21c)
+#define SDIO_SAMPLB_DLL_CLK_MASK	(0x1f << 0)
+#define sdio_samplb_sel(phase)		((phase) << 0)
+
+#define REG_EMMC_DRV_DLL_CTRL		(CRG_REG_BASE + 0x1fc)
+#define REG_SDIO0_DRV_DLL_CTRL		REG_EMMC_DRV_DLL_CTRL
+#define REG_SDIO1_DRV_DLL_CTRL		(CRG_REG_BASE + 0x220)
+#define SDIO_DRV_PHASE_SEL_MASK		(0x1f << 24)
+#define sdio_drv_sel(phase)		((phase) << 24)
+
+#define REG_EMMC_DS_DLL_CTRL		(CRG_REG_BASE + 0x200)
+#define EMMC_DS_DLL_MODE_SSEL		BIT(13)
+#define EMMC_DS_DLL_SSEL_MASK		0x7f
+
+#define REG_EMMC_DS180_DLL_CTRL		(CRG_REG_BASE + 0x204)
+#define EMMC_DS180_DLL_BYPASS		BIT(15)
+#define REG_EMMC_DS180_DLL_STATUS	(CRG_REG_BASE + 0x218)
+#define EMMC_DS180_DLL_READY		BIT(0)
+
+#define IO_CFG_SR			BIT(10)
+#define IO_CFG_PULL_DOWN		BIT(9)
+#define IO_CFG_PULL_UP			BIT(8)
+#define IO_CFG_DRV_STR_MASK		(0xf << 4)
+#define io_cfg_drv_str_sel(str)		((str) << 4)
+
+#define REG_IO_CFG_BASE			0x100C0000
+/* EMMC_IOCFG */
+#define IO_CFG_EMMC_DATA_LINE_COUNT	8
+#define REG_CTRL_EMMC_CLK		0x0014
+#define REG_CTRL_EMMC_CMD		0x0018
+#define REG_CTRL_EMMC_DATA0		0x001c
+#define REG_CTRL_EMMC_DATA1		0x0028
+#define REG_CTRL_EMMC_DATA2		0x0024
+#define REG_CTRL_EMMC_DATA3		0x0020
+#define REG_CTRL_EMMC_DATA4		0x0030
+#define REG_CTRL_EMMC_DATA5		0x0034
+#define REG_CTRL_EMMC_DATA6		0x0038
+#define REG_CTRL_EMMC_DATA7		0x003c
+#define REG_CTRL_EMMC_DS		0x0058
+#define REG_CTRL_EMMC_RST		0x005c
+static unsigned int io_emmc_data_reg[IO_CFG_EMMC_DATA_LINE_COUNT] = {
+	REG_CTRL_EMMC_DATA0, REG_CTRL_EMMC_DATA1,
+	REG_CTRL_EMMC_DATA2, REG_CTRL_EMMC_DATA3,
+	REG_CTRL_EMMC_DATA4, REG_CTRL_EMMC_DATA5,
+	REG_CTRL_EMMC_DATA6, REG_CTRL_EMMC_DATA7
+};
+
+#define IO_CFG_SDIO0_DATA_LINE_COUNT	4
+#define REG_CTRL_SDIO0_CLK		0x0040
+#define REG_CTRL_SDIO0_CMD		0x0044
+#define REG_CTRL_SDIO0_DATA0		0x0048
+#define REG_CTRL_SDIO0_DATA1		0x004C
+#define REG_CTRL_SDIO0_DATA2		0x0050
+#define REG_CTRL_SDIO0_DATA3		0x0054
+static unsigned int io_sdio0_data_reg[IO_CFG_SDIO0_DATA_LINE_COUNT] = {
+	REG_CTRL_SDIO0_DATA0, REG_CTRL_SDIO0_DATA1,
+	REG_CTRL_SDIO0_DATA2, REG_CTRL_SDIO0_DATA3
+};
+
+#define CLK_100K	100000
+#define CLK_400K	400000
+#define CLK_25M		25000000
+#define CLK_50M		50000000
+#define CLK_90M		90000000
+#define CLK_112M	112000000
+#define CLK_150M	150000000
+#define CLK_198M	198000000
+
+static void bsp_enable_sample(struct sdhci_host *host);
+static void bsp_set_drv_phase(struct sdhci_host *host,	unsigned int phase);
+static void bsp_set_sampl_phase(struct sdhci_host *host, unsigned int phase);
+static void bsp_wait_sampl_dll_slave_ready(struct sdhci_host *host);
+static void bsp_enable_card_clk(struct sdhci_host *host);
+static void bsp_disable_card_clk(struct sdhci_host *host);
+static void bsp_enable_internal_clk(struct sdhci_host *host);
+static void bsp_disable_internal_clk(struct sdhci_host *host);
+static int bsp_mmc_exec_tuning(struct sdhci_host *host, unsigned int opcode);
+
+static void bsp_dll_reset_assert(struct sdhci_host *host)
+{
+	uintptr_t crg_addr;
+	unsigned int reg;
+
+	crg_addr = REG_EMMC_CRG;
+	reg = readl(crg_addr);
+	reg |= SDIO_DRV_DLL_SRST_REQ;
+	writel(reg, crg_addr);
+}
+
+static void bsp_dll_reset_deassert(struct sdhci_host *host)
+{
+	uintptr_t crg_addr;
+	unsigned int reg;
+
+	crg_addr = REG_EMMC_CRG;
+	reg = readl(crg_addr);
+	reg &= ~SDIO_DRV_DLL_SRST_REQ;
+	writel(reg, crg_addr);
+}
+
+static void bsp_set_crg(struct sdhci_host *host, unsigned int clk)
+{
+	uintptr_t crg_addr;
+	unsigned int sel, reg;
+	unsigned int clk_mux[] = {
+		CLK_100K, CLK_400K, CLK_25M, CLK_50M,
+		CLK_90M, CLK_112M, CLK_150M, CLK_198M
+	};
+
+	crg_addr = REG_EMMC_CRG;
+	reg = readl(crg_addr);
+	reg &= ~MMC_CLK_SEL_MASK;
+
+	if (clk <= MIN_FREQ) {
+		sel = 1;
+	} else {
+		for (sel = 0x6; sel > 0; sel--) {
+			if (clk >= clk_mux[sel])
+				break;
+		}
+	}
+
+	reg |= mmc_clk_sel(sel);
+	writel(reg, crg_addr);
+}
+
+static void bsp_wait_ds180_dll_ready(void)
+{
+	unsigned int reg;
+	unsigned int timeout = 20;
+
+	do {
+		reg = readl(REG_EMMC_DS180_DLL_STATUS);
+		if (reg & EMMC_DS180_DLL_READY)
+			return;
+
+		udelay(1000); /* delay 1000us */
+		timeout--;
+	} while (timeout > 0);
+
+	printf("DS180 DLL master not ready.\n");
+}
+
+static void bsp_mmc_priv_init(struct sdhci_host *host)
+{
+	unsigned short ctrl;
+	unsigned int reg;
+
+	ctrl = sdhci_readw(host, SDHCI_MSHC_CTRL);
+	ctrl &= ~SDHCI_CMD_CONFLIT_CHECK;
+	sdhci_writew(host, ctrl, SDHCI_MSHC_CTRL);
+
+	reg = sdhci_readl(host, SDHCI_AXI_MBIIU_CTRL);
+	reg |= SDHCI_GM_WR_OSRC_LMT | SDHCI_GM_RD_OSRC_LMT;
+	reg &= ~SDHCI_UNDEFL_INCR_EN;
+	sdhci_writel(host, reg, SDHCI_AXI_MBIIU_CTRL);
+
+	reg  = sdhci_readl(host, SDHCI_MULTI_CYCLE);
+	reg &= ~SDHCI_CMD_DLY_EN;
+	reg |= SDHCI_EDGE_DETECT_EN | SDHCI_DATA_DLY_EN;
+	sdhci_writel(host, reg, SDHCI_MULTI_CYCLE);
+}
+
+static void bsp_set_drv_str(unsigned int offset, unsigned int pull_up,
+				unsigned int pull_down, unsigned int sr,
+				unsigned int drv_str)
+{
+	unsigned int reg;
+	const uintptr_t crg_addr = REG_IO_CFG_BASE + offset;
+
+	reg = readl(crg_addr);
+	reg &= ~(IO_CFG_PULL_UP | IO_CFG_PULL_DOWN |
+		 IO_CFG_DRV_STR_MASK | IO_CFG_SR);
+	reg |= (pull_up ? IO_CFG_PULL_UP : 0);
+	reg |= (pull_down ? IO_CFG_PULL_DOWN : 0);
+	reg |= (sr ? IO_CFG_SR : 0);
+	reg |= io_cfg_drv_str_sel(drv_str);
+	writel(reg, crg_addr);
+}
+
+static int sd_hardware_init(void)
+{
+	unsigned int reg;
+
+	/* clk enable */
+	reg = readl(REG_EMMC_CRG);
+	reg |= SDIO_CLK_EN;
+	writel(reg, REG_EMMC_CRG);
+
+	/* reset assert */
+	reg = readl(REG_EMMC_CRG);
+	reg |= SDIO_SRST_REQ | SDIO_DRV_DLL_SRST_REQ;
+	writel(reg, REG_EMMC_CRG);
+	udelay(25); /* delay 25us */
+
+	/* reset deassert */
+	reg &= ~SDIO_SRST_REQ;
+	writel(reg, REG_EMMC_CRG);
+	udelay(1); /* delay 1us */
+
+	udelay(5000); /* delay 5000us */
+
+	return 0;
+}
+
+static int emmc_hardware_init(void)
+{
+	unsigned int reg;
+
+	/* eMMC clk enable */
+	reg = readl(REG_EMMC_CRG);
+	reg |= SDIO_CLK_EN;
+	writel(reg, REG_EMMC_CRG);
+
+	/* eMMC reset assert */
+	reg = readl(REG_EMMC_CRG);
+	reg |= SDIO_SRST_REQ | SDIO_DRV_DLL_SRST_REQ;
+	writel(reg, REG_EMMC_CRG);
+	udelay(25); /* delay 25us */
+
+	/* select 400K clk */
+	reg = readl(REG_EMMC_CRG);
+	reg &= ~SDIO_CLK_SEL;
+	reg |= SDIO_CLK_SEL_400K;
+	writel(reg, REG_EMMC_CRG);
+	udelay(25); /* delay 25us */
+
+	/* eMMC reset deassert */
+	reg = readl(REG_EMMC_CRG);
+	reg &= ~SDIO_SRST_REQ;
+	writel(reg, REG_EMMC_CRG);
+	udelay(1); /* delay 1us */
+
+	return 0;
+}
+
+static void bsp_mmc_set_ioconfig(struct sdhci_host *host)
+{
+	unsigned int reg;
+	int i;
+
+	if (host->type == MMC_TYPE_MMC) {
+		reg = sdhci_readw(host, SDHCI_EMMC_CTRL);
+		reg |= SDHCI_CARD_IS_EMMC;
+		sdhci_writew(host, reg, SDHCI_EMMC_CTRL);
+
+		switch (host->mmc->timing) {
+		case MMC_TIMING_MMC_HS400:
+			bsp_set_drv_str(REG_CTRL_EMMC_CLK, 0, 1, 0, 0x3);  /* set drv level 3 */
+			bsp_set_drv_str(REG_CTRL_EMMC_CMD, 1, 0, 0, 0x5);  /* set drv level 5 */
+			for (i = 0; i < IO_CFG_EMMC_DATA_LINE_COUNT; i++)
+				bsp_set_drv_str(
+					io_emmc_data_reg[i], 1, 0, 0, 0x5); /* set drv level 5 */
+
+			bsp_set_drv_str(REG_CTRL_EMMC_DS, 0, 1, 1, 0x3);   /* set drv level 3 */
+			bsp_set_drv_str(REG_CTRL_EMMC_RST, 1, 0, 1, 0x3);  /* set drv level 3 */
+			break;
+		case MMC_TIMING_MMC_HS200:
+			bsp_set_drv_str(REG_CTRL_EMMC_CLK, 0, 1, 0, 0x2);  /* set drv level 2 */
+			bsp_set_drv_str(REG_CTRL_EMMC_CMD, 1, 0, 1, 0x4);  /* set drv level 4 */
+			for (i = 0; i < IO_CFG_EMMC_DATA_LINE_COUNT; i++)
+				bsp_set_drv_str(
+					io_emmc_data_reg[i], 1, 0, 1, 0x4); /* set drv level 4 */
+
+			bsp_set_drv_str(REG_CTRL_EMMC_RST, 1, 0, 1, 0x3);  /* set drv level 3 */
+			break;
+		case MMC_TIMING_MMC_HS:
+			bsp_set_drv_str(REG_CTRL_EMMC_CLK, 0, 1, 1, 0x4);  /* set drv level 4 */
+			bsp_set_drv_str(REG_CTRL_EMMC_CMD, 1, 0, 1, 0x6);  /* set drv level 6 */
+			for (i = 0; i < IO_CFG_EMMC_DATA_LINE_COUNT; i++)
+				bsp_set_drv_str(
+					io_emmc_data_reg[i], 1, 0, 1, 0x6); /* set drv level 6 */
+
+			bsp_set_drv_str(REG_CTRL_EMMC_RST, 1, 0, 1, 0x3);  /* set drv level 3 */
+			break;
+		case MMC_TIMING_LEGACY:
+		case MMC_TIMING_MMC_DDR52:
+		default:
+			bsp_set_drv_str(REG_CTRL_EMMC_CLK, 0, 1, 1, 0x5);  /* set drv level 5 */
+			bsp_set_drv_str(REG_CTRL_EMMC_CMD, 1, 0, 1, 0x6);  /* set drv level 6 */
+			for (i = 0; i < IO_CFG_EMMC_DATA_LINE_COUNT; i++)
+				bsp_set_drv_str(
+					io_emmc_data_reg[i], 1, 0, 1, 0x6); /* set drv level 6 */
+
+			bsp_set_drv_str(REG_CTRL_EMMC_RST, 1, 0, 1, 0x3);  /* set drv level 3 */
+			break;
+		}
+	} else {
+		switch (host->mmc->timing) {
+		case MMC_TIMING_SD_HS:
+			bsp_set_drv_str(REG_CTRL_SDIO0_CLK, 0, 1, 1, 0x5);  /* set drv level 5 */
+			bsp_set_drv_str(REG_CTRL_SDIO0_CMD, 1, 0, 1, 0x7);  /* set drv level 7 */
+			for (i = 0; i < IO_CFG_SDIO0_DATA_LINE_COUNT; i++)
+				bsp_set_drv_str(
+					io_sdio0_data_reg[i], 1, 0, 1, 0x7); /* set drv level 7 */
+			break;
+		case MMC_TIMING_LEGACY:
+		default:
+			bsp_set_drv_str(REG_CTRL_SDIO0_CLK, 0, 1, 1, 0x5);  /* set drv level 5 */
+			bsp_set_drv_str(REG_CTRL_SDIO0_CMD, 1, 0, 1, 0x7);  /* set drv level 7 */
+			for (i = 0; i < IO_CFG_SDIO0_DATA_LINE_COUNT; i++)
+				bsp_set_drv_str(
+					io_sdio0_data_reg[i], 1, 0, 1, 0x7); /* set drv level 7 */
+			break;
+		}
+	}
+}
+
+static void bsp_set_phase(struct sdhci_host *host)
+{
+	unsigned int drv_phase, sample_phase;
+
+	if (host->mmc->timing == MMC_TIMING_MMC_HS400) {
+		drv_phase = 9;   /* 9 for 101.25 degree */
+		sample_phase = host->tuning_phase;
+	} else if (host->mmc->timing == MMC_TIMING_MMC_HS200) {
+		drv_phase = 23;   /* 23 for 258.75 degree */
+		sample_phase = host->tuning_phase;
+	} else if (host->mmc->timing == MMC_TIMING_MMC_HS) {
+		drv_phase = 16;   /* 16 for 180 degree */
+		sample_phase = 4; /* 4 for 45 degree */
+	} else if (host->mmc->timing == MMC_TIMING_SD_HS) {
+		drv_phase = 20;   /* 20 for 225 degree */
+		sample_phase = 4; /* 4 for 45 degree */
+	} else if (host->mmc->timing == MMC_TIMING_MMC_DDR52) {
+		drv_phase = 8;    /* 8 for 90 degree */
+		sample_phase = host->tuning_phase;
+	} else if (host->mmc->timing == MMC_TIMING_LEGACY) {
+		drv_phase = 16;   /* 16 for 180 degree */
+		sample_phase = 0; /* 0 for degree */
+	} else {
+		drv_phase = 16;   /* 16 for 180 degree */
+		sample_phase = 0; /* 0 for degree */
+	}
+
+	bsp_set_drv_phase(host, drv_phase);
+	bsp_enable_sample(host);
+	bsp_set_sampl_phase(host, sample_phase);
+
+	udelay(25); /* delay 25us */
+}
+
+static void bsp_wait_drv_dll_lock(struct sdhci_host *host)
+{
+	unsigned int timeout = 20;
+	unsigned int reg;
+	uintptr_t reg_addr;
+
+	reg_addr = host->type == MMC_TYPE_MMC ?
+		REG_EMMC_DRV_DLL_STATUS : REG_SDIO0_DRV_DLL_STATUS;
+	do {
+		reg = readl(reg_addr);
+		if (reg & SDIO_DRV_DLL_LOCK)
+			return;
+
+		udelay(1000); /* delay 1000us */
+		timeout--;
+	} while (timeout > 0);
+
+	printf("sdhci: DRV DLL master not locked.\n");
+}
+
+static void bsp_enable_sampl_dll_slave(struct sdhci_host *host)
+{
+	unsigned int reg;
+	uintptr_t reg_addr;
+
+	reg_addr = host->type == MMC_TYPE_MMC ?
+		REG_EMMC_SAMPL_DLL_CTRL : REG_SDIO0_SAMPL_DLL_CTRL;
+	reg = readl(reg_addr);
+	reg |= SDIO_SAMPL_DLL_SLAVE_EN;
+	writel(reg, reg_addr);
+}
+
+static int bsp_mmc_set_clk(struct sdhci_host *host, unsigned int clk)
+{
+	bsp_dll_reset_assert(host);
+	udelay(25); /* delay 25us */
+	bsp_set_crg(host, clk);
+	bsp_set_phase(host);
+	udelay(25); /* delay 25us */
+
+	if (clk > MMC_HIGH_52_MAX_DTR) {
+		bsp_enable_sampl_dll_slave(host);
+		bsp_dll_reset_deassert(host);
+	}
+
+	bsp_enable_internal_clk(host);
+
+	if (clk > MMC_HIGH_52_MAX_DTR) {
+		bsp_wait_drv_dll_lock(host);
+		bsp_wait_sampl_dll_slave_ready(host);
+		bsp_wait_ds180_dll_ready();
+	}
+
+	bsp_enable_card_clk(host);
+	udelay(100); /* delay 100us */
+
+	return 0;
+}
+
+#include "bsp_sdhci.c"
+#endif
\ No newline at end of file
diff -uraN u-boot-2016.11/drivers/mmc/Kconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mmc/Kconfig
--- u-boot-2016.11/drivers/mmc/Kconfig	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mmc/Kconfig	2021-06-07 13:01:32.000000000 +0300
@@ -2,7 +2,7 @@
 
 config MMC
 	bool "Enable MMC support"
-	depends on ARCH_SUNXI || SANDBOX
+	depends on ARCH_SUNXI || SANDBOX || TARGET_GK7205V200 || TARGET_GK7205V300 || TARGET_GK7202V300 || TARGET_GK7605V100 
 	help
 	  TODO: Move all architectures to use this option
 
diff -uraN u-boot-2016.11/drivers/mmc/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mmc/Makefile
--- u-boot-2016.11/drivers/mmc/Makefile	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mmc/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -57,6 +57,10 @@
 obj-$(CONFIG_MMC_UNIPHIER) += uniphier-sd.o
 obj-$(CONFIG_ZYNQ_SDHCI) += zynq_sdhci.o
 obj-$(CONFIG_ROCKCHIP_SDHCI) += rockchip_sdhci.o
+obj-$(CONFIG_TARGET_GK7202V300) += gk7202v300.o
+obj-$(CONFIG_TARGET_GK7205V200) += gk7205v200.o
+obj-$(CONFIG_TARGET_GK7205V300) += gk7205v300.o
+obj-$(CONFIG_TARGET_GK7605V100) += gk7605v100.o
 
 ifdef CONFIG_SPL_BUILD
 obj-$(CONFIG_SPL_MMC_BOOT) += fsl_esdhc_spl.o
diff -uraN u-boot-2016.11/drivers/mmc/mmc_boot.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mmc/mmc_boot.c
--- u-boot-2016.11/drivers/mmc/mmc_boot.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mmc/mmc_boot.c	2021-06-07 13:01:32.000000000 +0300
@@ -6,6 +6,8 @@
  */
 
 #include <common.h>
+#include <asm/io.h>
+#include <memalign.h>
 #include <mmc.h>
 #include "mmc_private.h"
 
@@ -117,3 +119,104 @@
 	return mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_RST_N_FUNCTION,
 			  enable);
 }
+
+u8 mmc_get_boot_mode(void)
+{
+	u8 boot_mode;
+
+	boot_mode = 0;
+
+	return boot_mode;
+}
+
+#define EXT_CSD_REV_4_41	5
+
+int mmc_set_boot_config(struct mmc *mmc)
+{
+	int err, changed = 0;
+	u8 val, rev, rst_n_en;
+	u8 boot_part, boot_bus_width, part_conf, bus_cond, boot_mode;
+	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, MMC_MAX_BLOCK_LEN);
+
+	err = mmc_send_ext_csd(mmc, ext_csd);
+	if (err) {
+		printf("Get ext_csd error!\n");
+		return err;
+	}
+
+	rev = ext_csd[EXT_CSD_REV];
+	rst_n_en = ext_csd[EXT_CSD_RST_N_FUNCTION] & EXT_CSD_RST_N_EN_MASK;
+	if ((rev >= EXT_CSD_REV_4_41) && (rst_n_en != EXT_CSD_RST_N_ENABLED)) {
+		err = mmc_set_rst_n_function(mmc, EXT_CSD_RST_N_ENABLED);
+		if (err) {
+			printf("mmc_set_rst_n_function error!\n");
+			return err;
+		}
+	}
+
+	if ((rev >= EXT_CSD_REV_4_41) &&
+			(ext_csd[EXT_CSD_WR_REL_PARAM] & EXT_CSD_HS_CTRL_REL)) {
+		val = ext_csd[EXT_CSD_WR_REL_SET];
+		if (val != EXT_CSD_WR_REL_VALUE) {
+			err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+					EXT_CSD_WR_REL_SET,
+					EXT_CSD_WR_REL_VALUE);
+			if (err) {
+				printf("Set EXT_CSD_WR_REL_SET error!\n");
+				return err;
+			}
+		}
+	}
+
+	boot_part = 0x7; /* user area enable for boot */
+	if (readl(SYS_CTRL_REG_BASE + REG_SYSSTAT) & NF_BOOTBW_MASK)
+		boot_bus_width = EXT_CSD_BUS_WIDTH_8; /* 8bits */
+	else
+		boot_bus_width = EXT_CSD_BUS_WIDTH_4; /* 4bits */
+
+	boot_mode = mmc_get_boot_mode();
+	part_conf = EXT_CSD_BOOT_ACK(0) |
+		EXT_CSD_BOOT_PART_NUM(boot_part) |
+		EXT_CSD_PARTITION_ACCESS(0);
+	bus_cond = EXT_CSD_BOOT_BUS_WIDTH_MODE(boot_mode) |
+		EXT_CSD_BOOT_BUS_WIDTH_RESET(0) |
+		EXT_CSD_BOOT_BUS_WIDTH_WIDTH(boot_bus_width);
+
+	if (ext_csd[EXT_CSD_PART_CONF] != part_conf) {
+		err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+				EXT_CSD_PART_CONF, part_conf);
+		if (err) {
+			printf("Set EXT_CSD_PART_CONF error!\n");
+			return err;
+		}
+		changed = 1;
+	}
+
+	if (ext_csd[EXT_CSD_BOOT_BUS_WIDTH] != bus_cond) {
+		err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+				EXT_CSD_BOOT_BUS_WIDTH, bus_cond);
+		if (err) {
+			printf("Set EXT_CSD_BOOT_BUS_WIDTH error!\n");
+			return err;
+		}
+		changed = 1;
+	}
+
+	if (!changed)
+		return 0;
+
+	err = mmc_send_ext_csd(mmc, ext_csd);
+	if (err) {
+		printf("Check ext_csd error!\n");
+		return err;
+	}
+
+	if (part_conf != ext_csd[EXT_CSD_PART_CONF] ||
+			bus_cond != ext_csd[EXT_CSD_BOOT_BUS_WIDTH]) {
+		printf("EXT_CSD CONFIG Fail!\n");
+		return -1;
+	}
+
+	printf("EXT_CSD CONFIG OK!\n");
+	return 0;
+}
diff -uraN u-boot-2016.11/drivers/mmc/mmc.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mmc/mmc.c
--- u-boot-2016.11/drivers/mmc/mmc.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mmc/mmc.c	2021-06-07 13:01:32.000000000 +0300
@@ -10,6 +10,7 @@
 #include <config.h>
 #include <common.h>
 #include <command.h>
+#include <asm/io.h>
 #include <dm.h>
 #include <dm/device-internal.h>
 #include <errno.h>
@@ -22,6 +23,36 @@
 #include <div64.h>
 #include "mmc_private.h"
 
+static const u8 tuning_blk_pattern_4bit[] = {
+	0xff, 0x0f, 0xff, 0x00, 0xff, 0xcc, 0xc3, 0xcc,
+	0xc3, 0x3c, 0xcc, 0xff, 0xfe, 0xff, 0xfe, 0xef,
+	0xff, 0xdf, 0xff, 0xdd, 0xff, 0xfb, 0xff, 0xfb,
+	0xbf, 0xff, 0x7f, 0xff, 0x77, 0xf7, 0xbd, 0xef,
+	0xff, 0xf0, 0xff, 0xf0, 0x0f, 0xfc, 0xcc, 0x3c,
+	0xcc, 0x33, 0xcc, 0xcf, 0xff, 0xef, 0xff, 0xee,
+	0xff, 0xfd, 0xff, 0xfd, 0xdf, 0xff, 0xbf, 0xff,
+	0xbb, 0xff, 0xf7, 0xff, 0xf7, 0x7f, 0x7b, 0xde,
+};
+
+static const u8 tuning_blk_pattern_8bit[] = {
+	0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,
+	0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc, 0xcc,
+	0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff, 0xff,
+	0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee, 0xff,
+	0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd, 0xdd,
+	0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff, 0xbb,
+	0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff, 0xff,
+	0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee, 0xff,
+	0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
+	0x00, 0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc,
+	0xcc, 0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff,
+	0xff, 0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee,
+	0xff, 0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd,
+	0xdd, 0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff,
+	0xbb, 0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff,
+	0xff, 0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee,
+};
+
 static const unsigned int sd_au_size[] = {
 	0,		SZ_16K / 512,		SZ_32K / 512,
 	SZ_64K / 512,	SZ_128K / 512,		SZ_256K / 512,
@@ -469,7 +500,7 @@
 }
 
 
-static int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
+int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
 {
 	struct mmc_cmd cmd;
 	struct mmc_data data;
@@ -490,7 +521,54 @@
 	return err;
 }
 
-int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
+int mmc_send_tuning(struct mmc *mmc, u32 opcode)
+{
+	ALLOC_CACHE_ALIGN_BUFFER(u8, data_buf, MMC_MAX_BLOCK_LEN);
+	struct mmc_cmd cmd;
+	struct mmc_data data;
+	const u8 *tuning_block_pattern;
+	int err, size;
+
+	if (mmc->bus_width == 8) {
+		tuning_block_pattern = tuning_blk_pattern_8bit;
+		size = sizeof(tuning_blk_pattern_8bit);
+	} else if (mmc->bus_width == 4) {
+		tuning_block_pattern = tuning_blk_pattern_4bit;
+		size = sizeof(tuning_blk_pattern_4bit);
+	} else
+		return -EINVAL;
+
+	/* Get the Card Status Register */
+	cmd.cmdidx = opcode;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = 0;
+
+	data.dest = (char *)data_buf;
+	data.blocks = 1;
+	data.blocksize = size;
+	data.flags = MMC_DATA_READ;
+
+	err = mmc_send_cmd(mmc, &cmd, &data);
+	if (err) {
+		/*
+		 * Send STOP command after tuning fail to stop transmission on card
+		 * we don't care if this STOP command fails or not
+		 */
+		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
+		cmd.cmdarg = 0;
+		cmd.resp_type = MMC_RSP_R1;
+		mmc_send_cmd(mmc, &cmd, NULL);
+		return err;
+	}
+
+	if (memcmp(data_buf, tuning_block_pattern, size))
+		return -EIO;
+
+	return 0;
+}
+
+static int __mmc_switch(struct mmc *mmc, u8 set,
+		u8 index, u8 value, bool send_status)
 {
 	struct mmc_cmd cmd;
 	int timeout = 1000;
@@ -500,22 +578,37 @@
 	cmd.resp_type = MMC_RSP_R1b;
 	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
 				 (index << 16) |
-				 (value << 8);
+				 (value << 8) |
+				 set;
 
 	ret = mmc_send_cmd(mmc, &cmd, NULL);
 
+	if (mmc->cfg->ops->card_busy) {
+		do {
+			if (!mmc->cfg->ops->card_busy(mmc))
+				break;
+			udelay(1000);
+		} while (--timeout);
+	}
+
 	/* Waiting for the ready status */
-	if (!ret)
+	timeout = 1000;
+	if (!ret && send_status)
 		ret = mmc_send_status(mmc, timeout);
 
 	return ret;
 
 }
 
+int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
+{
+	return __mmc_switch(mmc, set, index, value, true);
+}
+
 static int mmc_change_freq(struct mmc *mmc)
 {
 	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, MMC_MAX_BLOCK_LEN);
-	char cardtype;
+	char cardtype, strobe_support;
 	int err;
 
 	mmc->card_caps = 0;
@@ -534,7 +627,29 @@
 	if (err)
 		return err;
 
-	cardtype = ext_csd[EXT_CSD_CARD_TYPE] & 0xf;
+	cardtype = ext_csd[EXT_CSD_CARD_TYPE];
+	strobe_support = ext_csd[EXT_CSD_STROBE_SUPPORT];
+	if (cardtype & EXT_CSD_CARD_TYPE_HS400) {
+		if (cardtype & EXT_CSD_CARD_TYPE_HS400_1_8V)
+			mmc->card_caps |= MMC_MODE_HS400_1_8V;
+		else if (cardtype & EXT_CSD_CARD_TYPE_HS400_1_2V)
+			mmc->card_caps |= MMC_MODE_HS400_1_2V;
+
+		if (strobe_support)
+			mmc->card_caps |= MMC_MODE_HS400ES;
+	}
+
+	if (cardtype & EXT_CSD_CARD_TYPE_HS200) {
+		if (cardtype & EXT_CSD_CARD_TYPE_HS200_1_8V)
+			mmc->card_caps |= MMC_MODE_HS200_1_8V;
+		else if (cardtype & EXT_CSD_CARD_TYPE_HS200_1_2V)
+			mmc->card_caps |= MMC_MODE_HS200_1_2V;
+	}
+
+	mmc->card_caps &= mmc->cfg->host_caps;
+	if (mmc->card_caps & EXT_CSD_CARD_TYPE_HS200 ||
+		mmc->card_caps & EXT_CSD_CARD_TYPE_HS400)
+		return 0;
 
 	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING, 1);
 
@@ -1069,6 +1184,181 @@
 	mmc_set_ios(mmc);
 }
 
+static void mmc_set_timing(struct mmc *mmc, char timing)
+{
+	mmc->timing = timing;
+
+	mmc_set_ios(mmc);
+}
+
+static int mmc_execute_tuning(struct mmc *mmc)
+{
+	u32 opcode;
+	int err;
+
+	if (!mmc->cfg->ops->execute_tuning)
+		return 0;
+
+	if (IS_SD(mmc))
+		opcode = MMC_CMD_SEND_TUNING_BLOCK;
+	else
+		opcode = MMC_CMD_SEND_TUNING_BLOCK_HS200;
+
+	err = mmc->cfg->ops->execute_tuning(mmc, opcode);
+
+	if (err)
+		printf("tuning execution failed: %d\n", err);
+
+	return err;
+}
+
+static int mmc_switch_status(struct mmc *mmc)
+{
+	struct mmc_cmd cmd = {0};
+	unsigned int status;
+	int err;
+
+	cmd.cmdidx = MMC_CMD_SEND_STATUS;
+	cmd.resp_type = MMC_RSP_R1;
+	if (!mmc_host_is_spi(mmc))
+		cmd.cmdarg = mmc->rca << 16;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+	if (err)
+		return err;
+
+	if (!mmc_host_is_spi(host)) {
+		status = cmd.response[0];
+		if (status & 0xFDFFA000)
+			printf("unexpected status %#x after switch\n", status);
+		if (status & MMC_STATUS_SWITCH_ERROR)
+			return -EBADMSG;
+	}
+
+	return 0;
+}
+
+static int mmc_select_hs400(struct mmc *mmc)
+{
+	int err;
+
+	if (!(mmc->card_caps & MMC_MODE_HS400 && mmc->bus_width == 8))
+		return 0;
+
+	err = __mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+			EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS, false);
+	if (err) {
+		printf("switch to hs from hs200 failed, err:%d\n", err);
+		return err;
+	}
+
+	mmc_set_timing(mmc, MMC_TIMING_MMC_HS);
+	mmc->tran_speed = MMC_HIGH_52_MAX_DTR;
+	mmc_set_clock(mmc, mmc->tran_speed);
+
+	err = mmc_switch_status(mmc);
+	if (err)
+		return err;
+
+	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+			EXT_CSD_BUS_WIDTH, EXT_CSD_DDR_BUS_WIDTH_8);
+	if (err) {
+		printf("switch to bus width for hs400 failed, err:%d\n", err);
+		return err;
+	}
+
+	err = __mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+			EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS400, false);
+	if (err) {
+		printf("switch to hs400 failed, err:%d\n", err);
+		return err;
+	}
+
+	mmc_set_timing(mmc, MMC_TIMING_MMC_HS400);
+	mmc->tran_speed = MMC_HS200_MAX_DTR;
+	mmc_set_clock(mmc, mmc->tran_speed);
+	mmc->ddr_mode = 1;
+
+	return mmc_switch_status(mmc);
+}
+
+static int mmc_select_hs200(struct mmc *mmc)
+{
+	int err;
+	u8 old_timing;
+
+	err = __mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+			EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS200, false);
+	if (err) {
+		printf("switch to hs200 failed, err:%d\n", err);
+		return err;
+	}
+
+	old_timing = mmc->timing;
+	mmc_set_timing(mmc, MMC_TIMING_MMC_HS200);
+	err = mmc_switch_status(mmc);
+	if (err == -EBADMSG) {
+		mmc_set_timing(mmc, old_timing);
+		return err;
+	}
+
+	mmc->tran_speed = MMC_HS200_MAX_DTR;
+	mmc_set_clock(mmc, mmc->tran_speed);
+
+	err = mmc_execute_tuning(mmc);
+	if (err)
+		return err;
+
+	return mmc_select_hs400(mmc);
+}
+
+static int mmc_select_hs400es(struct mmc *mmc)
+{
+	int err;
+	u8 val;
+
+	if (!(mmc->card_caps & MMC_MODE_8BIT))
+		return -EOPNOTSUPP;
+
+	err = __mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+			EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS, false);
+	if (err)
+		return err;
+
+	mmc->tran_speed = MMC_HIGH_52_MAX_DTR;
+	mmc_set_clock(mmc, mmc->tran_speed);
+	err = mmc_switch_status(mmc);
+	if (err)
+		return err;
+
+	/* Switch card to DDR with strobe bit */
+	val = EXT_CSD_DDR_BUS_WIDTH_8 | EXT_CSD_BUS_WIDTH_STROBE;
+	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+			EXT_CSD_BUS_WIDTH, val);
+	if (err) {
+		printf("switch to bus width for hs400es failed, err:%d\n", err);
+		return err;
+	}
+
+	err = __mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+			EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS400, false);
+	if (err) {
+		printf("switch to hs400es failed, err:%d\n", err);
+		return err;
+	}
+
+	mmc_set_timing(mmc, MMC_TIMING_MMC_HS400);
+	mmc->tran_speed = MMC_HS200_MAX_DTR;
+	mmc_set_clock(mmc, mmc->tran_speed);
+
+	if (mmc->cfg->ops->hs400_enable_es) {
+		mmc->strobe_enhanced = 1;
+		mmc->cfg->ops->hs400_enable_es(mmc, 1);
+	}
+
+	return mmc_switch_status(mmc);
+}
+
 static int mmc_startup(struct mmc *mmc)
 {
 	int err, i;
@@ -1515,14 +1805,33 @@
 		}
 	}
 
+	if (mmc->card_caps & MMC_MODE_HS) {
+		if (IS_SD(mmc))
+			mmc_set_timing(mmc, MMC_TIMING_SD_HS);
+		else
+			mmc_set_timing(mmc, MMC_TIMING_MMC_HS);
+	}
+
 	mmc_set_clock(mmc, mmc->tran_speed);
 
+	if (mmc->card_caps & MMC_MODE_HS400ES) {
+		err = mmc_select_hs400es(mmc);
+		if (err)
+			return err;
+		mmc->ddr_mode = 1;
+	} else if (mmc->card_caps & MMC_MODE_HS200) {
+		err = mmc_select_hs200(mmc);
+		if (err)
+			return err;
+	}
+
 	/* Fix the block length for DDR mode */
 	if (mmc->ddr_mode) {
 		mmc->read_bl_len = MMC_MAX_BLOCK_LEN;
 		mmc->write_bl_len = MMC_MAX_BLOCK_LEN;
 	}
 
+	mmc->ocr_from_bootrom = 0;
 	/* fill in device description */
 	bdesc = mmc_get_blk_desc(mmc);
 	bdesc->lun = 0;
@@ -1645,6 +1954,7 @@
 		return err;
 #endif
 	mmc->ddr_mode = 0;
+	mmc_set_timing(mmc, MMC_TIMING_LEGACY);
 	mmc_set_bus_width(mmc, 1);
 	mmc_set_clock(mmc, 1);
 
diff -uraN u-boot-2016.11/drivers/mmc/mmc_private.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mmc/mmc_private.h
--- u-boot-2016.11/drivers/mmc/mmc_private.h	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mmc/mmc_private.h	2021-06-07 13:01:32.000000000 +0300
@@ -12,6 +12,7 @@
 
 #include <mmc.h>
 
+extern int mmc_send_tuning(struct mmc *mmc, u32 opcode);
 extern int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
 			struct mmc_data *data);
 extern int mmc_send_status(struct mmc *mmc, int timeout);
diff -uraN u-boot-2016.11/drivers/mmc/rpmb.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mmc/rpmb.c
--- u-boot-2016.11/drivers/mmc/rpmb.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mmc/rpmb.c	2021-06-07 13:01:32.000000000 +0300
@@ -67,7 +67,7 @@
 	unsigned char mac[RPMB_SZ_MAC];
 	unsigned char data[RPMB_SZ_DATA];
 	unsigned char nonce[RPMB_SZ_NONCE];
-	unsigned long write_counter;
+	unsigned int write_counter;
 	unsigned short address;
 	unsigned short block_count;
 	unsigned short result;
diff -uraN u-boot-2016.11/drivers/mmc/sdhci.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mmc/sdhci.c
--- u-boot-2016.11/drivers/mmc/sdhci.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mmc/sdhci.c	2021-06-07 13:01:32.000000000 +0300
@@ -20,6 +20,172 @@
 void *aligned_buffer;
 #endif
 
+static void sdhci_dumpregs(struct sdhci_host *host)
+{
+	printf("=========== REGISTER DUMP (mmc%d)===========\n", host->index);
+
+	printf("Sys addr: 0x%08x | Version:  0x%08x\n",
+			sdhci_readl(host, SDHCI_DMA_ADDRESS),
+			sdhci_readw(host, SDHCI_HOST_VERSION));
+	printf("Blk size: 0x%08x | Blk cnt:  0x%08x\n",
+			sdhci_readw(host, SDHCI_BLOCK_SIZE),
+			sdhci_readw(host, SDHCI_BLOCK_COUNT));
+	printf("Argument: 0x%08x | Trn mode: 0x%08x\n",
+			sdhci_readl(host, SDHCI_ARGUMENT),
+			sdhci_readw(host, SDHCI_TRANSFER_MODE));
+	printf("Present:  0x%08x | Host ctl: 0x%08x\n",
+			sdhci_readl(host, SDHCI_PRESENT_STATE),
+			sdhci_readb(host, SDHCI_HOST_CONTROL));
+	printf("Power:    0x%08x | Blk gap:  0x%08x\n",
+			sdhci_readb(host, SDHCI_POWER_CONTROL),
+			sdhci_readb(host, SDHCI_BLOCK_GAP_CONTROL));
+	printf("Wake-up:  0x%08x | Clock:    0x%08x\n",
+			sdhci_readb(host, SDHCI_WAKE_UP_CONTROL),
+			sdhci_readw(host, SDHCI_CLOCK_CONTROL));
+	printf("Timeout:  0x%08x | Int stat: 0x%08x\n",
+			sdhci_readb(host, SDHCI_TIMEOUT_CONTROL),
+			sdhci_readl(host, SDHCI_INT_STATUS));
+	printf("Int enab: 0x%08x | Sig enab: 0x%08x\n",
+			sdhci_readl(host, SDHCI_INT_ENABLE),
+			sdhci_readl(host, SDHCI_SIGNAL_ENABLE));
+	printf("ACMD err: 0x%08x | Slot int: 0x%08x\n",
+			sdhci_readw(host, SDHCI_ACMD12_ERR),
+			sdhci_readw(host, SDHCI_SLOT_INT_STATUS));
+	printf("Caps:     0x%08x | Caps_1:   0x%08x\n",
+			sdhci_readl(host, SDHCI_CAPABILITIES),
+			sdhci_readl(host, SDHCI_CAPABILITIES_1));
+	printf("Cmd:      0x%08x | Max curr: 0x%08x\n",
+			sdhci_readw(host, SDHCI_COMMAND),
+			sdhci_readl(host, SDHCI_MAX_CURRENT));
+	printf("Host ctl2: 0x%08x | ADMA Err: 0x%08x\n",
+			sdhci_readw(host, SDHCI_HOST_CONTROL2),
+			sdhci_readl(host, SDHCI_ADMA_ERROR));
+
+	printf(" ADMA Ptr: 0x%08x_%08x\n",
+			sdhci_readl(host, SDHCI_ADMA_ADDRESS_HI),
+			sdhci_readl(host, SDHCI_ADMA_ADDRESS));
+
+	printf("===========================================\n");
+}
+
+#ifdef CONFIG_SDHCI_ADMA
+static void sdhci_adma_write_desc(void *desc,
+		dma_addr_t addr, int len, unsigned int cmd)
+{
+#ifdef CONFIG_PHYS_64BIT
+	struct sdhci_adma2_64_desc *dma_desc = desc;
+#else
+	struct sdhci_adma2_32_desc *dma_desc = desc;
+#endif
+
+	/* 32-bit and 64-bit descriptors have these members in same position */
+	dma_desc->cmd = cpu_to_le16(cmd);
+	dma_desc->len = cpu_to_le16(len);
+	dma_desc->addr_lo = cpu_to_le32((u32)addr);
+
+#ifdef CONFIG_PHYS_64BIT
+	dma_desc->addr_hi = cpu_to_le32((u64)addr >> 32);
+#endif
+}
+
+#define ADMA2_TRAN_VALID	0x21
+#define ADMA2_NOP_END_VALID	0x3
+
+static int sdhci_adma_table_pre(struct sdhci_host *host,
+		struct mmc_data *data, unsigned int trans_bytes)
+{
+	dma_addr_t addr;
+	void *desc = host->adma_table;
+	unsigned int left = trans_bytes;
+	int len;
+	int is_aligned = 1;
+
+	addr = (dma_addr_t)(uintptr_t)(data->flags == MMC_DATA_READ ?
+			data->src : data->dest);
+
+	/*
+	 * If dma buffer isn't cache line aligned, set is_aligned to be zero,
+	 * and return.
+	 */
+	if ((addr & (CONFIG_SYS_CACHELINE_SIZE - 1)) != 0x0) {
+		is_aligned = 0;
+		goto exit;
+	}
+
+	while (left >= host->max_seg_size) {
+		if (((addr & (SDHCI_DMA_BOUNDARY_SIZE - 1))
+			+ host->max_seg_size) > SDHCI_DMA_BOUNDARY_SIZE) {
+			len = SDHCI_DMA_BOUNDARY_SIZE -
+				    (addr & (SDHCI_DMA_BOUNDARY_SIZE - 1));
+		} else
+			len = host->max_seg_size;
+		sdhci_adma_write_desc(desc, addr, len, ADMA2_TRAN_VALID);
+		addr += len;
+		left -= len;
+		desc += host->desc_sz;
+	}
+
+	if (left) {
+		if (((addr & (SDHCI_DMA_BOUNDARY_SIZE - 1))
+				+ left) > SDHCI_DMA_BOUNDARY_SIZE) {
+			len = SDHCI_DMA_BOUNDARY_SIZE -
+				    (addr & (SDHCI_DMA_BOUNDARY_SIZE - 1));
+			sdhci_adma_write_desc(desc, addr, len, ADMA2_TRAN_VALID);
+			addr += len;
+			left -= len;
+			desc += host->desc_sz;
+		}
+
+		sdhci_adma_write_desc(desc, addr, left, ADMA2_TRAN_VALID);
+		desc += host->desc_sz;
+	}
+
+	sdhci_adma_write_desc(desc, 0, 0, ADMA2_NOP_END_VALID);
+exit:
+	return is_aligned;
+}
+
+static int sdhci_prep_data(struct sdhci_host *host,
+		struct mmc_data *data, unsigned int trans_bytes)
+{
+	unsigned char ctrl;
+	unsigned long bytes;
+	int is_aligned;
+
+	/* If dma buffer isn't cache line aligned, don't use dma mode. */
+	is_aligned = sdhci_adma_table_pre(host, data, trans_bytes);
+	if (!is_aligned)
+		goto exit;
+
+	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
+	ctrl &= ~SDHCI_CTRL_DMA_MASK;
+#ifdef CONFIG_PHYS_64BIT
+	ctrl |= SDHCI_CTRL_ADMA64;
+#else
+	ctrl |= SDHCI_CTRL_ADMA32;
+#endif
+	sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
+
+	sdhci_writel(host, (u32)(uintptr_t)host->adma_table, SDHCI_ADMA_ADDRESS);
+#ifdef CONFIG_PHYS_64BIT
+	sdhci_writel(host, (u64)(uintptr_t)host->adma_table >> 32, /* upper 32bits */
+			SDHCI_ADMA_ADDRESS_HI);
+#endif
+	bytes = ALIGN(trans_bytes, CONFIG_SYS_CACHELINE_SIZE);
+	if (data->flags != MMC_DATA_READ)
+		flush_cache((unsigned long)(uintptr_t)data->src, bytes);
+	else
+		invalidate_dcache_range((unsigned long)(uintptr_t)data->dest,
+				(unsigned long)(uintptr_t)data->dest + bytes);
+
+	bytes = ALIGN(host->adma_table_sz, CONFIG_SYS_CACHELINE_SIZE);
+	flush_cache((unsigned long)(uintptr_t)host->adma_table, bytes);
+
+exit:
+	return is_aligned;
+}
+#endif
+
 static void sdhci_reset(struct sdhci_host *host, u8 mask)
 {
 	unsigned long timeout;
@@ -71,7 +237,7 @@
 static int sdhci_transfer_data(struct sdhci_host *host, struct mmc_data *data,
 				unsigned int start_addr)
 {
-	unsigned int stat, rdy, mask, timeout, block = 0;
+	unsigned int stat, rdy, mask, timeout;
 #ifdef CONFIG_MMC_SDMA
 	unsigned char ctrl;
 	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
@@ -85,8 +251,11 @@
 	do {
 		stat = sdhci_readl(host, SDHCI_INT_STATUS);
 		if (stat & SDHCI_INT_ERROR) {
-			printf("%s: Error detected in status(0x%X)!\n",
-			       __func__, stat);
+			if (!host->is_tuning) {
+				printf("%s: Error detected in status(0x%X)!\n",
+						__func__, stat);
+				sdhci_dumpregs(host);
+			}
 			return -EIO;
 		}
 		if (stat & rdy) {
@@ -95,8 +264,6 @@
 			sdhci_writel(host, rdy, SDHCI_INT_STATUS);
 			sdhci_transfer_pio(host, data);
 			data->dest += data->blocksize;
-			if (++block >= data->blocks)
-				break;
 		}
 #ifdef CONFIG_MMC_SDMA
 		if (stat & SDHCI_INT_DMA_END) {
@@ -110,9 +277,11 @@
 			udelay(10);
 		else {
 			printf("%s: Transfer data timeout\n", __func__);
+			sdhci_dumpregs(host);
 			return -ETIMEDOUT;
 		}
 	} while (!(stat & SDHCI_INT_DATA_END));
+
 	return 0;
 }
 
@@ -141,11 +310,15 @@
 	struct sdhci_host *host = mmc->priv;
 	unsigned int stat = 0;
 	int ret = 0;
-	int trans_bytes = 0, is_aligned = 1;
+#if defined(CONFIG_SDHCI_ADMA) || defined(CONFIG_MMC_SDMA)
+	unsigned int trans_bytes = 0;
+	int is_aligned = 1;
+#endif
 	u32 mask, flags, mode;
-	unsigned int time = 0, start_addr = 0;
+	unsigned int time = 0;
+	unsigned int start_addr = 0;
+	unsigned int start;
 	int mmc_dev = mmc_get_blk_desc(mmc)->devnum;
-	unsigned start = get_timer(0);
 
 	/* Timeout unit - ms */
 	static unsigned int cmd_timeout = SDHCI_CMD_DEFAULT_TIMEOUT;
@@ -197,42 +370,62 @@
 	if (data != 0) {
 		sdhci_writeb(host, 0xe, SDHCI_TIMEOUT_CONTROL);
 		mode = SDHCI_TRNS_BLK_CNT_EN;
+#if defined(CONFIG_SDHCI_ADMA) || defined(CONFIG_MMC_SDMA)
 		trans_bytes = data->blocks * data->blocksize;
+#endif
 		if (data->blocks > 1)
 			mode |= SDHCI_TRNS_MULTI;
 
 		if (data->flags == MMC_DATA_READ)
 			mode |= SDHCI_TRNS_READ;
 
+#ifdef CONFIG_SDHCI_ADMA
+		/*
+		 * If buffer is cache line aligned, use dma mode, otherwise,
+		 * don't use dma mode.
+		 */
+		is_aligned = sdhci_prep_data(host, data, trans_bytes);
+		if (is_aligned)
+			mode |= SDHCI_TRNS_DMA;
+#endif
+
 #ifdef CONFIG_MMC_SDMA
 		if (data->flags == MMC_DATA_READ)
 			start_addr = (unsigned long)data->dest;
 		else
 			start_addr = (unsigned long)data->src;
-		if ((host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR) &&
-				(start_addr & 0x7) != 0x0) {
+
+		/*
+		 * If buffer isn't cache line aligned , but defined
+		 * CONFIG_FIXED_SDHCI_ALIGNED_BUFFER,
+		 * use aligend_buffer to store the data for dma,
+		 * otherwise, don't use dma mode.
+		 */
+		if ((start_addr & (CONFIG_SYS_CACHELINE_SIZE - 1)) != 0x0) {
+#if defined(CONFIG_FIXED_SDHCI_ALIGNED_BUFFER)
+			/*
+			 * Always use this bounce-buffer when
+			 * CONFIG_FIXED_SDHCI_ALIGNED_BUFFER is defined
+			 */
 			is_aligned = 0;
 			start_addr = (unsigned long)aligned_buffer;
 			if (data->flags != MMC_DATA_READ)
 				memcpy(aligned_buffer, data->src, trans_bytes);
-		}
+#else
 
-#if defined(CONFIG_FIXED_SDHCI_ALIGNED_BUFFER)
-		/*
-		 * Always use this bounce-buffer when
-		 * CONFIG_FIXED_SDHCI_ALIGNED_BUFFER is defined
-		 */
-		is_aligned = 0;
-		start_addr = (unsigned long)aligned_buffer;
-		if (data->flags != MMC_DATA_READ)
-			memcpy(aligned_buffer, data->src, trans_bytes);
+			is_aligned = 0;
+			goto no_dma;
 #endif
+		}
+
 
 		sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
 		mode |= SDHCI_TRNS_DMA;
+no_dma:
+
 #endif
 		sdhci_writew(host, SDHCI_MAKE_BLKSZ(SDHCI_DEFAULT_BOUNDARY_ARG,
-				data->blocksize),
+					data->blocksize),
 				SDHCI_BLOCK_SIZE);
 		sdhci_writew(host, data->blocks, SDHCI_BLOCK_COUNT);
 		sdhci_writew(host, mode, SDHCI_TRANSFER_MODE);
@@ -241,9 +434,22 @@
 	}
 
 	sdhci_writel(host, cmd->cmdarg, SDHCI_ARGUMENT);
+
 #ifdef CONFIG_MMC_SDMA
+	/*
+	 * Execute to here, if has defined CONFIG_FIXED_SDHCI_ALIGNED_BUFFER or
+	 * is_aligned is 1, we should flush cache for start_addr. Otherwise, we do nothing.
+	 */
+#if defined(CONFIG_FIXED_SDHCI_ALIGNED_BUFFER)
 	trans_bytes = ALIGN(trans_bytes, CONFIG_SYS_CACHELINE_SIZE);
 	flush_cache(start_addr, trans_bytes);
+#else
+	if (is_aligned) {
+		trans_bytes = ALIGN(trans_bytes, CONFIG_SYS_CACHELINE_SIZE);
+		flush_cache(start_addr, trans_bytes);
+	}
+#endif
+
 #endif
 	sdhci_writew(host, SDHCI_MAKE_CMD(cmd->cmdidx, flags), SDHCI_COMMAND);
 	start = get_timer(0);
@@ -278,9 +484,15 @@
 	stat = sdhci_readl(host, SDHCI_INT_STATUS);
 	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_STATUS);
 	if (!ret) {
-		if ((host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR) &&
-				!is_aligned && (data->flags == MMC_DATA_READ))
+		/*
+		 * If used aligend_buffer, we should copy data from
+		 * aliagned_buffer to dest buffer when executing dma
+		 * read operation.
+		 */
+#if defined(CONFIG_FIXED_SDHCI_ALIGNED_BUFFER)
+		if (!is_aligned && (data->flags == MMC_DATA_READ))
 			memcpy(data->dest, aligned_buffer, trans_bytes);
+#endif
 		return 0;
 	}
 
@@ -360,7 +572,7 @@
 	}
 
 	if (host->set_clock)
-		host->set_clock(host->index, div);
+		return host->set_clock(host, clock);
 
 	clk |= (div & SDHCI_DIV_MASK) << SDHCI_DIVIDER_SHIFT;
 	clk |= ((div & SDHCI_DIV_HI_MASK) >> SDHCI_DIV_MASK_LEN)
@@ -419,6 +631,30 @@
 	sdhci_writeb(host, pwr, SDHCI_POWER_CONTROL);
 }
 
+static void sdhci_set_uhs_signaling(struct sdhci_host *host, u8 timing)
+{
+	u16 ctrl_2;
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	/* Select Bus Speed Mode for host */
+	ctrl_2 &= ~SDHCI_CTRL_UHS_MASK;
+	if ((timing == MMC_TIMING_MMC_HS200) ||
+			(timing == MMC_TIMING_UHS_SDR104))
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR104;
+	else if (timing == MMC_TIMING_UHS_SDR12)
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR12;
+	else if (timing == MMC_TIMING_UHS_SDR25)
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR25;
+	else if (timing == MMC_TIMING_UHS_SDR50)
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR50;
+	else if ((timing == MMC_TIMING_UHS_DDR50) ||
+			(timing == MMC_TIMING_MMC_DDR52))
+		ctrl_2 |= SDHCI_CTRL_UHS_DDR50;
+	else if (timing == MMC_TIMING_MMC_HS400)
+		ctrl_2 |= SDHCI_CTRL_HS400; /* Non-standard */
+	sdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);
+}
+
 #ifdef CONFIG_DM_MMC_OPS
 static int sdhci_set_ios(struct udevice *dev)
 {
@@ -462,6 +698,8 @@
 		ctrl &= ~SDHCI_CTRL_HISPD;
 
 	sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
+
+	sdhci_set_uhs_signaling(host, mmc->timing);
 #ifdef CONFIG_DM_MMC_OPS
 	return 0;
 #endif
@@ -473,15 +711,6 @@
 
 	sdhci_reset(host, SDHCI_RESET_ALL);
 
-	if ((host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR) && !aligned_buffer) {
-		aligned_buffer = memalign(8, 512*1024);
-		if (!aligned_buffer) {
-			printf("%s: Aligned buffer alloc failed!!!\n",
-			       __func__);
-			return -ENOMEM;
-		}
-	}
-
 	sdhci_set_power(host, fls(mmc->cfg->voltages) - 1);
 
 	if (host->quirks & SDHCI_QUIRK_NO_CD) {
@@ -504,6 +733,9 @@
 #endif
 	}
 
+	if (host->priv_init)
+		host->priv_init(host);
+
 	/* Enable only interrupts served by the SD controller */
 	sdhci_writel(host, SDHCI_INT_DATA_MASK | SDHCI_INT_CMD_MASK,
 		     SDHCI_INT_ENABLE);
@@ -513,6 +745,27 @@
 	return 0;
 }
 
+static int sdhci_execute_tuning(struct mmc *mmc, unsigned int opcode)
+{
+	struct sdhci_host *host = mmc->priv;
+
+	if (host->execute_tuning)
+		return host->execute_tuning(host, opcode);
+
+	return 0;
+}
+
+static int sdhci_card_busy(struct mmc *mmc)
+{
+	struct sdhci_host *host = mmc->priv;
+	u32 present_state;
+
+	/* Check whether DAT[0] is 0 */
+	present_state = sdhci_readl(host, SDHCI_PRESENT_STATE);
+
+	return !(present_state & SDHCI_DATA_0_LVL_MASK);
+}
+
 #ifdef CONFIG_DM_MMC_OPS
 int sdhci_probe(struct udevice *dev)
 {
@@ -530,6 +783,9 @@
 	.send_cmd	= sdhci_send_command,
 	.set_ios	= sdhci_set_ios,
 	.init		= sdhci_init,
+	.hs400_enable_es = sdhci_hs400_enhanced_stobe,
+	.execute_tuning = sdhci_execute_tuning,
+	.card_busy = sdhci_card_busy,
 };
 #endif
 
@@ -592,16 +848,9 @@
 	if (host->quirks & SDHCI_QUIRK_BROKEN_VOLTAGE)
 		cfg->voltages |= host->voltages;
 
-	cfg->host_caps = MMC_MODE_HS | MMC_MODE_HS_52MHz | MMC_MODE_4BIT;
-	if (SDHCI_GET_VERSION(host) >= SDHCI_SPEC_300) {
-		if (caps & SDHCI_CAN_DO_8BIT)
-			cfg->host_caps |= MMC_MODE_8BIT;
-	}
-
 	if (host->host_caps)
 		cfg->host_caps |= host->host_caps;
 
-
 	cfg->b_max = CONFIG_SYS_MMC_MAX_BLK_COUNT;
 
 	/*
diff -uraN u-boot-2016.11/drivers/mtd/fmc_common.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/fmc_common.c
--- u-boot-2016.11/drivers/mtd/fmc_common.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/fmc_common.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,134 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+/*****************************************************************************/
+#include <fmc_common.h>
+#include <common.h>
+#include <asm/io.h>
+#include <errno.h>
+
+#define BUFF_LEN			20
+
+/*****************************************************************************/
+static unsigned char fmc_current_dev_type = FLASH_TYPE_DEFAULT;
+static unsigned char fmc_boot_dev_type = FLASH_TYPE_DEFAULT;
+
+/*****************************************************************************/
+unsigned char fmc_ip_user;
+unsigned char fmc_cs_user[CONFIG_FMC_MAX_CS_NUM];
+
+/*****************************************************************************/
+void *get_fmc_ip(void)
+{
+	return &fmc_ip_user;
+}
+/*****************************************************************************/
+unsigned char *get_cs_number(unsigned char cs)
+{
+	return fmc_cs_user + cs;
+}
+/*****************************************************************************/
+int fmc_ip_ver_check(void)
+{
+	unsigned int fmc_ip_ver;
+#ifndef CONFIG_MINI_BOOT
+	printf("Check Flash Memory Controller v100 ...");
+#endif
+	fmc_ip_ver = readl(CONFIG_FMC_REG_BASE + FMC_VERSION);
+	if (fmc_ip_ver != FMC_VER_100) {
+		printf("\n");
+		return -EFAULT;
+	}
+#ifndef CONFIG_MINI_BOOT
+	printf(" Found\n");
+#endif
+
+	return 0;
+}
+
+/*****************************************************************************/
+void fmc_dev_type_switch(unsigned char type)
+{
+	unsigned int reg, spi_device_type, flash_type;
+	const char *str[] = {"SPI nor", "SPI nand", "Nand", "Boot"};
+
+	if (fmc_current_dev_type == type)
+		return;
+
+	fmc_pr(BT_DBG, "\t|*-Start switch current device type\n");
+
+	if (type > FLASH_TYPE_DEFAULT) {
+		fmc_pr(BT_DBG, "\t||-Switch unknown device type %d\n", type);
+		return;
+	}
+
+	if (fmc_boot_dev_type == FLASH_TYPE_DEFAULT) {
+		reg = readl((void *)(SYS_CTRL_REG_BASE + REG_SYSSTAT));
+		fmc_pr(BT_DBG, "\t||-Get system STATUS[%#x]%#x\n",
+		       SYS_CTRL_REG_BASE + REG_SYSSTAT, reg);
+		fmc_boot_dev_type = get_spi_device_type(reg);
+		fmc_pr(BT_DBG, "\t||-Init boot device type to %s flash\n",
+		       str[fmc_boot_dev_type]);
+	}
+
+	if (type == FLASH_TYPE_DEFAULT)
+		spi_device_type = fmc_boot_dev_type;
+	else
+		spi_device_type = type;
+
+	fmc_pr(BT_DBG, "\t||-Switch type to %s flash\n", str[type]);
+
+	reg = readl((void *)(CONFIG_FMC_REG_BASE + FMC_CFG));
+	fmc_pr(BT_DBG, "\t||-Get FMC CFG[%#x]%#x\n", FMC_CFG, reg);
+	flash_type = (reg & FLASH_SEL_MASK) >> FLASH_SEL_SHIFT;
+	if (spi_device_type != flash_type) {
+		reg &= ~FLASH_SEL_MASK;
+		reg |= fmc_cfg_flash_sel(spi_device_type);
+		writel(reg, (void *)(CONFIG_FMC_REG_BASE + FMC_CFG));
+		fmc_pr(BT_DBG, "\t||-Set FMC CFG[%#x]%#x\n", FMC_CFG, reg);
+	}
+	fmc_current_dev_type = spi_device_type;
+
+	fmc_pr(BT_DBG, "\t|*-End switch current device type\n");
+}
+
+/*****************************************************************************/
+char *ulltostr(unsigned long long size)
+{
+	int ix;
+	static char buffer[BUFF_LEN];
+	char *fmt[] = {"%u", "%uK", "%uM", "%uG", "%uT"};
+	/* 4 size type ,0x3ff Obtains the lower six bits*/
+	for (ix = 0; (ix < 4) && !(size & 0x3FF) && size; ix++)
+		size = (size >> 10); /* byte to kb, right left 10 */
+
+	sprintf(buffer, fmt[ix], size);
+	return buffer;
+}
+
+/*****************************************************************************/
+void debug_register_dump(void)
+{
+	unsigned int ix;
+	unsigned long base = CONFIG_FMC_REG_BASE;
+
+	printf("Register dump:");
+	/* 0x98  Register length , 4 is Byte */
+	for (ix = 0; ix <= 0x98; ix += 0x04) {
+		if (!(ix & 0x0F))
+			printf("\n0x%08lX: ", base + ix);
+		printf("%08X ", readl((void *)(uintptr_t)(base + ix)));
+	}
+	printf("\n");
+}
+/*****************************************************************************/
+/* REG_SYSSTAT 0: 3 Bytes address boot mode; 1: 4Bytes address boot mode */
+unsigned int get_fmc_boot_mode(void)
+{
+	unsigned int regval;
+	unsigned int boot_mode;
+	regval = readl(SYS_CTRL_REG_BASE + REG_SYSSTAT);
+	boot_mode = get_spi_nor_addr_mode(regval);
+	return boot_mode;
+}
diff -uraN u-boot-2016.11/drivers/mtd/fmc_gk7202v300.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/fmc_gk7202v300.c
--- u-boot-2016.11/drivers/mtd/fmc_gk7202v300.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/fmc_gk7202v300.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,141 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/platform.h>
+#include <fmc_common.h>
+
+#include "fmc_spi_ids.h"
+
+#define REG_IO_BASE 0x100c0000
+static void gk7202v300_io_config_spi_sfc(void)
+{
+	/* set pad ctrl reg for spi */
+	writel(0x401, REG_IO_BASE + 0x14);    /* sfc_clk */
+	writel(0x461, REG_IO_BASE + 0x18);    /* sfc_hold_io0 */
+	writel(0x461, REG_IO_BASE + 0x1c);    /* sfc_miso_io1 */
+	writel(0x461, REG_IO_BASE + 0x20);    /* sfc_wp_io2 */
+	writel(0x461, REG_IO_BASE + 0x24);    /* sfc_mosi_io3 */
+	writel(0x461, REG_IO_BASE + 0x28);   /* sfc_csn */
+}
+
+static void gk7202v300_io_config_spi_sdio(void)
+{
+	/* set pad ctrl reg for spi */
+	writel(0x461, REG_IO_BASE + 0x60);    /* SDIO1_CCLK_OUT */
+	writel(0x561, REG_IO_BASE + 0x64);    /* SDIO1_CCMD */
+	writel(0x461, REG_IO_BASE + 0x68);    /* SDIO1_CDATA0 */
+	writel(0x561, REG_IO_BASE + 0x6c);    /* SDIO1_CDATA1 */
+	writel(0x531, REG_IO_BASE + 0x70);    /* SDIO1_CDATA2 */
+	writel(0x461, REG_IO_BASE + 0x74);   /* SDIO1_CDATA3 */
+}
+/*****************************************************************************/
+void fmc_set_fmc_system_clock(struct spi_op *op, int clk_en)
+{
+	unsigned int old_val;
+	unsigned int regval;
+	unsigned int sysstat_val;
+
+	sysstat_val = readl(SYS_CTRL_REG_BASE + REG_SC_SYSSTAT);
+
+	old_val = regval = readl(CRG_REG_BASE + REG_FMC_CRG);
+
+	regval &= ~FMC_CLK_SEL_MASK;
+
+	if (op && op->clock) {
+		regval |= op->clock & FMC_CLK_SEL_MASK;
+		fmc_pr(DTR_DB, "\t|||*-get the setting clock value: %#x\n",
+			op->clock);
+	} else {
+		regval |= fmc_clk_sel(FMC_CLK_24M); /* Default Clock */
+		if (spi_input_sle(sysstat_val))
+			gk7202v300_io_config_spi_sdio();
+		else
+			gk7202v300_io_config_spi_sfc();
+	}
+	if (clk_en)
+		regval |= FMC_CLK_ENABLE;
+	else
+		regval &= ~FMC_CLK_ENABLE;
+
+	if (regval != old_val) {
+		fmc_pr(DTR_DB, "\t|||*-setting system clock [%#x]%#x\n",
+			REG_FMC_CRG, regval);
+		writel(regval, (CRG_REG_BASE + REG_FMC_CRG));
+	}
+}
+
+/*****************************************************************************/
+void fmc_get_fmc_best_2x_clock(unsigned int *clock)
+{
+	int ix;
+	unsigned int clk_reg;
+	unsigned int clk_type;
+	const char *str[] = {"12", "50", "75", "100"};
+
+	unsigned int sys_2x_clk[] = {
+		clk_2x(24), fmc_clk_sel(FMC_CLK_24M),
+		clk_2x(100), fmc_clk_sel(FMC_CLK_100M),
+		clk_2x(150), fmc_clk_sel(FMC_CLK_150M),
+		clk_2x(200), fmc_clk_sel(FMC_CLK_200M),
+		0,      0,
+	};
+
+	clk_type = FMC_CLK_24M;
+	clk_reg = fmc_clk_sel(clk_type);
+	fmc_pr(QE_DBG, "\t|||*-matching flash clock %d\n", *clock);
+	for (ix = 0; sys_2x_clk[ix]; ix += _2B) {
+		if (*clock < sys_2x_clk[ix])
+			break;
+		clk_reg = sys_2x_clk[ix + 1];
+		clk_type = get_fmc_clk_type(clk_reg);
+		fmc_pr(QE_DBG, "\t||||-select system clock: %sMHz\n",
+			str[clk_type]);
+	}
+#ifdef CONFIG_DTR_MODE_SUPPORT
+	fmc_pr(DTR_DB, "best system clock for SDR.\n");
+#endif
+	fmc_pr(QE_DBG, "\t|||*-matched best system clock: %sMHz\n",
+		str[clk_type]);
+	*clock = clk_reg;
+}
+
+#ifdef CONFIG_DTR_MODE_SUPPORT
+/*****************************************************************************/
+void fmc_get_fmc_best_4x_clock(unsigned int *clock)
+{
+	int ix;
+	unsigned int clk_reg;
+	unsigned int clk_type;
+	char *const str[] = {"6", "25", "37.5", "50", "75", "90"};
+
+	unsigned int sys_4x_clk[] = {
+		clk_4x(24), fmc_clk_sel(FMC_CLK_24M),
+		clk_4x(100), fmc_clk_sel(FMC_CLK_100M),
+		clk_4x(150), fmc_clk_sel(FMC_CLK_150M),
+		clk_4x(200), fmc_clk_sel(FMC_CLK_200M),
+		clk_4x(300), fmc_clk_sel(FMC_CLK_300M),
+		clk_4x(360), fmc_clk_sel(FMC_CLK_360M),
+		0,      0,
+	};
+
+	clk_type = FMC_CLK_24M;
+	clk_reg = fmc_clk_sel(clk_type);
+	fmc_pr(DTR_DB, "\t|||*-matching flash clock %d\n", *clock);
+	for (ix = 0; sys_4x_clk[ix]; ix += _2B) {
+		if (*clock < sys_4x_clk[ix])
+			break;
+		clk_reg = sys_4x_clk[ix + 1];
+		clk_type = get_fmc_clk_type(clk_reg);
+		fmc_pr(DTR_DB, "\t||||-select system clock: %sMHz\n",
+			str[clk_type]);
+	}
+	fmc_pr(DTR_DB, "best system clock for DTR.\n");
+	fmc_pr(DTR_DB, "\t|||*-matched best system clock: %sMHz\n",
+		str[clk_type]);
+	*clock = clk_reg;
+}
+/*****************************************************************************/
+#endif/* CONFIG_DTR_MODE_SUPPORT */
diff -uraN u-boot-2016.11/drivers/mtd/fmc_gk7205v200.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/fmc_gk7205v200.c
--- u-boot-2016.11/drivers/mtd/fmc_gk7205v200.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/fmc_gk7205v200.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,141 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/platform.h>
+#include <fmc_common.h>
+
+#include "fmc_spi_ids.h"
+
+#define REG_IO_BASE 0x100c0000
+static void gk7205v200_io_config_spi_sfc(void)
+{
+	/* set pad ctrl reg for spi */
+	writel(0x401, REG_IO_BASE + 0x14);    /* sfc_clk */
+	writel(0x461, REG_IO_BASE + 0x18);    /* sfc_hold_io0 */
+	writel(0x461, REG_IO_BASE + 0x1c);    /* sfc_miso_io1 */
+	writel(0x461, REG_IO_BASE + 0x20);    /* sfc_wp_io2 */
+	writel(0x461, REG_IO_BASE + 0x24);    /* sfc_mosi_io3 */
+	writel(0x461, REG_IO_BASE + 0x28);   /* sfc_csn */
+}
+
+static void gk7205v200_io_config_spi_sdio(void)
+{
+	/* set pad ctrl reg for spi */
+	writel(0x461, REG_IO_BASE + 0x60);    /* SDIO1_CCLK_OUT */
+	writel(0x561, REG_IO_BASE + 0x64);    /* SDIO1_CCMD */
+	writel(0x461, REG_IO_BASE + 0x68);    /* SDIO1_CDATA0 */
+	writel(0x561, REG_IO_BASE + 0x6c);    /* SDIO1_CDATA1 */
+	writel(0x531, REG_IO_BASE + 0x70);    /* SDIO1_CDATA2 */
+	writel(0x461, REG_IO_BASE + 0x74);   /* SDIO1_CDATA3 */
+}
+/*****************************************************************************/
+void fmc_set_fmc_system_clock(struct spi_op *op, int clk_en)
+{
+	unsigned int old_val;
+	unsigned int regval;
+	unsigned int sysstat_val;
+
+	sysstat_val = readl(SYS_CTRL_REG_BASE + REG_SC_SYSSTAT);
+
+	old_val = regval = readl(CRG_REG_BASE + REG_FMC_CRG);
+
+	regval &= ~FMC_CLK_SEL_MASK;
+
+	if (op && op->clock) {
+		regval |= op->clock & FMC_CLK_SEL_MASK;
+		fmc_pr(DTR_DB, "\t|||*-get the setting clock value: %#x\n",
+			op->clock);
+	} else {
+		regval |= fmc_clk_sel(FMC_CLK_24M); /* Default Clock */
+		if (spi_input_sle(sysstat_val))
+			gk7205v200_io_config_spi_sdio();
+		else
+			gk7205v200_io_config_spi_sfc();
+	}
+	if (clk_en)
+		regval |= FMC_CLK_ENABLE;
+	else
+		regval &= ~FMC_CLK_ENABLE;
+
+	if (regval != old_val) {
+		fmc_pr(DTR_DB, "\t|||*-setting system clock [%#x]%#x\n",
+			REG_FMC_CRG, regval);
+		writel(regval, (CRG_REG_BASE + REG_FMC_CRG));
+	}
+}
+
+/*****************************************************************************/
+void fmc_get_fmc_best_2x_clock(unsigned int *clock)
+{
+	int ix;
+	unsigned int clk_reg;
+	unsigned int clk_type;
+	const char *str[] = {"12", "50", "75", "100"};
+
+	unsigned int sys_2x_clk[] = {
+		clk_2x(24), fmc_clk_sel(FMC_CLK_24M),
+		clk_2x(100), fmc_clk_sel(FMC_CLK_100M),
+		clk_2x(150), fmc_clk_sel(FMC_CLK_150M),
+		clk_2x(200), fmc_clk_sel(FMC_CLK_200M),
+		0,      0,
+	};
+
+	clk_type = FMC_CLK_24M;
+	clk_reg = fmc_clk_sel(clk_type);
+	fmc_pr(QE_DBG, "\t|||*-matching flash clock %d\n", *clock);
+	for (ix = 0; sys_2x_clk[ix]; ix += _2B) {
+		if (*clock < sys_2x_clk[ix])
+			break;
+		clk_reg = sys_2x_clk[ix + 1];
+		clk_type = get_fmc_clk_type(clk_reg);
+		fmc_pr(QE_DBG, "\t||||-select system clock: %sMHz\n",
+			str[clk_type]);
+	}
+#ifdef CONFIG_DTR_MODE_SUPPORT
+	fmc_pr(DTR_DB, "best system clock for SDR.\n");
+#endif
+	fmc_pr(QE_DBG, "\t|||*-matched best system clock: %sMHz\n",
+		str[clk_type]);
+	*clock = clk_reg;
+}
+
+#ifdef CONFIG_DTR_MODE_SUPPORT
+/*****************************************************************************/
+void fmc_get_fmc_best_4x_clock(unsigned int *clock)
+{
+	int ix;
+	unsigned int clk_reg;
+	unsigned int clk_type;
+	char *const str[] = {"6", "25", "37.5", "50", "75", "90"};
+
+	unsigned int sys_4x_clk[] = {
+		clk_4x(24), fmc_clk_sel(FMC_CLK_24M),
+		clk_4x(100), fmc_clk_sel(FMC_CLK_100M),
+		clk_4x(150), fmc_clk_sel(FMC_CLK_150M),
+		clk_4x(200), fmc_clk_sel(FMC_CLK_200M),
+		clk_4x(300), fmc_clk_sel(FMC_CLK_300M),
+		clk_4x(360), fmc_clk_sel(FMC_CLK_360M),
+		0,      0,
+	};
+
+	clk_type = FMC_CLK_24M;
+	clk_reg = fmc_clk_sel(clk_type);
+	fmc_pr(DTR_DB, "\t|||*-matching flash clock %d\n", *clock);
+	for (ix = 0; sys_4x_clk[ix]; ix += _2B) {
+		if (*clock < sys_4x_clk[ix])
+			break;
+		clk_reg = sys_4x_clk[ix + 1];
+		clk_type = get_fmc_clk_type(clk_reg);
+		fmc_pr(DTR_DB, "\t||||-select system clock: %sMHz\n",
+			str[clk_type]);
+	}
+	fmc_pr(DTR_DB, "best system clock for DTR.\n");
+	fmc_pr(DTR_DB, "\t|||*-matched best system clock: %sMHz\n",
+		str[clk_type]);
+	*clock = clk_reg;
+}
+/*****************************************************************************/
+#endif/* CONFIG_DTR_MODE_SUPPORT */
diff -uraN u-boot-2016.11/drivers/mtd/fmc_gk7205v300.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/fmc_gk7205v300.c
--- u-boot-2016.11/drivers/mtd/fmc_gk7205v300.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/fmc_gk7205v300.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,141 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/platform.h>
+#include <fmc_common.h>
+
+#include "fmc_spi_ids.h"
+
+#define REG_IO_BASE 0x100c0000
+static void gk7205v300_io_config_spi_sfc(void)
+{
+	/* set pad ctrl reg for spi */
+	writel(0x401, REG_IO_BASE + 0x14);    /* sfc_clk */
+	writel(0x461, REG_IO_BASE + 0x18);    /* sfc_hold_io0 */
+	writel(0x461, REG_IO_BASE + 0x1c);    /* sfc_miso_io1 */
+	writel(0x461, REG_IO_BASE + 0x20);    /* sfc_wp_io2 */
+	writel(0x461, REG_IO_BASE + 0x24);    /* sfc_mosi_io3 */
+	writel(0x461, REG_IO_BASE + 0x28);   /* sfc_csn */
+}
+
+static void gk7205v300_io_config_spi_sdio(void)
+{
+	/* set pad ctrl reg for spi */
+	writel(0x401, REG_IO_BASE + 0x60);    /* SDIO1_CCLK_OUT */
+	writel(0x451, REG_IO_BASE + 0x64);    /* SDIO1_CCMD */
+	writel(0x451, REG_IO_BASE + 0x68);    /* SDIO1_CDATA0 */
+	writel(0x451, REG_IO_BASE + 0x6c);    /* SDIO1_CDATA1 */
+	writel(0x421, REG_IO_BASE + 0x70);    /* SDIO1_CDATA2 */
+	writel(0x451, REG_IO_BASE + 0x74);   /* SDIO1_CDATA3 */
+}
+/*****************************************************************************/
+void fmc_set_fmc_system_clock(struct spi_op *op, int clk_en)
+{
+	unsigned int old_val;
+	unsigned int regval;
+	unsigned int sysstat_val;
+
+	sysstat_val = readl(SYS_CTRL_REG_BASE + REG_SC_SYSSTAT);
+
+	old_val = regval = readl(CRG_REG_BASE + REG_FMC_CRG);
+
+	regval &= ~FMC_CLK_SEL_MASK;
+
+	if (op && op->clock) {
+		regval |= op->clock & FMC_CLK_SEL_MASK;
+		fmc_pr(DTR_DB, "\t|||*-get the setting clock value: %#x\n",
+			op->clock);
+	} else {
+		regval |= fmc_clk_sel(FMC_CLK_24M); /* Default Clock */
+		if (spi_input_sle(sysstat_val))
+			gk7205v300_io_config_spi_sdio();
+		else
+			gk7205v300_io_config_spi_sfc();
+	}
+	if (clk_en)
+		regval |= FMC_CLK_ENABLE;
+	else
+		regval &= ~FMC_CLK_ENABLE;
+
+	if (regval != old_val) {
+		fmc_pr(DTR_DB, "\t|||*-setting system clock [%#x]%#x\n",
+			REG_FMC_CRG, regval);
+		writel(regval, (CRG_REG_BASE + REG_FMC_CRG));
+	}
+}
+
+/*****************************************************************************/
+void fmc_get_fmc_best_2x_clock(unsigned int *clock)
+{
+	int ix;
+	unsigned int clk_reg;
+	unsigned int clk_type;
+	const char *str[] = {"12", "50", "75", "100"};
+
+	unsigned int sys_2x_clk[] = {
+		clk_2x(24), fmc_clk_sel(FMC_CLK_24M),
+		clk_2x(100), fmc_clk_sel(FMC_CLK_100M),
+		clk_2x(150), fmc_clk_sel(FMC_CLK_150M),
+		clk_2x(200), fmc_clk_sel(FMC_CLK_200M),
+		0,      0,
+	};
+
+	clk_type = FMC_CLK_24M;
+	clk_reg = fmc_clk_sel(clk_type);
+	fmc_pr(QE_DBG, "\t|||*-matching flash clock %d\n", *clock);
+	for (ix = 0; sys_2x_clk[ix]; ix += _2B) {
+		if (*clock < sys_2x_clk[ix])
+			break;
+		clk_reg = sys_2x_clk[ix + 1];
+		clk_type = get_fmc_clk_type(clk_reg);
+		fmc_pr(QE_DBG, "\t||||-select system clock: %sMHz\n",
+			str[clk_type]);
+	}
+#ifdef CONFIG_DTR_MODE_SUPPORT
+	fmc_pr(DTR_DB, "best system clock for SDR.\n");
+#endif
+	fmc_pr(QE_DBG, "\t|||*-matched best system clock: %sMHz\n",
+	       str[clk_type]);
+	*clock = clk_reg;
+}
+
+#ifdef CONFIG_DTR_MODE_SUPPORT
+/*****************************************************************************/
+void fmc_get_fmc_best_4x_clock(unsigned int *clock)
+{
+	int ix;
+	unsigned int clk_reg;
+	unsigned int clk_type;
+	char *const str[] = {"6", "25", "37.5", "50", "75", "90"};
+
+	unsigned int sys_4x_clk[] = {
+		clk_4x(24), fmc_clk_sel(FMC_CLK_24M),
+		clk_4x(100), fmc_clk_sel(FMC_CLK_100M),
+		clk_4x(150), fmc_clk_sel(FMC_CLK_150M),
+		clk_4x(200), fmc_clk_sel(FMC_CLK_200M),
+		clk_4x(300), fmc_clk_sel(FMC_CLK_300M),
+		clk_4x(360), fmc_clk_sel(FMC_CLK_360M),
+		0,      0,
+	};
+
+	clk_type = FMC_CLK_24M;
+	clk_reg = fmc_clk_sel(clk_type);
+	fmc_pr(DTR_DB, "\t|||*-matching flash clock %d\n", *clock);
+	for (ix = 0; sys_4x_clk[ix]; ix += _2B) {
+		if (*clock < sys_4x_clk[ix])
+			break;
+		clk_reg = sys_4x_clk[ix + 1];
+		clk_type = get_fmc_clk_type(clk_reg);
+		fmc_pr(DTR_DB, "\t||||-select system clock: %sMHz\n",
+			str[clk_type]);
+	}
+	fmc_pr(DTR_DB, "best system clock for DTR.\n");
+	fmc_pr(DTR_DB, "\t|||*-matched best system clock: %sMHz\n",
+		str[clk_type]);
+	*clock = clk_reg;
+}
+/*****************************************************************************/
+#endif/* CONFIG_DTR_MODE_SUPPORT */
diff -uraN u-boot-2016.11/drivers/mtd/fmc_gk7605v100.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/fmc_gk7605v100.c
--- u-boot-2016.11/drivers/mtd/fmc_gk7605v100.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/fmc_gk7605v100.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,141 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/platform.h>
+#include <fmc_common.h>
+
+#include "fmc_spi_ids.h"
+
+#define REG_IO_BASE 0x100c0000
+static void gk7605v100_io_config_spi_sfc(void)
+{
+	/* set pad ctrl reg for spi */
+	writel(0x401, REG_IO_BASE + 0x14);    /* sfc_clk */
+	writel(0x461, REG_IO_BASE + 0x18);    /* sfc_hold_io0 */
+	writel(0x461, REG_IO_BASE + 0x1c);    /* sfc_miso_io1 */
+	writel(0x461, REG_IO_BASE + 0x20);    /* sfc_wp_io2 */
+	writel(0x461, REG_IO_BASE + 0x24);    /* sfc_mosi_io3 */
+	writel(0x461, REG_IO_BASE + 0x28);   /* sfc_csn */
+}
+
+static void gk7605v100_io_config_spi_sdio(void)
+{
+	/* set pad ctrl reg for spi */
+	writel(0x401, REG_IO_BASE + 0x60);    /* SDIO1_CCLK_OUT */
+	writel(0x451, REG_IO_BASE + 0x64);    /* SDIO1_CCMD */
+	writel(0x451, REG_IO_BASE + 0x68);    /* SDIO1_CDATA0 */
+	writel(0x451, REG_IO_BASE + 0x6c);    /* SDIO1_CDATA1 */
+	writel(0x421, REG_IO_BASE + 0x70);    /* SDIO1_CDATA2 */
+	writel(0x451, REG_IO_BASE + 0x74);   /* SDIO1_CDATA3 */
+}
+/*****************************************************************************/
+void fmc_set_fmc_system_clock(struct spi_op *op, int clk_en)
+{
+	unsigned int old_val;
+	unsigned int regval;
+	unsigned int sysstat_val;
+
+	sysstat_val = readl(SYS_CTRL_REG_BASE + REG_SC_SYSSTAT);
+
+	old_val = regval = readl(CRG_REG_BASE + REG_FMC_CRG);
+
+	regval &= ~FMC_CLK_SEL_MASK;
+
+	if (op && op->clock) {
+		regval |= op->clock & FMC_CLK_SEL_MASK;
+		fmc_pr(DTR_DB, "\t|||*-get the setting clock value: %#x\n",
+			op->clock);
+	} else {
+		regval |= fmc_clk_sel(FMC_CLK_24M); /* Default Clock */
+		if (spi_input_sle(sysstat_val))
+			gk7605v100_io_config_spi_sdio();
+		else
+			gk7605v100_io_config_spi_sfc();
+	}
+	if (clk_en)
+		regval |= FMC_CLK_ENABLE;
+	else
+		regval &= ~FMC_CLK_ENABLE;
+
+	if (regval != old_val) {
+		fmc_pr(DTR_DB, "\t|||*-setting system clock [%#x]%#x\n",
+		       REG_FMC_CRG, regval);
+		writel(regval, (CRG_REG_BASE + REG_FMC_CRG));
+	}
+}
+
+/*****************************************************************************/
+void fmc_get_fmc_best_2x_clock(unsigned int *clock)
+{
+	int ix;
+	unsigned int clk_reg;
+	unsigned int clk_type;
+	const char *str[] = {"12", "50", "75", "100"};
+
+	unsigned int sys_2x_clk[] = {
+		clk_2x(24), fmc_clk_sel(FMC_CLK_24M),
+		clk_2x(100),    fmc_clk_sel(FMC_CLK_100M),
+		clk_2x(150),    fmc_clk_sel(FMC_CLK_150M),
+		clk_2x(200),    fmc_clk_sel(FMC_CLK_200M),
+		0,      0,
+	};
+
+	clk_type = FMC_CLK_24M;
+	clk_reg = fmc_clk_sel(clk_type);
+	fmc_pr(QE_DBG, "\t|||*-matching flash clock %d\n", *clock);
+	for (ix = 0; sys_2x_clk[ix]; ix += _2B) {
+		if (*clock < sys_2x_clk[ix])
+			break;
+		clk_reg = sys_2x_clk[ix + 1];
+		clk_type = get_fmc_clk_type(clk_reg);
+		fmc_pr(QE_DBG, "\t||||-select system clock: %sMHz\n",
+		       str[clk_type]);
+	}
+#ifdef CONFIG_DTR_MODE_SUPPORT
+	fmc_pr(DTR_DB, "best system clock for SDR.\n");
+#endif
+	fmc_pr(QE_DBG, "\t|||*-matched best system clock: %sMHz\n",
+	       str[clk_type]);
+	*clock = clk_reg;
+}
+
+#ifdef CONFIG_DTR_MODE_SUPPORT
+/*****************************************************************************/
+void fmc_get_fmc_best_4x_clock(unsigned int *clock)
+{
+	int ix;
+	unsigned int clk_reg;
+	unsigned int clk_type;
+	char *const str[] = {"6", "25", "37.5", "50", "75", "90"};
+
+	unsigned int sys_4x_clk[] = {
+		clk_4x(24), fmc_clk_sel(FMC_CLK_24M),
+		clk_4x(100), fmc_clk_sel(FMC_CLK_100M),
+		clk_4x(150), fmc_clk_sel(FMC_CLK_150M),
+		clk_4x(200), fmc_clk_sel(FMC_CLK_200M),
+		clk_4x(300), fmc_clk_sel(FMC_CLK_300M),
+		clk_4x(360), fmc_clk_sel(FMC_CLK_360M),
+		0,	0,
+	};
+
+	clk_type = FMC_CLK_24M;
+	clk_reg = fmc_clk_sel(clk_type);
+	fmc_pr(DTR_DB, "\t|||*-matching flash clock %d\n", *clock);
+	for (ix = 0; sys_4x_clk[ix]; ix += _2B) {
+		if (*clock < sys_4x_clk[ix])
+			break;
+		clk_reg = sys_4x_clk[ix + 1];
+		clk_type = get_fmc_clk_type(clk_reg);
+		fmc_pr(DTR_DB, "\t||||-select system clock: %sMHz\n",
+			str[clk_type]);
+	}
+	fmc_pr(DTR_DB, "best system clock for DTR.\n");
+	fmc_pr(DTR_DB, "\t|||*-matched best system clock: %sMHz\n",
+		str[clk_type]);
+	*clock = clk_reg;
+}
+/*****************************************************************************/
+#endif/* CONFIG_DTR_MODE_SUPPORT */
diff -uraN u-boot-2016.11/drivers/mtd/fmc_spi_ids.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/fmc_spi_ids.h
--- u-boot-2016.11/drivers/mtd/fmc_spi_ids.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/fmc_spi_ids.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,447 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __FMC_SPI_IDS_H__
+#define __FMC_SPI_IDS_H__
+
+#include "fmc_common.h"
+/*****************************************************************************/
+#define INFINITE			0xFFFFFFFF
+
+/*****************************************************************************/
+#define SPI_IF_READ_STD		 	0x01
+#define SPI_IF_READ_FAST		0x02
+#define SPI_IF_READ_DUAL		0x04
+#define SPI_IF_READ_DUAL_ADDR	   	0x08
+#define SPI_IF_READ_QUAD		0x10
+#define SPI_IF_READ_QUAD_ADDR	   	0x20
+#define SPI_IF_READ_QUAD_DTR		0x40
+
+#define SPI_IF_WRITE_STD		0x01
+#define SPI_IF_WRITE_DUAL	  	0x02
+#define SPI_IF_WRITE_DUAL_ADDR	  	0x04
+#define SPI_IF_WRITE_QUAD	   	0x08
+#define SPI_IF_WRITE_QUAD_ADDR	  	0x10
+
+#define SPI_IF_ERASE_SECTOR_4K	  	0x01
+#define SPI_IF_ERASE_SECTOR_32K	 	0x02
+#define SPI_IF_ERASE_SECTOR_64K	 	0x04
+#define SPI_IF_ERASE_SECTOR_128K	0x08
+#define SPI_IF_ERASE_SECTOR_256K	0x10
+
+/*****************************************************************************/
+#define FMC_SPI_NOR_SUPPORT_READ  (SPI_IF_READ_STD | \
+					SPI_IF_READ_FAST | \
+					SPI_IF_READ_DUAL | \
+					SPI_IF_READ_DUAL_ADDR | \
+					SPI_IF_READ_QUAD | \
+					SPI_IF_READ_QUAD_ADDR | \
+					SPI_IF_READ_QUAD_DTR)
+
+#define FMC_SPI_NOR_SUPPORT_WRITE (SPI_IF_WRITE_STD | \
+					SPI_IF_WRITE_DUAL | \
+					SPI_IF_WRITE_DUAL_ADDR | \
+					SPI_IF_WRITE_QUAD | \
+					SPI_IF_WRITE_QUAD_ADDR)
+
+#define FMC_SPI_NOR_STR_MAX_DUMMY	 7
+#define FMC_SPI_NOR_DTR_MAX_DUMMY	 12
+
+/******************************************************************************/
+#define FMC_SPI_NAND_SUPPORT_READ (SPI_IF_READ_STD | \
+					SPI_IF_READ_FAST | \
+					SPI_IF_READ_DUAL | \
+					SPI_IF_READ_DUAL_ADDR | \
+					SPI_IF_READ_QUAD | \
+					SPI_IF_READ_QUAD_ADDR)
+
+#define FMC_SPI_NAND_SUPPORT_WRITE	(SPI_IF_WRITE_STD | SPI_IF_WRITE_QUAD)
+
+#define FMC_SPI_NAND_SUPPORT_MAX_DUMMY	8
+
+/*****************************************************************************/
+#define SPI_CMD_READ_STD	0x03  /* Standard read cache */
+#define SPI_CMD_READ_STD4B	0x13  /* Standard read cache 4byte mode */
+#define SPI_CMD_READ_FAST	0x0B  /* Higher speed read cache */
+#define SPI_CMD_READ_FAST4B	0x0C  /* Higher speed read cache 4byte mode */
+#define SPI_CMD_READ_DUAL	0x3B  /* 2 IO read cache only date */
+#define SPI_CMD_READ_DUAL4B	0x3C  /* 2 IO read cache only date 4byte mode */
+#define SPI_CMD_READ_DUAL_ADDR	0xBB  /* 2 IO read cache date&addr */
+#define SPI_CMD_READ_DUAL_ADDR4B 0xBC /* 2 IO read cache date&addr 4byte mode */
+#define SPI_CMD_READ_QUAD	0x6B  /* 4 IO read cache only date */
+#define SPI_CMD_READ_QUAD4B	0x6C  /* 4 IO read cache only date 4byte mode */
+#define SPI_CMD_READ_QUAD_ADDR	0xEB  /* 4 IO read cache date&addr */
+#define SPI_CMD_READ_QUAD_ADDR4B 0xEC /* 4 IO read cache date&addr 4byte mode */
+#define SPI_CMD_READ_QUAD_DTR	0xED /* 4DTR MODE */
+#define SPI_CMD_READ_QUAD_DTR4B	0xEE /* 4DTR MODE 4byte mode */
+#define SPI_CMD_READ_QUAD_DTR4B_WINBOND	0xEC /* 4DTR MODE */
+
+#define SPI_CMD_WRITE_STD	0x02 /* Standard page program */
+#define SPI_CMD_WRITE_STD4B	0x12 /* Standard page program 4byte mode */
+#define SPI_CMD_WRITE_DUAL	0xA2 /* 2 IO program only date */
+#define SPI_CMD_WRITE_DUAL4B	0xA2 /* 2 IO program only date 4byte mode */
+#define SPI_CMD_WRITE_DUAL_ADDR	 0xD2 /* 2 IO program date&addr */
+#define SPI_CMD_WRITE_DUAL_ADDR4B 0xD2 /* 2 IO program date&addr 4byte mode */
+#define SPI_CMD_WRITE_QUAD	0x32 /* 4 IO program only date */
+#define SPI_CMD_WRITE_QUAD4B	0x34 /* 4 IO program only date 4byte mode */
+#define SPI_CMD_WRITE_QUAD_ADDR	 0x38 /* 4 IO program date&addr */
+#define SPI_CMD_WRITE_QUAD_ADDR4B 0x3E /* 4 IO program date&addr 4byte mode */
+
+#define SPI_CMD_SE_4K	0x20 /* 4KB sector Erase */
+#define SPI_CMD_SE_4K4B	0x21 /* 4KB sector Erase 4byte mode */
+#define SPI_CMD_SE_32K	0x52 /* 32KB sector Erase */
+#define SPI_CMD_SE_32K4B 0x5C /* 32KB sector Erase 4byte mode */
+#define SPI_CMD_SE_64K	0xD8 /* 64KB sector Erase */
+#define SPI_CMD_SE_64K4B 0xDC /* 64KB sector Erase 4byte mode */
+#define SPI_CMD_SE_128K	 0xD8 /* 128KB sector Erase */
+#define SPI_CMD_SE_128K4B 0xD8 /* 128KB sector Erase 4byte mode */
+#define SPI_CMD_SE_256K	 0xD8 /* 256KB sector Erase */
+#define SPI_CMD_SE_256K4B 0xD8 /* 256KB sector Erase 4byte mode */
+
+/*****************************************************************************/
+#define set_read_std(_dummy_, _size_, _clk_) \
+	static struct spi_op read_std_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_READ_STD, SPI_CMD_READ_STD, _dummy_, _size_, _clk_ }
+
+#define set_read_std4b(_dummy_, _size_, _clk_) \
+	static struct spi_op read_std4b_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_READ_STD, SPI_CMD_READ_STD4B, _dummy_, _size_, _clk_ }
+
+#define set_read_fast(_dummy_, _size_, _clk_) \
+	static struct spi_op read_fast_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_READ_FAST, SPI_CMD_READ_FAST, _dummy_, _size_, _clk_ }
+
+#define set_read_fast4b(_dummy_, _size_, _clk_) \
+	static struct spi_op read_fast4b_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_READ_FAST, SPI_CMD_READ_FAST4B, _dummy_, _size_, _clk_ }
+
+#define set_read_dual(_dummy_, _size_, _clk_) \
+	static struct spi_op read_dual_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_READ_DUAL, SPI_CMD_READ_DUAL, _dummy_, _size_, _clk_ }
+
+#define set_read_dual4b(_dummy_, _size_, _clk_) \
+	static struct spi_op read_dual4b_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_READ_DUAL, SPI_CMD_READ_DUAL4B, _dummy_, _size_, _clk_ }
+
+#define set_read_dual_addr(_dummy_, _size_, _clk_) \
+	static struct spi_op read_dual_addr_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_READ_DUAL_ADDR, SPI_CMD_READ_DUAL_ADDR, _dummy_, _size_, _clk_ }
+
+#define set_read_dual_addr4b(_dummy_, _size_, _clk_) \
+	static struct spi_op read_dual_addr4b_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_READ_DUAL_ADDR, SPI_CMD_READ_DUAL_ADDR4B, _dummy_, _size_, _clk_ }
+
+#define set_read_quad(_dummy_, _size_, _clk_) \
+	static struct spi_op read_quad_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_READ_QUAD, SPI_CMD_READ_QUAD, _dummy_, _size_, _clk_ }
+
+#define set_read_quad4b(_dummy_, _size_, _clk_) \
+	static struct spi_op read_quad4b_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_READ_QUAD, SPI_CMD_READ_QUAD4B, _dummy_, _size_, _clk_ }
+
+#define set_read_quad_addr(_dummy_, _size_, _clk_) \
+	static struct spi_op read_quad_addr_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_READ_QUAD_ADDR, SPI_CMD_READ_QUAD_ADDR, _dummy_, _size_, _clk_ }
+
+#define set_read_quad_addr4b(_dummy_, _size_, _clk_) \
+	static struct spi_op read_quad_addr4b_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_READ_QUAD_ADDR, SPI_CMD_READ_QUAD_ADDR4B, _dummy_, _size_, _clk_ }
+
+#ifdef CONFIG_DTR_MODE_SUPPORT
+#define set_read_quad_dtr(_dummy_, _size_, _clk_) \
+	static struct spi_op read_quad_dtr_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_READ_QUAD_DTR, SPI_CMD_READ_QUAD_DTR, _dummy_, _size_, _clk_ }
+
+#define set_read_quad_dtr4b(_dummy_, _size_, _clk_) \
+	static struct spi_op read_quad_dtr4b_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_READ_QUAD_DTR, SPI_CMD_READ_QUAD_DTR4B, _dummy_, _size_, _clk_ }
+
+#define set_read_quad_dtr4b_winbond(_dummy_, _size_, _clk_) \
+	static struct spi_op read_quad_dtr_winbond_##_dummy_##_size_##_clk_ = \
+	{SPI_IF_READ_QUAD_DTR, SPI_CMD_READ_QUAD_DTR4B_WINBOND, \
+		_dummy_, _size_, _clk_ }
+#endif
+
+/*****************************************************************************/
+#define set_write_std(_dummy_, _size_, _clk_) \
+	static struct spi_op write_std_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_WRITE_STD, SPI_CMD_WRITE_STD, _dummy_, _size_, _clk_ }
+
+#define set_write_std4b(_dummy_, _size_, _clk_) \
+	static struct spi_op write_std4b_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_WRITE_STD, SPI_CMD_WRITE_STD4B, _dummy_, _size_, _clk_ }
+
+#define set_write_dual(_dummy_, _size_, _clk_) \
+	static struct spi_op write_dual_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_WRITE_DUAL, SPI_CMD_WRITE_DUAL, _dummy_, _size_, _clk_ }
+
+#define set_write_dual4b(_dummy_, _size_, _clk_) \
+	static struct spi_op write_dual4b_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_WRITE_DUAL, SPI_CMD_WRITE_DUAL4B, _dummy_, _size_, _clk_ }
+
+#define set_write_dual_addr(_dummy_, _size_, _clk_) \
+	static struct spi_op write_dual_addr_##_dummy_##_size_##_clk_ = { \
+SPI_IF_WRITE_DUAL_ADDR, SPI_CMD_WRITE_DUAL_ADDR, _dummy_, _size_, _clk_ }
+
+#define set_write_dual_addr4b(_dummy_, _size_, _clk_) \
+	static struct spi_op write_dual_addr4b_##_dummy_##_size_##_clk_ = { \
+SPI_IF_WRITE_DUAL_ADDR, SPI_CMD_WRITE_DUAL_ADDR4B, _dummy_, _size_, _clk_ }
+
+#define set_write_quad(_dummy_, _size_, _clk_) \
+	static struct spi_op write_quad_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_WRITE_QUAD, SPI_CMD_WRITE_QUAD, _dummy_, _size_, _clk_ }
+
+#define set_write_quad4b(_dummy_, _size_, _clk_) \
+	static struct spi_op write_quad4b_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_WRITE_QUAD, SPI_CMD_WRITE_QUAD4B, _dummy_, _size_, _clk_ }
+
+#define set_write_quad_addr(_dummy_, _size_, _clk_) \
+	static struct spi_op write_quad_addr_##_dummy_##_size_##_clk_ = { \
+SPI_IF_WRITE_QUAD_ADDR, SPI_CMD_WRITE_QUAD_ADDR, _dummy_, _size_, _clk_ }
+
+#define set_write_quad_addr4b(_dummy_, _size_, _clk_) \
+	static struct spi_op write_quad_addr4b_##_dummy_##_size_##_clk_ = { \
+SPI_IF_WRITE_QUAD_ADDR, SPI_CMD_WRITE_QUAD_ADDR4B, _dummy_, _size_, _clk_ }
+
+/*****************************************************************************/
+#define set_erase_sector_4k(_dummy_, _size_, _clk_) \
+	static struct spi_op erase_sector_4k_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_ERASE_SECTOR_4K, SPI_CMD_SE_4K, _dummy_, _size_, _clk_ }
+
+#define set_erase_sector_4k4b(_dummy_, _size_, _clk_) \
+	static struct spi_op erase_sector_4k4b_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_ERASE_SECTOR_4K, SPI_CMD_SE_4K4B, _dummy_, _size_, _clk_ }
+
+#define set_erase_sector_32k(_dummy_, _size_, _clk_) \
+	static struct spi_op erase_sector_32k_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_ERASE_SECTOR_32K, SPI_CMD_SE_32K, _dummy_, _size_, _clk_ }
+
+#define set_erase_sector_32k4b(_dummy_, _size_, _clk_) \
+	static struct spi_op erase_sector_32k4b_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_ERASE_SECTOR_32K, SPI_CMD_SE_32K4B, _dummy_, _size_, _clk_ }
+
+#define set_erase_sector_64k(_dummy_, _size_, _clk_) \
+	static struct spi_op erase_sector_64k_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_ERASE_SECTOR_64K, SPI_CMD_SE_64K, _dummy_, _size_, _clk_ }
+
+#define set_erase_sector_64k4b(_dummy_, _size_, _clk_) \
+	static struct spi_op erase_sector_64k4b_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_ERASE_SECTOR_64K, SPI_CMD_SE_64K4B, _dummy_, _size_, _clk_ }
+
+#define set_erase_sector_128k(_dummy_, _size_, _clk_) \
+	static struct spi_op erase_sector_128k_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_ERASE_SECTOR_128K, SPI_CMD_SE_128K, _dummy_, _size_, _clk_ }
+
+#define set_erase_sector_128k4b(_dummy_, _size_, _clk_) \
+	static struct spi_op erase_sector_128k4b_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_ERASE_SECTOR_128K, SPI_CMD_SE_128K4B, _dummy_, _size_, _clk_ }
+
+#define set_erase_sector_256k(_dummy_, _size_, _clk_) \
+	static struct spi_op erase_sector_256k_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_ERASE_SECTOR_256K, SPI_CMD_SE_256K, _dummy_, _size_, _clk_ }
+
+#define set_erase_sector_256k4b(_dummy_, _size_, _clk_) \
+	static struct spi_op erase_sector_256k4b_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_ERASE_SECTOR_256K, SPI_CMD_SE_256K4B, _dummy_, _size_, _clk_ }
+
+/*****************************************************************************/
+#define read_std(_dummy_, _size_, _clk_) read_std_##_dummy_##_size_##_clk_
+#define read_std4b(_dummy_, _size_, _clk_) read_std4b_##_dummy_##_size_##_clk_
+#define read_fast(_dummy_, _size_, _clk_) read_fast_##_dummy_##_size_##_clk_
+#define read_fast4b(_dummy_, _size_, _clk_) \
+					read_fast4b_##_dummy_##_size_##_clk_
+#define read_dual(_dummy_, _size_, _clk_) read_dual_##_dummy_##_size_##_clk_
+#define read_dual4b(_dummy_, _size_, _clk_) \
+					read_dual4b_##_dummy_##_size_##_clk_
+#define read_dual_addr(_dummy_, _size_, _clk_) \
+		read_dual_addr_##_dummy_##_size_##_clk_
+#define read_dual_addr4b(_dummy_, _size_, _clk_) \
+		read_dual_addr4b_##_dummy_##_size_##_clk_
+#define read_quad(_dummy_, _size_, _clk_) read_quad_##_dummy_##_size_##_clk_
+#define read_quad4b(_dummy_, _size_, _clk_) \
+					read_quad4b_##_dummy_##_size_##_clk_
+#define read_quad_addr(_dummy_, _size_, _clk_) \
+		read_quad_addr_##_dummy_##_size_##_clk_
+#define read_quad_addr4b(_dummy_, _size_, _clk_) \
+		read_quad_addr4b_##_dummy_##_size_##_clk_
+#ifdef CONFIG_DTR_MODE_SUPPORT
+#define read_quad_dtr(_dummy_, _size_, _clk_) \
+		read_quad_dtr_##_dummy_##_size_##_clk_
+#define read_quad_dtr4b(_dummy_, _size_, _clk_) \
+		read_quad_dtr4b_##_dummy_##_size_##_clk_
+#define read_quad_dtr4b_winbond(_dummy_, _size_, _clk_) \
+		read_quad_dtr4b_winbond_##_dummy_##_size_##_clk_
+#endif
+
+/*****************************************************************************/
+#define write_std(_dummy_, _size_, _clk_) write_std_##_dummy_##_size_##_clk_
+#define write_std4b(_dummy_, _size_, _clk_) \
+					write_std4b_##_dummy_##_size_##_clk_
+#define write_dual(_dummy_, _size_, _clk_) write_dual_##_dummy_##_size_##_clk_
+#define write_dual4b(_dummy_, _size_, _clk_) \
+					write_dual4b_##_dummy_##_size_##_clk_
+#define write_dual_addr(_dummy_, _size_, _clk_) \
+		write_dual_addr_##_dummy_##_size_##_clk_
+#define write_dual_addr4b(_dummy_, _size_, _clk_) \
+		write_dual_addr4b_##_dummy_##_size_##_clk_
+#define write_quad(_dummy_, _size_, _clk_) write_quad_##_dummy_##_size_##_clk_
+#define write_quad4b(_dummy_, _size_, _clk_) \
+					write_quad4b_##_dummy_##_size_##_clk_
+#define write_quad_addr(_dummy_, _size_, _clk_) \
+		write_quad_addr_##_dummy_##_size_##_clk_
+#define write_quad_addr4b(_dummy_, _size_, _clk_) \
+		write_quad_addr4b_##_dummy_##_size_##_clk_
+
+/*****************************************************************************/
+#define erase_sector_4k(_dummy_, _size_, _clk_) \
+		erase_sector_4k_##_dummy_##_size_##_clk_
+#define erase_sector_4k4b(_dummy_, _size_, _clk_) \
+		erase_sector_4k4b_##_dummy_##_size_##_clk_
+#define erase_sector_32k(_dummy_, _size_, _clk_) \
+		erase_sector_32k_##_dummy_##_size_##_clk_
+#define erase_sector_32k4b(_dummy_, _size_, _clk_) \
+		erase_sector_32k4b_##_dummy_##_size_##_clk_
+#define erase_sector_64k(_dummy_, _size_, _clk_) \
+		erase_sector_64k_##_dummy_##_size_##_clk_
+#define erase_sector_64k4b(_dummy_, _size_, _clk_) \
+		erase_sector_64k4b_##_dummy_##_size_##_clk_
+#define erase_sector_128k(_dummy_, _size_, _clk_) \
+		erase_sector_128k_##_dummy_##_size_##_clk_
+#define erase_sector_128k4b(_dummy_, _size_, _clk_) \
+		erase_sector_128k4b_##_dummy_##_size_##_clk_
+#define erase_sector_256k(_dummy_, _size_, _clk_) \
+		erase_sector_256k_##_dummy_##_size_##_clk_
+#define erase_sector_256k4b(_dummy_, _size_, _clk_) \
+		erase_sector_256k4b_##_dummy_##_size_##_clk_
+
+/*****************************************************************************/
+#define SPI_CMD_WREN			0x06 /* Write Enable */
+#define SPI_CMD_WRDI			0x04 /* Write Disable */
+
+/*****************************************************************************/
+#define SPI_CMD_WRSR			0x01 /* Write Status Register */
+#define SPI_CMD_WRSR2			0x31 /* Write Status Register-2 */
+#define SPI_CMD_WRSR3			0x11 /* Write Status Register-3 */
+
+#define SPI_CMD_RDSR			0x05 /* Read Status Register */
+#define SPI_CMD_RDSR2			0x35 /* Read Status Register-2 */
+#define SPI_CMD_RDSR3			0x15 /* Read Status Register-3 */
+
+#define SPI_CMD_RDCR			0x35 /* Read Config Register */
+
+#define SPI_CMD_RDID			0x9F /* Read Identification */
+
+#define SPI_CMD_RD_SFDP			0x5A /* Read SFDP */
+/*****************************************************************************/
+#define SPI_CMD_GET_FEATURES		0x0F /* Get Features */
+#define SPI_CMD_SET_FEATURE		0x1F /* Set Feature */
+
+#define SPI_CMD_PAGE_READ		0x13 /* Page Read to Cache */
+
+#define SPI_CMD_RESET			0xff /* Reset the device */
+
+/*****************************************************************************/
+#define SPI_CMD_EN4B	0xB7 /* enter 4 bytes mode and set 4 byte bit as '1' */
+#define SPI_CMD_EX4B	0xE9 /* exit 4 bytes mode and clear 4 byte bit */
+
+/*****************************************************************************/
+#define MAX_SPI_OP		  8
+
+/*****************************************************************************/
+/* SPI general operation parameter */
+struct spi_op {
+	unsigned char iftype;
+	unsigned char cmd;
+	unsigned char dummy;
+	unsigned int size;
+	unsigned int clock;
+};
+
+struct spi_drv;
+
+/* SPI interface all operation */
+struct fmc_spi {
+	char *name;
+	unsigned int chipselect;
+	unsigned long long chipsize;
+	unsigned int erasesize;
+#define SPI_NOR_3BYTE_ADDR_LEN  3   /* address len 3Bytes */
+#define SPI_NOR_4BYTE_ADDR_LEN  4   /* address len 4Bytes for 32MB */
+	unsigned int addrcycle;
+
+	struct spi_op read[1];
+	struct spi_op write[1];
+	struct spi_op erase[MAX_SPI_OP];
+
+	void *host;
+
+	struct spi_drv *driver;
+#ifdef CONFIG_DTR_MODE_SUPPORT
+	unsigned int dtr_mode_support;
+	/* @dtr_cookie: Some device must set some registers when wants to
+	 * work on DTR mode, so this cookie tells us to set s.th */
+	unsigned int dtr_cookie;
+#define DTR_MODE_SET_NONE 0x0   /* Need not set anything */
+#define DTR_MODE_SET_ODS  0x1   /* Need to set output driver strength */
+#endif
+};
+
+/* SPI interface special operation function hook */
+struct spi_drv {
+	int (*wait_ready)(struct fmc_spi *spi);
+	int (*write_enable)(struct fmc_spi *spi);
+	int (*qe_enable)(struct fmc_spi *spi);
+	int (*bus_prepare)(struct fmc_spi *spi, int op);
+	int (*entry_4addr)(struct fmc_spi *spi, int en);
+#ifdef CONFIG_DTR_MODE_SUPPORT
+	int (*dtr_set_device)(struct fmc_spi *spi, int dtr_en);
+#endif
+};
+#ifndef MAX_SPI_NAND_ID_LEN
+#define MAX_SPI_NAND_ID_LEN 1
+#endif
+struct spi_nand_info {
+	char *name;
+	unsigned char id[MAX_SPI_NAND_ID_LEN];
+	unsigned char id_len;
+	unsigned long long chipsize;
+	unsigned int erasesize;
+	unsigned int pagesize;
+	unsigned int oobsize;
+#define BBP_LAST_PAGE	   0x01
+#define BBP_FIRST_PAGE	  0x02
+	unsigned int badblock_pos;
+	struct spi_op *read[MAX_SPI_OP];
+	struct spi_op *write[MAX_SPI_OP];
+	struct spi_op *erase[MAX_SPI_OP];
+	struct spi_drv *driver;
+};
+
+#ifndef MAX_SPI_NOR_ID_LEN
+#define MAX_SPI_NOR_ID_LEN 8
+#endif
+
+struct spi_nor_info {
+	char *name;
+	unsigned char id[MAX_SPI_NOR_ID_LEN];
+	unsigned int id_len;
+	unsigned long chipsize;
+	unsigned int erasesize;
+	unsigned int addrcycle;
+	struct spi_op *read[MAX_SPI_OP];
+	struct spi_op *write[MAX_SPI_OP];
+	struct spi_op *erase[MAX_SPI_OP];
+	struct spi_drv *driver;
+};
+
+/*****************************************************************************/
+void fmc_set_fmc_system_clock(struct spi_op *op, int clk_en);
+
+void fmc_get_fmc_best_2x_clock(unsigned int *clock);
+#ifdef CONFIG_DTR_MODE_SUPPORT
+void fmc_get_fmc_best_4x_clock(unsigned int *clock);
+#endif
+/*****************************************************************************/
+
+#endif /* End of __FMC_SPI_IDS_H__ */
\ No newline at end of file
diff -uraN u-boot-2016.11/drivers/mtd/Kconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/Kconfig
--- u-boot-2016.11/drivers/mtd/Kconfig	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/Kconfig	2021-06-07 13:01:32.000000000 +0300
@@ -35,6 +35,13 @@
 	  This enables access to Microchip PIC32 internal non-CFI flash
 	  chips through PIC32 Non-Volatile-Memory Controller.
 
+config FMC
+	bool "Enable FMC - Goke Flash Memory Controller"
+	depends on TARGET_GK7205V200 || TARGET_GK7205V300 || TARGET_GK7202V300 || TARGET_GK7605V100
+	help
+	  Goke Flash Memory Controller support SPI Nor SPI Nand often used on
+	  embedded chip. This option will provide the generic support for FMC drivers to register.
+
 endmenu
 
 source "drivers/mtd/nand/Kconfig"
diff -uraN u-boot-2016.11/drivers/mtd/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/Makefile
--- u-boot-2016.11/drivers/mtd/Makefile	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -22,3 +22,8 @@
 obj-$(CONFIG_FLASH_PIC32) += pic32_flash.o
 obj-$(CONFIG_ST_SMI) += st_smi.o
 obj-$(CONFIG_STM32_FLASH) += stm32_flash.o
+obj-$(CONFIG_FMC) += fmc_common.o
+obj-$(CONFIG_TARGET_GK7205V200) += fmc_gk7205v200.o
+obj-$(CONFIG_TARGET_GK7205V300) += fmc_gk7205v300.o
+obj-$(CONFIG_TARGET_GK7202V300) += fmc_gk7202v300.o
+obj-$(CONFIG_TARGET_GK7605V100) += fmc_gk7605v100.o
diff -uraN u-boot-2016.11/drivers/mtd/nand/fmc100/fmc100.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/fmc100/fmc100.c
--- u-boot-2016.11/drivers/mtd/nand/fmc100/fmc100.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/fmc100/fmc100.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,982 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "fmc100.h"
+#include <common.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <malloc.h>
+#include <match_table.h>
+#include <asm/arch/platform.h>
+
+/*****************************************************************************/
+void fmc100_ecc0_switch(struct fmc_host *host, unsigned char op)
+{
+	unsigned int config;
+#if EC_DBG
+	unsigned int cmp_cfg;
+
+	config = fmc_read(host, FMC_CFG);
+	fmc_pr(EC_DBG, "\t *-Get CFG[%#x]%#x\n", FMC_CFG, config);
+
+	if (op)
+		cmp_cfg = host->fmc_cfg;
+	else
+		cmp_cfg = host->fmc_cfg_ecc0;
+
+	if (cmp_cfg != config)
+		db_msg("Warning: FMC config[%#x] is different.\n",
+		       cmp_cfg);
+#endif
+
+	if (op == ENABLE) {
+		config = host->fmc_cfg_ecc0;
+	} else if (op == DISABLE) {
+		config = host->fmc_cfg;
+	} else {
+		db_msg("Error: Invalid opcode: %d\n", op);
+		return;
+	}
+
+	fmc_write(host, FMC_CFG, config);
+	fmc_pr(EC_DBG, "\t *-Set CFG[%#x]%#x\n", FMC_CFG, config);
+}
+
+/*****************************************************************************/
+static u32 select_addr_of(unsigned char only_oob, struct fmc_host *host)
+{
+	unsigned int addr_of = 0;
+
+	if (only_oob)
+		switch (host->ecctype) {
+		case NAND_ECC_8BIT:
+			addr_of = REG_CNT_ECC_8BIT_OFFSET;
+			break;
+
+		case NAND_ECC_16BIT:
+			addr_of = REG_CNT_ECC_16BIT_OFFSET;
+			break;
+
+		case NAND_ECC_24BIT:
+			addr_of = REG_CNT_ECC_24BIT_OFFSET;
+			break;
+
+		case NAND_ECC_0BIT:
+		default:
+			break;
+		}
+	return addr_of;
+}
+
+static void set_dma_addr_reg(struct fmc_host *host)
+{
+	unsigned int reg;
+
+	reg = host->dma_buffer;
+	fmc_write(host, FMC_DMA_SADDR_D0, reg);
+	fmc_pr(DMA_DB, "\t|-Set DMA_SADDR_D0[%#x]%#x\n", FMC_DMA_SADDR_D0, reg);
+	/* get hight 32 bits */
+	reg = ((unsigned long)host->dma_buffer & FMC_DMA_SADDRH_MASK) >> 32;
+	fmc_write(host, FMC_DMA_SADDRH_D0, reg);
+	fmc_pr(DMA_DB, "\t|-Set DMA_SADDRH_D0[%#x]%#x\n", FMC_DMA_SADDRH_D0, reg);
+	reg = host->dma_oob;
+	fmc_write(host, FMC_DMA_SADDR_OOB, reg);
+	fmc_pr(DMA_DB, "\t|-Set DMA_SADDR_OOB[%#x]%#x\n", FMC_DMA_SADDR_OOB,
+	       reg);
+	/* get hight 32 bits */
+	reg = ((unsigned long)host->dma_oob & FMC_DMA_SADDRH_MASK) >> 32;
+	fmc_write(host, FMC_DMA_SADDRH_OOB, reg);
+	fmc_pr(DMA_DB, "\t|-Set DMA_SADDRH_OOB[%#x]%#x\n", FMC_DMA_SADDRH_OOB,
+	       reg);
+}
+
+static void set_addr_reg(unsigned int addr_of, struct fmc_host *host)
+{
+	unsigned int reg;
+	struct nand_chip *chip = host->chip;
+	unsigned char pages_per_block_shift;
+	unsigned int block_num;
+	unsigned int block_num_h;
+	unsigned int page_num;
+
+	pages_per_block_shift = chip->phys_erase_shift - chip->page_shift;
+	block_num = host->addr_value[1] >> pages_per_block_shift;
+	block_num_h = block_num >> REG_CNT_HIGH_BLOCK_NUM_SHIFT;
+	reg = fmc_addrh_set(block_num_h);
+	fmc_write(host, FMC_ADDRH, reg);
+	fmc_pr(REG_DB, "|-Set ADDRH[%#x]%#x\n", FMC_ADDRH, reg);
+
+	page_num = host->addr_value[1] - (block_num << pages_per_block_shift);
+	reg = ((block_num & REG_CNT_BLOCK_NUM_MASK) << REG_CNT_BLOCK_NUM_SHIFT) |
+	      ((page_num & REG_CNT_PAGE_NUM_MASK) << REG_CNT_PAGE_NUM_SHIFT) |
+	      (addr_of & REG_CNT_ECC_OFFSET_MASK);
+	fmc_write(host, FMC_ADDRL, reg);
+	fmc_pr(REG_DB, "|-Set ADDRL[%#x]%#x\n", FMC_ADDRL, reg);
+}
+
+/****************************************************************************/
+static void set_cs_addr_reg(enum OP op, unsigned char only_oob,
+				struct fmc_host *host)
+{
+	unsigned int reg;
+	struct fmc_spi *spi = host->spi;
+	unsigned char iftype = 0;
+	unsigned char dummy = 0;
+	unsigned int addr_of = 0;
+
+	reg = FMC_INT_CLR_ALL;
+	fmc_write(host, FMC_INT_CLR, reg);
+	fmc_pr(WR_DBG, "|-Set INT_CLR[%#x]%#x\n", FMC_INT_CLR, reg);
+
+	if (op == READ) {
+		iftype  = spi->read->iftype;
+		dummy   = spi->read->dummy;
+		addr_of = select_addr_of(only_oob, host);
+	} else if (op == WRITE) {
+		iftype = spi->write->iftype;
+	} else {
+	    	iftype = spi->erase->iftype;
+	}
+
+	reg = op_cfg_fm_cs(host->cmd_op.cs) |
+	      OP_CFG_OEN_EN |
+	      op_cfg_mem_if_type(iftype) |
+	      op_cfg_dummy_num(dummy);
+	fmc_write(host, FMC_OP_CFG, reg);
+	fmc_pr(REG_DB, "|-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	set_addr_reg(addr_of, host);
+}
+
+/*****************************************************************************/
+static void fmc100_send_cmd_pageprog(struct fmc_host *host)
+{
+	unsigned int reg;
+	struct fmc_spi *spi = host->spi;
+	unsigned char *fmc_ip = NULL;
+#ifndef CONFIG_SYS_DCACHE_OFF
+	unsigned int dma_align_len;
+#endif
+	fmc_pr(WR_DBG, "\n*-Enter Dma page program!\n");
+
+	fmc_ip = get_fmc_ip();
+	if (*fmc_ip) {
+		printf("Warning: Fmc IP is busy, Please try again.\n");
+		udelay(1); /* delay 1 us */
+		return;
+	} else {
+		fmc_dev_type_switch(FLASH_TYPE_SPI_NAND);
+		(*fmc_ip)++;
+	}
+
+	reg = spi->driver->write_enable(spi);
+	if (reg) {
+		db_msg("Error: Dma program write enable failed! reg: %#x\n", reg);
+		goto end;
+	}
+
+	host->set_system_clock(spi->write, ENABLE);
+
+	if (ecc0_flag == 1) {
+		fmc100_ecc0_switch(host, ENABLE);
+		fmc_write(host, FMC_DMA_LEN, host->oobsize);
+	}
+
+	set_cs_addr_reg(WRITE, 0, host);
+
+	if (ecc0_flag != 1)
+		*host->epm = 0x0000;
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+	dma_align_len = ((host->pagesize + host->oobsize +
+	    CONFIG_SYS_CACHELINE_SIZE - 1) & ~(CONFIG_SYS_CACHELINE_SIZE - 1));
+	flush_dcache_range(host->dma_buffer, host->dma_buffer + dma_align_len);
+#endif
+
+	set_dma_addr_reg(host);
+
+	reg = op_ctrl_wr_opcode(spi->write->cmd) | op_ctrl_dma_op(OP_TYPE_DMA) |
+		op_ctrl_rw_op(RW_OP_WRITE) | OP_CTRL_DMA_OP_READY;
+	fmc_write(host, FMC_OP_CTRL, reg);
+	fmc_pr(WR_DBG, "|-Set OP_CTRL[%#x]%#x\n", FMC_OP_CTRL, reg);
+	fmc_dma_wait_int_finish(host);
+
+	if (ecc0_flag == 1)
+		fmc100_ecc0_switch(host, DISABLE);
+
+	reg = spi->driver->wait_ready(spi);
+	if (reg)
+		db_msg("Error: Dma program wait ready failed! status: %#x\n", reg);
+
+end:
+	(*fmc_ip)--;
+	fmc_pr(WR_DBG, "*-End Dma page program!\n");
+}
+/*****************************************************************************/
+static void fmc100_send_cmd_readstart(struct fmc_host *host)
+{
+	unsigned char only_oob = 0;
+	unsigned int reg;
+	struct fmc_spi *spi = host->spi;
+	unsigned char *fmc_ip = NULL;
+#ifndef CONFIG_SYS_DCACHE_OFF
+	unsigned int dma_align_len;
+#endif
+	fmc_pr(RD_DBG, "\n\t*-Start Dma page read\n");
+
+	fmc_ip = get_fmc_ip();
+	if (*fmc_ip) {
+		printf("Warning: Fmc IP is busy, Please try again.\n");
+		udelay(1); /* delay 1 us */
+		return;
+	} else {
+		fmc_dev_type_switch(FLASH_TYPE_SPI_NAND);
+		(*fmc_ip)++;
+	}
+
+	host->set_system_clock(spi->read, ENABLE);
+
+	if (ecc0_flag == 1 && (host->cmd_op.l_cmd != NAND_CMD_READOOB)) {
+		fmc100_ecc0_switch(host, ENABLE);
+		fmc_write(host, FMC_DMA_LEN, host->oobsize);
+	}
+
+	if (host->cmd_op.l_cmd == NAND_CMD_READOOB) {
+		only_oob = 1;
+		host->cmd_op.op_cfg = op_ctrl_rd_op_sel(RD_OP_READ_OOB);
+	} else {
+		host->cmd_op.op_cfg = op_ctrl_rd_op_sel(RD_OP_READ_ALL_PAGE);
+	}
+
+	set_cs_addr_reg(READ, only_oob, host);
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+	dma_align_len = ((host->pagesize + host->oobsize +
+		CONFIG_SYS_CACHELINE_SIZE - 1) & ~(CONFIG_SYS_CACHELINE_SIZE - 1));
+	invalidate_dcache_range(host->dma_buffer, host->dma_buffer + dma_align_len);
+#endif
+	set_dma_addr_reg(host);
+
+	reg = op_ctrl_rd_opcode(spi->read->cmd) |
+			host->cmd_op.op_cfg | op_ctrl_dma_op(OP_TYPE_DMA) |
+			op_ctrl_rw_op(RW_OP_READ) | OP_CTRL_DMA_OP_READY;
+	fmc_write(host, FMC_OP_CTRL, reg);
+	fmc_pr(RD_DBG, "\t|-Set OP_CTRL[%#x]%#x\n", FMC_OP_CTRL, reg);
+	fmc_dma_wait_int_finish(host);
+
+	if (ecc0_flag == 1 && (host->cmd_op.l_cmd != NAND_CMD_READOOB))
+		fmc100_ecc0_switch(host, DISABLE);
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+	invalidate_dcache_range(host->dma_buffer, host->dma_buffer + dma_align_len);
+#endif
+
+	(*fmc_ip)--;
+	fmc_pr(RD_DBG, "\t*-End Dma page read\n");
+}
+
+/*****************************************************************************/
+static void fmc100_send_cmd_erase(struct fmc_host *host)
+{
+	unsigned int reg;
+	struct fmc_spi *spi = host->spi;
+	unsigned char *fmc_ip = NULL;
+
+	if (ER_DBG)
+		printf("\n");
+	fmc_pr(ER_DBG, "\t*-Start send cmd erase!\n");
+
+	fmc_ip = get_fmc_ip();
+	if (*fmc_ip) {
+		printf("Warning: Fmc IP is busy, Please try again.\n");
+		udelay(1); /* delay 1 us */
+		return;
+	} else {
+		fmc_dev_type_switch(FLASH_TYPE_SPI_NAND);
+		(*fmc_ip)++;
+	}
+
+	reg = spi->driver->write_enable(spi);
+	if (reg) {
+		db_msg("Error: Erase write enable failed! reg: %#x\n", reg);
+		goto end;
+	}
+
+	host->set_system_clock(spi->erase, ENABLE);
+
+	reg = FMC_INT_CLR_ALL;
+	fmc_write(host, FMC_INT_CLR, reg);
+	fmc_pr(ER_DBG, "\t|-Set INT_CLR[%#x]%#x\n", FMC_INT_CLR, reg);
+
+	reg = spi->erase->cmd;
+	fmc_write(host, FMC_CMD, fmc_cmd_cmd1(reg));
+	fmc_pr(ER_DBG, "\t|-Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	reg = fmc_addrl_block_h_mask(host->addr_value[1]) |
+			fmc_addrl_block_l_mask(host->addr_value[0]);
+	fmc_write(host, FMC_ADDRL, reg);
+	fmc_pr(ER_DBG, "\t|-Set ADDRL[%#x]%#x\n", FMC_ADDRL, reg);
+
+	reg = op_cfg_fm_cs(host->cmd_op.cs) | OP_CFG_OEN_EN |
+		op_cfg_mem_if_type(spi->erase->iftype)      |
+		op_cfg_addr_num(STD_OP_ADDR_NUM)            |
+		op_cfg_dummy_num(spi->erase->dummy);
+
+	fmc_write(host, FMC_OP_CFG, reg);
+	fmc_pr(ER_DBG, "\t|-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	reg = fmc_op_cmd1_en(ENABLE) | fmc_op_addr_en(ENABLE) |
+		FMC_OP_REG_OP_START;
+	fmc_write(host, FMC_OP, reg);
+	fmc_pr(ER_DBG, "\t|-Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	fmc_cmd_wait_cpu_finish(host);
+
+	reg = spi->driver->wait_ready(spi);
+	fmc_pr(ER_DBG, "\t|-Erase wait ready, reg: %#x\n", reg);
+	if (reg)
+		db_msg("Error: Erase wait ready fail! status: %#x\n", reg);
+
+end:
+	(*fmc_ip)--;
+
+	fmc_pr(ER_DBG, "\t*-End send cmd erase!\n");
+}
+
+/*****************************************************************************/
+static void fmc100_send_cmd_status(struct fmc_host *host)
+{
+	unsigned char status;
+	unsigned char addr = STATUS_ADDR;
+	struct fmc_spi *spi = host->spi;
+	unsigned char *fmc_ip = get_fmc_ip();
+
+	if (*fmc_ip) {
+		printf("Warning: Fmc IP is busy, Please try again.\n");
+		udelay(1); /* delay 1 us */
+		return;
+	} else {
+		fmc_dev_type_switch(FLASH_TYPE_SPI_NAND);
+		(*fmc_ip)++;
+	}
+
+	if (host->cmd_op.l_cmd == NAND_CMD_GET_FEATURES)
+		addr = PROTECT_ADDR;
+
+	status = spi_nand_feature_op(spi, GET_OP, addr, 0);
+	fmc_pr((ER_DBG || WR_DBG), "\t*-Get status[%#x]: %#x\n", addr, status);
+
+	(*fmc_ip)--;
+}
+
+/*****************************************************************************/
+static void fmc100_send_cmd_readid(struct fmc_host *host)
+{
+	unsigned int reg;
+
+	fmc_pr(BT_DBG, "\t|*-Start send cmd read ID\n");
+
+	fmc100_ecc0_switch(host, ENABLE);
+
+	reg = fmc_cmd_cmd1(SPI_CMD_RDID);
+	fmc_write(host, FMC_CMD, reg);
+	fmc_pr(BT_DBG, "\t||-Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	reg = READ_ID_ADDR;
+	fmc_write(host, FMC_ADDRL, reg);
+	fmc_pr(BT_DBG, "\t||-Set ADDRL[%#x]%#x\n", FMC_ADDRL, reg);
+
+	reg = op_cfg_fm_cs(host->cmd_op.cs) | OP_CFG_OEN_EN |
+	      op_cfg_addr_num(READ_ID_ADDR_NUM);
+	fmc_write(host, FMC_OP_CFG, reg);
+	fmc_pr(BT_DBG, "\t||-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	reg = fmc_data_num_cnt(MAX_SPI_NAND_ID_LEN);
+	fmc_write(host, FMC_DATA_NUM, reg);
+	fmc_pr(BT_DBG, "\t||-Set DATA_NUM[%#x]%#x\n", FMC_DATA_NUM, reg);
+
+	reg = fmc_op_cmd1_en(ENABLE) | fmc_op_addr_en(ENABLE) |
+	      fmc_op_read_data_en(ENABLE) | FMC_OP_REG_OP_START;
+	fmc_write(host, FMC_OP, reg);
+	fmc_pr(BT_DBG, "\t||-Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	host->addr_cycle = 0x0;
+
+	fmc_cmd_wait_cpu_finish(host);
+
+	fmc100_ecc0_switch(host, DISABLE);
+
+	fmc_pr(BT_DBG, "\t|*-End read flash ID\n");
+}
+
+/*****************************************************************************/
+static void fmc100_send_cmd_reset(struct fmc_host *host)
+{
+	unsigned int reg;
+
+	fmc_pr(BT_DBG, "\t|*-Start send cmd reset\n");
+
+	reg = fmc_cmd_cmd1(SPI_CMD_RESET);
+	fmc_write(host, FMC_CMD, reg);
+	fmc_pr(BT_DBG, "\t||-Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	reg = op_cfg_fm_cs(host->cmd_op.cs) | OP_CFG_OEN_EN;
+	fmc_write(host, FMC_OP_CFG, reg);
+	fmc_pr(BT_DBG, "\t||-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	reg = fmc_op_cmd1_en(ENABLE) | FMC_OP_REG_OP_START;
+	fmc_write(host, FMC_OP, reg);
+	fmc_pr(BT_DBG, "\t||-Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	fmc_cmd_wait_cpu_finish(host);
+
+	fmc_pr(BT_DBG, "\t|*-End send cmd reset\n");
+}
+
+/*****************************************************************************/
+static unsigned char fmc100_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct fmc_host *host = chip->priv;
+	unsigned char value = 0;
+	unsigned char ret_val = 0;
+
+	if (host->cmd_op.l_cmd == NAND_CMD_READID) {
+		value = readb(host->iobase + host->offset);
+		host->offset++;
+		if (host->cmd_op.data_no == host->offset)
+			host->cmd_op.l_cmd = 0;
+		return value;
+	}
+
+	if (host->cmd_op.cmd == NAND_CMD_STATUS) {
+		value = fmc_read(host, FMC_STATUS);
+		if (host->cmd_op.l_cmd == NAND_CMD_GET_FEATURES) {
+			fmc_pr((ER_DBG || WR_DBG), "\t\tRead BP status: %#x\n",
+			       value);
+			if (any_bp_enable(value))
+				ret_val |= NAND_STATUS_WP;
+
+			host->cmd_op.l_cmd = NAND_CMD_STATUS;
+		}
+
+		if (!(value & STATUS_OIP_MASK))
+			ret_val |= NAND_STATUS_READY;
+
+		if ((chip->state == FL_ERASING) &&
+			(value & STATUS_E_FAIL_MASK)) {
+			fmc_pr(ER_DBG, "\t\tGet erase status: %#x\n", value);
+			ret_val |= NAND_STATUS_FAIL;
+		}
+
+		if ((chip->state == FL_WRITING) &&
+			(value & STATUS_P_FAIL_MASK)) {
+			fmc_pr(WR_DBG, "\t\tGet write status: %#x\n", value);
+			ret_val |= NAND_STATUS_FAIL;
+		}
+
+		return ret_val;
+	}
+
+	if (host->cmd_op.l_cmd == NAND_CMD_READOOB) {
+		value = readb((unsigned char *)
+		   ((unsigned char *)(uintptr_t)host->dma_oob + host->offset));
+		host->offset++;
+		return value;
+	}
+
+	host->offset++;
+
+	return readb(host->buffer + host->column + host->offset - 1);
+}
+
+/*****************************************************************************/
+static unsigned short fmc100_read_word(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct fmc_host *host = chip->priv;
+
+	return readw(host->buffer + host->column + host->offset);
+}
+
+/*****************************************************************************/
+static void fmc100_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct fmc_host *host = chip->priv;
+
+	if (buf == chip->oob_poi)
+		memcpy((unsigned char *)(uintptr_t)host->dma_oob, buf, len);
+	else
+		memcpy((unsigned char *)(uintptr_t)host->dma_buffer, buf, len);
+	return;
+}
+
+/*****************************************************************************/
+static void fmc100_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct fmc_host *host = chip->priv;
+
+	if (buf == chip->oob_poi)
+		memcpy(buf, (unsigned char *)(uintptr_t)host->dma_oob, len);
+	else
+		memcpy(buf, (unsigned char *)(uintptr_t)host->dma_buffer, len);
+	return;
+}
+
+/*****************************************************************************/
+static void fmc100_select_chip(struct mtd_info *mtd, int chipselect)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct fmc_host *host = chip->priv;
+
+	if (chipselect < 0)
+		return;
+
+	if (chipselect > CONFIG_SPI_NAND_MAX_CHIP_NUM)
+		db_bug("Error: Invalid chipselect: %d\n", chipselect);
+
+	if (host->mtd != mtd)
+		host->mtd = mtd;
+
+	if (!(chip->options & NAND_BROKEN_XD))
+		if ((chip->state == FL_ERASING) || (chip->state == FL_WRITING))
+			host->cmd_op.l_cmd = NAND_CMD_GET_FEATURES;
+}
+
+/******************************************************************************/
+static void fmc100_cmdfunc(struct mtd_info *mtd,
+				unsigned int command,
+				int column, int page_addr)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct fmc_host *host = chip->priv;
+
+	switch (command) {
+	case NAND_CMD_RESET:
+		host->send_cmd_reset(host);
+		chip->dev_ready(mtd);
+		break;
+	case NAND_CMD_READID:
+		host->offset = 0;
+		host->cmd_op.l_cmd = command & 0xff;
+		memset((u_char *)(host->iobase), 0, MAX_SPI_NAND_ID_LEN);
+		host->cmd_op.data_no = MAX_SPI_NAND_ID_LEN;
+		host->send_cmd_readid(host);
+		break;
+	case NAND_CMD_GET_FEATURES:
+	case NAND_CMD_STATUS:
+		host->cmd_op.l_cmd = command & 0xff;
+		host->cmd_op.cmd = NAND_CMD_STATUS;
+		host->send_cmd_status(host);
+		break;
+	case NAND_CMD_READOOB:
+		host->offset = 0;
+		host->cmd_op.l_cmd = command & 0xff;
+		/* use same command as normal read */
+		host->cmd_op.cmd = command & 0xff;
+	case NAND_CMD_READ0:
+		if (command == NAND_CMD_READ0)
+			host->cmd_op.l_cmd = command & 0xff;
+		host->addr_value[1] = page_addr;
+		host->send_cmd_readstart(host);
+		break;
+	case NAND_CMD_SEQIN:
+		host->addr_value[1] = page_addr;
+		break;
+	case NAND_CMD_PAGEPROG:
+		host->offset = 0;
+		host->send_cmd_pageprog(host);
+		break;
+	case NAND_CMD_ERASE1:
+		host->cmd_op.l_cmd = command & 0xff;
+		host->addr_value[0] = page_addr;
+		/* page_addr to block_addr, move right 16 bits */
+		host->addr_value[1] = (unsigned int)page_addr >> 16;
+		/* erase operation need a seral of command sequences */
+		host->send_cmd_erase(host);
+		break;
+	case NAND_CMD_ERASE2:
+	case NAND_CMD_READSTART:
+		break;
+	default:
+		printf("%s not support command 0x%08x:\n", mtd->name, command);
+		break;
+	}
+}
+
+/*****************************************************************************/
+static int fmc100_dev_ready(struct mtd_info *mtd)
+{
+	unsigned int reg = 0;
+	/* just a big number, so move 12 bits */
+	unsigned long deadline = 1 << 12;
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct fmc_host *host = chip->priv;
+
+	do {
+		reg = op_cfg_fm_cs(host->cmd_op.cs) | OP_CFG_OEN_EN;
+		fmc_write(host, FMC_OP_CFG, reg);
+
+		reg = fmc_op_read_status_en(ENABLE) | FMC_OP_REG_OP_START;
+		fmc_write(host, FMC_OP, reg);
+
+		fmc_cmd_wait_cpu_finish(host);
+
+		reg = fmc_read(host, FMC_STATUS);
+		if (!(reg & STATUS_OIP_MASK))
+			return 1;
+
+		udelay(1); /* delay 1 us */
+	} while (deadline--);
+
+#ifndef CONFIG_SYS_NAND_QUIET_TEST
+	printf("Warning: Wait SPI nand ready timeout, status: %#x\n", reg);
+#endif
+
+	return 0;
+}
+
+/*****************************************************************************/
+/*
+ * 'host->epm' only use the first oobfree[0] field, it looks very simple, But..
+ */
+static struct nand_ecclayout nand_ecc_default = {
+	.oobfree = {{2, 30} }
+};
+
+#ifdef CONFIG_FS_MAY_NOT_YAFFS2
+static struct nand_ecclayout nand_ecc_2k16bit = {
+	.oobfree = {{2, 6} }
+};
+
+static struct nand_ecclayout nand_ecc_4k16bit = {
+	.oobfree = {{2, 14} }
+};
+#endif
+
+/*****************************************************************************/
+static struct nand_config_info fmc_spi_nand_config_table[] = {
+	{NAND_PAGE_4K,  NAND_ECC_24BIT, 200,    &nand_ecc_default},
+#ifdef CONFIG_FS_MAY_NOT_YAFFS2
+	{NAND_PAGE_4K,  NAND_ECC_16BIT, 128,    &nand_ecc_4k16bit},
+#endif
+	{NAND_PAGE_4K,  NAND_ECC_8BIT,  128,    &nand_ecc_default},
+	{NAND_PAGE_4K,  NAND_ECC_0BIT,  32,     &nand_ecc_default},
+
+	{NAND_PAGE_2K,  NAND_ECC_24BIT, 128,    &nand_ecc_default},
+#ifdef CONFIG_FS_MAY_NOT_YAFFS2
+	{NAND_PAGE_2K,  NAND_ECC_16BIT, 64,     &nand_ecc_2k16bit},
+#endif
+	{NAND_PAGE_2K,  NAND_ECC_8BIT,  64,     &nand_ecc_default},
+	{NAND_PAGE_2K,  NAND_ECC_0BIT,  32,     &nand_ecc_default},
+
+	{0,     0,      0,  NULL},
+};
+
+/*
+ * Auto-sensed the page size and ecc type value. driver will try each of page
+ * size and ecc type one by one till flash can be read and wrote accurately.
+ * so the page size and ecc type is match adaptively without switch on the board
+ */
+static struct nand_config_info *fmc100_get_config_type_info(struct mtd_info *mtd)
+{
+	struct nand_config_info *best = NULL;
+	struct nand_config_info *info = fmc_spi_nand_config_table;
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	for (; info->layout; info++) {
+		if (match_page_type_to_size(info->pagetype) != mtd->writesize)
+			continue;
+
+		if (mtd->oobsize < info->oobsize)
+			continue;
+
+		if (!best || (best->ecctype < info->ecctype))
+			best = info;
+	}
+	/* All SPI NAND are small-page,SLC */
+	chip->bits_per_cell = 1;
+	return best;
+}
+
+/*****************************************************************************/
+static void fmc100_set_oob_info(struct mtd_info *mtd,
+				struct nand_config_info *info)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct fmc_host *host = chip->priv;
+
+	if (info->ecctype != NAND_ECC_0BIT)
+		mtd->oobsize = info->oobsize;
+
+	host->oobsize = mtd->oobsize;
+	host->dma_oob = host->dma_buffer + host->pagesize;
+	host->bbm = (u_char *)(host->buffer + host->pagesize
+			       + FMC_BAD_BLOCK_POS);
+
+	chip->ecc.layout = info->layout;
+
+	/* EB bytes locate in the bottom two of CTRL(30) */
+	host->epm = (u_short *)(host->buffer + host->pagesize
+				+ chip->ecc.layout->oobfree[0].offset + EB_NORMAL);
+
+#ifdef CONFIG_FS_MAY_NOT_YAFFS2
+
+	if (best->ecctype == NAND_ECC_16BIT)
+		if (host->pagesize == _2K)
+			/* EB bits locate in the bottom two of CTRL(4) */
+			host->epm = (u_short *)(host->buffer + host->pagesize
+			 + chip->ecc.layout->oobfree[0].offset + EB_2K_16_BIT);
+		else if (host->pagesize == _4K)
+			/* EB bit locate in the bottom two of CTRL(14) */
+			host->epm = (u_short *)(host->buffer + host->pagesize
+			 + chip->ecc.layout->oobfree[0].offset + EB_4K_16_BIT);
+
+#endif
+}
+
+/*****************************************************************************/
+static unsigned int fmc100_get_ecc_reg(struct fmc_host *host,
+				struct nand_config_info *info)
+{
+	host->ecctype = info->ecctype;
+
+	return fmc_cfg_ecc_type(match_ecc_type_to_reg(info->ecctype));
+}
+
+/*****************************************************************************/
+static unsigned int fmc100_get_page_reg(struct fmc_host *host,
+				struct nand_config_info *info)
+{
+	host->pagesize = match_page_type_to_size(info->pagetype);
+
+	return fmc_cfg_page_size(match_page_type_to_reg(info->pagetype));
+}
+
+/*****************************************************************************/
+static unsigned int fmc100_get_block_reg(struct fmc_host *host,
+				struct nand_config_info *info)
+{
+	unsigned int block_reg = 0;
+	unsigned int page_per_block;
+	struct mtd_info *mtd = host->mtd;
+
+	host->block_page_mask = ((mtd->erasesize / mtd->writesize) - 1);
+	page_per_block = mtd->erasesize / match_page_type_to_size(info->pagetype);
+	switch (page_per_block) {
+	case _64_PAGES:
+		block_reg = BLOCK_SIZE_64_PAGE;
+		break;
+	case _128_PAGES:
+		block_reg = BLOCK_SIZE_128_PAGE;
+		break;
+	case _256_PAGES:
+		block_reg = BLOCK_SIZE_256_PAGE;
+		break;
+	case _512_PAGES:
+		block_reg = BLOCK_SIZE_512_PAGE;
+		break;
+	default:
+		db_msg("Can't support block %#x and page %#x size\n",
+		       mtd->erasesize, mtd->writesize);
+	}
+
+	return fmc_cfg_block_size(block_reg);
+}
+
+/*****************************************************************************/
+static void fmc100_set_fmc_cfg_reg(struct mtd_info *mtd,
+				struct nand_config_info *type_info)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct fmc_host *host = chip->priv;
+	unsigned int page_reg, ecc_reg, block_reg, reg_fmc_cfg;
+
+	ecc_reg = fmc100_get_ecc_reg(host, type_info);
+	page_reg = fmc100_get_page_reg(host, type_info);
+	block_reg = fmc100_get_block_reg(host, type_info);
+
+	reg_fmc_cfg = fmc_read(host, FMC_CFG);
+	reg_fmc_cfg &= ~(PAGE_SIZE_MASK | ECC_TYPE_MASK | BLOCK_SIZE_MASK);
+	reg_fmc_cfg |= ecc_reg | page_reg | block_reg;
+	fmc_write(host, FMC_CFG, reg_fmc_cfg);
+
+	/* max number of correctible bit errors per ecc step */
+	mtd->ecc_strength = host->ecctype;
+
+	/* Save value of FMC_CFG and FMC_CFG_ECC0 to turn on/off ECC */
+	host->fmc_cfg = reg_fmc_cfg;
+	host->fmc_cfg_ecc0 = (host->fmc_cfg & ~ECC_TYPE_MASK) | ECC_TYPE_0BIT;
+	fmc_pr(BT_DBG, "\t|-Save FMC_CFG[%#x]: %#x and FMC_CFG_ECC0: %#x\n",
+	       FMC_CFG, host->fmc_cfg, host->fmc_cfg_ecc0);
+}
+
+/*****************************************************************************/
+static int fmc100_set_config_info(struct mtd_info *mtd)
+{
+	struct nand_config_info *type_info = NULL;
+
+	fmc_pr(BT_DBG, "\t*-Start match PageSize and EccType\n");
+
+	type_info = fmc100_get_config_type_info(mtd);
+	if (!type_info)
+		db_bug(ERR_STR_DRIVER "pagesize: %d and oobsize: %d.\n",
+		       mtd->writesize, mtd->oobsize);
+
+	/* Set the page_size, ecc_type, block_size of FMC_CFG[0x0] register */
+	fmc100_set_fmc_cfg_reg(mtd, type_info);
+
+	fmc_pr(BT_DBG, "\t|- PageSize %s EccType %s OOB Size %d\n",
+	       nand_page_name(type_info->pagetype),
+	       nand_ecc_name(type_info->ecctype), type_info->oobsize);
+
+	fmc100_set_oob_info(mtd, type_info);
+
+	fmc_pr(BT_DBG, "\t*-End match PageSize and EccType\n");
+
+	return 0;
+}
+
+/*****************************************************************************/
+static void fmc100_chip_init(struct nand_chip *chip)
+{
+	if (!chip->IO_ADDR_R)
+		chip->IO_ADDR_R = (void __iomem *)CONFIG_FMC_BUFFER_BASE;
+	chip->IO_ADDR_W = chip->IO_ADDR_R;
+	memset((char *)chip->IO_ADDR_R, 0xff, FMC100_BUFFER_LEN);
+
+	chip->read_byte = fmc100_read_byte;
+	chip->read_word = fmc100_read_word;
+	chip->write_buf = fmc100_write_buf;
+	chip->read_buf = fmc100_read_buf;
+
+	chip->select_chip = fmc100_select_chip;
+
+	chip->cmdfunc = fmc100_cmdfunc;
+	chip->dev_ready = fmc100_dev_ready;
+
+	chip->chip_delay = FMC_CHIP_DELAY;
+
+	chip->options = NAND_BBT_SCANNED | NAND_BROKEN_XD;
+
+	chip->ecc.layout = NULL;
+	chip->ecc.mode = NAND_ECC_NONE;
+}
+
+/*****************************************************************************/
+int host_data_init(struct fmc_host *host)
+{
+	unsigned long align_mask;
+
+	host->addr_cycle = 0;
+	host->addr_value[0] = 0;
+	host->addr_value[1] = 0;
+	host->cache_addr_value[0] = ~0;
+	host->cache_addr_value[1] = ~0;
+
+	fmc_pr(BT_DBG, "\t|||-Malloc memory for dma buffer\n");
+	host->buforg = kmalloc((FMC100_BUFFER_LEN + FMC_DMA_ALIGN),
+			       GFP_KERNEL);
+	if (!host->buforg) {
+		db_msg("Error: Can't malloc memory for SPI Nand driver.\n");
+		return -ENOMEM;
+	}
+	memset(host->buforg, 0xff, FMC100_BUFFER_LEN + FMC_DMA_ALIGN);
+
+	/* DMA need 32 bytes alignment */
+	align_mask = FMC_DMA_ALIGN - 1;
+	host->dma_buffer = (uintptr_t)(host->buforg + align_mask) & ~align_mask;
+
+	host->buffer = (char *)(uintptr_t)host->dma_buffer;
+	memset(host->buffer, 0xff, FMC100_BUFFER_LEN);
+
+	host->send_cmd_pageprog = fmc100_send_cmd_pageprog;
+	host->send_cmd_status = fmc100_send_cmd_status;
+	host->send_cmd_readstart = fmc100_send_cmd_readstart;
+	host->send_cmd_erase = fmc100_send_cmd_erase;
+	host->send_cmd_readid = fmc100_send_cmd_readid;
+	host->send_cmd_reset = fmc100_send_cmd_reset;
+	host->set_system_clock = fmc_set_fmc_system_clock;
+
+	return 0;
+}
+/*****************************************************************************/
+int fmc100_host_init(struct fmc_host *host)
+{
+	unsigned int reg;
+	unsigned int flash_type;
+	int ret;
+
+	fmc_pr(BT_DBG, "\t||*-Start SPI Nand host init\n");
+	host->iobase = (void __iomem *)CONFIG_FMC_BUFFER_BASE;
+	host->regbase = (void __iomem *)CONFIG_FMC_REG_BASE;
+
+	reg = fmc_read(host, FMC_CFG);
+	flash_type = (reg & FLASH_SEL_MASK) >> FLASH_SEL_SHIFT;
+	if (flash_type != FLASH_TYPE_SPI_NAND) {
+		db_msg("Error: Flash type isn't SPI Nand. reg: %#x\n", reg);
+		return -ENODEV;
+	}
+
+	if ((reg & OP_MODE_MASK) == OP_MODE_BOOT) {
+		reg |= fmc_cfg_op_mode(OP_MODE_NORMAL);
+		fmc_write(host, FMC_CFG, reg);
+		fmc_pr(BT_DBG, "\t|||-Set CFG[%#x]%#x\n", FMC_CFG, reg);
+	}
+
+	host->fmc_cfg = reg;
+	host->fmc_cfg_ecc0 = (reg & ~ECC_TYPE_MASK) | ECC_TYPE_0BIT;
+
+	reg = fmc_read(host, FMC_GLOBAL_CFG);
+	if (reg & FMC_GLOBAL_CFG_WP_ENABLE) {
+		reg &= ~FMC_GLOBAL_CFG_WP_ENABLE;
+		fmc_write(host, FMC_GLOBAL_CFG, reg);
+	}
+
+	ret = host_data_init(host);
+	if (ret)
+	    return ret;
+
+	/* ecc0_flag for ecc0 read/write */
+	ecc0_flag = 0;
+
+	reg = timing_cfg_tcsh(CS_HOLD_TIME) |
+	      timing_cfg_tcss(CS_SETUP_TIME) |
+	      timing_cfg_tshsl(CS_DESELECT_TIME);
+	fmc_write(host, FMC_SPI_TIMING_CFG, reg);
+	fmc_pr(BT_DBG, "\t|||-Set TIMING[%#x]%#x\n", FMC_SPI_TIMING_CFG, reg);
+
+	reg = ALL_BURST_ENABLE;
+	fmc_write(host, FMC_DMA_AHB_CTRL, reg);
+	fmc_pr(BT_DBG, "\t|||-Set DMA_AHB[%#x]%#x\n", FMC_DMA_AHB_CTRL, reg);
+
+	fmc_pr(BT_DBG, "\t|||-Register SPI Nand ID table and ecc probe\n");
+	fmc_spi_nand_ids_register();
+	nand_oob_resize = fmc100_set_config_info;
+
+	fmc_pr(BT_DBG, "\t||*-End SPI Nand host init\n");
+
+	return 0;
+}
+
+/*****************************************************************************/
+void fmc100_spi_nand_init(struct fmc_host *host)
+{
+	struct nand_chip *chip = host->chip;
+
+	fmc_pr(BT_DBG, "\t|*-Start fmc100 SPI Nand init\n");
+
+	/* Set system clock and enable controller */
+	fmc_pr(BT_DBG, "\t||-Set system clock and Enable Controller\n");
+	if (host->set_system_clock)
+		host->set_system_clock(NULL, ENABLE);
+
+	/* Fmc nand_chip struct init */
+	fmc_pr(BT_DBG, "\t||-fmc100 struct nand_chip init\n");
+	chip->priv = host;
+	fmc100_chip_init(chip);
+
+	fmc_pr(BT_DBG, "\t|*-End fmc100 SPI Nand init\n");
+}
diff -uraN u-boot-2016.11/drivers/mtd/nand/fmc100/fmc100.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/fmc100/fmc100.h
--- u-boot-2016.11/drivers/mtd/nand/fmc100/fmc100.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/fmc100/fmc100.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,112 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __FMC100_H__
+#define __FMC100_H__
+
+#include <nand.h>
+#include <fmc_common.h>
+#include <nfc_common.h>
+#include "../../fmc_spi_ids.h"
+
+/*****************************************************************************/
+/* These macroes are for debug only, reg option is slower then dma option */
+#undef FMC100_SPI_NAND_SUPPORT_REG_READ
+#undef FMC100_SPI_NAND_SUPPORT_REG_WRITE
+
+/*****************************************************************************/
+#define REG_CNT_HIGH_BLOCK_NUM_SHIFT        10
+
+#define REG_CNT_BLOCK_NUM_MASK          0x3ff
+#define REG_CNT_BLOCK_NUM_SHIFT         22
+
+#define REG_CNT_PAGE_NUM_MASK           0x3f
+#define REG_CNT_PAGE_NUM_SHIFT          16
+
+#define REG_CNT_WRAP_MASK           0xf
+#define REG_CNT_WRAP_SHIFT          12
+
+#define REG_CNT_ECC_OFFSET_MASK         0xfff
+#define REG_CNT_ECC_8BIT_OFFSET         1054
+#define REG_CNT_ECC_16BIT_OFFSET        1056
+#define REG_CNT_ECC_24BIT_OFFSET        1082
+
+#define ERR_STR_DRIVER "Driver does not support this configure "
+#define ERR_STR_CHECK "Please make sure the hardware configuration is correct"
+
+/*****************************************************************************/
+#define SPI_NAND_MAX_PAGESIZE           4096
+#define SPI_NAND_MAX_OOBSIZE            256
+
+#define FMC100_BUFFER_LEN (SPI_NAND_MAX_PAGESIZE + SPI_NAND_MAX_OOBSIZE)
+
+#define FMC100_ADDR_CYCLE_MASK        0x2
+
+/*****************************************************************************/
+struct fmc_host {
+	struct mtd_info *mtd;
+	struct nand_chip *chip;
+	struct fmc_spi spi[CONFIG_SPI_NAND_MAX_CHIP_NUM];
+	struct fmc_cmd_op cmd_op;
+
+	void __iomem *iobase;
+	void __iomem *regbase;
+
+	unsigned int fmc_cfg;
+	unsigned int fmc_cfg_ecc0;
+
+	unsigned int offset;
+
+	struct device *dev;
+
+	/* This is maybe an un-aligment address, only for malloc or free */
+	char *buforg;
+	char *buffer;
+
+	long dma_buffer;
+	long dma_oob;
+
+	unsigned int addr_cycle;
+	unsigned int addr_value[2]; /* 2 addr */
+	unsigned int cache_addr_value[2]; /* 2 addr */
+
+	unsigned int column;
+	unsigned int block_page_mask;
+
+	unsigned int ecctype;
+	unsigned int pagesize;
+	unsigned int oobsize;
+
+	int add_partition;
+
+	/* BOOTROM read two bytes to detect the bad block flag */
+#define FMC_BAD_BLOCK_POS     0
+	unsigned char *bbm; /* nand bad block mark */
+	unsigned short *epm;    /* nand empty page mark */
+
+	unsigned int uc_er;
+
+	void (*send_cmd_pageprog)(struct fmc_host *host);
+	void (*send_cmd_status)(struct fmc_host *host);
+	void (*send_cmd_readstart)(struct fmc_host *host);
+	void (*send_cmd_erase)(struct fmc_host *host);
+	void (*send_cmd_readid)(struct fmc_host *host);
+	void (*send_cmd_reset)(struct fmc_host *host);
+	void (*set_system_clock)(struct spi_op *op, int clk_en);
+};
+
+/*****************************************************************************/
+void fmc100_ecc0_switch(struct fmc_host *host, unsigned char op);
+
+int fmc100_host_init(struct fmc_host *host);
+
+void fmc100_spi_nand_init(struct fmc_host *host);
+
+/*****************************************************************************/
+void fmc_spi_nand_ids_register(void);
+unsigned char spi_nand_feature_op(struct fmc_spi *spi, unsigned char op,
+				unsigned char addr, unsigned char val);
+/*****************************************************************************/
+
+#endif /* End of __FMC100_H__ */
diff -uraN u-boot-2016.11/drivers/mtd/nand/fmc100/fmc100_os.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/fmc100/fmc100_os.c
--- u-boot-2016.11/drivers/mtd/nand/fmc100/fmc100_os.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/fmc100/fmc100_os.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,120 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "fmc100_os.h"
+#include <common.h>
+
+/*****************************************************************************/
+static struct fmc_host fmc100_host = {
+	.chip = NULL,
+};
+
+/*****************************************************************************/
+static void fmc100_driver_probe(struct nand_chip *chip, unsigned char cs)
+{
+	int ret = 0;
+	struct fmc_host *host = &fmc100_host;
+
+	fmc_pr(BT_DBG, "\t*-Start SPI Nand flash driver probe\n");
+
+	if (!host->chip) {
+		/* Fmc ip version check */
+		if (fmc_ip_ver_check())
+			db_bug("Error: fmc IP version unknown!\n");
+
+		/* Fmc current SPI device type check */
+		fmc_dev_type_switch(FLASH_TYPE_SPI_NAND);
+
+		/* Fmc SPI nand init */
+		memset((char *)host, 0, sizeof(struct fmc_host));
+		ret = fmc100_host_init(host);
+		if (ret) {
+			db_msg("Error: Host init failed, result: %d\n", ret);
+			/* Change SPI device type to default */
+			fmc_dev_type_switch(FLASH_TYPE_DEFAULT);
+			return;
+		}
+	} else {
+		fmc_pr(BT_DBG, "\t*-SPI Nand host is initialized.\n");
+	}
+
+	host->cmd_op.cs = cs;
+	host->chip = chip;
+	fmc100_spi_nand_init(host);
+
+	fmc_pr(BT_DBG, "\t*-End SPI Nand flash driver probe.\n");
+
+	return;
+}
+
+/*****************************************************************************/
+static int fmc100_spi_nand_pre_probe(struct nand_chip *chip)
+{
+	uint8_t nand_maf_id;
+	struct mtd_info *mtd = nand_to_mtd(chip);
+	struct fmc_host *host = chip->priv;
+
+	/* Reset the chip first */
+	host->send_cmd_reset(host);
+	chip->dev_ready(mtd);
+
+	/* Check the ID */
+	host->offset = 0;
+	memset((unsigned char *)(chip->IO_ADDR_R), 0, 0x10);
+	host->send_cmd_readid(host);
+	nand_maf_id = readb(chip->IO_ADDR_R);
+	if (nand_maf_id == 0x00 || nand_maf_id == 0xff) {
+		printf("Cannot found a valid SPI Nand Device\n");
+		return 1;
+	}
+
+	return 0;
+}
+
+/*****************************************************************************/
+int board_nand_init(struct nand_chip *chip)
+{
+	unsigned char chip_num = CONFIG_SPI_NAND_MAX_CHIP_NUM;
+	static unsigned char cs = 0;
+	unsigned char *fmc_cs = NULL;
+
+	for (cs = 0; chip_num && (cs < CONFIG_FMC_MAX_CS_NUM); cs++) {
+		fmc_cs = get_cs_number(cs);
+		if (*fmc_cs) {
+			fmc_pr(BT_DBG, "\t\t*-Current CS(%d) is occupied.\n",
+			       cs);
+			continue;
+		}
+
+		fmc100_driver_probe(chip, cs);
+		chip_num--;
+	}
+
+	if (chip_num)
+		return 1;
+
+	if (fmc100_spi_nand_pre_probe(chip))
+		return 1;
+
+	return 0;
+}
+
+/*****************************************************************************/
+static int fmc100_spi_nand_get_ecctype(void)
+{
+	struct fmc_host *host = &fmc100_host;
+
+	if (!host->chip) {
+		printf("SPI Nand flash uninitialized.\n");
+		return -1;
+	}
+
+	return match_ecc_type_to_yaffs(fmc100_host.ecctype);
+}
+
+/*****************************************************************************/
+int nand_get_ecctype(void)
+{
+	return fmc100_spi_nand_get_ecctype();
+}
\ No newline at end of file
diff -uraN u-boot-2016.11/drivers/mtd/nand/fmc100/fmc100_os.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/fmc100/fmc100_os.h
--- u-boot-2016.11/drivers/mtd/nand/fmc100/fmc100_os.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/fmc100/fmc100_os.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,13 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __FMC100_OS_H__
+#define __FMC100_OS_H__
+
+#include "fmc100.h"
+
+/*****************************************************************************/
+int board_nand_init(struct nand_chip *chip);
+
+#endif /* End of __FMC100_OS_H__ */
\ No newline at end of file
diff -uraN u-boot-2016.11/drivers/mtd/nand/fmc100/fmc100_spi_general.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/fmc100/fmc100_spi_general.c
--- u-boot-2016.11/drivers/mtd/nand/fmc100/fmc100_spi_general.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/fmc100/fmc100_spi_general.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,255 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+/*
+ * Send set/get features command to SPI Nand flash
+ */
+/*****************************************************************************/
+void spi_nand_set_cmd(struct fmc_host *host, u_char op, u_char addr,
+				u_char val)
+{
+	unsigned int reg;
+
+	reg = fmc_cmd_cmd1(op ? SPI_CMD_SET_FEATURE : SPI_CMD_GET_FEATURES);
+	fmc_write(host, FMC_CMD, reg);
+	fmc_pr(FT_DBG, "\t||||-Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	fmc_write(host, FMC_ADDRL, addr);
+	fmc_pr(FT_DBG, "\t||||-Set ADDRL[%#x]%#x\n", FMC_ADDRL, addr);
+
+	reg = op_cfg_fm_cs(host->cmd_op.cs) | OP_CFG_OEN_EN |
+		op_cfg_addr_num(FEATURES_OP_ADDR_NUM);
+	fmc_write(host, FMC_OP_CFG, reg);
+	fmc_pr(FT_DBG, "\t||||-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	reg = fmc_data_num_cnt(FEATURES_DATA_LEN);
+	fmc_write(host, FMC_DATA_NUM, reg);
+	fmc_pr(FT_DBG, "\t||||-Set DATA_NUM[%#x]%#x\n", FMC_DATA_NUM, reg);
+
+	reg = fmc_op_cmd1_en(ENABLE) | fmc_op_addr_en(ENABLE) |
+		FMC_OP_REG_OP_START;
+
+	if (op == SET_OP) {
+		reg |= fmc_op_write_data_en(ENABLE);
+		writeb(val, host->iobase);
+		fmc_pr(FT_DBG, "\t||||-Write IO[%p]%#x\n", host->iobase,
+		       *(u_char *)host->iobase);
+	} else {
+		reg |= fmc_op_read_data_en(ENABLE);
+	}
+
+	fmc_write(host, FMC_OP, reg);
+	fmc_pr(FT_DBG, "\t||||-Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	fmc_cmd_wait_cpu_finish(host);
+}
+/*****************************************************************************/
+unsigned char spi_nand_feature_op(struct fmc_spi *spi, unsigned char op,
+					unsigned char addr, unsigned char val)
+{
+	unsigned int reg = 0;
+	const char *str[] = {"Get", "Set"};
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	if ((op == GET_OP) && (addr == STATUS_ADDR)) {
+		fmc_pr(SR_DBG, "\n\t\t|*-Start Get Status\n");
+
+		reg = op_cfg_fm_cs(host->cmd_op.cs) | OP_CFG_OEN_EN;
+		fmc_write(host, FMC_OP_CFG, reg);
+		fmc_pr(SR_DBG, "\t\t||-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+		reg = fmc_op_read_status_en(ENABLE) | FMC_OP_REG_OP_START;
+		fmc_write(host, FMC_OP, reg);
+		fmc_pr(SR_DBG, "\t\t||-Set OP[%#x]%#x\n", FMC_OP, reg);
+
+		fmc_cmd_wait_cpu_finish(host);
+
+		val = fmc_read(host, FMC_STATUS);
+		fmc_pr(SR_DBG, "\t\t|*-End Get Status, result: %#x\n", val);
+
+		return val;
+	}
+
+	fmc_pr(FT_DBG, "\t|||*-Start %s feature, addr[%#x]\n", str[op], addr);
+
+	fmc100_ecc0_switch(host, ENABLE);
+
+	spi_nand_set_cmd(host, op, addr, val);
+
+	if (op == GET_OP) {
+		val = readb(host->iobase);
+		fmc_pr(FT_DBG, "\t||||-Read IO[%p]%#x\n", host->iobase,
+		       *(u_char *)host->iobase);
+	}
+
+	fmc100_ecc0_switch(host, DISABLE);
+
+	fmc_pr(FT_DBG, "\t|||*-End %s Feature[%#x]:%#x\n", str[op], addr, val);
+
+	return val;
+}
+
+/*****************************************************************************/
+/*
+ * Read status[C0H]:[0]bit OIP, judge whether the device is busy or not
+ */
+static int spi_general_wait_ready(struct fmc_spi *spi)
+{
+	unsigned char status;
+	/* just get a big number, so move left 12 bits */
+	unsigned int deadline = 1 << 12;
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	do {
+		status = spi_nand_feature_op(spi, GET_OP, STATUS_ADDR, 0);
+		if (!(status & STATUS_OIP_MASK)) {
+			if ((host->cmd_op.l_cmd == NAND_CMD_ERASE2) &&
+				(status & STATUS_E_FAIL_MASK)) {
+				return status;
+			}
+			if ((host->cmd_op.l_cmd == NAND_CMD_PAGEPROG) &&
+				(status & STATUS_P_FAIL_MASK)) {
+				return status;
+			}
+			return 0;
+		}
+
+		udelay(1); /* delay 1 us */
+	} while (deadline--);
+
+	db_msg("Error: SPI Nand wait ready timeout, status: %#x\n", status);
+
+	return 1;
+}
+
+/*****************************************************************************/
+/*
+ * Send write enable cmd to SPI Nand, status[C0H]:[2]bit WEL must be set 1
+ */
+static int spi_general_write_enable(struct fmc_spi *spi)
+{
+	unsigned int reg;
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	if (WE_DBG)
+		printf("\n");
+	fmc_pr(WE_DBG, "\t|*-Start Write Enable\n");
+
+	reg = spi_nand_feature_op(spi, GET_OP, STATUS_ADDR, 0);
+	if (reg & STATUS_WEL_MASK) {
+		fmc_pr(WE_DBG, "\t||-Write Enable was opened! reg: %#x\n",
+		       reg);
+		return 0;
+	}
+
+	reg = fmc_read(host, FMC_GLOBAL_CFG);
+	fmc_pr(WE_DBG, "\t||-Get GLOBAL_CFG[%#x]%#x\n", FMC_GLOBAL_CFG, reg);
+	if (reg & FMC_GLOBAL_CFG_WP_ENABLE) {
+		reg &= ~FMC_GLOBAL_CFG_WP_ENABLE;
+		fmc_write(host, FMC_GLOBAL_CFG, reg);
+		fmc_pr(WE_DBG, "\t||-Set GLOBAL_CFG[%#x]%#x\n",
+		       FMC_GLOBAL_CFG, reg);
+	}
+
+	reg = fmc_cmd_cmd1(SPI_CMD_WREN);
+	fmc_write(host, FMC_CMD, reg);
+	fmc_pr(WE_DBG, "\t||-Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	reg = op_cfg_fm_cs(host->cmd_op.cs) | OP_CFG_OEN_EN;
+	fmc_write(host, FMC_OP_CFG, reg);
+	fmc_pr(WE_DBG, "\t||-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	reg = fmc_op_cmd1_en(ENABLE) | FMC_OP_REG_OP_START;
+	fmc_write(host, FMC_OP, reg);
+	fmc_pr(WE_DBG, "\t||-Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	fmc_cmd_wait_cpu_finish(host);
+
+#if WE_DBG
+	spi->driver->wait_ready(spi);
+
+	reg = spi_nand_feature_op(spi, GET_OP, STATUS_ADDR, 0);
+	if (reg & STATUS_WEL_MASK) {
+		fmc_pr(WE_DBG, "\t||-Write Enable success. reg: %#x\n", reg);
+	} else {
+		db_msg("Error: Write Enable failed! reg: %#x\n", reg);
+		return reg;
+	}
+#endif
+
+	fmc_pr(WE_DBG, "\t|*-End Write Enable\n");
+	return 0;
+}
+
+/*****************************************************************************/
+/*
+ * judge whether SPI Nand support QUAD read/write or not
+ */
+static int spi_is_quad(struct fmc_spi *spi)
+{
+	const char *if_str[] = {"STD", "DUAL", "DIO", "QUAD", "QIO"};
+
+	fmc_pr(QE_DBG, "\t\t|||*-SPI read iftype: %s write iftype: %s\n",
+			if_str[spi->read->iftype], if_str[spi->write->iftype]);
+
+	if ((spi->read->iftype == IF_TYPE_QUAD) 		||
+			(spi->read->iftype == IF_TYPE_QIO) 	||
+			(spi->write->iftype == IF_TYPE_QUAD) 	||
+			(spi->write->iftype == IF_TYPE_QIO))
+		return 1;
+
+	return 0;
+}
+
+/*****************************************************************************/
+/*
+ * Send set features cmd to SPI Nand, feature[B0H]:[0]bit QE would be set
+ */
+static int spi_general_qe_enable(struct fmc_spi *spi)
+{
+	unsigned int reg;
+	unsigned int op;
+
+	const char *str[] = {"Disable", "Enable"};
+
+	fmc_pr(QE_DBG, "\t||*-Start SPI Nand flash QE\n");
+
+	op = spi_is_quad(spi);
+
+	fmc_pr(QE_DBG, "\t|||*-End Quad check, SPI Nand %s Quad.\n", str[op]);
+
+	reg = spi_nand_feature_op(spi, GET_OP, FEATURE_ADDR, 0);
+	fmc_pr(QE_DBG, "\t|||-Get [%#x]feature: %#x\n", FEATURE_ADDR, reg);
+	if ((reg & FEATURE_QE_ENABLE) == op) {
+		fmc_pr(QE_DBG, "\t||*-SPI Nand quad was %sd!\n", str[op]);
+		return op;
+	}
+
+	if (op == ENABLE)
+		reg |= FEATURE_QE_ENABLE;
+	else
+		reg &= ~FEATURE_QE_ENABLE;
+
+	spi_nand_feature_op(spi, SET_OP, FEATURE_ADDR, reg);
+	fmc_pr(QE_DBG, "\t|||-SPI Nand %s Quad\n", str[op]);
+
+	spi->driver->wait_ready(spi);
+
+	reg = spi_nand_feature_op(spi, GET_OP, FEATURE_ADDR, 0);
+	if ((reg & FEATURE_QE_ENABLE) == op)
+		fmc_pr(QE_DBG, "\t|||-SPI Nand %s Quad succeed!\n", str[op]);
+	else
+		db_msg("Error: %s Quad failed! reg: %#x\n", str[op], reg);
+
+	fmc_pr(QE_DBG, "\t||*-End SPI Nand %s Quad.\n", str[op]);
+
+	return op;
+}
+
+/****************************************************************************/
+/* some spi nand flash don't QUAD enable */
+static int spi_do_not_qe_enable(struct fmc_spi *spi)
+{
+	return 0;
+}
\ No newline at end of file
diff -uraN u-boot-2016.11/drivers/mtd/nand/fmc100/fmc_spi_nand_ids.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/fmc100/fmc_spi_nand_ids.c
--- u-boot-2016.11/drivers/mtd/nand/fmc100/fmc_spi_nand_ids.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/fmc100/fmc_spi_nand_ids.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,2132 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <common.h>
+#include <exports.h>
+#include <asm/io.h>
+#include <linux/mtd/nand.h>
+#include <fmc_common.h>
+#include "../../fmc_spi_ids.h"
+#include "nfc_common.h"
+#include "fmc100.h"
+
+/*****************************************************************************/
+set_read_std(1, INFINITE, 24);
+
+set_read_fast(1, INFINITE, 60);
+set_read_fast(1, INFINITE, 80);
+set_read_fast(1, INFINITE, 100);
+set_read_fast(1, INFINITE, 104);
+set_read_fast(1, INFINITE, 108);
+set_read_fast(1, INFINITE, 120);
+set_read_fast(1, INFINITE, 133);
+
+set_read_dual(1, INFINITE, 60);
+set_read_dual(1, INFINITE, 80);
+set_read_dual(1, INFINITE, 100);
+set_read_dual(1, INFINITE, 104);
+set_read_dual(1, INFINITE, 108);
+set_read_dual(1, INFINITE, 120);
+set_read_dual(1, INFINITE, 133);
+
+set_read_dual_addr(1, INFINITE, 40);
+set_read_dual_addr(1, INFINITE, 60);
+set_read_dual_addr(1, INFINITE, 80);
+set_read_dual_addr(2, INFINITE, 80);
+set_read_dual_addr(2, INFINITE, 104);
+set_read_dual_addr(1, INFINITE, 100);
+set_read_dual_addr(1, INFINITE, 104);
+set_read_dual_addr(1, INFINITE, 108);
+set_read_dual_addr(1, INFINITE, 120);
+
+set_read_quad(1, INFINITE, 60);
+set_read_quad(1, INFINITE, 80);
+set_read_quad(1, INFINITE, 100);
+set_read_quad(1, INFINITE, 104);
+set_read_quad(1, INFINITE, 108);
+set_read_quad(1, INFINITE, 120);
+set_read_quad(1, INFINITE, 133);
+
+set_read_quad_addr(2, INFINITE, 40);
+set_read_quad_addr(1, INFINITE, 60);
+set_read_quad_addr(1, INFINITE, 80);
+set_read_quad_addr(2, INFINITE, 80);
+set_read_quad_addr(4, INFINITE, 80);
+set_read_quad_addr(4, INFINITE, 104);
+set_read_quad_addr(1, INFINITE, 100);
+set_read_quad_addr(1, INFINITE, 104);
+set_read_quad_addr(2, INFINITE, 104);
+set_read_quad_addr(1, INFINITE, 108);
+set_read_quad_addr(1, INFINITE, 120);
+
+/*****************************************************************************/
+set_write_std(0, 256, 24);
+set_write_std(0, 256, 75);
+set_write_std(0, 256, 80);
+set_write_std(0, 256, 100);
+set_write_std(0, 256, 104);
+set_write_std(0, 256, 133);
+
+set_write_quad(0, 256, 80);
+set_write_quad(0, 256, 100);
+set_write_quad(0, 256, 104);
+set_write_quad(0, 256, 108);
+set_write_quad(0, 256, 120);
+set_write_quad(0, 256, 133);
+
+/*****************************************************************************/
+set_erase_sector_128k(0, _128K, 24);
+set_erase_sector_128k(0, _128K, 75);
+set_erase_sector_128k(0, _128K, 80);
+set_erase_sector_128k(0, _128K, 104);
+set_erase_sector_128k(0, _128K, 133);
+
+set_erase_sector_256k(0, _256K, 24);
+set_erase_sector_256k(0, _256K, 75);
+set_erase_sector_256k(0, _256K, 80);
+set_erase_sector_256k(0, _256K, 100);
+set_erase_sector_256k(0, _256K, 104);
+set_erase_sector_256k(0, _256K, 133);
+
+/*****************************************************************************/
+#include "fmc100_spi_general.c"
+static struct spi_drv spi_driver_general = {
+	.wait_ready = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+	.qe_enable = spi_general_qe_enable,
+};
+
+static struct spi_drv spi_driver_no_qe = {
+	.wait_ready = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+	.qe_enable = spi_do_not_qe_enable,
+};
+
+/*****************************************************************************/
+#define SPI_NAND_ID_TAB_VER     "2.7"
+
+/* ****** SPI Nand ID Table ***************************************************
+ * Version  Manufacturer    Chip Name   Size        Operation
+ * 1.0  ESMT        F50L512M41A     64MB        Add 5 chip
+ *      GD          5F1GQ4UAYIG     128MB
+ *      GD          5F2GQ4UAYIG     256MB
+ *	GD	    GD5F2GQ5UEYIG   256MB
+ *      GD          5F4GQ4UAYIG     512MB
+ *      GD          5F4GQ4UBYIG     512MB
+ *      GD          5F1GQ4RB9IG     128MB
+ *      GD          5F1GQ4UEYIHY    128MB
+ * 1.1  ESMT        F50L1G41A       128MB       Add 2 chip
+ *      Winbond     W25N01GV        128MB
+ *      Winbond     W25N02JWZEIF    256MB        1.8V
+ * 1.2  GD          5F1GQ4UBYIG     128MB       Add 2 chip
+ *      GD      5F2GQ4U9IGR/BYIG    256MB
+ * 1.3  ATO         ATO25D1GA       128MB       Add 1 chip
+ * 1.4  MXIC        MX35LF1GE4AB    128MB       Add 2 chip
+ *      MXIC        MX35LF2GE4AB    256MB       (SOP-16Pin)
+ * 1.5  Paragon     PN26G01A        128MB       Add 1 chip
+ * 1.6  All-flash   AFS1GQ4UAC      128MB       Add 1 chip
+ * 1.7  TOSHIBA     TC58CVG0S3H     128MB       Add 2 chip
+ *      TOSHIBA     TC58CVG2S0H     512MB
+ * 1.8  ALL-flash   AFS2GQ4UAD      256MB       Add 2 chip
+ *      Paragon     PN26G02A        256MB
+ * 1.9  TOSHIBA     TC58CVG1S3H     256MB       Add 1 chip
+ * 2.0  HeYangTek   HYF1GQ4UAACAE   128MB       Add 3 chip
+ *      HeYangTek   HYF2GQ4UAACAE   256MB
+ *      HeYangTek   HYF4GQ4UAACBE   512MB
+ * 2.1  Micron      MT29F1G01ABA    128MB       Add 5 chip
+ *      TOSHIBA 1.8V TC58CYG0S3H    128MB
+ *      TOSHIBA 1.8V TC58CYG1S3H    256MB
+ *      TOSHIBA 1.8V TC58CYG2S0H    512MB
+ *      Winbond 1.8V W25N01GWZEIG   128MB
+ * 2.2  Micron      MT29F2G01ABA    256MB       Add 1 chip
+ * 2.3  MXIC        MX35LF2G14AC    256MB       Add 1 chip
+ * 2.4  GD 1.8V     5F4GQ4RAYIG     512MB       Add 1 chip
+ * 2.5  GD 1.8V     5F2GQ4RB9IGR    256MB       Add 1 chip
+ *      GD 1.8V     5F4GQ6RE9IG     512MB
+ * 2.6  MXIC 1.8V   MX35UF1G14AC    128MB       Add 4 chip
+ *      MXIC 1.8V   MX35UF2G14AC    256MB
+ *      Micron 1.8V MT29F1G01ABB    128MB
+ *      Micron 1.8V MT29F2G01ABB    256MB
+ * 2.7  Dosilicon   DS35Q1GA-IB     128MB       Add 2 chip
+ *      Dosilicon   DS35Q2GA-IB     256MB
+ *      GD          5F1GQ4RB9IGR    128MB
+ *      Micron      MT29F4G01ADAG   512MB       Add 1 chip
+ *      GD 1.8V     5F4GQ4RBYIG     512MB       Add 1 chip
+ *      Etron 1.8V  EM78D044VCF-H   256MB
+ *      Etron 3.3V  EM73C044VCC-H   128MB
+ *      XTX 3.3V    XT26G01B 1Gbit  128MB
+ *      Micron 1.8V MT29F4G01ABBFDW 512MB		Add 1 chip
+ *	FM	    FM25S01-DND-A-G 128MB  	3.3V
+ *	HUAHONG	    FM25S01A	    128MB	3.3V
+ *****************************************************************************/
+struct spi_nand_info fmc_spi_nand_flash_table[] = {
+	/* Micron MT29F1G01ABA 1GBit */
+	{
+		.name      = "MT29F1G01ABA",
+		.id        = {0x2C, 0x14},
+		.id_len    = _2B,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			/* dummy clock:1 byte, read size:INFINITE bytes,
+			 * clock frq:24MHz */
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 80), /* 80MHz */
+			&read_dual(1, INFINITE, 80), /* 80MHz */
+			&read_dual_addr(1, INFINITE, 80), /* 80MHz */
+			&read_quad(1, INFINITE, 80), /* 80MHz */
+			&read_quad_addr(2, INFINITE, 80), /* 80MHz */
+			0
+		},
+		.write     = {
+			/* dummy clock:0byte, erase size:64K,
+			 * clock frq:80MHz */
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_quad(0, 256, 80), /* 80MHz */
+			0
+		},
+		.erase     = {
+			/* dummy clock:0byte, erase size:128K,
+			clock frq:80MHz */
+			&erase_sector_128k(0, _128K, 80), /* 80MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* Micron MT29F1G01ABB 1GBit 1.8V */
+	{
+		.name      = "MT29F1G01ABB",
+		.id        = {0x2C, 0x15},
+		.id_len    = _2B,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 80), /* 80MHz */
+			&read_dual(1, INFINITE, 80), /* 80MHz */
+			&read_dual_addr(1, INFINITE, 80), /* 80MHz */
+			&read_quad(1, INFINITE, 80), /* 80MHz */
+			&read_quad_addr(2, INFINITE, 80), /* 80MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_quad(0, 256, 80), /* 80MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 80), /* 80MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* Micron MT29F2G01ABA 2GBit */
+	{
+		.name      = "MT29F2G01ABA",
+		.id        = {0x2C, 0x24},
+		.id_len    = _2B,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 108),  /* 108MHz */
+			&read_dual(1, INFINITE, 108),  /* 108MHz */
+			&read_dual_addr(1, INFINITE, 108),  /* 108MHz */
+			&read_quad(1, INFINITE, 108),  /* 108MHz */
+			&read_quad_addr(2, INFINITE, 104), /* 104MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_quad(0, 256, 108), /* 108MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 80), /* 80MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* Micron MT29F2G01ABB 2GBit 1.8V */
+	{
+		.name      = "MT29F2G01ABB",
+		.id        = {0x2C, 0x25},
+		.id_len    = _2B,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 80), /* 80MHz */
+			&read_dual(1, INFINITE, 80), /* 80MHz */
+			&read_dual_addr(1, INFINITE, 80), /* 80MHz */
+			&read_quad(1, INFINITE, 80), /* 80MHz */
+			&read_quad_addr(2, INFINITE, 80), /* 80MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_quad(0, 256, 80), /* 80MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 80), /* 80MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* Micron MT29F4G01ADAG 4GBit 3.3V */
+	{
+		.name      = "MT29F4G01ADAG",
+		.id        = {0x2C, 0x36},
+		.id_len    = _2B,
+		.chipsize  = _512M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 80), /* 80MHz */
+			&read_dual(1, INFINITE, 80), /* 80MHz */
+			&read_dual_addr(1, INFINITE, 80), /* 80MHz */
+			&read_quad(1, INFINITE, 80), /* 80MHz */
+			&read_quad_addr(2, INFINITE, 80), /* 80MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_quad(0, 256, 80), /* 80MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 80), /* 80MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* Micron MT29F4G01ABBFDWB 4GBit 1.8V */
+	{
+		.name      = "MT29F4G01ABBFDWB",
+		.id        = {0x2C, 0x35},
+		.id_len    = _2B,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = _256B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 80),  /* 80MHz */
+			&read_dual(1, INFINITE, 80),  /* 80MHz */
+			&read_quad(1, INFINITE, 80),  /* 80MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_quad(0, 256, 80), /* 80MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_256k(0, _256K, 80), /* 80MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* ESMT F50L512M41A 512Mbit */
+	{
+		.name      = "F50L512M41A",
+		.id        = {0xC8, 0x20},
+		.id_len    = _2B,
+		.chipsize  = _64M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _64B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 104),  /* 104MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 24),  /* 24MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* ESMT F50L1G41A 1Gbit */
+	{
+		.name      = "F50L1G41A",
+		.id        = {0xC8, 0x21},
+		.id_len    = _2B,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _64B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 104),  /* 104MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 24),  /* 24MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* GD 3.3v GD5F1GQ4UAYIG 1Gbit */
+	{
+		.name      = "GD5F1GQ4UAYIG",
+		.id        = {0xc8, 0xf1},
+		.id_len    = _2B,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _64B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 120),  /* 120MHz */
+			&read_dual(1, INFINITE, 120),  /* 120MHz */
+			&read_dual_addr(1, INFINITE, 120),  /* 120MHz */
+			&read_quad(1, INFINITE, 120),  /* 120MHz */
+			&read_quad_addr(1, INFINITE, 120),  /* 120MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 120),  /* 120MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 24),  /* 24MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 1.8v GD5F1GQ4RB9IG 1Gbit */
+	{
+		.name      = "GD5F1GQ4RB9IG",
+		.id        = {0xc8, 0xc1},
+		.id_len    = _2B,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 120),  /* 120MHz */
+			&read_dual(1, INFINITE, 120),  /* 120MHz */
+			&read_dual_addr(1, INFINITE, 120),  /* 120MHz */
+			&read_quad(1, INFINITE, 120),  /* 120MHz */
+			&read_quad_addr(1, INFINITE, 120),  /* 120MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 120),  /* 120MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 24),  /* 24MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+	/* GD 3.3v GD5F1GQ4UBYIG 1Gbit */
+	{
+		.name      = "GD5F1GQ4UBYIG",
+		.id        = {0xc8, 0xd1},
+		.id_len    = _2B,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 120),  /* 120MHz */
+			&read_dual(1, INFINITE, 120),  /* 120MHz */
+			&read_dual_addr(1, INFINITE, 120),  /* 120MHz */
+			&read_quad(1, INFINITE, 120),  /* 120MHz */
+			&read_quad_addr(1, INFINITE, 120),  /* 120MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 120),  /* 120MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 24),  /* 24MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 3.3v GD5F2GQ4UAYIG 2Gbit */
+	{
+		.name      = "GD5F2GQ4UAYIG",
+		.id        = {0xc8, 0xf2},
+		.id_len    = _2B,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _64B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 120),  /* 120MHz */
+			&read_dual(1, INFINITE, 120),  /* 120MHz */
+			&read_dual_addr(1, INFINITE, 120),  /* 120MHz */
+			&read_quad(1, INFINITE, 120),  /* 120MHz */
+			&read_quad_addr(1, INFINITE, 120),  /* 120MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 120),  /* 120MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 24),  /* 24MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 3.3v GD5F2GQ4U9IGR/BYIG 2Gbit */
+	{
+		.name      = "GD5F2GQ4U9IGR/BYIG",
+		.id        = {0xc8, 0xd2},
+		.id_len    = _2B,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 120),  /* 120MHz */
+			&read_dual(1, INFINITE, 120),  /* 120MHz */
+			&read_dual_addr(1, INFINITE, 120),  /* 120MHz */
+			&read_quad(1, INFINITE, 120),  /* 120MHz */
+			&read_quad_addr(1, INFINITE, 120),  /* 120MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 120),  /* 120MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 24),  /* 24MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+
+	/* GD 3.3v GD5F4GQ4UAYIG 4Gbit */
+	{
+		.name      = "GD5F4GQ4UAYIG",
+		.id        = {0xc8, 0xf4},
+		.id_len    = _2B,
+		.chipsize  = _512M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _64B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 120),  /* 120MHz */
+			&read_dual(1, INFINITE, 120),  /* 120MHz */
+			&read_dual_addr(1, INFINITE, 120),  /* 120MHz */
+			&read_quad(1, INFINITE, 120),  /* 120MHz */
+			&read_quad_addr(1, INFINITE, 120),  /* 120MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 120),  /* 120MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 24),  /* 24MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 3.3v GD5F4GQ6UEYIG 4Gbit */
+	{
+		.name      = "GD5F4GQ6UEYIG",
+		.id        = {0xc8, 0x55},
+		.id_len    = _2B,
+		.chipsize  = _512M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104),  /* 104MHz */
+			&read_dual(1, INFINITE, 104),  /* 104MHz */
+			&read_dual_addr(2, INFINITE, 104),  /* 104MHz */
+			&read_quad(1, INFINITE, 104),  /* 104MHz */
+			&read_quad_addr(4, INFINITE, 104),  /* 104MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 104),  /* 104MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 104),  /* 104MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 3.3v GD5F4GQ4UBYIG 4Gbit */
+	{
+		.name      = "GD5F4GQ4UBYIG",
+		.id        = {0xc8, 0xd4},
+		.id_len    = _2B,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = _256B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 120),  /* 120MHz */
+			&read_dual(1, INFINITE, 120),  /* 120MHz */
+			&read_dual_addr(1, INFINITE, 120),  /* 120MHz */
+			&read_quad(1, INFINITE, 120),  /* 120MHz */
+			&read_quad_addr(1, INFINITE, 120),  /* 120MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 120),  /* 120MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_256k(0, _256K, 24),  /* 24MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 3.3v GD5F1GQ4UEYIHY 1Gbit */
+	{
+		.name      = "GD5F1GQ4UEYIHY",
+		.id        = {0xc8, 0xd9},
+		.id_len    = _2B,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _64B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 120),  /* 120MHz */
+			&read_dual(1, INFINITE, 120),  /* 120MHz */
+			&read_dual_addr(1, INFINITE, 120),  /* 120MHz */
+			&read_quad(1, INFINITE, 120),  /* 120MHz */
+			&read_quad_addr(1, INFINITE, 120),  /* 120MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 104), /* 104MHz */
+			&write_quad(0, 256, 120),  /* 120MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 104), /* 104MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 3.3v GD5F2GQ5UEYIG 2Gbit */
+	{
+		.name      = "GD5F2GQ5UEYIG",
+		.id        = {0xc8, 0x52},
+		.id_len    = _2B,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104),  /* 104MHz */
+			&read_dual(1, INFINITE, 104),  /* 104MHz */
+			&read_dual_addr(2, INFINITE, 104),  /* 104MHz */
+			&read_quad(1, INFINITE, 104),  /* 104MHz */
+			&read_quad_addr(4, INFINITE, 104),  /* 104MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 104), /* 104MHz */
+			&write_quad(0, 256, 104),  /* 104MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 104), /* 104MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 1.8V GD5F1GQ4RB9IGR 1Gbit */
+	{
+		.name      = "GD5F1GQ4RB9IGR",
+		.id        = {0xc8, 0xc1},
+		.id_len    = _2B,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_dual_addr(1, INFINITE, 104),
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			&read_quad_addr(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 104),  /* 104MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 24),  /* 24MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 1.8V GD5F2GQ4RB9IGR 2Gbit */
+	{
+		.name      = "GD5F2GQ4RB9IGR",
+		.id        = {0xc8, 0xc2},
+		.id_len    = _2B,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_dual_addr(1, INFINITE, 104),
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			&read_quad_addr(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 104),  /* 104MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 24),  /* 24MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+	/* GD 1.8V 5F4GQ6RE9IG 4Gbit */
+	{
+		.name      = "GD5F4GQ6RE9IG",
+		.id        = {0xc8, 0x45},
+		.id_len    = 2,
+		.chipsize  = _512M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24),
+			&read_fast(1, INFINITE, 80),
+			&read_dual(1, INFINITE, 80),
+			&read_dual_addr(2, INFINITE, 80),
+			&read_quad(1, INFINITE, 80),
+			&read_quad_addr(4, INFINITE, 80),
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 80),
+			&write_quad(0, 256, 80),
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 80),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+	/* GD 1.8V GD5F4GQ4RAYIG 4Gbit */
+	{
+		.name      = "GD5F4GQ4RAYIG",
+		.id        = {0xc8, 0xe4},
+		.id_len    = _2B,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = _256B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_dual_addr(1, INFINITE, 104),
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			&read_quad_addr(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 104),  /* 104MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_256k(0, _256K, 24),  /* 24MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 1.8V GD5F4GQ4RBYIG 4Gbit */
+	{
+		.name      = "GD5F4GQ4RBYIG",
+		.id        = {0xc8, 0xc4},
+		.id_len    = _2B,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = _256B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 120),  /* 120MHz */
+			&read_dual(1, INFINITE, 120),  /* 120MHz */
+			&read_dual_addr(1, INFINITE, 120),  /* 120MHz */
+			&read_quad(1, INFINITE, 120),  /* 120MHz */
+			&read_quad_addr(1, INFINITE, 120),  /* 120MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 120),  /* 120MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_256k(0, _256K, 24),  /* 24MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* Winbond 1.8V W25N02JWZEIF 2Gbit */
+	{
+		.name      = "W25N02JWZEIF",
+		.id        = {0xef, 0xbf, 0x22},
+		.id_len    = _3B,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _64B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 120),  /* 120MHz */
+			&read_dual(1, INFINITE, 120),  /* 120MHz */
+			&read_dual_addr(1, INFINITE, 120),  /* 120MHz */
+			&read_quad(1, INFINITE, 120),  /* 120MHz */
+			&read_quad_addr(2, INFINITE, 104), /* 104MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 104), /* 104MHz */
+			&write_quad(0, 256, 104),  /* 104MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 104), /* 104MHz */
+			0
+		},
+		.driver  = &spi_driver_general,
+	},
+
+	/* Winbond W25N01GV 1Gbit 3.3V */
+	{
+		.name      = "W25N01GV",
+		.id        = {0xef, 0xaa, 0x21},
+		.id_len    = _3B,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _64B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_dual_addr(1, INFINITE, 104),
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			&read_quad_addr(2, INFINITE, 104), /* 104MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 104),  /* 104MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 24),  /* 24MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* Winbond W25N01GWZEIG 1Gbit 1.8V */
+	{
+		.name      = "W25N01GWZEIG",
+		.id        = {0xef, 0xba, 0x21},
+		.id_len    = _3B,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _64B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_dual_addr(1, INFINITE, 104),
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			&read_quad_addr(2, INFINITE, 104), /* 104MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 80), /* 80MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 24),  /* 24MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* ATO ATO25D1GA 1Gbit */
+	{
+		.name      = "ATO25D1GA",
+		.id        = {0x9b, 0x12},
+		.id_len    = _2B,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _64B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 104),  /* 104MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 24),  /* 24MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* MXIC MX35LF1GE4AB 1Gbit */
+	{
+		.name      = "MX35LF1GE4AB",
+		.id        = {0xc2, 0x12},
+		.id_len    = _2B,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _64B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 104), /* 104MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 24),  /* 24MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* MXIC MX35UF1G14AC 1Gbit 1.8V */
+	{
+		.name      = "MX35UF1G14AC",
+		.id        = {0xc2, 0x90},
+		.id_len    = _2B,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _64B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 104),  /* 104MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 104), /* 104MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* MXIC MX35LF2GE4AB 2Gbit SOP-16Pin */
+	{
+		.name      = "MX35LF2GE4AB",
+		.id        = {0xc2, 0x22},
+		.id_len    = _2B,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _64B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 104),  /* 104MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 24),  /* 24MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* MXIC MX35LF2G14AC 2GBit */
+	{
+		.name      = "MX35LF2G14AC",
+		.id        = {0xc2, 0x20},
+		.id_len    = _2B,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _64B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 104),  /* 104MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 24),  /* 24MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* MXIC MX35UF2G14AC 2Gbit 1.8V */
+	{
+		.name      = "MX35UF2G14AC",
+		.id        = {0xc2, 0xa0},
+		.id_len    = _2B,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _64B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 104),  /* 104MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 104), /* 104MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* Paragon PN26G01A 1Gbit */
+	{
+		.name      = "PN26G01A",
+		.id        = {0xa1, 0xe1},
+		.id_len    = _2B,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 108),  /* 108MHz */
+			&read_dual(1, INFINITE, 108),  /* 108MHz */
+			&read_dual_addr(1, INFINITE, 108),  /* 108MHz */
+			&read_quad(1, INFINITE, 108),  /* 108MHz */
+			&read_quad_addr(1, INFINITE, 108),  /* 108MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 108), /* 108MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 24),  /* 24MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* Paragon PN26G02A 2Gbit */
+	{
+		.name      = "PN26G02A",
+		.id        = {0xa1, 0xe2},
+		.id_len    = _2B,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 108),  /* 108MHz */
+			&read_dual(1, INFINITE, 108),  /* 108MHz */
+			&read_dual_addr(1, INFINITE, 108),  /* 108MHz */
+			&read_quad(1, INFINITE, 108),  /* 108MHz */
+			&read_quad_addr(1, INFINITE, 108),  /* 108MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 108), /* 108MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 24),  /* 24MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* All-flash AFS1GQ4UAC 1Gbit */
+	{
+		.name      = "AFS1GQ4UAC",
+		.id        = {0xc1, 0x51},
+		.id_len    = _2B,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 80),  /* 80MHz */
+			&read_dual(1, INFINITE, 80),  /* 80MHz */
+			&read_dual_addr(1, INFINITE, 80),  /* 80MHz */
+			&read_quad(1, INFINITE, 80),  /* 80MHz */
+			&read_quad_addr(1, INFINITE, 80),  /* 80MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 80), /* 80MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 24),  /* 24MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* All-flash AFS2GQ4UAD 2Gbit */
+	{
+		.name      = "AFS2GQ4UAD",
+		.id        = {0xc1, 0x52},
+		.id_len    = _2B,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 80),  /* 80MHz */
+			&read_dual(1, INFINITE, 80),  /* 80MHz */
+			&read_dual_addr(1, INFINITE, 80),  /* 80MHz */
+			&read_quad(1, INFINITE, 80),  /* 80MHz */
+			&read_quad_addr(1, INFINITE, 80),  /* 80MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 24),  /* 24MHz */
+			&write_quad(0, 256, 80), /* 80MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 24),  /* 24MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* TOSHIBA TC58CVG0S3H 1Gbit */
+	{
+		.name      = "TC58CVG0S3H",
+		.id        = {0x98, 0xc2},
+		.id_len    = _2B,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 104), /* 104MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 104), /* 104MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* TOSHIBA TC58CYG0S3H 1.8V 1Gbit */
+	{
+		.name      = "TC58CYG0S3H",
+		.id        = {0x98, 0xb2},
+		.id_len    = _2B,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 104), /* 104MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 104), /* 104MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* TOSHIBA TC58CYG0S3HRAIJ 1.8V 1Gbit */
+	{
+		.name      = "TC58CYG0S3HRAIJ",
+		.id        = {0x98, 0xD2, 0x40},
+		.id_len    = _3B,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 133), /* 133MHz */
+			&read_dual(1, INFINITE, 133), /* 133MHz */
+			&read_quad(1, INFINITE, 133), /* 133MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 133), /* 133MHz */
+			&write_quad(0, 256, 133), /* 133MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 133), /* 133MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* TOSHIBA TC58CVG1S3H 2Gbit */
+	{
+		.name      = "TC58CVG1S3H",
+		.id        = {0x98, 0xcb},
+		.id_len    = _2B,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 104), /* 104MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 104), /* 104MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* TOSHIBA TC58CYG1S3H 1.8V 2Gbit */
+	{
+		.name      = "TC58CYG1S3H",
+		.id        = {0x98, 0xbb},
+		.id_len    = _2B,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 75), /* 75MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 75), /* 75MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* TOSHIBA TC58CVG1S3HRAIJ 3.3V 2Gbit */
+	{
+		.name      = "TC58CVG1S3HRAIJ",
+		.id        = {0x98, 0xeb, 0x40},
+		.id_len    = _3B,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 133), /* 133MHz */
+			&read_dual(1, INFINITE, 133), /* 133MHz */
+			&read_quad(1, INFINITE, 133), /* 133MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 133), /* 133MHz */
+			&write_quad(0, 256, 133), /* 133MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 133), /* 133MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* TOSHIBA TC58CVG2S0H 4Gbit */
+	{
+		.name      = "TC58CVG2S0H",
+		.id        = {0x98, 0xcd},
+		.id_len    = _2B,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = _256B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 104), /* 104MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_256k(0, _256K, 104), /* 104MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* TOSHIBA TC58CYG2S0H 1.8V 4Gbit */
+	{
+		.name      = "TC58CYG2S0H",
+		.id        = {0x98, 0xbd},
+		.id_len    = _2B,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = _256B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 75), /* 75MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_256k(0, _256K, 75), /* 75MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* KIOXIA TC58CYG2S0HRAIJ 1.8V 4Gbit */
+	{
+		.name      = "TC58CYG2S0HRAIJ",
+		.id        = {0x98, 0xdd, 0x51},
+		.id_len    = _3B,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = _256B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 133), /* 133MHz */
+			&read_dual(1, INFINITE, 133), /* 133MHz */
+			&read_quad(1, INFINITE, 133), /* 133MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 133), /* 133MHz */
+			&write_quad(0, 256, 133), /* 133MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_256k(0, _256K, 133), /* 133MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* KIOXIA TH58CYG3S0H 1.8V 8Gbit */
+	{
+		.name      = "TH58CYG3S0H",
+		.id        = {0x98, 0xd4, 0x51},
+		.id_len    = _3B,
+		.chipsize  = _1G,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = _256B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 133), /* 133MHz */
+			&read_dual(1, INFINITE, 133), /* 133MHz */
+			&read_quad(1, INFINITE, 133), /* 133MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 133), /* 133MHz */
+			&write_quad(0, 256, 133), /* 133MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_256k(0, _256K, 133), /* 133MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* HeYangTek HYF1GQ4UAACAE 1Gbit */
+	{
+		.name      = "HYF1GQ4UAACAE",
+		.id        = {0xc9, 0x51},
+		.id_len    = _2B,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 60), /* 60MHz */
+			&read_dual(1, INFINITE, 60), /* 60MHz */
+			&read_dual_addr(1, INFINITE, 60), /* 60MHz */
+			&read_quad(1, INFINITE, 60), /* 60MHz */
+			&read_quad_addr(1, INFINITE, 60), /* 60MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_quad(0, 256, 80), /* 80MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 80), /* 80MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* HeYangTek HYF2GQ4UAACAE 2Gbit */
+	{
+		.name      = "HYF2GQ4UAACAE",
+		.id        = {0xc9, 0x52},
+		.id_len    = _2B,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 60), /* 60MHz */
+			&read_dual(1, INFINITE, 60), /* 60MHz */
+			&read_dual_addr(1, INFINITE, 60), /* 60MHz */
+			&read_quad(1, INFINITE, 60), /* 60MHz */
+			&read_quad_addr(1, INFINITE, 60), /* 60MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_quad(0, 256, 80), /* 80MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 80), /* 80MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* HeYangTek HYF4GQ4UAACBE 4Gbit */
+	{
+		.name      = "HYF4GQ4UAACBE",
+		.id        = {0xc9, 0xd4},
+		.id_len    = _2B,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = _256B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 60), /* 60MHz */
+			&read_dual(1, INFINITE, 60), /* 60MHz */
+			&read_dual_addr(1, INFINITE, 60), /* 60MHz */
+			&read_quad(1, INFINITE, 60), /* 60MHz */
+			&read_quad_addr(1, INFINITE, 60), /* 60MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_quad(0, 256, 80), /* 80MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_256k(0, _256K, 80), /* 80MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* Dosilicon 3.3V DS35Q1GA-IB 1Gbit */
+	{
+		.name      = "DS35Q1GA-IB",
+		.id        = {0xe5, 0x71},
+		.id_len    = _2B,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _64B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_quad(0, 256, 104),  /* 104MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 104), /* 104MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* XTX 3.3V XT26G01B 1Gbit */
+	{
+		.name      = "XT26G01B",
+		.id        = {0x0B, 0xF1},
+		.id_len    = _2B,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _64B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 80),  /* 80MHz */
+			&read_dual(1, INFINITE, 80),  /* 80MHz */
+			&read_dual_addr(1, INFINITE, 80),  /* 80MHz */
+			&read_quad(1, INFINITE, 80),  /* 80MHz */
+			&read_quad_addr(1, INFINITE, 80),  /* 80MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_quad(0, 256, 80), /* 80MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 80), /* 80MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* Etron 1.8V EM78F044VCA-H 8Gbit */
+	{
+		.name      = "EM78F044VCA-H",
+		.id        = {0xD5, 0x8D},
+		.id_len    = _2B,
+		.chipsize  = _1G,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = _256B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 100), /* 100MHz */
+			&read_dual(1, INFINITE, 100), /* 100MHz */
+			&read_dual_addr(1, INFINITE, 100),  /* 100MHz */
+			&read_quad(1, INFINITE, 100),  /* 100MHz */
+			&read_quad_addr(1, INFINITE, 100),  /* 100MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 100),  /* 100MHz */
+			&write_quad(0, 256, 100),  /* 100MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_256k(0, _256K, 100),  /* 100MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* Etron 1.8V EM78E044VCA-H 4Gbit */
+	{
+		.name      = "EM78E044VCA-H",
+		.id        = {0xD5, 0x8C},
+		.id_len    = _2B,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = _256B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 100), /* 100MHz */
+			&read_dual(1, INFINITE, 100), /* 100MHz */
+			&read_dual_addr(1, INFINITE, 100),  /* 100MHz */
+			&read_quad(1, INFINITE, 100),  /* 100MHz */
+			&read_quad_addr(1, INFINITE, 100),  /* 100MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 100),  /* 100MHz */
+			&write_quad(0, 256, 100),  /* 100MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_256k(0, _256K, 100),  /* 100MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* Etron 1.8V EM78D044VCF-H 2Gbit */
+	{
+		.name      = "EM78D044VCF-H",
+		.id        = {0xd5, 0x81},
+		.id_len    = _2B,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _64B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_dual_addr(1, INFINITE, 104),
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			&read_quad_addr(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_quad(0, 256, 104),  /* 104MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 104), /* 104MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+	/* Etron 3.3V EM73C044VCC-H 1Gbit */
+	{
+		.name      = "EM73C044VCC-H",
+		.id        = {0xd5, 0x22},
+		.id_len    = _2B,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _64B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24),
+			&read_fast(1, INFINITE, 120),
+			&read_dual(1, INFINITE, 120),
+			&read_dual_addr(1, INFINITE, 120),
+			&read_quad(1, INFINITE, 120),
+			&read_quad_addr(1, INFINITE, 120),
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 104),
+			&write_quad(0, 256, 120),
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 104),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+	/* Dosilicon 3.3V DS35Q2GA-IB 1Gb */
+	{
+		.name      = "DS35Q2GA-IB",
+		.id        = {0xe5, 0x72},
+		.id_len    = _2B,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _64B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_quad(0, 256, 104),  /* 104MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 104), /* 104MHz */
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* FM 3.3V FM25S01-DND-A-G 1Gb */
+	{
+		.name      = "FM25S01-DND-A-G",
+		.id        = {0xa1, 0xa1},
+		.id_len    = _2B,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _128B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_dual_addr(1, INFINITE, 40), /* 40MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			&read_quad_addr(2, INFINITE, 40), /* 40MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 104), /* 104MHz */
+			&write_quad(0, 256, 104),  /* 104MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 104), /* 104MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* FM 3.3V FM25S01A 1Gb */
+	{
+		.name      = "FM25S01A",
+		.id        = {0xa1, 0xe4},
+		.id_len    = _2B,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = _64B,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&read_std(1, INFINITE, 24), /* 24MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_dual_addr(1, INFINITE, 40), /* 40MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			&read_quad_addr(2, INFINITE, 40), /* 40MHz */
+			0
+		},
+		.write     = {
+			&write_std(0, 256, 104), /* 104MHz */
+			&write_quad(0, 256, 104),  /* 104MHz */
+			0
+		},
+		.erase     = {
+			&erase_sector_128k(0, _128K, 104), /* 104MHz */
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	{   .id_len    = 0, },
+};
+
+/*****************************************************************************/
+static void fmc100_spi_nand_search_rw(struct spi_nand_info *spiinfo,
+				struct spi_op *spiop_rw, u_int iftype,
+				u_int max_dummy, int rw_type)
+{
+	int ix = 0;
+	struct spi_op **spiop = NULL;
+	struct spi_op **fitspiop = NULL;
+
+	for (fitspiop = spiop = (rw_type ? spiinfo->write : spiinfo->read);
+	     (*spiop) && ix < MAX_SPI_OP; spiop++, ix++)
+		if (((*spiop)->iftype & iftype) &&
+		((*spiop)->dummy <= max_dummy) &&
+		((*fitspiop)->iftype < (*spiop)->iftype))
+			fitspiop = spiop;
+
+	memcpy(spiop_rw, (*fitspiop), sizeof(struct spi_op));
+}
+
+/*****************************************************************************/
+static void fmc100_spi_nand_get_erase(struct spi_nand_info *spiinfo,
+				struct spi_op *spiop_erase)
+{
+	int ix;
+
+	spiop_erase->size = 0;
+	for (ix = 0; ix < MAX_SPI_OP; ix++) {
+		if (spiinfo->erase[ix] == NULL)
+			break;
+		if (spiinfo->erasesize == spiinfo->erase[ix]->size) {
+			memcpy(&spiop_erase[ix], spiinfo->erase[ix],
+			       sizeof(struct spi_op));
+			break;
+		}
+	}
+}
+
+/*****************************************************************************/
+static void fmc100_map_spi_op(struct fmc_spi *spi)
+{
+	unsigned char ix = 0;
+
+	const int iftype_read[] = {
+		SPI_IF_READ_STD,    IF_TYPE_STD,
+		SPI_IF_READ_FAST,   IF_TYPE_STD,
+		SPI_IF_READ_DUAL,   IF_TYPE_DUAL,
+		SPI_IF_READ_DUAL_ADDR,  IF_TYPE_DIO,
+		SPI_IF_READ_QUAD,   IF_TYPE_QUAD,
+		SPI_IF_READ_QUAD_ADDR,  IF_TYPE_QIO,
+		0,          0,
+	};
+	const int iftype_write[] = {
+		SPI_IF_WRITE_STD,   IF_TYPE_STD,
+		SPI_IF_WRITE_QUAD,  IF_TYPE_QUAD,
+		0,          0,
+	};
+	const char *if_str[] = {"STD", "DUAL", "DIO", "QUAD", "QIO"};
+
+	fmc_pr(BT_DBG, "\t||*-Start Get SPI operation iftype & clock\n");
+	/* the element with an even number of arrays, so increase is 2 */
+	for (ix = 0; iftype_write[ix]; ix += 2) {
+		if (spi->write->iftype == iftype_write[ix]) {
+			spi->write->iftype = iftype_write[ix + 1];
+			break;
+		}
+	}
+	fmc_get_fmc_best_2x_clock(&spi->write->clock);
+	fmc_pr(BT_DBG, "\t|||-Get best write iftype: %s clock type: %d\n",
+	       if_str[spi->write->iftype],
+	       get_fmc_clk_type(spi->write->clock));
+	/* the element with an even number of arrays, so increase is 2 */
+	for (ix = 0; iftype_read[ix]; ix += 2) {
+		if (spi->read->iftype == iftype_read[ix]) {
+			spi->read->iftype = iftype_read[ix + 1];
+			break;
+		}
+	}
+	fmc_get_fmc_best_2x_clock(&spi->read->clock);
+	fmc_pr(BT_DBG, "\t|||-Get best read iftype: %s clock type: %d\n",
+	       if_str[spi->read->iftype],
+	       get_fmc_clk_type(spi->read->clock));
+
+	fmc_get_fmc_best_2x_clock(&spi->erase->clock);
+	spi->erase->iftype = IF_TYPE_STD;
+	fmc_pr(BT_DBG, "\t|||-Get best erase iftype: %s clock type: %d\n",
+	       if_str[spi->erase->iftype],
+	       get_fmc_clk_type(spi->erase->clock));
+
+	fmc_pr(BT_DBG, "\t||*-End Get SPI operation iftype & clock\n");
+}
+
+/*****************************************************************************/
+static void fmc100_spi_ids_probe(struct fmc_host *host,
+				struct spi_nand_info *spi_dev)
+{
+	unsigned int reg;
+	struct fmc_spi *spi = host->spi;
+	unsigned char *fmc_cs = get_cs_number(host->cmd_op.cs);
+
+	fmc_pr(BT_DBG, "\t|*-Start match SPI operation & chip init\n");
+
+	spi->host = host;
+	spi->name = spi_dev->name;
+	spi->driver = spi_dev->driver;
+
+	fmc100_spi_nand_search_rw(spi_dev, spi->read,
+			FMC_SPI_NAND_SUPPORT_READ,
+			FMC_SPI_NAND_SUPPORT_MAX_DUMMY, RW_OP_READ);
+	fmc_pr(BT_DBG, "\t||-Save spi->read op cmd:%#x\n", spi->read->cmd);
+
+	fmc100_spi_nand_search_rw(spi_dev, spi->write,
+				FMC_SPI_NAND_SUPPORT_WRITE,
+				FMC_SPI_NAND_SUPPORT_MAX_DUMMY, RW_OP_WRITE);
+	fmc_pr(BT_DBG, "\t||-Save spi->write op cmd:%#x\n", spi->write->cmd);
+
+	fmc100_spi_nand_get_erase(spi_dev, spi->erase);
+	fmc_pr(BT_DBG, "\t||-Save spi->erase op cmd:%#x\n", spi->erase->cmd);
+
+	fmc100_map_spi_op(spi);
+
+	spi->driver->qe_enable(spi);
+
+	/* Disable write protection */
+	reg = spi_nand_feature_op(spi, GET_OP, PROTECT_ADDR, 0);
+	fmc_pr(BT_DBG, "\t||-Get protect status[%#x]: %#x\n", PROTECT_ADDR, reg);
+	if (any_bp_enable(reg)) {
+		reg &= ~ALL_BP_MASK;
+		spi_nand_feature_op(spi, SET_OP, PROTECT_ADDR, reg);
+		fmc_pr(BT_DBG, "\t||-Set [%#x]FT %#x\n", PROTECT_ADDR, reg);
+
+		spi->driver->wait_ready(spi);
+
+		reg = spi_nand_feature_op(spi, GET_OP, PROTECT_ADDR, 0);
+		fmc_pr(BT_DBG, "\t||-Check BP disable result: %#x\n", reg);
+		if (any_bp_enable(reg))
+			db_msg("Error: Write protection disable failed!\n");
+	}
+
+	/* Disable chip internal ECC */
+	reg = spi_nand_feature_op(spi, GET_OP, FEATURE_ADDR, 0);
+	fmc_pr(BT_DBG, "\t||-Get feature status[%#x]: %#x\n", FEATURE_ADDR, reg);
+	if (reg & FEATURE_ECC_ENABLE) {
+		reg &= ~FEATURE_ECC_ENABLE;
+		spi_nand_feature_op(spi, SET_OP, FEATURE_ADDR, reg);
+		fmc_pr(BT_DBG, "\t||-Set [%#x]FT: %#x\n", FEATURE_ADDR, reg);
+
+		spi->driver->wait_ready(spi);
+
+		reg = spi_nand_feature_op(spi, GET_OP, FEATURE_ADDR, 0);
+		fmc_pr(BT_DBG, "\t||-Check internal ECC disable result: %#x\n",
+		       reg);
+		if (reg & FEATURE_ECC_ENABLE)
+			db_msg("Error: Chip internal ECC disable failed!\n");
+	}
+
+	(*fmc_cs)++;
+
+	fmc_pr(BT_DBG, "\t|*-End match SPI operation & chip init\n");
+}
+
+static struct nand_flash_dev spi_nand_dev;
+/*****************************************************************************/
+static struct nand_flash_dev *spi_nand_get_flash_info(struct mtd_info *mtd,
+				struct nand_chip *chip, unsigned char *id)
+{
+	unsigned char ix;
+	unsigned char len;
+	char buffer[TMP_BUF_LEN];
+	struct fmc_host *host = chip->priv;
+	struct spi_nand_info *spi_dev = fmc_spi_nand_flash_table;
+	struct nand_flash_dev *type = &spi_nand_dev;
+
+	fmc_pr(BT_DBG, "\t*-Start find SPI Nand flash\n");
+
+	len = sprintf(buffer, "SPI Nand(cs %d) ID: %#x %#x",
+		      host->cmd_op.cs, id[0], id[1]);
+
+	for (; spi_dev->id_len; spi_dev++) {
+		if (memcmp(id, spi_dev->id, spi_dev->id_len))
+			continue;
+		/* element with an even number of arrays, so increase is 2 */
+		for (ix = 2; ix < spi_dev->id_len; ix++)
+			len += sprintf(buffer + len, " %#x", id[ix]);
+		printf("%s Name:\"%s\"\n", buffer, spi_dev->name);
+
+		fmc_pr(BT_DBG, "\t||-CS(%d) found SPI Nand: %s\n",
+		       host->cmd_op.cs, spi_dev->name);
+
+		type->name = spi_dev->name;
+		memcpy(type->id, spi_dev->id, spi_dev->id_len);
+		type->pagesize = spi_dev->pagesize;
+		type->chipsize = byte_to_mb(spi_dev->chipsize);
+		type->erasesize = spi_dev->erasesize;
+		type->id_len = spi_dev->id_len;
+		type->oobsize = spi_dev->oobsize;
+		type->options = chip->options;
+		fmc_pr(BT_DBG, "\t|-Save struct spi_nand_info info\n");
+
+		mtd->size = spi_dev->chipsize;
+
+		fmc100_spi_ids_probe(host, spi_dev);
+
+		fmc_pr(BT_DBG, "\t*-Found SPI nand: %s\n", spi_dev->name);
+
+		return type;
+	}
+
+	fmc_pr(BT_DBG, "\t*-Not found SPI nand flash, ID: %s\n", buffer);
+
+	return NULL;
+}
+
+/*****************************************************************************/
+void fmc_spi_nand_ids_register(void)
+{
+#ifndef CONFIG_SYS_NAND_QUIET_TEST
+	printf("SPI Nand ID Table Version %s\n", SPI_NAND_ID_TAB_VER);
+#endif
+	get_flash_type = spi_nand_get_flash_info;
+}
diff -uraN u-boot-2016.11/drivers/mtd/nand/fmc100/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/fmc100/Makefile
--- u-boot-2016.11/drivers/mtd/nand/fmc100/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/fmc100/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1 @@
+obj-y += fmc100.o fmc100_os.o fmc_spi_nand_ids.o
diff -uraN u-boot-2016.11/drivers/mtd/nand/Kconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/Kconfig
--- u-boot-2016.11/drivers/mtd/nand/Kconfig	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/Kconfig	2021-06-07 13:01:32.000000000 +0300
@@ -87,6 +87,62 @@
 	  This enables NAND driver for the NAND flash controller on the
 	  MXS processors.
 
+config FMC_SPI_NAND
+	bool "Goke SPI Nand Flash Interface support"
+	depends on FMC
+	help
+	  Enable the Goke SPI Nand flash support.
+
+	  If unsure, say N
+
+config SPI_NAND_MAX_CHIP_NUM
+    int "Support max number of SPI Nand flash chip (1, 2)"
+	depends on FMC_SPI_NAND
+    default 1
+    help
+      flash memory controller v100 device only support 1 or 2 SPI nand flash
+      chip, your should not config other value.
+
+config NAND_MAX_CHIP_NUM
+    int "Support max number of Nand flash chip (1, 2)"
+	depends on FMC_NAND
+    default 1
+    help
+      flash memory controller v100 device only support 1 or 2 nand flash
+      chip, your should not config other value.
+
+if FMC_SPI_NAND || FMC_NAND
+
+choice
+    prompt "Page Size and Ecc Type Select"
+    default FMC100_AUTO_PAGESIZE_ECC
+
+config FMC100_HARDWARE_PAGESIZE_ECC
+    bool "Hardware"
+    help
+      the configure of page size and ecc type lie on switch on the board.
+      so the page size and ecc type is controlled by Hardware see demo
+      board of SOC.
+
+config FMC100_AUTO_PAGESIZE_ECC
+    bool "Auto"
+    help
+      auto-sensed the page size and ecc type value. driver will try each of
+      page size and ecc type one by one till flash can be read and wrote
+      accurately. so the page size and ecc type is match adaptively without
+      switch on the board
+
+config FMC100_PAGESIZE_AUTO_ECC_NONE
+    bool "Pagesize Auto, Ecc None"
+    help
+      auto-sensed the page size and select ecc none. driver will try each
+      of page size one by one till flash can be read and wrote accurately.
+      so the page size is match adaptively without switch on the board
+
+endchoice
+
+endif
+
 comment "Generic NAND options"
 
 # Enhance depends when converting drivers to Kconfig which use this config
diff -uraN u-boot-2016.11/drivers/mtd/nand/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/Makefile
--- u-boot-2016.11/drivers/mtd/nand/Makefile	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -33,6 +33,8 @@
 obj-y += nand_ecc.o
 obj-y += nand_base.o
 obj-y += nand_timings.o
+obj-$(CONFIG_CMD_NAND) += nfc_common.o
+obj-$(CONFIG_FMC_SPI_NAND) += fmc100/
 
 endif # not spl
 
diff -uraN u-boot-2016.11/drivers/mtd/nand/nand_base.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/nand_base.c
--- u-boot-2016.11/drivers/mtd/nand/nand_base.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/nand_base.c	2021-06-07 13:01:32.000000000 +0300
@@ -45,6 +45,7 @@
 #endif
 #include <asm/io.h>
 #include <linux/errno.h>
+#include <nfc_common.h>
 
 /* Define default oob placement schemes for large and small page devices */
 static struct nand_ecclayout nand_oob_8 = {
@@ -880,7 +881,7 @@
 
  	u32 timer = (CONFIG_SYS_HZ * timeo) / 1000;
  	u32 time_start;
- 
+
  	time_start = get_timer(0);
  	while (get_timer(time_start) < timer) {
 		if (chip->dev_ready) {
@@ -2372,6 +2373,10 @@
 	int ret;
 	int oob_required = oob ? 1 : 0;
 
+#if defined(CONFIG_FMC_SPI_NAND)|| defined(CONFIG_FMC_NAND)
+    oob_required = 1;
+#endif
+
 	ops->retlen = 0;
 	if (!writelen)
 		return 0;
@@ -3593,6 +3598,14 @@
 	return false;
 }
 
+/* The info for burn */
+static struct mtd_info_ex nand_info_ex = {.type = 0, };
+
+struct mtd_info_ex *get_nand_info(void)
+{
+	    return &nand_info_ex;
+}
+
 /*
  * Get the flash and manufacturer id and lookup if the type is supported.
  */
@@ -3640,6 +3653,11 @@
 		return ERR_PTR(-ENODEV);
 	}
 
+#ifdef CONFIG_FMC
+	if (get_flash_type)
+		type = get_flash_type(mtd, chip, id_data);
+#endif
+
 	if (!type)
 		type = nand_flash_ids;
 
@@ -3687,6 +3705,11 @@
 	if (*maf_id != NAND_MFR_SAMSUNG && !type->pagesize)
 		chip->options &= ~NAND_SAMSUNG_LP_OPTIONS;
 ident_done:
+#ifdef CONFIG_FMC
+	if (nand_oob_resize
+			&& nand_oob_resize(mtd))
+		return ERR_PTR(-ENODEV);
+#endif
 
 	/* Try to identify manufacturer */
 	for (maf_idx = 0; nand_manuf_ids[maf_idx].id != 0x0; maf_idx++) {
@@ -3712,6 +3735,30 @@
 		return ERR_PTR(-EINVAL);
 	}
 
+	if (nand_info_ex.type == 0) {
+		memset(&nand_info_ex, 0, sizeof(struct mtd_info_ex));
+
+		nand_info_ex.type      = MTD_NANDFLASH;
+		nand_info_ex.chipsize  = chip->chipsize;
+		nand_info_ex.erasesize = mtd->erasesize;
+		nand_info_ex.pagesize  = mtd->writesize;
+		/* smaller than nand chip space area */
+		nand_info_ex.oobsize   = mtd->oobsize;
+
+		nand_info_ex.ecctype   = mtd->ecc_strength;
+
+		nand_info_ex.id_length = type->id_len;
+		nand_info_ex.numchips  = 1;
+
+		memcpy(nand_info_ex.ids, id_data,
+				nand_info_ex.id_length);
+
+		strncpy(nand_info_ex.name, mtd->name,
+				sizeof(nand_info_ex.name));
+
+		nand_info_ex.name[sizeof(nand_info_ex.name)-1] = '\0';
+	}
+
 	nand_decode_bbm_options(mtd, chip, id_data);
 
 	/* Calculate the address shift from the page size */
@@ -3755,9 +3802,6 @@
 	else
 		pr_info("%s %s\n", nand_manuf_ids[maf_idx].name,
 				type->name);
-
-	pr_info("%s %s\n", nand_manuf_ids[maf_idx].name,
-		type->name);
 #endif
 
 	pr_info("%d MiB, %s, erase size: %d KiB, page size: %d, OOB size: %d\n",
@@ -3891,6 +3935,18 @@
 	chip->numchips = i;
 	mtd->size = i * chip->chipsize;
 
+	if (nand_info_ex.type != MTD_NANDFLASH)
+		BUG();
+
+	nand_info_ex.numchips = chip->numchips;
+
+	printf("Block:%sB ", ultohstr(mtd->erasesize));
+	printf("Page:%sB ",  ultohstr(mtd->writesize));
+	printf("OOB:%sB ", ultohstr(mtd->oobsize));
+	printf("ECC:%s ", nand_ecc_name(nand_info_ex.ecctype));
+	printf("\n");
+	printf("Chipsize:");
+
 	return 0;
 }
 EXPORT_SYMBOL(nand_scan_ident);
diff -uraN u-boot-2016.11/drivers/mtd/nand/nand_ids.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/nand_ids.c
--- u-boot-2016.11/drivers/mtd/nand/nand_ids.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/nand_ids.c	2021-06-07 13:01:32.000000000 +0300
@@ -195,6 +195,9 @@
 	{NAND_MFR_SANDISK, "SanDisk"},
 	{NAND_MFR_INTEL, "Intel"},
 	{NAND_MFR_ATO, "ATO"},
+	{NAND_MFR_HEYANGTEK, "HeYangTek"},
+	{NAND_MFR_DOSILICON, "Dosilicon"},
+	{NAND_MFR_FIDELIX, "Fidelix/Dosi"}, /* Fidelix was purchased by Dosilicon */
 	{0x0, "Unknown"}
 };
 
diff -uraN u-boot-2016.11/drivers/mtd/nand/nand_util.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/nand_util.c
--- u-boot-2016.11/drivers/mtd/nand/nand_util.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/nand_util.c	2021-06-07 13:01:32.000000000 +0300
@@ -34,6 +34,8 @@
 typedef struct erase_info	erase_info_t;
 typedef struct mtd_info		mtd_info_t;
 
+/* for ecc0 read and write */
+unsigned int ecc0_flag;
 /* support only for native endian JFFS2 */
 #define cpu_to_je16(x) (x)
 #define cpu_to_je32(x) (x)
@@ -602,6 +604,10 @@
 
 	need_skip = check_skip_len(mtd, offset, *length, &used_for_write);
 
+	/* add to cooperate with tool */
+	print_to_tool("pure data length is %d, len_incl_bad is %d\r\n",
+	       (u_int)*length, (u_int)used_for_write);
+
 	if (actual)
 		*actual = used_for_write;
 
@@ -782,6 +788,309 @@
 	return 0;
 }
 
+/**
+ * nand_write_yaffs_skip_bad:
+ *
+ * Write image to NAND flash.
+ * Blocks that are marked bad are skipped and the is written to the next
+ * block instead as long as the image is short enough to fit even after
+ * skipping the bad blocks.
+ *
+ * @param nand   NAND device
+ * @param offset offset in flash
+ * @param length buffer length
+ * @param buf           buffer to read from
+ * @return       0 in case of success
+ */
+int nand_write_yaffs_skip_bad(struct mtd_info *mtd, loff_t offset, size_t *length,
+		u_char *buffer)
+{
+	int rval;
+	size_t left_to_write;
+	size_t len_incl_bad = 0;
+	u_char *p_buffer = buffer;
+	mtd_oob_ops_t ops = {0};
+	int     i;
+	size_t  length_data;  /* length without oob */
+	u_int32_t oobsize;
+	int need_skip;
+
+	oobsize = mtd->oobsize;
+
+	/* Reject writes, which are not page aligned */
+	if (((unsigned long long)offset & (mtd->writesize - 1)) != 0) {
+		printf("Attempt to write non page aligned data, offset %#x\n",
+			(u_int)offset);
+		return -EINVAL;
+	}
+	if ((*length % (mtd->writesize  + oobsize)) != 0) {
+		printf("Attempt to write non page aligned data, length %#x\n",
+			(u_int)*length);
+		printf("Page size %#x, OOB size %d\n", (u_int)mtd->writesize,
+			oobsize);
+		return -EINVAL;
+	}
+
+	length_data = (*length / (mtd->writesize + oobsize))
+			* mtd->writesize;
+	
+	need_skip = check_skip_len(mtd, offset, length_data, &len_incl_bad);
+	if (need_skip < 0) {
+		printf("Attempt to read outside the flash area\n");
+		*length = 0;
+		return -EINVAL;
+	}
+
+	if (len_incl_bad != length_data)
+		printf("data length:%#x, include bad block length: %#x\n",
+			(u_int)length_data, (u_int)len_incl_bad);
+
+	if ((offset + len_incl_bad) >= mtd->size) {
+		printf("Attempt to write outside the flash area\n");
+		return -EINVAL;
+	}
+
+	/* add to cooperate with tool */
+	print_to_tool("pure data length is %d, len_incl_bad is %d\r\n",
+		length_data, len_incl_bad);
+
+	if (len_incl_bad == length_data) {
+		for (i = 0; i < length_data / mtd->writesize; i++) {
+			ops.datbuf = buffer
+					+ i * (mtd->writesize + oobsize);
+			ops.oobbuf = buffer
+					+ i * (mtd->writesize + oobsize)
+					+ mtd->writesize;
+			ops.len = mtd->writesize;
+			ops.ooblen = oobsize;
+			ops.mode = MTD_OPS_RAW;
+
+			rval = mtd_write_oob(mtd, offset
+						+ i * mtd->writesize, &ops);
+			if (rval != 0) {
+				printf("NAND write to offset %llx failed %d\n",
+					offset + i*mtd->writesize, rval);
+				return rval;
+			}
+		}
+
+		printf("NAND write yaffs finished\n");
+		return 0;
+	}
+
+	left_to_write = length_data;
+
+	while (left_to_write > 0) {
+		size_t block_offset = (unsigned long long)offset & (mtd->erasesize - 1);
+		size_t write_size;
+
+		if (nand_block_isbad(mtd, (unsigned long long)offset
+					& ~((loff_t)mtd->erasesize - 1))) {
+			printf("Skip bad block 0x%08llx\n",
+				(unsigned long long)offset & ~((loff_t)mtd->erasesize - 1));
+			offset += mtd->erasesize - block_offset;
+			continue;
+		}
+
+		if (left_to_write < (mtd->erasesize - block_offset))
+			write_size = left_to_write;
+		else
+			write_size = mtd->erasesize - block_offset;
+
+		for (i = 0; i < write_size / mtd->writesize; i++) {
+			ops.datbuf = p_buffer;
+			ops.oobbuf = p_buffer + mtd->writesize;
+			ops.len = mtd->writesize;
+			ops.ooblen = oobsize;
+			ops.ooboffs = 0;
+			ops.mode = MTD_OPS_RAW;
+
+			rval = mtd_write_oob(mtd, offset, &ops);
+			if (rval != 0) {
+				printf("NAND write to offset %llx failed %d\n",
+						offset, rval);
+				*length -= left_to_write;
+				return rval;
+			}
+
+			p_buffer += mtd->writesize + oobsize;
+			left_to_write -= mtd->writesize;
+			offset        += mtd->writesize;
+		}
+	}
+
+	printf("\n");
+	return 0;
+}
+
+
+/**
+ * nand_fill_ecc - [Internal] Process oob to client buffer
+ * @chip:	nand chip structure
+ * @oob:	oob destination address
+ * @len:	size of oob to process
+ */
+void nand_fill_ecc(struct nand_chip *chip, uint8_t *oob, size_t len)
+{
+	struct nand_oobfree *free = chip->ecc.layout->oobfree;
+	uint32_t offset = 0, bytes;
+
+	for (; free->length && offset < len; free++) {
+		if (offset < free->offset) {
+			bytes = min_t(size_t, len, free->offset) - offset;
+			memset(oob + offset, 0xff, bytes);
+		}
+
+		offset = free->offset + free->length;
+	}
+
+	if (offset < len)
+		memset(oob + offset, 0xff, len - offset);
+}
+
+/**
+ * nand_read_yaffs_skip_bad:
+ * Read image from NAND flash.
+ * Blocks that are marked bad are skipped and the next block is readen
+ * instead as long as the image is short enough to fit even after skipping the
+ * bad blocks.
+ *
+ * @param nand NAND device
+ * @param offset offset in flash, alignment with pagesize
+ * @param length buffer length, on return holds remaining bytes to read,
+ *		alignment with (pagesize + oobsize)
+ * @param buffer buffer to read to
+ * @return 0 in case of success
+ */
+int nand_read_yaffs_skip_bad(struct mtd_info *mtd, loff_t offset, size_t *length,
+		    u_char *buffer)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	u_int32_t oobsize;
+	size_t left_to_read;
+	size_t len_incl_bad = 0;
+	size_t length_data;  /* length without oob */
+	u_char *p_buffer = buffer;
+	mtd_oob_ops_t ops = {0};
+	int need_skip;
+	int rval;
+	int i;
+
+	oobsize = mtd->oobsize;
+
+	/* Reject reads, which are not page aligned */
+	if (((unsigned long long)offset & (mtd->writesize - 1)) != 0) {
+		printf("Attempt to read non page aligned data, offset %lld\n",
+				offset);
+		return -EINVAL;
+	}
+
+	if ((*length % (mtd->writesize  + oobsize)) != 0) {
+		printf("Attempt to read non aligned data, read length should "\
+				"be aligned with (pagesize + oobsize), length:%lu "
+				"pagesize:%d oobsize:%d\n",
+				(unsigned long)*length, mtd->writesize, oobsize);
+		return -EINVAL;
+	}
+
+	length_data = *length / (mtd->writesize + oobsize) * mtd->writesize;
+
+	need_skip = check_skip_len(mtd, offset, length_data, &len_incl_bad);
+	if (need_skip < 0) {
+		printf("Attempt to read outside the flash area\n");
+		*length = 0;
+		return -EINVAL;
+	}
+
+	if (len_incl_bad != length_data)
+		printf("data length:%#x, include bad block length: %#x\n",
+				(u_int)length_data, (u_int)len_incl_bad);
+
+	if ((offset + len_incl_bad) >= mtd->size) {
+		printf("Attempt to read outside the flash area\n");
+		return -EINVAL;
+	}
+
+	/* add to cooperate with tool */
+	print_to_tool("pure data length is %d, len_incl_bad is %d\r\n",
+		length_data, len_incl_bad);
+
+	if (len_incl_bad == length_data) {
+		for (i = 0; i < length_data / mtd->writesize; i++) {
+			ops.datbuf = buffer +
+				 i*(mtd->writesize + oobsize);
+			ops.oobbuf = buffer +
+				 i*(mtd->writesize + oobsize) +
+				 mtd->writesize;
+			ops.len = mtd->writesize;
+			ops.ooblen = oobsize;
+			ops.mode = MTD_OPS_RAW;
+
+			rval = mtd_read_oob(mtd, offset + i*mtd->writesize,&ops);
+			if (rval != 0) {
+				printf("NAND read to offset %llx failed %d\n",
+					offset + i*mtd->writesize, rval);
+				return rval;
+			}
+
+			if (ecc0_flag != 1)
+				nand_fill_ecc(chip, ops.oobbuf, ops.ooblen);
+
+			*length -= mtd->writesize + oobsize;
+		}
+
+
+		return 0;
+	}
+
+	left_to_read = length_data;
+
+	while (left_to_read > 0) {
+		size_t block_offset = (unsigned long long)offset & (mtd->erasesize - 1);
+		size_t read_size;
+
+		if (nand_block_isbad(mtd, (unsigned long long)offset &
+			 ~((loff_t)mtd->erasesize - 1))) {
+			printf("Skip bad block 0x%08llx\n",
+				(unsigned long long)offset & ~((loff_t)mtd->erasesize - 1));
+			offset += mtd->erasesize - block_offset;
+			continue;
+		}
+
+		if (left_to_read < (mtd->erasesize - block_offset))
+			read_size = left_to_read;
+		else
+			read_size = mtd->erasesize - block_offset;
+
+		for (i = 0; i < read_size / mtd->writesize; i++) {
+			ops.datbuf = p_buffer;
+			ops.oobbuf = p_buffer + mtd->writesize;
+			ops.len = mtd->writesize;
+			ops.ooblen = oobsize;
+			ops.ooboffs = 0;
+			ops.mode = MTD_OPS_RAW;
+
+			rval = mtd_read_oob(mtd, offset, &ops);
+			if (rval != 0) {
+				printf("NAND read to offset %llx failed %d\n",
+				offset, rval);
+				return rval;
+			}
+
+			if (ecc0_flag != 1)
+				nand_fill_ecc(chip, ops.oobbuf, ops.ooblen);
+
+			p_buffer += mtd->writesize + oobsize;
+			left_to_read -= mtd->writesize;
+			offset += mtd->writesize;
+			*length -= mtd->writesize + oobsize;
+		}
+	}
+
+	printf("\n");
+	return 0;
+}
+
 #ifdef CONFIG_CMD_NAND_TORTURE
 
 /**
diff -uraN u-boot-2016.11/drivers/mtd/nand/nfc_common.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/nfc_common.c
--- u-boot-2016.11/drivers/mtd/nand/nfc_common.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/nand/nfc_common.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,165 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <nfc_common.h>
+
+/*****************************************************************************/
+struct nand_flash_dev *(*get_flash_type)(
+	struct mtd_info *mtd,
+	struct nand_chip *chip,
+	unsigned char *id) = NULL;
+
+int (*nand_oob_resize)(struct mtd_info *mtd) = NULL;
+
+/*****************************************************************************/
+#if defined(CONFIG_FMC_SPI_NAND) || defined(CONFIG_FMC_NAND)
+static struct match_type_str ecc2name[] = {
+	{NAND_ECC_0BIT,  "none"     },
+	{NAND_ECC_8BIT,  "4bit/512" },
+	{NAND_ECC_16BIT, "8bit/512" },
+	{NAND_ECC_24BIT, "24bit/1K" },
+	{NAND_ECC_28BIT, "28bit/1K" },
+	{NAND_ECC_40BIT, "40bit/1K" },
+	{NAND_ECC_42BIT, "42bit/1K" },
+	{NAND_ECC_64BIT, "64bit/1K" },
+};
+
+const char *nand_ecc_name(int type)
+{
+	return type2str(ecc2name, ARRAY_SIZE(ecc2name), type, "unknown");
+}
+
+/*****************************************************************************/
+static struct match_type_str page2name[] = {
+	{ NAND_PAGE_512B, "512" },
+	{ NAND_PAGE_2K,   "2K" },
+	{ NAND_PAGE_4K,   "4K" },
+	{ NAND_PAGE_8K,   "8K" },
+	{ NAND_PAGE_16K,  "16K" },
+	{ NAND_PAGE_32K,  "32K" },
+};
+
+const char *nand_page_name(int type)
+{
+	return type2str(page2name, ARRAY_SIZE(page2name), type, "unknown");
+}
+
+/*****************************************************************************/
+static struct match_reg_type page2size[] = {
+	{ _512B, NAND_PAGE_512B },
+	{ _2K, NAND_PAGE_2K },
+	{ _4K, NAND_PAGE_4K },
+	{ _8K, NAND_PAGE_8K },
+	{ _16K, NAND_PAGE_16K },
+	{ _32K, NAND_PAGE_32K },
+};
+
+int nandpage_size2type(int size)
+{
+	return reg2type(page2size, ARRAY_SIZE(page2size), size, NAND_PAGE_2K);
+}
+
+int nandpage_type2size(int size)
+{
+	return type2reg(page2size, ARRAY_SIZE(page2size), size, NAND_PAGE_2K);
+}
+#endif
+
+/*****************************************************************************/
+#define ET_ECC_NONE	0x00
+#define ET_ECC_4BIT	0x02
+#define ET_ECC_8BIT	0x03
+#define ET_ECC_24BIT	0x04
+#define ET_ECC_40BIT1K	0x05
+#define ET_ECC_64BIT1K	0x06
+
+static struct match_reg_type ecc_yaffs_type_t[] = {
+	{ET_ECC_NONE,		NAND_ECC_0BIT},
+	{ET_ECC_4BIT,		NAND_ECC_8BIT},
+	{ET_ECC_8BIT,		NAND_ECC_16BIT},
+	{ET_ECC_24BIT,		NAND_ECC_24BIT},
+	{ET_ECC_40BIT1K,	NAND_ECC_40BIT},
+	{ET_ECC_64BIT1K,	NAND_ECC_64BIT}
+};
+
+unsigned char match_ecc_type_to_yaffs(unsigned char type)
+{
+	return type2reg(ecc_yaffs_type_t, ARRAY_SIZE(ecc_yaffs_type_t), type,
+			ET_ECC_4BIT);
+}
+
+/*****************************************************************************/
+static struct match_t page_table[] = {
+	{NAND_PAGE_2K,	PAGE_SIZE_2KB,	"2K"},
+	{NAND_PAGE_4K,	PAGE_SIZE_4KB,	"4K"},
+	{NAND_PAGE_8K,	PAGE_SIZE_8KB,	"8K"},
+	{NAND_PAGE_16K,	PAGE_SIZE_16KB,	"16K"},
+};
+
+unsigned char match_page_reg_to_type(unsigned char reg)
+{
+	return match_reg_to_type(page_table, ARRAY_SIZE(page_table), reg,
+				 NAND_PAGE_2K);
+}
+
+unsigned char match_page_type_to_reg(unsigned char type)
+{
+	return match_type_to_reg(page_table, ARRAY_SIZE(page_table), type,
+				 PAGE_SIZE_2KB);
+}
+
+const char *match_page_type_to_str(unsigned char type)
+{
+	return match_type_to_data(page_table, ARRAY_SIZE(page_table), type,
+				  "unknown");
+}
+
+/*****************************************************************************/
+static struct match_t ecc_table[] = {
+	{NAND_ECC_0BIT,		ECC_TYPE_0BIT,	"none"},
+	{NAND_ECC_8BIT,		ECC_TYPE_8BIT,	"4bit/512"},
+	{NAND_ECC_16BIT,	ECC_TYPE_16BIT,	"8bit/512"},
+	{NAND_ECC_24BIT,	ECC_TYPE_24BIT,	"24bit/1K"},
+	{NAND_ECC_28BIT,	ECC_TYPE_28BIT,	"28bit/1K"},
+	{NAND_ECC_40BIT,	ECC_TYPE_40BIT,	"40bit/1K"},
+	{NAND_ECC_64BIT,	ECC_TYPE_64BIT,	"64bit/1K"},
+};
+
+unsigned char match_ecc_reg_to_type(unsigned char reg)
+{
+	return match_reg_to_type(ecc_table, ARRAY_SIZE(ecc_table), reg,
+				 NAND_ECC_8BIT);
+}
+
+unsigned char match_ecc_type_to_reg(unsigned char type)
+{
+	return match_type_to_reg(ecc_table, ARRAY_SIZE(ecc_table), type,
+				 ECC_TYPE_8BIT);
+}
+
+const char *match_ecc_type_to_str(unsigned char type)
+{
+	return match_type_to_data(ecc_table, ARRAY_SIZE(ecc_table), type,
+				  "unknown");
+}
+
+/*****************************************************************************/
+static struct match_t page_type_size_table[] = {
+	{NAND_PAGE_2K,	_2K,	NULL},
+	{NAND_PAGE_4K,	_4K,	NULL},
+	{NAND_PAGE_8K,	_8K,	NULL},
+	{NAND_PAGE_16K,	_16K,	NULL},
+};
+
+unsigned char match_page_size_to_type(unsigned int size)
+{
+	return match_reg_to_type(page_type_size_table,
+			ARRAY_SIZE(page_type_size_table), size, NAND_PAGE_2K);
+}
+
+unsigned int match_page_type_to_size(unsigned char type)
+{
+	return match_type_to_reg(page_type_size_table,
+				 ARRAY_SIZE(page_type_size_table), type, _2K);
+}
diff -uraN u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100.c
--- u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,1414 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+/*****************************************************************************/
+#include "fmc100.h"
+#include <common.h>
+#include <malloc.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <errno.h>
+#include <asm/arch/platform.h>
+
+/*****************************************************************************/
+int write_bp_area_check(struct fmc_host *host, u_int to, size_t len)
+{
+#ifdef CONFIG_SPI_BLOCK_PROTECT
+	if (host->level) {
+		if ((host->cmp == BP_CMP_TOP)
+				&& ((to + len) > host->start_addr)) {
+			puts("\n");
+			db_msg("Reg write area[%#x => %#x] was locked\n",
+					host->start_addr, (to + len));
+			return -EINVAL;
+		}
+
+		if ((host->cmp == BP_CMP_BOTTOM) && (to < host->end_addr)) {
+			unsigned end = ((to + len) > host->end_addr) ?
+				host->end_addr : (to + len);
+
+			puts("\n");
+			db_msg("Reg write area[%#x => %#x] was locked\n", to,
+					end);
+			return -EINVAL;
+		}
+	}
+#endif
+	return 0;
+}
+
+/*****************************************************************************/
+static void fmc100_dma_transfer(struct fmc_spi *spi,
+			 unsigned int spi_start_addr, unsigned char *dma_buffer,
+			 unsigned char rw_op, unsigned int size)
+{
+	unsigned char if_type = 0;
+	unsigned char dummy = 0;
+	unsigned char w_cmd = 0;
+	unsigned char r_cmd = 0;
+	unsigned int regval;
+	struct fmc_host *host = spi->host;
+
+	fmc_pr(DMA_DB, "\t\t *-Start dma transfer => [%#x], len[%#x], buf = %p\n",
+	       spi_start_addr, size, dma_buffer);
+
+	regval = FMC_INT_CLR_ALL;
+	fmc_write(host, FMC_INT_CLR, regval);
+	fmc_pr(DMA_DB, "\t\t   Set INT_CLR[%#x]%#x\n", FMC_INT_CLR, regval);
+
+	regval = spi_start_addr;
+	fmc_write(host, FMC_ADDRL, regval);
+	fmc_pr(DMA_DB, "\t\t   Set ADDRL[%#x]%#x\n", FMC_ADDRL, regval);
+
+	if (rw_op == RW_OP_WRITE) {
+		if_type = spi->write->iftype;
+		dummy = spi->write->dummy;
+		w_cmd = spi->write->cmd;
+	} else if (rw_op == RW_OP_READ) {
+		if_type = spi->read->iftype;
+		dummy = spi->read->dummy;
+		r_cmd = spi->read->cmd;
+	}
+
+	regval = op_cfg_fm_cs(spi->chipselect) | OP_CFG_OEN_EN |
+		 op_cfg_mem_if_type(if_type) | op_cfg_addr_num(spi->addrcycle) |
+		 op_cfg_dummy_num(dummy);
+	fmc_write(host, FMC_OP_CFG, regval);
+	fmc_pr(DMA_DB, "\t\t   Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, regval);
+
+	regval = fmc_dma_len_set(size);
+	fmc_write(host, FMC_DMA_LEN, regval);
+	fmc_pr(DMA_DB, "\t\t   Set DMA_LEN[%#x]%#x\n", FMC_DMA_LEN, regval);
+	/* get hight 32 bits */
+	regval = (((uintptr_t)dma_buffer & FMC_DMA_SADDRH_MASK) >> 32);
+	fmc_write(host, FMC_DMA_SADDRH_D0, regval);
+	fmc_pr(DMA_DB, "\t\t   Set DMA_SADDRH_D0[%#x]%#x\n", FMC_DMA_SADDRH_D0,
+	       regval);
+
+	regval = (unsigned int)((uintptr_t)dma_buffer);
+	fmc_write(host, FMC_DMA_SADDR_D0, regval);
+	fmc_pr(DMA_DB, "\t\t   Set DMA_SADDR_D0[%#x]%#x\n", FMC_DMA_SADDR_D0,
+	       regval);
+
+	regval = op_ctrl_rd_opcode(r_cmd) | op_ctrl_wr_opcode(w_cmd) |
+		 op_ctrl_rw_op(rw_op) | OP_CTRL_DMA_OP_READY;
+
+	fmc_write(host, FMC_OP_CTRL, regval);
+	fmc_pr(DMA_DB, "\t\t   Set OP_CTRL[%#x]%#x\n", FMC_OP_CTRL, regval);
+
+	fmc_dma_wait_int_finish(host);
+
+	fmc_pr(DMA_DB, "\t\t *-End dma transfer.\n");
+}
+
+/*****************************************************************************/
+#ifdef FMC100_SPI_NOR_SUPPORT_REG_READ
+static char *fmc100_reg_read_buf(struct fmc_host *host,
+				struct fmc_spi *spi,
+				unsigned int spi_start_addr,
+				unsigned int size,
+				unsigned char *buffer)
+{
+	unsigned int regval;
+
+	fmc_pr(DMA_DB, "* Start reg read, from:%#x len:%#x\n", spi_start_addr,
+	       size);
+
+	if (size > FMC100_REG_RD_MAX_SIZE)
+		db_bug("reg read out of reg range.\n");
+
+	fmc_write(host, FMC_ADDRL, spi_start_addr);
+	fmc_pr(DMA_DB, "  Set ADDRL[%#x]%#x\n", FMC_ADDRL, spi_start_addr);
+
+	regval = fmc_data_num_cnt(size);
+	fmc_write(host, FMC_DATA_NUM, regval);
+	fmc_pr(DMA_DB, "  Set DATA_NUM[%#x]%#x\n", FMC_DATA_NUM, regval);
+
+	regval = op_ctrl_rd_opcode(spi->read->cmd) |
+		 op_ctrl_dma_op(OP_TYPE_REG) |
+		 op_ctrl_rw_op(RW_OP_READ) |
+		 OP_CTRL_DMA_OP_READY;
+	fmc_write(host, FMC_OP_CTRL, regval);
+	fmc_pr(DMA_DB, "  Set OP_CTRL[%#x]%#x\n", FMC_OP_CTRL, regval);
+
+	fmc_cmd_wait_cpu_finish(host);
+
+	memcpy(buffer, host->iobase, size);
+
+	fmc_pr(DMA_DB, "*-End reg page read.\n");
+
+	return (char*)buffer;
+}
+
+/*****************************************************************************/
+static int fmc100_reg_read(struct spi_flash *spiflash, u_int from,
+				size_t len, char *buf)
+{
+	int num;
+	int chip_idx = 0; 
+	int result = -EIO;
+	unsigned char *ptr = (u_char *)buf;
+	struct fmc_host *host = spiflash_to_host(spiflash);
+	struct fmc_spi *spi = host->spi;
+	unsigned char *fmc_ip;
+
+	if (((from + len) > spiflash->size) || (!len)) {
+		db_msg("read area out of range or len is zero\n");
+		return -EINVAL;
+	}
+
+	fmc_ip = get_fmc_ip();
+	if (*fmc_ip) {
+		printf("Warning: Fmc IP is busy, Please try again.\n");
+		udelay(100); /* delay 100 us */
+		return;
+	} else {
+		fmc_dev_type_switch(FLASH_TYPE_SPI_NOR);
+		(*fmc_ip)++;
+	}
+
+	if (spi->driver->wait_ready(spi)) {
+		db_msg("Error: Dma read wait ready fail!\n");
+		result = -EBUSY;
+		goto fail;
+	}
+
+	host->set_system_clock(spi->read, ENABLE);
+
+	while (len > 0) {
+		while (from >= spi->chipsize) {
+			from -= spi->chipsize;
+			chip_idx++;
+			spi++;
+			if ((chip_idx == CONFIG_SPI_NOR_MAX_CHIP_NUM) || (!spi->name)) {
+				db_bug("read memory out of range.\n");
+				goto fail;
+			}
+			if (spi->driver->wait_ready(spi))
+				goto fail;
+			host->set_system_clock(spi->read, ENABLE);
+		}
+
+		num = ((from + len) >= spi->chipsize) ? (spi->chipsize - from) : len;
+
+		while (num >= FMC100_REG_RD_MAX_SIZE) {
+			fmc100_reg_read_buf(host, spi,
+					      from, FMC100_REG_RD_MAX_SIZE, ptr);
+			ptr += FMC100_REG_RD_MAX_SIZE;
+			from += FMC100_REG_RD_MAX_SIZE;
+			len -= FMC100_REG_RD_MAX_SIZE;
+			num -= FMC100_REG_RD_MAX_SIZE;
+		}
+
+		if (num) {
+			fmc100_reg_read_buf(host, spi, from, num, ptr);
+			from += num;
+			ptr += num;
+			len -= num;
+		}
+	}
+	result = 0;
+
+fail:
+	(*fmc_ip)--;
+	return result;
+}
+#endif
+static int dma_cycle_op(struct spi_flash *spiflash, unsigned char rw_op,
+				u_int from, size_t len, const void *buf)
+{
+	int op_len = 0;
+	size_t num = 0;
+	int chip_idx = 0;
+	struct spi_op *op = NULL;
+	struct fmc_host *host = spiflash_to_host(spiflash);
+	struct fmc_spi *spi = host->spi;
+
+	if (rw_op == RW_OP_READ) {
+		op_len = FMC100_DMA_RD_MAX_SIZE;
+		op = spi->read;
+	} else {
+		op_len = FMC100_DMA_WR_MAX_SIZE;
+		op = spi->write;
+	}
+
+	while (len) {
+		num = ((len >= op_len) ? op_len : len);
+
+		while (from >= spi->chipsize) {
+			from -= spi->chipsize;
+			chip_idx++;
+			spi++;
+			if ((chip_idx == CONFIG_SPI_NOR_MAX_CHIP_NUM) || (!spi->name)) {
+				db_bug("read memory out of range.\n");
+				return -1;
+			}
+
+			if (spi->driver->wait_ready(spi)) {
+				db_msg("Error: Dma op wait ready fail!!\n");
+				return -EBUSY;
+			}
+
+			host->set_system_clock(op, ENABLE);
+		}
+
+		if (from + num > spi->chipsize)
+			num = spi->chipsize - from;
+
+		fmc100_dma_transfer(spi, from, (u_char *)buf,
+				rw_op, num);
+		from += num;
+		buf  += num;
+		len  -= num;
+	}
+	return 0;
+}
+
+/*****************************************************************************/
+#ifndef FMC100_SPI_NOR_SUPPORT_REG_READ
+static int fmc100_dma_read(struct spi_flash *spiflash, u_int from, size_t len,
+				unsigned char *buf)
+{
+	int result = -EIO;
+	struct fmc_host *host = spiflash_to_host(spiflash);
+	struct fmc_spi *spi = host->spi;
+	unsigned char *fmc_ip = NULL;
+
+	fmc_pr(RD_DBG, "\t|*-Start dma read, from:%#x len:%#lx\n", from, (long)len);
+
+	if (((from + len) > spiflash->size) || (!len)) {
+		db_msg("read area out of range[%#x].\n", spiflash->size);
+		return -EINVAL;
+	}
+
+	fmc_ip = get_fmc_ip();
+	if (*fmc_ip) {
+		printf("Warning: Fmc IP is busy, Please try again.\n");
+		udelay(100); /* delay 100 us */
+		return -EBUSY;
+	} else {
+		fmc_dev_type_switch(FLASH_TYPE_SPI_NOR);
+		(*fmc_ip)++;
+	}
+
+	if (spi->driver->wait_ready(spi)) {
+		db_msg("Error: Dma read wait ready fail!\n");
+		result = -EBUSY;
+		goto fail;
+	}
+
+	host->set_system_clock(spi->read, ENABLE);
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+	invalidate_dcache_range((uintptr_t)buf, (uintptr_t)(buf + len));
+#endif
+	if (dma_cycle_op(spiflash, RW_OP_READ, from, len, buf))
+		goto fail;
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+	invalidate_dcache_range((uintptr_t)buf, (uintptr_t)(buf + len));
+#endif
+
+	result = 0;
+fail:
+	(*fmc_ip)--;
+
+	fmc_pr(RD_DBG, "\t|*-End dma read.\n");
+
+	return result;
+}
+#endif
+/*****************************************************************************/
+void fmc100_read_ids(struct fmc_spi *spi, u_char cs, u_char *id)
+{
+	unsigned int reg;
+	struct fmc_host *host = spi->host;
+
+	fmc_pr(BT_DBG, "\t|||*-Start Read SPI(cs:%d) ID.\n", cs);
+
+	reg = fmc_cmd_cmd1(SPI_CMD_RDID);
+	fmc_write(host, FMC_CMD, reg);
+	fmc_pr(BT_DBG, "\t||||-Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	reg = op_cfg_fm_cs(cs) | OP_CFG_OEN_EN;
+	fmc_write(host, FMC_OP_CFG, reg);
+	fmc_pr(BT_DBG, "\t||||-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	reg = fmc_data_num_cnt(MAX_SPI_NOR_ID_LEN);
+	fmc_write(host, FMC_DATA_NUM, reg);
+	fmc_pr(BT_DBG, "\t||||-Set DATA_NUM[%#x]%#x\n", FMC_DATA_NUM, reg);
+
+	reg = fmc_op_cmd1_en(ENABLE) |
+	      fmc_op_read_data_en(ENABLE) |
+	      FMC_OP_REG_OP_START;
+	fmc_write(host, FMC_OP, reg);
+	fmc_pr(BT_DBG, "\t||||-Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	fmc_cmd_wait_cpu_finish(host);
+
+	memcpy(id, host->iobase, MAX_SPI_NOR_ID_LEN);
+
+	fmc_pr(BT_DBG, "\t|||*-Read CS: %d ID: %#X %#X %#X %#X %#X %#X\n",
+	       cs, id[0], id[1], id[2], id[3], id[4], id[5]); /* id 1 2 3 4 5 6 */
+}
+
+/*****************************************************************************/
+static int fmc100_reg_erase_one_block(struct fmc_host *host,
+				struct fmc_spi *spi, unsigned int offset)
+{
+	unsigned int regval;
+
+	fmc_pr(OP_DBG, "\t\t * Start erase one block, offset:%#x\n", offset);
+
+	regval = spi->driver->wait_ready(spi);
+	if (regval) {
+		db_msg("Error: Erase wait ready fail! reg:%#x\n", regval);
+		return 1;
+	}
+
+	spi->driver->write_enable(spi);
+
+	host->set_system_clock(spi->erase, ENABLE);
+
+	regval = fmc_cmd_cmd1(spi->erase->cmd);
+	fmc_write(host, FMC_CMD, regval);
+	fmc_pr(OP_DBG, "\t\t   Set CMD[%#x]%#x\n", FMC_CMD, regval);
+
+	regval = offset;
+	fmc_write(host, FMC_ADDRL, regval);
+	fmc_pr(OP_DBG, "\t\t   Set ADDRL[%#x]%#x\n", FMC_ADDRL, regval);
+
+	regval = op_cfg_fm_cs(spi->chipselect) |
+		 OP_CFG_OEN_EN |
+		 op_cfg_mem_if_type(spi->erase->iftype) |
+		 op_cfg_addr_num(spi->addrcycle) |
+		 op_cfg_dummy_num(spi->erase->dummy);
+	fmc_write(host, FMC_OP_CFG, regval);
+	fmc_pr(OP_DBG, "\t\t   Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, regval);
+
+	regval = fmc_op_cmd1_en(ENABLE) |
+		 fmc_op_addr_en(ENABLE) |
+		 FMC_OP_REG_OP_START;
+	fmc_write(host, FMC_OP, regval);
+	fmc_pr(OP_DBG, "\t\t   Set OP[%#x]%#x\n", FMC_OP, regval);
+
+	fmc_cmd_wait_cpu_finish(host);
+
+	fmc_pr(OP_DBG, "\t\t * End erase one block.\n");
+
+	return 0;
+}
+
+/*****************************************************************************/
+#ifndef FMC100_SPI_NOR_SUPPORT_REG_WRITE
+static int fmc100_dma_write(struct spi_flash *spiflash, u_int to, size_t len,
+				const unsigned char *buf)
+{
+	int result = -EIO;
+	struct fmc_host *host = spiflash_to_host(spiflash);
+	struct fmc_spi *spi = host->spi;
+	unsigned char *fmc_ip = NULL;
+
+	fmc_pr(WR_DBG, "\n\t\t* Start dma write, to:%#x len:%#lx\n", to, (long)len);
+
+	if (((to + len) > spiflash->size) || (!len)) {
+		db_msg("write data out of range or len is zero.\n");
+		return -EINVAL;
+	}
+
+#ifdef CONFIG_SPI_BLOCK_PROTECT
+	if (host->level && (to < host->end_addr)) {
+		printf("\nERROR: The DMA write area was locked.\n");
+		return -EINVAL;
+	}
+#endif
+
+	fmc_ip = get_fmc_ip();
+	if (*fmc_ip) {
+		printf("Warning: Fmc IP is busy, Please try again.\n");
+		udelay(100); /* delay 100 us */
+		return -EBUSY;
+	} else {
+		fmc_dev_type_switch(FLASH_TYPE_SPI_NOR);
+		(*fmc_ip)++;
+	}
+
+	if (spi->driver->wait_ready(spi))
+		goto fail;
+
+	spi->driver->write_enable(spi);
+	host->set_system_clock(spi->write, ENABLE);
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+	flush_dcache_range((uintptr_t)buf, (uintptr_t)(buf + len));
+#endif
+
+	if (dma_cycle_op(spiflash, RW_OP_WRITE, to, len, buf))
+		goto fail;
+
+	result = 0;
+fail:
+	(*fmc_ip)--;
+	fmc_pr(WR_DBG, "\t\t* End dma write.\n");
+	return result;
+}
+#endif
+/*****************************************************************************/
+#ifdef FMC100_SPI_NOR_SUPPORT_REG_WRITE
+static int fmc100_reg_write_buf(struct fmc_host *host,
+				struct fmc_spi *spi, u_int spi_start_addr,
+				size_t size, unsigned char *buffer)
+{
+	if (size > FMC100_DMA_WR_MAX_SIZE)
+		db_bug("reg read out of reg range.\n");
+
+	if (spi->driver->wait_ready(spi))
+		return 1;
+
+	memcpy((char *)host->iobase, buffer, size);
+
+	spi->driver->write_enable(spi);
+
+	fmc_write(host, FMC_INT_CLR, FMC_INT_CLR_ALL);
+
+	fmc_write(host, FMC_CMD, fmc_cmd_cmd1(spi->write->cmd));
+
+	fmc_write(host, FMC_OP_CFG, op_cfg_fm_cs(spi->chipselect) |
+			op_cfg_mem_if_type(spi->write->iftype) | OP_CFG_OEN_EN);
+
+	fmc_write(host, FMC_ADDRL, spi_start_addr);
+
+	fmc_write(host, FMC_OP_CTRL, (op_ctrl_wr_opcode(spi->write->cmd) |
+					op_ctrl_dma_op(OP_TYPE_REG) |
+					op_ctrl_rw_op(RW_OP_WRITE) |
+					OP_CTRL_DMA_OP_READY));
+
+	FMC_DMA_WAIT_CPU_FINISH(host);
+
+	return 0;
+}
+
+static int cycle_write(struct fmc_spi *spi, u_int to, size_t len,
+				unsigned char *ptr, int num)
+{
+	int chip_idx = 0;
+
+	while (to >= spi->chipsize) {
+		to -= spi->chipsize;
+		chip_idx++;
+		spi++;
+		if ((chip_idx == CONFIG_SPI_NOR_MAX_CHIP_NUM) || (!spi->name)) {
+			db_bug("write memory out of range.\n");
+			return -1;
+		}
+
+		if (spi->driver->wait_ready(spi))
+			return -1;
+
+		host->set_system_clock(spi->write, ENABLE);
+	}
+
+	if (fmc100_reg_write_buf(host, spi, to, num, ptr))
+		return -1;
+
+	to += num;
+	ptr += num;
+	len -= num;
+
+	return 0;
+}
+/*****************************************************************************/
+static int fmc100_reg_write(struct spi_flash *spiflash, u_int to, size_t len,
+				const unsigned char *buf)
+{
+	int num;
+	int result = -EIO;
+	unsigned char *ptr = (unsigned char *)buf;
+	struct fmc_host *host = spiflash_to_host(spiflash);
+	struct fmc_spi *spi = host->spi;
+	unsigned char *fmc_ip;
+
+	if ((to + len) > spiflash->size) {
+		db_msg("write data out of range.\n");
+		return -EINVAL;
+	}
+
+	if (!len) {
+		db_msg("write length is 0.\n");
+		return 0;
+	}
+
+	if (write_bp_area_check(host, to, len))
+		return -EINVAL;
+
+	fmc_ip = get_fmc_ip();
+	if (*fmc_ip) {
+		printf("Warning: Fmc IP is busy, Please try again.\n");
+		udelay(100); /* delay 100 us */
+		return;
+	} else {
+		fmc_dev_type_switch(FLASH_TYPE_SPI_NOR);
+		(*fmc_ip)++;
+	}
+
+	if (spi->driver->wait_ready(spi))
+		goto fail;
+
+	host->set_system_clock(spi->write, ENABLE);
+
+	if (to & FMC100_DMA_WR_MASK) {
+		num = FMC100_DMA_WR_MAX_SIZE - (to & FMC100_DMA_WR_MASK);
+		if (num > (int)len)
+			num = (int)len;
+
+		if (cycle_write(spi, to, len, ptr, num)) {
+			result = -1;
+			goto fail;
+		}
+	}
+
+	while (len > 0) {
+		num = ((len >= FMC100_DMA_WR_MAX_SIZE) ?
+		       FMC100_DMA_WR_MAX_SIZE : len);
+
+		if (cycle_write(spi, to, len, ptr, num)) {
+			result = -1;
+			goto fail;
+		}
+	}
+	result = 0;
+fail:
+	(*fmc_ip)--;
+	return result;
+}
+#endif /* FMC100_SPI_NOR_SUPPORT_REG_WRITE */
+
+/*****************************************************************************/
+static int fmc100_reg_erase(struct spi_flash *spiflash, u_int offset,
+				size_t length)
+{
+	int chip_idx = 0;
+	struct fmc_host *host = spiflash_to_host(spiflash);
+	struct fmc_spi *spi = host->spi;
+	unsigned char *fmc_ip = NULL;
+
+	if (offset + length > spiflash->size) {
+		db_msg("Error: Erase area out of range of mtd.\n");
+		return -EINVAL;
+	}
+
+	if (offset & (spi->erasesize - 1)) {
+		db_msg("Error: Erase start address is not alignment.\n");
+		return -EINVAL;
+	}
+
+	if (length & (spi->erasesize - 1)) {
+		db_msg("Error: Erase length is not alignment.\n");
+		return -EINVAL;
+	}
+
+#ifdef CONFIG_SPI_BLOCK_PROTECT
+	if ((host->level) && (offset < host->end_addr)) {
+		printf("\nERROR: The erase area was locked.\n");
+		return -EINVAL;
+	}
+#endif
+	fmc_ip = get_fmc_ip();
+	if (*fmc_ip) {
+		printf("Warning: Fmc IP is busy, Please try again.\n");
+		udelay(100); /* delay 100 us */
+		return -EBUSY;
+	} else {
+		fmc_dev_type_switch(FLASH_TYPE_SPI_NOR);
+		(*fmc_ip)++;
+	}
+
+	while (length) {
+		if (spi->chipsize <= offset) {
+			offset -= spi->chipsize;
+			chip_idx++;
+			spi++;
+			if ((chip_idx == CONFIG_SPI_NOR_MAX_CHIP_NUM) || (!spi->name)) {
+				db_bug("Error: Erase memory out of range.\n");
+				(*fmc_ip)--;
+				return -1;
+			}
+		}
+
+		if (fmc100_reg_erase_one_block(host, spi, offset)) {
+			(*fmc_ip)--;
+			return -1;
+		}
+
+		offset += spi->erase->size;
+		length -= spi->erase->size;
+	}
+
+	(*fmc_ip)--;
+
+	return 0;
+}
+
+/*****************************************************************************/
+static void spi_nor_func_hook(struct fmc_host *host)
+{
+	struct spi_flash *spi_nor_flash = host->spi_nor_flash;
+
+#ifdef CONFIG_SPI_BLOCK_PROTECT
+	host->cmp = BP_CMP_UPDATE_FLAG;
+	fmc100_get_bp_lock_level(host);
+	spi_nor_flash->lock = fmc100_spi_flash_lock;
+#endif
+	fmc_pr(BT_DBG, "\t||-Initial spi_flash structure\n");
+	spi_nor_flash->name = "bsp_fmc";
+	spi_nor_flash->erase = fmc100_reg_erase;
+#ifdef FMC100_SPI_NOR_SUPPORT_REG_WRITE
+	spi_nor_flash->write = fmc100_reg_write;
+#else
+	spi_nor_flash->write = fmc100_dma_write;
+#endif
+
+#ifdef FMC100_SPI_NOR_SUPPORT_REG_READ
+	spi_nor_flash->read = fmc100_reg_read;
+#else
+	spi_nor_flash->read = fmc100_dma_read;
+#endif
+}
+
+/*****************************************************************************/
+struct spi_flash *fmc100_spi_nor_scan(struct fmc_host *host)
+{
+	unsigned char cs;
+	struct spi_flash *spi_nor_flash = host->spi_nor_flash;
+	struct fmc_spi *spi = host->spi;
+	struct mtd_info_ex *spi_nor_info = host->spi_nor_info;
+
+	fmc_pr(BT_DBG, "\t|*-Start Scan SPI nor flash\n");
+
+	spi_nor_flash->size = 0;
+
+	for (cs = 0; cs < CONFIG_SPI_NOR_MAX_CHIP_NUM; cs++)
+		host->spi[cs].host = host;
+
+	fmc_pr(BT_DBG, "\t||-Initial mtd_info_ex structure\n");
+	memset(spi_nor_info, 0, sizeof(struct mtd_info_ex));
+
+	if (!fmc_spi_nor_probe(spi_nor_info, spi)) {
+#ifndef CONFIG_SPI_NOR_QUIET_TEST
+		printf("Can't find a valid spi nor flash chip.\n");
+#endif
+		return NULL;
+	}
+
+	if (spi->addrcycle == SPI_NOR_4BYTE_ADDR_LEN) {
+		host->set_host_addr_mode(host, ENABLE);
+		fmc_pr(AC_DBG, "\t* Controller entry 4-byte mode.\n");
+	}
+
+	spi_nor_func_hook(host);
+
+#ifdef CONFIG_DTR_MODE_SUPPORT
+	if (spi->dtr_mode_support) {
+		int ret;
+
+		host->dtr_training_flag = 0;
+		/* setting DTR mode dummy and traning */
+		ret = spi_dtr_dummy_training_set(host, ENABLE);
+		/* If training setting fail, must reset back to SDR mode,
+		 * Note: logic auto turn on DTR when read
+		 *       auto turn off DTR when write and erase */
+		if (ret) {
+			printf("Reset to STR mode.\n");
+			/* switch DTR mode to SDR mode */
+			fmc_dtr_mode_ctrl(spi, DISABLE);
+			spi_dtr_to_sdr_switch(spi);
+			spi_dtr_dummy_training_set(host, DISABLE);
+		}
+	}
+#endif
+
+	fmc_pr(BT_DBG, "\t|*-Found SPI nor flash: %s\n", spi_nor_info->name);
+
+	return spi_nor_flash;
+}
+
+/*****************************************************************************/
+static void fmc100_set_host_addr_mode(struct fmc_host *host, int enable)
+{
+	unsigned int regval = fmc_read(host, FMC_CFG);
+
+	/* 1: SPI_NOR_ADDR_MODE_4_BYTES 0: SPI_NOR_ADDR_MODE_3_BYTES */
+	if (enable)
+		regval |= SPI_NOR_ADDR_MODE_MASK;
+	else
+		regval &= ~SPI_NOR_ADDR_MODE_MASK;
+
+	fmc_write(host, FMC_CFG, regval);
+}
+
+/*****************************************************************************/
+static int fmc100_host_init(struct fmc_host *host)
+{
+	unsigned int reg, flash_type;
+
+	fmc_pr(BT_DBG, "\t|||*-Start SPI Nor host init\n");
+
+	host->regbase = (void *)CONFIG_FMC_REG_BASE;
+	host->iobase = (void *)CONFIG_FMC_BUFFER_BASE;
+
+	reg = fmc_read(host, FMC_CFG);
+	fmc_pr(BT_DBG, "\t||||-Get CFG[%#x]%#x\n", FMC_CFG, reg);
+	flash_type = (reg & FLASH_SEL_MASK) >> FLASH_SEL_SHIFT;
+	if (flash_type != FLASH_TYPE_SPI_NOR) {
+		db_msg("Error: Flash type isn't SPI Nor. reg: %#x\n", reg);
+		return -ENODEV;
+	}
+
+	if ((reg & OP_MODE_MASK) == OP_MODE_BOOT) {
+		reg |= fmc_cfg_op_mode(OP_MODE_NORMAL);
+		fmc_pr(BT_DBG, "\t||||-Controller enter normal mode\n");
+		fmc_write(host, FMC_CFG, reg);
+		fmc_pr(BT_DBG, "\t||||-Set CFG[%#x]%#x\n", FMC_CFG, reg);
+	}
+
+	host->set_system_clock = fmc_set_fmc_system_clock;
+	host->set_host_addr_mode = fmc100_set_host_addr_mode;
+
+	reg = timing_cfg_tcsh(CS_HOLD_TIME) |
+	      timing_cfg_tcss(CS_SETUP_TIME) |
+	      timing_cfg_tshsl(CS_DESELECT_TIME);
+	fmc_write(host, FMC_SPI_TIMING_CFG, reg);
+	fmc_pr(BT_DBG, "\t||||-Set TIMING[%#x]%#x\n", FMC_SPI_TIMING_CFG, reg);
+
+	fmc_pr(BT_DBG, "\t|||*-End SPI Nor host init\n");
+
+	return 0;
+}
+
+/*****************************************************************************/
+int fmc100_spi_nor_init(struct fmc_host *host)
+{
+	int ret;
+
+	fmc_pr(BT_DBG, "\t||*-Start fmc100 SPI Nor init\n");
+
+	fmc_pr(BT_DBG, "\t|||-fmc100 host structure init\n");
+	ret = fmc100_host_init(host);
+	if (ret) {
+		db_msg("Error: SPI Nor host init failed, result: %d\n", ret);
+		return ret;
+	}
+
+	fmc_pr(BT_DBG, "\t|||-Set default system clock, Enable controller\n");
+	if (host->set_system_clock)
+		host->set_system_clock(NULL, ENABLE);
+
+	fmc_pr(BT_DBG, "\t||*-End fmc100 SPI Nor init\n");
+
+	return ret;
+}
+
+#ifdef CONFIG_SPI_BLOCK_PROTECT
+/*****************************************************************************/
+void spi_lock_update_address(struct fmc_host *host)
+{
+	unsigned int lock_level_max, erasesize, chipsize;
+	unsigned char mid = host->spi_nor_info->ids[0];
+	struct fmc_spi *spi = host->spi;
+
+	if (!host->level) {
+		host->end_addr = 0;
+		fmc_pr(BP_DBG, "all blocks is unlocked.\n");
+		return;
+	}
+
+	chipsize = spi->chipsize;
+	erasesize = spi->erasesize;
+	lock_level_max = host->spi_nor_flash[0].bp_level_max;
+
+	switch (mid) {
+	case MID_MXIC:
+		if (spi->chipsize == _2M) {
+			if ((host->level != lock_level_max) &&
+			   (host->level != 1))
+				host->end_addr = chipsize - (erasesize <<
+					(lock_level_max - host->level - 1));
+			else
+				host->end_addr = chipsize;
+			return;
+		}
+
+		if (spi->chipsize != _8M)
+			break;
+	/* general case */
+	case MID_ESMT:
+		/* this case is for ESMT and MXIC 8M devices */
+		if (host->level != lock_level_max)
+			host->end_addr = chipsize - (erasesize  <<
+				(lock_level_max - host->level));
+		else
+			host->end_addr = chipsize;
+		return;
+	case MID_CFEON:
+		if (host->level != lock_level_max)
+			host->end_addr = chipsize - (erasesize  <<
+							(host->level - 1));
+		else
+			host->end_addr = chipsize;
+		return;
+	default:
+		break;
+	}
+
+	/* general case */
+	host->end_addr = chipsize >> (lock_level_max - host->level);
+}
+
+/*****************************************************************************/
+void fmc100_get_bp_lock_level(struct fmc_host *host)
+{
+	struct fmc_spi *spi = host->spi;
+	unsigned char mid = host->spi_nor_info->ids[0];
+	unsigned int lock_level_max;
+
+	fmc_pr(BP_DBG, "Get manufacturer ID: [%#x]\n", mid);
+
+	/* match the manufacture ID to get the block protect info */
+	switch (mid) {
+	case MID_GD:
+	case MID_ESMT:
+	case MID_CFEON:
+	case MID_SPANSION:
+		host->bp_num = BP_NUM_3;
+		host->level = fmc100_bp_to_level(host);
+		break;
+	case MID_WINBOND:
+		if (spi->chipsize <= _16M) {
+			host->bp_num = BP_NUM_3;
+			host->level = fmc100_bp_to_level(host);
+		} else {
+			host->bp_num = BP_NUM_4;
+			host->level = fmc100_bp_to_level(host);
+		}
+		break;
+	case MID_MXIC:
+		if (spi->chipsize <= _8M) {
+			host->bp_num = BP_NUM_3;
+			host->level = fmc100_bp_to_level(host);
+		} else {
+			host->bp_num = BP_NUM_4;
+			host->level = fmc100_bp_to_level(host);
+		}
+		break;
+	case MID_MICRON:
+	case MID_PARAGON:
+		return;
+	default:
+		goto usage;
+	}
+
+	/* this branch only for initialization */
+	if (host->cmp == BP_CMP_UPDATE_FLAG) {
+		/* get the max block protect level of current manufacture ID */
+		if (host->bp_num == BP_NUM_4) {
+			lock_level_max = lock_level_max(host->bp_num) - BP_NUM_5;
+			/* just for MXIC(16M), the max lock level is 9 */
+			if ((mid == MID_MXIC) && (spi->chipsize == _16M))
+				lock_level_max--;
+		} else {
+			lock_level_max = lock_level_max(host->bp_num);
+		}
+
+		host->spi_nor_flash[0].bp_level_max = lock_level_max;
+		fmc_pr(BP_DBG, "Get the max bp level: [%d]\n", lock_level_max);
+
+		spi_lock_update_address(host);
+		if (host->end_addr)
+			printf("Spi is locked. lock address[0 => %#x]\n",
+			       host->end_addr);
+	}
+	return;
+usage:
+	db_msg("Error:The ID: %#x isn't in the BP table,\n", mid);
+	db_msg("Current device can't not protect\n");
+}
+/*****************************************************************************/
+unsigned short fmc100_set_spi_lock_info(struct fmc_host *host)
+{
+	unsigned short val;
+	unsigned char mid = host->spi_nor_info->ids[0];
+	struct fmc_spi *spi = host->spi;
+
+	fmc_pr(BP_DBG, "Get manufacturer ID: [%#x]\n", mid);
+
+	/* match the manufacture ID to get the block protect set info */
+	switch (mid) {
+	case MID_SPANSION:
+		val = fmc100_handle_bp_rdcr_info(host, SPI_CMD_RDCR);
+		break;
+	case MID_MXIC:
+		if (spi->chipsize < _16M)
+			val = fmc100_handle_bp_rdsr_info(host, SPI_CMD_RDSR);
+		else
+			val = fmc100_handle_bp_rdcr_info(host,
+							   SPI_CMD_RDCR_MX);
+		break;
+	case MID_GD:
+	case MID_ESMT:
+	case MID_CFEON:
+	case MID_WINBOND:
+		val = fmc100_handle_bp_rdsr_info(host, SPI_CMD_RDSR);
+		break;
+	default:
+		goto usage;
+	}
+
+	return val;
+usage:
+	db_msg("Error: The manufacture ID is change,\n Pleaer check!!\n");
+	db_msg("Error: The ID: %#x isn't in the BP table,\n", mid);
+	return 1;
+}
+
+/*****************************************************************************/
+unsigned short fmc100_handle_bp_rdcr_info(struct fmc_host *host, u_char cmd)
+{
+	unsigned char status, config;
+	struct fmc_spi *spi = host->spi;
+	unsigned char mid = host->spi_nor_info->ids[0];
+
+	/* this macro definition is for determining the writing length */
+	host->bt_loc = BT_LOC_RDCR;
+	spi->driver->wait_ready(spi);
+
+	/* get the block protect B/P info in config register */
+	config = spi_general_get_flash_register(spi, cmd);
+	fmc_pr(BP_DBG, "Get Config Register[%#x]\n", config);
+
+	/* the location of T/B bit in config register is different.
+	 SPANSION is 5th and the MXIC(16/32M) is 3th */
+	if (mid == MID_SPANSION) {
+		config = spi_bp_bottom_rdcr_set_s(config);
+		fmc_pr(BP_DBG, "Set Config Register[%#x]\n", config);
+	} else {
+		config = spi_bp_bottom_rdcr_set(config);
+		fmc_pr(BP_DBG, "Set Config Register[%#x]\n", config);
+	}
+
+	/* get the block protect level info in status register */
+	status = spi_general_get_flash_register(spi, SPI_CMD_RDSR);
+	fmc_pr(BP_DBG, "Get Status Register[%#x]\n", status);
+
+	return ((unsigned short)config << SPI_NOR_CR_SHIFT) | status;
+}
+/*****************************************************************************/
+unsigned short fmc100_handle_bp_rdsr_info(struct fmc_host *host,
+				u_char cmd)
+{
+	unsigned char val;
+	struct fmc_spi *spi = host->spi;
+	unsigned char mid = host->spi_nor_info->ids[0];
+
+	/* this macro definition is for determining the writing length */
+	host->bt_loc = BT_LOC_RDSR;
+	spi->driver->wait_ready(spi);
+
+	/* get the block protect level and B/T info in status register */
+	val = spi_general_get_flash_register(spi, cmd);
+	fmc_pr(BP_DBG, "Get Status Register[%#x]\n", val);
+	if (mid == MID_CFEON)
+		val &= spi_bp_bottom_rdsr_set_0(host->bp_num);
+	else
+		val |= spi_bp_bottom_rdsr_set_1(host->bp_num);
+	fmc_pr(BP_DBG, "Set Config Register[%#x]\n", val);
+
+	return val;
+}
+/*****************************************************************************/
+static void fmc100_set_bp_val(struct fmc_host *host, unsigned short val)
+{
+	unsigned int reg;
+	struct fmc_spi *spi = host->spi;
+
+	reg = fmc_read(host, FMC_GLOBAL_CFG);
+	if (reg & FMC_GLOBAL_CFG_WP_ENABLE) {
+		fmc_pr(BP_DBG, " Hardware protected enable!, reg[%#x]\n", reg);
+		reg &= ~FMC_GLOBAL_CFG_WP_ENABLE;
+		fmc_write(host, FMC_GLOBAL_CFG, reg);
+		val &= ~SPI_NOR_SR_SRWD_MASK;
+		fmc_pr(BP_DBG, "Disable SR[%d]:SRWD and WP#\n",
+				SPI_NOR_SR_SRWD_SHIFT);
+	}
+
+	if (host->bt_loc == BT_LOC_RDSR) {
+		writeb(val, host->iobase);
+		fmc_pr(BP_DBG, "Write IO[%p]%#x\n", host->iobase,
+				*(unsigned char *)host->iobase);
+	} else {
+		writew(val, host->iobase);
+		fmc_pr(BP_DBG, "Write IO[%p]%#x\n", host->iobase,
+				*(unsigned short *)host->iobase);
+	}
+
+	reg = fmc_cmd_cmd1(SPI_CMD_WRSR);
+	fmc_write(host, FMC_CMD, reg);
+	fmc_pr(BP_DBG, " Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	reg = op_cfg_fm_cs(spi->chipselect) | OP_CFG_OEN_EN;
+	fmc_write(host, FMC_OP_CFG, reg);
+	fmc_pr(BP_DBG, " Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	if (host->bt_loc == BT_LOC_RDSR)
+		reg = fmc_data_num_cnt(SPI_NOR_SR_LEN);
+	else
+		reg = fmc_data_num_cnt(SPI_NOR_SR_LEN + SPI_NOR_CR_LEN);
+
+	fmc_write(host, FMC_DATA_NUM, reg);
+	fmc_pr(BP_DBG, " Set DATA_NUM[%#x]%#x\n", FMC_DATA_NUM, reg);
+
+	reg = fmc_op_cmd1_en(ENABLE) 		|
+		fmc_op_write_data_en(ENABLE) 	|
+		FMC_OP_REG_OP_START;
+	fmc_write(host, FMC_OP, reg);
+	fmc_pr(BP_DBG, " Set OP[%#x]%#x\n", FMC_OP, reg);
+}
+
+/*****************************************************************************/
+static void fmc100_set_bp_level(struct fmc_host *host, unsigned char level)
+{
+	unsigned char old_level;
+	unsigned short val;
+	struct fmc_spi *spi = host->spi;
+	unsigned char mid = host->spi_nor_info->ids[0];
+
+	fmc_pr(BP_DBG, "* Start BP bottom level %d\n", level);
+
+	val = fmc100_set_spi_lock_info(host);
+	old_level = host->level;
+	fmc_pr(BP_DBG, "  Read CR:SR[%#x]\n", val);
+
+	if (old_level != level) {
+		if (host->bp_num == BP_NUM_3)
+			val &= ~SPI_NOR_SR_BP_MASK_3;
+		else
+			val &= ~SPI_NOR_SR_BP_MASK_4;
+		val |= level << SPI_NOR_SR_BP0_SHIFT;
+		fmc_pr(BP_DBG, "Set Status Register[%#x]\n", val);
+	} else {
+		fmc_pr(BP_DBG, "NOTES: old_level[%#x] = level[%#x]\n",
+		       old_level, level);
+		return;
+	}
+
+	if (((mid == MID_ESMT) || ((mid == MID_MXIC)
+				&& (spi->chipsize < _16M))) && (level == 0)) {
+		val &= spi_bp_bottom_rdsr_set_0(host->bp_num);
+		fmc_pr(BP_DBG, "set level = 0[PB3 = 0]:[%#x]\n", val);
+	}
+
+	spi->driver->write_enable(spi);
+	fmc100_set_bp_val(host, val);
+	fmc_cmd_wait_cpu_finish(host);
+	fmc_pr(BP_DBG, "* Set BP level end.\n");
+}
+
+/*****************************************************************************/
+void fmc100_spi_lock(struct fmc_host *host, unsigned char level)
+{
+	unsigned char current_level;
+
+	fmc100_set_bp_level(host, level);
+
+	/* check if we have set successfully or not */
+	current_level = fmc100_bp_to_level(host);
+	if (current_level != level) {
+		db_msg("Error: Current lock level: %d, but set value: %d\n",
+		       current_level, level);
+		return;
+	}
+
+	host->level = level;
+	spi_lock_update_address(host);
+
+	if (host->end_addr)
+		printf("Spi is locked. lock address[0 => %#x]\n",
+		       host->end_addr);
+
+	return;
+}
+
+/*****************************************************************************/
+unsigned char fmc100_bp_to_level(struct fmc_host *host)
+{
+	unsigned char val;
+	unsigned char level;
+	struct fmc_spi *spi = host->spi;
+
+	spi->driver->wait_ready(spi);
+	val = spi_general_get_flash_register(spi, SPI_CMD_RDSR);
+	fmc_pr(BP_DBG, "Get Status Register[%#x]\n", val);
+
+	fmc_pr(BP_DBG, "the bp_num[%d]\n", host->bp_num);
+
+	if (host->bp_num == BP_NUM_3)
+		level = (val & SPI_NOR_SR_BP_MASK_3) >> SPI_NOR_SR_BP0_SHIFT;
+	else
+		level = (val & SPI_NOR_SR_BP_MASK_4) >> SPI_NOR_SR_BP0_SHIFT;
+
+	fmc_pr(BP_DBG, "the current level[%d]\n", level);
+
+	return level;
+}
+/*****************************************************************************/
+#endif /* CONFIG_SPI_BLOCK_PROTECT */
+
+#ifdef CONFIG_DTR_MODE_SUPPORT
+/*****************************************************************************/
+int spi_dtr_dummy_training_set(struct fmc_host *host, int dtr_en)
+{
+	struct fmc_spi *spi = host->spi;
+	int ret;
+
+	switch (spi->dtr_cookie) {
+	case DTR_MODE_SET_ODS:
+		if (spi->driver->dtr_set_device)
+			spi->driver->dtr_set_device(spi, dtr_en);
+		break;
+	case DTR_MODE_SET_NONE:
+	default:
+		break;
+	}
+
+	/* disable DTR mode without training */
+	/* dtr dummy training is done, return it */
+	if ((host->dtr_training_flag == 1) || (dtr_en == DISABLE))
+		return 0;
+
+	/* enable DTR mode and set sample point */
+	fmc_dtr_mode_ctrl(spi, ENABLE);
+
+	/* set training */
+	ret = spi_dtr_training(host);
+	if (ret) {
+		fmc_pr(DTR_DB, " * Set dtr training fail.\n");
+		return 1;
+	}
+	fmc_pr(DTR_DB, "* Set dtr and dummy end.\n");
+	return 0;
+}
+/*****************************************************************************/
+static int select_sample_point(unsigned char *status, int len)
+{
+	int ix = 0;
+	unsigned int p_count = 0;
+	unsigned int p_temp = 0;
+	unsigned int reg = 0;
+
+	if (len <= 0)
+		return 0;
+
+	/* select the best smaple point */
+	for (ix = 0; ix < len;) {
+		if (status[ix] == 1) {
+			p_count++;
+			ix++;
+			if ((status[ix] == 0) && (p_count > p_temp)) {
+				p_temp = p_count;
+				p_count = 0;
+				reg = ix - ((p_temp + 1) >> 1);
+				fmc_pr(DTR_DB, "the sample point choice: %#x\n",
+				       reg);
+				break;
+			}
+			continue;
+		}
+		ix++;
+	}
+	return reg;
+}
+/*****************************************************************************/
+static int dtr_training_handle(struct fmc_host *host)
+{
+	int ret = 0;
+	int ix = 0;
+	unsigned int reg = 0;
+	unsigned int regval;
+	unsigned char *buf = NULL;
+	unsigned char status[DTR_TRAINING_POINT_NUM] = {0};
+	struct fmc_spi *spi = host->spi;
+
+	spi->driver->wait_ready(spi);
+
+	/* set div 4 clock */
+	host->set_system_clock(spi->read, ENABLE);
+
+	buf = memalign(CONFIG_SYS_CACHELINE_SIZE, DTR_TRAINING_CMP_LEN);
+	if (!buf)
+		return -1;
+
+	/* start training to check every sample point */
+	regval = fmc_read(host, FMC_GLOBAL_CFG);
+	for (ix = 0; ix < DTR_TRAINING_POINT_NUM; ix++) {
+		regval = dtr_training_point_clr(regval);
+		regval |= (ix << DTR_TRAINING_POINT_MASK);
+		fmc_pr(DTR_DB, " setting the dtr training point:%d\n", ix);
+		fmc_write(host, FMC_GLOBAL_CFG, regval);
+		fmc_pr(DTR_DB, " Set dtr_training[%#x]%#x\n",
+		       FMC_GLOBAL_CFG, regval);
+		/* read */
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+		invalidate_dcache_range((uintptr_t)buf,
+					(uintptr_t)(buf + DTR_TRAINING_CMP_LEN));
+#endif
+
+		fmc100_dma_transfer(spi, DTR_TRAINING_CMP_ADDR_SHIFT, buf,
+				      RW_OP_READ, DTR_TRAINING_CMP_LEN);
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+		invalidate_dcache_range((uintptr_t)buf,
+					(uintptr_t)(buf + DTR_TRAINING_CMP_LEN));
+#endif
+
+		ret = memcmp((const void *)buf,
+			     (const void *)DTR_TRAINING_CMP_ADDR_S,
+			     DTR_TRAINING_CMP_LEN);
+		if (ret == 0) {
+			/* Just to reduce the use of variables, no other reasion */
+			reg = 1;
+			status[ix] = 1; /* like */
+			fmc_pr(DTR_DB, " status[%d] = 1\n", ix);
+		}
+		if (!reg && (ix == DTR_TRAINING_POINT_NUM - 1))
+			goto fail_training;
+	}
+
+	kfree(buf);
+
+	/* select the best smaple point */
+	reg = 0;
+	reg = select_sample_point(status, DTR_TRAINING_POINT_NUM);
+
+	/* to set the best sample point */
+	regval = dtr_training_point_clr(regval);
+	regval |= (reg << DTR_TRAINING_POINT_MASK);
+	fmc_pr(DTR_DB, " set the sample point[%#x]%#x\n",
+	       FMC_GLOBAL_CFG, regval);
+	fmc_write(host, FMC_GLOBAL_CFG, regval);
+
+	/* training handle end */
+	return regval;
+
+fail_training:
+	printf("Cannot find an useful sample point.\n");
+	kfree(buf);
+	return -1;
+}
+/*****************************************************************************/
+unsigned int spi_dtr_training(struct fmc_host *host)
+{
+	int reg, cur_reg;
+
+	fmc_pr(DTR_DB, "DTR traiining start ...\n");
+	/* DTR traiining start */
+	reg = dtr_training_handle(host);
+	if (reg == -1) {
+		host->dtr_training_flag = 0;
+		printf("DTR traiining fail.\n");
+		return 1;
+	}
+	fmc_pr(DTR_DB, "* DTR traiining end.\n");
+	cur_reg = fmc_read(host, FMC_GLOBAL_CFG);
+	/* to check whether training is done */
+	if (cur_reg == reg) {
+		host->dtr_training_flag = 1;
+		fmc_pr(DTR_DB, "* Set dtr_training seccess.\n");
+		return 0;
+	}
+	return 1;
+}
+/*****************************************************************************/
+void fmc_dtr_mode_ctrl(struct fmc_spi *spi, int dtr_en)
+{
+	unsigned int regval;
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	host->dtr_mode_en = dtr_en;
+	regval = fmc_read(host, FMC_GLOBAL_CFG);
+	if (dtr_en == ENABLE) {
+		/* enable DTR mode and set the DC value */
+		regval |= (1 << DTR_MODE_REQUEST_SHIFT);
+		fmc_write(host, FMC_GLOBAL_CFG, regval);
+		fmc_pr(DTR_DB, " enable dtr mode[%#x]%#x\n",
+		       FMC_GLOBAL_CFG, regval);
+	} else {
+		/* disable DTR mode */
+		regval &= (~(1 << DTR_MODE_REQUEST_SHIFT));
+		fmc_write(host, FMC_GLOBAL_CFG, regval);
+		fmc_pr(DTR_DB, " disable dtr mode[%#x]%#x\n",
+		       FMC_GLOBAL_CFG, regval);
+	}
+}
+/*****************************************************************************/
+void fmc_check_spi_dtr_support(struct fmc_spi *spi, u_char *ids, int len)
+{
+	unsigned char manu_id = 0;
+	unsigned char dev_id = 0;
+
+	if(len < 2){
+		return;
+	}
+	
+	manu_id = ids[0];
+	dev_id = ids[1];
+
+	spi->dtr_mode_support = 0;
+	spi->dtr_cookie = DTR_MODE_SET_NONE;
+
+	switch (manu_id) {
+	case MID_MXIC:
+		if (spi_mxic_check_spi_dtr_support(spi)) {
+			spi->dtr_cookie = DTR_MODE_SET_ODS;
+			goto dtr_on;
+		}
+		break;
+	case MID_WINBOND:
+		/* Device ID: 0x70 means support DTR Mode for Winbond */
+		if (dev_id == DEVICE_ID_SUPPORT_DTR_WINBOND) {
+			spi->dtr_mode_support = 1;
+			goto dtr_on;
+		}
+		break;
+	default:
+		break;
+	}
+
+	fmc_pr(DTR_DB, "The Double Transfer Rate Read Mode isn't supported.\n");
+	return;
+
+dtr_on:
+	fmc_pr(FMC_INFO, "The Double Transfer Rate Read Mode is supported.\n");
+}
+#endif /* CONFIG_DTR_MODE_SUPPORT */
+/*****************************************************************************/
+void fmc100_op_reg(struct fmc_spi *spi, unsigned char opcode,
+				unsigned int len, unsigned char optype)
+{
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+	u32 regval;
+
+	regval = fmc_cmd_cmd1(opcode);
+	fmc_write(host, FMC_CMD, regval);
+
+	regval = fmc_data_num_cnt(len);
+	fmc_write(host, FMC_DATA_NUM, regval);
+
+	regval = op_cfg_fm_cs(spi->chipselect) | OP_CFG_OEN_EN;
+	fmc_write(host, FMC_OP_CFG, regval);
+
+	regval = fmc_op_cmd1_en(ENABLE) | FMC_OP_REG_OP_START | optype;
+	fmc_write(host, FMC_OP, regval);
+
+	fmc_cmd_wait_cpu_finish(host);
+}
diff -uraN u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100.h
--- u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,169 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __FMC100_H__
+#define __FMC100_H__
+
+#include <spi_flash.h>
+#include <fmc_common.h>
+#include "../../fmc_spi_ids.h"
+
+/*****************************************************************************/
+/* These macroes are for debug only, reg read is slower then dma read,
+    so we don't define it */
+#undef FMC100_SPI_NOR_SUPPORT_REG_READ
+#undef FMC100_SPI_NOR_SUPPORT_REG_WRITE
+
+/*****************************************************************************/
+#define FMC100_DMA_WR_MAX_SIZE		4096
+#define FMC100_DMA_WR_MASK			(FMC100_DMA_WR_MAX_SIZE - 1)
+#define FMC100_DMA_RD_MAX_SIZE		(_2M)
+#define FMC100_DMA_RD_MASK			(FMC100_DMA_RD_MAX_SIZE - 1)
+#define FMC100_REG_RD_MAX_SIZE		(_16K)
+#define FMC100_REG_RD_MASK			(FMC100_REG_RD_MAX_SIZE - 1)
+
+/*****************************************************************************/
+#define SPI_NOR_CR_SHIFT	8   /* Config Register shift(bit) */
+
+#define SPI_NOR_CR_4BYTE_SHIFT  5
+#define SPI_NOR_CR_4BYTE_MASK	   (1 << SPI_NOR_CR_4BYTE_SHIFT)
+#define spi_nor_get_4byte_by_cr(cr) (((cr) & SPI_NOR_CR_4BYTE_MASK) \
+						>> SPI_NOR_CR_4BYTE_SHIFT)
+
+#define SPI_NOR_CR_QE_SHIFT	 1
+#define SPI_NOR_CR_QE_MASK	  (1 << SPI_NOR_CR_QE_SHIFT)
+#define spi_nor_get_qe_by_cr(cr)	(((cr) & SPI_NOR_CR_QE_MASK) \
+						>> SPI_NOR_CR_QE_SHIFT)
+
+#define SPI_NOR_CR_RST_HOLD_SHIFT   7
+#define SPI_NOR_CR_RST_HOLD_MASK	(1 << SPI_NOR_CR_RST_HOLD_SHIFT)
+#define SPI_NOR_CR_HOLD_MASK		(~(1 << SPI_NOR_CR_RST_HOLD_SHIFT))
+#define spi_nor_get_rst_hold_by_cr(cr)  (((cr) & SPI_NOR_CR_RST_HOLD_MASK) \
+						>> SPI_NOR_CR_RST_HOLD_SHIFT)
+#define spi_nor_set_rst_by_cr(cr)   ((cr) | SPI_NOR_CR_RST_HOLD_MASK)
+#define spi_nor_set_hold_by_cr(cr)  ((cr) & SPI_NOR_CR_HOLD_MASK)
+
+#ifdef CONFIG_SPI_BLOCK_PROTECT
+#define DEBUG_SPI_NOR_BP	0
+
+#define SPI_NOR_SR_SRWD_SHIFT   7
+#define SPI_NOR_SR_SRWD_MASK	(1 << SPI_NOR_SR_SRWD_SHIFT)
+
+#define SPI_NOR_SR_BP0_SHIFT	2
+#define SPI_NOR_SR_BP_WIDTH_4   0xf
+#define SPI_NOR_SR_BP_MASK_4	(SPI_NOR_SR_BP_WIDTH_4 << SPI_NOR_SR_BP0_SHIFT)
+
+#define SPI_NOR_SR_BP_WIDTH_3   0x7
+#define SPI_NOR_SR_BP_MASK_3	(SPI_NOR_SR_BP_WIDTH_3 << SPI_NOR_SR_BP0_SHIFT)
+
+#define SPI_NOR_SR_TB_SHIFT 3
+#define SPI_NOR_SR_TB_MASK  (1 << SPI_NOR_SR_TB_SHIFT)
+
+#define SPI_NOR_SR_TB_SHIFT_S   5
+#define SPI_NOR_SR_TB_MASK_S	(1 << SPI_NOR_SR_TB_SHIFT_S)
+
+#define spi_bp_bottom_rdcr_set_s(config)	((config) | \
+					(0x01 << SPI_NOR_SR_TB_SHIFT_S))
+#define spi_bp_bottom_rdcr_set(config)	  ((config) | \
+					(0x01 << SPI_NOR_SR_TB_SHIFT))
+
+#define spi_bp_bottom_rdsr_set_1(bp_num)	(0x1 << (2 + bp_num))
+#define spi_bp_bottom_rdsr_set_0(bp_num)	(~(0x1 << (2 + bp_num)))
+
+#define lock_level_max(bp_num)		  (((0x01) << bp_num) - 1)
+
+#endif /* CONFIG_SPI_BLOCK_PROTECT */
+
+#ifdef CONFIG_DTR_MODE_SUPPORT
+#define DTR_DUMMY_CYCLES_6	  6
+#define DTR_DUMMY_CYCLES_8	  8
+#define DTR_DUMMY_CYCLES_10	 10
+#define dtr_rdcr_dc_mask(_val)	  (_val)
+#define DTR_RDSR_DC_SHIFT	   14
+#define DTR_RDCR_DC_SHIFT	   6
+#define dtr_rdcr_dc_bit_clr(_reg)   ((_reg) & (~(3 << DTR_RDSR_DC_SHIFT)))
+#define DTR_MODE_REQUEST_SHIFT	  11
+
+#define DTR_TRAINING_POINT_NUM		  12
+#define DTR_TRAINING_POINT_MASK		 12
+#define dtr_training_point_clr(_reg)	((_reg) & (~(0xf << 12)))
+#define DTR_TRAINING_CMP_ADDR_SHIFT (2048 + 96)
+#define DTR_TRAINING_CMP_ADDR_S	 (CONFIG_SYS_TEXT_BASE_ORI + \
+					DTR_TRAINING_CMP_ADDR_SHIFT)
+#define DTR_TRAINING_CMP_LEN		0x100
+#define SFDP_BUF_LEN			0x33
+#define SFDP_DTR_BIT_SHIFT	  3
+#define SFDP_DTR_BYTE_SHIFT	 0x32
+#define SFDP_DTR_BIT_MASK	   0x1
+#define DEVICE_ID_SUPPORT_DTR_WINBOND 0x70
+#endif /* CONFIG_DTR_MODE_SUPPORT */
+
+/* MXIC Config Register's dummy cycle bits */
+#define CR_DUMMY_CYCLE	  (0x03 << 6)
+#define SPI_CMD_RDCR_MX		 0x15 /* MXIC Read Config Register */
+#define DTR_MODE_REQUEST_SHIFT		   11
+#define SPI_NOR_SR_WIP_MASK 			(1 << 0)
+/*****************************************************************************/
+struct fmc_host {
+	struct spi_flash spi_nor_flash[1];
+	struct mtd_info_ex *spi_nor_info;
+	struct fmc_spi spi[CONFIG_SPI_NOR_MAX_CHIP_NUM];
+
+	void *regbase;
+	void *iobase;
+
+	void (*set_system_clock)(struct spi_op *op, int clk_en);
+	void (*set_host_addr_mode)(struct fmc_host *host, int enable);
+
+#ifdef CONFIG_SPI_BLOCK_PROTECT
+	unsigned int start_addr;
+	unsigned int end_addr;
+	unsigned char cmp;
+	unsigned int bp_num;
+	/* the BT bit location, decide the data num count */
+	unsigned int bt_loc;
+	unsigned char level;
+#endif
+#ifdef CONFIG_DTR_MODE_SUPPORT
+	unsigned int dtr_mode_en;
+	unsigned int dtr_training_flag;
+#endif
+};
+
+#ifdef CONFIG_SPI_BLOCK_PROTECT
+unsigned short fmc100_set_spi_lock_info(struct fmc_host *host);
+void fmc100_get_bp_lock_level(struct fmc_host *host);
+void fmc100_spi_lock(struct fmc_host *host, unsigned char level);
+void fmc100_spi_flash_lock(unsigned char cmp, unsigned char level,
+				unsigned char op);
+unsigned short fmc100_handle_bp_rdcr_info(struct fmc_host *host,
+				u_char cmd);
+unsigned char fmc100_bp_to_level(struct fmc_host *host);
+unsigned short fmc100_handle_bp_rdsr_info(struct fmc_host *host,
+				u_char cmd);
+#endif
+unsigned char spi_general_get_flash_register(struct fmc_spi *spi,
+				u_char cmd);
+
+#define spiflash_to_host(_spiflash) ((struct fmc_host *)(_spiflash))
+/*****************************************************************************/
+#ifdef CONFIG_DTR_MODE_SUPPORT
+void fmc_dtr_mode_ctrl(struct fmc_spi *spi, int dtr_en);
+unsigned int spi_dtr_training(struct fmc_host *host);
+void spi_dtr_to_sdr_switch(struct fmc_spi *spi);
+int spi_dtr_dummy_training_set(struct fmc_host *host, int dtr_en);
+void fmc_check_spi_dtr_support(struct fmc_spi *spi, u_char *ids, int len);
+unsigned int spi_mxic_check_spi_dtr_support(struct fmc_spi *spi);
+#endif
+/*****************************************************************************/
+void fmc100_read_ids(struct fmc_spi *, u_char, u_char *);
+void fmc100_op_reg(struct fmc_spi *spi, unsigned char opcode,
+				unsigned int len, unsigned char optype);
+int fmc_spi_nor_probe(struct mtd_info_ex *mtd, struct fmc_spi *spi);
+int fmc100_spi_nor_init(struct fmc_host *);
+struct spi_flash *fmc100_spi_nor_scan(struct fmc_host *host);
+/*****************************************************************************/
+
+#endif /* End of __FMC100_H__ */
+
diff -uraN u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100_os.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100_os.c
--- u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100_os.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100_os.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,192 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+/*****************************************************************************/
+#include "fmc100_os.h"
+#include <common.h>
+#include <linux/mtd/mtd.h>
+#include <asm/io.h>
+
+/*****************************************************************************/
+static struct fmc_host fmc100_host;
+static struct mtd_info_ex fmc100_spi_nor_info = {.type = 0, };
+
+/*****************************************************************************/
+static void fmc100_driver_shutdown(void)
+{	
+	unsigned int start_up_addr_mode = get_fmc_boot_mode();
+	if (start_up_addr_mode == SPI_NOR_ADDR_MODE_3_BYTES) {
+		int ix;
+		struct fmc_host *host = &fmc100_host;
+		struct fmc_spi *spi = host->spi;
+		struct mtd_info_ex *spi_nor_info = &fmc100_spi_nor_info;
+
+		fmc_dev_type_switch(FLASH_TYPE_SPI_NOR);
+
+		for (ix = 0; ix < spi_nor_info->numchips; ix++, spi++) {
+			/* 4 byte addr mode */
+			if (spi->addrcycle == 4) {
+				spi->driver->wait_ready(spi);
+				spi->driver->entry_4addr(spi, DISABLE);
+			}
+		}
+	}
+}
+
+/*****************************************************************************/
+static int fmc100_driver_probe(void)
+{
+	int ret;
+	struct fmc_host *host = &fmc100_host;
+
+	fmc_pr(BT_DBG, "\t|*-Start SPI nor flash driver probe\n");
+
+	/* Fmc ip version check */
+	ret = fmc_ip_ver_check();
+	if (ret) {
+		fmc_pr(BT_DBG, "\t|*-IP version unknown, result: %d\n", ret);
+		return ret;
+	}
+
+	fmc_pr(BT_DBG, "\t||-SPI nor host init\n");
+	memset((char *)host, 0, sizeof(struct fmc_host));
+	ret = fmc100_spi_nor_init(host);
+	if (ret) {
+		fmc_pr(BT_DBG, "Error: SPI Nor init failed, ret: %d\n", ret);
+		goto end;
+	}
+
+end:
+	fmc_pr(BT_DBG, "\t|*-End SPI nor flash driver probe\n");
+
+	return ret;
+}
+
+/*****************************************************************************/
+struct mtd_info_ex *fmc100_get_spi_nor_info(struct spi_flash *spi_nor_flash)
+{
+	if (fmc100_spi_nor_info.type == 0) {
+		if (fmc100_spi_nor_probe(NULL) == NULL)
+			return NULL;
+	}
+
+	return &fmc100_spi_nor_info;
+}
+
+/*****************************************************************************/
+static void fmc100_probe_spi_size(struct spi_flash *spi_nor_flash)
+{
+	struct fmc_host *host = &fmc100_host;
+	struct fmc_spi *spi = host->spi;
+	unsigned int ix;
+	unsigned int total = 0;
+	struct mtd_info_ex *spi_nor_info = host->spi_nor_info;
+
+	fmc_pr(BT_DBG, "\t|*-Start probe SPI nor flash total size\n");
+	for (ix = 0; ix < spi_nor_info->numchips; ix++, spi++) {
+		fmc_pr(BT_DBG, "\t||-SPI nor flash[%d]: %dMB\n", ix,
+		       (u_int)byte_to_mb(spi->chipsize));
+		total += spi->chipsize;
+	}
+
+	spi_nor_flash->size = total;
+
+	fmc_pr(BT_DBG, "\t|*-Probe SPI nor total size: %dMB, chip num: %d\n",
+	       byte_to_mb(spi_nor_flash->size), spi_nor_info->numchips);
+}
+
+/*****************************************************************************/
+struct spi_flash *fmc100_spi_nor_probe(struct mtd_info_ex **spi_nor_info)
+{
+	static struct spi_flash *spi_nor_flash = NULL;
+
+	fmc_pr(BT_DBG, "\t*-Start SPI Nor flash probe\n");
+
+	if (spi_nor_flash) {
+		fmc_pr(BT_DBG, "\t*-SPI Nor flash is initialized.\n");
+		return spi_nor_flash;
+	}
+
+	/* Check current SPI device type whether SPI nor */
+	fmc_dev_type_switch(FLASH_TYPE_SPI_NOR);
+
+	fmc_pr(BT_DBG, "\t|-SPI Nor flash driver probe\n");
+	if (!fmc100_driver_probe()) {
+		struct fmc_host *host = &fmc100_host;
+
+		fmc_pr(BT_DBG, "\t|-SPI nor flash scanning\n");
+		host->spi_nor_info = &fmc100_spi_nor_info;
+		spi_nor_flash = fmc100_spi_nor_scan(host);
+		if (spi_nor_flash) {
+			*spi_nor_info =
+				fmc100_get_spi_nor_info(spi_nor_flash);
+
+			fmc100_probe_spi_size(spi_nor_flash);
+#ifndef CONFIG_MINI_BOOT
+			printf("SPI Nor total size: %uMB\n",
+			       byte_to_mb(spi_nor_flash->size));
+#endif
+			fmc_pr(BT_DBG, "\t|-Add func hook for Reset cmd\n");
+			add_shutdown(fmc100_driver_shutdown);
+
+			goto end;
+		}
+	}
+
+	spi_nor_flash = NULL;
+	fmc100_spi_nor_info.type = 0;
+
+end:
+	/* Change SPI device type to default */
+	fmc_dev_type_switch(FLASH_TYPE_DEFAULT);
+
+	fmc_pr(BT_DBG, "\t*-End SPI Nor flash probe\n");
+
+	return spi_nor_flash;
+}
+
+/*****************************************************************************/
+#ifdef CONFIG_SPI_BLOCK_PROTECT
+void fmc100_spi_flash_lock(unsigned char cmp, unsigned char level,
+				unsigned char op)
+{
+	struct fmc_host *host = &fmc100_host;
+	struct spi_flash *nor = host->spi_nor_flash;
+
+	host->cmp = cmp;
+
+	if (op == BP_OP_GET) {
+		puts("Get spi lock information\n");
+		if (host->level) {
+			if (host->level == nor->bp_level_max)
+				puts("all blocks are locked.\n");
+			else
+				printf("level: %d\n", host->level);
+			printf("Spi is locked. lock address[0 => %#x]\n",
+			       host->end_addr);
+		} else {
+			puts("all blocks are unlocked.\n");
+		}
+
+		return;
+	}
+
+	if (op == BP_OP_SET) {
+		if (level) {
+			if (level == nor->bp_level_max)
+				puts("lock all blocks.\n");
+			else
+				printf("lock level: %d\n", level);
+		} else {
+			puts("unlock all block.\n");
+		}
+
+		fmc100_spi_lock(host, level);
+		return;
+	}
+
+	printf("%s ERROR: Invalid optin argument!", __func__);
+}
+/*****************************************************************************/
+#endif /* CONFIG_SPI_BLOCK_PROTECT */
diff -uraN u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100_os.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100_os.h
--- u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100_os.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100_os.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,13 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __FMC100_OS_H__
+#define __FMC100_OS_H__
+
+#include "fmc100.h"
+#include "../spi.h"
+
+/*****************************************************************************/
+#endif /* End of __FMC100_OS_H__ */
+
diff -uraN u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100_spi_gd25qxxx.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100_spi_gd25qxxx.c
--- u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100_spi_gd25qxxx.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100_spi_gd25qxxx.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,163 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+/*****************************************************************************/
+#define GD_SPI_CMD_RDSR1        0x35    /* Read Status Register-1 */
+
+/*****************************************************************************/
+/*
+ * enable QE bit if QUAD read write is supported by GD "25qxxx" SPI
+ */
+static void set_cmd(struct fmc_spi *spi, u8 cmd, u8 len)
+{
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+	unsigned int regval;
+
+	regval = fmc_cmd_cmd1(cmd);
+	fmc_write(host, FMC_CMD, regval);
+	fmc_pr(QE_DBG, "\t|-Set CMD[%#x]%#x\n", FMC_CMD, regval);
+
+	regval = op_cfg_fm_cs(spi->chipselect) | OP_CFG_OEN_EN;
+	fmc_write(host, FMC_OP_CFG, regval);
+	fmc_pr(QE_DBG, "\t|-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, regval);
+
+	regval = fmc_data_num_cnt(len);
+	fmc_write(host, FMC_DATA_NUM, regval);
+	fmc_pr(QE_DBG, "\t|-Set DATA_NUM[%#x]%#x\n", FMC_DATA_NUM, regval);
+
+	regval = fmc_op_cmd1_en(ENABLE) |
+		 fmc_op_write_data_en(ENABLE) |
+		 FMC_OP_REG_OP_START;
+	fmc_write(host, FMC_OP, regval);
+	fmc_pr(QE_DBG, "\t|-Set OP[%#x]%#x\n", FMC_OP, regval);
+
+	fmc_cmd_wait_cpu_finish(host);
+
+	spi->driver->wait_ready(spi);
+}
+
+static int gd_16pin_qe_enable(struct fmc_spi *spi, int op)
+{
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+	unsigned char config;
+	unsigned char status;
+	const char *str[] = {"Disable", "Enable"};
+
+	config = spi_general_get_flash_register(spi, GD_SPI_CMD_RDSR1);
+	fmc_pr(QE_DBG, "\t|-Read GD SR-1[%#x], val: %#x\n", GD_SPI_CMD_RDSR1,
+	       config);
+	if (op && (op == spi_nor_get_qe_by_cr(config))) {
+		fmc_pr(QE_DBG, "\t* Quad was %sd, status:%#x\n", str[op],
+		       config);
+		return op;
+	}
+
+	/* First, we enable/disable QE for 16Pin GD flash, use WRSR[01h] cmd */
+	fmc_pr(QE_DBG, "\t|-First, 16Pin GD flash %s Quad.\n", str[op]);
+
+	status = spi_general_get_flash_register(spi, SPI_CMD_RDSR);
+	fmc_pr(QE_DBG, "\t|-Read Status Register[%#x]%#x\n", SPI_CMD_RDSR,
+	       status);
+
+	spi->driver->write_enable(spi);
+
+	if (op)
+		config |= SPI_NOR_CR_QE_MASK;
+	else
+		config &= ~SPI_NOR_CR_QE_MASK;
+	writeb(status, host->iobase);
+	writeb(config, host->iobase + SPI_NOR_SR_LEN);
+	fmc_pr(QE_DBG, "\t|-Write IO[%p]%#x\n", host->iobase,
+	       *(unsigned short *)host->iobase);
+
+	set_cmd(spi, SPI_CMD_WRSR, SPI_NOR_SR_LEN + SPI_NOR_CR_LEN);
+
+	config = spi_general_get_flash_register(spi, GD_SPI_CMD_RDSR1);
+	fmc_pr(QE_DBG, "\t|-Read GD SR-1[%#x], val: %#x\n", GD_SPI_CMD_RDSR1,
+	       config);
+	if (op == spi_nor_get_qe_by_cr(config)) {
+		fmc_pr(QE_DBG, "\t|-16P %s Quad success reg: %#x\n", str[op],
+		       config);
+		return op;
+	} else {
+		fmc_pr(QE_DBG, "\t|-16P %s Quad failed, reg: %#x\n", str[op],
+		       config);
+	}
+
+	return 0;
+}
+
+static void gd_8pin_qe_enable(struct fmc_spi *spi, int op)
+{
+	unsigned char config;
+	unsigned char status;
+	const char *str[] = {"Disable", "Enable"};
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	fmc_pr(QE_DBG, "\t|-Second, 8Pin GD flash %s Quad.\n", str[op]);
+
+	status = spi_general_get_flash_register(spi, SPI_CMD_RDSR);
+	fmc_pr(QE_DBG, "\t|-Read Status Register[%#x]:%#x\n", SPI_CMD_RDSR,
+	       status);
+	if (!(status & STATUS_WEL_MASK))
+		spi->driver->write_enable(spi);
+
+	config = spi_general_get_flash_register(spi, SPI_CMD_RDSR2);
+	fmc_pr(QE_DBG, "\t|-Read SR-2[%#x], val: %#x\n", SPI_CMD_RDSR2,
+	       config);
+
+	if (op && (op == spi_nor_get_qe_by_cr(config))) {
+		fmc_pr(QE_DBG, "\t* Quad was %sd, status:%#x\n", str[op],
+		       config);
+		return;
+	}
+
+	if (op)
+		config |= SPI_NOR_CR_QE_MASK;
+	else
+		config &= ~SPI_NOR_CR_QE_MASK;
+
+	writeb(config, host->iobase);
+	fmc_pr(QE_DBG, "\t|-Write IO[%p]%#x\n", host->iobase,
+	       *(unsigned char *)host->iobase);
+
+	set_cmd(spi, SPI_CMD_WRSR2, SPI_NOR_CR_LEN);
+
+	config = spi_general_get_flash_register(spi, SPI_CMD_RDSR2);
+	fmc_pr(QE_DBG, "\t|-Read GD SR-2[%#x], val: %#x\n", SPI_CMD_RDSR2,
+	       config);
+	if (op == spi_nor_get_qe_by_cr(config))
+		fmc_pr(QE_DBG, "\t|-8P %s Quad success, reg: %#x.\n", str[op],
+		       config);
+	else
+		db_msg("Error: %s Quad failed, reg: %#x\n", str[op], config);
+
+	return;
+}
+
+static int spi_gd25qxxx_qe_enable(struct fmc_spi *spi)
+{
+	unsigned char op;
+	const char *str[] = {"Disable", "Enable"};
+
+	op = spi_is_quad(spi);
+
+	fmc_pr(QE_DBG, "\t*-Start GD SPI nor %s Quad.\n", str[op]);
+
+	/* First, we enable/disable QE for 16Pin GD flash, use WRSR[01h] cmd */
+	if (gd_16pin_qe_enable(spi, op))
+		goto QE_END;
+
+	/* Second, we enable/disable QE for 8Pin GD flash, use WRSR2[31h] cmd */
+	gd_8pin_qe_enable(spi, op);
+
+QE_END:
+	/* Enable the reset pin when working on dual mode for 8PIN */
+	if (!op)
+		spi_nor_reset_pin_enable(spi, ENABLE);
+
+	fmc_pr(QE_DBG, "\t*-End GD SPI nor %s Quad end.\n", str[op]);
+	return op;
+}
+
diff -uraN u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100_spi_general.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100_spi_general.c
--- u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100_spi_general.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100_spi_general.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,379 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+/*
+  Get status/config register value from SPI Nor flash
+*/
+unsigned char spi_general_get_flash_register(struct fmc_spi *spi, u_char cmd)
+{
+	unsigned char status;
+	unsigned int reg;
+
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	host->set_system_clock(NULL, ENABLE);
+
+	fmc_pr(SR_DBG, "\t * Start get flash Register[%#x]\n", cmd);
+
+	reg = op_cfg_fm_cs(spi->chipselect) | OP_CFG_OEN_EN;
+	fmc_write(host, FMC_OP_CFG, reg);
+
+	if (cmd == SPI_CMD_RDSR) {
+		reg = fmc_op_read_status_en(ENABLE) | FMC_OP_REG_OP_START;
+		goto cmd_config_done;
+	}
+
+	fmc_write(host, FMC_CMD, cmd);
+	fmc_pr(SR_DBG, "\t   Set CMD[%#x]%#x\n", FMC_CMD, cmd);
+
+	reg = fmc_data_num_cnt(SPI_NOR_CR_LEN);
+	fmc_write(host, FMC_DATA_NUM, reg);
+	fmc_pr(SR_DBG, "\t   Set DATA_NUM[%#x]%#x\n", FMC_DATA_NUM, reg);
+
+	reg = fmc_op_cmd1_en(ENABLE) | fmc_op_read_data_en(ENABLE) |
+		FMC_OP_REG_OP_START;
+
+cmd_config_done:
+	fmc_write(host, FMC_OP, reg);
+	fmc_pr(SR_DBG, "\t   Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	fmc_cmd_wait_cpu_finish(host);
+
+	if (cmd == SPI_CMD_RDSR)
+		status = fmc_read(host, FMC_STATUS);
+	else
+		status = readb(host->iobase);
+	fmc_pr(SR_DBG, "\t * End get flash Register[%#x], val: %#x\n", cmd,
+		status);
+
+	return status;
+}
+
+/*****************************************************************************/
+/*
+    Read status[C0H]:[0]bit OIP, judge whether the device is busy or not
+*/
+static int spi_general_wait_ready(struct fmc_spi *spi)
+{
+	unsigned char status;
+	/* need a big number,so move left 20 bit */
+	unsigned int deadline = 1 << 20;
+
+	do {
+		status = spi_general_get_flash_register(spi, SPI_CMD_RDSR);
+		if (!(status & SPI_NOR_SR_WIP_MASK))
+			return 0;
+
+		udelay(1); /* delay 1 us */
+	} while (deadline--);
+
+	db_msg("Error: SPI nor wait ready timeout, status[%#x]\n", status);
+
+	return 1;
+}
+
+/*****************************************************************************/
+/*
+    Send write enable cmd to SPI Nor, status[C0H]:[2]bit WEL must be set 1
+*/
+static int spi_general_write_enable(struct fmc_spi *spi)
+{
+	unsigned char status;
+	unsigned int reg;
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	if (WE_DBG)
+		printf("\n");
+	fmc_pr(WE_DBG, "\t  * Start Write Enable\n");
+
+	status = spi_general_get_flash_register(spi, SPI_CMD_RDSR);
+	fmc_pr(WE_DBG, "\t    Read Status Register[%#x]:%#x\n", SPI_CMD_RDSR,
+	       status);
+	if (status & STATUS_WEL_MASK) {
+		fmc_pr(WE_DBG, "\t    Write Enable was opened! reg: %#x\n",
+		       status);
+		return 0;
+	}
+
+	reg = fmc_read(host, FMC_GLOBAL_CFG);
+	if (reg & FMC_GLOBAL_CFG_WP_ENABLE) {
+		reg &= ~FMC_GLOBAL_CFG_WP_ENABLE;
+		fmc_write(host, FMC_GLOBAL_CFG, reg);
+		fmc_pr(WE_DBG, "\t    Set GLOBAL_CFG[%#x]%#x\n",
+		       FMC_GLOBAL_CFG, reg);
+	}
+
+	reg = fmc_cmd_cmd1(SPI_CMD_WREN);
+	fmc_write(host, FMC_CMD, reg);
+	fmc_pr(WE_DBG, "\t    Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	reg = op_cfg_fm_cs(spi->chipselect) | OP_CFG_OEN_EN;
+	fmc_write(host, FMC_OP_CFG, reg);
+	fmc_pr(WE_DBG, "\t    Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	reg = fmc_op_cmd1_en(ENABLE) | FMC_OP_REG_OP_START;
+	fmc_write(host, FMC_OP, reg);
+	fmc_pr(WE_DBG, "\t    Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	fmc_cmd_wait_cpu_finish(host);
+
+	spi->driver->wait_ready(spi);
+
+	reg = spi_general_get_flash_register(spi, SPI_CMD_RDSR);
+	if (reg & STATUS_WEL_MASK) {
+		fmc_pr(WE_DBG, "\t    Write Enable success.reg: %#x\n", reg);
+	} else {
+		db_msg("Error: Write Enable failed! status: %#x\n", reg);
+		return status;
+	}
+
+	fmc_pr(WE_DBG, "\t  * End Write Enable\n");
+
+	return 0;
+}
+
+/*****************************************************************************/
+/*
+  enable 4byte address for SPI which memory more than 16M
+*/
+static int spi_general_entry_4addr(struct fmc_spi *spi, int enable)
+{
+	unsigned char status;
+	unsigned int reg;
+	const char *str[] = {"Disable", "Enable"};
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	fmc_pr(AC_DBG, "\t* Start SPI Nor flash %s 4-byte mode.\n",
+	       str[enable]);
+
+	if (spi->addrcycle != SPI_NOR_4BYTE_ADDR_LEN) {
+		fmc_pr(AC_DBG, "\t* Flash isn't support entry 4-byte mode.\n");
+		return 0;
+	}
+
+	status = spi_general_get_flash_register(spi, SPI_CMD_RDSR3);
+	fmc_pr(AC_DBG, "\t  Read Status Register-3[%#x]:%#x\n", SPI_CMD_RDSR3,
+	       status);
+	if (spi_nor_get_4byte_by_cr(status) == enable) {
+		fmc_pr(AC_DBG, "\t* 4-byte was %sd, reg:%#x\n", str[enable],
+		       status);
+		return 0;
+	}
+
+	if (enable)
+		reg = SPI_CMD_EN4B;
+	else
+		reg = SPI_CMD_EX4B;
+	fmc_write(host, FMC_CMD, fmc_cmd_cmd1(reg));
+	fmc_pr(AC_DBG, "\t  Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	reg = op_cfg_fm_cs(spi->chipselect) | OP_CFG_OEN_EN;
+	fmc_write(host, FMC_OP_CFG, reg);
+	fmc_pr(AC_DBG, "\t  Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	reg = fmc_op_cmd1_en(ENABLE) | FMC_OP_REG_OP_START;
+	fmc_write(host, FMC_OP, reg);
+	fmc_pr(AC_DBG, "\t  Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	fmc_cmd_wait_cpu_finish(host);
+
+	spi->driver->wait_ready(spi);
+
+	status = spi_general_get_flash_register(spi, SPI_CMD_RDSR3);
+	fmc_pr(AC_DBG, "\t  Read SR-3[%#x]:%#x\n", SPI_CMD_RDSR3,
+	       status);
+	if (spi_nor_get_4byte_by_cr(status) != enable) {
+		db_msg("Error: %s 4-byte failed! SR3:%#x\n",
+		       str[enable], status);
+		return status;
+	}
+
+	fmc_pr(AC_DBG, "\t  %s 4-byte success, SR3:%#x\n", str[enable], status);
+	fmc_pr(AC_DBG, "\t* End SPI Nor flash %s 4-byte mode.\n", str[enable]);
+
+	return 0;
+}
+
+/****************************************************************************/
+/*
+    judge whether SPI Nor support QUAD read write or not
+*/
+int spi_is_quad(struct fmc_spi *spi)
+{
+	char *const if_str[] = {"STD", "DUAL", "DIO", "QUAD", "QIO", "DTR"};
+
+	fmc_pr(QE_DBG, "\t\t|*-SPI read iftype: %s write iftype: %s\n",
+	       if_str[spi->read->iftype], if_str[spi->write->iftype]);
+
+	if ((spi->read->iftype == IF_TYPE_QUAD) ||
+	    (spi->read->iftype == IF_TYPE_QIO) ||
+	    (spi->write->iftype == IF_TYPE_QUAD) ||
+#ifdef CONFIG_DTR_MODE_SUPPORT
+	    (spi->read->iftype == IF_TYPE_DTR) ||
+#endif
+	    (spi->write->iftype == IF_TYPE_QIO)
+	   ) {
+		return 1;
+	}
+
+	return 0;
+}
+
+/*****************************************************************************/
+static void spi_general_set_cmd(struct fmc_spi *spi)
+{
+	unsigned int reg;
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	reg = fmc_cmd_cmd1(SPI_CMD_WRSR);
+	fmc_write(host, FMC_CMD, reg);
+	fmc_pr(QE_DBG, "\t|-Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	reg = op_cfg_fm_cs(spi->chipselect) | OP_CFG_OEN_EN;
+	fmc_write(host, FMC_OP_CFG, reg);
+	fmc_pr(QE_DBG, "\t|-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	reg = fmc_data_num_cnt(SPI_NOR_SR_LEN + SPI_NOR_CR_LEN);
+	fmc_write(host, FMC_DATA_NUM, reg);
+	fmc_pr(QE_DBG, "\t|-Set DATA_NUM[%#x]%#x\n", FMC_DATA_NUM, reg);
+
+	reg = fmc_op_cmd1_en(ENABLE) |
+	      fmc_op_write_data_en(ENABLE) |
+	      FMC_OP_REG_OP_START;
+	fmc_write(host, FMC_OP, reg);
+	fmc_pr(QE_DBG, "\t|-Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	fmc_cmd_wait_cpu_finish(host);
+}
+/*****************************************************************************/
+/*
+ * enable QE bit if QUAD read write is supported by SPI
+ */
+static int spi_general_qe_enable(struct fmc_spi *spi)
+{
+	unsigned char status;
+	unsigned char config;
+	unsigned char op;
+
+	const char *str[] = {"Disable", "Enable"};
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	op = spi_is_quad(spi);
+
+	fmc_pr(QE_DBG, "\t*-Start SPI Nor %s Quad.\n", str[op]);
+
+	config = spi_general_get_flash_register(spi, SPI_CMD_RDCR);
+	fmc_pr(QE_DBG, "\t|-Read Config Register[%#x]%#x\n", SPI_CMD_RDCR,
+	       config);
+	if (op == spi_nor_get_qe_by_cr(config)) {
+		fmc_pr(QE_DBG, "\t* Quad was %sd, config:%#x\n", str[op],
+		       config);
+		return op;
+	}
+
+	status = spi_general_get_flash_register(spi, SPI_CMD_RDSR);
+	fmc_pr(QE_DBG, "\t|-Read Status Register[%#x]%#x\n", SPI_CMD_RDSR,
+	       status);
+
+	spi->driver->write_enable(spi);
+
+	if (op)
+		config |= SPI_NOR_CR_QE_MASK;
+	else
+		config &= ~SPI_NOR_CR_QE_MASK;
+	writeb(status, host->iobase);
+	writeb(config, host->iobase + SPI_NOR_SR_LEN);
+	fmc_pr(QE_DBG, "\t|-Write IO[%p]%#x\n", host->iobase,
+	       *(unsigned short *)host->iobase);
+
+	spi_general_set_cmd(spi);
+
+	spi->driver->wait_ready(spi);
+
+	config = spi_general_get_flash_register(spi, SPI_CMD_RDCR);
+	if (op == spi_nor_get_qe_by_cr(config)) {
+		fmc_pr(QE_DBG, "\t|-%s Quad success, config: %#x\n", str[op],
+		       config);
+	} else {
+		db_msg("Error: %s Quad failed! reg: %#x\n", str[op], config);
+	}
+
+	fmc_pr(QE_DBG, "\t* End SPI Nor %s Quad.\n", str[op]);
+
+	return op;
+}
+
+/*****************************************************************************/
+/*
+  some chip don't QUAD enable
+*/
+static int spi_do_not_qe_enable(struct fmc_spi *spi)
+{
+	return 0;
+}
+
+/*****************************************************************************/
+/*
+ * some chip set the mux HOLD#/RESET#/IO3 pin to RESET#, as it is HOLD# default.
+ */
+static void spi_nor_reset_pin_enable(struct fmc_spi *spi, int enable)
+{
+	unsigned char config;
+	unsigned int regval;
+	const char *str[] = {"HOLD#", "RESET#"};
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	config = spi_general_get_flash_register(spi, SPI_CMD_RDSR3);
+	fmc_pr(RST_DB, "\t|-Read SR-3[%#x], val: %#x\n",
+	       SPI_CMD_RDSR3, config);
+
+	if (enable == spi_nor_get_rst_hold_by_cr(config)) {
+		fmc_pr(RST_DB, " Device has worked on %s.\n", str[enable]);
+		return;
+	}
+
+	fmc_pr(RST_DB, " Start to enable %s function.\n", str[enable]);
+	spi->driver->write_enable(spi);
+
+	if (enable)
+		config = spi_nor_set_rst_by_cr(config);
+	else
+		config = spi_nor_set_hold_by_cr(config);
+
+	writeb(config, host->iobase);
+	fmc_pr(RST_DB, "\t|-Write IO[%p]%#x\n", host->iobase,
+	       *(unsigned char *)host->iobase);
+
+	regval = fmc_cmd_cmd1(SPI_CMD_WRSR3);
+	fmc_write(host, FMC_CMD, regval);
+	fmc_pr(RST_DB, "\t|-Set CMD[%#x]%#x\n", FMC_CMD, regval);
+
+	regval = op_cfg_fm_cs(spi->chipselect) | OP_CFG_OEN_EN;
+	fmc_write(host, FMC_OP_CFG, regval);
+	fmc_pr(RST_DB, "\t|-Set OP_CFG[%#x]%#x\n",
+	       FMC_OP_CFG, regval);
+
+	regval = fmc_data_num_cnt(SPI_NOR_CR_LEN);
+	fmc_write(host, FMC_DATA_NUM, regval);
+	fmc_pr(RST_DB, "\t|-Set DATA_NUM[%#x]%#x\n",
+	       FMC_DATA_NUM, regval);
+
+	regval = fmc_op_cmd1_en(ENABLE) |
+		 fmc_op_write_data_en(ENABLE) |
+		 FMC_OP_REG_OP_START;
+	fmc_write(host, FMC_OP, regval);
+	fmc_pr(RST_DB, "\t|-Set OP[%#x]%#x\n", FMC_OP, regval);
+
+	fmc_cmd_wait_cpu_finish(host);
+
+	spi->driver->wait_ready(spi);
+
+	config = spi_general_get_flash_register(spi, SPI_CMD_RDSR3);
+	fmc_pr(RST_DB, "\t|-Read SR-3[%#x], val: %#x\n",
+	       SPI_CMD_RDSR3, config);
+	if (enable == spi_nor_get_rst_hold_by_cr(config))
+		fmc_pr(RST_DB, "\t|- Set the MUX pin to RESET# success!\n");
+	else
+		fmc_pr(RST_DB, "\t|- The MUX pin works on HOLD# or DNU!\n");
+}
diff -uraN u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100_spi_issi.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100_spi_issi.c
--- u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100_spi_issi.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100_spi_issi.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#define SPI_NOR_ISSI_QE_SHIFT      6
+#define SPI_NOR_ISSI_SRWD_MASK      (1 << 7)
+#define SPI_NOR_ISSI_QE_MASK        (1 << SPI_NOR_ISSI_QE_SHIFT)
+#define spi_nor_issi_get_qe(sr)        (((sr) & SPI_NOR_ISSI_QE_MASK) \
+						>> SPI_NOR_ISSI_QE_SHIFT)
+
+static void spi_issi_set_cmd(struct fmc_spi *spi)
+{
+	unsigned int reg;
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	reg = fmc_cmd_cmd1(SPI_CMD_WRSR);
+	fmc_write(host, FMC_CMD, reg);
+	fmc_pr(QE_DBG, "\t|-Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	reg = op_cfg_fm_cs(spi->chipselect) | OP_CFG_OEN_EN;
+	fmc_write(host, FMC_OP_CFG, reg);
+	fmc_pr(QE_DBG, "\t|-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	reg = fmc_data_num_cnt(SPI_NOR_SR_LEN);
+	fmc_write(host, FMC_DATA_NUM, reg);
+	fmc_pr(QE_DBG, "\t|-Set DATA_NUM[%#x]%#x\n", FMC_DATA_NUM, reg);
+
+	reg = fmc_op_cmd1_en(ENABLE) |
+		fmc_op_write_data_en(ENABLE) |
+		FMC_OP_REG_OP_START;
+	fmc_write(host, FMC_OP, reg);
+	fmc_pr(QE_DBG, "\t|-Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	fmc_cmd_wait_cpu_finish(host);
+}
+
+static int spi_issi_qe_enable(struct fmc_spi *spi)
+{
+	unsigned char config;
+	unsigned char op;
+
+	const char *str[] = {"Disable", "Enable"};
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	op = spi_is_quad(spi);
+
+	fmc_pr(QE_DBG, "\t*-Start SPI Nor %s Quad.\n", str[op]);
+
+	config = spi_general_get_flash_register(spi, SPI_CMD_RDSR);
+	fmc_pr(QE_DBG, "\t|-Read Config Register[%#x]%#x\n", SPI_CMD_RDSR,
+	       config);
+	if (op == spi_nor_issi_get_qe(config)) {
+		fmc_pr(QE_DBG, "\t* Quad was %sd, config:%#x\n", str[op],
+		       config);
+		return op;
+	}
+
+	spi->driver->write_enable(spi);
+
+	config = spi_general_get_flash_register(spi, SPI_CMD_RDSR);
+	config &= ~SPI_NOR_ISSI_SRWD_MASK;
+
+	if (op)
+		config |= SPI_NOR_ISSI_QE_MASK;
+	else
+		config &= ~SPI_NOR_ISSI_QE_MASK;
+	writeb(config, host->iobase);
+	fmc_pr(QE_DBG, "\t|-Write IO[%p]%#x\n", host->iobase,
+	       *(unsigned short *)host->iobase);
+
+	spi_issi_set_cmd(spi);
+
+	spi->driver->wait_ready(spi);
+
+	config = spi_general_get_flash_register(spi, SPI_CMD_RDSR);
+	if (op == spi_nor_issi_get_qe(config)) {
+		fmc_pr(QE_DBG, "\t|-%s Quad success, config: %#x\n", str[op],
+		       config);
+	} else {
+		db_msg("Error: %s Quad failed! reg: %#x\n", str[op], config);
+	}
+
+	fmc_pr(QE_DBG, "\t* End SPI Nor %s Quad.\n", str[op]);
+
+	return op;
+}
+
diff -uraN u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100_spi_micron.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100_spi_micron.c
--- u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100_spi_micron.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100_spi_micron.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,79 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+/*****************************************************************************/
+#define SPI_CMD_FIRST_RESET_4ADDR  0x66
+#define SPI_CMD_SECOND_RESET_4ADDR 0x99
+
+#define SPI_CMD_FLAG_SR_MICRON  0x70  /* READ FLAG STATUS REGISTER */
+#define SPI_CMD_RD_RDCR_MICRON  0xB5  /* READ NONVOLATILE CONFIGURATION
+                                         REGISTER */
+#define SPI_CMD_WR_RDCR_MICRON  0xB1 /* WRITE NONVOLATILE CONFIGURATION
+                                         REGISTER */
+#define SPI_NOR_ADS_MASK    0x1
+#define spi_nor_get_4byte_by_flag_sr(sr)     ((sr) & SPI_NOR_ADS_MASK)
+
+#define spi_nor_ads_set_4byte(cr)        ((cr) & (~SPI_NOR_ADS_MASK))
+#define spi_nor_ads_get_4byte(cr)        ((cr) & SPI_NOR_ADS_MASK)
+/****************************************************************************/
+static int spi_micron_entry_4addr(struct fmc_spi *spi, int enable)
+{
+	unsigned char status;
+	unsigned int reg;
+	const char *str[] = {"Disable", "Enable"};
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	fmc_pr(AC_DBG, "\t* Start SPI Nor %s 4-byte mode.\n",
+	       str[enable]);
+
+	if (spi->addrcycle != SPI_NOR_4BYTE_ADDR_LEN) {
+		fmc_pr(AC_DBG, "\t* Not support 4B mode.\n");
+		return 0;
+	}
+
+	status = spi_general_get_flash_register(spi, SPI_CMD_FLAG_SR_MICRON);
+	fmc_pr(AC_DBG, "\t Read flag status register[%#x]:%#x\n",
+	       SPI_CMD_FLAG_SR_MICRON, status);
+	if (spi_nor_get_4byte_by_flag_sr(status) == enable) {
+		fmc_pr(AC_DBG, "\t* 4-byte was %sd, reg:%#x\n", str[enable],
+		       status);
+		return 0;
+	}
+
+	spi->driver->write_enable(spi);
+
+	if (enable)
+		reg = SPI_CMD_EN4B;
+	else
+		reg = SPI_CMD_EX4B;
+	fmc_write(host, FMC_CMD, fmc_cmd_cmd1(reg));
+	fmc_pr(AC_DBG, "\t  Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	reg = op_cfg_fm_cs(spi->chipselect) | OP_CFG_OEN_EN;
+	fmc_write(host, FMC_OP_CFG, reg);
+	fmc_pr(AC_DBG, "\t  Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	reg = fmc_op_cmd1_en(ENABLE) | FMC_OP_REG_OP_START;
+	fmc_write(host, FMC_OP, reg);
+	fmc_pr(AC_DBG, "\t  Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	fmc_cmd_wait_cpu_finish(host);
+
+	spi->driver->wait_ready(spi);
+
+	status = spi_general_get_flash_register(spi,
+						SPI_CMD_FLAG_SR_MICRON);
+	fmc_pr(AC_DBG, "\t Read flag status register[%#x]:%#x\n",
+	       SPI_CMD_FLAG_SR_MICRON, status);
+	if (spi_nor_get_4byte_by_flag_sr(status) != enable) {
+		db_msg("Error: %s 4-byte failed! SR3:%#x\n",
+		       str[enable], status);
+		return status;
+	}
+
+	fmc_pr(AC_DBG, "\t  %s 4-byte success, SR3:%#x\n", str[enable], status);
+	fmc_pr(AC_DBG, "\t* End SPI Nor flash %s 4-byte mode.\n", str[enable]);
+
+	return 0;
+}
diff -uraN u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100_spi_mx25l25635e.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100_spi_mx25l25635e.c
--- u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100_spi_mx25l25635e.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100_spi_mx25l25635e.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,257 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+/*****************************************************************************/
+/* MXIC QE(bit) include in Status Register */
+#define MX_SPI_NOR_SR_QE_SHIFT  6
+#define MX_SPI_NOR_SR_QE_MASK   (1 << MX_SPI_NOR_SR_QE_SHIFT)
+#define mx_spi_nor_get_qe_by_sr(sr) (((sr) & MX_SPI_NOR_SR_QE_MASK) \
+							>> MX_SPI_NOR_SR_QE_SHIFT)
+
+/*****************************************************************************/
+/*
+ * enable QE bit if 4X R/W is supported by MXIC "25L(256/257)35(E/F)" SPI
+ */
+#ifndef CONFIG_DTR_MODE_SUPPORT
+static void clear_dtr_mode(struct fmc_spi *spi, unsigned char status)
+{
+	unsigned int regval;
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+	unsigned char config;
+	unsigned short reg;
+
+	config = spi_general_get_flash_register(spi, SPI_CMD_RDCR_MX);
+
+	regval = fmc_read(host, FMC_GLOBAL_CFG);
+	if ((regval >> DTR_MODE_REQUEST_SHIFT) & 0x1) {
+		regval &= (~(1 << DTR_MODE_REQUEST_SHIFT));
+		regval = fmc_write(host, FMC_GLOBAL_CFG, regval);
+	}
+
+	if (config & CR_DUMMY_CYCLE) {
+		config &= (~CR_DUMMY_CYCLE);
+		reg = ((unsigned short)config << SPI_NOR_CR_SHIFT) | status;
+		writew(reg, host->iobase);
+		spi->driver->write_enable(spi);
+		fmc100_op_reg(spi, SPI_CMD_WRSR, sizeof(unsigned short), fmc_op_write_data_en(ENABLE));
+	}
+}
+#endif
+/*****************************************************************************/
+static void spi_mx25l25635e_set_cmd(struct fmc_spi *spi)
+{
+	unsigned int regval;
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	regval = fmc_cmd_cmd1(SPI_CMD_WRSR);
+	fmc_write(host, FMC_CMD, regval);
+	fmc_pr(QE_DBG, "\t||-Set CMD[%#x]%#x\n", FMC_CMD, regval);
+
+	regval = op_cfg_fm_cs(spi->chipselect) | OP_CFG_OEN_EN;
+	fmc_write(host, FMC_OP_CFG, regval);
+	fmc_pr(QE_DBG, "\t||-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, regval);
+
+	regval = fmc_data_num_cnt(SPI_NOR_SR_LEN);
+	fmc_write(host, FMC_DATA_NUM, regval);
+	fmc_pr(QE_DBG, "\t||-Set DATA_NUM[%#x]%#x\n", FMC_DATA_NUM, regval);
+
+	regval = fmc_op_cmd1_en(ENABLE) | fmc_op_write_data_en(ENABLE) |
+			FMC_OP_REG_OP_START;
+	fmc_write(host, FMC_OP, regval);
+	fmc_pr(QE_DBG, "\t||-Set OP[%#x]%#x\n", FMC_OP, regval);
+
+	fmc_cmd_wait_cpu_finish(host);
+}
+
+/*****************************************************************************/
+static int spi_mx25l25635e_qe_enable(struct fmc_spi *spi)
+{
+	unsigned char status;
+	unsigned char op;
+	const char *str[] = {"Disable", "Enable"};
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	op = spi_is_quad(spi);
+
+	fmc_pr(QE_DBG, "\t|*-Start MXIC SPI Nor %s Quad.\n", str[op]);
+
+	status = spi_general_get_flash_register(spi, SPI_CMD_RDSR);
+	fmc_pr(QE_DBG, "\t||-Read Status Register[%#x]%#x\n", SPI_CMD_RDSR,
+	       status);
+
+#ifndef CONFIG_DTR_MODE_SUPPORT
+	clear_dtr_mode(spi, status);
+#endif
+
+	if (mx_spi_nor_get_qe_by_sr(status) == op) {
+		fmc_pr(QE_DBG, "\t|*-Quad was %sd, status:%#x\n", str[op],
+		       status);
+		return op;
+	}
+
+	spi->driver->write_enable(spi);
+
+	if (op)
+		status |= MX_SPI_NOR_SR_QE_MASK;
+	else
+		status &= ~MX_SPI_NOR_SR_QE_MASK;
+
+	writeb(status, host->iobase);
+	fmc_pr(QE_DBG, "\t||-Write IO[%p]%#x\n", host->iobase,
+	       *(unsigned char *)host->iobase);
+
+	spi_mx25l25635e_set_cmd(spi);
+
+	spi->driver->wait_ready(spi);
+
+	status = spi_general_get_flash_register(spi, SPI_CMD_RDSR);
+	if (mx_spi_nor_get_qe_by_sr(status) == op)
+		fmc_pr(QE_DBG, "\t||-%s Quad success, status:%#x.\n", str[op],
+		       status);
+	else
+		db_msg("Error: %s Quad failed! reg: %#x\n", str[op], status);
+
+	fmc_pr(QE_DBG, "\t|*-End MXIC SPI Nor %s Quad.\n", str[op]);
+
+	return op;
+}
+
+#ifdef CONFIG_DTR_MODE_SUPPORT
+/*****************************************************************************/
+void spi_mxic_set_reg(struct fmc_spi *spi)
+{
+	unsigned int regval;
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	regval = fmc_cmd_cmd1(SPI_CMD_WRSR);
+	fmc_write(host, FMC_CMD, regval);
+	fmc_pr(DTR_DB, " Set CMD[%#x]%#x\n", FMC_CMD, regval);
+
+	regval = op_cfg_fm_cs(spi->chipselect) | OP_CFG_OEN_EN;
+	fmc_write(host, FMC_OP_CFG, regval);
+	fmc_pr(DTR_DB, " Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, regval);
+
+	regval = fmc_data_num_cnt(SPI_NOR_SR_LEN + SPI_NOR_CR_LEN);
+	fmc_write(host, FMC_DATA_NUM, regval);
+	fmc_pr(DTR_DB, " Set DATA_NUM[%#x]%#x\n", FMC_DATA_NUM, regval);
+
+	regval = fmc_op_cmd1_en(ENABLE) 	|
+		fmc_op_write_data_en(ENABLE) 	|
+		FMC_OP_REG_OP_START;
+	fmc_write(host, FMC_OP, regval);
+	fmc_pr(DTR_DB, " Set OP[%#x]%#x\n", FMC_OP, regval);
+}
+/*****************************************************************************/
+int spi_mxic_output_driver_strength_set(struct fmc_spi *spi, int dtr_en)
+{
+	unsigned char status;
+	unsigned char config;
+	unsigned short reg;
+	unsigned short val = 0;
+	unsigned int ix;
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	/************************************************************************/
+	/* DC[1:0]  |  Numbers of Dummy clock cycles|  Quad IO DTR Read     */
+	/*   00(default)|       6       |   54      */
+	/*   01     |       6       |   54      */
+	/*   10     |       8       |   70/80R      */
+	/*   11     |       10      |   84/100R     */
+	/************************************************************************/
+	unsigned int str_dummy[] = {
+		DTR_DUMMY_CYCLES_6,      dtr_rdcr_dc_mask(0),
+		DTR_DUMMY_CYCLES_6,      dtr_rdcr_dc_mask(1),
+		DTR_DUMMY_CYCLES_8,      dtr_rdcr_dc_mask(2),
+		DTR_DUMMY_CYCLES_10,     dtr_rdcr_dc_mask(3),
+		0,      0,
+	};
+
+	/* get the RDCR and RDSR */
+	spi->driver->wait_ready(spi);
+
+	/* setting the DC value to match high system clock */
+	config = spi_general_get_flash_register(spi, SPI_CMD_RDCR_MX);
+	fmc_pr(DTR_DB, "Get Config Register[%#x]\n", config);
+
+	/* check the QE value */
+	status = spi_general_get_flash_register(spi, SPI_CMD_RDSR);
+	fmc_pr(DTR_DB, "Get Status Register[%#x]\n", status);
+
+	reg = ((unsigned short)config << SPI_NOR_CR_SHIFT) | status;
+
+	if (dtr_en == ENABLE) {
+		/* setting DC value */
+		fmc_pr(DTR_DB, "Get the dummy value[%#x]\n", spi->read->dummy);
+		/* Only the element with an even number of arrays is required, so increase is 2 */
+		for (ix = 0; str_dummy[ix]; ix += _2B) {
+			if (spi->read->dummy < str_dummy[ix])
+				break;
+			val = (unsigned short)str_dummy[ix + 1];
+		}
+	} else {
+		val = dtr_rdcr_dc_mask(0);
+	}
+
+	reg = dtr_rdcr_dc_bit_clr(reg) | (val << DTR_RDSR_DC_SHIFT);
+
+	spi->driver->write_enable(spi);
+	writew(reg, host->iobase);
+	fmc_pr(DTR_DB, "Write IO[%p]%#x\n", host->iobase,
+	       *(unsigned short *)host->iobase);
+	spi_mxic_set_reg(spi);
+	fmc_cmd_wait_cpu_finish(host);
+
+	config = spi_general_get_flash_register(spi, SPI_CMD_RDCR_MX);
+	if ((config >> DTR_RDCR_DC_SHIFT) != (unsigned char)val) {
+		printf("* Set DC dummy fail.\n");
+		return -1;
+	}
+	return 0;
+}
+
+unsigned int spi_mxic_check_spi_dtr_support(struct fmc_spi *spi)
+{
+	unsigned int regval;
+	unsigned int rd_sfdp_dummy = 1;
+	unsigned int sfdp_addrcycle = 3;
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	/* get the RDCR and RDSR */
+	spi->driver->wait_ready(spi);
+
+	/* Read the Serial Flash Discoverable Parameter (SFDP) */
+	fmc_write(host, FMC_CMD, SPI_CMD_RD_SFDP);
+	fmc_pr(DTR_DB, "\t   Set CMD[%#x]%#x\n", FMC_CMD, SPI_CMD_RD_SFDP);
+
+	regval = op_cfg_fm_cs(spi->chipselect) 		|
+			OP_CFG_OEN_EN 			|
+			op_cfg_addr_num(sfdp_addrcycle) |
+			op_cfg_dummy_num(rd_sfdp_dummy);
+	fmc_write(host, FMC_OP_CFG, regval);
+	fmc_pr(DTR_DB, "\t\t   Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, regval);
+
+	regval = fmc_data_num_cnt(SFDP_BUF_LEN);
+	fmc_write(host, FMC_DATA_NUM, regval);
+	fmc_pr(DTR_DB, "\t   Set DATA_NUM[%#x]%#x\n", FMC_DATA_NUM, regval);
+
+	regval = fmc_op_dummy_en(ENABLE) 		|
+			fmc_op_cmd1_en(ENABLE) 		|
+			fmc_op_addr_en(ENABLE) 		|
+			fmc_op_read_data_en(ENABLE) 	|
+			FMC_OP_REG_OP_START;
+	fmc_write(host, FMC_OP, regval);
+	fmc_pr(DTR_DB, "\t   Set OP[%#x]%#x\n", FMC_OP, regval);
+
+	fmc_cmd_wait_cpu_finish(host);
+
+	regval = readb((char *)host->iobase + SFDP_DTR_BYTE_SHIFT);
+	fmc_pr(DTR_DB, "\t the dtr_mode_support is: %#x\n", regval);
+
+	/* get the DTR mode support bit */
+	spi->dtr_mode_support = (regval >> SFDP_DTR_BIT_SHIFT)
+				& SFDP_DTR_BIT_MASK;
+
+	return spi->dtr_mode_support;
+}
+#endif /* CONFIG_DTR_MODE_SUPPORT */
diff -uraN u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100_spi_puya.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100_spi_puya.c
--- u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100_spi_puya.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100_spi_puya.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+/*****************************************************************************/
+static int spi_puya_entry_4addr(struct fmc_spi *spi, int enable)
+{
+	return 0;
+}
+
+/****************************************************************************/
+/*
+ *  enable QE bit if QUAD read write is supported by puya'a P25Q128H,it is as same as W25Q(128/256)FV
+ *  opcode	type	name
+ *   0x35	 RD	SR(S15-S8)
+ *   0x31	 WR	SR(S15-S8)
+ */
+static int spi_puya_qe_enable(struct fmc_spi *spi)
+{
+	unsigned char status;
+	unsigned char op;
+	unsigned int regval;
+	const char *str[] = {"Disable", "Enable"};
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	op = spi_is_quad(spi);
+
+	fmc_pr(QE_DBG, "\t* Start SPI Nor %s Quad.\n", str[op]);
+
+	status = spi_general_get_flash_register(spi, SPI_CMD_RDSR2);
+	fmc_pr(QE_DBG, "\t  Read Status Register-2[%#x]%#x\n", SPI_CMD_RDSR2,
+			status);
+	if (spi_nor_get_qe_by_cr(status) == op) {
+		fmc_pr(QE_DBG, "\t* Quad was %s status:%#x\n", str[op], status);
+		goto QE_END;
+	}
+
+	spi->driver->write_enable(spi);
+	if (op)
+		status |= SPI_NOR_CR_QE_MASK;
+	else
+		status &= ~SPI_NOR_CR_QE_MASK;
+
+	writeb(status, host->iobase);
+	fmc_pr(QE_DBG, "\t  Write IO[%#lx]%#x\n", (uintptr_t)host->iobase,
+			*(unsigned char *)host->iobase);
+
+	/* There is new cmd for Write Status Register 2 by W25Q(128/256)FV */
+	regval = fmc_cmd_cmd1(SPI_CMD_WRSR2);
+	fmc_write(host, FMC_CMD, regval);
+	fmc_pr(QE_DBG, "\t  Set CMD[%#x]%#x\n", FMC_CMD, regval);
+
+	regval = op_cfg_fm_cs(spi->chipselect);
+	fmc_write(host, FMC_OP_CFG, regval);
+	fmc_pr(QE_DBG, "\t  Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, regval);
+
+	regval = fmc_data_num_cnt(SPI_NOR_SR_LEN);
+	fmc_write(host, FMC_DATA_NUM, regval);
+	fmc_pr(QE_DBG, "\t  Set DATA_NUM[%#x]%#x\n", FMC_DATA_NUM, regval);
+
+	regval = fmc_op_cmd1_en(ENABLE) |
+		fmc_op_write_data_en(ENABLE) | FMC_OP_REG_OP_START;
+	fmc_write(host, FMC_OP, regval);
+	fmc_pr(QE_DBG, "\t  Set OP[%#x]%#x\n", FMC_OP, regval);
+
+	fmc_cmd_wait_cpu_finish(host);
+
+	/* wait the flash have switched quad mode success */
+	spi->driver->wait_ready(spi);
+
+	status = spi_general_get_flash_register(spi, SPI_CMD_RDSR2);
+	fmc_pr(QE_DBG, "\t  Read Status Register-2[%#x]:%#x\n",
+			SPI_CMD_RDSR2, status);
+	if (spi_nor_get_qe_by_cr(status) == op)
+		fmc_pr(QE_DBG, "\t  %s Quad success. status:%#x\n",
+				str[op], status);
+	else
+		db_msg("Error: %s Quad failed! reg:%#x\n", str[op], status);
+QE_END:
+	return op;
+}
\ No newline at end of file
diff -uraN u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100_spi_s25fl256s.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100_spi_s25fl256s.c
--- u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100_spi_s25fl256s.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100_spi_s25fl256s.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+/*****************************************************************************/
+/* SpanSion SPI Nor Flash "S25FL256S" Bank Address Register command */
+#define SS_SPI_CMD_BRRD         0x16    /* Read Bank Register */
+#define SS_SPI_CMD_BRWR         0x17    /* Write Bank Register */
+
+/* Bank Address Register length(byte) */
+#define SS_SPI_NOR_BR_LEN       1
+
+/* Extended Address Enable bit[7] include in Bank Address Register */
+#define SS_SPI_NOR_BR_EAE_SHIFT     7
+#define SS_SPI_NOR_BR_EAE_MASK      (1 << SS_SPI_NOR_BR_EAE_SHIFT)
+#define ss_spi_nor_get_eae_by_br(br)    (((br) & SS_SPI_NOR_BR_EAE_MASK) \
+						>> SS_SPI_NOR_BR_EAE_SHIFT)
+
+/*****************************************************************************/
+static void spi_s25fl256s_set_cmd(struct fmc_spi *spi)
+{
+	unsigned int regval;
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	regval = fmc_cmd_cmd1(SS_SPI_CMD_BRWR);
+	fmc_write(host, FMC_CMD, regval);
+	fmc_pr(AC_DBG, "\t  Set CMD[%#x]%#x\n", FMC_CMD, regval);
+
+	regval = op_cfg_fm_cs(spi->chipselect);
+	fmc_write(host, FMC_OP_CFG, regval);
+	fmc_pr(AC_DBG, "\t  Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, regval);
+
+	regval = fmc_data_num_cnt(SS_SPI_NOR_BR_LEN);
+	fmc_write(host, FMC_DATA_NUM, regval);
+	fmc_pr(AC_DBG, "\t  Set DATA_NUM[%#x]%#x\n", FMC_DATA_NUM, regval);
+
+	regval = fmc_op_cmd1_en(ENABLE)
+		 | fmc_op_write_data_en(ENABLE)
+		 | FMC_OP_REG_OP_START;
+	fmc_write(host, FMC_OP, regval);
+	fmc_pr(AC_DBG, "\t  Set OP[%#x]%#x\n", FMC_OP, regval);
+
+	fmc_cmd_wait_cpu_finish(host);
+}
+/*****************************************************************************/
+/*
+  enable 4byte address mode for SpanSion "s25fl256" SPI Nor
+*/
+static int spi_s25fl256s_entry_4addr(struct fmc_spi *spi, int enable)
+{
+	unsigned char bank;
+	const char *str[] = {"Disable", "Enable"};
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	fmc_pr(AC_DBG, "\t* Start SpanSion SPI Nor %s 4-byte mode.\n",
+	       str[enable]);
+
+	if (spi->addrcycle != SPI_NOR_4BYTE_ADDR_LEN) {
+		fmc_pr(AC_DBG, "\t* Flash isn't support 4-byte mode.\n");
+		return 0;
+	}
+
+	/* Read old Bank Register value */
+	bank = spi_general_get_flash_register(spi, SS_SPI_CMD_BRRD);
+	fmc_pr(AC_DBG, "\t  Read Bank Register[%#x]%#x\n", SS_SPI_CMD_BRRD,
+	       bank);
+	if (ss_spi_nor_get_eae_by_br(bank) == enable) {
+		fmc_pr(AC_DBG, "\t* 4-byte was %sd, bank:%#x\n", str[enable],
+		       bank);
+		return 0;
+	}
+
+	/* Write new Bank Register value */
+	if (enable)
+		bank |= SS_SPI_NOR_BR_EAE_MASK;
+	else
+		bank &= ~SS_SPI_NOR_BR_EAE_MASK;
+	writeb(bank, host->iobase);
+	fmc_pr(AC_DBG, "\t  Write IO[%p]%#x\n", host->iobase,
+	       *(unsigned char *)host->iobase);
+
+	spi_s25fl256s_set_cmd(spi);
+
+	spi->driver->wait_ready(spi);
+
+	/* Check out Bank Register value */
+	bank = spi_general_get_flash_register(spi, SS_SPI_CMD_BRRD);
+	fmc_pr(AC_DBG, "\t  Read Bank Register[%#x]%#x\n", SS_SPI_CMD_BRRD,
+	       bank);
+	if (ss_spi_nor_get_eae_by_br(bank) != enable) {
+		db_msg("Error: %s 4bytes failed! bank: %#x\n", str[enable],
+		       bank);
+		return bank;
+	}
+
+	fmc_pr(AC_DBG, "\t  %s 4byte success, bank:%#x.\n", str[enable], bank);
+	fmc_pr(AC_DBG, "\t* End SpanSion SPI Nor %s 4-byte mode.\n",
+	       str[enable]);
+
+	return 0;
+}
+
diff -uraN u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100_spi_w25q256fv.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100_spi_w25q256fv.c
--- u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100_spi_w25q256fv.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100_spi_w25q256fv.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,172 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+/*****************************************************************************/
+#define W25Q256FV_CR_4BYTE_MASK     0x1
+
+#define WB_SPI_NOR_SR_ADS_MASK  1
+#define wb_spi_nor_get_4byte_by_sr(sr)  ((sr) & WB_SPI_NOR_SR_ADS_MASK)
+
+#define SPI_CMD_FIRST_RESET_4ADDR  0x66
+#define SPI_CMD_SECOND_RESET_4ADDR 0x99
+
+/****************************************************************************/
+static void spi_w25q256fv_set_cmd(struct fmc_spi *spi, u8 cmd)
+{
+	unsigned int regval;
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	regval = fmc_cmd_cmd1(cmd);
+	fmc_write(host, FMC_CMD, regval);
+	fmc_pr(AC_DBG, "\t  Set CMD[%#x]%#x\n", FMC_CMD, regval);
+
+	regval = op_cfg_fm_cs(spi->chipselect) | OP_CFG_OEN_EN;
+	fmc_write(host, FMC_OP_CFG, regval);
+	fmc_pr(AC_DBG, "\t  Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, regval);
+
+	regval = fmc_op_cmd1_en(ENABLE) | FMC_OP_REG_OP_START;
+	fmc_write(host, FMC_OP, regval);
+	fmc_pr(AC_DBG, "\t  Set OP[%#x]%#x\n", FMC_OP, regval);
+
+	fmc_cmd_wait_cpu_finish(host);
+}
+/****************************************************************************/
+static int spi_w25q256fv_entry_4addr(struct fmc_spi *spi, int enable)
+{
+	unsigned char status;
+	const char *str[] = {"Disable", "Enable"};
+
+	fmc_pr(AC_DBG, "\t* Start W25Q256FV SPI Nor %s 4-byte mode.\n",
+	       str[enable]);
+
+	if (spi->addrcycle != SPI_NOR_4BYTE_ADDR_LEN) {
+		fmc_pr(AC_DBG, "\t* W25Q(128/256)FV not support 4B mode.\n");
+		return 0;
+	}
+
+	status = spi_general_get_flash_register(spi, SPI_CMD_RDSR3);
+	fmc_pr(AC_DBG, "\t  Read Status Register-3[%#x]:%#x\n", SPI_CMD_RDSR3,
+	       status);
+	if (wb_spi_nor_get_4byte_by_sr(status) == enable) {
+		fmc_pr(AC_DBG, "\t* 4-byte was %sd, reg:%#x\n", str[enable],
+		       status);
+		return 0;
+	}
+
+	if (enable) {
+		spi_w25q256fv_set_cmd(spi, SPI_CMD_EN4B);
+
+		spi->driver->wait_ready(spi);
+
+		status = spi_general_get_flash_register(spi, SPI_CMD_RDSR3);
+		fmc_pr(AC_DBG, "\t  Get Status Register 3[%#x]:%#x\n",
+		       SPI_CMD_RDSR3, status);
+		if (status & W25Q256FV_CR_4BYTE_MASK) {
+			fmc_pr(AC_DBG, "\t  Enter 4-byte success, reg[%#x]\n",
+			       status);
+		} else {
+			db_msg("Error: Enter 4-byte failed! [%#x]\n", status);
+		}
+	} else {
+		/* reset cmd */
+		spi_w25q256fv_set_cmd(spi, SPI_CMD_FIRST_RESET_4ADDR);
+
+		spi_w25q256fv_set_cmd(spi, SPI_CMD_SECOND_RESET_4ADDR);
+
+		fmc_pr(AC_DBG, "\tnow W25Q256FV start software reset\n");
+
+		udelay(30); /* delay 30 us */
+	}
+
+	fmc_pr(AC_DBG, "\t* End W25Q256FV enter 4-byte mode.\n");
+
+	return 0;
+}
+
+/****************************************************************************/
+static void spi_w25q256fv_set_op(struct fmc_spi *spi)
+{
+	unsigned int regval;
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	regval = fmc_cmd_cmd1(SPI_CMD_WRSR2);
+	fmc_write(host, FMC_CMD, regval);
+	fmc_pr(QE_DBG, "\t  Set CMD[%#x]%#x\n", FMC_CMD, regval);
+
+	regval = op_cfg_fm_cs(spi->chipselect) | OP_CFG_OEN_EN;
+	fmc_write(host, FMC_OP_CFG, regval);
+	fmc_pr(QE_DBG, "\t  Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, regval);
+
+	regval = fmc_data_num_cnt(SPI_NOR_SR_LEN);
+	fmc_write(host, FMC_DATA_NUM, regval);
+	fmc_pr(QE_DBG, "\t  Set DATA_NUM[%#x]%#x\n", FMC_DATA_NUM, regval);
+
+	regval = fmc_op_cmd1_en(ENABLE) |
+		 fmc_op_write_data_en(ENABLE) |
+		 FMC_OP_REG_OP_START;
+	fmc_write(host, FMC_OP, regval);
+	fmc_pr(QE_DBG, "\t  Set OP[%#x]%#x\n", FMC_OP, regval);
+
+	fmc_cmd_wait_cpu_finish(host);
+}
+
+/****************************************************************************/
+/*
+   enable QE bit if QUAD read write is supported by W25Q(128/256)FV
+*/
+static int spi_w25q256fv_qe_enable(struct fmc_spi *spi)
+{
+	unsigned char status, op;
+	const char *str[] = {"Disable", "Enable"};
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	op = spi_is_quad(spi);
+
+	fmc_pr(QE_DBG, "\t* Start SPI Nor W25Q(128/256)FV %s Quad.\n", str[op]);
+
+	status = spi_general_get_flash_register(spi, SPI_CMD_RDSR2);
+	fmc_pr(QE_DBG, "\t  Read Status Register-2[%#x]%#x\n", SPI_CMD_RDSR2,
+	       status);
+	if (op == spi_nor_get_qe_by_cr(status)) {
+		fmc_pr(QE_DBG, "\t* Quad was %s status:%#x\n", str[op], status);
+		goto QE_END;
+	}
+
+	spi->driver->write_enable(spi);
+
+	if (op)
+		status |= SPI_NOR_CR_QE_MASK;
+	else
+		status &= ~SPI_NOR_CR_QE_MASK;
+
+	writeb(status, host->iobase);
+	fmc_pr(QE_DBG, "\t  Write IO[%p]%#x\n", host->iobase,
+	       *(unsigned char *)host->iobase);
+
+	/* There is new cmd for Write Status Register 2 by W25Q(128/256)FV */
+	spi_w25q256fv_set_op(spi);
+
+	/* wait the flash have switched quad mode success */
+	spi->driver->wait_ready(spi);
+
+	status = spi_general_get_flash_register(spi, SPI_CMD_RDSR2);
+	fmc_pr(QE_DBG, "\t  Read Status Register-2[%#x]:%#x\n",
+	       SPI_CMD_RDSR2, status);
+	if (op == spi_nor_get_qe_by_cr(status)) {
+		fmc_pr(QE_DBG, "\t  %s Quad success. status:%#x\n",
+		       str[op], status);
+	} else {
+		db_msg("Error: %s Quad failed! reg:%#x\n", str[op],
+		       status);
+	}
+QE_END:
+	/* Enable the reset pin when working on dual mode for 8PIN */
+	if (!op)
+		spi_nor_reset_pin_enable(spi, ENABLE);
+
+	fmc_pr(QE_DBG, "\t* End SPI Nor W25Q(128/256)FV %s Quad.\n", str[op]);
+
+	return op;
+}
+
diff -uraN u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100_spi_xtx.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100_spi_xtx.c
--- u-boot-2016.11/drivers/mtd/spi/fmc100/fmc100_spi_xtx.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc100_spi_xtx.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,90 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+/*****************************************************************************/
+#define XTX_READ_SR_H 	0x35
+#define XTX_READ_SR_L   0x05
+
+/****************************************************************************/
+static void spi_xtx_set_op(struct fmc_spi *spi)
+{
+	unsigned int regval;
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	regval = fmc_cmd_cmd1(SPI_CMD_WRSR);
+	fmc_write(host, FMC_CMD, regval);
+	fmc_pr(QE_DBG, "\t  Set CMD[%#x]%#x\n", FMC_CMD, regval);
+
+	regval = op_cfg_fm_cs(spi->chipselect) | OP_CFG_OEN_EN;
+	fmc_write(host, FMC_OP_CFG, regval);
+	fmc_pr(QE_DBG, "\t  Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, regval);
+
+	regval = fmc_data_num_cnt(sizeof(unsigned short));
+	fmc_write(host, FMC_DATA_NUM, regval);
+	fmc_pr(QE_DBG, "\t  Set DATA_NUM[%#x]%#x\n", FMC_DATA_NUM, regval);
+
+	regval = fmc_op_cmd1_en(ENABLE) | fmc_op_write_data_en(ENABLE) |
+		 FMC_OP_REG_OP_START;
+	fmc_write(host, FMC_OP, regval);
+	fmc_pr(QE_DBG, "\t  Set OP[%#x]%#x\n", FMC_OP, regval);
+
+	fmc_cmd_wait_cpu_finish(host);
+}
+/****************************************************************************/
+/*
+   enable QE bit if QUAD read write is supported by xtx's flash
+*/
+static int spi_xtx_qe_enable(struct fmc_spi *spi)
+{
+	unsigned char status_h;
+	unsigned char status_l;
+	unsigned char op;
+	unsigned short reg;
+	const char *str[] = {"Disable", "Enable"};
+	struct fmc_host *host = (struct fmc_host *)spi->host;
+
+	op = spi_is_quad(spi);
+
+	fmc_pr(QE_DBG, "\t* Start SPI Nor xtx %s Quad.\n", str[op]);
+
+	status_h = spi_general_get_flash_register(spi, XTX_READ_SR_H);
+
+	fmc_pr(QE_DBG, "\t  Read Status Register-h[%#x]%#x\n", XTX_READ_SR_H,
+	       status_h);
+	if (op == spi_nor_get_qe_by_cr(status_h)) {
+		fmc_pr(QE_DBG, "\t* Quad was %s status:%#x\n", str[op], status_h);
+		goto QE_END;
+	}
+
+	spi->driver->write_enable(spi);
+	status_l = spi_general_get_flash_register(spi, XTX_READ_SR_L);
+
+	if (op)
+		status_h |= SPI_NOR_CR_QE_MASK;
+	else
+		status_h &= ~SPI_NOR_CR_QE_MASK;
+	/* Move left to 8 bit to assign a value to the upper bits */
+	reg = ((unsigned short)status_h << 8) | status_l;
+	writew(reg, host->iobase);
+	fmc_pr(QE_DBG, "\t  Write IO[%p]%#x\n", host->iobase,
+	       *(unsigned short *)host->iobase);
+
+	spi_xtx_set_op(spi);
+
+	/* wait the flash have switched quad mode success */
+	spi->driver->wait_ready(spi);
+
+	status_h = spi_general_get_flash_register(spi, XTX_READ_SR_H);
+	fmc_pr(QE_DBG, "\t  Read Status Register-h[%#x]:%#x\n",
+	       XTX_READ_SR_H, status_h);
+	if (op == spi_nor_get_qe_by_cr(status_h)) {
+		fmc_pr(QE_DBG, "\t  %s Quad success. status_h:%#x\n",
+		       str[op], status_h);
+	} else {
+		db_msg("Error: %s Quad failed! reg:%#x\n", str[op],
+		       status_h);
+	}
+QE_END:
+	return status_h;
+}
diff -uraN u-boot-2016.11/drivers/mtd/spi/fmc100/fmc_spi_nor_ids.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc_spi_nor_ids.c
--- u-boot-2016.11/drivers/mtd/spi/fmc100/fmc_spi_nor_ids.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/fmc_spi_nor_ids.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,2206 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+/*****************************************************************************/
+#include <common.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include "fmc100.h"
+
+/*****************************************************************************/
+struct spi_nor_info *spiinfo;
+
+/*****************************************************************************/
+set_read_std(0, INFINITE, 33);
+set_read_std(0, INFINITE, 40);
+set_read_std(0, INFINITE, 45);
+set_read_std(0, INFINITE, 50);
+set_read_std4b(0, INFINITE, 50);
+set_read_std(0, INFINITE, 54);
+set_read_std4b(0, INFINITE, 54);
+set_read_std(0, INFINITE, 55);
+set_read_std4b(0, INFINITE, 55);
+set_read_std(0, INFINITE, 66);
+set_read_std4b(0, INFINITE, 66);
+set_read_std(0, INFINITE, 80);
+
+set_read_fast(1, INFINITE, 55);
+set_read_fast(1, INFINITE, 80);
+set_read_fast4b(1, INFINITE, 80);
+set_read_fast(1, INFINITE, 86);
+set_read_fast(1, INFINITE, 100);
+set_read_fast(1, INFINITE, 104);
+set_read_fast4b(1, INFINITE, 104);
+set_read_fast(1, INFINITE, 108);
+set_read_fast4b(1, INFINITE, 108);
+set_read_fast(1, INFINITE, 112);
+set_read_fast(1, INFINITE, 133);
+set_read_fast4b(1, INFINITE, 133);
+
+set_read_dual(1, INFINITE, 55);
+set_read_dual(1, INFINITE, 64);
+set_read_dual(1, INFINITE, 80);
+set_read_dual4b(1, INFINITE, 80);
+set_read_dual(1, INFINITE, 84);
+set_read_dual(1, INFINITE, 104);
+set_read_dual4b(1, INFINITE, 104);
+set_read_dual(1, INFINITE, 108);
+set_read_dual4b(1, INFINITE, 108);
+set_read_dual(1, INFINITE, 112);
+set_read_dual(1, INFINITE, 133);
+set_read_dual4b(1, INFINITE, 133);
+
+set_read_dual_addr(1, INFINITE, 80);
+set_read_dual_addr4b(1, INFINITE, 80);
+set_read_dual_addr4b(1, INFINITE, 108);
+set_read_dual_addr(2, INFINITE, 84);
+set_read_dual_addr4b(2, INFINITE, 84);
+set_read_dual_addr(2, INFINITE, 108);
+set_read_dual_addr(1, INFINITE, 104);
+set_read_dual_addr4b(1, INFINITE, 104);
+set_read_dual_addr(1, INFINITE, 108);
+set_read_dual_addr(1, INFINITE, 112);
+set_read_dual_addr(1, INFINITE, 133);
+set_read_dual_addr4b(1, INFINITE, 133);
+set_read_dual_addr4b(2, INFINITE, 133);
+
+set_read_quad(1, INFINITE, 80);
+set_read_quad4b(1, INFINITE, 80);
+set_read_quad(1, INFINITE, 84);
+set_read_quad(1, INFINITE, 104);
+set_read_quad4b(1, INFINITE, 104);
+set_read_quad(1, INFINITE, 108);
+set_read_quad4b(1, INFINITE, 108);
+set_read_quad(1, INFINITE, 112);
+set_read_quad(1, INFINITE, 133);
+set_read_quad4b(1, INFINITE, 133);
+
+set_read_quad_addr(3, INFINITE, 80);
+set_read_quad_addr4b(3, INFINITE, 80);
+set_read_quad_addr(5, INFINITE, 84);
+set_read_quad_addr4b(5, INFINITE, 84);
+set_read_quad_addr(5, INFINITE, 108);
+set_read_quad_addr(3, INFINITE, 104);
+set_read_quad_addr4b(3, INFINITE, 104);
+set_read_quad_addr(3, INFINITE, 108);
+set_read_quad_addr4b(3, INFINITE, 108);
+set_read_quad_addr4b(5, INFINITE, 125);
+set_read_quad_addr(3, INFINITE, 112);
+set_read_quad_addr(3, INFINITE, 133);
+set_read_quad_addr(3, INFINITE, 72);
+set_read_quad_addr4b(3, INFINITE, 133);
+
+#ifdef CONFIG_DTR_MODE_SUPPORT
+set_read_quad_dtr(8, INFINITE, 80);
+set_read_quad_dtr4b(10, INFINITE, 100);
+set_read_quad_dtr(10, INFINITE, 100);
+#endif
+/*****************************************************************************/
+set_write_std(0, 256, 33);
+set_write_std(0, 256, 55);
+set_write_std(0, 256, 80);
+set_write_std4b(0, 256, 80);
+set_write_std(0, 256, 86);
+set_write_std(0, 256, 100);
+set_write_std(0, 256, 104);
+set_write_std4b(0, 256, 104);
+set_write_std(0, 256, 108);
+set_write_std(0, 256, 112);
+set_write_std(0, 256, 133);
+set_write_std4b(0, 256, 120);
+set_write_std4b(0, 256, 133);
+
+set_write_dual(0, 256, 75);
+set_write_dual4b(0, 256, 75);
+set_write_dual(0, 256, 108);
+set_write_dual4b(0, 256, 133);
+
+set_write_dual_addr(0, 256, 75);
+set_write_dual_addr4b(0, 256, 75);
+set_write_dual_addr(0, 256, 108);
+set_write_dual_addr4b(0, 256, 133);
+
+set_write_quad(0, 256, 55);
+set_write_quad(0, 256, 80);
+set_write_quad4b(0, 256, 80);
+set_write_quad(0, 256, 104);
+set_write_quad(0, 256, 108);
+set_write_quad(0, 256, 112);
+set_write_quad(0, 256, 133);
+set_write_quad4b(0, 256, 133);
+
+/* As Micron MT25Q(and MIXC) and N25Q have different QUAD I/O write code,
+ * but they have the same ID, so we cannot compatiable it. User can open
+ * by theirselves. */
+set_write_quad_addr(0, 256, 33);
+set_write_quad_addr(0, 256, 80);
+set_write_quad_addr(0, 256, 104);
+set_write_quad_addr4b(0, 256, 104);
+set_write_quad_addr(0, 256, 108);
+set_write_quad_addr4b(0, 256, 108);
+set_write_quad_addr4b(0, 256, 120);
+set_write_quad_addr(0, 256, 133);
+set_write_quad_addr4b(0, 256, 133);
+/*****************************************************************************/
+set_erase_sector_64k(0, _64K, 33);
+set_erase_sector_64k(0, _64K, 55);
+set_erase_sector_64k(0, _64K, 50);
+set_erase_sector_64k(0, _64K, 80);
+set_erase_sector_64k4b(0, _64K, 80);
+set_erase_sector_64k(0, _64K, 86);
+set_erase_sector_64k(0, _64K, 100);
+set_erase_sector_64k(0, _64K, 104);
+set_erase_sector_64k4b(0, _64K, 104);
+set_erase_sector_64k(0, _64K, 108);
+set_erase_sector_64k4b(0, _64K, 108);
+set_erase_sector_64k4b(0, _64K, 120);
+set_erase_sector_64k(0, _64K, 112);
+set_erase_sector_64k(0, _64K, 133);
+set_erase_sector_64k4b(0, _64K, 133);
+
+/*****************************************************************************/
+#include "fmc100_spi_general.c"
+static struct spi_drv spi_driver_general = {
+	.wait_ready = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+	.entry_4addr = spi_general_entry_4addr,
+	.qe_enable = spi_general_qe_enable,
+};
+
+static struct spi_drv spi_driver_no_qe = {
+	.wait_ready = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+	.entry_4addr = spi_general_entry_4addr,
+	.qe_enable = spi_do_not_qe_enable,
+};
+
+#include "fmc100_spi_s25fl256s.c"
+static struct spi_drv spi_driver_s25fl256s = {
+	.wait_ready = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+	.entry_4addr = spi_s25fl256s_entry_4addr,
+	.qe_enable = spi_general_qe_enable,
+};
+
+#include "fmc100_spi_w25q256fv.c"
+static struct spi_drv spi_driver_w25q256fv = {
+	.wait_ready = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+	.entry_4addr = spi_w25q256fv_entry_4addr,
+	.qe_enable = spi_w25q256fv_qe_enable,
+};
+
+#include "fmc100_spi_mx25l25635e.c"
+static struct spi_drv spi_driver_mx25l25635e = {
+	.wait_ready = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+	.entry_4addr = spi_general_entry_4addr,
+	.qe_enable = spi_mx25l25635e_qe_enable,
+#ifdef CONFIG_DTR_MODE_SUPPORT
+	.dtr_set_device =
+	spi_mxic_output_driver_strength_set,
+#endif
+};
+
+static struct spi_drv spi_driver_f25l64q = {
+	.wait_ready = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+	.entry_4addr = spi_general_entry_4addr,
+	.qe_enable = spi_mx25l25635e_qe_enable,
+};
+
+#include "fmc100_spi_gd25qxxx.c"
+static struct spi_drv spi_driver_gd25qxxx = {
+	.wait_ready = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+	.entry_4addr = spi_general_entry_4addr,
+	.qe_enable = spi_gd25qxxx_qe_enable,
+};
+
+#include "fmc100_spi_micron.c"
+static struct spi_drv spi_driver_micron = {
+	.wait_ready = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+	.entry_4addr = spi_micron_entry_4addr,
+	.qe_enable = spi_do_not_qe_enable,
+};
+
+#include "fmc100_spi_xtx.c"
+static struct spi_drv spi_driver_xtx = {
+	.wait_ready = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+	.entry_4addr = spi_general_entry_4addr,
+	.qe_enable = spi_xtx_qe_enable,
+};
+
+#include "fmc100_spi_puya.c"
+static struct spi_drv spi_driver_puya = {
+	.wait_ready = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+	.entry_4addr = spi_puya_entry_4addr,
+	.qe_enable = spi_puya_qe_enable,
+};
+
+
+#include "fmc100_spi_issi.c"
+static struct spi_drv spi_driver_issi = {
+	.wait_ready = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+	.entry_4addr = spi_s25fl256s_entry_4addr,
+	.qe_enable = spi_issi_qe_enable,
+};
+/*****************************************************************************/
+#define SPI_NOR_ID_TBL_VER     "1.0"
+
+/* ****** SPI Nor ID Table ****************************************************
+ * 	Manufacturer     Chip Name           Chipsize    Block   Vol  Operation
+ * 1.0  Macronix/MXIC   MX25L1606E		2M	64K 	3V3
+ *      Macronix/MXIC   MX25V1635F		2M	64K 	3V3
+ *      Macronix/MXIC   MX25L6436F		8M	64K 	3V3
+ *      Macronix/MXIC   MX25R6435F	  8M	64K  1V8/3V3 Add 14chips
+ *      Macronix/MXIC   MX25U6435F		8M	64K 	1V8
+ *      Macronix/MXIC   MX25U12835F		16M	64K     1V8
+ *      Macronix/MXIC   MX25U12832F		16M	64K     1V8
+ *      Macronix/MXIC   MX25F128XXX		16M	64K     3V3
+ *      Macronix/MXIC   MX25U25635F/45G     	32M	64K 	1V8 25645G-DTR
+ *      Macronix/MXIC   MX25L(256/257)      	32M	64K     3V3 25645G-DTR
+ *      Macronix/MXIC   MX25U51245G		64M	64K 	1V8 51245G-DTR
+ *      Macronix/MXIC   MX25L51245G		64M	64K	3V3
+ * 	Macronix/MXIC	MX66U1G45GM		128M	64K	1V8
+ *      Spansion    	S25FL129P1		16M	64K 	3V3
+ *      Spansion    	S25FL256S		32M	64K 	3V3
+ *      Micron      	N25Q064A		8M	64K     3V3
+ *      Micron      	N25QL064A		8M	64K     3V3
+ *      Micron      	N25Q128A11/MT25QU128AB  16M	64K     1V8
+ *      Micron      	N25QL128A		16M	64K     3V3
+ *      Micron      	MT25QU256A		32M	64K     1V8
+ *      Micron      	MT25QL256A		32M	64K     3V3
+ *      Winbond     	W25Q16(B/C)V/S25FL016K  2M	64K     3V3
+ *      Winbond     	W25Q32(B/F)V        	4M	64K     3V3
+ *      Winbond     	W25Q32FW		4M	64K     1V8
+ *      Winbond     	W25Q64FW		8M	64K     1V8
+ *      Winbond     	W25Q64FV(SPI)/W25Q64JV_IQ   8M	64K     3V3
+ *      Winbond     	W25Q128FW		16M	64K     1V8
+ *      Winbond     	W25Q128(B/F)V       	16M	64K     3V3
+ *      Winbond     	W25Q128JV_IM        	16M	64K     3V3 DTR
+ *      Winbond     	W25Q256JWEIQ        	32M	64K     1V8
+ *      Winbond         W25Q256JWFIM        	32M	64K     1V8
+ *      Winbond         W25Q256JV-IQ		32M	64K     3V3
+ *      ESMT/CFEON  	EN25Q32B		4M	64K     3V3
+ *      ESMT/CFEON  	EN25Q64			8M	64K     3V3
+ *      ESMT/CFEON  	EN25Q128		16M	64K     3V3
+ *      ESMT/CFEON  	F25L64QA		8M	64K     3V3
+ *      GD		GD25Q64			8M	64K     3V3
+ *      GD		GD25LQ128		16M	64K     1V8
+ *      GD		GD25Q128		16M	64K     3V3
+ *      GD		GD25LQ64C		8M	64K     1V8
+ *      GD		GD25Q32			4M	64K     3V3
+ *      GD		GD25Q16C		2M	64K     3V3
+ *      Paragon     	PN25F16S		2M	64K     3V3
+ *      Paragon     	PN25F32S		4M	64K     3V3
+ *      XMC		XM25QH64AHIG        	8M	64K 	3V3
+ *      XMC		XM25QH128A		16M	64K 	3V3
+ *      XMC		XM25QH128B		16M	64K 	3V3
+ *	XTX		XT25F128BSSI/HGU	16M	64K	3V3
+ *	XTX		XM25QH64		8M	64K	3V3
+ *      Puya		P25Q128H-SUH-IT		16M	64K	3V3
+ *      FM		FM25Q64-SOB-T-G		8M	64K	3V3
+ *      FM		FM25Q128-SOB-T-G	16M	64K	3V3
+ *      HUAHONG		H25S64			8M	64K	3V3
+ *      HUAHONG		H25S128			16M	64K	3V3
+ *	ISSI		IS25WP512M-RMLA3	64M	64k	1V8
+ *****************************************************************************/
+static struct spi_nor_info fmc_spi_nor_info_table[] = {
+	/* name     id  id_len  chipsize(Bytes) erasesize  */
+	{
+		"MX25L1606E",  {0xc2, 0x20, 0x15}, 3, _2M,    _64K, 3,
+		{
+			/* dummy clock:1 byte, read size:INFINITE bytes,
+			 * clock frq:33MHz */
+			&read_std(0, INFINITE, 33), /* 33MHz */
+			&read_fast(1, INFINITE, 86), /* 86MHz */
+			&read_dual(1, INFINITE, 80), /* 80MHz */
+			0
+		},
+		{
+			/* dummy clock:0 byte, write size:256 bytes,
+			 * clock frq:86MHz */
+			&write_std(0, 256, 86), /* 86MHz */
+			0
+		},
+		{
+			/* dummy clock:0byte, erase size:64K,
+			 * clock frq:86MHz */
+			&erase_sector_64k(0, _64K, 86), /* 86MHz */
+			0
+		},
+		&spi_driver_no_qe,
+	},
+
+	{
+		"MX25L6436F",  {0xc2, 0x20, 0x17}, 3, _8M,    _64K, 3,
+		{
+			&read_std(0, INFINITE, 50), /* 50MHz */
+			&read_fast(1, INFINITE, 133), /* 133MHz */
+			&read_dual(1, INFINITE, 133), /* 133MHz */
+			&read_dual_addr(1, INFINITE, 133), /* 133MHz */
+			&read_quad(1, INFINITE, 133), /* 133MHz */
+			&read_quad_addr(3, INFINITE, 133), /* 133MHz */
+			0
+		},
+
+		{
+			&write_std(0, 256, 133), /* 133MHz */
+			&write_quad_addr(0, 256, 133), /* 133MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 133), /* 133MHz */
+			0
+		},
+		&spi_driver_mx25l25635e,
+	},
+	/* MX25L51245G  3.3V */
+	{
+		"MX25L51245G",  {0xc2, 0x20, 0x1a}, 3, _64M,    _64K, 4,
+		{
+			&read_std4b(0, INFINITE, 66),
+			&read_fast4b(1, INFINITE, 133),
+			&read_dual4b(1, INFINITE, 133),
+			&read_dual_addr4b(1, INFINITE, 133),
+			&read_quad4b(1, INFINITE, 133),
+			&read_quad_addr4b(3, INFINITE, 133),
+			0
+		},
+
+		{
+			&write_std4b(0, 256, 133),
+			&write_quad_addr4b(0, 256, 133),
+			0
+		},
+
+		{
+			&erase_sector_64k4b(0, _64K, 133),
+			0
+		},
+		&spi_driver_mx25l25635e,
+	},
+
+	/* MX25V1635F  3.3V */
+	{
+		"MX25V1635F",  {0xc2, 0x23, 0x15}, 3, _2M,    _64K, 3,
+		{
+			&read_std(0, INFINITE, 33), /* 33MHz */
+			&read_fast(1, INFINITE, 80), /* 80MHz */
+			&read_dual(1, INFINITE, 80), /* 80MHz */
+			&read_dual_addr(1, INFINITE, 80), /* 80MHz */
+			&read_quad(1, INFINITE, 80), /* 80MHz */
+			&read_quad_addr(3, INFINITE, 80), /* 80MHz */
+			0
+		},
+
+		{
+			&write_std(0, 256, 33), /* 33MHz */
+			&write_quad_addr(0, 256, 80), /* 80MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 80), /* 80MHz */
+			0
+		},
+		&spi_driver_mx25l25635e,
+	},
+
+	/* MX25R6435F Wide Voltage Range 1.65~3.6V */
+	{
+		"MX25R6435F", {0xc2, 0x28, 0x17}, 3, _8M, _64K, 3,
+		{
+			&read_std(0, INFINITE, 33), /* 33MHz */
+			&read_fast(1, INFINITE, 80), /* 80MHz */
+			&read_dual(1, INFINITE, 80), /* 80MHz */
+			&read_dual_addr(1, INFINITE, 80), /* 80MHz */
+			&read_quad(1, INFINITE, 80), /* 80MHz */
+			&read_quad_addr(3, INFINITE, 80), /* 80MHz */
+			0
+		},
+
+		{
+			&write_std(0, 256, 33), /* 33MHz */
+			&write_quad_addr(0, 256, 33), /* 33MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 33), /* 33MHz */
+			0
+		},
+		&spi_driver_mx25l25635e,
+	},
+
+	/* MX25U1633F, 1.65-2.0V */
+	{
+		"MX25U1633F", {0xc2, 0x25, 0x35}, 3, _2M, _64K, 3,
+		{
+			&read_std(0, INFINITE, 33), /* 33MHz */
+			&read_fast(1, INFINITE, 80), /* 80MHz */
+			&read_dual(1, INFINITE, 80), /* 80MHz */
+			&read_dual_addr(1, INFINITE, 80), /* 80MHz */
+			&read_quad(1, INFINITE, 80), /* 80MHz */
+			&read_quad_addr(3, INFINITE, 80), /* 80MHz */
+			0
+		},
+
+		{
+			&write_std(0, 256, 33), /* 33MHz */
+			&write_quad_addr(0, 256, 80), /* 80MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 80), /* 80MHz */
+			0
+		},
+		&spi_driver_mx25l25635e,
+	},
+
+	/* MX25U6435F, 1.65-2.0V */
+	{
+		"MX25U6435F", {0xc2, 0x25, 0x37}, 3, _8M, _64K, 3,
+		{
+			&read_std(0, INFINITE, 50), /* 50MHz */
+			&read_fast(1, INFINITE, 108), /* 108MHz */
+			&read_dual(1, INFINITE, 108), /* 108MHz */
+			&read_dual_addr(1, INFINITE, 108), /* 108MHz */
+			&read_quad(1, INFINITE, 108), /* 108MHz */
+			&read_quad_addr(3, INFINITE, 108), /* 108MHz */
+			0
+		},
+
+		{
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_quad_addr(0, 256, 108), /* 108MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 108), /* 108MHz */
+			0
+		},
+		&spi_driver_mx25l25635e,
+	},
+
+	/* MX25U12835F/MX25U12832F, 1.65-2.0V */
+	{
+		"MX25U12835F/MX25U12832F", {0xc2, 0x25, 0x38}, 3, _16M, _64K, 3,
+		{
+			&read_std(0, INFINITE, 55), /* 55MHz */
+			&read_fast(1, INFINITE, 108), /* 108MHz */
+			&read_dual(1, INFINITE, 108), /* 108MHz */
+			&read_dual_addr(1, INFINITE, 108), /* 108MHz */
+			&read_quad(1, INFINITE, 108), /* 108MHz */
+			&read_quad_addr(3, INFINITE, 108), /* 108MHz */
+			0
+		},
+
+		{
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_quad_addr(0, 256, 108), /* 108MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 108), /* 108MHz */
+			0
+		},
+		&spi_driver_mx25l25635e,
+	},
+
+	{
+		"MX25L128XX", {0xc2, 0x20, 0x18}, 3, _16M, _64K, 3,
+		{
+			&read_std(0, INFINITE, 50), /* 50MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_dual_addr(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			&read_quad_addr(3, INFINITE, 104), /* 104MHz */
+#ifdef CONFIG_DTR_MODE_SUPPORT
+			&read_quad_dtr(10, INFINITE, 100 /* 84 */), /* 100MHz */
+#endif
+			0
+		},
+
+		{
+			&write_std(0, 256, 104), /* 104MHz */
+			&write_quad_addr(0, 256, 104), /* 104MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 104), /* 104MHz */
+			0
+		},
+		&spi_driver_mx25l25635e,
+	},
+
+	/* MX25U25635F/MX25U25645G, 1.65-2.0V */
+	{
+		"MX25U25635F/45G", {0xc2, 0x25, 0x39}, 3, _32M, _64K, 4,
+		{
+			&read_std4b(0, INFINITE, 55), /* 55MHz */
+			&read_fast4b(1, INFINITE, 108), /* 108MHz */
+			&read_dual4b(1, INFINITE, 108), /* 108MHz */
+			&read_dual_addr4b(1, INFINITE, 108), /* 108MHz */
+			&read_quad4b(1, INFINITE, 108), /* 108MHz */
+			&read_quad_addr4b(3, INFINITE, 108), /* 108MHz */
+#ifdef CONFIG_DTR_MODE_SUPPORT
+			&read_quad_dtr4b(10, INFINITE, 100), /* 100MHz */
+#endif
+			0
+		},
+
+		{
+			&write_std4b(0, 256, 80), /* 80MHz */
+			&write_quad_addr4b(0, 256, 108), /* 108MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k4b(0, _64K, 108), /* 108MHz */
+			0
+		},
+		&spi_driver_mx25l25635e,
+	},
+
+	/* MX25L25635F/MX25L25645G/MX25L25735F/MX25L25635E, 3.3V */
+	{
+		"MX25L(256/257)XX",
+		{0xc2, 0x20, 0x19}, 3, _32M, _64K, 4,
+		{
+			&read_std4b(0, INFINITE, 50), /* 50MHz */
+			&read_fast4b(1, INFINITE, 80 /* 84 */), /* 80MHz */
+			&read_dual4b(1, INFINITE, 80 /* 84 */), /* 80MHz */
+			&read_dual_addr4b(1, INFINITE, 80 /* 84 */), /* 80MHz */
+			&read_quad4b(1, INFINITE, 80 /* 84 */), /* 80MHz */
+			&read_quad_addr4b(3, INFINITE, 80 /* 84 */), /* 80MHz */
+#ifdef CONFIG_DTR_MODE_SUPPORT
+			&read_quad_dtr4b(10, INFINITE, 100 /* 84 */), /* 100MHz */
+#endif
+			0
+		},
+
+		{
+			&write_std4b(0, 256, 120 /* 133 */), /* 120MHz */
+			&write_quad_addr4b(0, 256, 120 /* 133 */), /* 120MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k4b(0, _64K, 120 /* 133 */), /* 120MHz */
+			0
+		},
+		&spi_driver_mx25l25635e,
+	},
+
+	/* MX25U51245G, 1.65-2.0V */
+	{
+		"MX25U51245G", {0xc2, 0x25, 0x3a}, 3, _64M, _64K, 4,
+		{
+			&read_std4b(0, INFINITE, 66), /* 66MHz */
+			&read_fast4b(1, INFINITE, 104), /* 104MHz */
+			&read_dual4b(1, INFINITE, 104), /* 104MHz */
+			&read_dual_addr4b(1, INFINITE, 104), /* 104MHz */
+			&read_quad4b(1, INFINITE, 104), /* 104MHz */
+			&read_quad_addr4b(3, INFINITE, 104), /* 104MHz */
+#ifdef CONFIG_DTR_MODE_SUPPORT
+			&read_quad_dtr4b(10, INFINITE, 100), /* 100MHz */
+#endif
+			0
+		},
+
+		{
+			&write_std4b(0, 256, 104), /* 104MHz */
+			&write_quad_addr4b(0, 256, 104), /* 104MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k4b(0, _64K, 104), /* 104MHz */
+			0
+		},
+		&spi_driver_mx25l25635e,
+	},
+	/* MX66U1G45GM, 1.65-2.0V */
+	{
+		"MX66U1G45GM", {0xc2, 0x25, 0x3b}, 3, _128M, _64K, 4,
+		{
+			&read_std4b(0, INFINITE, 50),
+			&read_fast4b(1, INFINITE, 133),
+			&read_dual4b(1, INFINITE, 133),
+			&read_dual_addr4b(1, INFINITE, 133),
+			&read_quad4b(1, INFINITE, 133),
+			&read_quad_addr4b(3, INFINITE, 133),
+			0
+		},
+
+		{
+			&write_std4b(0, 256, 133),
+			&write_quad_addr4b(0, 256, 133),
+			0
+		},
+
+		{
+			&erase_sector_64k4b(0, _64K, 133),
+			0
+		},
+		&spi_driver_mx25l25635e,
+	},
+	/* Spansion/Cypress  S25FL129P1 3.3V */
+	{
+		"S25FL129P1",
+		{0x01, 0x20, 0x18, 0x4d, 0x01, 0x80}, 6, (_64K * _256B),  _64K,  3,
+		{
+			&read_std(0, INFINITE, 40), /* 40MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 64), /* 64MHz */
+			&read_dual_addr(1, INFINITE, 80), /* 80MHz */
+			&read_quad(1, INFINITE, 80), /* 80MHz */
+			&read_quad_addr(3, INFINITE, 80), /* 80MHz */
+			0
+		},
+
+		{
+			&write_std(0, 256, 104), /* 104MHz */
+			&write_quad(0, 256, 80), /* 80MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 104), /* 104MHz */
+			0
+		},
+		&spi_driver_general,
+	},
+
+	/* Spansion/Cypress S25FL256S 3.3V */
+	{
+		"S25FL256S", {0x01, 0x02, 0x19, 0x4d, 0x01, 0x80}, 6, _32M,  _64K,  4,
+		{
+			&read_std4b(0, INFINITE, 50),  /* 50MHz */
+			&read_fast4b(1, INFINITE, 133), /* 133MHz */
+			&read_dual4b(1, INFINITE, 104),  /* 104MHz */
+			&read_dual_addr4b(1, INFINITE, 104),  /* 104MHz */
+			&read_quad4b(1, INFINITE, 104),  /* 104MHz */
+			&read_quad_addr4b(3, INFINITE, 104),  /* 104MHz */
+			0
+		},
+
+		{
+			&write_std4b(0, 256, 104),  /* 104MHz */
+			&write_quad4b(0, 256, 80),  /* 80MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k4b(0, _64K, 104),  /* 104MHz */
+			0
+		},
+		&spi_driver_s25fl256s,
+	},
+
+	/* Micron  N25Q064A 1.8V */
+	{
+		"N25Q064A",   {0x20, 0xbb, 0x17}, 3, (_64K * _128B), _64K, 3,
+		{
+			&read_std(0, INFINITE, 54),  /* 54MHz */
+			&read_fast(1, INFINITE, 108), /* 108MHz */
+			&read_dual(1, INFINITE, 108), /* 108MHz */
+			&read_dual_addr(2, INFINITE, 108),
+			&read_quad(1, INFINITE, 108), /* 108MHz */
+			0
+		},
+
+		{
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_dual(0, 256, 108), /* 108MHz */
+			&write_dual_addr(0, 256, 108), /* 108MHz */
+			&write_quad(0, 256, 108), /* 108MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 108), /* 108MHz */
+			0
+		},
+		&spi_driver_general,
+	},
+
+	/* Micron "N25Q128A11/MT25QU128AB" 1.8V */
+	{
+		"(MT)N25Q(U)128A",   {0x20, 0xbb, 0x18}, 3,
+		(_64K * _256B), _64K, 3,
+		{
+			&read_std(0, INFINITE, 54),   /* 54MHz */
+			&read_fast(1, INFINITE, 108), /* 108MHz */
+			&read_dual(1, INFINITE, 108), /* 108MHz */
+			&read_dual_addr(2, INFINITE, 108),  /* 108MHz */
+			&read_quad(1, INFINITE, 108), /* 108MHz */
+			&read_quad_addr(5, INFINITE, 108), /* 108MHz */
+			0
+		},
+
+		{
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_dual(0, 256, 108), /* 108MHz */
+			&write_dual_addr(0, 256, 108), /* 108MHz */
+			&write_quad(0, 256, 108), /* 108MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 108), /* 108MHz */
+			0
+		},
+		&spi_driver_micron,
+	},
+
+	/* Micron  N25QL064A 3.3V */
+	{
+		"N25QL064A",   {0x20, 0xba, 0x17}, 3, (_64K * _128B), _64K, 3,
+		{
+			&read_std(0, INFINITE, 54),     /* 54MHz */
+			&read_fast(1, INFINITE, 80), /* 80MHz */
+			&read_dual(1, INFINITE, 80), /* 80MHz */
+			&read_dual_addr(2, INFINITE, 84), /* 84MHz */
+			&read_quad(1, INFINITE, 80), /* 80MHz */
+			&read_quad_addr(5, INFINITE, 84), /* 84MHz */
+			0
+		},
+
+		{
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_dual(0, 256, 75), /* 75MHz */
+			&write_dual_addr(0, 256, 75), /* 75MHz */
+			&write_quad(0, 256, 80),  /* 80MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 50),   /* 50MHz */
+			0
+		},
+		&spi_driver_micron,
+	},
+
+	/* Micron  MT(N)25QL128A 3.3V */
+	{
+		"N25QL128A",   {0x20, 0xba, 0x18}, 3, (_64K * _256B), _64K, 3,
+		{
+			&read_std(0, INFINITE, 54),   /* 54MHz */
+			&read_fast(1, INFINITE, 108), /* 108MHz */
+			&read_dual(1, INFINITE, 84),   /* 84MHz */
+			&read_dual_addr(2, INFINITE, 84),  /* 84MHz */
+			&read_quad(1, INFINITE, 84), /* 84MHz */
+			&read_quad_addr(5, INFINITE, 84), /* 84MHz */
+			0
+		},
+
+		{
+			&write_std(0, 256, 108), /* 108MHz */
+			&write_dual(0, 256, 108), /* 108MHz */
+			&write_dual_addr(0, 256, 108), /* 108MHz */
+			&write_quad(0, 256, 108), /* 108MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 108), /* 108MHz */
+			0
+		},
+		&spi_driver_micron,
+	},
+
+	/* Micron MT25QL256A 3.3V */
+	{
+		"MT25QL256A", {0x20, 0xba, 0x19, 0x10, 0x44}, 5, (_64K * _512B), _64K, 4,
+		{
+			&read_std4b(0, INFINITE, 54), /* 54MHz */
+			&read_fast4b(1, INFINITE, 133), /* 133MHz */
+			&read_dual4b(1, INFINITE, 133), /* 133MHz */
+			&read_dual_addr4b(2, INFINITE, 133), /* 133MHz */
+			&read_quad4b(1, INFINITE, 133), /* 133MHz */
+			&read_quad_addr4b(5, INFINITE, 125), /* 125MHz */
+			0
+		},
+
+		{
+			&write_std4b(0, 256, 133), /* 133MHz */
+			&write_dual4b(0, 256, 133), /* 133MHz */
+			&write_dual_addr4b(0, 256, 133), /* 133MHz */
+			&write_quad4b(0, 256, 133), /* 133MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k4b(0, _64K, 133), /* 133MHz */
+			0
+		},
+		&spi_driver_micron,
+	},
+
+	/* Micron "MT25QU256A" 1.8V */
+	{
+		"MT25QU256A",   {0x20, 0xbb, 0x19}, 3, (_64K * _512B), _64K, 4,
+		{
+			&read_std4b(0, INFINITE, 54), /* 54MHz */
+			&read_fast4b(1, INFINITE, 80), /* 80MHz */
+			&read_dual4b(1, INFINITE, 80), /* 80MHz */
+			&read_dual_addr4b(2, INFINITE, 84), /* 84MHz */
+			&read_quad4b(1, INFINITE, 80), /* 80MHz */
+			&read_quad_addr4b(5, INFINITE, 84), /* 84MHz */
+			0
+		},
+
+		{
+			&write_std4b(0, 256, 80), /* 80MHz */
+			&write_dual4b(0, 256, 75), /* 75MHz */
+			&write_dual_addr4b(0, 256, 75), /* 75MHz */
+			&write_quad4b(0, 256, 80), /* 80MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k4b(0, _64K, 80), /* 80MHz */
+			0
+		},
+		&spi_driver_micron,
+	},
+
+	/* Winbond -- w25x "blocks" are 64K, "sectors" are 4KiB */
+	{
+		"W25Q16JV-IQ/S25FL016K",
+		{0xef, 0x40, 0x15}, 3, (_64K * _32B), _64K, 3,
+		{
+			&read_std(0, INFINITE, 50), /* 50MHz */
+			&read_fast(1, INFINITE, 80), /* 80MHz */
+			&read_dual(1, INFINITE, 80), /* 80MHz */
+			&read_quad(1, INFINITE, 80), /* 80MHz */
+			0
+		},
+
+		{
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_quad(0, 256, 80), /* 80MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 80), /* 80MHz */
+			0
+		},
+		&spi_driver_general,
+	},
+
+	{
+		"W25Q32(B/F)V", {0xef, 0x40, 0x16}, 3, (_64K * _64B), _64K, 3,
+		{
+			&read_std(0, INFINITE, 50), /* 50MHz */
+			&read_fast(1, INFINITE, 80), /* 80MHz */
+			&read_dual(1, INFINITE, 80), /* 80MHz */
+			&read_quad(1, INFINITE, 80), /* 80MHz */
+			0
+		},
+
+		{
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_quad(0, 256, 80), /* 80MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 80), /* 80MHz */
+			0
+		},
+		&spi_driver_general,
+	},
+
+	/* winbond w25q32fw is 1.8v */
+	{
+		"W25Q32FW",  {0xef, 0x60, 0x16}, 3, _4M,  _64K, 3,
+		{
+			&read_std(0, INFINITE, 50), /* 50MHz */
+			&read_fast(1, INFINITE, 133), /* 133MHz */
+			&read_dual(1, INFINITE, 133), /* 133MHz */
+			&read_quad(1, INFINITE, 133), /* 133MHz */
+			&read_quad_addr(3, INFINITE, 133), /* 133MHz */
+			0
+		},
+
+		{
+			&write_std(0, 256, 133), /* 133MHz */
+			&write_quad(0, 256, 133), /* 133MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 133), /* 133MHz */
+			0
+		},
+		&spi_driver_w25q256fv,
+	},
+
+	{
+		"W25Q64FV(SPI)/W25Q64JV_IQ",  {0xef, 0x40, 0x17}, 3, _8M,   _64K, 3,
+		{
+			&read_std(0, INFINITE, 50), /* 50MHz */
+			&read_fast(1, INFINITE, 80), /* 80MHz */
+			&read_dual(1, INFINITE, 80), /* 80MHz */
+			&read_quad(1, INFINITE, 80), /* 80MHz */
+			0
+		},
+
+		{
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_quad(0, 256, 80), /* 80MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 80), /* 80MHz */
+			0
+		},
+		&spi_driver_general,
+	},
+
+	/* winbond w25q64fw is 1.8v */
+	{
+		"W25Q64FW",  {0xef, 0x60, 0x17}, 3, _8M,   _64K, 3,
+		{
+			&read_std(0, INFINITE, 50), /* 50MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, 80), /* 80MHz */
+			&read_quad_addr(3, INFINITE, 104), /* 104MHz */
+			0
+		},
+
+		{
+			&write_std(0, 256, 104), /* 104MHz */
+			&write_quad(0, 256, 80), /* 80MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 104), /* 104MHz */
+			0
+		},
+		&spi_driver_w25q256fv,
+	},
+
+	/* winbond w25q128fw is 1.8v */
+	{
+		"W25Q128FW",  {0xef, 0x60, 0x18}, 3, _16M,   _64K, 3,
+		{
+			&read_std(0, INFINITE, 50), /* 50MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_dual_addr(1, INFINITE, 80), /* 80MHz */
+			&read_quad(1, INFINITE, 80), /* 80MHz */
+			&read_quad_addr(3, INFINITE, 104), /* 104MHz */
+			0
+		},
+
+		{
+			&write_std(0, 256, 104), /* 104MHz */
+			&write_quad(0, 256, 80), /* 80MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 104), /* 104MHz */
+			0
+		},
+		&spi_driver_w25q256fv,
+	},
+
+	{
+		"W25Q128(B/F)V", {0xEF, 0x40, 0x18}, 3, _16M, _64K, 3,
+		{
+			&read_std(0, INFINITE, 33), /* 33MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, /* 70 */ 80), /* 80MHz */
+			0
+		},
+
+		{
+			&write_std(0, 256, 104), /* 104MHz */
+			&write_quad(0, 256, /* 70 */ 80), /* 80MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 104), /* 104MHz */
+			0
+		},
+		&spi_driver_w25q256fv,
+	},
+
+	/* "W25Q128JV_IM" can support DTR mode 80MHz */
+	{
+		"W25Q128JV_IM", {0xEF, 0x70, 0x18}, 3, _16M, _64K, 3,
+		{
+			&read_std(0, INFINITE, 33), /* 33MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, /* 70 */80), /* 80MHz */
+#ifdef CONFIG_DTR_MODE_SUPPORT
+			&read_quad_dtr(8, INFINITE, 80), /* 80MHz */
+#endif
+			0
+		},
+
+		{
+			&write_std(0, 256, 104), /* 104MHz */
+			&write_quad(0, 256, /* 70 */ 80), /* 80MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 104), /* 104MHz */
+			0
+		},
+		&spi_driver_w25q256fv,
+	},
+
+	/* Winbond W25Q256(F/J)V-IQ */
+	{
+		"W25Q256(F/J)V-IQ", {0xEF, 0x40, 0x19}, 3, _32M, _64K, 4,
+#ifdef CONFIG_AUTOMOTIVE_GRADE
+		{
+			&read_std(0, INFINITE, 50),  /* 50MHz */
+			&read_fast(1, INFINITE, 80), /* 80MHz */
+			&read_dual(1, INFINITE, 80), /* 80MHz */
+			&read_dual_addr(1, INFINITE, 80), /* 80MHz */
+			&read_quad(1, INFINITE, 80), /* 80MHz */
+			&read_quad_addr(3, INFINITE, 80), /* 80MHz */
+			0
+		},
+
+		{
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_quad(0, 256, 80),  /* 80MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 104),  /* 104MHz */
+			0
+		},
+#else
+		{
+			&read_std4b(0, INFINITE, 50),  /* 50MHz */
+			&read_fast4b(1, INFINITE, 80), /* 80MHz */
+			&read_dual4b(1, INFINITE, 80), /* 80MHz */
+			&read_dual_addr4b(1, INFINITE, 80), /* 80MHz */
+			&read_quad4b(1, INFINITE, 80), /* 80MHz */
+			&read_quad_addr4b(3, INFINITE, 80), /* 80MHz */
+			0
+		},
+
+		{
+			&write_std4b(0, 256, 80), /* 80MHz */
+			&write_quad4b(0, 256, 80),  /* 80MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k4b(0, _64K, 104),  /* 104MHz */
+			0
+		},
+#endif
+		&spi_driver_w25q256fv,
+	},
+	/* Winbond W25Q256JW-IQ  1.8V */
+	{
+		"W25Q256JW-IQ", {0xEF, 0x60, 0x19}, 3, _32M, _64K, 4,
+		{
+			&read_std4b(0, INFINITE, 50),
+			&read_fast4b(1, INFINITE, 133),
+			&read_dual4b(1, INFINITE, 133),
+			&read_dual_addr4b(1, INFINITE, 133),
+			&read_quad4b(1, INFINITE, 133),
+			&read_quad_addr4b(3, INFINITE, 133),
+			0
+		},
+
+		{
+			&write_std4b(0, 256, 133),
+			&write_quad4b(0, 256, 133),
+			0
+		},
+
+		{
+			&erase_sector_64k4b(0, _64K, 133),
+			0
+		},
+		&spi_driver_w25q256fv,
+	},
+	/* Winbond W25Q256JWFIM  1.8V */
+	{
+		"W25Q256JWFIM", {0xEF, 0x80, 0x19}, 3, _32M, _64K, 4,
+		{
+			&read_std4b(0, INFINITE, 50),  /* 50MHz */
+			&read_fast4b(1, INFINITE, 133), /* 133MHz */
+			&read_dual4b(1, INFINITE, 133), /* 133MHz */
+			&read_dual_addr4b(1, INFINITE, 133), /* 133MHz */
+			&read_quad4b(1, INFINITE, 133), /* 133MHz */
+			&read_quad_addr4b(3, INFINITE, 133), /* 133MHz */
+			0
+		},
+
+		{
+			&write_std4b(0, 256, 133), /* 133MHz */
+			&write_quad4b(0, 256, 133), /* 133MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k4b(0, _64K, 133), /* 133MHz */
+			0
+		},
+		&spi_driver_w25q256fv,
+	},
+
+	/* ESMT/CFEON */
+	{
+		"EN25Q32B", {0x1c, 0x30, 0x16}, 3, (_64K * _64B),  _64K, 3,
+		{
+			&read_std(0, INFINITE, 50), /* 50MHz */
+			&read_fast(1, INFINITE, 80), /* 80MHz */
+			&read_dual(1, INFINITE, 80), /* 80MHz */
+			&read_dual_addr(1, INFINITE, 80), /* 80MHz */
+			/* &read_quad(3, INFINITE, 80), */
+			0
+		},
+
+		{
+			&write_std(0, 256, 80 /* 104 */), /* 80MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 80 /* 104 */), /* 80MHz */
+			0
+		},
+		&spi_driver_general,
+	},
+
+	{
+		"EN25Q64", {0x1c, 0x30, 0x17}, 3, (_64K * _128B),  _64K, 3,
+		{
+			&read_std(0, INFINITE, 50), /* 50MHz */
+			&read_fast(1, INFINITE, 100), /* 100MHz */
+			&read_dual(1, INFINITE, 80), /* 80MHz */
+			&read_dual_addr(1, INFINITE, 80), /* 80MHz */
+			0
+		},
+
+		{
+			&write_std(0, 256, 80), /* 80MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 104), /* 104MHz */
+			0
+		},
+		&spi_driver_no_qe,
+	},
+
+	/* CFEON EN25QH64A 3.3V */
+	{
+		"EN25QH64A", {0x1c, 0x70, 0x17}, 3, (_64K * _128B),  _64K, 3,
+		{
+			&read_std(0, INFINITE, 50), /* 50MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_dual_addr(1, INFINITE, 104), /* 104MHz */
+#ifndef CONFIG_CLOSE_SPI_8PIN_4IO
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			&read_quad_addr(3, INFINITE, 104), /* 104MHz */
+#endif
+			0
+		},
+
+		{
+			&write_std(0, 256, 80), /* 80MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 104), /* 104MHz */
+			0
+		},
+		&spi_driver_no_qe,
+	},
+
+	/* CFEON EN25QH128A 3.3V */
+	{
+		"EN25QH128A", {0x1c, 0x70, 0x18}, 3, _16M,  _64K, 3,
+		{
+			&read_std(0, INFINITE, 50), /* 50MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_dual_addr(1, INFINITE, 104), /* 104MHz */
+#ifndef CONFIG_CLOSE_SPI_8PIN_4IO
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			&read_quad_addr(3, INFINITE, 104), /* 104MHz */
+#endif
+			0
+		},
+
+		{
+			&write_std(0, 256, 104), /* 104MHz */
+			&write_quad(0, 256, 104), /* 104MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 104), /* 104MHz */
+			0
+		},
+		&spi_driver_no_qe,
+	},
+
+	{
+		"EN25Q128", {0x1c, 0x30, 0x18}, 3, (_64K * _256B),  _64K, 3,
+		{
+			&read_std(0, INFINITE, 50), /* 50MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 80), /* 80MHz */
+			&read_dual_addr(1, INFINITE, 80), /* 80MHz */
+			0
+		},
+
+		{
+			&write_std(0, 256, 104), /* 104MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k(0, _64K, 104), /* 104MHz */
+			0
+		},
+		&spi_driver_no_qe,
+	},
+
+	/* ESMT */
+	{
+		"F25L64QA", {0x8C, 0x41, 0x17}, 3, (_64K * _128B),  _64K, 3,
+		{
+			&read_std(0, INFINITE, 66), /* 66MHz */
+			&read_fast(1, INFINITE, /* 66 */100), /* 100MHz */
+			&read_dual(1, INFINITE, /* 66 */80), /* 80MHz */
+			&read_quad(1, INFINITE, 80), /* 80MHz */
+			0
+		},
+		{
+			&write_std(0, 256, /* 66 */100), /* 100MHz */
+			&write_quad(0, 256, 80), /* 80MHz */
+			0
+		},
+		{
+			&erase_sector_64k(0, _64K, /* 66 */100), /* 100MHz */
+			0
+		},
+		&spi_driver_f25l64q,
+	},
+
+	/* GD GD25LQ128 1.8V */
+	{
+		"GD25LQ128", {0xC8, 0x60, 0x18}, 3, _16M,  _64K, 3,
+		{
+			&read_std(0, INFINITE, 80), /* 80MHz */
+			&read_fast(1, INFINITE, 80), /* 80MHz */
+			&read_dual(1, INFINITE, 80), /* 80MHz */
+			&read_dual_addr(1, INFINITE, 80), /* 80MHz */
+			&read_quad(1, INFINITE, 80), /* 80MHz */
+			&read_quad_addr(3, INFINITE, 80), /* 80MHz */
+			0
+		},
+		{
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_quad(0, 256, 80), /* 80MHz */
+			0
+		},
+		{
+			&erase_sector_64k(0, _64K, 80), /* 80MHz */
+			0
+		},
+		&spi_driver_gd25qxxx,
+	},
+
+	{
+		"GD25Q256", {0xC8, 0x40, 0x19}, 3, _32M,  _64K, 4,
+		{
+			&read_std4b(0, INFINITE, 50), /* 50MHz */
+			&read_fast4b(1, INFINITE, 80), /* 80MHz */
+			&read_dual4b(1, INFINITE, 80), /* 80MHz */
+			&read_dual_addr4b(1, INFINITE, 80), /* 80MHz */
+			&read_quad4b(1, INFINITE, 80), /* 80MHz */
+			&read_quad_addr4b(3, INFINITE, 80), /* 80MHz */
+			0
+		},
+
+		{
+			&write_std4b(0, 256, 80), /* 80MHz */
+			&write_quad4b(0, 256, 80), /* 80MHz */
+			0
+		},
+
+		{
+			&erase_sector_64k4b(0, _64K, 104), /* 104MHz */
+			0
+		},
+		&spi_driver_gd25qxxx,
+	},
+
+	{
+		"GD25Q128/GD25Q127", {0xC8, 0x40, 0x18}, 3, _16M,  _64K, 3,
+		{
+			&read_std(0, INFINITE, 80), /* 80MHz */
+			&read_fast(1, INFINITE, 80), /* 80MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_dual_addr(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			&read_quad_addr(3, INFINITE, 104), /* 104MHz */
+			0
+		},
+		{
+			&write_std(0, 256, 100), /* 100MHz */
+			&write_quad(0, 256, 80), /* 80MHz */
+			0
+		},
+		{
+			&erase_sector_64k(0, _64K, 100), /* 100MHz */
+			0
+		},
+		&spi_driver_gd25qxxx,
+	},
+
+	{
+		"GD25Q64", {0xC8, 0x40, 0x17}, 3, _8M,  _64K, 3,
+		{
+			&read_std(0, INFINITE, 66),  /* 66MHz */
+			&read_quad(1, INFINITE, 80), /* 80MHz */
+			0
+		},
+		{
+			&write_std(0, 256, 100),  /* 100MHz */
+			&write_quad(0, 256, 80),  /* 80MHz */
+			0
+		},
+		{
+			&erase_sector_64k(0, _64K, 100),  /* 100MHz */
+			0
+		},
+		&spi_driver_gd25qxxx,
+	},
+
+	{
+		"GD25Q16C", {0xC8, 0x40, 0x15}, 3, _2M,  _64K, 3,
+		{
+			&read_std(0, INFINITE, 80), /* 80MHz */
+			&read_fast(1, INFINITE, 80), /* 80MHz */
+			&read_dual(1, INFINITE, 80), /* 80MHz */
+			&read_dual_addr(1, INFINITE, 80), /* 80MHz */
+			&read_quad(1, INFINITE, 80), /* 80MHz */
+			&read_quad_addr(3, INFINITE, 80), /* 80MHz */
+			0
+		},
+		{
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_quad(0, 256, 80),  /* 80MHz */
+			0
+		},
+		{
+			&erase_sector_64k(0, _64K, 80), /* 80MHz */
+			0
+		},
+		&spi_driver_gd25qxxx,
+	},
+
+	/* GD GD25LQ16C 1.65~2.1V */
+	{
+		"GD25LQ16C", {0xC8, 0x60, 0x15}, 3, _2M,  _64K, 3,
+		{
+			&read_std(0, INFINITE, 80), /* 80MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_dual_addr(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			&read_quad_addr(3, INFINITE, 104), /* 104MHz */
+			0
+		},
+		{
+			&write_std(0, 256, 104), /* 104MHz */
+			&write_quad(0, 256, 104),  /* 104MHz */
+			0
+		},
+		{
+			&erase_sector_64k(0, _64K, 104), /* 104MHz */
+			0
+		},
+		&spi_driver_gd25qxxx,
+	},
+
+	/* GD GD25LQ64C 1.8V */
+	{
+		"GD25LQ64C", {0xC8, 0x60, 0x17}, 3, _8M,  _64K, 3,
+		{
+			&read_std(0, INFINITE, 80), /* 80MHz */
+			&read_fast(1, INFINITE, 80), /* 80MHz */
+			&read_dual(1, INFINITE, 80), /* 80MHz */
+			&read_dual_addr(1, INFINITE, 80), /* 80MHz */
+			&read_quad(1, INFINITE, 80), /* 80MHz */
+			&read_quad_addr(3, INFINITE, 80), /* 80MHz */
+			0
+		},
+		{
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_quad(0, 256, 80),  /* 80MHz */
+			0
+		},
+		{
+			&erase_sector_64k(0, _64K, 80), /* 80MHz */
+			0
+		},
+		&spi_driver_gd25qxxx,
+	},
+
+	{
+		"GD25Q32", {0xC8, 0x40, 0x16}, 3, _4M,  _64K, 3,
+		{
+			&read_std(0, INFINITE, 66),  /* 66MHz */
+			&read_quad(1, INFINITE, 80), /* 80MHz */
+			0
+		},
+		{
+			&write_std(0, 256, 100),  /* 100MHz */
+			&write_quad(0, 256, 80),  /* 80MHz */
+			0
+		},
+		{
+			&erase_sector_64k(0, _64K, 100),  /* 100MHz */
+			0
+		},
+		&spi_driver_gd25qxxx,
+	},
+
+	/* Paragon 3.3V */
+	{
+		"PN25F16S", {0xe0, 0x40, 0x15}, 3, _2M,  _64K, 3,
+		{
+			&read_std(0, INFINITE, 55), /* 55MHz */
+			&read_fast(1, INFINITE, 108), /* 108MHz */
+			&read_dual(1, INFINITE, 108), /* 108MHz */
+			&read_dual_addr(1, INFINITE, 108), /* 108MHz */
+			0
+		},
+		{
+			&write_std(0, 256, 108),  /* 108MHz */
+			0
+		},
+		{
+			&erase_sector_64k(0, _64K, 108), /* 108MHz */
+			0
+		},
+		&spi_driver_general,
+	},
+
+	{
+		"PN25F32S", {0xe0, 0x40, 0x16}, 3, _4M,  _64K, 3,
+		{
+			&read_std(0, INFINITE, 55), /* 55MHz */
+			&read_fast(1, INFINITE, 108), /* 108MHz */
+			&read_dual(1, INFINITE, 108), /* 108MHz */
+			&read_dual_addr(1, INFINITE, 108), /* 108MHz */
+			&read_quad(1, INFINITE, 108), /* 108MHz */
+			&read_quad_addr(3, INFINITE, 108), /* 108MHz */
+			0
+		},
+		{
+			&write_std(0, 256, 108),  /* 108MHz */
+			0
+		},
+		{
+			&erase_sector_64k(0, _64K, 108), /* 108MHz */
+			0
+		},
+		&spi_driver_general,
+	},
+
+	/* XMC */
+	{
+		"XM25QH64AHIG", {0x20, 0x70, 0x17}, 3, _8M,  _64K, 3,
+		{
+			&read_std(0, INFINITE, 80), /* 80MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_dual_addr(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			&read_quad_addr(3, INFINITE, 104), /* 104MHz */
+			0
+		},
+		{
+			&write_std(0, 256, 104), /* 104MHz */
+			&write_quad(0, 256, 104),  /* 104MHz */
+			0
+		},
+		{
+			&erase_sector_64k(0, _64K, 104), /* 104MHz */
+			0
+		},
+		&spi_driver_no_qe,
+	},
+
+	/* XMC 3.3v */
+	{
+		"XM25QH128A", {0x20, 0x70, 0x18}, 3, _16M,  _64K, 3,
+		{
+			&read_std(0, INFINITE, 80), /* 80MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_dual_addr(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			&read_quad_addr(3, INFINITE, 104), /* 104MHz */
+			0
+		},
+		{
+			&write_std(0, 256, 104), /* 104MHz */
+			&write_quad(0, 256, 104),  /* 104MHz */
+			0
+		},
+		{
+			&erase_sector_64k(0, _64K, 104), /* 104MHz */
+			0
+		},
+		&spi_driver_no_qe,
+	},
+
+	/* XMC */
+	{
+		"XM25QH64B", {0x20, 0x60, 0x17}, 3, _8M,  _64K, 3,
+		{
+			&read_std(0, INFINITE, 80), /* 80MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_dual_addr(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			&read_quad_addr(3, INFINITE, 104), /* 104MHz */
+			0
+		},
+		{
+			&write_std(0, 256, 104), /* 104MHz */
+			&write_quad(0, 256, 104),  /* 104MHz */
+			0
+		},
+		{
+			&erase_sector_64k(0, _64K, 104), /* 104MHz */
+			0
+		},
+		&spi_driver_no_qe,
+	},
+
+	/* XMC 3.3v */
+	{
+		"XM25QH128B", {0x20, 0x60, 0x18}, 3, _16M,  _64K, 3,
+		{
+			&read_std(0, INFINITE, 50), /* 50MHz */
+			&read_fast(1, INFINITE, 104), /* 104MHz */
+			&read_dual(1, INFINITE, 104), /* 104MHz */
+			&read_dual_addr(1, INFINITE, 104), /* 104MHz */
+			&read_quad(1, INFINITE, 104), /* 104MHz */
+			&read_quad_addr(3, INFINITE, 104), /* 104MHz */
+			0
+		},
+		{
+			&write_std(0, 256, 104), /* 104MHz */
+			&write_quad(0, 256, 104),  /* 104MHz */
+			0
+		},
+		{
+			&erase_sector_64k(0, _64K, 104), /* 104MHz */
+			0
+		},
+		&spi_driver_no_qe,
+	},
+
+	/* XTX 3.3v */
+	{
+		"XT25F128BSSI/HGU", {0x0B, 0x40, 0x18}, 3, _16M,  _64K, 3,
+		{
+			&read_std(0, INFINITE, 80), /* 80MHz */
+			&read_dual(1, INFINITE, 108), /* 108MHz */
+			&read_dual_addr(1, INFINITE, 108), /* 108MHz */
+			&read_quad(1, INFINITE, 108), /* 108MHz */
+			&read_quad_addr(3, INFINITE, 72),  /* 72MHz */
+			0
+		},
+		{
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_quad(0, 256, 80),  /* 80MHz */
+			0
+		},
+		{
+			&erase_sector_64k(0, _64K, 80), /* 80MHz */
+			0
+		},
+		&spi_driver_xtx,
+	},
+
+	{
+		"XT25F64BSSI/HGU-S", {0x0B, 0x40, 0x17}, 3, _8M,  _64K, 3,
+		{
+			&read_std(0, INFINITE, 80), /* 80MHz */
+			&read_dual(1, INFINITE, 108), /* 108MHz */
+			&read_dual_addr(1, INFINITE, 108), /* 108MHz */
+			&read_quad(1, INFINITE, 84),  /* 84MHz */
+			&read_quad_addr(3, INFINITE, 72),  /* 72MHz */
+			0
+		},
+		{
+			&write_std(0, 256, 80), /* 80MHz */
+			&write_quad(0, 256, 80),  /* 80MHz */
+			0
+		},
+		{
+			&erase_sector_64k(0, _64K, 80), /* 80MHz */
+			0
+		},
+		&spi_driver_xtx,
+	},
+
+	/* Puya Semiconductor 3.3V */
+	{
+		"P25Q128H", {0x85, 0x60, 0x18}, 3, _16M,  _64K, 3,
+		{
+			&read_std(0, INFINITE, 80),
+			&read_fast(1, INFINITE, 104),
+			&read_dual(1, INFINITE, 104),
+			&read_dual_addr(1, INFINITE, 104),
+			&read_quad(1, INFINITE, 104),
+			&read_quad_addr(3, INFINITE, 104),
+			0
+		},
+		{
+			&write_std(0, 256, 104),
+			&write_quad(0, 256, 104),
+			0
+		},
+		{
+			&erase_sector_64k(0, _64K, 104),
+			0
+		},
+		&spi_driver_puya,
+	},
+
+	/* FM 3.3V */
+	{
+		"FM25Q64-SOB-T-G", {0xa1, 0x40, 0x17}, 3, _8M,  _64K, 3,
+		{
+			&read_std(0, INFINITE, 66),
+			&read_fast(1, INFINITE, 104),
+			&read_dual(1, INFINITE, 104),
+			&read_dual_addr(1, INFINITE, 104),
+			&read_quad(1, INFINITE, 104),
+			&read_quad_addr(3, INFINITE, 104),
+			0
+		},
+		{
+			&write_std(0, 256, 104),
+			&write_quad(0, 256, 104),
+			0
+		},
+		{
+			&erase_sector_64k(0, _64K, 104),
+			0
+		},
+		&spi_driver_general,
+	},
+
+	/* FM 3.3V */
+	{
+		"FM25Q128A-SOB-T-G", {0xa1, 0x40, 0x18}, 3, _16M,  _64K, 3,
+		{
+			&read_std(0, INFINITE, 50),
+			&read_fast(1, INFINITE, 104),
+			&read_dual(1, INFINITE, 104),
+			&read_dual_addr(1, INFINITE, 104),
+			&read_quad(1, INFINITE, 104),
+			&read_quad_addr(3, INFINITE, 104),
+			0
+		},
+		{
+			&write_std(0, 256, 104),
+			&write_quad(0, 256, 104),
+			0
+		},
+		{
+			&erase_sector_64k(0, _64K, 104),
+			0
+		},
+		&spi_driver_general,
+	},
+
+	/* HUAHONG 3.3V */
+	{
+		"H25S64", {0x68, 0x40, 0x17}, 3, _8M,  _64K, 3,
+		{
+			&read_std(0, INFINITE, 55),
+			&read_fast(1, INFINITE, 55),
+			&read_dual(1, INFINITE, 55),
+			&read_dual_addr(1, INFINITE, 108),
+			&read_quad(1, INFINITE, 108),
+			&read_quad_addr(3, INFINITE, 108),
+			0
+		},
+		{
+			&write_std(0, 256, 55),
+			&write_quad(0, 256, 55),
+			0
+		},
+		{
+			&erase_sector_64k(0, _64K, 55),
+			0
+		},
+		&spi_driver_w25q256fv,
+	},
+
+	{
+		"H25S128", {0x68, 0x40, 0x18}, 3, _16M,  _64K, 3,
+		{
+			&read_std(0, INFINITE, 55),
+			&read_fast(1, INFINITE, 55),
+			&read_dual(1, INFINITE, 55),
+			&read_dual_addr(1, INFINITE, 108),
+			&read_quad(1, INFINITE, 108),
+			&read_quad_addr(3, INFINITE, 108),
+			0
+		},
+		{
+			&write_std(0, 256, 55),
+			&write_quad(0, 256, 55),
+			0
+		},
+		{
+			&erase_sector_64k(0, _64K, 55),
+			0
+		},
+		&spi_driver_w25q256fv,
+	},
+
+	/* ISSI 1V8 */
+	{
+		"IS25WP512M-RMLA3", {0x9d, 0x70, 0x1a}, 3, _64M,  _64K, 4,
+		{
+			&read_std(0, INFINITE, 50),
+			&read_fast(1, INFINITE, 112),
+			&read_dual(1, INFINITE, 112),
+			&read_dual_addr(1, INFINITE, 112),
+			&read_quad(1, INFINITE, 112),
+			&read_quad_addr(3, INFINITE, 112),
+			0
+		},
+		{
+			&write_std(0, 256, 112),
+			&write_quad(0, 256, 112),
+			0
+		},
+		{
+			&erase_sector_64k(0, _64K, 112),
+			0
+		},
+		&spi_driver_issi,
+	},
+
+	/* ZB 3.3V */
+	{
+		"ZB25VQ64A", {0x5e, 0x40, 0x17}, 3, _8M,  _64K, 3,
+		{
+			&read_std(0, INFINITE, 45),
+			&read_fast(1, INFINITE, 104),
+			&read_dual(1, INFINITE, 104),
+			&read_dual_addr(1, INFINITE, 104),
+			&read_quad(1, INFINITE, 104),
+			&read_quad_addr(3, INFINITE, 104),
+			0
+		},
+		{
+			&write_std(0, 256, 104),
+			&write_quad(0, 256, 104),
+			0
+		},
+		{
+			&erase_sector_64k(0, _64K, 104),
+			0
+		},
+		&spi_driver_general,
+	},
+
+	{0, {0}, 0, 0, 0, 0, {0}, {0}, {0}, NULL},
+};
+
+/*****************************************************************************/
+static struct spi_nor_info *fmc_spi_nor_serach_ids(u_char ids[], int len)
+{
+	struct spi_nor_info *info = fmc_spi_nor_info_table;
+	struct spi_nor_info *fit_info = NULL;
+
+	if (len <= 0)
+		return NULL;
+
+	for (; info->name; info++) {
+		if (memcmp(info->id, ids, info->id_len))
+			continue;
+
+		if ((fit_info == NULL) || (fit_info->id_len < info->id_len))
+			fit_info = info;
+	}
+	return fit_info;
+}
+
+/*****************************************************************************/
+static void fmc_spi_nor_search_rw(struct spi_nor_info *info,
+				struct spi_op *spiop_rw,
+				u_int iftype,
+				u_int max_dummy,
+				int rw_type)
+{
+	int ix = 0;
+	struct spi_op **spiop, **fitspiop;
+
+	for (fitspiop = spiop = (rw_type ? info->write : info->read);
+	     (*spiop) && ix < MAX_SPI_OP; spiop++, ix++)
+		if (((*spiop)->iftype & iftype) &&
+			((*spiop)->dummy <= max_dummy) &&
+			((*fitspiop)->iftype < (*spiop)->iftype))
+			fitspiop = spiop;
+
+	memcpy(spiop_rw, (*fitspiop), sizeof(struct spi_op));
+}
+
+/*****************************************************************************/
+static void fmc_map_iftype_and_clock(struct fmc_spi *spi)
+{
+	int ix;
+	const int iftype_read[] = {
+		SPI_IF_READ_STD,    IF_TYPE_STD,
+		SPI_IF_READ_FAST,   IF_TYPE_STD,
+		SPI_IF_READ_DUAL,   IF_TYPE_DUAL,
+		SPI_IF_READ_DUAL_ADDR,  IF_TYPE_DIO,
+		SPI_IF_READ_QUAD,   IF_TYPE_QUAD,
+		SPI_IF_READ_QUAD_ADDR,  IF_TYPE_QIO,
+#ifdef CONFIG_DTR_MODE_SUPPORT
+		SPI_IF_READ_QUAD_DTR,   IF_TYPE_DTR,
+#endif
+		0,          0,
+	};
+	const int iftype_write[] = {
+		SPI_IF_WRITE_STD,   IF_TYPE_STD,
+		SPI_IF_WRITE_DUAL,  IF_TYPE_DUAL,
+		SPI_IF_WRITE_DUAL_ADDR, IF_TYPE_DIO,
+		SPI_IF_WRITE_QUAD,  IF_TYPE_QUAD,
+		SPI_IF_WRITE_QUAD_ADDR, IF_TYPE_QIO,
+		0,          0,
+	};
+
+	/* Only an even number of values is required,so increase length is 2 */
+	for (ix = 0; iftype_write[ix]; ix += 2) {
+		if (spi->write->iftype == iftype_write[ix]) {
+			spi->write->iftype = iftype_write[ix + 1];
+			break;
+		}
+	}
+	fmc_get_fmc_best_2x_clock(&spi->write->clock);
+
+	/* Only an even number of values is required,so increase length is 2 */
+	for (ix = 0; iftype_read[ix]; ix += 2) {
+		if (spi->read->iftype == iftype_read[ix]) {
+			spi->read->iftype = iftype_read[ix + 1];
+			break;
+		}
+	}
+#ifdef CONFIG_DTR_MODE_SUPPORT
+	if (spi->dtr_mode_support)
+		/* get the div4 clock */
+		fmc_get_fmc_best_4x_clock(&spi->read->clock);
+	else
+		fmc_get_fmc_best_2x_clock(&spi->read->clock);
+#else
+	fmc_get_fmc_best_2x_clock(&spi->read->clock);
+#endif
+
+	fmc_get_fmc_best_2x_clock(&spi->erase->clock);
+	spi->erase->iftype = IF_TYPE_STD;
+}
+
+/*****************************************************************************/
+void fmc_spi_nor_get_erase(struct spi_nor_info *info,
+				struct spi_op *spiop_erase)
+{
+	int ix;
+
+	spiop_erase->size = 0;
+	for (ix = 0; ix < MAX_SPI_OP; ix++) {
+		if (info->erase[ix] == NULL)
+			break;
+		if (info->erasesize == info->erase[ix]->size) {
+			memcpy(&spiop_erase[ix], info->erase[ix],
+			       sizeof(struct spi_op));
+			break;
+		}
+	}
+}
+
+/*****************************************************************************/
+static void switch_to_4byte(struct fmc_spi *spi, u_char *ids, int len)
+{
+	unsigned char manu_id = 0;
+	/* auto check fmc_addr_mode 3 bytes or 4 bytes */
+	unsigned int start_up_addr_mode = get_fmc_boot_mode();
+
+	if(len < 3){
+		return;
+	}
+
+	manu_id = ids[0];
+	if ((spi->addrcycle == SPI_NOR_3BYTE_ADDR_LEN)
+			&& (start_up_addr_mode == SPI_NOR_ADDR_MODE_4_BYTES))
+		printf("\nError!!! the flash's addres len is 3bytes and start \
+			up address mode is 4bytes,please set the start up \
+				address mode to 3bytes mode");
+	if ((spi->addrcycle == SPI_NOR_4BYTE_ADDR_LEN)
+			&& (start_up_addr_mode == SPI_NOR_ADDR_MODE_3_BYTES)) {
+		switch (manu_id) {
+		case MID_WINBOND:
+#ifdef CONFIG_AUTOMOTIVE_GRADE
+			if((ids[1] == 0x40) && (ids[2] == 0x19)) { /* W25Q256FV/W25Q256JV */
+				spi->driver->entry_4addr(spi, ENABLE);
+				break;
+			}
+#endif
+		case MID_MXIC:
+		case MID_MICRON:
+			fmc_pr(BT_DBG, "\t|||-4-Byte Command Operation\n");
+			break;
+		default:
+				fmc_pr(BT_DBG, "\t|||-start up: 3-Byte mode\n");
+				spi->driver->entry_4addr(spi, ENABLE);
+			break;
+		}
+	} else {
+		fmc_pr(BT_DBG, "\t|||-start up: 4-Byte mode or 4-Byte Command\n");
+	}
+}
+
+/*****************************************************************************/
+static void spi_data_init(struct fmc_spi *spi, struct spi_nor_info *spiinfo,
+				unsigned char cs)
+{
+	spi->name = spiinfo->name;
+	spi->chipselect = cs;
+	spi->chipsize = spiinfo->chipsize;
+	spi->erasesize = spiinfo->erasesize;
+	spi->addrcycle = spiinfo->addrcycle;
+	spi->driver = spiinfo->driver;
+}
+/*****************************************************************************/
+static void mtd_data_set(struct mtd_info_ex *mtd, struct spi_nor_info *spiinfo,
+				struct fmc_spi *spi)
+{
+	if (mtd->type == 0) {
+		mtd->type = MTD_NORFLASH;
+		mtd->chipsize = spi->chipsize;
+		mtd->erasesize = spi->erasesize;
+		mtd->pagesize = 1;
+		mtd->addrcycle = spi->addrcycle;
+
+		if (spiinfo->id_len > sizeof(mtd->ids)) {
+			printf("BUG! ID len out of range.\n");
+			BUG();
+		}
+
+		mtd->id_length = spiinfo->id_len;
+		memcpy(mtd->ids, spiinfo->id, spiinfo->id_len);
+		strncpy(mtd->name, spi->name,
+				sizeof(mtd->name));
+		mtd->name[sizeof(mtd->name) - 1] = '\0';
+	}
+}
+/*****************************************************************************/
+static void fmc_init_print(struct fmc_spi *spi)
+{
+	const char *str[] = {"STD", "DUAL", "DIO", "QUAD", "QIO"};
+
+#ifndef CONFIG_MINI_BOOT
+	printf("Block:%sB ", ulltostr(spi->erasesize));
+	printf("Chip:%sB ", ulltostr(spi->chipsize));
+	printf("Name:\"%s\"\n", spi->name);
+#endif
+	fmc_pr(BT_DBG, "\t|||-Read if: %s, cmd: %#X, clock reg: %#x\n",
+			str[spi->read->iftype],
+			spi->read->cmd, spi->read->clock);
+	fmc_pr(BT_DBG, "\t|||-Write if: %s, cmd: %#X, clock reg: %#x\n",
+			str[spi->write->iftype],
+			spi->write->cmd, spi->write->clock);
+	fmc_pr(BT_DBG, "\t|||-Erase if: %s, cmd: %#X, clock reg: %#x\n",
+			str[spi->erase[0].iftype],
+			spi->erase[0].cmd, spi->erase[0].clock);
+}
+/*****************************************************************************/
+static void fmc_spi_map_op(struct spi_nor_info *spiinfo, struct fmc_spi *spi)
+{
+#ifdef CONFIG_DTR_MODE_SUPPORT
+	if (spi->dtr_mode_support) {
+		/* to match the best dummy/if_type/clock */
+		fmc_spi_nor_search_rw(spiinfo, spi->read,
+				FMC_SPI_NOR_SUPPORT_READ,
+				FMC_SPI_NOR_DTR_MAX_DUMMY, RW_OP_READ);
+	} else {
+		fmc_spi_nor_search_rw(spiinfo, spi->read,
+				FMC_SPI_NOR_SUPPORT_READ,
+				FMC_SPI_NOR_STR_MAX_DUMMY, RW_OP_READ);
+	}
+#else
+	/* to match the best dummy/if_type/clock */
+	fmc_spi_nor_search_rw(spiinfo, spi->read,
+			FMC_SPI_NOR_SUPPORT_READ,
+			FMC_SPI_NOR_STR_MAX_DUMMY, RW_OP_READ);
+#endif
+	fmc_spi_nor_search_rw(spiinfo, spi->write,
+			FMC_SPI_NOR_SUPPORT_WRITE,
+			FMC_SPI_NOR_STR_MAX_DUMMY, RW_OP_WRITE);
+
+	fmc_spi_nor_get_erase(spiinfo, spi->erase);
+	fmc_map_iftype_and_clock(spi);
+}
+/*****************************************************************************/
+int fmc_spi_nor_probe(struct mtd_info_ex *mtd, struct fmc_spi *spi)
+{
+	unsigned char cs = 0;
+	unsigned char ids[MAX_SPI_NOR_ID_LEN] = {0};
+	unsigned char  ix = 0;
+	unsigned char len = 0;
+	unsigned int total = 0;
+	char buffer[TMP_BUF_LEN];
+	unsigned char *fmc_cs = NULL;
+
+	mtd->numchips = 0;
+
+#ifndef CONFIG_MINI_BOOT
+	printf("SPI Nor ID Table Version %s\n", SPI_NOR_ID_TBL_VER);
+#endif
+
+	for (cs = 0; cs < CONFIG_SPI_NOR_MAX_CHIP_NUM; cs++) {
+		fmc_cs = get_cs_number(cs);
+		if (*fmc_cs) {
+			fmc_pr(BT_DBG, "\t|||-CS(%d) is occupied\n", cs);
+			continue;
+		}
+
+		fmc100_read_ids(spi, cs, ids);
+
+		/* can't find spi flash device, for id 0-2 */
+		if (!(ids[0] | ids[1] | ids[2]) ||
+				((ids[0] & ids[1] & ids[2]) == 0xFF)) /* id 0-2 */
+			continue;
+
+		len = sprintf(buffer, "SPI Nor(cs %d) ID: %#x %#x %#x", cs,
+				ids[0], ids[1], ids[2]); /* id 0-2 */
+
+		spiinfo = fmc_spi_nor_serach_ids(ids, MAX_SPI_NOR_ID_LEN);
+		/* id 3-7th */
+		for (ix = 3; (spiinfo) && (ix < spiinfo->id_len); ix++)
+			len += sprintf(buffer + len, " %#x", ids[ix]);
+
+		if (spiinfo) {
+#ifndef CONFIG_MINI_BOOT
+			printf("%s\n", buffer);
+#endif
+
+			fmc_pr(BT_DBG, "\t|||-CS-%d found SPI nor flash: %s\n",
+			       cs, spiinfo->name);
+
+			spi_data_init(spi, spiinfo, cs);
+
+#ifdef CONFIG_DTR_MODE_SUPPORT
+			/* to check weather current device support DTR mode */
+			fmc_check_spi_dtr_support(spi, ids, MAX_SPI_NOR_ID_LEN);
+#endif
+			fmc_spi_map_op(spiinfo, spi);
+
+			spi->driver->qe_enable(spi);
+
+			switch_to_4byte(spi, ids, MAX_SPI_NOR_ID_LEN);
+
+			fmc_init_print(spi);
+			mtd_data_set(mtd, spiinfo, spi);
+
+			mtd->numchips++;
+			total += spi->chipsize;
+			spi++;
+			(*fmc_cs)++;
+		} else {
+			printf("SPI Nor(cs %d) ID: %#x %#x %#x can't find"
+			 " in the ID table !!!\n", cs, ids[0], ids[1], ids[2]);
+		}
+	}
+
+	fmc_pr(BT_DBG, "\t||*-End probe SPI nor flash, num: %d\n",
+			mtd->numchips);
+
+	return mtd->numchips;
+}
+
+/*****************************************************************************/
+#ifdef CONFIG_DTR_MODE_SUPPORT
+void spi_dtr_to_sdr_switch(struct fmc_spi *spi)
+{
+	unsigned int ix = 0;
+	unsigned int spi_dtr_dummy;
+	struct spi_op **spiop, **fitspiop;
+	const int iftype_read[] = {
+		SPI_IF_READ_QUAD,   IF_TYPE_QUAD,
+		SPI_IF_READ_QUAD_ADDR,  IF_TYPE_QIO,
+		0,          0,
+	};
+
+	/* the dummy in SDR mode is impossible equal to DTR */
+	spi_dtr_dummy = spi->read->dummy;
+
+	/* match the best clock and dummy value agian */
+	for (fitspiop = spiop = spiinfo->read;
+	     (*spiop) && ix < MAX_SPI_OP; spiop++, ix++)
+		if (((*spiop)->iftype & FMC_SPI_NOR_SUPPORT_READ) &&
+		((*spiop)->dummy != spi_dtr_dummy) &&
+		((*fitspiop)->iftype < (*spiop)->iftype))
+			fitspiop = spiop;
+
+	memcpy(spi->read, (*fitspiop), sizeof(struct spi_op));
+
+	/* to map the iftype and clock of SDR mode */
+	/* Only an even number of values is required,so increase length is 2 */
+	for (ix = 0; iftype_read[ix]; ix += 2) {
+		if (spi->read->iftype == iftype_read[ix]) {
+			spi->read->iftype = iftype_read[ix + 1];
+			break;
+		}
+	}
+	fmc_get_fmc_best_2x_clock(&spi->read->clock);
+}
+#endif /* CONFIG_DTR_MODE_SUPPORT */
diff -uraN u-boot-2016.11/drivers/mtd/spi/fmc100/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/Makefile
--- u-boot-2016.11/drivers/mtd/spi/fmc100/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/fmc100/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1 @@
+obj-y += fmc100.o fmc100_os.o fmc_spi_nor_ids.o
diff -uraN u-boot-2016.11/drivers/mtd/spi/Kconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/Kconfig
--- u-boot-2016.11/drivers/mtd/spi/Kconfig	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/Kconfig	2021-06-07 13:01:32.000000000 +0300
@@ -128,6 +128,35 @@
 
 	  If unsure, say N
 
+config FMC_SPI_NOR
+	bool "Goke SPI Nor Flash Interface support"
+	depends on FMC
+	help
+	  Enable the Goke SPI Nor flash support.
+
+	  If unsure, say N
+
+config SPI_BLOCK_PROTECT
+    bool "Spi Nor Device BP(Block Protect) Support"
+	depends on FMC_SPI_NOR
+    help
+      SFC supports BP(Block Protect) feature to preestablish a series
+      area to avoid writing and erasing, except to reading. With this macro
+      definition we can get the BP info which was setted before. The
+      BOTTOM/TOP bit is setted to BOTTOM, it means the lock area starts
+      from 0 address.
+
+	  If unsure, say N
+
+config DTR_MODE_SUPPORT
+    bool "Spi Nor Device DTR mode Support"
+	depends on FMC_SPI_NOR
+	default n
+    help
+	  To support DTR mode
+
+	  If unsure, say N
+
 if SPL
 
 config SPL_SPI_SUNXI
diff -uraN u-boot-2016.11/drivers/mtd/spi/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/Makefile
--- u-boot-2016.11/drivers/mtd/spi/Makefile	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -5,6 +5,9 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
+obj-y = spi_nor.o
+obj-$(CONFIG_FMC_SPI_NOR) += fmc100/
+
 obj-$(CONFIG_DM_SPI_FLASH) += sf-uclass.o
 
 ifdef CONFIG_SPL_BUILD
diff -uraN u-boot-2016.11/drivers/mtd/spi/spi.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/spi.h
--- u-boot-2016.11/drivers/mtd/spi/spi.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/spi.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,15 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+ 
+#ifndef __FMC100_SPI_H__
+#define __FMC100_SPI_H__
+
+#include <spi_flash.h>
+#include <linux/mtd/mtd.h>
+
+struct spi_flash *fmc100_spi_nor_probe(struct mtd_info_ex **);
+struct mtd_info_ex *fmc100_get_spi_nor_info(struct spi_flash *);
+
+#endif
+
diff -uraN u-boot-2016.11/drivers/mtd/spi/spi_nor.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/spi_nor.c
--- u-boot-2016.11/drivers/mtd/spi/spi_nor.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/mtd/spi/spi_nor.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <asm/io.h>
+#include <spi_flash.h>
+#include <errno.h>
+#include <linux/mtd/mtd.h>
+#include "spi.h"
+
+
+/*****************************************************************************/
+static struct spi_flash *spiflash;
+static struct mtd_info_ex *spiinfo_ex;
+/*****************************************************************************/
+
+struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
+				unsigned int max_hz, unsigned int spi_mode)
+{
+	if (get_boot_media() != BOOT_MEDIA_SPIFLASH) {
+		puts("Boot Media isn't SPI Nor\n");
+		return NULL;
+	}
+
+	if (spiflash)
+		return spiflash;
+
+#ifdef CONFIG_FMC_SPI_NOR
+	spiflash = fmc100_spi_nor_probe(&spiinfo_ex);
+	spiflash->erase_size = spiinfo_ex->erasesize;
+#endif
+
+	return spiflash;
+}
+/*****************************************************************************/
+
+struct mtd_info_ex *get_spiflash_info(void)
+{
+	if (spiinfo_ex)
+		return spiinfo_ex;
+
+#ifdef CONFIG_FMC_SPI_NOR
+	spiinfo_ex = fmc100_get_spi_nor_info(spiflash);
+#endif
+
+	return spiinfo_ex;
+}
+/*****************************************************************************/
+
+void spi_flash_free(struct spi_flash *flash)
+{
+}
+/*****************************************************************************/
+
+#ifdef CONFIG_SPI_BLOCK_PROTECT
+void spi_flash_lock(unsigned char cmp, unsigned char level, unsigned char op)
+{
+	cmp = BP_CMP_BOTTOM;
+
+	if (spiflash->lock)
+		spiflash->lock(cmp, level, op);
+
+	return;
+}
+/*****************************************************************************/
+#endif /* CONFIG_SPI_BLOCK_PROTECT */
+
diff -uraN u-boot-2016.11/drivers/net/femac/bspeth.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/bspeth.h
--- u-boot-2016.11/drivers/net/femac/bspeth.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/bspeth.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,139 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __BSPETH_H__
+#define __BSPETH_H__
+
+#include <config.h>
+#include <common.h>
+#include <command.h>
+
+#include <linux/list.h>
+#include <asm/io.h>
+
+#include <malloc.h> /* malloc, free, realloc */
+
+#include <net.h>
+#include <miiphy.h>
+#include <asm/arch/platform.h>
+
+#define OSDRV_MODULE_VERSION_STRING "Vendor ETH net controler"
+
+#ifndef bit
+#define bit(nr) (1UL << (nr))
+#endif
+#define mdelay(n) udelay((n)*1000)
+/* ***********************************************************
+ *
+ * Global varibles and defintions
+ *
+ * ***********************************************************
+ */
+
+/* configuerable values */
+
+#ifdef BSPETH_RX_QUEUE_MULTI_DESC
+#define BSPETH_HW_DESC_DEPTH 72
+#endif
+
+#define ETH_MDIO_FRQDIV 2
+
+/* mdiobus device name, such as platform device name */
+#define BSPETH_MDIOBUS_NAME "bspeth_mdiobus"
+
+/* eth device name, such as platform device name */
+#define BSPETH_FEMAC_NAME     "gk_femac"
+#define MAX_PHY_NAME_LEN      16
+#define BSPETH_MAX_QUEUE_DEPTH 64
+#ifdef BSPETH_RX_QUEUE_MULTI_DESC
+#define BSPETH_HW_RXQ_DEPTH 52 /* uboot */
+#else
+#define BSPETH_HW_RXQ_DEPTH 1 /* uboot */
+#endif
+#define BSPETH_HW_TXQ_DEPTH 1 /* uboot */
+
+#define BSPETH_MAX_FRAME_SIZE PKTSIZE_ALIGN /* 1536 */
+
+#define BSPETH_TRACE_ETH		2
+#define BSPETH_TRACE_MDIO	4
+#define BSPETH_TRACE_DRV		7
+#define BSPETH_TRACE_LEVEL	8
+
+/* Error number */
+#define BSPETH_E_QUEUE (-1)
+#define BSPETH_E_BUSY  (-2)
+#define BSPETH_E_FULL  (-3)
+#define BSPETH_E_EMPTY (-4)
+
+struct bspeth_frame_desc {
+	unsigned long frm_addr; /* required by the controler */
+	unsigned int frm_len : 11; /* required by the controler */
+};
+
+#define bspeth_trace_fd(level, fd) bspeth_trace(level, \
+	#fd "<%p>={ .frm_addr=%08lx, .frm_len=%d}",      \
+	&(fd), (fd).frm_addr, (fd).frm_len)
+
+/* port */
+#define UP_PORT		0
+#define DOWN_PORT	1
+#define MAX_PORT	2
+
+enum if_mode {
+	INTERFACE_MODE_MII,
+	INTERFACE_MODE_RMII
+};
+
+struct bspeth_netdev_local {
+	unsigned long iobase_phys; /* physical io addr */
+	int port : 1; /* 0 => up port,    1 => down port */
+
+#ifdef BSPETH_RX_QUEUE_MULTI_DESC
+	int desc_hw_offset; /* the offset where we feed hw */
+	int desc_rec_offset; /* the offset where we receve the package */
+	struct bspeth_frame_desc *bspeth_desc_head;
+#endif
+
+	u32 link_stat;
+	char *mii_name;
+	unsigned char phy_addr;
+	enum if_mode phy_intf;
+
+	/* mdio_bus freq-div, 1 for 1/100, 0 for 1/50 */
+	u32 mdio_frqdiv;
+};
+
+/* ***********************************************************
+ *
+ * Only for internal used!
+ *
+ * ***********************************************************
+ */
+
+/* read/write IO */
+
+#define _readl(c)     ({ u32 __v = le32_to_cpu(__raw_readl(c)); __v; })
+#define _writel(v, c) __raw_writel(cpu_to_le32(v), c)
+
+#define mk_bits(shift, nbits) ((((shift) & 0x1F) << 16) | ((nbits) & 0x1F))
+
+u32 bspeth_readl(struct bspeth_netdev_local *ld, u32 ofs);
+void bspeth_writel(struct bspeth_netdev_local *ld, u32 v, u32 ofs);
+u32 bspeth_readl_bits(struct bspeth_netdev_local *ld, u32 ofs, u32 bits_desc);
+void bspeth_writel_bits(struct bspeth_netdev_local *ld, u32 v, u32 ofs, u32 bits_desc);
+
+void bspeth_trace(int level, const char *fmt, ...);
+void bspeth_error(const char *fmt, ...);
+void bspeth_assert(bool cond);
+
+#define local_lock_init(ld)
+#define local_lock_exit(ld)
+#define local_lock(ld)
+#define local_unlock(ld)
+
+#define ud_reg_name(name) ((ld->port == UP_PORT) ? U_##name : D_##name)
+#define ud_bit_name(name) ((ld->port == UP_PORT) ? name##_U : name##_D)
+
+#endif
diff -uraN u-boot-2016.11/drivers/net/femac/ctrl.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/ctrl.c
--- u-boot-2016.11/drivers/net/femac/ctrl.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/ctrl.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,184 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#define BSPETH_FEMAC
+
+#include "bspeth.h"
+#include "ctrl.h"
+
+static inline u32 _bspeth_irq_enable(struct bspeth_netdev_local *ld, u32 irqs)
+{
+	u32 old = bspeth_readl(ld, GLB_RW_IRQ_ENA);
+
+	bspeth_writel(ld, old | irqs, GLB_RW_IRQ_ENA);
+
+	return old;
+}
+
+static inline u32 _bspeth_irq_disable(struct bspeth_netdev_local *ld, u32 irqs)
+{
+	u32 old = bspeth_readl(ld, GLB_RW_IRQ_ENA);
+
+	bspeth_writel(ld, old & (~irqs), GLB_RW_IRQ_ENA);
+
+	return old;
+}
+
+static inline u32 _bspeth_read_irqstatus(struct bspeth_netdev_local *ld)
+{
+	u32 status;
+
+	status = bspeth_readl(ld, GLB_RO_IRQ_STAT);
+
+	return status;
+}
+
+static inline int _test_xmit_queue_ready(struct bspeth_netdev_local *ld)
+{
+	return bspeth_readl_bits(ld, ud_reg_name(GLB_RO_QUEUE_STAT),
+							BITS_XMITQ_RDY);
+}
+
+static inline int _test_recv_queue_ready(struct bspeth_netdev_local *ld)
+{
+	return bspeth_readl_bits(ld, ud_reg_name(GLB_RO_QUEUE_STAT),
+							BITS_RECVQ_RDY);
+}
+
+u32 bspeth_irq_enable(struct bspeth_netdev_local *ld, u32 irqs)
+{
+	u32 old;
+
+	local_lock(ld);
+	old = _bspeth_irq_enable(ld, irqs);
+	local_unlock(ld);
+
+	return old;
+}
+
+u32 bspeth_irq_disable(struct bspeth_netdev_local *ld, u32 irqs)
+{
+	u32 old;
+
+	local_lock(ld);
+	old = _bspeth_irq_disable(ld, irqs);
+	local_unlock(ld);
+
+	return old;
+}
+
+u32 bspeth_read_irqstatus(struct bspeth_netdev_local *ld)
+{
+	u32 status;
+
+	local_lock(ld);
+	status = _bspeth_read_irqstatus(ld);
+	local_unlock(ld);
+
+	return status;
+}
+
+u32 bspeth_read_raw_irqstatus(struct bspeth_netdev_local *ld)
+{
+	u32 status;
+
+	local_lock(ld);
+	status = bspeth_readl(ld, GLB_RO_IRQ_STAT);
+	local_unlock(ld);
+
+	return status;
+}
+
+u32 bspeth_clear_irqstatus(struct bspeth_netdev_local *ld, u32 irqs)
+{
+	u32 status;
+
+	local_lock(ld);
+	bspeth_writel(ld, irqs, GLB_RW_IRQ_RAW);
+	status = _bspeth_read_irqstatus(ld);
+	local_unlock(ld);
+
+	return status;
+}
+
+u32 bspeth_set_endian_mode(struct bspeth_netdev_local *ld, u32 mode)
+{
+	u32 old;
+
+	local_lock(ld);
+	old = bspeth_readl_bits(ld, GLB_ENDIAN_MOD, BITS_ENDIAN);
+	bspeth_writel_bits(ld, mode, GLB_ENDIAN_MOD, BITS_ENDIAN);
+	local_unlock(ld);
+
+	return old;
+}
+
+void hw_xmitq_setfd(struct bspeth_netdev_local *ld, struct bspeth_frame_desc fd)
+{
+	bspeth_writel(ld, fd.frm_addr, ud_reg_name(GLB_EQ_ADDR));
+	bspeth_writel_bits(ld, fd.frm_len, ud_reg_name(GLB_EQFRM_LEN), BITS_TXINQ_LEN);
+}
+
+u32 bspeth_readl(struct bspeth_netdev_local *ld, u32 ofs)
+{
+	u32 reg = _readl((uintptr_t)(ld->iobase_phys + ofs));
+	bspeth_trace(BSPETH_TRACE_ETH, "_readl(0x%08X) = 0x%08X",
+		(u32)(ld->iobase_phys + ofs), reg);
+	return reg;
+}
+
+void bspeth_writel(struct bspeth_netdev_local *ld, u32 v, u32 ofs)
+{
+	_writel(v, (uintptr_t)(ld->iobase_phys + ofs));
+	bspeth_trace(BSPETH_TRACE_ETH, "_writel(0x%08X) = 0x%08X",
+		(u32)(ld->iobase_phys + ofs), v);
+}
+
+
+u32 bspeth_readl_bits(struct bspeth_netdev_local *ld, u32 ofs, u32 bits_desc)
+{
+	u32 _bits_desc = bits_desc;
+	u32 _shift = _bits_desc >> 16; /* shift 16 bit */
+	u32 _mask = ((1 << (_bits_desc & 0x1F)) - 1) << _shift;
+	u32 reg = (bspeth_readl(ld, ofs) & _mask) >> _shift;
+	return reg;
+}
+
+void bspeth_writel_bits(struct bspeth_netdev_local *ld, u32 v, u32 ofs, u32 bits_desc)
+{
+	u32 _bits_desc = bits_desc;
+	u32 _shift = _bits_desc >> 16; /* shift 16 bit */
+	u32 _reg = bspeth_readl(ld, ofs);
+	u32 _mask = ((1 << (_bits_desc & 0x1F)) - 1) << _shift;
+	bspeth_writel(ld, (_reg & (~_mask)) | ((v << _shift) & _mask), ofs);
+}
+
+void bspeth_trace(int level, const char *fmt, ...)
+{
+	if (level >= BSPETH_TRACE_LEVEL) {
+		va_list args;
+		va_start(args, fmt);
+		printf("bspeth_trace:");
+		printf(fmt, args);
+		printf("\n");
+		va_end(args);
+	}
+}
+
+void bspeth_error(const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	printf("bspeth:");
+	printf(fmt, args);
+	printf("\n");
+	va_end(args);
+}
+
+void bspeth_assert(bool cond)
+{
+	if (!cond)
+		printf("Assert:bspeth:%s:%d\n", __FILE__, __LINE__);
+}
\ No newline at end of file
diff -uraN u-boot-2016.11/drivers/net/femac/ctrl.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/ctrl.h
--- u-boot-2016.11/drivers/net/femac/ctrl.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/ctrl.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,148 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __BSPETH_CTRL_H__
+#define __BSPETH_CTRL_H__
+
+#include "bspeth.h"
+
+#ifdef BSPETH_FEMAC
+
+/* ENDIAN */
+#define GLB_ENDIAN_MOD		0x1318
+#define BITS_ENDIAN			mk_bits(0, 2)
+#define BSPETH_BIG_ENDIAN	0
+#define BSPETH_LITTLE_ENDIAN	3
+
+/* IRQs */
+#define GLB_RO_IRQ_STAT		0x1330
+#define GLB_RW_IRQ_ENA		0x1334
+#define GLB_RW_IRQ_RAW		0x1338
+
+/* IRQs mask bits */
+#define BITS_IRQS_U				mk_bits(0, 8)
+#define BITS_VLAN_IRQS			mk_bits(11, 1)
+#define BITS_MDIO_IRQS			mk_bits(13, 2)
+#define BITS_IRQS_ENA_D			mk_bits(17, 1)
+#define BITS_IRQS_ENA_U			mk_bits(18, 1)
+#define BITS_IRQS_ENA_ALLPORT	mk_bits(19, 1)
+#define BITS_IRQS_D				mk_bits(20, 8)
+
+#define BITS_IRQS_MASK_U		(0xFF)
+#define BITS_IRQS_MASK_D		(0xFF << 20)
+
+/* IRQs bit name */
+#define BSPETH_INT_RX_RDY_U      bit(0)
+#define BSPETH_INT_RX_RDY_D      bit(20)
+#define BSPETH_INT_TX_FIN_U		bit(1)
+#define BSPETH_INT_TX_FIN_D		bit(21)
+#define BSPETH_INT_LINK_CH_U		bit(2)
+#define BSPETH_INT_LINK_CH_D		bit(22)
+#define BSPETH_INT_SPEED_CH_U	bit(3)
+#define BSPETH_INT_SPEED_CH_D	bit(23)
+#define BSPETH_INT_DUPLEX_CH_U	bit(4)
+#define BSPETH_INT_DUPLEX_CH_D	bit(24)
+#define BSPETH_INT_STATE_CH_U	bit(5)
+#define BSPETH_INT_STATE_CH_D	bit(25)
+#define BSPETH_INT_TXQUE_RDY_U	bit(6)
+#define BSPETH_INT_TXQUE_RDY_D	bit(26)
+#define BSPETH_INT_MULTI_RXRDY_U	bit(7)
+#define BSPETH_INT_MULTI_RXRDY_D	bit(27)
+
+#define BSPETH_INT_MDIO_FINISH	bit(12)
+#define BSPETH_INT_UNKNOW_VLANID	bit(13)
+#define BSPETH_INT_UNKNOW_VLANM	bit(14)
+
+/* Tx/Rx Queue depth */
+#define U_GLB_QLEN_SET			0x0344
+#define D_GLB_QLEN_SET			0x2344
+#define BITS_TXQ_DEP			mk_bits(0, 6)
+#define BITS_RXQ_DEP			mk_bits(8, 6)
+
+/* Rx (read only) Queue-ID and LEN */
+#define U_GLB_RO_IQFRM_DES		0x0354
+#define D_GLB_RO_IQFRM_DES		0x2354
+/* bits of UD_GLB_RO_IQFRM_DES */
+#define BITS_RXPKG_LEN			mk_bits(0, 11)
+#define BITS_RXPKG_ID			mk_bits(12, 6)
+#define BITS_FRM_VLAN_VID		mk_bits(18, 1)
+#define BITS_FD_VID_VID			mk_bits(19, 1)
+#define BITS_FD_VLANID			mk_bits(20, 12)
+
+/* Rx ADDR */
+#define U_GLB_IQ_ADDR		0x0358
+#define D_GLB_IQ_ADDR		0x2358
+
+/* Tx ADDR and LEN */
+#define U_GLB_EQ_ADDR		0x0360
+#define D_GLB_EQ_ADDR		0x2360
+#define U_GLB_EQFRM_LEN		0x0364
+#define D_GLB_EQFRM_LEN		0x2364
+/* bits of UD_GLB_EQFRM_LEN */
+#define BITS_TXINQ_LEN		mk_bits(0, 11)
+
+/* Rx/Tx Queue ID */
+#define U_GLB_RO_QUEUE_ID	0x0368
+#define D_GLB_RO_QUEUE_ID	0x2368
+/* bits of UD_GLB_RO_QUEUE_ID */
+#define BITS_TXOUTQ_ID		mk_bits(0, 6)
+#define BITS_TXINQ_ID		mk_bits(8, 6)
+#define BITS_RXINQ_ID		mk_bits(16, 6)
+
+/* Rx/Tx Queue staus  */
+#define U_GLB_RO_QUEUE_STAT	0x036C
+#define D_GLB_RO_QUEUE_STAT	0x236C
+/* bits of UD_GLB_RO_QUEUE_STAT */
+/* check this bit to see if we can add a Tx package */
+#define BITS_XMITQ_RDY		mk_bits(24, 1)
+/* check this bit to see if we can add a Rx addr */
+#define BITS_RECVQ_RDY		mk_bits(25, 1)
+/* counts in queue, include currently sending */
+#define BITS_XMITQ_CNT_INUSE	mk_bits(0, 6)
+/* counts in queue, include currently receving */
+#define BITS_RECVQ_CNT_RXOK		mk_bits(8, 6)
+
+#define is_recv_packet(ld)		(bspeth_readl(ld, GLB_RW_IRQ_RAW) & (ud_bit_name(BSPETH_INT_RX_RDY)))
+#define is_recv_packet_rx(ld)	((bspeth_readl(ld, ud_reg_name(GLB_RO_QUEUE_STAT)) >> 8) & 0x3F)
+#define hw_set_rxpkg_finish(ld)	bspeth_writel(ld, ud_bit_name(BSPETH_INT_RX_RDY), GLB_RW_IRQ_RAW)
+
+// //////////////////////////////////////////////////////////////////////////////////////////
+
+#define hw_get_rxpkg_id(ld)		bspeth_readl_bits(ld, ud_reg_name(GLB_RO_IQFRM_DES), BITS_RXPKG_ID)
+#define hw_get_rxpkg_len(ld)	bspeth_readl_bits(ld, ud_reg_name(GLB_RO_IQFRM_DES), BITS_RXPKG_LEN)
+
+#define hw_get_txqid(ld)	bspeth_readl_bits(ld, ud_reg_name(GLB_RO_QUEUE_ID), BITS_TXINQ_ID)
+#define hw_get_rxqid(ld)	bspeth_readl_bits(ld, ud_reg_name(GLB_RO_QUEUE_ID), BITS_RXINQ_ID)
+
+#define hw_xmitq_cnt_inuse(ld)	bspeth_readl_bits(ld, ud_reg_name(GLB_RO_QUEUE_STAT), BITS_XMITQ_CNT_INUSE)
+#define hw_recvq_cnt_rxok(ld)	bspeth_readl_bits(ld, ud_reg_name(GLB_RO_QUEUE_STAT), BITS_RECVQ_CNT_RXOK)
+
+#define hw_recvq_setfd(ld, fd) bspeth_writel(ld, (fd).frm_addr, ud_reg_name(GLB_IQ_ADDR))
+
+#endif
+
+/* for each bits, set '1' enable the intterrupt, and '0' takes no effects */
+/* return last irq_enable status */
+u32 bspeth_irq_enable(struct bspeth_netdev_local *ld, u32 irqs);
+u32 bspeth_irq_disable(struct bspeth_netdev_local *ld, u32 irqs);
+/* return irqstatus */
+u32 bspeth_read_irqstatus(struct bspeth_netdev_local *ld);
+u32 bspeth_read_raw_irqstatus(struct bspeth_netdev_local *ld);
+/* return irqstatus after clean */
+u32 bspeth_clear_irqstatus(struct bspeth_netdev_local *ld, u32 irqs);
+
+u32 bspeth_set_endian_mode(struct bspeth_netdev_local *ld, u32 mode);
+void hw_xmitq_setfd(struct bspeth_netdev_local *ld, struct bspeth_frame_desc fd);
+
+/* Tx/Rx queue operation */
+int bspeth_set_hwq_depth(struct bspeth_netdev_local *ld);
+int bspeth_get_hwq_xmit_depth(struct bspeth_netdev_local *ld);
+int bspeth_get_hwq_recv_depth(struct bspeth_netdev_local *ld);
+
+#define bspeth_invalid_txqfd_addr(addr)	((addr) & 0x3)
+#define bspeth_invalid_rxqfd_addr(addr)	((addr) & 0x3)
+#define bspeth_invalid_rxpkg_len(len)	(!((len) >= 42 && (len) <= BSPETH_MAX_FRAME_SIZE))
+
+#endif
diff -uraN u-boot-2016.11/drivers/net/femac/glb.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/glb.c
--- u-boot-2016.11/drivers/net/femac/glb.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/glb.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#define BSPETH_FEMAC
+
+#include <config.h>
+#include "bspeth.h"
+#include "mac.h"
+#include "ctrl.h"
+#include "glb.h"
+
+int bspeth_glb_preinit_dummy(struct bspeth_netdev_local *ld)
+{
+	local_lock_init(ld);
+
+	/*
+	 * bspeth_glb_preinit_dummy
+	 * HW MAX DEFAULT RX-PKT-LEN [42,1518]
+	 * HW MAC FILTER TABLE DISABLE
+	 */
+
+	/* soft reset */
+	bspeth_writel_bits(ld, 1, GLB_SOFT_RESET, BITS_ETH_SOFT_RESET);
+	mdelay(1);
+	bspeth_writel_bits(ld, 0, GLB_SOFT_RESET, BITS_ETH_SOFT_RESET);
+
+	bspeth_set_endian_mode(ld, BSPETH_LITTLE_ENDIAN);
+
+	bspeth_set_linkstat(ld, 0);
+
+	bspeth_set_negmode(ld, BSPETH_NEGMODE_CPUSET);
+
+	/* RMII mode */
+	bspeth_set_mii_mode(ld, ud_bit_name(BSPETH_MII_RMII_MODE));
+
+	bspeth_writel_bits(ld, ~0, GLB_RW_IRQ_ENA, ud_bit_name(BITS_IRQS));
+	bspeth_writel_bits(ld, ~0, GLB_RW_IRQ_ENA, ud_bit_name(BITS_IRQS_ENA));
+	bspeth_writel_bits(ld, ~0, GLB_RW_IRQ_ENA, BITS_IRQS_ENA_ALLPORT);
+	bspeth_irq_disable(ld, ~0);
+
+	/* init */
+	bspeth_writel(ld, 0, GLB_FWCTRL);
+	bspeth_writel(ld, 0, GLB_MACTCTRL);
+
+	/* disable vlan func */
+	bspeth_writel_bits(ld, 0, GLB_FWCTRL, BITS_VLAN_ENABLE);
+
+	/* enable UpEther<->CPU */
+	bspeth_writel_bits(ld, 1, GLB_FWCTRL, BITS_FW2CPU_ENA_UP);
+	bspeth_writel_bits(ld, 0, GLB_FWCTRL, BITS_FWALL2CPU_UP);
+	bspeth_writel_bits(ld, 0, GLB_MACTCTRL, BITS_BROAD2CPU_UP);
+	bspeth_writel_bits(ld, 1, GLB_MACTCTRL, BITS_MACT_ENA_UP);
+
+	/* enable DownEther<->CPU and UpEther<->CPU */
+	bspeth_writel_bits(ld, 1, GLB_FWCTRL, BITS_FW2CPU_ENA_DOWN);
+	bspeth_writel_bits(ld, 0, GLB_FWCTRL, BITS_FWALL2CPU_DOWN);
+	bspeth_writel_bits(ld, 0, GLB_MACTCTRL, BITS_BROAD2CPU_DOWN);
+	bspeth_writel_bits(ld, 1, GLB_MACTCTRL, BITS_MACT_ENA_DOWN);
+
+	bspeth_set_mac_leadcode_cnt_limit(ld, 0);
+
+	return 0;
+}
diff -uraN u-boot-2016.11/drivers/net/femac/glb.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/glb.h
--- u-boot-2016.11/drivers/net/femac/glb.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/glb.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __BSPETH_GLB_H__
+#define __BSPETH_GLB_H__
+
+#include "bspeth.h"
+
+#define GLB_HOSTMAC_L32  0x1300
+#define BITS_HOSTMAC_L32 mk_bits(0, 32)
+#define GLB_HOSTMAC_H16  0x1304
+#define BITS_HOSTMAC_H16 mk_bits(0, 16)
+
+#define GLB_SOFT_RESET      0x1308
+#define BITS_ETH_SOFT_RESET mk_bits(0, 1)
+
+#define GLB_FWCTRL           0x1310
+#define BITS_VLAN_ENABLE     mk_bits(0, 1)
+#define BITS_FW2CPU_ENA_UP   mk_bits(5, 1)
+#define BITS_FWALL2CPU_UP    mk_bits(7, 1)
+#define BITS_FW2CPU_ENA_DOWN mk_bits(9, 1)
+#define BITS_FWALL2CPU_DOWN  mk_bits(11, 1)
+
+#define GLB_MACTCTRL        0x1314
+#define BITS_BROAD2CPU_UP   mk_bits(5, 1)
+#define BITS_BROAD2CPU_DOWN mk_bits(13, 1)
+#define BITS_MACT_ENA_DOWN  mk_bits(15, 1)
+#define BITS_MACT_ENA_UP    mk_bits(7, 1)
+
+#define GLB_MAC0_L32      0x1400
+#define GLB_MAC0_H16      0x1404
+#define BITS_MAC0_H16     mk_bits(0, 16)
+#define BITS_PKT2CPU_UP   mk_bits(21, 1)
+#define BITS_PKT2CPU_DOWN mk_bits(19, 1)
+
+int bspeth_glb_preinit_dummy(struct bspeth_netdev_local *ld);
+
+#endif
diff -uraN u-boot-2016.11/drivers/net/femac/mac.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/mac.c
--- u-boot-2016.11/drivers/net/femac/mac.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/mac.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,117 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#define BSPETH_FEMAC
+
+#include "bspeth.h"
+#include "mac.h"
+
+static u32 _set_linkstat(struct bspeth_netdev_local *ld, u32 mode)
+{
+	u32 old;
+
+	old = bspeth_readl_bits(ld, ud_reg_name(MAC_PORTSET), BITS_MACSTAT);
+	bspeth_writel_bits(ld, mode, ud_reg_name(MAC_PORTSET), BITS_MACSTAT);
+
+	return old;
+}
+
+static u32 _set_negmode(struct bspeth_netdev_local *ld, u32 mode)
+{
+	u32 old;
+
+	old = bspeth_readl_bits(ld, ud_reg_name(MAC_PORTSEL), BITS_NEGMODE);
+	bspeth_writel_bits(ld, mode, ud_reg_name(MAC_PORTSEL), BITS_NEGMODE);
+
+	return old;
+}
+
+static u32 _get_negmode(struct bspeth_netdev_local *ld)
+{
+	u32 val;
+
+	val = bspeth_readl_bits(ld, ud_reg_name(MAC_PORTSEL), BITS_NEGMODE);
+	return val;
+}
+
+void bspeth_set_linkstat(struct bspeth_netdev_local *ld, u32 mode)
+{
+	local_lock(ld);
+	(void)_set_linkstat(ld, mode);
+	local_unlock(ld);
+}
+
+u32 bspeth_get_linkstat(struct bspeth_netdev_local *ld)
+{
+	u32 val;
+
+	local_lock(ld);
+	val = bspeth_readl_bits(ld, ud_reg_name(MAC_RO_STAT), BITS_MACSTAT);
+	local_unlock(ld);
+	return val;
+}
+
+void bspeth_set_mac_leadcode_cnt_limit(struct bspeth_netdev_local *ld, u32 cnt)
+{
+	local_lock(ld);
+	(void)bspeth_readl_bits(ld, ud_reg_name(MAC_TX_IPGCTRL),
+						   BITS_PRE_CNT_LIMIT);
+	bspeth_writel_bits(ld, cnt, ud_reg_name(MAC_TX_IPGCTRL),
+					  BITS_PRE_CNT_LIMIT);
+	local_unlock(ld);
+}
+
+void bspeth_set_mac_trans_interval_bits(struct bspeth_netdev_local *ld, u32 nbits)
+{
+	u32 linkstat, negmode;
+
+	local_lock(ld);
+
+	negmode = _set_negmode(ld, BSPETH_NEGMODE_CPUSET);
+	linkstat = _set_linkstat(ld, 0);
+	mdelay(1);
+
+	(void)bspeth_readl_bits(ld, ud_reg_name(MAC_TX_IPGCTRL), BITS_IPG);
+	bspeth_writel_bits(ld, nbits, ud_reg_name(MAC_TX_IPGCTRL), BITS_IPG);
+	udelay(100); /* delay 100us */
+
+	_set_negmode(ld, negmode);
+	_set_linkstat(ld, linkstat);
+
+	local_unlock(ld);
+}
+
+void bspeth_set_mac_fc_interval(struct bspeth_netdev_local *ld, u32 para)
+{
+	local_lock(ld);
+	(void)bspeth_readl_bits(ld, ud_reg_name(MAC_TX_IPGCTRL), BITS_FC_INTER);
+	bspeth_writel_bits(ld, para, ud_reg_name(MAC_TX_IPGCTRL), BITS_FC_INTER);
+	local_unlock(ld);
+}
+
+void bspeth_set_negmode(struct bspeth_netdev_local *ld, u32 mode)
+{
+	local_lock(ld);
+	_set_negmode(ld, mode);
+	local_unlock(ld);
+}
+
+u32 bspeth_get_negmode(struct bspeth_netdev_local *ld)
+{
+	u32 val;
+
+	local_lock(ld);
+	val = _get_negmode(ld);
+	local_unlock(ld);
+	return val;
+}
+
+void bspeth_set_mii_mode(struct bspeth_netdev_local *ld, u32 mode)
+{
+	local_lock(ld);
+	(void)bspeth_readl_bits(ld, ud_reg_name(MAC_PORTSEL), BITS_MII_MODE);
+	bspeth_writel_bits(ld, mode, ud_reg_name(MAC_PORTSEL), BITS_MII_MODE);
+	local_unlock(ld);
+}
diff -uraN u-boot-2016.11/drivers/net/femac/mac.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/mac.h
--- u-boot-2016.11/drivers/net/femac/mac.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/mac.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __BSPETH_MAC_H__
+#define __BSPETH_MAC_H__
+
+#include "bspeth.h"
+
+#ifdef BSPETH_FEMAC
+
+#define U_MAC_PORTSEL     0x0200
+#define D_MAC_PORTSEL     0x2200
+#define U_MAC_RO_STAT     0x0204
+#define D_MAC_RO_STAT     0x2204
+#define U_MAC_PORTSET     0x0208
+#define D_MAC_PORTSET     0x2208
+#define U_MAC_STAT_CHANGE 0x020C
+#define D_MAC_STAT_CHANGE 0x220C
+#define U_MAC_SET         0x0210
+#define D_MAC_SET         0x2210
+#define U_MAC_RX_IPGCTRL  0x0214
+#define D_MAC_RX_IPGCTRL  0x2214
+#define U_MAC_TX_IPGCTRL  0x0218
+#define D_MAC_TX_IPGCTRL  0x2218
+
+/* bits of UD_MAC_PORTSET and UD_MAC_RO_STAT */
+#define BITS_MACSTAT mk_bits(0, 3)
+
+/* bits of U_MAC_PORTSEL and D_MAC_PORTSEL */
+#define BITS_NEGMODE  mk_bits(0, 1)
+#define BITS_MII_MODE mk_bits(1, 1)
+
+/* bits of U_MAC_TX_IPGCTRL and D_MAC_TX_IPGCTRL */
+#define BITS_PRE_CNT_LIMIT mk_bits(23, 3)
+#define BITS_IPG           mk_bits(16, 7)
+#define BITS_FC_INTER      mk_bits(0, 16)
+
+#endif
+
+#define BSPETH_SPD_100M bit(2)
+#define BSPETH_LINKED   bit(1)
+#define BSPETH_DUP_FULL bit(0)
+
+void bspeth_set_mac_leadcode_cnt_limit(struct bspeth_netdev_local *ld, u32 cnt);
+void bspeth_set_mac_trans_interval_bits(struct bspeth_netdev_local *ld, u32 nbits);
+void bspeth_set_mac_fc_interval(struct bspeth_netdev_local *ld, u32 para);
+
+void bspeth_set_linkstat(struct bspeth_netdev_local *ld, u32 mode);
+u32 bspeth_get_linkstat(struct bspeth_netdev_local *ld);
+
+#define BSPETH_NEGMODE_CPUSET 1
+#define BSPETH_NEGMODE_AUTO   0
+
+void bspeth_set_negmode(struct bspeth_netdev_local *ld, u32 mode);
+u32 bspeth_get_negmode(struct bspeth_netdev_local *ld);
+
+#define BSPETH_MII_MODE  0
+#define BSPETH_RMII_MODE 1
+
+void bspeth_set_mii_mode(struct bspeth_netdev_local *ld, u32 mode);
+
+#endif
diff -uraN u-boot-2016.11/drivers/net/femac/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/Makefile
--- u-boot-2016.11/drivers/net/femac/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,8 @@
+#
+# (C) Copyright 2008
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y += net_drv.o mii_drv.o ctrl.o glb.o mac.o mdio.o sys.o
diff -uraN u-boot-2016.11/drivers/net/femac/mdio.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/mdio.c
--- u-boot-2016.11/drivers/net/femac/mdio.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/mdio.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#define BSPETH_FEMAC
+
+#include "bspeth.h"
+#include "mdio.h"
+
+/* write mdio registers reset value */
+static void mdio_reg_reset(struct bspeth_netdev_local *ld)
+{
+	bspeth_writel(ld, 0x00008000, MDIO_RWCTRL);
+	bspeth_writel(ld, 0x00000001, U_MDIO_PHYADDR);
+	bspeth_writel(ld, 0x00000001, D_MDIO_PHYADDR);
+	bspeth_writel(ld, 0x04631EA9, U_MDIO_ANEG_CTRL);
+	bspeth_writel(ld, 0x04631EA9, D_MDIO_ANEG_CTRL);
+	bspeth_writel(ld, 0x00000000, U_MDIO_IRQENA);
+	bspeth_writel(ld, 0x00000000, D_MDIO_IRQENA);
+}
+
+static int wait_mdio_ready(struct bspeth_netdev_local *ld)
+{
+	int timeout_us = 5000;
+
+	while (--timeout_us && !test_mdio_ready(ld))
+		udelay(50);  /* delay 50us */
+
+	return timeout_us;
+}
+
+int bspeth_mdio_read(struct bspeth_netdev_local *ld, int phy_addr, unsigned int regnum)
+{
+	int val = 0;
+	bspeth_assert((!((unsigned int)phy_addr & (~0x1F))) && (!(regnum & (~0x1F))));
+
+	local_lock(ld);
+
+	if (!wait_mdio_ready(ld)) {
+		bspeth_error("mdio busy");
+		goto error_exit;
+	}
+
+	mdio_start_phyread(ld, (unsigned int)phy_addr, regnum);
+
+	if (wait_mdio_ready(ld) != 0) {
+		val = mdio_get_phyread_val(ld);
+	} else {
+		bspeth_error("read timeout");
+	}
+
+error_exit:
+
+	local_unlock(ld);
+
+	bspeth_trace(BSPETH_TRACE_MDIO, "phy_addr = %d, regnum = %d, val = 0x%04x", phy_addr,
+				(int)regnum, val);
+
+	return val;
+}
+
+int bspeth_mdio_write(struct bspeth_netdev_local *ld, int phy_addr, int regnum, int val)
+{
+	bspeth_assert((!((unsigned int)phy_addr & (~0x1F))) && (!((unsigned int)regnum & (~0x1F))));
+
+	bspeth_trace(BSPETH_TRACE_MDIO, "phy_addr = %d, regnum = %d", phy_addr, regnum);
+
+	local_lock(ld);
+
+	if (!wait_mdio_ready(ld)) {
+		bspeth_error("mdio busy");
+		val = -1;
+		goto error_exit;
+	}
+
+	mdio_phywrite(ld, (unsigned int)phy_addr, (unsigned int)regnum, (unsigned int)val);
+
+error_exit:
+
+	local_unlock(ld);
+
+	return val;
+}
+
+int bspeth_mdio_reset(struct bspeth_netdev_local *ld)
+{
+	mdio_reg_reset(ld);
+
+	return 0;
+}
+
+int bspeth_mdio_init(struct bspeth_netdev_local *ld)
+{
+	local_lock_init(ld);
+
+	bspeth_mdio_reset(ld);
+
+	return 0;
+}
+
+void bspeth_mdio_exit(struct bspeth_netdev_local *ld)
+{
+	local_lock_exit(ld);
+}
diff -uraN u-boot-2016.11/drivers/net/femac/mdio.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/mdio.h
--- u-boot-2016.11/drivers/net/femac/mdio.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/mdio.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __BSPETH_MDIO_H__
+#define __BSPETH_MDIO_H__
+
+#include "bspeth.h"
+
+#ifdef BSPETH_FEMAC
+
+#define MDIO_RWCTRL      0x1100
+#define MDIO_RO_DATA     0x1104
+#define U_MDIO_PHYADDR   0x0108
+#define D_MDIO_PHYADDR   0x2108
+#define U_MDIO_RO_STAT   0x010C
+#define D_MDIO_RO_STAT   0x210C
+#define U_MDIO_ANEG_CTRL 0x0110
+#define D_MDIO_ANEG_CTRL 0x2110
+#define U_MDIO_IRQENA    0x0114
+#define D_MDIO_IRQENA    0x2114
+
+#define mdio_mk_rwctl(cpu_data_in, finish, rw, phy_exaddr, frq_div, phy_regnum) \
+	(((cpu_data_in) << 16) | (((finish) & 0x01) << 15) | (((rw) & 0x01) << 13) | \
+	(((phy_exaddr) & 0x1F) << 8) | (((frq_div) & 0x7) << 5) | ((phy_regnum) & 0x1F))
+
+/* hardware set bit'15 of MDIO_REG(0) if mdio ready */
+#define test_mdio_ready(ld) (bspeth_readl(ld, MDIO_RWCTRL) & bit(15))
+
+#define mdio_start_phyread(ld, phy_addr, regnum) \
+	bspeth_writel(ld, mdio_mk_rwctl(0, 0, 0, phy_addr, (ld)->mdio_frqdiv, regnum), MDIO_RWCTRL)
+
+#define mdio_get_phyread_val(ld) (bspeth_readl(ld, MDIO_RO_DATA) & 0xFFFF)
+
+#define mdio_phywrite(ld, phy_addr, regnum, val) \
+	bspeth_writel(ld, mdio_mk_rwctl(val, 0, 1, phy_addr, (ld)->mdio_frqdiv, regnum), MDIO_RWCTRL)
+
+#endif
+
+/* APIs */
+int bspeth_mdio_read(struct bspeth_netdev_local *ld, int phy_addr, unsigned int regnum);
+int bspeth_mdio_write(struct bspeth_netdev_local *ld, int phy_addr, int regnum, int val);
+int bspeth_mdio_reset(struct bspeth_netdev_local *ld);
+int bspeth_mdio_init(struct bspeth_netdev_local *ld);
+void bspeth_mdio_exit(struct bspeth_netdev_local *ld);
+#endif
diff -uraN u-boot-2016.11/drivers/net/femac/mii_drv.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/mii_drv.c
--- u-boot-2016.11/drivers/net/femac/mii_drv.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/mii_drv.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,152 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#include "bspeth.h"
+#include "mdio.h"
+#include "mii_drv.h"
+#include <config.h>
+
+/* MDIO Bus Interface */
+static int bspeth_mdiobus_read(struct mii_dev *bus, int addr, int devad, int reg)
+{
+	struct bspeth_netdev_local *ld = (struct bspeth_netdev_local *)bus->priv;
+
+	return bspeth_mdio_read(ld, addr, reg);
+}
+
+static int bspeth_mdiobus_write(struct mii_dev *bus, int addr, int devad,
+		  int reg, u16 value)
+{
+	struct bspeth_netdev_local *ld = (struct bspeth_netdev_local *)bus->priv;
+
+	bspeth_mdio_write(ld, addr, reg, value);
+
+	return 0;
+}
+
+#define PHY_ID_KSZ8051 0x00221550
+#define PHY_ID_KSZ8081 0x00221560
+#define PHY_ID_MASK    0xFFFFFFF0
+
+static bool get_fephy_id(const char *devname, unsigned char phyaddr, u32 *phy_id)
+{
+	u16 id1 = 0;
+	u16 id2 = 0;
+
+	if (miiphy_read(devname, phyaddr, MII_PHYSID1, &id1)) {
+		printf("%s,%d:PHY_PHYIDR1 read failed!\n", __func__, __LINE__);
+		return false;
+	}
+	if (miiphy_read(devname, phyaddr, MII_PHYSID2, &id2)) {
+		printf("%s,%d:PHY_PHYIDR2 read failed!\n", __func__, __LINE__);
+		return false;
+	}
+
+	*phy_id = (id1 & 0xffff) << 16; /* high 16 bit */
+	*phy_id |= (id2 & 0xffff);
+
+	/* If the phy_id is all Fs, there is no device there */
+	if (*phy_id == 0xffffffff || *phy_id == 0 || *phy_id == 0xFFFF || *phy_id == 0xFFFF0000) {
+		return false;
+	}
+
+	return true;
+}
+
+bool phy_detected(const char *devname, unsigned char phyaddr)
+{
+	u32 phy_id = 0;
+
+	if (!get_fephy_id(devname, phyaddr, &phy_id)) return false;
+
+	/* run this at RMII mode */
+	if (BSPETH_MII_RMII_MODE_U == 1) {
+		/* PHY-KSZ8051RNL */
+		if ((phy_id & PHY_ID_MASK) == PHY_ID_KSZ8051) {
+			unsigned short reg = 0;
+
+			if (miiphy_read(devname, phyaddr, 0x1F, &reg)) {
+				printf("PHY 0x1F read failed\n");
+				return false;
+			}
+			reg |= bit(7); /* bit7:set phy RMII 50MHz clk; */
+			if (miiphy_write(devname, phyaddr, 0x1F, reg)) {
+				printf("PHY 0x1F write failed\n");
+				return false;
+			}
+
+			if (miiphy_read(devname, phyaddr, 0x16, &reg)) {
+				printf("PHY 0x16 read failed\n");
+				return false;
+			}
+			reg |= bit(1); /* set phy RMII override; */
+			if (miiphy_write(devname, phyaddr, 0x16, reg)) {
+				printf("PHY 0x16 write failed\n");
+				return false;
+			}
+		}
+
+		/* PHY-KSZ8081 */
+		if ((phy_id & PHY_ID_MASK) == PHY_ID_KSZ8081) {
+			unsigned short val = 0;
+
+			if (miiphy_read(devname, phyaddr, 0x1F, &val) != 0) {
+				printf("PHY 0x1F read failed\n");
+				return false;
+			};
+			val |= bit(7); /* bit7:set phy RMII 50MHz clk; */
+			if (miiphy_write(devname, phyaddr, 0x1F, val) != 0) {
+				printf("PHY 0x1F write failed\n");
+				return false;
+			}
+		}
+	}
+	return true;
+}
+
+static int g_mdio_registered;
+
+int bspeth_mdiobus_driver_init(struct bspeth_netdev_local *ld)
+{
+	memset(ld->mii_name, 0, MAX_PHY_NAME_LEN);
+	snprintf(ld->mii_name, MAX_PHY_NAME_LEN, "mii_bspeth");
+	ld->mdio_frqdiv = ETH_MDIO_FRQDIV;
+#if defined(CONFIG_MII) || defined(CONFIG_CMD_MII)
+	if (!g_mdio_registered) {
+		struct mii_dev *bus = mdio_alloc();
+
+		if (!bus) {
+			printf("Failed to allocate MDIO bus\n");
+			return -ENOMEM;
+		}
+
+		bus->priv = ld;
+		bus->read = bspeth_mdiobus_read;
+		bus->write = bspeth_mdiobus_write;
+		snprintf(bus->name, sizeof(bus->name), ld->mii_name);
+
+		bspeth_mdio_init(ld);
+
+		if (mdio_register(bus)) {
+			mdio_free(bus);
+			return -1;
+		}
+
+		miiphy_set_current_dev(ld->mii_name);
+		g_mdio_registered = 1;
+	}
+#endif
+	return 0;
+}
+
+void bspeth_mdiobus_driver_exit(struct bspeth_netdev_local *ld)
+{
+	/* add this to avoid the first time to use eth will print 'No such device: XXXXX' message. */
+	if (!miiphy_get_current_dev()) {
+		return;
+	}
+
+	bspeth_mdio_exit(ld);
+}
diff -uraN u-boot-2016.11/drivers/net/femac/mii_drv.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/mii_drv.h
--- u-boot-2016.11/drivers/net/femac/mii_drv.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/mii_drv.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,10 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __BSPETH_MII_DRV_H__
+#define __BSPETH_MII_DRV_H__
+
+bool phy_detected(const char *devname, unsigned char phyaddr);
+#endif
\ No newline at end of file
diff -uraN u-boot-2016.11/drivers/net/femac/net_drv.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/net_drv.c
--- u-boot-2016.11/drivers/net/femac/net_drv.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/net_drv.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,535 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#define BSPETH_FEMAC
+#include "bspeth.h"
+#include "mac.h"
+#include "ctrl.h"
+#include "glb.h"
+#include "sys.h"
+#include "mii_drv.h"
+#include <config.h>
+#include <miiphy.h>
+#include <net.h>
+/*************************************************************************/
+int bspeth_mdiobus_driver_init(struct bspeth_netdev_local *ld);
+void bspeth_mdiobus_driver_exit(struct bspeth_netdev_local *ld);
+
+/* Used when trying to connect to a specific phy (mii bus id:phy device id) */
+/* refer linux-2.6.23 ./include/linux/phy.h line 76 */
+char mdio_bus_name[MAX_PHY_NAME_LEN];
+
+#define MAC_LEN 6
+
+struct bspeth_netdev_local bspeth_devs_priv[MAX_PORT] = {
+	{
+		.port = UP_PORT,
+		.mii_name = mdio_bus_name,
+		.phy_addr = SFV_PHY_U,
+		.phy_intf = BSPETH_MII_RMII_MODE_U,
+	},
+	{
+		.port = DOWN_PORT,
+		.mii_name = mdio_bus_name,
+		.phy_addr = SFV_PHY_D,
+		.phy_intf = BSPETH_MII_RMII_MODE_D,
+	},
+};
+
+static int set_mac_address(const char *mac)
+{
+	u32 val;
+
+	val = ((u32)mac[0] << 8) | (u32)mac[1]; /* mac 0 [8:15], mac 1 [0:7] */
+	writel(val, REG_BASE_SF + GLB_HOSTMAC_H16);
+	/* mac 2 [24:31], mac 3 [16:23], mac 4 [8:15], mac 5 [0:7] */
+	val = ((u32)mac[2] << 24) | ((u32)mac[3] << 16) | ((u32)mac[4] << 8) | (u32)mac[5];
+	writel(val, REG_BASE_SF + GLB_HOSTMAC_L32);
+
+	return 0;
+}
+
+#ifdef BSPETH_RX_QUEUE_MULTI_DESC
+static int bspeth_init_hw_desc_queue(struct bspeth_netdev_local *ld)
+{
+	struct bspeth_frame_desc *queue_phy_addr = NULL;
+	int i;
+
+	const int size = BSPETH_HW_DESC_DEPTH * sizeof(struct bspeth_frame_desc);
+	/* init rx fq */
+	queue_phy_addr = (struct bspeth_frame_desc *)malloc(size);
+	if (queue_phy_addr == NULL) {
+		printf("alloc rx fq error!\n");
+		return 1;
+	}
+
+	memset((void *)queue_phy_addr, 0, size);
+	ld->bspeth_desc_head = queue_phy_addr;
+	ld->desc_hw_offset = 0;
+	ld->desc_rec_offset = 0;
+
+	for (i = 0; i < BSPETH_HW_DESC_DEPTH; i++) {
+		queue_phy_addr[i].frm_addr = (unsigned long)memalign(PKTALIGN, PKTSIZE_ALIGN);
+		queue_phy_addr[i].frm_len = 0;
+	}
+	return 0;
+}
+#endif
+
+#ifdef BSPETH_RX_QUEUE_MULTI_DESC
+static int bspeth_destroy_hw_desc_queue(struct bspeth_netdev_local *ld)
+{
+	struct bspeth_frame_desc *queue_phy_addr = ld->bspeth_desc_head;
+	int i;
+
+	if (queue_phy_addr != NULL) {
+		for (i = 0; i < BSPETH_HW_DESC_DEPTH; i++)
+			free((void *)queue_phy_addr[i].frm_addr);
+
+		free(ld->bspeth_desc_head);
+		ld->bspeth_desc_head = NULL;
+	}
+	ld->desc_hw_offset = 0;
+	ld->desc_rec_offset = 0;
+
+	return 0;
+}
+#endif
+
+int eth_set_host_mac_address(struct eth_device *dev)
+{
+	unsigned char mac[MAC_LEN];
+
+	memset(mac, 0, sizeof(mac));
+
+	if (!eth_getenv_enetaddr("ethaddr", mac)) {
+		printf("MAC address invalid!\n");
+#ifdef CONFIG_NET_RANDOM_ETHADDR
+		net_random_ethaddr(mac);
+		printf("Set Random MAC address!\n");
+		eth_setenv_enetaddr("ethaddr", mac);
+#endif
+	}
+
+	set_mac_address((char *)mac);
+	memcpy(dev->enetaddr, mac, MAC_LEN);
+
+	return 0;
+}
+
+static void phy_print_status(struct bspeth_netdev_local *ld, unsigned int stat)
+{
+	printf("%s : phy status change : LINK=%s : DUPLEX=%s : SPEED=%s\n",
+		   (ld->port == UP_PORT) ? "eth0" : "eth1",
+		   (stat & BSPETH_LINKED) ? "UP" : "DOWN",
+		   (stat & BSPETH_DUP_FULL) ? "FULL" : "HALF",
+		   (stat & BSPETH_SPD_100M) ? "100M" : "10M");
+}
+
+static void bspeth_adjust_link(struct bspeth_netdev_local *ld)
+{
+	u32 stat = 0;
+	int timeout_us = 1000;
+	/* this env phy_link_time used to solve the difference phy auto-negotiation time of  various phys */
+	char *timeout = getenv("phy_link_time");
+	if (timeout != NULL) {
+		timeout_us = simple_strtol(timeout, 0, 10); /* Base10 */
+		if (timeout_us < 0)
+			timeout_us = 1000; /* delay 1000us */
+	}
+retry:
+	udelay(1);
+
+	stat |= miiphy_link(ld->mii_name, ld->phy_addr) ? BSPETH_LINKED : 0;
+	stat |= miiphy_duplex(ld->mii_name, ld->phy_addr) == FULL ? BSPETH_DUP_FULL : 0;
+	stat |= miiphy_speed(ld->mii_name, ld->phy_addr) == _100BASET ? BSPETH_SPD_100M : 0;
+	if (--timeout_us && !(stat & BSPETH_LINKED))
+		goto retry;
+
+	if (stat != ld->link_stat) {
+		bspeth_set_linkstat(ld, stat);
+		phy_print_status(ld, stat);
+		ld->link_stat = stat;
+		bspeth_set_mii_mode(ld, ld->phy_intf);
+	}
+
+	set_phy_valtage();
+}
+
+static int bspeth_net_open(struct bspeth_netdev_local *ld)
+{
+	/* enable sys-ctrl-en and clk-en  */
+	bspeth_sys_startup();
+
+	/* setup hardware tx dep */
+	bspeth_writel_bits(ld, BSPETH_HW_TXQ_DEPTH, ud_reg_name(GLB_QLEN_SET), BITS_TXQ_DEP);
+
+	/* setup hardware rx dep */
+	bspeth_writel_bits(ld, BSPETH_HW_RXQ_DEPTH, ud_reg_name(GLB_QLEN_SET), BITS_RXQ_DEP);
+
+	ld->link_stat = 0;
+	bspeth_adjust_link(ld);
+
+	bspeth_irq_enable(ld, ud_bit_name(BSPETH_INT_RX_RDY));
+
+	return 0;
+}
+
+static int bspeth_net_close(struct bspeth_netdev_local *ld)
+{
+	bspeth_glb_preinit_dummy(ld);
+
+	bspeth_sys_allstop();
+
+	return 0;
+}
+
+static int bspeth_dev_probe_init(struct bspeth_netdev_local *ld)
+{
+	ld->iobase_phys = REG_BASE_SF;
+
+	bspeth_glb_preinit_dummy(ld);
+
+#ifdef BSPETH_RX_QUEUE_MULTI_DESC
+	bspeth_init_hw_desc_queue(ld);
+#endif
+
+	bspeth_sys_allstop();
+
+	return 0;
+}
+
+static int bspeth_dev_remove(struct bspeth_netdev_local *ld)
+{
+#ifdef BSPETH_RX_QUEUE_MULTI_DESC
+	bspeth_destroy_hw_desc_queue(ld);
+#endif
+
+	return 0;
+}
+
+static void bspeth_get_phy_intf(struct bspeth_netdev_local *ld)
+{
+	char *mdio_intf = NULL;
+
+	/* get mdio interface from env.FORMAT: mdio_intf=mii or mdio_intf=rmii */
+	mdio_intf = getenv("mdio_intf");
+	if (mdio_intf != NULL) {
+		if (!strncmp(mdio_intf, "mii", strlen("mii"))) {
+			ld->phy_intf = INTERFACE_MODE_MII;
+		} else if (!strncmp(mdio_intf, "rmii", strlen("rmii"))) {
+			ld->phy_intf = INTERFACE_MODE_RMII;
+		} else {
+			printf("Invalid mdio_intf, should be mii or rmii.\n");
+			ld->phy_intf = INTERFACE_MODE_RMII;
+		}
+	}
+}
+
+static void bspeth_get_phy_addr(struct bspeth_netdev_local *ld)
+{
+	char *phyaddr = NULL;
+	char addr_name[MAX_PORT][10] = { "phyaddru", "phyaddrd" }; /* max name size is 10 */
+
+	if (ld->port >= MAX_PORT)
+		return;
+
+	/* get phy addr of up port */
+	phyaddr = getenv(addr_name[ld->port]);
+	if (phyaddr != NULL) {
+		unsigned long tmp = simple_strtoul(phyaddr, 0, 10); /* use Base10 */
+		/* check phyaddr > 0x1f */
+		if (tmp >= 0x1f) {
+			printf("Detected env '%s' had been set greater"
+				   "than 0x1f,this may not correct.\n",
+				   addr_name[ld->port]);
+			return;
+		}
+		ld->phy_addr = (unsigned char)tmp;
+	} else {
+#if defined(INNER_PHY)
+		if (ld->port == UP_PORT) {
+#if defined(INNER_PHY_ADDR_U)
+			ld->phy_addr = INNER_PHY_ADDR_U;
+#endif
+		} else {
+#if defined(INNER_PHY_ADDR_D)
+			ld->phy_addr = INNER_PHY_ADDR_D;
+#endif
+		}
+#endif
+	}
+}
+
+static void bspeth_exit(struct bspeth_netdev_local *ld)
+{
+	bspeth_mdiobus_driver_exit(ld);
+
+	bspeth_sys_exit();
+}
+
+int bspeth_init(struct eth_device *dev, bd_t *bd)
+{
+	struct bspeth_netdev_local *ld = (struct bspeth_netdev_local *)dev->priv;
+	int ret;
+	int count = 30;
+
+	bspeth_get_phy_intf(ld);
+
+	bspeth_get_phy_addr(ld);
+#ifdef INNER_PHY
+	if (ld->port == UP_PORT)
+		set_inner_phy_addr(ld->phy_addr);
+#endif
+
+	printf(OSDRV_MODULE_VERSION_STRING "\n");
+
+	set_efuse_unread();
+
+	/* sys-func-sel */
+	bspeth_sys_init();
+
+	/* register MDIO bus to uboot */
+	if (bspeth_mdiobus_driver_init(ld) != 0) {
+		goto _error_bspeth_init;
+	}
+
+	if (phy_detected(ld->mii_name, ld->phy_addr) == false) {
+		goto _error_bspeth_init;
+	}
+
+	miiphy_reset(ld->mii_name, ld->phy_addr);
+
+	ret = bspeth_dev_probe_init(ld);
+	if (ret) {
+		bspeth_error("register Ether netdevice"
+					" driver failed!");
+		goto _error_bspeth_init;
+	}
+
+	eth_set_host_mac_address(dev);
+
+	while (--count >= 0) {
+		/* open UpEther net dev */
+		bspeth_net_open(ld);
+		if (ld->link_stat & BSPETH_LINKED) {
+			return 0;
+		}
+	}
+
+	printf("PHY not link.\n");
+
+_error_bspeth_init:
+	bspeth_mdiobus_driver_exit(ld);
+	bspeth_net_close(ld);
+
+	return -1;
+}
+
+#ifdef BSPETH_RX_QUEUE_MULTI_DESC
+static int bspeth_recv(struct eth_device *dev)
+{
+	struct bspeth_netdev_local *ld = (struct bspeth_netdev_local *)dev->priv;
+	int recvq_ready, hw_offset, rec_offset;
+	int timeout_us = 10000;
+	struct bspeth_frame_desc *fd;
+	struct bspeth_frame_desc receive_fd;
+
+	fd = ld->bspeth_desc_head;
+	hw_offset = ld->desc_hw_offset;
+	rec_offset = ld->desc_rec_offset;
+
+	/* check this we can add a Rx addr */
+	recvq_ready = bspeth_readl_bits(ld, ud_reg_name(GLB_RO_QUEUE_STAT), BITS_RECVQ_RDY);
+	if (!recvq_ready)
+		bspeth_trace(BSPETH_TRACE_DRV, "hw can't add a rx addr.");
+
+	while (recvq_ready &&
+		   ((hw_offset + 1) % BSPETH_HW_DESC_DEPTH != rec_offset)) {
+		receive_fd = fd[hw_offset];
+		invalidate_dcache_range(receive_fd.frm_addr,
+								ALIGN(receive_fd.frm_addr + PKTSIZE_ALIGN, ARCH_DMA_MINALIGN));
+		hw_recvq_setfd(ld, receive_fd);
+
+		hw_offset = (hw_offset + 1) % BSPETH_HW_DESC_DEPTH;
+
+		recvq_ready =
+			bspeth_readl_bits(ld, ud_reg_name(GLB_RO_QUEUE_STAT),
+							 BITS_RECVQ_RDY);
+	}
+	ld->desc_hw_offset = hw_offset;
+
+	/* receive packed, loop in NetLoop */
+	while (--timeout_us && !is_recv_packet_rx(ld))
+		udelay(1);
+
+	if (is_recv_packet_rx(ld)) {
+		receive_fd = fd[rec_offset];
+
+		receive_fd.frm_len = hw_get_rxpkg_len(ld);
+		hw_set_rxpkg_finish(ld);
+
+		rec_offset = (rec_offset + 1) % BSPETH_HW_DESC_DEPTH;
+		ld->desc_rec_offset = rec_offset;
+
+		if (bspeth_invalid_rxpkg_len(receive_fd.frm_len)) {
+			bspeth_error("frm_len invalid (%u)", receive_fd.frm_len);
+			goto _error_exit;
+		}
+
+		invalidate_dcache_range(receive_fd.frm_addr,
+								ALIGN(receive_fd.frm_addr + receive_fd.frm_len, ARCH_DMA_MINALIGN));
+		memcpy((void *)net_rx_packets[0], (void *)receive_fd.frm_addr,
+			   receive_fd.frm_len);
+
+		/* Pass the packet up to the protocol layers. */
+		net_process_received_packet(net_rx_packets[0], receive_fd.frm_len);
+
+		return 0;
+	} else {
+		bspeth_trace(BSPETH_TRACE_DRV, "hw rx timeout.");
+	}
+
+_error_exit:
+	return -1;
+}
+#else
+static int bspeth_recv(struct eth_device *dev)
+{
+	struct bspeth_netdev_local *ld = (struct bspeth_netdev_local *)dev->priv;
+	int recvq_ready;
+	int timeout_us = 10000;
+	struct bspeth_frame_desc fd = { 0 };
+
+	/* check this we can add a Rx addr */
+	recvq_ready = bspeth_readl_bits(ld, ud_reg_name(GLB_RO_QUEUE_STAT), BITS_RECVQ_RDY);
+	if (!recvq_ready)
+		bspeth_trace(BSPETH_TRACE_DRV, "hw can't add a rx addr.");
+
+	/* enable rx int */
+	bspeth_irq_enable(ld, ud_bit_name(BSPETH_INT_RX_RDY));
+
+	/* fill rx hwq fd */
+	fd.frm_addr = (uintptr_t)net_rx_packets[0];
+	fd.frm_len = 0;
+	/* recv data will be put into DDR , in case of get the cache data, mush be invalid Dcache */
+	invalidate_dcache_range(fd.frm_addr, ALIGN(fd.frm_addr + PKTSIZE_ALIGN, ARCH_DMA_MINALIGN));
+
+	hw_recvq_setfd(ld, fd);
+
+	/* receive packed, loop in NetLoop */
+	while (--timeout_us && !is_recv_packet(ld))
+		udelay(1);
+
+	if (is_recv_packet(ld)) {
+		fd.frm_len = hw_get_rxpkg_len(ld);
+		hw_set_rxpkg_finish(ld);
+
+		if (bspeth_invalid_rxpkg_len(fd.frm_len)) {
+			bspeth_error("frm_len invalid (%u)", fd.frm_len);
+			goto _error_exit;
+		}
+
+		invalidate_dcache_range(fd.frm_addr,
+								ALIGN(fd.frm_addr + fd.frm_len, ARCH_DMA_MINALIGN));
+		/* Pass the packet up to the protocol layers. */
+		net_process_received_packet(net_rx_packets[0], fd.frm_len);
+
+		return 0;
+	} else {
+		bspeth_trace(BSPETH_TRACE_DRV, "hw rx timeout.");
+	}
+
+_error_exit:
+	return -1;
+}
+#endif
+
+#define ETH_FCS_LEN 4 /* Octets in the FCS */
+static int bspeth_send(struct eth_device *dev, void *packet, int length)
+{
+	struct bspeth_netdev_local *ld = (struct bspeth_netdev_local *)dev->priv;
+	unsigned int ints, xmitq_ready;
+	unsigned int timeout_us = 3000;
+	struct bspeth_frame_desc fd;
+
+	/* check this we can add a Tx addr */
+	xmitq_ready = bspeth_readl_bits(ld, ud_reg_name(GLB_RO_QUEUE_STAT), BITS_XMITQ_RDY);
+	if (!xmitq_ready) {
+		bspeth_error("hw can't add a tx addr");
+		goto _error_exit;
+	}
+
+	/* enable tx int */
+	bspeth_irq_enable(ld, ud_bit_name(BSPETH_INT_TXQUE_RDY));
+
+	flush_cache((uintptr_t)packet, ALIGN((unsigned int)length + ETH_FCS_LEN, ARCH_DMA_MINALIGN));
+	/* fill tx hwq fd */
+	fd.frm_addr = (uintptr_t)packet;
+	fd.frm_len = length + ETH_FCS_LEN;
+	hw_xmitq_setfd(ld, fd);
+
+	do {
+		udelay(1);
+		ints = bspeth_read_irqstatus(ld);
+	} while (--timeout_us && !(ints & ud_bit_name(BSPETH_INT_TXQUE_RDY)));
+
+	bspeth_clear_irqstatus(ld, ints);
+
+	if (!timeout_us) {
+		bspeth_error("hw tx timeout");
+		goto _error_exit;
+	}
+
+	return 0;
+
+_error_exit:
+	return -1;
+}
+
+static void bspeth_halt(struct eth_device *dev)
+{
+	struct bspeth_netdev_local *ld = (struct bspeth_netdev_local *)dev->priv;
+
+	bspeth_net_close(ld);
+
+	bspeth_dev_remove(ld);
+
+	bspeth_exit(ld);
+}
+
+static int bspeth_register_dev(unsigned char port_id)
+{
+	struct eth_device *dev;
+
+	dev = malloc(sizeof(*dev));
+	if (dev == NULL)
+		return -1;
+	memset(dev, 0, sizeof(*dev));
+
+	dev->iobase = REG_BASE_SF;
+	dev->init = bspeth_init;
+	dev->halt = bspeth_halt;
+	dev->send = bspeth_send;
+	dev->recv = bspeth_recv;
+	dev->priv = &bspeth_devs_priv[port_id];
+	bspeth_devs_priv[port_id].iobase_phys = REG_BASE_SF;
+	snprintf(dev->name, sizeof(dev->name) - 1, "eth%d", port_id);
+
+	eth_register(dev);
+
+	return 0;
+}
+
+int bspeth_initialize(bd_t *bis)
+{
+	int ret;
+
+	ret = bspeth_register_dev(UP_PORT);
+	if (ret)
+		return ret;
+
+	return 0;
+}
diff -uraN u-boot-2016.11/drivers/net/femac/sys.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/sys.c
--- u-boot-2016.11/drivers/net/femac/sys.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/sys.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,316 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#include <config.h>
+#include "bspeth.h"
+#include "sys.h"
+
+#define BSPETH_CRG_REG (CRG_REG_BASE + REG_ETH_CRG)
+
+
+#define ETH_SOFT_RESET bit(0)
+#define ETH_CLK_ENABLE bit(1)
+
+
+#if defined(SFV_RESET_PHY_BY_CRG)
+#define ETH_EXTERNAL_PHY_RESET bit(3)
+#endif
+
+#define ETH_CORE_CLK_SELECT_54M bit(7)
+
+#if ((defined CONFIG_TARGET_GK7205V200) || (defined CONFIG_TARGET_GK7205V300) || \
+	(defined CONFIG_TARGET_GK7202V300) || (defined CONFIG_TARGET_GK7605V100))
+
+#define BSPETH_SYSCTL_REG        (SYS_CTRL_REG_BASE + MISC_CTRL9)
+#define ETH_INTERNAL_PHY_RESET  bit(3)
+#define ETH_INTERNAL_PHY_CLK_EN bit(2)
+#endif
+
+#define BSPETH_CRG_INPHY_CLK_REG   BSPETH_CRG_REG
+#define BSPETH_CRG_EXTPHY_CLK_REG  BSPETH_CRG_REG
+
+
+#if 0
+void set_efuse_unread(void)
+{
+	u32 reg_value;
+
+	reg_value = readl(BSPETH_EFUSE_REG);
+	reg_value |= 0x1;
+	writel(reg_value, BSPETH_EFUSE_REG);
+
+	reg_value = readl(BSPETH_EFUSE_DATA_REG);
+	reg_value |= 0x1;
+	writel(reg_value, BSPETH_EFUSE_DATA_REG);
+
+	mdelay(300); /* delay 300ms */
+
+	reg_value = readl(BSPETH_EFUSE_REG);
+	reg_value &= ~0x1;
+	writel(reg_value, BSPETH_EFUSE_REG);
+}
+#else
+void set_efuse_unread(void)
+{
+}
+#endif
+
+#ifdef INNER_PHY
+void set_inner_phy_addr(u32 phy_addr)
+{
+	u32 reg_value;
+
+	reg_value = readl(BSPETH_SYSCTL_REG);
+	reg_value &= ~0x1f;
+	phy_addr &= 0x1f;
+	reg_value |= phy_addr;
+	writel(reg_value, BSPETH_SYSCTL_REG);
+}
+#else
+void set_inner_phy_addr(u32 phyaddr)
+{
+}
+#endif
+
+#if 0
+void revise_led_shine(void)
+{
+#define MDIO_RWCTRL      0x1100
+#define tmp_mdio_ready() \
+	(readl(REG_BASE_SF + MDIO_RWCTRL) & bit(15))
+
+	unsigned int reg_value;
+	/* select page 7 */
+	do {
+		reg_value = 0x0007235f;
+		writel(reg_value, REG_BASE_SF + MDIO_RWCTRL);
+		udelay(10); /* delay 10us */
+	} while (!tmp_mdio_ready());
+
+	/* enable LED modify function */
+	do {
+		reg_value = 0xc03c2353;
+		writel(reg_value, REG_BASE_SF + MDIO_RWCTRL);
+		udelay(10); /* delay 10us */
+	} while (!tmp_mdio_ready());
+
+	/* set green LED shine all the while when link up,
+	 * yellow LED blink when data coming
+	 */
+	do {
+		reg_value = 0x00382351;
+		writel(reg_value, REG_BASE_SF + MDIO_RWCTRL);
+		udelay(10); /* delay 10us */
+	} while (!tmp_mdio_ready());
+
+	return;
+}
+#else
+void revise_led_shine(void)
+{
+}
+#endif
+
+#if 0
+void set_phy_valtage(void)
+{
+#define MDIO_RWCTRL      0x1100
+#define tmp_mdio_ready() \
+	(readl(REG_BASE_SF + MDIO_RWCTRL) & bit(15))
+
+	unsigned int reg_value;
+	/* select page 1 */
+	do {
+		reg_value = 0x0001235f;
+		writel(reg_value, REG_BASE_SF + MDIO_RWCTRL);
+		udelay(10); /* delay 10us */
+	} while (!tmp_mdio_ready());
+
+	/* set fe-phy in lower valtage */
+	do {
+		reg_value = 0x94482352;
+		writel(reg_value, REG_BASE_SF + MDIO_RWCTRL);
+		udelay(10); /* delay 10us */
+	} while (!tmp_mdio_ready());
+
+	/* select page 0 */
+	do {
+		reg_value = 0x0000235f;
+		writel(reg_value, REG_BASE_SF + MDIO_RWCTRL);
+		udelay(10); /* delay 10us */
+	} while (!tmp_mdio_ready());
+}
+#else
+void set_phy_valtage(void)
+{
+}
+#endif
+
+static void bspeth_reset(int rst)
+{
+	u32 val;
+
+	val = _readl(BSPETH_CRG_REG);
+	if (rst) {
+		val |= ETH_SOFT_RESET;
+	} else {
+		val &= ~ETH_SOFT_RESET;
+	}
+	_writel(val, BSPETH_CRG_REG);
+
+	udelay(100); /* delay 100us */
+}
+
+static inline void bspeth_clk_ena(void)
+{
+	u32 val = _readl(BSPETH_CRG_REG);
+	val |= (ETH_CORE_CLK_SELECT_54M | ETH_CLK_ENABLE);
+	_writel(val, BSPETH_CRG_REG);
+}
+
+static inline void bspeth_clk_dis(void)
+{
+	u32 val = _readl(BSPETH_CRG_REG);
+	val &= ~ETH_CLK_ENABLE;
+	_writel(val, BSPETH_CRG_REG);
+}
+
+#if defined(INNER_PHY)
+static void bspeth_fephy_trim(void)
+{
+	/* To simplify internal FEPHY trim process,
+	 * we just delay 300ms to wait FEPHY auto-trim completed.
+	 * Not read trim data from EFUSE register.
+	 */
+	mdelay(350); /* delay 350ms */
+}
+#endif
+
+
+static void bspeth_reset_internal_phy(void)
+{
+#ifdef INNER_PHY
+	u32 rst;
+
+	/* disable MDCK clock to make sure FEPHY reset success */
+	bspeth_clk_dis();
+
+	rst = readl(BSPETH_CRG_INPHY_CLK_REG);
+	rst |= ETH_INTERNAL_PHY_CLK_EN;
+	/* internal FEPHY only support MII mode */
+
+	writel(rst, BSPETH_CRG_INPHY_CLK_REG);
+	udelay(10); /* delay 10us */
+
+	rst = _readl(BSPETH_CRG_INPHY_CLK_REG);
+	rst |= ETH_INTERNAL_PHY_RESET;
+	_writel(rst, BSPETH_CRG_INPHY_CLK_REG);
+	/* delay at least 10ms */
+	mdelay(15); /* delay 15ms */
+
+	rst = _readl(BSPETH_CRG_INPHY_CLK_REG);
+	rst &= ~ETH_INTERNAL_PHY_RESET;
+	_writel(rst, BSPETH_CRG_INPHY_CLK_REG);
+	/* delay at least 15ms for MDIO operation */
+	mdelay(20); /* delay 20ms */
+
+	bspeth_clk_ena();
+	/* delay 5ms after enable MDCK to make sure FEPHY trim safe */
+	mdelay(5); /* delay 5ms */
+	bspeth_fephy_trim();
+#endif
+}
+
+static void bspeth_reset_external_phy_by_crg(void)
+{
+#if defined(SFV_RESET_PHY_BY_CRG)
+	u32 v;
+
+	/************************************************/
+	/* reset external phy with default reset pin */
+	v = readl(BSPETH_CRG_EXTPHY_CLK_REG);
+	v |= ETH_EXTERNAL_PHY_RESET;
+	writel(v, BSPETH_CRG_EXTPHY_CLK_REG);
+
+	mdelay(50); /* delay 50ms */
+
+	/* then, cancel reset, and should delay some time */
+	v = readl(BSPETH_CRG_EXTPHY_CLK_REG);
+	v &= ~ETH_EXTERNAL_PHY_RESET;
+	writel(v, BSPETH_CRG_EXTPHY_CLK_REG);
+
+	mdelay(50); /* delay 50ms */
+#endif
+}
+
+static void bspeth_reset_external_phy_by_gpio(void)
+{
+#ifdef SFV_RESET_GPIO_EN
+	unsigned int val;
+	/* gpiox[x] set to reset, then delay 200ms */
+	val = __raw_readw(SFV_RESET_GPIO_BASE + SFV_RESET_GPIO_DIR);
+	val |= (SFV_RESET_GPIO_DIR_OUT << SFV_RESET_GPIO_BIT);
+	__raw_writew(val, SFV_RESET_GPIO_BASE + SFV_RESET_GPIO_DIR);
+	__raw_writew(SFV_RESET_GPIO_DATA,
+				 SFV_RESET_GPIO_BASE +
+				 (4 << SFV_RESET_GPIO_BIT)); /* offset addr 4 */
+
+	mdelay(200); /* delay 200ms */
+
+	/* then,cancel reset,and should delay 200ms */
+	val = __raw_readw(SFV_RESET_GPIO_BASE + SFV_RESET_GPIO_DIR);
+	val |= (SFV_RESET_GPIO_DIR_OUT << SFV_RESET_GPIO_BIT);
+	__raw_writew(val, SFV_RESET_GPIO_BASE + SFV_RESET_GPIO_DIR);
+	__raw_writew(((!SFV_RESET_GPIO_DATA) << SFV_RESET_GPIO_BIT),
+				 SFV_RESET_GPIO_BASE +
+				 (4 << SFV_RESET_GPIO_BIT)); /* offset addr 4 */
+
+	mdelay(20); /* delay 20ms */
+#endif
+}
+
+static void bspeth_phy_reset(void)
+{
+	bspeth_reset_internal_phy();
+	bspeth_reset_external_phy_by_crg();
+	bspeth_reset_external_phy_by_gpio();
+}
+
+static void bspeth_funsel_config(void)
+{
+}
+
+static void bspeth_funsel_restore(void)
+{
+}
+
+/**************************************************/
+void bspeth_sys_startup(void)
+{
+	bspeth_clk_ena();
+	/* undo reset */
+	bspeth_reset(0);
+}
+
+void bspeth_sys_allstop(void)
+{
+}
+
+void bspeth_sys_init(void)
+{
+	bspeth_funsel_config();
+	bspeth_sys_allstop();
+	bspeth_clk_ena();
+	bspeth_reset(1);
+	bspeth_reset(0);
+	bspeth_phy_reset();
+	revise_led_shine();
+}
+
+void bspeth_sys_exit(void)
+{
+	bspeth_funsel_restore();
+	bspeth_sys_allstop();
+}
diff -uraN u-boot-2016.11/drivers/net/femac/sys.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/sys.h
--- u-boot-2016.11/drivers/net/femac/sys.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/femac/sys.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,19 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __BSPETH_SYS_H__
+#define __BSPETH_SYS_H__
+
+void bspeth_sys_init(void);
+void bspeth_sys_exit(void);
+
+void bspeth_set_crg_phy_mode(unsigned char is_rmii_mode);
+void set_inner_phy_addr(u32 phyaddr);
+void set_efuse_unread(void);
+
+void bspeth_sys_startup(void);
+void bspeth_sys_allstop(void);
+
+void set_phy_valtage(void);
+#endif
diff -uraN u-boot-2016.11/drivers/net/Kconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/Kconfig
--- u-boot-2016.11/drivers/net/Kconfig	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/Kconfig	2021-06-07 13:01:32.000000000 +0300
@@ -215,4 +215,7 @@
 	  This driver implements 10/100 Mbps Ethernet and MAC layer for
 	  Microchip PIC32 microcontrollers.
 
+config NET_FEMAC
+	bool "Vendor Ethernet femac family network Support"
+
 endif # NETDEVICES
diff -uraN u-boot-2016.11/drivers/net/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/Makefile
--- u-boot-2016.11/drivers/net/Makefile	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/net/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -77,3 +77,4 @@
 obj-$(CONFIG_VSC9953) += vsc9953.o
 obj-$(CONFIG_PIC32_ETH) += pic32_mdio.o pic32_eth.o
 obj-$(CONFIG_DWC_ETH_QOS) += dwc_eth_qos.o
+obj-$(CONFIG_NET_FEMAC) += femac/
diff -uraN u-boot-2016.11/drivers/phy/goke/Kconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/phy/goke/Kconfig
--- u-boot-2016.11/drivers/phy/goke/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/phy/goke/Kconfig	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,9 @@
+
+config PHY_VENDOR_USB
+	bool "Goke usb phy driver"
+	default y
+	---help---
+	  support for PHY on Goke Socs. This Phy supports
+	  USB 1.5Mb/s, USB 12Mb/s, USB 480Mb/s speeds. It suppots one
+	  USB host port to accept one USB device. Support init the phy
+	  and adjust phy Eye Diagram.
diff -uraN u-boot-2016.11/drivers/phy/goke/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/phy/goke/Makefile
--- u-boot-2016.11/drivers/phy/goke/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/phy/goke/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,4 @@
+obj-$(CONFIG_TARGET_GK7202V300) += phy-gk7202v300-usb.o
+obj-$(CONFIG_TARGET_GK7205V200) += phy-gk7205v200-usb.o
+obj-$(CONFIG_TARGET_GK7205V300) += phy-gk7205v300-usb.o
+obj-$(CONFIG_TARGET_GK7605V100) += phy-gk7605v100-usb.o
\ No newline at end of file
diff -uraN u-boot-2016.11/drivers/phy/goke/phy-gk7202v300-usb.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/phy/goke/phy-gk7202v300-usb.c
--- u-boot-2016.11/drivers/phy/goke/phy-gk7202v300-usb.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/phy/goke/phy-gk7202v300-usb.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,307 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifdef CONFIG_PHY_VENDOR_USB
+#include <asm/arch-gk7202v300/platform.h>
+#include <dm.h>
+#include "../../usb/host/xhci.h"
+#include "phy-usb.h"
+
+/* offset 0x140 */
+#define USB2_CTRL				0x140
+#define USB2_CRG_DEFAULT_VAL	0x3b2f
+#define USB2_UTMI_CKEN			(0x1 << 12)
+#define USB2_PHY_APB_CKEN		(0x1 << 11)
+#define USB2_REF_CKEN			(0x1 << 9)
+#define USB2_BUS_CKEN			(0x1 << 8)
+#define USB2_PHY_PLL_CKEN		(0x1 << 4)
+#define USB2_PHY_XTAL_CKEN		(0x1 << 2)
+#define USB2_FREECLK_CKSEL		(0x1 << 13)
+#define USB2_PHY_APB_RST		(0x1 << 10)
+#define USB2_VCC_SRST_REQ		(0x1 << 3)
+#define USB2_PHY_REQ			(0x1 << 0)
+#define USB2_PHY_PORT_TREQ		(0x1 << 1)
+
+#define GTXTHRCFG				0xc108
+#define GRXTHRCFG				0xc10c
+#define REG_GCTL				0xc110
+#define REG_GUSB3PIPECTL0		0xc2c0
+#define PCS_SSP_SOFT_RESET		(0x1 << 31)
+
+#define PORT_CAP_DIR			(0x3 << 12)
+#define PORT_SET_HOST			(0x1 << 12)
+#define PORT_DISABLE_SUSPEND	(0x1 << 17)
+
+
+#define	USB2_G_TXTHRCFG			0x23100000
+#define	USB2_G_RXTHRCFG			0x23100000
+
+/* PHY base register */
+#define USB2_PHY_BASE_REG		0x100D0000
+#define RG_PLL_EN_MASK			0x0003
+#define RG_PLL_EN_VAL			0x0003
+#define PHY_PLL_OFFSET			0x0014
+
+#define USB_VBUS_IO_CONFIG_REG	0x100c007C
+#define USB_VBUS_IO_CONFIG_VAL	0x0531
+
+#define USB_PWREN_CONFIG_REG	0x100c0080
+#define USB_PWREN_CONFIG_VAL	0x1
+
+/* PHY eye config */
+#define PHY_ANA_CFG_0_OFFSET			0x00
+#define PHY_PRE_DRIVE_MASK			(0xf << 24)
+#define PHY_PRE_DRIVE_VAL				(0x4 << 24)
+#define PHY_HSTX_DE_MASK			(0xf << 8)
+#define PHY_HSTX_DE_VAL				(0xc << 8)
+#define PHY_HSTX_DEEN_BIT				(0x1 << 5)
+#define PHY_ANA_CFG_2_OFFSET			0x08
+#define PHY_TX_TEST_BIT				(0x1 << 20)
+#define PHY_HALF_DEEM_BIT				(0x1 << 21)
+#define PHY_DISCONNECT_REFERENCE_MASK	(0x7 << 16)
+#define PHY_DISCONNECT_REFERENCE_VAL	(0x2 << 16)
+#define PHY_ANA_CFG_4_OFFSET			0x10
+#define PHY_TX_REFERENCE_MASK			(0x7 << 4)
+#define PHY_TX_REFERENCE_VAL			(0x5 << 4)
+#define PHY_SQUELCH_REFERENCE_MASK	(0x7 << 0)
+#define PHY_SQUELCH_REFERENCE_VAL		(0x5 << 0)
+
+/* PHY trim config */
+#define USB_TRIM_BASE_REG					0x12028004
+#define USB_TRIM_VAL_MASK					0x001F
+#define USB_TRIM_VAL_MIN					0x0009
+#define USB_TRIM_VAL_MAX					0x001D
+#define USB2_TRIM_OFFSET					0x0008
+#define USB2_TRIM_MASK						0x1f00
+#define usb2_trim_val(a)					(((a) << 8) & USB2_TRIM_MASK)
+#define USB2_TRIM_DEFAULT_VAL				0x000F
+
+static uintptr_t xhci_base = 0;
+
+int xhci_hcd_init(int index, struct xhci_hccr **hccr, struct xhci_hcor **hcor)
+{
+	if ((hccr == NULL) || (hcor == NULL))
+		return -EINVAL;
+
+	xhci_base = USB3_CTRL_REG_BASE;
+
+	*hccr = (struct xhci_hccr *)(xhci_base);
+	*hcor = (struct xhci_hcor *)((uintptr_t) *hccr +
+				HC_LENGTH(xhci_readl(&(*hccr)->cr_capbase)));
+
+	return 0;
+}
+
+void usb2_eye_config(void)
+{
+	unsigned int reg;
+	/* HSTX pre-drive strength */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_0_OFFSET);
+	reg &= ~PHY_PRE_DRIVE_MASK;
+	reg |= PHY_PRE_DRIVE_VAL;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_0_OFFSET);
+
+	/* HSTX de-emphasis strength */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_0_OFFSET);
+	reg &= ~PHY_HSTX_DE_MASK;
+	reg |= PHY_HSTX_DE_VAL;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_0_OFFSET);
+
+	/* HSTX de-emphasis enable */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_0_OFFSET);
+	reg |= PHY_HSTX_DEEN_BIT;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_0_OFFSET);
+
+	/* TX test bit */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_2_OFFSET);
+	reg |= PHY_TX_TEST_BIT;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_2_OFFSET);
+
+	/* TX half de-emphasis bit */
+	reg = readl(USB2_PHY_BASE_REG + XVP_PHY_ANA_CFG_2_OFFSET);
+	reg |= PHY_HALF_DEEM_BIT;
+	writel(reg, USB2_PHY_BASE_REG + XVP_PHY_ANA_CFG_2_OFFSET);
+
+	/* Disconnect reference voltage sel */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_2_OFFSET);
+	reg &= ~PHY_DISCONNECT_REFERENCE_MASK;
+	reg |= PHY_DISCONNECT_REFERENCE_VAL;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_2_OFFSET);
+
+	/* TX reference voltage sel */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_4_OFFSET);
+	reg &= ~PHY_TX_REFERENCE_MASK;
+	reg |= PHY_TX_REFERENCE_VAL;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_4_OFFSET);
+
+	/* Squlech reference voltage sel */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_4_OFFSET);
+	reg &= ~PHY_SQUELCH_REFERENCE_MASK;
+	reg |= PHY_SQUELCH_REFERENCE_VAL;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_4_OFFSET);
+}
+
+void usb2_trim_config(void)
+{
+	unsigned int ret;
+	unsigned int reg;
+	unsigned int trim_val;
+
+	ret = readl(USB_TRIM_BASE_REG);
+	trim_val = (ret & USB_TRIM_VAL_MASK); /* get usb trim value */
+	reg = readl(USB2_PHY_BASE_REG + USB2_TRIM_OFFSET);
+	reg &= ~USB2_TRIM_MASK;
+	if ((trim_val >= USB_TRIM_VAL_MIN) && (trim_val <= USB_TRIM_VAL_MAX))
+		reg |= usb2_trim_val(trim_val);
+	else
+		reg |= usb2_trim_val(USB2_TRIM_DEFAULT_VAL);
+
+	writel(reg, USB2_PHY_BASE_REG + USB2_TRIM_OFFSET);
+}
+
+void phy_usb_init_crg_clk(int index)
+{
+	unsigned int reg;
+
+	/* set usb2 CRG default val */
+	reg = USB2_CRG_DEFAULT_VAL;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+	udelay(U_LEVEL6);
+
+	/* open UTMI clk */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_UTMI_CKEN;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* open phy apb clk */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_PHY_APB_CKEN;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* open ctrl ref clk */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_REF_CKEN;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* open bus clk */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_BUS_CKEN;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* open phy pll clk */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_PHY_PLL_CKEN;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* open phy xtal clk */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_PHY_XTAL_CKEN;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* freeclk_cksel_free */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_FREECLK_CKSEL;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	udelay(U_LEVEL5);
+}
+
+void phy_usb_init(int index)
+{
+	unsigned int reg;
+
+	/* VBUS config */
+	reg = USB_VBUS_IO_CONFIG_VAL;
+	writel(reg, USB_VBUS_IO_CONFIG_REG);
+
+	reg = USB_PWREN_CONFIG_VAL;
+	writel(reg, USB_PWREN_CONFIG_REG);
+
+	/* init crg and clk */
+	phy_usb_init_crg_clk(index);
+
+	/* release phy apb */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg &= ~USB2_PHY_APB_RST;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	udelay(U_LEVEL5);
+
+	/* por noreset */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg &= ~USB2_PHY_REQ;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	reg = readl(USB2_PHY_BASE_REG + PHY_PLL_OFFSET);
+	reg &= ~RG_PLL_EN_MASK;
+	reg |= RG_PLL_EN_VAL;
+	writel(reg, USB2_PHY_BASE_REG + PHY_PLL_OFFSET);
+
+	udelay(U_LEVEL10);
+
+	/* cancel TPOR */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg &= ~USB2_PHY_PORT_TREQ;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+	udelay(U_LEVEL6);
+
+	/* vcc reset */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg &= ~USB2_VCC_SRST_REQ;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* USB2 Controller configs */
+	reg = readl(USB3_CTRL_REG_BASE + REG_GUSB3PIPECTL0);
+	reg |= PCS_SSP_SOFT_RESET;
+	writel(reg, USB3_CTRL_REG_BASE + REG_GUSB3PIPECTL0);
+	udelay(U_LEVEL2);
+
+	reg = readl(USB3_CTRL_REG_BASE + REG_GCTL);
+	reg &= ~PORT_CAP_DIR;
+	reg |= PORT_SET_HOST; /* [13:12] 01: Host; 10: Device; 11: OTG */
+	writel(reg, USB3_CTRL_REG_BASE + REG_GCTL);
+	udelay(U_LEVEL2);
+
+	reg = readl(USB3_CTRL_REG_BASE + REG_GUSB3PIPECTL0);
+	reg &= ~PCS_SSP_SOFT_RESET;
+	reg &= ~PORT_DISABLE_SUSPEND; /* disable suspend */
+	writel(reg, USB3_CTRL_REG_BASE + REG_GUSB3PIPECTL0);
+	udelay(U_LEVEL2);
+
+	writel(USB2_G_TXTHRCFG, USB3_CTRL_REG_BASE + GTXTHRCFG);
+	writel(USB2_G_RXTHRCFG, USB3_CTRL_REG_BASE + GRXTHRCFG);
+	udelay(U_LEVEL2);
+
+	/* USB2 eye config */
+	usb2_eye_config();
+
+	/* USB2 trim config */
+	usb2_trim_config();
+}
+EXPORT_SYMBOL(phy_usb_init);
+
+void xhci_hcd_stop(int index)
+{
+	unsigned int reg;
+
+	/* por noreset */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_PHY_REQ;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	udelay(U_LEVEL10);
+
+	/* cancel TPOR */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_PHY_PORT_TREQ;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+	udelay(U_LEVEL6);
+
+	/* vcc reset */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_VCC_SRST_REQ;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+}
+EXPORT_SYMBOL(xhci_hcd_stop);
+#endif
\ No newline at end of file
diff -uraN u-boot-2016.11/drivers/phy/goke/phy-gk7205v200-usb.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/phy/goke/phy-gk7205v200-usb.c
--- u-boot-2016.11/drivers/phy/goke/phy-gk7205v200-usb.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/phy/goke/phy-gk7205v200-usb.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,306 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifdef CONFIG_PHY_VENDOR_USB
+#include <asm/arch-gk7205v200/platform.h>
+#include <dm.h>
+#include "../../usb/host/xhci.h"
+#include "phy-usb.h"
+
+/* offset 0x140 */
+#define USB2_CTRL				0x140
+#define USB2_CRG_DEFAULT_VAL	0x3b2f
+#define USB2_UTMI_CKEN			(0x1 << 12)
+#define USB2_PHY_APB_CKEN		(0x1 << 11)
+#define USB2_REF_CKEN			(0x1 << 9)
+#define USB2_BUS_CKEN			(0x1 << 8)
+#define USB2_PHY_PLL_CKEN		(0x1 << 4)
+#define USB2_PHY_XTAL_CKEN		(0x1 << 2)
+#define USB2_FREECLK_CKSEL		(0x1 << 13)
+#define USB2_PHY_APB_RST		(0x1 << 10)
+#define USB2_VCC_SRST_REQ		(0x1 << 3)
+#define USB2_PHY_REQ			(0x1 << 0)
+#define USB2_PHY_PORT_TREQ		(0x1 << 1)
+
+#define GTXTHRCFG				0xc108
+#define GRXTHRCFG				0xc10c
+#define REG_GCTL				0xc110
+#define REG_GUSB3PIPECTL0		0xc2c0
+#define PCS_SSP_SOFT_RESET		(0x1 << 31)
+
+#define PORT_CAP_DIR			(0x3 << 12)
+#define PORT_SET_HOST			(0x1 << 12)
+#define PORT_DISABLE_SUSPEND	(0x1 << 17)
+
+#define USB2_G_TXTHRCFG			0x23100000
+#define USB2_G_RXTHRCFG			0x23100000
+
+/* PHY base register */
+#define USB2_PHY_BASE_REG		0x100D0000
+#define RG_PLL_EN_MASK			0x0003
+#define RG_PLL_EN_VAL			0x0003
+#define PHY_PLL_OFFSET			0x0014
+
+#define USB_VBUS_IO_CONFIG_REG	0x100c007C
+#define USB_VBUS_IO_CONFIG_VAL	0x0531
+
+#define USB_PWREN_CONFIG_REG	0x100c0080
+#define USB_PWREN_CONFIG_VAL	0x1
+
+/* PHY eye config */
+#define PHY_ANA_CFG_0_OFFSET			0x00
+#define PHY_PRE_DRIVE_MASK			(0xf << 24)
+#define PHY_PRE_DRIVE_VAL				(0x4 << 24)
+#define PHY_HSTX_DE_MASK			(0xf << 8)
+#define PHY_HSTX_DE_VAL				(0xc << 8)
+#define PHY_HSTX_DEEN_BIT				(0x1 << 5)
+#define PHY_ANA_CFG_2_OFFSET			0x08
+#define PHY_TX_TEST_BIT				(0x1 << 20)
+#define PHY_HALF_DEEM_BIT				(0x1 << 21)
+#define PHY_DISCONNECT_REFERENCE_MASK	(0x7 << 16)
+#define PHY_DISCONNECT_REFERENCE_VAL	(0x2 << 16)
+#define PHY_ANA_CFG_4_OFFSET			0x10
+#define PHY_TX_REFERENCE_MASK			(0x7 << 4)
+#define PHY_TX_REFERENCE_VAL			(0x5 << 4)
+#define PHY_SQUELCH_REFERENCE_MASK	(0x7 << 0)
+#define PHY_SQUELCH_REFERENCE_VAL		(0x5 << 0)
+
+/* PHY trim config */
+#define USB_TRIM_BASE_REG					0x12028004
+#define USB_TRIM_VAL_MASK					0x001F
+#define USB_TRIM_VAL_MIN					0x0009
+#define USB_TRIM_VAL_MAX					0x001D
+#define USB2_TRIM_OFFSET					0x0008
+#define USB2_TRIM_MASK						0x1f00
+#define usb2_trim_val(a)					(((a) << 8) & USB2_TRIM_MASK)
+#define USB2_TRIM_DEFAULT_VAL				0x000F
+
+static uintptr_t xhci_base = 0;
+
+int xhci_hcd_init(int index, struct xhci_hccr **hccr, struct xhci_hcor **hcor)
+{
+	if ((hccr == NULL) || (hcor == NULL))
+		return -EINVAL;
+
+	xhci_base = USB3_CTRL_REG_BASE;
+
+	*hccr = (struct xhci_hccr *)(xhci_base);
+	*hcor = (struct xhci_hcor *)((uintptr_t) *hccr +
+				HC_LENGTH(xhci_readl(&(*hccr)->cr_capbase)));
+
+	return 0;
+}
+
+void usb2_eye_config(void)
+{
+	unsigned int reg;
+	/* HSTX pre-drive strength */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_0_OFFSET);
+	reg &= ~PHY_PRE_DRIVE_MASK;
+	reg |= PHY_PRE_DRIVE_VAL;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_0_OFFSET);
+
+	/* HSTX de-emphasis strength */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_0_OFFSET);
+	reg &= ~PHY_HSTX_DE_MASK;
+	reg |= PHY_HSTX_DE_VAL;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_0_OFFSET);
+
+	/* HSTX de-emphasis enable */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_0_OFFSET);
+	reg |= PHY_HSTX_DEEN_BIT;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_0_OFFSET);
+
+	/* TX test bit */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_2_OFFSET);
+	reg |= PHY_TX_TEST_BIT;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_2_OFFSET);
+
+	/* TX half de-emphasis bit */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_2_OFFSET);
+	reg |= PHY_HALF_DEEM_BIT;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_2_OFFSET);
+
+	/* Disconnect reference voltage sel */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_2_OFFSET);
+	reg &= ~PHY_DISCONNECT_REFERENCE_MASK;
+	reg |= PHY_DISCONNECT_REFERENCE_VAL;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_2_OFFSET);
+
+	/* TX reference voltage sel */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_4_OFFSET);
+	reg &= ~PHY_TX_REFERENCE_MASK;
+	reg |= PHY_TX_REFERENCE_VAL;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_4_OFFSET);
+
+	/* Squlech reference voltage sel */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_4_OFFSET);
+	reg &= ~PHY_SQUELCH_REFERENCE_MASK;
+	reg |= PHY_SQUELCH_REFERENCE_VAL;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_4_OFFSET);
+}
+
+void usb2_trim_config(void)
+{
+	unsigned int ret;
+	unsigned int reg;
+	unsigned int trim_val;
+
+	ret = readl(USB_TRIM_BASE_REG);
+	trim_val = (ret & USB_TRIM_VAL_MASK); /* get usb trim value */
+	reg = readl(USB2_PHY_BASE_REG + USB2_TRIM_OFFSET);
+	reg &= ~USB2_TRIM_MASK;
+	if ((trim_val >= USB_TRIM_VAL_MIN) && (trim_val <= USB_TRIM_VAL_MAX))
+		reg |= usb2_trim_val(trim_val);
+	else
+		reg |= usb2_trim_val(USB2_TRIM_DEFAULT_VAL);
+
+	writel(reg, USB2_PHY_BASE_REG + USB2_TRIM_OFFSET);
+}
+
+void phy_usb_init_crg_clk(int index)
+{
+	unsigned int reg;
+
+	/* set usb2 CRG default val */
+	reg = USB2_CRG_DEFAULT_VAL;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+	udelay(U_LEVEL6);
+
+	/* open UTMI clk */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_UTMI_CKEN;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* open phy apb clk */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_PHY_APB_CKEN;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* open ctrl ref clk */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_REF_CKEN;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* open bus clk */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_BUS_CKEN;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* open phy pll clk */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_PHY_PLL_CKEN;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* open phy xtal clk */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_PHY_XTAL_CKEN;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* freeclk_cksel_free */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_FREECLK_CKSEL;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	udelay(U_LEVEL5);
+}
+
+void phy_usb_init(int index)
+{
+	unsigned int reg;
+
+	/* VBUS config */
+	reg = USB_VBUS_IO_CONFIG_VAL;
+	writel(reg, USB_VBUS_IO_CONFIG_REG);
+
+	reg = USB_PWREN_CONFIG_VAL;
+	writel(reg, USB_PWREN_CONFIG_REG);
+
+	/* init crg and clk */
+	phy_usb_init_crg_clk(index);
+
+	/* release phy apb */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg &= ~USB2_PHY_APB_RST;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	udelay(U_LEVEL5);
+
+	/* por noreset */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg &= ~USB2_PHY_REQ;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	reg = readl(USB2_PHY_BASE_REG + PHY_PLL_OFFSET);
+	reg &= ~RG_PLL_EN_MASK;
+	reg |= RG_PLL_EN_VAL;
+	writel(reg, USB2_PHY_BASE_REG + PHY_PLL_OFFSET);
+
+	udelay(U_LEVEL10);
+
+	/* cancel TPOR */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg &= ~USB2_PHY_PORT_TREQ;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+	udelay(U_LEVEL6);
+
+	/* vcc reset */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg &= ~USB2_VCC_SRST_REQ;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* USB2 Controller configs */
+	reg = readl(USB3_CTRL_REG_BASE + REG_GUSB3PIPECTL0);
+	reg |= PCS_SSP_SOFT_RESET;
+	writel(reg, USB3_CTRL_REG_BASE + REG_GUSB3PIPECTL0);
+	udelay(U_LEVEL2);
+
+	reg = readl(USB3_CTRL_REG_BASE + REG_GCTL);
+	reg &= ~PORT_CAP_DIR;
+	reg |= PORT_SET_HOST; /* [13:12] 01: Host; 10: Device; 11: OTG */
+	writel(reg, USB3_CTRL_REG_BASE + REG_GCTL);
+	udelay(U_LEVEL2);
+
+	reg = readl(USB3_CTRL_REG_BASE + REG_GUSB3PIPECTL0);
+	reg &= ~PCS_SSP_SOFT_RESET;
+	reg &= ~PORT_DISABLE_SUSPEND; /* disable suspend */
+	writel(reg, USB3_CTRL_REG_BASE + REG_GUSB3PIPECTL0);
+	udelay(U_LEVEL2);
+
+	writel(USB2_G_TXTHRCFG, USB3_CTRL_REG_BASE + GTXTHRCFG);
+	writel(USB2_G_RXTHRCFG, USB3_CTRL_REG_BASE + GRXTHRCFG);
+	udelay(U_LEVEL2);
+
+	/* USB2 eye config */
+	usb2_eye_config();
+
+	/* USB2 trim config */
+	usb2_trim_config();
+}
+EXPORT_SYMBOL(phy_usb_init);
+
+void xhci_hcd_stop(int index)
+{
+	unsigned int reg;
+
+	/* por noreset */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_PHY_REQ;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	udelay(U_LEVEL10);
+
+	/* cancel TPOR */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_PHY_PORT_TREQ;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+	udelay(U_LEVEL6);
+
+	/* vcc reset */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_VCC_SRST_REQ;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+}
+EXPORT_SYMBOL(xhci_hcd_stop);
+#endif
\ No newline at end of file
diff -uraN u-boot-2016.11/drivers/phy/goke/phy-gk7205v300-usb.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/phy/goke/phy-gk7205v300-usb.c
--- u-boot-2016.11/drivers/phy/goke/phy-gk7205v300-usb.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/phy/goke/phy-gk7205v300-usb.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,307 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifdef CONFIG_PHY_VENDOR_USB
+#include <asm/arch-gk7205v300/platform.h>
+#include <dm.h>
+#include "../../usb/host/xhci.h"
+#include "phy-usb.h"
+
+/* offset 0x140 */
+#define USB2_CTRL				0x140
+#define USB2_CRG_DEFAULT_VAL	0x3b2f
+#define USB2_UTMI_CKEN			(0x1 << 12)
+#define USB2_PHY_APB_CKEN		(0x1 << 11)
+#define USB2_REF_CKEN			(0x1 << 9)
+#define USB2_BUS_CKEN			(0x1 << 8)
+#define USB2_PHY_PLL_CKEN		(0x1 << 4)
+#define USB2_PHY_XTAL_CKEN		(0x1 << 2)
+#define USB2_FREECLK_CKSEL		(0x1 << 13)
+#define USB2_PHY_APB_RST		(0x1 << 10)
+#define USB2_VCC_SRST_REQ		(0x1 << 3)
+#define USB2_PHY_REQ			(0x1 << 0)
+#define USB2_PHY_PORT_TREQ		(0x1 << 1)
+
+
+#define GTXTHRCFG				0xc108
+#define GRXTHRCFG				0xc10c
+#define REG_GCTL				0xc110
+#define REG_GUSB3PIPECTL0		0xc2c0
+#define PCS_SSP_SOFT_RESET		(0x1 << 31)
+
+#define PORT_CAP_DIR			(0x3 << 12)
+#define PORT_SET_HOST			(0x1 << 12)
+#define PORT_DISABLE_SUSPEND	(0x1 << 17)
+
+
+#define	USB2_G_TXTHRCFG			0x23100000
+#define	USB2_G_RXTHRCFG			0x23100000
+
+/* PHY base register */
+#define USB2_PHY_BASE_REG		0x100D0000
+#define RG_PLL_EN_MASK			0x0003
+#define RG_PLL_EN_VAL			0x0003
+#define PHY_PLL_OFFSET			0x0014
+
+#define USB_VBUS_IO_CONFIG_REG	0x100c007C
+#define USB_VBUS_IO_CONFIG_VAL	0x0431
+
+#define USB_PWREN_CONFIG_REG	0x100c0080
+#define USB_PWREN_CONFIG_VAL	0x1
+
+/* PHY eye config */
+#define PHY_ANA_CFG_0_OFFSET			0x00
+#define PHY_PRE_DRIVE_MASK			(0xf << 24)
+#define PHY_PRE_DRIVE_VAL				(0x4 << 24)
+#define PHY_HSTX_DE_MASK			(0xf << 8)
+#define PHY_HSTX_DE_VAL				(0xc << 8)
+#define PHY_HSTX_DEEN_BIT				(0x1 << 5)
+#define PHY_ANA_CFG_2_OFFSET			0x08
+#define PHY_TX_TEST_BIT				(0x1 << 20)
+#define PHY_HALF_DEEM_BIT				(0x1 << 21)
+#define PHY_DISCONNECT_REFERENCE_MASK	(0x7 << 16)
+#define PHY_DISCONNECT_REFERENCE_VAL	(0x2 << 16)
+#define PHY_ANA_CFG_4_OFFSET			0x10
+#define PHY_TX_REFERENCE_MASK			(0x7 << 4)
+#define PHY_TX_REFERENCE_VAL			(0x5 << 4)
+#define PHY_SQUELCH_REFERENCE_MASK	(0x7 << 0)
+#define PHY_SQUELCH_REFERENCE_VAL		(0x5 << 0)
+
+/* PHY trim config */
+#define USB_TRIM_BASE_REG					0x12028004
+#define USB_TRIM_VAL_MASK					0x001F
+#define USB_TRIM_VAL_MIN					0x0009
+#define USB_TRIM_VAL_MAX					0x001D
+#define USB2_TRIM_OFFSET					0x0008
+#define USB2_TRIM_MASK						0x1f00
+#define usb2_trim_val(a)					(((a) << 8) & USB2_TRIM_MASK)
+#define USB2_TRIM_DEFAULT_VAL				0x000F
+
+static uintptr_t xhci_base = 0;
+
+int xhci_hcd_init(int index, struct xhci_hccr **hccr, struct xhci_hcor **hcor)
+{
+	if ((hccr == NULL) || (hcor == NULL))
+		return -EINVAL;
+
+	xhci_base = USB3_CTRL_REG_BASE;
+
+	*hccr = (struct xhci_hccr *)(xhci_base);
+	*hcor = (struct xhci_hcor *)((uintptr_t) *hccr +
+				HC_LENGTH(xhci_readl(&(*hccr)->cr_capbase)));
+
+	return 0;
+}
+
+void usb2_eye_config(void)
+{
+	unsigned int reg;
+	/* HSTX pre-drive strength */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_0_OFFSET);
+	reg &= ~PHY_PRE_DRIVE_MASK;
+	reg |= PHY_PRE_DRIVE_VAL;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_0_OFFSET);
+
+	/* HSTX de-emphasis strength */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_0_OFFSET);
+	reg &= ~PHY_HSTX_DE_MASK;
+	reg |= PHY_HSTX_DE_VAL;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_0_OFFSET);
+
+	/* HSTX de-emphasis enable */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_0_OFFSET);
+	reg |= PHY_HSTX_DEEN_BIT;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_0_OFFSET);
+
+	/* TX test bit */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_2_OFFSET);
+	reg |= PHY_TX_TEST_BIT;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_2_OFFSET);
+
+	/* TX half de-emphasis bit */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_2_OFFSET);
+	reg |= PHY_HALF_DEEM_BIT;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_2_OFFSET);
+
+	/* Disconnect reference voltage sel */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_2_OFFSET);
+	reg &= ~PHY_DISCONNECT_REFERENCE_MASK;
+	reg |= PHY_DISCONNECT_REFERENCE_VAL;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_2_OFFSET);
+
+	/* TX reference voltage sel */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_4_OFFSET);
+	reg &= ~PHY_TX_REFERENCE_MASK;
+	reg |= PHY_TX_REFERENCE_VAL;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_4_OFFSET);
+
+	/* Squlech reference voltage sel */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_4_OFFSET);
+	reg &= ~PHY_SQUELCH_REFERENCE_MASK;
+	reg |= PHY_SQUELCH_REFERENCE_VAL;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_4_OFFSET);
+}
+
+void usb2_trim_config(void)
+{
+	unsigned int ret;
+	unsigned int reg;
+	unsigned int trim_val;
+
+	ret = readl(USB_TRIM_BASE_REG);
+	trim_val = (ret & USB_TRIM_VAL_MASK); /* get usb trim value */
+	reg = readl(USB2_PHY_BASE_REG + USB2_TRIM_OFFSET);
+	reg &= ~USB2_TRIM_MASK;
+	if ((trim_val >= USB_TRIM_VAL_MIN) && (trim_val <= USB_TRIM_VAL_MAX))
+		reg |= usb2_trim_val(trim_val);
+	else
+		reg |= usb2_trim_val(USB2_TRIM_DEFAULT_VAL);
+
+	writel(reg, USB2_PHY_BASE_REG + USB2_TRIM_OFFSET);
+}
+
+void phy_usb_init_crg_clk(int index)
+{
+	unsigned int reg;
+	/* set usb2 CRG default val */
+	reg = USB2_CRG_DEFAULT_VAL;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+	udelay(U_LEVEL6);
+
+	/* open UTMI clk */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_UTMI_CKEN;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* open phy apb clk */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_PHY_APB_CKEN;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* open ctrl ref clk */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_REF_CKEN;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* open bus clk */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_BUS_CKEN;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* open phy pll clk */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_PHY_PLL_CKEN;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* open phy xtal clk */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_PHY_XTAL_CKEN;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* freeclk_cksel_free */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_FREECLK_CKSEL;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	udelay(U_LEVEL5);
+}
+
+void phy_usb_init(int index)
+{
+	unsigned int reg;
+
+	/* VBUS config */
+	reg = USB_VBUS_IO_CONFIG_VAL;
+	writel(reg, USB_VBUS_IO_CONFIG_REG);
+
+	reg = USB_PWREN_CONFIG_VAL;
+	writel(reg, USB_PWREN_CONFIG_REG);
+
+	/* init crg and clk */
+	phy_usb_init_crg_clk(index);
+
+	/* release phy apb */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg &= ~USB2_PHY_APB_RST;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	udelay(U_LEVEL5);
+
+	/* por noreset */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg &= ~USB2_PHY_REQ;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	reg = readl(USB2_PHY_BASE_REG + PHY_PLL_OFFSET);
+	reg &= ~RG_PLL_EN_MASK;
+	reg |= RG_PLL_EN_VAL;
+	writel(reg, USB2_PHY_BASE_REG + PHY_PLL_OFFSET);
+
+	udelay(U_LEVEL10);
+
+	/* cancel TPOR */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg &= ~USB2_PHY_PORT_TREQ;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+	udelay(U_LEVEL6);
+
+	/* vcc reset */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg &= ~USB2_VCC_SRST_REQ;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* USB2 Controller configs */
+	reg = readl(USB3_CTRL_REG_BASE + REG_GUSB3PIPECTL0);
+	reg |= PCS_SSP_SOFT_RESET;
+	writel(reg, USB3_CTRL_REG_BASE + REG_GUSB3PIPECTL0);
+	udelay(U_LEVEL2);
+
+	reg = readl(USB3_CTRL_REG_BASE + REG_GCTL);
+	reg &= ~PORT_CAP_DIR;
+	reg |= PORT_SET_HOST; /* [13:12] 01: Host; 10: Device; 11: OTG */
+	writel(reg, USB3_CTRL_REG_BASE + REG_GCTL);
+	udelay(U_LEVEL2);
+
+	reg = readl(USB3_CTRL_REG_BASE + REG_GUSB3PIPECTL0);
+	reg &= ~PCS_SSP_SOFT_RESET;
+	reg &= ~PORT_DISABLE_SUSPEND; /* disable suspend */
+	writel(reg, USB3_CTRL_REG_BASE + REG_GUSB3PIPECTL0);
+	udelay(U_LEVEL2);
+
+	writel(USB2_G_TXTHRCFG, USB3_CTRL_REG_BASE + GTXTHRCFG);
+	writel(USB2_G_RXTHRCFG, USB3_CTRL_REG_BASE + GRXTHRCFG);
+	udelay(U_LEVEL2);
+
+	/* USB2 eye config */
+	usb2_eye_config();
+
+	/* USB2 trim config */
+	usb2_trim_config();
+}
+EXPORT_SYMBOL(phy_usb_init);
+
+void xhci_hcd_stop(int index)
+{
+	unsigned int reg;
+
+	/* por noreset */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_PHY_REQ;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	udelay(U_LEVEL10);
+
+	/* cancel TPOR */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_PHY_PORT_TREQ;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+	udelay(U_LEVEL6);
+
+	/* vcc reset */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_VCC_SRST_REQ;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+}
+EXPORT_SYMBOL(xhci_hcd_stop);
+#endif
\ No newline at end of file
diff -uraN u-boot-2016.11/drivers/phy/goke/phy-gk7605v100-usb.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/phy/goke/phy-gk7605v100-usb.c
--- u-boot-2016.11/drivers/phy/goke/phy-gk7605v100-usb.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/phy/goke/phy-gk7605v100-usb.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,308 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifdef CONFIG_PHY_VENDOR_USB
+#include <asm/arch-gk7605v100/platform.h>
+#include <dm.h>
+#include "../../usb/host/xhci.h"
+#include "phy-usb.h"
+
+/* offset 0x140 */
+#define USB2_CTRL				0x140
+#define USB2_CRG_DEFAULT_VAL	0x3b2f
+#define USB2_UTMI_CKEN			(0x1 << 12)
+#define USB2_PHY_APB_CKEN		(0x1 << 11)
+#define USB2_REF_CKEN			(0x1 << 9)
+#define USB2_BUS_CKEN			(0x1 << 8)
+#define USB2_PHY_PLL_CKEN		(0x1 << 4)
+#define USB2_PHY_XTAL_CKEN		(0x1 << 2)
+#define USB2_FREECLK_CKSEL		(0x1 << 13)
+#define USB2_PHY_APB_RST		(0x1 << 10)
+#define USB2_VCC_SRST_REQ		(0x1 << 3)
+#define USB2_PHY_REQ			(0x1 << 0)
+#define USB2_PHY_PORT_TREQ		(0x1 << 1)
+
+#define GTXTHRCFG				0xc108
+#define GRXTHRCFG				0xc10c
+#define REG_GCTL				0xc110
+#define REG_GUSB3PIPECTL0		0xc2c0
+#define PCS_SSP_SOFT_RESET		(0x1 << 31)
+
+#define PORT_CAP_DIR			(0x3 << 12)
+#define PORT_SET_HOST			(0x1 << 12)
+#define PORT_DISABLE_SUSPEND	(0x1 << 17)
+
+
+#define	USB2_G_TXTHRCFG			0x23100000
+#define	USB2_G_RXTHRCFG			0x23100000
+
+/* PHY base register */
+#define USB2_PHY_BASE_REG		0x100D0000
+#define RG_PLL_EN_MASK			0x0003
+#define RG_PLL_EN_VAL			0x0003
+#define PHY_PLL_OFFSET			0x0014
+
+#define USB_VBUS_IO_CONFIG_REG	0x100c007C
+#define USB_VBUS_IO_CONFIG_VAL	0x0431
+
+#define USB_PWREN_CONFIG_REG	0x100c0080
+#define USB_PWREN_CONFIG_VAL	0x1
+
+/* PHY eye config */
+#define PHY_ANA_CFG_0_OFFSET			0x00
+#define PHY_PRE_DRIVE_MASK			(0xf << 24)
+#define PHY_PRE_DRIVE_VAL				(0x4 << 24)
+#define PHY_HSTX_DE_MASK			(0xf << 8)
+#define PHY_HSTX_DE_VAL				(0xc << 8)
+#define PHY_HSTX_DEEN_BIT				(0x1 << 5)
+#define PHY_ANA_CFG_2_OFFSET			0x08
+#define PHY_TX_TEST_BIT				(0x1 << 20)
+#define PHY_HALF_DEEM_BIT				(0x1 << 21)
+#define PHY_DISCONNECT_REFERENCE_MASK	(0x7 << 16)
+#define PHY_DISCONNECT_REFERENCE_VAL	(0x2 << 16)
+#define PHY_ANA_CFG_4_OFFSET			0x10
+#define PHY_TX_REFERENCE_MASK			(0x7 << 4)
+#define PHY_TX_REFERENCE_VAL			(0x5 << 4)
+#define PHY_SQUELCH_REFERENCE_MASK	(0x7 << 0)
+#define PHY_SQUELCH_REFERENCE_VAL		(0x5 << 0)
+
+/* PHY trim config */
+#define USB_TRIM_BASE_REG					0x12028004
+#define USB_TRIM_VAL_MASK					0x001F
+#define USB_TRIM_VAL_MIN					0x0009
+#define USB_TRIM_VAL_MAX					0x001D
+#define USB2_TRIM_OFFSET					0x0008
+#define USB2_TRIM_MASK						0x1f00
+#define usb2_trim_val(a)					(((a) << 8) & USB2_TRIM_MASK)
+#define USB2_TRIM_DEFAULT_VAL				0x000F
+
+static uintptr_t xhci_base = 0;
+
+int xhci_hcd_init(int index, struct xhci_hccr **hccr, struct xhci_hcor **hcor)
+{
+	if ((hccr == NULL) || (hcor == NULL))
+		return -EINVAL;
+
+	xhci_base = USB3_CTRL_REG_BASE;
+
+	*hccr = (struct xhci_hccr *)(xhci_base);
+	*hcor = (struct xhci_hcor *)((uintptr_t) *hccr +
+				HC_LENGTH(xhci_readl(&(*hccr)->cr_capbase)));
+
+	return 0;
+}
+
+void usb2_eye_config(void)
+{
+	unsigned int reg;
+	/* HSTX pre-drive strength */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_0_OFFSET);
+	reg &= ~PHY_PRE_DRIVE_MASK;
+	reg |= PHY_PRE_DRIVE_VAL;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_0_OFFSET);
+
+	/* HSTX de-emphasis strength */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_0_OFFSET);
+	reg &= ~PHY_HSTX_DE_MASK;
+	reg |= PHY_HSTX_DE_VAL;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_0_OFFSET);
+
+	/* HSTX de-emphasis enable */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_0_OFFSET);
+	reg |= PHY_HSTX_DEEN_BIT;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_0_OFFSET);
+
+	/* TX test bit */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_2_OFFSET);
+	reg |= PHY_TX_TEST_BIT;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_2_OFFSET);
+
+	/* TX half de-emphasis bit */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_2_OFFSET);
+	reg |= PHY_HALF_DEEM_BIT;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_2_OFFSET);
+
+	/* Disconnect reference voltage sel */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_2_OFFSET);
+	reg &= ~PHY_DISCONNECT_REFERENCE_MASK;
+	reg |= PHY_DISCONNECT_REFERENCE_VAL;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_2_OFFSET);
+
+	/* TX reference voltage sel */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_4_OFFSET);
+	reg &= ~PHY_TX_REFERENCE_MASK;
+	reg |= PHY_TX_REFERENCE_VAL;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_4_OFFSET);
+
+	/* Squlech reference voltage sel */
+	reg = readl(USB2_PHY_BASE_REG + PHY_ANA_CFG_4_OFFSET);
+	reg &= ~PHY_SQUELCH_REFERENCE_MASK;
+	reg |= PHY_SQUELCH_REFERENCE_VAL;
+	writel(reg, USB2_PHY_BASE_REG + PHY_ANA_CFG_4_OFFSET);
+}
+
+void usb2_trim_config(void)
+{
+	unsigned int ret;
+	unsigned int reg;
+	unsigned int trim_val;
+
+	ret = readl(USB_TRIM_BASE_REG);
+	trim_val = (ret & USB_TRIM_VAL_MASK); /* get usb trim value */
+	reg = readl(USB2_PHY_BASE_REG + USB2_TRIM_OFFSET);
+	reg &= ~USB2_TRIM_MASK;
+
+	if ((trim_val >= USB_TRIM_VAL_MIN) && (trim_val <= USB_TRIM_VAL_MAX))
+		reg |= usb2_trim_val(trim_val);
+	else
+		reg |= usb2_trim_val(USB2_TRIM_DEFAULT_VAL);
+
+	writel(reg, USB2_PHY_BASE_REG + USB2_TRIM_OFFSET);
+}
+
+void phy_usb_init_crg_clk(int index)
+{
+	unsigned int reg;
+
+	/* set usb2 CRG default val */
+	reg = USB2_CRG_DEFAULT_VAL;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+	udelay(U_LEVEL6);
+
+	/* open UTMI clk */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_UTMI_CKEN;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* open phy apb clk */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_PHY_APB_CKEN;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* open ctrl ref clk */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_REF_CKEN;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* open bus clk */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_BUS_CKEN;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* open phy pll clk */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_PHY_PLL_CKEN;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* open phy xtal clk */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_PHY_XTAL_CKEN;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* freeclk_cksel_free */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_FREECLK_CKSEL;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	udelay(U_LEVEL5);
+}
+
+void phy_usb_init(int index)
+{
+	unsigned int reg;
+
+	/* VBUS config */
+	reg = USB_VBUS_IO_CONFIG_VAL;
+	writel(reg, USB_VBUS_IO_CONFIG_REG);
+
+	reg = USB_PWREN_CONFIG_VAL;
+	writel(reg, USB_PWREN_CONFIG_REG);
+
+	/* init crg and clk */
+	phy_usb_init_crg_clk(index);
+
+	/* release phy apb */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg &= ~USB2_PHY_APB_RST;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	udelay(U_LEVEL5);
+
+	/* por noreset */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg &= ~USB2_PHY_REQ;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	reg = readl(USB2_PHY_BASE_REG + PHY_PLL_OFFSET);
+	reg &= ~RG_PLL_EN_MASK;
+	reg |= RG_PLL_EN_VAL;
+	writel(reg, USB2_PHY_BASE_REG + PHY_PLL_OFFSET);
+
+	udelay(U_LEVEL10);
+
+	/* cancel TPOR */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg &= ~USB2_PHY_PORT_TREQ;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+	udelay(U_LEVEL6);
+
+	/* vcc reset */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg &= ~USB2_VCC_SRST_REQ;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	/* USB2 Controller configs */
+	reg = readl(USB3_CTRL_REG_BASE + REG_GUSB3PIPECTL0);
+	reg |= PCS_SSP_SOFT_RESET;
+	writel(reg, USB3_CTRL_REG_BASE + REG_GUSB3PIPECTL0);
+	udelay(U_LEVEL2);
+
+	reg = readl(USB3_CTRL_REG_BASE + REG_GCTL);
+	reg &= ~PORT_CAP_DIR;
+	reg |= PORT_SET_HOST; /* [13:12] 01: Host; 10: Device; 11: OTG */
+	writel(reg, USB3_CTRL_REG_BASE + REG_GCTL);
+	udelay(U_LEVEL2);
+
+	reg = readl(USB3_CTRL_REG_BASE + REG_GUSB3PIPECTL0);
+	reg &= ~PCS_SSP_SOFT_RESET;
+	reg &= ~PORT_DISABLE_SUSPEND; /* disable suspend */
+	writel(reg, USB3_CTRL_REG_BASE + REG_GUSB3PIPECTL0);
+	udelay(U_LEVEL2);
+
+	writel(USB2_G_TXTHRCFG, USB3_CTRL_REG_BASE + GTXTHRCFG);
+	writel(USB2_G_RXTHRCFG, USB3_CTRL_REG_BASE + GRXTHRCFG);
+	udelay(U_LEVEL2);
+
+	/* USB2 eye config */
+	usb2_eye_config();
+
+	/* USB2 trim config */
+	usb2_trim_config();
+}
+EXPORT_SYMBOL(phy_usb_init);
+
+void xhci_hcd_stop(int index)
+{
+	unsigned int reg;
+
+	/* por noreset */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_PHY_REQ;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+
+	udelay(U_LEVEL10);
+
+	/* cancel TPOR */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_PHY_PORT_TREQ;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+	udelay(U_LEVEL6);
+
+	/* vcc reset */
+	reg = readl(CRG_REG_BASE + USB2_CTRL);
+	reg |= USB2_VCC_SRST_REQ;
+	writel(reg, CRG_REG_BASE + USB2_CTRL);
+}
+EXPORT_SYMBOL(xhci_hcd_stop);
+#endif
\ No newline at end of file
diff -uraN u-boot-2016.11/drivers/phy/goke/phy-usb.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/phy/goke/phy-usb.h
--- u-boot-2016.11/drivers/phy/goke/phy-usb.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/phy/goke/phy-usb.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,20 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef PHY_VENDOR_USB
+#define PHY_VENDOR_USB
+
+#define U_LEVEL1	10
+#define U_LEVEL2	20
+#define U_LEVEL3	30
+#define U_LEVEL4	50
+#define U_LEVEL5	100
+#define U_LEVEL6	200
+#define U_LEVEL7	300
+#define U_LEVEL8	500
+#define U_LEVEL9	1000
+#define U_LEVEL10	2000
+
+
+#endif // PHY_VENDOR_USB
diff -uraN u-boot-2016.11/drivers/phy/goke/usb.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/phy/goke/usb.h
--- u-boot-2016.11/drivers/phy/goke/usb.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/phy/goke/usb.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,10 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef USB_VENDOR_H
+#define USB_VENDOR_H
+
+extern void phy_usb_init(int index);
+
+#endif
diff -uraN u-boot-2016.11/drivers/serial/serial.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/serial/serial.c
--- u-boot-2016.11/drivers/serial/serial.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/serial/serial.c	2021-06-07 13:01:32.000000000 +0300
@@ -109,6 +109,7 @@
 	void name(void)						\
 		__attribute__((weak, alias("serial_null")));
 
+#ifndef CONFIG_MINI_BOOT
 serial_initfunc(amirix_serial_initialize);
 serial_initfunc(arc_serial_initialize);
 serial_initfunc(arm_dcc_initialize);
@@ -144,7 +145,11 @@
 serial_initfunc(ns16550_serial_initialize);
 serial_initfunc(oc_serial_initialize);
 serial_initfunc(p3mx_serial_initialize);
+#endif
+
 serial_initfunc(pl01x_serial_initialize);
+
+#ifndef CONFIG_MINI_BOOT
 serial_initfunc(pxa_serial_initialize);
 serial_initfunc(s3c24xx_serial_initialize);
 serial_initfunc(s5p_serial_initialize);
@@ -155,6 +160,7 @@
 serial_initfunc(stm32_serial_initialize);
 serial_initfunc(uartlite_serial_initialize);
 serial_initfunc(zynq_serial_initialize);
+#endif
 
 /**
  * serial_register() - Register serial driver with serial driver core
@@ -200,6 +206,7 @@
  */
 void serial_initialize(void)
 {
+#ifndef CONFIG_MINI_BOOT
 	amirix_serial_initialize();
 	arc_serial_initialize();
 	arm_dcc_initialize();
@@ -235,7 +242,9 @@
 	ns16550_serial_initialize();
 	oc_serial_initialize();
 	p3mx_serial_initialize();
+#endif
 	pl01x_serial_initialize();
+#ifndef CONFIG_MINI_BOOT
 	pxa_serial_initialize();
 	s3c24xx_serial_initialize();
 	s5p_serial_initialize();
@@ -246,7 +255,7 @@
 	stm32_serial_initialize();
 	uartlite_serial_initialize();
 	zynq_serial_initialize();
-
+#endif
 	serial_assign(default_serial_console()->name);
 }
 
@@ -514,6 +523,11 @@
 void default_serial_puts(const char *s)
 {
 	struct serial_device *dev = get_current();
+#ifndef CONFIG_MINI_BOOT
+#ifdef CONFIG_PHY_VENDOR_USB
+	udc_puts(s);
+#endif
+#endif
 	while (*s)
 		dev->putc(*s++);
 }
diff -uraN u-boot-2016.11/drivers/serial/serial_pl01x.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/serial/serial_pl01x.c
--- u-boot-2016.11/drivers/serial/serial_pl01x.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/serial/serial_pl01x.c	2021-06-07 13:01:32.000000000 +0300
@@ -35,6 +35,9 @@
 
 static int pl01x_putc(struct pl01x_regs *regs, char c)
 {
+#ifdef CONFIG_GK_DISABLE_CONSOLE
+	return 0;
+#endif
 	/* Wait until there is space in the FIFO */
 	if (readl(&regs->fr) & UART_PL01x_FR_TXFF)
 		return -EAGAIN;
@@ -47,6 +50,9 @@
 
 static int pl01x_getc(struct pl01x_regs *regs)
 {
+#ifdef CONFIG_GK_DISABLE_CONSOLE
+	return 1;
+#endif
 	unsigned int data;
 
 	/* Wait until there is data in the FIFO */
@@ -67,6 +73,9 @@
 
 static int pl01x_tstc(struct pl01x_regs *regs)
 {
+#ifdef CONFIG_GK_DISABLE_CONSOLE
+	return 0;
+#endif
 	WATCHDOG_RESET();
 	return !(readl(&regs->fr) & UART_PL01x_FR_RXFE);
 }
@@ -238,6 +247,9 @@
 
 static void pl01x_serial_setbrg(void)
 {
+#ifdef CONFIG_GK_DISABLE_CONSOLE
+	return;
+#endif
 	/*
 	 * Flush FIFO and wait for non-busy before changing baudrate to avoid
 	 * crap in console
@@ -272,6 +284,19 @@
 
 #endif /* nCONFIG_DM_SERIAL */
 
+void serial_puts_to_tool(const char *s)
+{
+#ifndef CONFIG_MINI_BOOT
+#ifdef CONFIG_PHY_VENDOR_USB
+	udc_puts(s);
+#endif
+#endif
+	while (*s) {
+		while (pl01x_putc(base_regs, *s) == -EAGAIN);
+		s++;
+	}
+}
+
 #ifdef CONFIG_DM_SERIAL
 
 struct pl01x_priv {
diff -uraN u-boot-2016.11/drivers/serial/serial-uclass.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/serial/serial-uclass.c
--- u-boot-2016.11/drivers/serial/serial-uclass.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/serial/serial-uclass.c	2021-06-07 13:01:32.000000000 +0300
@@ -15,6 +15,7 @@
 #include <watchdog.h>
 #include <dm/lists.h>
 #include <dm/device-internal.h>
+#include <types.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
diff -uraN u-boot-2016.11/drivers/usb/gadget/udc3/debug.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/debug.h
--- u-boot-2016.11/drivers/usb/gadget/udc3/debug.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/debug.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,166 @@
+#ifndef __DEBUG_H__
+#define __DEBUG_H__
+
+#include "types.h"
+#include "platform.h"
+#include <stdarg.h>
+
+#ifdef DEBUG
+
+#define MHZ (1000*1000)
+#if 0
+#define CFG_CLK_OTHER_BASE 32//FIXME
+#define CFG_CLK_OTHER (CFG_CLK_OTHER_BASE*MHZ)
+#else
+#define CFG_CLK_OTHER (19200000)
+#endif
+
+/*-----------------------------------------------------------------------
+ * Serial Configuration
+ */
+#define CONFIG_PL011_CLOCK    CFG_CLK_OTHER//FIXME
+#define CONFIG_PL01x_PORTS    { (void *)CFG_SERIAL0 }
+#define CONFIG_CONS_INDEX    0 /* select the default console */
+#define CONFIG_BAUDRATE         115200
+#define CFG_SERIAL0        REG_BASE_UART6
+
+
+/*
+ * ARM PrimeCell UART's (PL010 & PL011)
+ * ------------------------------------
+ *
+ *  Definitions common to both PL010 & PL011
+ *
+ */
+#define UART_PL01x_DR                   0x00     /*  Data read or written from the interface. */
+#define UART_PL01x_RSR                  0x04     /*  Receive status register (Read). */
+#define UART_PL01x_ECR                  0x04     /*  Error clear register (Write). */
+#define UART_PL01x_FR                   0x18     /*  Flag register (Read only). */
+
+#define UART_PL01x_RSR_OE               0x08
+#define UART_PL01x_RSR_BE               0x04
+#define UART_PL01x_RSR_PE               0x02
+#define UART_PL01x_RSR_FE               0x01
+
+#define UART_PL01x_FR_TXFE              0x80
+#define UART_PL01x_FR_RXFF              0x40
+#define UART_PL01x_FR_TXFF              0x20
+#define UART_PL01x_FR_RXFE              0x10
+#define UART_PL01x_FR_BUSY              0x08
+#define UART_PL01x_FR_TMSK              (UART_PL01x_FR_TXFF + UART_PL01x_FR_BUSY)
+
+/*
+ *  PL010 definitions
+ *
+ */
+#define UART_PL010_LCRH                 0x08     /*  Line control register, high byte. */
+#define UART_PL010_LCRM                 0x0C     /*  Line control register, middle byte. */
+#define UART_PL010_LCRL                 0x10     /*  Line control register, low byte. */
+#define UART_PL010_CR                   0x14     /*  Control register. */
+#define UART_PL010_IIR                  0x1C     /*  Interrupt indentification register (Read). */
+#define UART_PL010_ICR                  0x1C     /*  Interrupt clear register (Write). */
+#define UART_PL010_ILPR                 0x20     /*  IrDA low power counter register. */
+
+#define UART_PL010_CR_LPE               (1 << 7)
+#define UART_PL010_CR_RTIE              (1 << 6)
+#define UART_PL010_CR_TIE               (1 << 5)
+#define UART_PL010_CR_RIE               (1 << 4)
+#define UART_PL010_CR_MSIE              (1 << 3)
+#define UART_PL010_CR_IIRLP             (1 << 2)
+#define UART_PL010_CR_SIREN             (1 << 1)
+#define UART_PL010_CR_UARTEN            (1 << 0)
+
+#define UART_PL010_LCRH_WLEN_8          (3 << 5)
+#define UART_PL010_LCRH_WLEN_7          (2 << 5)
+#define UART_PL010_LCRH_WLEN_6          (1 << 5)
+#define UART_PL010_LCRH_WLEN_5          (0 << 5)
+#define UART_PL010_LCRH_FEN             (1 << 4)
+#define UART_PL010_LCRH_STP2            (1 << 3)
+#define UART_PL010_LCRH_EPS             (1 << 2)
+#define UART_PL010_LCRH_PEN             (1 << 1)
+#define UART_PL010_LCRH_BRK             (1 << 0)
+
+
+#define UART_PL010_BAUD_460800            1
+#define UART_PL010_BAUD_230400            3
+#define UART_PL010_BAUD_115200            7
+#define UART_PL010_BAUD_57600             15
+#define UART_PL010_BAUD_38400             23
+#define UART_PL010_BAUD_19200             47
+#define UART_PL010_BAUD_14400             63
+#define UART_PL010_BAUD_9600              95
+#define UART_PL010_BAUD_4800              191
+#define UART_PL010_BAUD_2400              383
+#define UART_PL010_BAUD_1200              767
+/*
+ *  PL011 definitions
+ *
+ */
+#define UART_PL011_IBRD                 0x24
+#define UART_PL011_FBRD                 0x28
+#define UART_PL011_LCRH                 0x2C
+#define UART_PL011_CR                   0x30
+#define UART_PL011_IMSC                 0x38
+#define UART_PL011_PERIPH_ID0           0xFE0
+
+#define UART_PL011_LCRH_SPS             (1 << 7)
+#define UART_PL011_LCRH_WLEN_8          (3 << 5)
+#define UART_PL011_LCRH_WLEN_7          (2 << 5)
+#define UART_PL011_LCRH_WLEN_6          (1 << 5)
+#define UART_PL011_LCRH_WLEN_5          (0 << 5)
+#define UART_PL011_LCRH_FEN             (1 << 4)
+#define UART_PL011_LCRH_STP2            (1 << 3)
+#define UART_PL011_LCRH_EPS             (1 << 2)
+#define UART_PL011_LCRH_PEN             (1 << 1)
+#define UART_PL011_LCRH_BRK             (1 << 0)
+
+#define UART_PL011_CR_CTSEN             (1 << 15)
+#define UART_PL011_CR_RTSEN             (1 << 14)
+#define UART_PL011_CR_OUT2              (1 << 13)
+#define UART_PL011_CR_OUT1              (1 << 12)
+#define UART_PL011_CR_RTS               (1 << 11)
+#define UART_PL011_CR_DTR               (1 << 10)
+#define UART_PL011_CR_RXE               (1 << 9)
+#define UART_PL011_CR_TXE               (1 << 8)
+#define UART_PL011_CR_LPE               (1 << 7)
+#define UART_PL011_CR_IIRLP             (1 << 2)
+#define UART_PL011_CR_SIREN             (1 << 1)
+#define UART_PL011_CR_UARTEN            (1 << 0)
+
+#define UART_PL011_IMSC_OEIM            (1 << 10)
+#define UART_PL011_IMSC_BEIM            (1 << 9)
+#define UART_PL011_IMSC_PEIM            (1 << 8)
+#define UART_PL011_IMSC_FEIM            (1 << 7)
+#define UART_PL011_IMSC_RTIM            (1 << 6)
+#define UART_PL011_IMSC_TXIM            (1 << 5)
+#define UART_PL011_IMSC_RXIM            (1 << 4)
+#define UART_PL011_IMSC_DSRMIM          (1 << 3)
+#define UART_PL011_IMSC_DCDMIM          (1 << 2)
+#define UART_PL011_IMSC_CTSMIM          (1 << 1)
+#define UART_PL011_IMSC_RIMIM           (1 << 0)
+
+void console_init();
+
+void __xprintf(const char *fmt, va_list ap,
+               void (*xputc)(unsigned n, void *cookie),
+               void *cookie);
+void cprintf(const char *fmt, ...);
+
+
+#define debug_init() console_init()
+#define debug_printf cprintf
+#define ASSERT(cond,exp) \
+        if(!(cond)) {cprintf((UINT8 *)exp);while(TRUE);}
+#define MSGLOGSTR(x) cprintf(x);
+
+#else
+
+#define debug_init()
+#define debug_printf(exp, ...)
+#define ASSERT(cond,exp)
+#define MSGLOGSTR(x)
+
+#endif
+
+#endif /* end of __DEBUG_H__ */
+
diff -uraN u-boot-2016.11/drivers/usb/gadget/udc3/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/Makefile
--- u-boot-2016.11/drivers/usb/gadget/udc3/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1 @@
+obj-y += usb3_drv.o usb3_pcd.o usb3_intr.o usb3_pcd_intr.o usb3_prot.o
diff -uraN u-boot-2016.11/drivers/usb/gadget/udc3/onchiprom.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/onchiprom.h
--- u-boot-2016.11/drivers/usb/gadget/udc3/onchiprom.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/onchiprom.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,62 @@
+#ifndef __ONCHIPROM_H__
+#define __ONCHIPROM_H__
+
+#include "platform.h"
+
+/* define vrl table of xloader loaded address & size */
+#define VRL_TABLE_LOAD_ADDRESS	REG_BASE_LP_RAM
+#define VRL_TABLE_LOAD_SIZE		(4*1024)
+
+/* define xloader loaded address & size */
+#define XLOADER_IMAGE_LOAD_ADDRESS	(VRL_TABLE_LOAD_ADDRESS+VRL_TABLE_LOAD_SIZE)
+#ifdef EDA_SPEEDUP
+#define XLOADER_IMAGE_LOAD_SIZE		(4*1024)
+#else
+#define XLOADER_IMAGE_LOAD_SIZE		(28*1024)
+#endif
+
+#define ONCHIPROM_IMAGE_LOAD_MAX	(100*1024)
+
+/* define ufs work space area */
+#define UFS_STATIC_WORK_SPACE_ADDRESS		(REG_BASE_LP_RAM+0x1C000)
+#define UFS_STATIC_WORK_SPACE_SIZE		(0xE00)
+
+/* define onchiprom static area */
+#define ONCHIPROM_STATIC_AREA_ADDRESS		(REG_BASE_LP_RAM+0x1CE00)
+#define ONCHIPROM_STATIC_AREA_SIZE			(0x100)
+
+/* define secure engine static area */
+#define SECURE_ENGINE_STATIC_AREA_ADDRESS	(REG_BASE_LP_RAM+0x1CF00)
+#define SECURE_ENGINE_STATIC_AREA_SIZE		(0x100)
+
+/* define secure engine work space address & size */
+#define SECURE_ENGINE_WORK_SPACE_ADDRESS	(REG_BASE_LP_RAM+0x1D000)
+#define SECURE_ENGINE_WORK_SPACE_SIZE		(0x1800)
+
+/* define secure engine work space address & size */
+#define USB_STATIC_WORK_SPACE_ADDRESS		(REG_BASE_LP_RAM+0x1E800)
+#define USB_STATIC_WORK_SPACE_SIZE			(0x1800)
+
+/* xloader image length address */
+#define VRL_TABLE_IMAGE_LENGTH_OFFEST_ADDR	(0xFFC)
+
+#define LPRAM_MEMORY_MAP_OFFEST_ADDRESS		SECURE_ENGINE_STATIC_AREA_ADDRESS
+#define LPRAM_MEMORY_MAP_OFFEST				(REG_BASE_LP_RAM_ACORE-REG_BASE_LP_RAM)
+
+/* static variable */
+#define STATIC_ERROR_CODE_ADDR				(ONCHIPROM_STATIC_AREA_ADDRESS+0x4)
+#define STATIC_TIMER_STATUS_ADDR			(ONCHIPROM_STATIC_AREA_ADDRESS+0x8)
+#define STATIC_TIMER_COUNT_ADDR				(ONCHIPROM_STATIC_AREA_ADDRESS+0xC)
+#define STATIC_UFS_TAG_ADDR				(ONCHIPROM_STATIC_AREA_ADDRESS+0x10)
+
+/* define boot mode */
+#define BOOT_MODE_USB_DOWNLOAD	0
+#define BOOT_MODE_NORMAL_BOOT	1
+
+#define BOOT_MODE_EMMC_BOOT		0
+#define BOOT_MODE_UFS_BOOT		1
+
+typedef void ( *PJUMPTOADDR ) ( void ); /* addr of xloader */
+
+#endif /* end of __ONCHIPROM_H__ */
+
diff -uraN u-boot-2016.11/drivers/usb/gadget/udc3/platform.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/platform.h
--- u-boot-2016.11/drivers/usb/gadget/udc3/platform.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/platform.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,28 @@
+
+#ifndef __PLATFORM_H__
+#define __PLATFORM_H__
+
+#define REG_BASE_USB_OTG              0x10180000
+#define REG_BASE_USB_OTG_BC           0XBF200000
+#define REG_BASE_LP_RAM               0x00020000
+
+#define REG_BASE_PCTRL                0xA8A09000
+#define REG_BASE_IOC                  0xA896C000
+#define REG_BASE_PMC                  0x40231000
+#define REG_BASE_UART6                0x40232000
+#define REG_BASE_PERI_CRG             0x40235000
+#define REG_BASE_LP_TIMER             0x4023E000
+#define REG_BASE_SCTRL                0x4020A000
+#define REG_BASE_AO_IOC               0x40211000
+
+#define REG_BASE_GPIO			0xA8A0B000	/* GPIO0~21 */
+#define REG_GPIO(x)			(REG_BASE_GPIO + (0x1000 * (x)))
+#define REG_GPIO22			0x4020B000
+
+#define LP_RAM_SIZE                   (96*1024)
+
+#define REG_BASE_LP_RAM_ACORE         0xFFF50000
+
+#endif /* end of __PLATFORM_H__ */
+
+
diff -uraN u-boot-2016.11/drivers/usb/gadget/udc3/sys.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/sys.h
--- u-boot-2016.11/drivers/usb/gadget/udc3/sys.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/sys.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,52 @@
+#ifndef __SYS_H__
+#define __SYS_H__
+#include "types.h"
+static inline void writel(u32 val, unsigned long int addr)
+{
+    (*(volatile u32*) (addr)) = (val);
+}
+
+static inline void writew(u16 val, unsigned long int addr)
+{
+    (*(volatile u16*) (addr)) = (val);
+}
+
+static inline void writeb(u8 val, unsigned long int addr)
+{
+    (*(volatile u8*) (addr)) = (val);
+}
+
+static inline u32 readl(unsigned long int addr)
+{
+    return (*(volatile u32*) (addr));
+}
+
+static inline u16 readw(unsigned long int addr)
+{
+    return (*(volatile u16*) (addr));
+}
+
+static inline u8 readb(unsigned long int addr)
+{
+    return (*(volatile u8*) (addr));
+}
+
+/* Set the bits of addr to 1, which in mask is 1 */
+static inline void set_bits(u32 mask, unsigned long int addr)
+{
+    (*(volatile u32*) (addr)) |= mask;
+}
+
+/* Clear the bits of addr to 0, which in mask is 1 */
+static inline void clr_bits(u32 mask, unsigned long int addr)
+{
+    (*(volatile u32*) (addr)) &= ~(mask);
+}
+
+/* Return True if all the bits of addr are 1, which is 1 in mask.
+   Else, return False. */
+static inline u32 is_bits_set(u32 mask, unsigned long int addr)
+{
+    return (((*(volatile u32*) (addr)) & (mask)) == (mask));
+}
+#endif /* end of __SYS_H__ */
diff -uraN u-boot-2016.11/drivers/usb/gadget/udc3/types.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/types.h
--- u-boot-2016.11/drivers/usb/gadget/udc3/types.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/types.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __TYPES_H__
+#define __TYPES_H__
+
+typedef signed char s8;
+typedef unsigned char u8;
+
+typedef signed short s16;
+typedef unsigned short u16;
+
+typedef signed int s32;
+typedef unsigned int u32;
+
+typedef signed long long s64;
+typedef unsigned long long u64;
+
+typedef int bool;
+
+#define INT8    char
+#define INT16   short
+#define INT32   int
+
+#define UINT8   unsigned INT8
+#define UINT16  unsigned INT16
+#define UINT32  unsigned INT32
+
+typedef unsigned long long      uint64_t;
+typedef signed long long        int64_t;
+typedef unsigned int            uint32_t;
+typedef signed int              int32_t;
+typedef unsigned short          uint16_t;
+typedef signed short            int16_t;
+typedef unsigned char           uint8_t;
+typedef signed char             int8_t;
+void udc_puts(const char *s);
+
+#ifndef NULL
+#define NULL                    (void *)0
+#endif
+
+#define TRUE    1
+#define FALSE   0
+
+#define BOOL    int
+
+#endif /* end of __TYPES_H__ */
+
diff -uraN u-boot-2016.11/drivers/usb/gadget/udc3/usb3_drv.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/usb3_drv.c
--- u-boot-2016.11/drivers/usb/gadget/udc3/usb3_drv.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/usb3_drv.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,773 @@
+#include "usb3.h"
+#include "usb3_hw.h"
+#include "usb3_drv.h"
+#include "sys.h"
+#include "onchiprom.h"
+#include "common.h"
+
+#include <common.h>
+#include <linux/string.h>
+#include <malloc.h>
+#include <linux/compat.h>
+#include "../../../phy/goke/usb.h"
+
+void usb3_handle_event(usb3_device_t *dev);
+void usb3_enable_device_interrupts(usb3_device_t *dev);
+void usb3_dis_flush_eventbuf_intr(usb3_device_t *dev);
+void usb3_init_eventbuf(usb3_device_t *dev, uint32_t size, phys_addr_t dma_addr);
+#define udelay_100us udelay
+#define msleep udelay
+void usb3_memset(void *buf, uint8_t value, uint32_t size)
+{
+	uint8_t *pbuf = (uint8_t *)buf;
+
+	while (size--) {
+		*pbuf++ = value;
+	}
+}
+
+void usb3_memcpy(void *dst, void *src, uint32_t size)
+{
+	uint8_t *pdst = (uint8_t *)dst;
+	uint8_t *psrc = (uint8_t *)src;
+
+	if (psrc > pdst) {
+		while (size--) {
+			*pdst++ = *psrc++;
+		}
+	} else {
+		pdst += size - 1;
+		psrc += size - 1;
+		while (size--) {
+			*pdst-- = *psrc--;
+		}
+	}
+}
+
+uint32_t usb3_rd32(volatile uint32_t *addr)
+{
+	return *(volatile uint32_t *)(addr);
+}
+extern int usb_out_open;
+void usb3_wr32(volatile uint32_t *addr, uint32_t val)
+{
+	*(volatile uint32_t *)(addr) = val;
+    udelay(200);
+}
+
+uint32_t usb3_is_host_mode(usb3_device_t *dev)
+{
+	return usb3_rd32(&dev->core_global_regs->gsts) & 0x01;
+}
+
+void pcd_epinit(usb3_pcd_t *pcd)
+{
+	usb3_pcd_ep_t *ep;
+
+	/* Init EP0 */
+	do {
+		ep = &pcd->ep0;
+
+		ep->pcd = pcd;
+		ep->stopped = 1;
+		ep->is_in = 0;
+		ep->active = 0;
+		ep->phys = 0;
+		ep->num = 0;
+		ep->tx_fifo_num = 0;
+		ep->out_ep_reg = &pcd->out_ep_regs[0];
+		ep->in_ep_reg = &pcd->in_ep_regs[0];
+
+		ep->type = USB3_EP_TYPE_CONTROL;
+		ep->maxburst = 0;
+		ep->maxpacket = 64;
+		ep->send_zlp = 0;
+
+		ep->req.length = 0;
+		ep->req.actual = 0;
+
+		pcd->ep0_req.length = 0;
+		pcd->ep0_req.actual = 0;
+	} while(0);
+
+	/* Init EP1-OUT */
+	do {
+		ep = &pcd->out_ep;
+
+		ep->pcd = pcd;
+		ep->stopped = 1;
+		ep->is_in = 0;
+		ep->active = 0;
+		ep->phys = USB3_BULK_OUT_EP << 1;
+		ep->num = 1;
+		ep->tx_fifo_num = 0;
+		ep->out_ep_reg = &pcd->out_ep_regs[USB3_BULK_OUT_EP];
+
+		/* Bulk EP is activated */
+		ep->type = USB3_EP_TYPE_BULK;
+		ep->maxburst = 0;
+		ep->maxpacket = USB2_FS_MAX_PACKET_SIZE;
+		ep->send_zlp = 0;
+
+		ep->req.length = 0;
+		ep->req.actual = 0;
+	} while(0);
+
+	/* Init EP1-IN */
+	do {
+		ep = &pcd->in_ep;
+
+		ep->pcd = pcd;
+		ep->stopped = 1;
+		ep->is_in = 1;
+		ep->active = 0;
+		ep->phys = (USB3_BULK_IN_EP << 1) | 1;
+		ep->num = 1;
+		ep->tx_fifo_num = USB3_BULK_IN_EP;
+		ep->in_ep_reg = &pcd->in_ep_regs[USB3_BULK_IN_EP];
+
+		/* Bulk EP is activated */
+		ep->type = USB3_EP_TYPE_BULK;
+		ep->maxburst = 0;
+		ep->maxpacket = USB2_FS_MAX_PACKET_SIZE;
+		ep->send_zlp = 0;
+
+		ep->req.length = 0;
+		ep->req.actual = 0;
+	} while(0);
+
+	pcd->ep0state = EP0_IDLE;
+}
+
+void usb3_set_address(usb3_pcd_t *pcd, uint32_t addr)
+{
+	uint32_t dcfg;
+
+	dcfg = usb3_rd32(&pcd->dev_global_regs->dcfg);
+	dcfg &= ~USB3_DCFG_DEVADDR_BITS;
+	dcfg |= addr << USB3_DCFG_DEVADDR_SHIFT;
+	usb3_wr32(&pcd->dev_global_regs->dcfg, dcfg);
+}
+
+#define RAM_WIDTH       8
+#define RAM_RX_DEPTH    4096
+#define RAM_TX0_DEPTH   1024
+#define RAM_TX1_DEPTH   2048
+void usb3_set_tx_fifo_size(usb3_device_t *dev)
+{
+	usb3_core_global_regs_t *global_regs =
+						dev->core_global_regs;
+	uint32_t prev_start = 0;
+	/* Set 1K for tx fifo0 */
+	usb3_wr32(&global_regs->gtxfifosiz[0],
+		 ((RAM_TX0_DEPTH / RAM_WIDTH) << USB3_FIFOSZ_DEPTH_SHIFT) |
+		 (prev_start << USB3_FIFOSZ_STARTADDR_SHIFT));
+
+	prev_start += RAM_TX0_DEPTH / RAM_WIDTH;
+	/* Set 2K for tx fifo1 */
+	usb3_wr32(&global_regs->gtxfifosiz[1],
+		 ((RAM_TX1_DEPTH / RAM_WIDTH) << USB3_FIFOSZ_DEPTH_SHIFT) |
+		 (prev_start << USB3_FIFOSZ_STARTADDR_SHIFT));
+}
+
+void usb3_set_rx_fifo_size(usb3_device_t *dev)
+{
+	usb3_core_global_regs_t *global_regs =
+						dev->core_global_regs;
+	/* Set 4K for rx fifo */
+	usb3_wr32(&global_regs->grxfifosiz[0],
+		 ((RAM_RX_DEPTH / RAM_WIDTH) << USB3_FIFOSZ_DEPTH_SHIFT));
+}
+
+void usb3_resume_usb2_phy(usb3_pcd_t *pcd)
+{
+	uint32_t usb2phycfg;
+
+	usb2phycfg = usb3_rd32(&pcd->usb3_dev->core_global_regs->gusb2phycfg[0]);
+	usb2phycfg |= USB3_USB2PHYCFG_SUS_PHY_BIT;
+	usb3_wr32(&pcd->usb3_dev->core_global_regs->gusb2phycfg[0], usb2phycfg);
+}
+
+void usb3_resume_usb3_phy(usb3_pcd_t *pcd)
+{
+	uint32_t pipectl;
+
+	pipectl = usb3_rd32(&pcd->usb3_dev->core_global_regs->gusb3pipectl[0]);
+	pipectl |= USB3_PIPECTL_SUS_PHY_BIT;
+	usb3_wr32(&pcd->usb3_dev->core_global_regs->gusb3pipectl[0],
+			pipectl);
+}
+
+void usb3_accept_u1(usb3_pcd_t *pcd)
+{
+	uint32_t dctl;
+
+	dctl = usb3_rd32(&pcd->dev_global_regs->dctl);
+	dctl |= USB3_DCTL_ACCEPT_U1_EN_BIT;
+	usb3_wr32(&pcd->dev_global_regs->dctl, dctl);
+}
+
+void usb3_accept_u2(usb3_pcd_t *pcd)
+{
+}
+
+void usb3_enable_u1(usb3_pcd_t *pcd)
+{
+	uint32_t dctl;
+
+	dctl = usb3_rd32(&pcd->dev_global_regs->dctl);
+	dctl |= USB3_DCTL_INIT_U1_EN_BIT;
+	usb3_wr32(&pcd->dev_global_regs->dctl, dctl);
+}
+
+void usb3_enable_u2(usb3_pcd_t *pcd)
+{
+}
+
+void usb3_disable_u1(usb3_pcd_t *pcd)
+{
+}
+
+void usb3_disable_u2(usb3_pcd_t *pcd)
+{
+	uint32_t dctl;
+
+	dctl = usb3_rd32(&pcd->dev_global_regs->dctl);
+	dctl &= ~USB3_DCTL_INIT_U2_EN_BIT;
+	usb3_wr32(&pcd->dev_global_regs->dctl, dctl);
+}
+
+uint32_t usb3_u1_enabled(usb3_pcd_t *pcd)
+{
+	uint32_t dctl;
+
+	dctl = usb3_rd32(&pcd->dev_global_regs->dctl);
+	return !!(dctl & USB3_DCTL_INIT_U1_EN_BIT);
+}
+
+uint32_t usb3_u2_enabled(usb3_pcd_t *pcd)
+{
+	uint32_t dctl;
+
+	dctl = usb3_rd32(&pcd->dev_global_regs->dctl);
+	return !!(dctl & USB3_DCTL_INIT_U2_EN_BIT);
+}
+
+void usb3_dep_cstall(usb3_pcd_t *pcd,
+			usb3_dev_ep_regs_t *ep_reg)
+{
+	/* Start the command */
+	usb3_wr32(&ep_reg->depcmd,
+		 USB3_EPCMD_CLR_STALL | USB3_EPCMD_ACT_BIT);
+
+	/* Wait for command completion */
+	handshake(pcd->usb3_dev, &ep_reg->depcmd, USB3_EPCMD_ACT_BIT, 0);
+}
+
+void usb3_dep_sstall(usb3_pcd_t *pcd,
+			usb3_dev_ep_regs_t *ep_reg)
+{
+	/* Start the command */
+	usb3_wr32(&ep_reg->depcmd,
+		 USB3_EPCMD_SET_STALL | USB3_EPCMD_ACT_BIT);
+
+	/* Wait for command completion */
+	handshake(pcd->usb3_dev, &ep_reg->depcmd, USB3_EPCMD_ACT_BIT, 0);
+}
+
+uint32_t handshake(usb3_device_t *dev, volatile uint32_t *ptr,
+		      uint32_t mask, uint32_t done)
+{
+	uint32_t usec = 1000;
+	uint32_t result;
+
+	do {
+		result = usb3_rd32(ptr);
+		if ((result & mask) == done) {
+			return 1;
+		}
+
+		udelay_100us(1);
+		usec -= 1;
+	} while (usec > 0);
+
+	return 0;
+}
+
+void usb3_fill_desc(usb3_dma_desc_t *desc, phys_addr_t dma_addr,
+			uint32_t dma_len, uint32_t stream, uint32_t type,
+			uint32_t ctrlbits, int own)
+{
+	dma_addr = map_to_dma_addr(dma_addr);
+
+	desc->bptl = (phys_addr_t)(dma_addr & 0xffffffffU);
+	desc->bpth = 0;
+	desc->status &= ~USB3_DSCSTS_XFRCNT_BITS;
+	desc->status |= ((dma_len << USB3_DSCSTS_XFRCNT_SHIFT)&USB3_DSCSTS_XFRCNT_BITS);
+	/* Note: If type is 0, leave original control bits intact (for isoc) */
+	if (type)
+		desc->control = type << USB3_DSCCTL_TRBCTL_SHIFT;
+
+	desc->control |= (stream << USB3_DSCCTL_STRMID_SOFN_SHIFT) | ctrlbits;
+
+	/* Must do this last! */
+	if (own)
+		desc->control |= USB3_DSCCTL_HWO_BIT;
+    flush_dcache_all();
+}
+
+
+void usb3_dep_startnewcfg(usb3_pcd_t *pcd,
+			     usb3_dev_ep_regs_t *ep_reg,
+			     uint32_t rsrcidx)
+{
+	/* Start the command */
+	usb3_wr32(&ep_reg->depcmd,
+		 (rsrcidx << USB3_EPCMD_XFER_RSRC_IDX_SHIFT) |
+		 USB3_EPCMD_START_NEW_CFG | USB3_EPCMD_ACT_BIT);
+
+	/* Wait for command completion */
+	handshake(pcd->usb3_dev, &ep_reg->depcmd, USB3_EPCMD_ACT_BIT, 0);
+}
+
+void usb3_dep_cfg(usb3_pcd_t *pcd,
+		     usb3_dev_ep_regs_t *ep_reg,
+		     uint32_t depcfg0, uint32_t depcfg1, uint32_t depcfg2)
+{
+	/* Set param 2 */
+	usb3_wr32(&ep_reg->depcmdpar2, depcfg2);
+
+	/* Set param 1 */
+	usb3_wr32(&ep_reg->depcmdpar1, depcfg1);
+
+	/* Set param 0 */
+	usb3_wr32(&ep_reg->depcmdpar0, depcfg0);
+
+	/* Start the command */
+	usb3_wr32(&ep_reg->depcmd,
+		 USB3_EPCMD_SET_EP_CFG | USB3_EPCMD_ACT_BIT);
+
+	/* Wait for command completion */
+	handshake(pcd->usb3_dev, &ep_reg->depcmd, USB3_EPCMD_ACT_BIT, 0);
+}
+
+void usb3_dep_xfercfg(usb3_pcd_t *pcd,
+			 usb3_dev_ep_regs_t *ep_reg,
+			 uint32_t depstrmcfg)
+{
+	/* Set param 0 */
+	usb3_wr32(&ep_reg->depcmdpar0, depstrmcfg);
+
+	/* Start the command */
+	usb3_wr32(&ep_reg->depcmd,
+		 USB3_EPCMD_SET_XFER_CFG | USB3_EPCMD_ACT_BIT);
+
+	/* Wait for command completion */
+	handshake(pcd->usb3_dev, &ep_reg->depcmd, USB3_EPCMD_ACT_BIT, 0);
+}
+
+uint8_t usb3_dep_startxfer(usb3_pcd_t *pcd,
+			   usb3_dev_ep_regs_t *ep_reg,
+			   phys_addr_t dma_addr, uint32_t stream_or_uf)
+{
+	uint32_t depcmd;
+
+	dma_addr = map_to_dma_addr(dma_addr);
+
+	/* Set param 1 */
+	usb3_wr32(&ep_reg->depcmdpar1, dma_addr & 0xffffffffU);
+
+	/* Set param 0 */
+	usb3_wr32(&ep_reg->depcmdpar0, 0);
+
+	usb3_wr32(&ep_reg->depcmd,
+		 (stream_or_uf << USB3_EPCMD_STR_NUM_OR_UF_SHIFT) |
+		 USB3_EPCMD_START_XFER | USB3_EPCMD_ACT_BIT);
+
+	/* Wait for command completion */
+	handshake(pcd->usb3_dev, &ep_reg->depcmd, USB3_EPCMD_ACT_BIT, 0);
+
+	depcmd = usb3_rd32(&ep_reg->depcmd);
+
+	return (depcmd >> USB3_EPCMD_XFER_RSRC_IDX_SHIFT) &
+	       (USB3_EPCMD_XFER_RSRC_IDX_BITS >> USB3_EPCMD_XFER_RSRC_IDX_SHIFT);
+}
+
+void usb3_dep_updatexfer(usb3_pcd_t *pcd,
+			    usb3_dev_ep_regs_t *ep_reg,
+			    uint32_t tri)
+{
+	/* Start the command */
+	usb3_wr32(&ep_reg->depcmd,
+		 (tri << USB3_EPCMD_XFER_RSRC_IDX_SHIFT) |
+		 USB3_EPCMD_UPDATE_XFER | USB3_EPCMD_ACT_BIT);
+
+	/* Wait for command completion */
+	handshake(pcd->usb3_dev, &ep_reg->depcmd, USB3_EPCMD_ACT_BIT, 0);
+}
+
+void usb3_enable_ep(usb3_pcd_t *pcd, usb3_pcd_ep_t *ep)
+{
+	uint32_t ep_index_num, dalepena;
+
+	ep_index_num = ep->num * 2;
+	if (ep->is_in)
+		ep_index_num += 1;
+
+	dalepena = usb3_rd32(&pcd->dev_global_regs->dalepena);
+
+	/* If we have already enabled this EP, leave it alone
+	 * (shouldn't happen)
+	 */
+	if (dalepena & (1 << ep_index_num))
+		return;
+
+	dalepena |= 1 << ep_index_num;
+	usb3_wr32(&pcd->dev_global_regs->dalepena, dalepena);
+	return;
+}
+
+void usb3_dis_usb2_suspend(usb3_pcd_t *pcd)
+{
+	uint32_t usb2phycfg;
+
+	if (pcd->speed == USB_SPEED_SUPER)
+		return;
+
+	usb2phycfg = usb3_rd32(&pcd->usb3_dev->core_global_regs->gusb2phycfg[0]);
+	usb2phycfg &= ~USB3_USB2PHYCFG_SUS_PHY_BIT;
+	usb2phycfg &= ~USB3_USB2PHYCFG_ENBL_SLP_M_BIT;
+	usb3_wr32(&pcd->usb3_dev->core_global_regs->gusb2phycfg[0], usb2phycfg);
+}
+
+void usb3_ep0_activate(usb3_pcd_t *pcd)
+{
+	uint32_t diepcfg0, doepcfg0, diepcfg1, doepcfg1;
+	uint32_t diepcfg2 = 0, doepcfg2 = 0;
+	usb3_dev_ep_regs_t *ep_reg;
+
+	diepcfg0 = USB3_EP_TYPE_CONTROL << USB3_EPCFG0_EPTYPE_SHIFT;
+	diepcfg1 = USB3_EPCFG1_XFER_CMPL_BIT | USB3_EPCFG1_XFER_IN_PROG_BIT | USB3_EPCFG1_XFER_NRDY_BIT | USB3_EPCFG1_EP_DIR_BIT;
+
+	doepcfg0 = USB3_EP_TYPE_CONTROL << USB3_EPCFG0_EPTYPE_SHIFT;
+	doepcfg1 = USB3_EPCFG1_XFER_CMPL_BIT | USB3_EPCFG1_XFER_IN_PROG_BIT | USB3_EPCFG1_XFER_NRDY_BIT;
+
+	/* Default to MPS of 512 (will reconfigure after ConnectDone event) */
+	diepcfg0 |= 512 << USB3_EPCFG0_MPS_SHIFT;
+	doepcfg0 |= 512 << USB3_EPCFG0_MPS_SHIFT;
+
+	diepcfg0 |= pcd->ep0.tx_fifo_num << USB3_EPCFG0_TXFNUM_SHIFT;
+
+	/* Issue "DEPCFG" command to EP0-OUT */
+
+	ep_reg = &pcd->out_ep_regs[0];
+	usb3_dis_usb2_suspend(pcd);
+	/* If core is version 1.09a or later */
+	/* Must issue DEPSTRTNEWCFG command first */
+	usb3_dep_startnewcfg(pcd, ep_reg, 0);
+
+	usb3_dep_cfg(pcd, ep_reg, doepcfg0, doepcfg1, doepcfg2);
+
+	/* Issue "DEPSTRMCFG" command to EP0-OUT */
+
+	/* One stream */
+	usb3_dep_xfercfg(pcd, ep_reg, 1);
+
+	/* Issue "DEPCFG" command to EP0-IN */
+
+	ep_reg = &pcd->in_ep_regs[0];
+	usb3_dep_cfg(pcd, ep_reg, diepcfg0, diepcfg1, diepcfg2);
+
+	/* Issue "DEPSTRMCFG" command to EP0-IN */
+
+	/* One stream */
+	usb3_dep_xfercfg(pcd, ep_reg, 1);
+
+	pcd->ep0.active = 1;
+}
+
+void usb3_ep_activate(usb3_pcd_t *pcd, usb3_pcd_ep_t *ep)
+{
+	usb3_dev_ep_regs_t *ep_reg, *ep0_reg;
+	uint32_t depcfg0, depcfg1, depcfg2 = 0;
+
+	/*
+	 * Get the appropriate EP registers
+	 */
+	if (ep->is_in)
+		ep_reg = ep->in_ep_reg;
+	else
+		ep_reg = ep->out_ep_reg;
+
+	/* If this is first EP enable (ie. start of a new configuration) */
+	if (!pcd->eps_enabled) {
+		pcd->eps_enabled = 1;
+
+		/* NOTE: When setting a new configuration, we must issue a
+		 * "DEPCFG" command to physical EP1 (logical EP0-IN) first.
+		 * This resets the core's Tx FIFO mapping table
+		 */
+		depcfg0 = USB3_EP_TYPE_CONTROL << USB3_EPCFG0_EPTYPE_SHIFT;
+		depcfg0 |= USB3_CFG_ACTION_MODIFY << USB3_EPCFG0_CFG_ACTION_SHIFT;
+		depcfg1 = USB3_EPCFG1_XFER_CMPL_BIT | USB3_EPCFG1_XFER_NRDY_BIT
+			| USB3_EPCFG1_EP_DIR_BIT;
+
+		switch (pcd->speed) {
+		case USB_SPEED_SUPER:
+			depcfg0 |= 512 << USB3_EPCFG0_MPS_SHIFT;
+			break;
+
+		case USB_SPEED_HIGH:
+		case USB_SPEED_FULL:
+			depcfg0 |= 64 << USB3_EPCFG0_MPS_SHIFT;
+			break;
+
+		case USB_SPEED_LOW:
+			depcfg0 |= 8 << USB3_EPCFG0_MPS_SHIFT;
+			break;
+		}
+
+		ep0_reg = &pcd->in_ep_regs[0];
+		usb3_dep_cfg(pcd, ep0_reg, depcfg0, depcfg1, 0);
+
+		/* If core is version 1.09a or later */
+		/* Must issue DEPSTRTNEWCFG command first */
+		ep0_reg = &pcd->out_ep_regs[0];
+		usb3_dep_startnewcfg(pcd, ep0_reg, 2);
+	}
+
+	/*
+	 * Issue "DEPCFG" command to EP
+	 */
+	depcfg0 = ep->type << USB3_EPCFG0_EPTYPE_SHIFT;
+	depcfg0 |= ep->maxpacket << USB3_EPCFG0_MPS_SHIFT;
+
+	if (ep->is_in) {
+		depcfg0 |= ep->tx_fifo_num << USB3_EPCFG0_TXFNUM_SHIFT;
+	}
+
+	depcfg0 |= ep->maxburst << USB3_EPCFG0_BRSTSIZ_SHIFT;
+
+	depcfg1 = ep->num << USB3_EPCFG1_EP_NUM_SHIFT;
+
+	if (ep->is_in)
+		depcfg1 |= USB3_EPCFG1_EP_DIR_BIT;
+
+	depcfg1 |= USB3_EPCFG1_XFER_CMPL_BIT;
+
+	usb3_dep_cfg(pcd, ep_reg, depcfg0, depcfg1, depcfg2);
+
+	/*
+	 * Issue "DEPSTRMCFG" command to EP
+	 */
+	/* Setting 1 stream resource */
+	usb3_dep_xfercfg(pcd, ep_reg, 1);
+
+	/* Enable EP in DALEPENA reg */
+	usb3_enable_ep(pcd, ep);
+
+	ep->active = 1;
+}
+
+void usb3_ep0_out_start(usb3_pcd_t *pcd)
+{
+	usb3_dev_ep_regs_t *ep_reg;
+	usb3_dma_desc_t *desc;
+	uint32_t desc_dma;
+	uint8_t tri;
+
+	/* Get the SETUP packet DMA Descriptor (TRB) */
+	desc = pcd->ep0_setup_desc;
+	desc_dma = (phys_addr_t)pcd->ep0_setup_desc;
+
+	/* DMA Descriptor setup */
+	usb3_fill_desc(desc, (phys_addr_t)pcd->ep0_setup_pkt,
+			   pcd->ep0.maxpacket,
+			   0, USB3_DSCCTL_TRBCTL_SETUP, USB3_DSCCTL_IOC_BIT |
+			   USB3_DSCCTL_ISP_BIT | USB3_DSCCTL_LST_BIT, 1);
+
+	ep_reg = &pcd->out_ep_regs[0];
+
+	/* Issue "DEPSTRTXFER" command to EP0-OUT */
+	tri = usb3_dep_startxfer(pcd, ep_reg, desc_dma, 0);
+	pcd->ep0.tri_out = tri;
+}
+
+void usb3_core_dev_init(usb3_device_t *dev)
+{
+	usb3_core_global_regs_t *global_regs = dev->core_global_regs;
+	usb3_pcd_t *pcd = &dev->pcd;
+	usb3_dev_global_regs_t *dev_global_regs = pcd->dev_global_regs;
+	uint32_t temp_t;
+
+	/* Soft-reset the core */
+	do {
+		temp_t = usb3_rd32(&dev_global_regs->dctl);
+		temp_t &= ~USB3_DCTL_RUN_STOP_BIT;
+		temp_t |= USB3_DCTL_CSFT_RST_BIT;
+		usb3_wr32(&dev_global_regs->dctl, temp_t);
+		do {
+			udelay_100us(1);
+			temp_t = usb3_rd32(&dev_global_regs->dctl);
+		} while(temp_t & USB3_DCTL_CSFT_RST_BIT);
+
+		/* Wait for at least 3 PHY clocks */
+		msleep(1);
+	} while(0);
+
+	pcd->link_state = 0;
+
+	/* Set Turnaround Time = 9 (8-bit UTMI+ / ULPI) */
+	temp_t = usb3_rd32(&global_regs->gusb2phycfg[0]);
+	temp_t &= ~USB3_USB2PHYCFG_USB_TRD_TIM_BITS;
+	temp_t |= 9 << USB3_USB2PHYCFG_USB_TRD_TIM_SHIFT;
+	usb3_wr32(&global_regs->gusb2phycfg[0], temp_t);
+
+	temp_t = 0x13802004;
+	usb3_wr32(&global_regs->gctl, temp_t);
+
+	usb_info("evnt buffer addr: 0x%x\n", dev->event_buf);
+
+	usb3_init_eventbuf(dev, USB3_EVENT_BUF_SIZE, (phys_addr_t)dev->event_buf);
+	dev->event_ptr = dev->event_buf;
+
+	/* Set speed to Super */
+	temp_t = usb3_rd32(&pcd->dev_global_regs->dcfg);
+	temp_t &= ~(USB3_DCFG_DEVSPD_BITS << USB3_DCFG_DEVSPD_SHIFT);
+    temp_t |= USB3_SPEED_HS_PHY_30MHZ_OR_60MHZ
+				<< USB3_DCFG_DEVSPD_SHIFT;
+	usb3_wr32(&pcd->dev_global_regs->dcfg, temp_t);
+
+	/* If LPM enable was requested */
+	temp_t = usb3_rd32(&pcd->dev_global_regs->dcfg);
+	temp_t |= USB3_DCFG_LPM_CAP_BIT;
+	usb3_wr32(&pcd->dev_global_regs->dcfg, temp_t);
+
+	/* Set Nump */
+	temp_t = usb3_rd32(&pcd->dev_global_regs->dcfg);
+	temp_t &= ~USB3_DCFG_NUM_RCV_BUF_BITS;
+	temp_t |= 16 << USB3_DCFG_NUM_RCV_BUF_SHIFT;
+	usb3_wr32(&pcd->dev_global_regs->dcfg, temp_t);
+
+	usb3_set_address(pcd, 0);
+
+	/* disable Phy suspend */
+	usb3_resume_usb3_phy(pcd);
+	usb3_resume_usb2_phy(pcd);
+	/* Enable Global and Device interrupts */
+	usb3_enable_device_interrupts(dev);
+
+	/* Activate EP0 */
+	usb3_ep0_activate(pcd);
+
+	/* Start EP0 to receive SETUP packets */
+	usb3_ep0_out_start(pcd);
+
+	/* Enable EP0-OUT/IN in DALEPENA register */
+	usb3_wr32(&pcd->dev_global_regs->dalepena, 3);
+
+	/* Set Run/Stop bit */
+	temp_t = usb3_rd32(&pcd->dev_global_regs->dctl);
+	temp_t |= USB3_DCTL_RUN_STOP_BIT;
+	usb3_wr32(&pcd->dev_global_regs->dctl, temp_t);
+}
+
+void usb3_pcd_init(usb3_device_t *dev)
+{
+	usb3_pcd_t *pcd = &dev->pcd;
+
+	pcd->usb3_dev = dev;
+	pcd->speed = USB_SPEED_UNKNOWN;
+
+	/* Initialize EP structures */
+	pcd_epinit(pcd);
+
+	/* Initialize the Core (also enables interrupts and sets Run/Stop bit) */
+	usb3_core_dev_init(dev);
+}
+
+void usb3_common_init(usb3_device_t *dev, volatile uint8_t *base)
+{
+	usb3_pcd_t *pcd;
+
+	dev->core_global_regs = (usb3_core_global_regs_t *)(base + USB3_CORE_GLOBAL_REG_OFFSET);
+
+	pcd = &dev->pcd;
+
+	pcd->dev_global_regs = (usb3_dev_global_regs_t *)(base + USB3_DEV_GLOBAL_REG_OFFSET);
+	pcd->out_ep_regs = (usb3_dev_ep_regs_t *)(base + USB3_DEV_OUT_EP_REG_OFFSET);
+	pcd->in_ep_regs = (usb3_dev_ep_regs_t *)(base + USB3_DEV_IN_EP_REG_OFFSET);
+}
+
+void usb3_init(usb3_device_t *dev)
+{
+	/* Init the PCD (also enables interrupts and sets Run/Stop bit) */
+	usb3_pcd_init(dev);
+}
+
+static uint8_t string_manu[]= {'G',0,'o',0,'k',0,'e',0};
+static uint8_t string_prod[]= {'U',0,'S',0,'B',0,'B',0,'u',0,'r',0,'n',0};
+int usb3_driver_init(void)
+{
+	usb3_device_t *usb3_dev;
+	struct usb_device_descriptor *usb3_dev_desc;
+
+	usb3_dev = malloc(sizeof(usb3_device_t));
+	if (!usb3_dev) {
+		debug("usb3_dev: out of memory\n");
+		return -ENOMEM;
+	}
+	usb3_memset((void *)usb3_dev, 0, sizeof(usb3_device_t));
+	usb3_dev_desc = malloc(sizeof(struct usb_device_descriptor));
+	usb3_pcd_t *pcd = &usb3_dev->pcd;
+	usb3_pcd_ep_t *ep = &pcd->in_ep;
+	usb3_pcd_req_t *req = &ep->req;
+	req->bufdma = (uint8_t *)malloc(512);
+	usb_info("size of usb3_dev %d\n", sizeof(*usb3_dev));
+	usb3_dev->base = (volatile uint8_t *)USB3_CTRL_REG_BASE;
+	usb3_dev->string_manu_len = sizeof(string_manu);
+	usb3_dev->string_prod_len = sizeof(string_prod);
+	usb3_dev->dev_desc = usb3_dev_desc;
+	memcpy(usb3_dev->string_manu, string_manu, usb3_dev->string_manu_len);
+	memcpy(usb3_dev->string_prod, string_prod, usb3_dev->string_prod_len);
+	usb3_dev->pcd.ep0_setup_desc = (usb3_dma_desc_t *)
+				((phys_addr_t)(usb3_dev->pcd.ep0_setup + 15) & (uint32_t)(~15));
+	usb3_dev->pcd.ep0_in_desc = (usb3_dma_desc_t *)
+				((phys_addr_t)(usb3_dev->pcd.ep0_in + 15) & (uint32_t)(~15));
+	usb3_dev->pcd.ep0_out_desc = (usb3_dma_desc_t *)
+				((phys_addr_t)(usb3_dev->pcd.ep0_out + 15) & (uint32_t)(~15));
+	usb3_dev->pcd.in_ep.ep_desc = (usb3_dma_desc_t *)
+				((phys_addr_t)(usb3_dev->pcd.in_ep.epx_desc + 15) & (uint32_t)(~15));
+	usb3_dev->pcd.out_ep.ep_desc = (usb3_dma_desc_t *)
+				((phys_addr_t)(usb3_dev->pcd.out_ep.epx_desc + 15) & (uint32_t)(~15));
+
+	/* Release usb3.0 controller */
+
+	phy_usb_init(0);
+
+	/* Get usb3.0 version number */
+	usb3_dev->snpsid = usb3_rd32((volatile uint32_t *)
+		(usb3_dev->base + USB3_CORE_REG_BASE + USB3_CORE_GSNPSID_REG_OFFSET));
+
+	/* Initialize usb3.0 core */
+	usb3_common_init(usb3_dev, usb3_dev->base + USB3_CORE_REG_BASE);
+
+	/* Initialize usb3.0 pcd */
+	usb3_init(usb3_dev);
+
+	usb_info("usb init done\n");
+	for (;;)
+		usb3_handle_event(usb3_dev);
+
+}
+
+/*
+ * Interface func for download the mirror, address from return.
+ */
+void udc_connect(void)
+{
+	dcache_disable();
+	usb3_driver_init();
+	dcache_enable();
+}
+EXPORT_SYMBOL(udc_connect);
diff -uraN u-boot-2016.11/drivers/usb/gadget/udc3/usb3_drv.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/usb3_drv.h
--- u-boot-2016.11/drivers/usb/gadget/udc3/usb3_drv.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/usb3_drv.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,250 @@
+#ifndef __USB3_DRIVER_H__
+#define	__USB3_DRIVER_H__
+
+#include "sys.h"
+#include "usb3.h"
+#include "usb3_hw.h"
+#include "debug.h"
+
+/* time limit of waiting for key enents */
+#define USB_WAIT_FOR_ENUM_DONE_TIME_MS (300 * 1000)
+#define USB_WAIT_FOR_RX_NEXT_TIME_MS (60 * 1000)
+
+enum usb_error_type {
+	USB_RX_NEXT_TIMEOUT = -5,
+	USB_ENUM_DONE_TIMEOUT = -3,
+	USB_PROCESS_ERR = -1,
+	USB_NO_ERR = 0,
+};
+
+struct usb_data_handle {
+	UINT32  uFileType;
+	UINT32  uFileAddress;
+	UINT32  uFileLength;
+
+	UINT32 IsRxStart;
+
+	UINT32 InitTimeStamp;
+	UINT32 RxTimeStamp;
+};
+
+#define USB_DEBUG
+
+#ifdef USB_DEBUG
+#define dbg(format, arg...) \
+	do {                    \
+		debug_printf("[%s]", __func__);     \
+		debug_printf(format, ##arg);     \
+	} while(0);
+#else
+#define dbg(format, arg...)
+#endif
+
+#define usb_info(format, arg...) debug_printf("[USBINFO]"format, ##arg);
+#define usb_err(format, arg...) debug_printf("[USBERR]"format, ##arg);
+
+typedef enum pcd_state {
+	USB3_STATE_UNCONNECTED,	/* no host */
+	USB3_STATE_DEFAULT,
+	USB3_STATE_ADDRESSED,
+	USB3_STATE_CONFIGURED,
+} pcdstate_e;
+
+typedef enum ep0_state {
+	EP0_IDLE,
+	EP0_IN_DATA_PHASE,
+	EP0_OUT_DATA_PHASE,
+	EP0_IN_WAIT_NRDY,
+	EP0_OUT_WAIT_NRDY,
+	EP0_IN_STATUS_PHASE,
+	EP0_OUT_STATUS_PHASE,
+	EP0_STALL,
+} ep0state_e;
+
+typedef union usb_setup_pkt {
+    usb_device_request_t req;
+    uint32_t d32[2];
+    uint8_t d8[8];
+} usb_setup_pkt_t;
+
+typedef struct usb3_pcd_req {
+    usb3_dma_desc_t *trb;
+    phys_addr_t trbdma;
+
+    uint32_t length;
+    uint32_t actual;
+
+   // void *bufdma;
+   uint8_t *bufdma;
+    void (*complete)(void *);
+} usb3_pcd_req_t;
+
+typedef struct usb3_pcd_ep {
+    struct usb3_pcd *pcd;
+
+    usb3_dev_ep_regs_t *out_ep_reg;
+    usb3_dev_ep_regs_t *in_ep_reg;
+
+    uint8_t phys;
+    uint8_t num;
+    uint8_t type;
+    uint8_t maxburst;
+    uint16_t maxpacket;
+    /* Tx FIFO # for IN EPs */
+    uint8_t tx_fifo_num;
+
+    /* The Transfer Resource Index from the Start Transfer command */
+    uint8_t tri_out;
+    uint8_t tri_in;
+
+    uint8_t stopped;
+    /* Send ZLP */
+    uint8_t send_zlp;
+    /* True if 3-stage control transfer */
+    uint8_t three_stage;
+    /* True if transfer has been started on EP */
+    uint8_t xfer_started;
+    /* EP direction 0 = OUT */
+    uint8_t is_in;
+    /* True if endpoint is active */
+    uint8_t active;
+    /* Initial data pid of bulk endpoint */
+    uint8_t data_pid_start;
+
+    /* ep_desc (excluding ep0) */
+    usb3_dma_desc_t *ep_desc;
+
+    /* TRB descriptor must be aligned to 16 bytes */
+    uint8_t epx_desc[32];
+
+    /* request (excluding ep0) */
+    usb3_pcd_req_t req;
+} usb3_pcd_ep_t;
+
+typedef struct usb3_pcd {
+    struct usb3_device *usb3_dev;
+
+    int32_t link_state;
+    pcdstate_e state;
+    uint8_t new_config;
+    ep0state_e ep0state;
+
+    uint32_t eps_enabled;
+    uint32_t ltm_enable;
+
+    usb3_pcd_ep_t ep0;
+    usb3_pcd_ep_t out_ep;
+    usb3_pcd_ep_t in_ep;
+
+    usb3_dev_global_regs_t *dev_global_regs;
+    usb3_dev_ep_regs_t *out_ep_regs;
+    usb3_dev_ep_regs_t *in_ep_regs;
+
+    usb3_pcd_req_t ep0_req;
+
+    uint8_t speed;
+
+    usb3_dma_desc_t *ep0_setup_desc;
+    usb3_dma_desc_t *ep0_in_desc;
+    usb3_dma_desc_t *ep0_out_desc;
+
+    /* TRB descriptor must be aligned to 16 bytes */
+    uint8_t ep0_setup[32];
+    uint8_t ep0_in[32];
+    uint8_t ep0_out[32];
+
+    usb_setup_pkt_t ep0_setup_pkt[5];
+
+#define USB3_STATUS_BUF_SIZE    512
+    uint8_t ep0_status_buf[USB3_STATUS_BUF_SIZE];
+
+#define USB3_BULK_BUF_SIZE      512
+    uint8_t ss_bulk_buf[USB3_BULK_BUF_SIZE];
+
+    uint32_t file_type;
+    uint32_t file_address;
+    uint32_t file_capacity;
+    uint32_t file_total_frame;
+    uint32_t file_curr_frame;
+    uint32_t file_next_frame;
+    uint32_t file_received;
+    uint32_t file_complete;
+} usb3_pcd_t;
+
+#define usb3_pcd_ep_to_pcd(pcd_ep) ((pcd_ep)->usb3_pcd_ep_t.pcd)
+#define usb3_pcd_ep_num(pcd_ep) ((pcd_ep)->usb3_pcd_ep_t.num)
+#define usb3_pcd_ep_type(pcd_ep) ((pcd_ep)->usb3_pcd_ep_t.type)
+#define usb3_pcd_ep_is_in(pcd_ep) ((pcd_ep)->usb3_pcd_ep_t.is_in)
+
+#define dwc_usb3_is_hwo(desc)	((desc)->control & USB3_DSCCTL_HWO_BIT)
+#define dwc_usb3_is_ioc(desc)	((desc)->control & USB3_DSCCTL_IOC_BIT)
+
+#define usb3_get_xfercnt(desc)				\
+	(((desc)->status >> USB3_DSCSTS_XFRCNT_SHIFT) &		\
+	 (USB3_DSCSTS_XFRCNT_BITS >> USB3_DSCSTS_XFRCNT_SHIFT))
+#define usb3_get_xfersts(desc)				\
+	(((desc)->status >> USB3_DSCSTS_TRBRSP_SHIFT) &		\
+	 (USB3_DSCSTS_TRBRSP_BITS >> USB3_DSCSTS_TRBRSP_SHIFT))
+
+#define map_to_dma_addr(addr)				\
+	((addr))
+//	((addr) + (REG_BASE_LP_RAM_ACORE - REG_BASE_LP_RAM))
+
+typedef struct usb3_device {
+    volatile uint8_t *base;
+    void *dev_desc;
+    uint8_t string_manu[32];
+    uint8_t string_prod[32];
+    uint32_t string_manu_len;
+    uint32_t string_prod_len;
+    usb3_pcd_t pcd;
+    uint32_t snpsid;
+    usb3_core_global_regs_t *core_global_regs;
+
+#define	USB3_EVENT_BUF_SIZE		256
+    uint32_t event_buf[USB3_EVENT_BUF_SIZE];
+    uint32_t *event_ptr;
+    struct usb_data_handle *p_handle;
+} usb3_device_t;
+
+void usb3_memset(void *buf, uint8_t value, uint32_t size);
+void usb3_memcpy(void *dst, void *src, uint32_t size);
+uint32_t usb3_rd32(volatile uint32_t *addr);
+void usb3_wr32(volatile uint32_t *addr, uint32_t val);
+void usb3_set_address(usb3_pcd_t *pcd, uint32_t addr);
+void usb3_accept_u1(usb3_pcd_t *pcd);
+void usb3_accept_u2(usb3_pcd_t *pcd);
+void usb3_enable_u1(usb3_pcd_t *pcd);
+void usb3_enable_u2(usb3_pcd_t *pcd);
+void usb3_disable_u1(usb3_pcd_t *pcd);
+void usb3_disable_u2(usb3_pcd_t *pcd);
+uint32_t usb3_u1_enabled(usb3_pcd_t *pcd);
+uint32_t usb3_u2_enabled(usb3_pcd_t *pcd);
+void usb3_dep_cstall(usb3_pcd_t *pcd,
+			usb3_dev_ep_regs_t *ep_reg);
+void usb3_dep_sstall(usb3_pcd_t *pcd,
+			usb3_dev_ep_regs_t *ep_reg);
+uint32_t handshake(usb3_device_t *dev, volatile uint32_t *ptr,
+		      uint32_t mask, uint32_t done);
+void usb3_fill_desc(usb3_dma_desc_t *desc, phys_addr_t dma_addr,
+			uint32_t dma_len, uint32_t stream, uint32_t type,
+			uint32_t ctrlbits, int own);
+void usb3_dep_startnewcfg(usb3_pcd_t *pcd,
+			usb3_dev_ep_regs_t *ep_reg, uint32_t rsrcidx);
+void usb3_dep_cfg(usb3_pcd_t *pcd, usb3_dev_ep_regs_t *ep_reg,
+		    uint32_t depcfg0, uint32_t depcfg1, uint32_t depcfg2);
+void usb3_dep_xfercfg(usb3_pcd_t *pcd,
+			usb3_dev_ep_regs_t *ep_reg, uint32_t depstrmcfg);
+uint8_t usb3_dep_startxfer(usb3_pcd_t *pcd, usb3_dev_ep_regs_t *ep_reg,
+			phys_addr_t dma_addr, uint32_t stream_or_uf);
+void usb3_dep_updatexfer(usb3_pcd_t *pcd,
+			    usb3_dev_ep_regs_t *ep_reg,
+			    uint32_t tri);
+void usb3_ep_activate(usb3_pcd_t *pcd, usb3_pcd_ep_t *ep);
+void usb3_ep0_out_start(usb3_pcd_t *pcd);
+void usb3_ep0_start_transfer(usb3_pcd_t *pcd, usb3_pcd_req_t *req);
+void usb3_resume_usb2_phy(usb3_pcd_t *pcd);
+//int usb_connected = 0;
+
+#endif /* __USB3_DRIVER_H */
+
diff -uraN u-boot-2016.11/drivers/usb/gadget/udc3/usb3.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/usb3.h
--- u-boot-2016.11/drivers/usb/gadget/udc3/usb3.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/usb3.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,244 @@
+#ifndef __USB3_H__
+#define __USB3_H__
+
+#include "asm/types.h"
+#include "types.h"
+
+#define UCONSTW(x)	{ (x) & 0xff, ((x) >> 8) & 0xff }
+#define UCONSTDW(x)	{ (x) & 0xff, ((x) >> 8) & 0xff, \
+			  ((x) >> 16) & 0xff, ((x) >> 24) & 0xff }
+
+#define STRING_LANGUAGE         0
+#define STRING_MANUFACTURER     1
+#define STRING_PRODUCT          2
+
+#define USB_SPEED_UNKNOWN	    0x00
+#define USB_SPEED_LOW		    0x01
+#define USB_SPEED_FULL		    0x02
+#define USB_SPEED_HIGH		    0x03
+#define USB_SPEED_VARIABLE	    0x04
+#define USB_SPEED_SUPER		    0x05
+
+#define  UDESC_DEVICE		    0x01
+#define  UDESC_CONFIG		    0x02
+#define  UDESC_STRING		    0x03
+#define  UDESC_INTERFACE	    0x04
+#define  UDESC_ENDPOINT		    0x05
+#define  UDESC_SS_USB_COMPANION	0x30
+#define  UDESC_DEVICE_QUALIFIER	0x06
+#define  UDESC_BOS		        0x0f
+#define  UDESC_DEVICE_CAPABILITY 0x10
+
+#define UT_GET_DIR(a) ((a) & 0x80)
+#define UT_WRITE		0x00
+#define UT_READ			0x80
+
+#define UT_GET_TYPE(a) ((a) & 0x60)
+#define UT_STANDARD		0x00
+#define UT_CLASS		0x20
+#define UT_VENDOR		0x40
+
+#define UT_GET_RECIPIENT(a) ((a) & 0x1f)
+#define UT_DEVICE		0x00
+#define UT_INTERFACE    0x01
+#define UT_ENDPOINT		0x02
+#define UT_OTHER		0x03
+
+#define UR_GET_STATUS		0x00
+#define UR_CLEAR_FEATURE	0x01
+#define UR_SET_FEATURE		0x03
+#define UR_SET_ADDRESS		0x05
+#define UR_GET_DESCRIPTOR	0x06
+#define UR_SET_DESCRIPTOR	0x07
+#define UR_GET_CONFIG		0x08
+#define UR_SET_CONFIG		0x09
+#define UR_GET_INTERFACE	0x0a
+#define UR_SET_INTERFACE	0x0b
+#define UR_SYNCH_FRAME		0x0c
+#define UR_SET_SEL		    0x30
+#define UR_SET_ISOC_DELAY	0x31
+
+/* Feature numbers */
+#define UF_ENDPOINT_HALT	        0
+#define UF_DEVICE_REMOTE_WAKEUP	    1
+#define UF_TEST_MODE		        2
+#define UF_DEVICE_B_HNP_ENABLE	    3
+#define UF_DEVICE_A_HNP_SUPPORT	    4
+#define UF_DEVICE_A_ALT_HNP_SUPPORT 5
+#define UF_FUNCTION_SUSPEND	0
+#define UF_U1_ENABLE		48
+#define UF_U2_ENABLE		49
+#define UF_LTM_ENABLE		50
+
+/* OTG feature selectors */
+#define UOTG_B_HNP_ENABLE	    3
+#define UOTG_A_HNP_SUPPORT	    4
+#define UOTG_A_ALT_HNP_SUPPORT	5
+#define UOTG_NTF_HOST_REL	    51
+#define UOTG_B3_RSP_ENABLE	    52
+
+#define UE_GET_DIR(a)	((a) & 0x80)
+#define UE_SET_DIR(a,d)	((a) | (((d)&1) << 7))
+#define UE_DIR_IN	0x80
+#define UE_DIR_OUT	0x00
+#define UE_ADDR		0x0f
+#define UE_GET_ADDR(a)	((a) & UE_ADDR)
+
+/** Maxpacket size for EP0, defined by USB3 spec */
+#define USB3_MAX_EP0_SIZE	    512
+
+/** Maxpacket size for any EP, defined by USB3 spec */
+#define USB3_MAX_PACKET_SIZE	    1024
+#define USB2_HS_MAX_PACKET_SIZE     512
+#define USB2_FS_MAX_PACKET_SIZE     64
+
+#define USB3_BULK_IN_EP         1
+#define USB3_BULK_OUT_EP        1
+
+typedef struct usb_device_request {
+    uint8_t bmRequestType;
+    uint8_t bRequest;
+    uint16_t wValue;
+    uint16_t wIndex;
+    uint16_t wLength;
+} usb_device_request_t;
+
+#pragma pack(1)
+/** USB_DT_DEVICE: Device descriptor */
+typedef struct usb_device_descriptor {
+	uint8_t  bLength;
+	uint8_t  bDescriptorType;
+
+	uint16_t bcdUSB;
+#define USB_CLASS_COMM          0x02
+#define USB_CLASS_VENDOR_SPEC   0xFF
+#define USB_SC_VENDOR_SPEC      0xFF
+#define USB_PR_VENDOR_SPEC      0xFF
+	uint8_t  bDeviceClass;
+	uint8_t  bDeviceSubClass;
+	uint8_t  bDeviceProtocol;
+	uint8_t  bMaxPacketSize0;
+	uint16_t idVendor;
+	uint16_t idProduct;
+	uint16_t bcdDevice;
+	uint8_t  iManufacturer;
+	uint8_t  iProduct;
+	uint8_t  iSerialNumber;
+	uint8_t  bNumConfigurations;
+} usb_device_descriptor_t;
+
+/* USB_DT_CONFIG: Config descriptor */
+typedef struct usb_config_descriptor {
+	uint8_t  bLength;
+	uint8_t  bDescriptorType;
+
+	uint16_t wTotalLength;
+	uint8_t  bNumInterfaces;
+#define CONFIG_VALUE    1
+	uint8_t  bConfigurationValue;
+	uint8_t  iConfiguration;
+#define USB_CONFIG_ATT_ONE      (1 << 7)
+	uint8_t  bmAttributes;
+#define USB_CONFIG_VBUS_DRAW    (0xFA)
+	uint8_t  bMaxPower;
+} usb_config_descriptor_t;
+
+/* USB_DT_DEVICE_QUALIFIER: Device Qualifier descriptor */
+typedef struct usb_qualifier_descriptor {
+	uint8_t  bLength;
+	uint8_t  bDescriptorType;
+
+	uint16_t bcdUSB;
+	uint8_t  bDeviceClass;
+	uint8_t  bDeviceSubClass;
+	uint8_t  bDeviceProtocol;
+	uint8_t  bMaxPacketSize0;
+	uint8_t  bNumConfigurations;
+	uint8_t  bRESERVED;
+} usb_qualifier_descriptor_t;
+
+/* USB_DT_INTERFACE: Interface descriptor */
+typedef struct usb_interface_descriptor {
+	uint8_t  bLength;
+	uint8_t  bDescriptorType;
+
+	uint8_t  bInterfaceNumber;
+	uint8_t  bAlternateSetting;
+	uint8_t  bNumEndpoints;
+	uint8_t  bInterfaceClass;
+	uint8_t  bInterfaceSubClass;
+	uint8_t  bInterfaceProtocol;
+	uint8_t  iInterface;
+} usb_interface_descriptor_t;
+
+/* USB_DT_ENDPOINT: Endpoint descriptor */
+typedef struct usb_endpoint_descriptor {
+	uint8_t  bLength;
+	uint8_t  bDescriptorType;
+
+	uint8_t  bEndpointAddress;
+	uint8_t  bmAttributes;
+#define USB_ENDPOINT_XFER_CONTROL	0x00
+#define USB_ENDPOINT_XFER_ISOC		0x01
+#define USB_ENDPOINT_XFER_BULK		0x02
+#define USB_ENDPOINT_XFER_INT		0x03
+	uint16_t wMaxPacketSize;
+	uint8_t  bInterval;
+} usb_endpoint_descriptor_t;
+
+/* USB_DT_SS_ENDPOINT_COMP: SuperSpeed Endpoint Companion descriptor */
+typedef struct usb_ss_ep_comp_descriptor {
+	uint8_t  bLength;
+	uint8_t  bDescriptorType;
+
+	uint8_t  bMaxBurst;
+	uint8_t  bmAttributes;
+	uint16_t wBytesPerInterval;
+} usb_ss_ep_comp_descriptor_t;
+
+/* WUSB BOS Descriptor (Binary device Object Store) */
+typedef struct wusb_bos_desc {
+	uint8_t bLength;
+	uint8_t bDescriptorType;
+	uint16_t wTotalLength;
+	uint8_t bNumDeviceCaps;
+} wusb_bos_desc_t;
+
+#define USB_DEVICE_CAPABILITY_20_EXTENSION	0x02
+typedef struct usb_dev_cap_20_ext_desc {
+	uint8_t bLength;
+	uint8_t bDescriptorType;
+	uint8_t bDevCapabilityType;
+#define USB_20_EXT_LPM				0x02
+	uint32_t bmAttributes;
+} usb_dev_cap_20_ext_desc_t;
+
+#define USB_DEVICE_CAPABILITY_SS_USB		0x03
+typedef struct usb_dev_cap_ss_usb {
+	uint8_t bLength;
+	uint8_t bDescriptorType;
+	uint8_t bDevCapabilityType;
+#define USB_DC_SS_USB_LTM_CAPABLE		0x02
+	uint8_t bmAttributes;
+#define USB_DC_SS_USB_SPEED_SUPPORT_LOW		0x01
+#define USB_DC_SS_USB_SPEED_SUPPORT_FULL	0x02
+#define USB_DC_SS_USB_SPEED_SUPPORT_HIGH	0x04
+#define USB_DC_SS_USB_SPEED_SUPPORT_SS		0x08
+	uint32_t wSpeedsSupported;
+	uint8_t bFunctionalitySupport;
+	uint8_t bU1DevExitLat;
+	uint32_t wU2DevExitLat;
+} usb_dev_cap_ss_usb_t;
+
+#define USB_DEVICE_CAPABILITY_CONTAINER_ID	0x04
+typedef struct usb_dev_cap_container_id {
+	uint8_t bLength;
+	uint8_t bDescriptorType;
+	uint8_t bDevCapabilityType;
+	uint8_t bReserved;
+	uint8_t containerID[16];
+} usb_dev_cap_container_id_t;
+#pragma pack()
+
+#endif /* __USB3_H__ */
+
diff -uraN u-boot-2016.11/drivers/usb/gadget/udc3/usb3_hw.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/usb3_hw.h
--- u-boot-2016.11/drivers/usb/gadget/udc3/usb3_hw.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/usb3_hw.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,1729 @@
+#ifndef __USB3_HW_H__
+#define __USB3_HW_H__
+
+#include "usb3.h"
+
+/****************************************************************************/
+/* Core Global Registers */
+
+/**
+ * This enum represents the bit fields of the Core SoC Bus Configuration 0
+ * Register (GSBUSCFG0).
+ */
+typedef enum gsbuscfg0_data {
+	/** Bus Burst Len			<i>Access: R_W</i>.
+	 * - 0:   single
+	 * - 1:   incr
+	 * - 3:   incr4
+	 * - 7:   incr8
+	 * - 15:  incr16
+	 * - 31:  incr32  (non-AHB mode only)
+	 * - 63:  incr64  (non-AHB mode only)
+	 * - 127: incr128 (non-AHB mode only)
+	 * - 255: incr256 (non-AHB mode only)
+	 */
+	USB3_SBUSCFG0_HBURSTLEN_BITS		= 0x000000ff,
+	USB3_SBUSCFG0_HBURSTLEN_SHIFT		= 0,
+
+	USB3_SBUSCFG0_INT_DMA_BURST_SINGLE	= 0,
+	USB3_SBUSCFG0_INT_DMA_BURST_INCR    = 1,
+	USB3_SBUSCFG0_INT_DMA_BURST_INCR4	= 3,
+	USB3_SBUSCFG0_INT_DMA_BURST_INCR8	= 7,
+	USB3_SBUSCFG0_INT_DMA_BURST_INCR16	= 15,
+	USB3_SBUSCFG0_INT_DMA_BURST_INCR32	= 31,
+	USB3_SBUSCFG0_INT_DMA_BURST_INCR64	= 63,
+	USB3_SBUSCFG0_INT_DMA_BURST_INCR128	= 127,
+	USB3_SBUSCFG0_INT_DMA_BURST_INCR256	= 255,
+
+	/** Descriptor Write is Posted		<i>Access: R_W</i> */
+	USB3_SBUSCFG0_DES_WR_POST_BIT		= 0x00000100,
+	USB3_SBUSCFG0_DES_WR_POST_SHIFT		= 8,
+
+	/** Data Write is Posted		<i>Access: R_W</i> */
+	USB3_SBUSCFG0_DAT_WR_POST_BIT		= 0x00000200,
+	USB3_SBUSCFG0_DAT_WR_POST_SHIFT		= 9,
+
+	/** Descriptor Access is Big-Endian	<i>Access: R_W</i> */
+	USB3_SBUSCFG0_DES_BIG_END_BIT		= 0x00000400,
+	USB3_SBUSCFG0_DES_BIG_END_SHIFT		= 10,
+
+	/** Data Access is Big-Endian		<i>Access: R_W</i> */
+	USB3_SBUSCFG0_DAT_BIG_END_BIT		= 0x00000800,
+	USB3_SBUSCFG0_DAT_BIG_END_SHIFT		= 11,
+
+	/** Store and Forward Mode		<i>Access: R_W</i> */
+	USB3_SBUSCFG0_STORE_AND_FORWARD_BIT	    = 0x00001000,
+	USB3_SBUSCFG0_STORE_AND_FORWARD_SHIFT	= 12,
+
+	/** Force Single Request		<i>Access: R_W</i> */
+	USB3_SBUSCFG0_SING_REQ_BIT		    = 0x00004000,
+	USB3_SBUSCFG0_SING_REQ_SHIFT		= 14,
+
+	/** Descriptor Readback Enable		<i>Access: R_W</i> */
+	USB3_SBUSCFG0_READ_AFTER_WRITE_BIT	    = 0x00008000,
+	USB3_SBUSCFG0_READ_AFTER_WRITE_SHIFT	= 15,
+
+	/** Descriptor Write Request Info	<i>Access: R_W</i> */
+	USB3_SBUSCFG0_DES_WR_REQ_INFO_BITS	= 0x000f0000,
+	USB3_SBUSCFG0_DES_WR_REQ_INFO_SHIFT	= 16,
+
+	/** Data Write Request Info		<i>Access: R_W</i> */
+	USB3_SBUSCFG0_DAT_WR_REQ_INFO_BITS	= 0x00f00000,
+	USB3_SBUSCFG0_DAT_WR_REQ_INFO_SHIFT	= 20,
+
+	/** Descriptor Read Request Info	<i>Access: R_W</i> */
+	USB3_SBUSCFG0_DES_RD_REQ_INFO_BITS	= 0x0f000000,
+	USB3_SBUSCFG0_DES_RD_REQ_INFO_SHIFT	= 24,
+
+	/** Data Read Request Info		<i>Access: R_W</i> */
+	USB3_SBUSCFG0_DAT_RD_REQ_INFO_BITS	= 0xf0000000,
+	USB3_SBUSCFG0_DAT_RD_REQ_INFO_SHIFT	= 28,
+} gsbuscfg0_data_t;
+
+/**
+ * This enum represents the bit fields of the Core SoC Bus Configuration 1
+ * Register (GSBUSCFG1).
+ */
+typedef enum gsbuscfg1_data {
+	/** OCP Address Space For Descriptor	<i>Access: R_W</i> */
+	USB3_SBUSCFG1_DES_ADDR_SPC_BITS		= 0x0000000f,
+	USB3_SBUSCFG1_DES_ADDR_SPC_SHIFT		= 0,
+
+	/** OCP Address Space For Data		<i>Access: R_W</i> */
+	USB3_SBUSCFG1_DAT_ADDR_SPC_BITS		= 0x000000f0,
+	USB3_SBUSCFG1_DAT_ADDR_SPC_SHIFT		= 4,
+} gsbuscfg1_data_t;
+
+/**
+ * This enum represents the bit fields of the Core Tx Threshold Control
+ * Register (GTXTHRCFG).
+ */
+typedef enum gtxthrcfg_data {
+	/** SoC Bus Transmit Threshold Length		<i>Access: R_W</i> */
+	USB3_TXTHRCFG_SBUS_THR_LEN_BITS		= 0x000007ff,
+	USB3_TXTHRCFG_SBUS_THR_LEN_SHIFT		= 0,
+
+	/** SoC Bus Non-ISO Transmit Threshold Enable	<i>Access: R_W</i> */
+	USB3_TXTHRCFG_SBUS_NON_ISO_THR_EN_BIT	= 0x00004000,
+	USB3_TXTHRCFG_SBUS_NON_ISO_THR_EN_SHIFT	= 14,
+
+	/** SoC Bus ISO Transmit Threshold Enable	<i>Access: R_W</i> */
+	USB3_TXTHRCFG_SBUS_ISO_THR_EN_BIT	= 0x00008000,
+	USB3_TXTHRCFG_SBUS_ISO_THR_EN_SHIFT	= 15,
+
+	/** USB Transmit Threshold Length		<i>Access: R_W</i> */
+	USB3_TXTHRCFG_USB_THR_LEN_BITS		= 0x1fff0000,
+	USB3_TXTHRCFG_USB_THR_LEN_SHIFT		= 16,
+
+	/** USB Non-ISO Transmit Threshold Enable	<i>Access: R_W</i> */
+	USB3_TXTHRCFG_USB_NON_ISO_THR_EN_BIT	= 0x40000000,
+	USB3_TXTHRCFG_USB_NON_ISO_THR_EN_SHIFT	= 30,
+
+	/** USB ISO Transmit Threshold Enable		<i>Access: R_W</i> */
+	USB3_TXTHRCFG_USB_ISO_THR_EN_BIT		= 0x80000000,
+	USB3_TXTHRCFG_USB_ISO_THR_EN_SHIFT	= 31,
+} gtxthrcfg_data_t;
+
+/**
+ * This enum represents the bit fields of the Core Rx Threshold Control
+ * Register (GRXTHRCFG).
+ */
+typedef enum grxthrcfg_data {
+	/** Receive Threshold Length		<i>Access: R_W</i> */
+	USB3_RXTHRCTL_THR_LEN_BITS	= 0x07ff,
+	USB3_RXTHRCTL_THR_LEN_SHIFT	= 0,
+
+	/** Receive Threshold Enable		<i>Access: R_W</i> */
+	USB3_RXTHRCTL_THR_EN_BIT		= 0x8000,
+	USB3_RXTHRCTL_THR_EN_SHIFT	= 15,
+} grxthrcfg_data_t;
+
+/**
+ * This enum represents the bit fields of the Core Control
+ * Register (GCTL).
+ */
+typedef enum gctl_data {
+	/** Disable Clock Gating		<i>Access: R_W</i> */
+	USB3_GCTL_DSBL_CLCK_GTNG_BIT	= 0x00000001,
+	USB3_GCTL_DSBL_CLCK_GTNG_SHIFT	= 0,
+
+	/** Global Hibernation Enable		<i>Access: R_W</i> */
+	USB3_GCTL_GBL_HIBER_EN_BIT	= 0x00000002,
+	USB3_GCTL_GBL_HIBER_EN_SHIFT	= 1,
+
+	/** U2Exit LFPS		                <i>Access: R_W</i> */
+	USB3_GCTL_GBL_U2EXIT_LFPS	= 0x00000004,
+	USB3_GCTL_GBL_U2EXIT_LFPS_SHIFT	= 2,
+
+	/** Disable Scrambling			<i>Access: R_W</i> */
+	USB3_GCTL_DIS_SCRAMBLE_BIT	= 0x00000008,
+	USB3_GCTL_DIS_SCRAMBLE_SHIFT	= 3,
+
+	/** Scale-down Mode			<i>Access: R_W</i> */
+	USB3_GCTL_SCALE_DOWN_BITS	= 0x00000030,
+	USB3_GCTL_SCALE_DOWN_SHIFT	= 4,
+
+	/** RAM Clock Select			<i>Access: R_W</i> */
+	USB3_GCTL_RAM_CLK_SEL_BITS	= 0x000000c0,
+	USB3_GCTL_RAM_CLK_SEL_SHIFT	= 6,
+
+	/** Debug Attach			<i>Access: R_W</i> */
+	USB3_GCTL_DEBUG_ATTACH_BIT	= 0x00000100,
+	USB3_GCTL_DEBUG_ATTACH_SHIFT	= 8,
+
+	/** Loopback Enable			<i>Access: R_W</i> */
+	USB3_GCTL_LPBK_EN_BIT		= 0x00000200,
+	USB3_GCTL_LPBK_EN_SHIFT		= 9,
+
+	/** Local Loopback Enable		<i>Access: R_W</i> */
+	USB3_GCTL_LOCAL_LPBK_EN_BIT	= 0x00000400,
+	USB3_GCTL_LOCAL_LPBK_EN_SHIFT	= 10,
+
+	/** Core Soft Reset			<i>Access: R_W</i> */
+	USB3_GCTL_CORE_SOFT_RST_BIT	= 0x00000800,
+	USB3_GCTL_CORE_SOFT_RST_SHIFT	= 11,
+
+	/** Port Capability Direction		<i>Access: R_W</i> */
+	USB3_GCTL_PRT_CAP_DIR_BITS	= 0x00003000,
+	USB3_GCTL_PRT_CAP_DIR_SHIFT	= 12,
+
+	/** Port Capability Values */
+	USB3_GCTL_PRT_CAP_HOST		= 1,
+	USB3_GCTL_PRT_CAP_DEVICE		= 2,
+	USB3_GCTL_PRT_CAP_OTG		= 3,
+
+	/** Frame Scale Down			<i>Access: R_W</i> */
+	USB3_GCTL_FRMSCLDWN_BITS		= 0x0000c000,
+	USB3_GCTL_FRMSCLDWN_SHIFT	= 14,
+
+	/** U2 Reset ECN			<i>Access: R_W</i> */
+	USB3_GCTL_U2RSTECN_BIT		= 0x00010000,
+	USB3_GCTL_U2RSTECN_SHIFT		= 16,
+
+	/** Power Down Scale			<i>Access: R_W</i> */
+	USB3_GCTL_PWR_DN_SCALE_BITS	= 0xfff80000,
+	USB3_GCTL_PWR_DN_SCALE_SHIFT	= 19,
+} gctl_data_t;
+
+/**
+ * This enum represents the bit fields of the Core Interrupt Mask
+ * Register (GEVTEN).
+ */
+typedef enum gevten_data {
+	/** ULPI Carkit Event Enable		<i>Access: R_W</i> */
+	USB3_GEVTEN_ULPI_CK_EVT_EN_BIT	= 0x00000001,
+	USB3_GEVTEN_ULPI_CK_EVT_SHIFT	= 0,
+
+	/** I2C Event Enable			<i>Access: R_W</i> */
+	USB3_GEVTEN_I2C_EVT_EN_BIT	= 0x00000002,
+	USB3_GEVTEN_I2C_EVT_EN_SHIFT	= 1,
+} gevten_data_t;
+
+/**
+ * This enum represents the bit fields of the Core Status
+ * Register (GSTS).
+ */
+typedef enum gsts_data {
+	/** Current Mode			<i>Access: RO</i>.
+	 * - 0: Device Mode
+	 * - 1: Host Mode
+	 * - 2: DRD Mode
+	 */
+	USB3_GSTS_CURMODE_BITS		= 0x00000003,
+	USB3_GSTS_CURMODE_SHIFT		= 0,
+
+	USB3_GSTS_DEVICE_MODE		= 0,
+	USB3_GSTS_HOST_MODE		= 1,
+	USB3_GSTS_DRD_MODE		= 2,
+
+	/** Bus Error Address Valid		<i>Access: RO</i> */
+	USB3_GSTS_BUS_ERR_ADDR_VLD_BIT	= 0x00000010,
+	USB3_GSTS_BUS_ERR_ADDR_VLD_SHIFT	= 4,
+
+	/** CSR Timeout */
+	USB3_GSTS_CSR_TIMEOUT_BIT	= 0x00000020,
+	USB3_GSTS_CSR_TIMEOUT_SHIFT	= 5,
+
+	/** Device Interrupt Pending */
+	USB3_GSTS_DEV_EVT_PENDING_BIT	= 0x00000040,
+	USB3_GSTS_DEV_EVT_PENDING_SHIFT	= 6,
+
+	/** Host Interrupt Pending */
+	USB3_GSTS_HOST_EVT_PENDING_BIT	= 0x00000080,
+	USB3_GSTS_HOST_EVT_PENDING_SHIFT	= 7,
+
+	/** ADP Interrupt Pending */
+	USB3_GSTS_ADP_EVT_PENDING_BIT	= 0x00000100,
+	USB3_GSTS_ADP_EVT_PENDING_SHIFT	= 8,
+
+	/** BC Interrupt Pending */
+	USB3_GSTS_BC_EVT_PENDING_BIT	= 0x00000200,
+	USB3_GSTS_BC_EVT_PENDING_SHIFT	= 9,
+
+	/** OTG Interrupt Pending */
+	USB3_GSTS_OTG_EVT_PENDING_BIT	= 0x00000400,
+	USB3_GSTS_OTG_EVT_PENDING_SHIFT	= 10,
+
+	/** Current BELT Value			<i>Access: RO</i> */
+	USB3_GSTS_CBELT_BITS		= 0xfff00000,
+	USB3_GSTS_CBELT_SHIFT		= 20,
+} gsts_data_t;
+
+/**
+ * This enum represents the bit fields of the Hardware Parameters 0
+ * Register (GHWPARAMS0).
+ */
+typedef enum ghwparams0_data {
+	USB3_HWP0_MODE_BITS		= 0x00000007,
+	USB3_HWP0_MODE_SHIFT		= 0,
+
+	USB3_HWP0_MBUS_TYPE_BITS		= 0x00000038,
+	USB3_HWP0_MBUS_TYPE_SHIFT	= 3,
+
+	USB3_HWP0_SBUS_TYPE_BITS		= 0x000000c0,
+	USB3_HWP0_SBUS_TYPE_SHIFT	= 6,
+
+	USB3_HWP0_MDWIDTH_BITS		= 0x0000ff00,
+	USB3_HWP0_MDWIDTH_SHIFT		= 8,
+
+	USB3_HWP0_SDWIDTH_BITS		= 0x00ff0000,
+	USB3_HWP0_SDWIDTH_SHIFT		= 16,
+
+	USB3_HWP0_AWIDTH_BITS		= 0x3f000000,
+	USB3_HWP0_AWIDTH_SHIFT		= 24,
+} ghwparams0_data_t;
+
+/**
+ * This enum represents the bit fields of the Hardware Parameters 1
+ * Register (GHWPARAMS1).
+ */
+typedef enum ghwparams1_data {
+	USB3_HWP1_IDWIDTH_M1_BITS		= 0x00000007,
+	USB3_HWP1_IDWIDTH_M1_SHIFT		= 0,
+
+	USB3_HWP1_BURSTWIDTH_M1_BITS		= 0x00000038,
+	USB3_HWP1_BURSTWIDTH_M1_SHIFT		= 3,
+
+	USB3_HWP1_DATAINFOWIDTH_BITS		= 0x000001c0,
+	USB3_HWP1_DATAINFOWIDTH_SHIFT		= 6,
+
+	USB3_HWP1_REQINFOWIDTH_BITS		= 0x00000e00,
+	USB3_HWP1_REQINFOWIDTH_SHIFT		= 9,
+
+	USB3_HWP1_ASPACEWIDTH_BITS		= 0x00007000,
+	USB3_HWP1_ASPACEWIDTH_SHIFT		= 12,
+
+	USB3_HWP1_DEV_NUM_INT_BITS		= 0x001f8000,
+	USB3_HWP1_DEV_NUM_INT_SHIFT		= 15,
+
+	USB3_HWP1_NUM_RAMS_BITS			= 0x00600000,
+	USB3_HWP1_NUM_RAMS_SHIFT			= 21,
+
+	USB3_HWP1_SPRAM_TYP_BIT			= 0x00800000,
+	USB3_HWP1_SPRAM_TYP_SHIFT		= 23,
+
+	USB3_HWP1_EN_PWROPT_BITS			= 0x03000000,
+	USB3_HWP1_EN_PWROPT_SHIFT		= 24,
+
+	USB3_EN_PWROPT_NONE		= 0,
+	USB3_EN_PWROPT_CLK_GATING_ONLY	= 1,
+	USB3_EN_PWROPT_HIBERNATION	= 2,
+
+	USB3_HWP1_MAC_PHY_CLKS_SYNC_BIT		= 0x04000000,
+	USB3_HWP1_MAC_PHY_CLKS_SYNC_SHIFT	= 26,
+
+	USB3_HWP1_MAC_RAM_CLKS_SYNC_BIT		= 0x08000000,
+	USB3_HWP1_MAC_RAM_CLKS_SYNC_SHIFT	= 27,
+
+	USB3_HWP1_RAM_BUS_CLKS_SYNC_BIT		= 0x10000000,
+	USB3_HWP1_RAM_BUS_CLKS_SYNC_SHIFT	= 28,
+
+	USB3_HWP1_RM_OPT_FEATURES_BIT		= 0x40000000,
+	USB3_HWP1_RM_OPT_FEATURES_SHIFT		= 30,
+} ghwparams1_data_t;
+
+/**
+ * This enum represents the bit fields of the Hardware Parameters 2
+ * Register (GHWPARAMS2).
+ */
+typedef enum ghwparams2_data {
+	USB3_HWP2_USERID_BITS	= 0xffffffff,
+	USB3_HWP2_USERID_SHIFT	= 0,
+} ghwparams2_data_t;
+
+/**
+ * This enum represents the bit fields of the Hardware Parameters 3
+ * Register (GHWPARAMS3).
+ */
+typedef enum ghwparams3_data {
+	USB3_HWP3_SSPHY_IFC_BITS		= 0x00000003,
+	USB3_HWP3_SSPHY_IFC_SHIFT	= 0,
+
+	USB3_HWP3_HSPHY_IFC_BITS		= 0x0000000c,
+	USB3_HWP3_HSPHY_IFC_SHIFT	= 2,
+
+	USB3_HWP3_FSPHY_IFC_BITS		= 0x00000030,
+	USB3_HWP3_FSPHY_IFC_SHIFT	= 4,
+
+	USB3_HWP3_HSPHY_DWIDTH_BITS	= 0x000000c0,
+	USB3_HWP3_HSPHY_DWIDTH_SHIFT	= 6,
+
+	USB3_HWP3_VEND_CTL_IFC_BIT	= 0x00000400,
+	USB3_HWP3_VEND_CTL_IFC_SHIFT	= 10,
+
+	USB3_HWP3_ULPI_CARKIT_BIT	= 0x00000800,
+	USB3_HWP3_ULPI_CARKIT_SHIFT	= 11,
+
+	USB3_HWP3_NUM_EPS_BITS		= 0x0003f000,
+	USB3_HWP3_NUM_EPS_SHIFT		= 12,
+
+	USB3_HWP3_NUM_IN_EPS_BITS	= 0x007c0000,
+	USB3_HWP3_NUM_IN_EPS_SHIFT	= 18,
+
+	USB3_HWP3_TOT_XFR_RSRC_BITS	= 0x7f800000,
+	USB3_HWP3_TOT_XFR_RSRC_SHIFT	= 23,
+} ghwparams3_data_t;
+
+/**
+ * This enum represents the bit fields of the Hardware Parameters 4
+ * Register (GHWPARAMS4).
+ */
+typedef enum ghwparams4_data {
+	USB3_HWP4_TRBS_PER_XFER_BITS	= 0x0000003f,
+	USB3_HWP4_TRBS_PER_XFER_SHIFT	= 0,
+
+	USB3_HWP4_HIBER_SPAD_BITS	= 0x0001e000,
+	USB3_HWP4_HIBER_SPAD_SHIFT	= 13,
+
+	USB3_HWP4_NUM_SS_USB_INST_BITS	= 0x001e0000,
+	USB3_HWP4_NUM_SS_USB_INST_SHIFT	= 17,
+
+	USB3_HWP4_EN_ISOC_SUPT_BIT	= 0x00800000,
+	USB3_HWP4_EN_ISOC_SUPT_SHIFT	= 23,
+
+	USB3_HWP4_BMU_PTL_DEPTH_BITS	= 0x0f000000,
+	USB3_HWP4_BMU_PTL_DEPTH_SHIFT	= 24,
+
+	USB3_HWP4_BMU_LSP_DEPTH_BITS	= 0xf0000000,
+	USB3_HWP4_BMU_LSP_DEPTH_SHIFT	= 28,
+} ghwparams4_data_t;
+
+/**
+ * This enum represents the bit fields of the Hardware Parameters 5
+ * Register (GHWPARAMS5).
+ */
+typedef enum ghwparams5_data {
+	USB3_HWP5_BMU_BUSGM_DEPTH_BITS	= 0x0000000f,
+	USB3_HWP5_BMU_BUSGM_DEPTH_SHIFT	= 0,
+
+	USB3_HWP5_RXQ_FIFO_DEPTH_BITS	= 0x000003f0,
+	USB3_HWP5_RXQ_FIFO_DEPTH_SHIFT	= 4,
+
+	USB3_HWP5_TXQ_FIFO_DEPTH_BITS	= 0x0000fc00,
+	USB3_HWP5_TXQ_FIFO_DEPTH_SHIFT	= 10,
+
+	USB3_HWP5_DWQ_FIFO_DEPTH_BITS	= 0x003f0000,
+	USB3_HWP5_DWQ_FIFO_DEPTH_SHIFT	= 16,
+
+	USB3_HWP5_DFQ_FIFO_DEPTH_BITS	= 0x0fc00000,
+	USB3_HWP5_DFQ_FIFO_DEPTH_SHIFT	= 22,
+} ghwparams5_data_t;
+
+/**
+ * This enum represents the bit fields of the Hardware Parameters 6
+ * Register (GHWPARAMS6).
+ */
+typedef enum ghwparams6_data {
+	USB3_HWP6_PSQ_FIFO_DEPTH_BITS	= 0x0000003f,
+	USB3_HWP6_PSQ_FIFO_DEPTH_SHIFT	= 0,
+
+	USB3_HWP6_EN_DBG_PORTS_BIT	= 0x00000040,
+	USB3_HWP6_EN_DBG_PORTS_SHIFT	= 6,
+
+	USB3_HWP6_EN_FPGA_BIT		= 0x00000080,
+	USB3_HWP6_EN_FPGA_SHIFT		= 7,
+
+	USB3_HWP6_EN_SRP_BIT		= 0x00000400,
+	USB3_HWP6_EN_SRP_SHIFT		= 10,
+
+	USB3_HWP6_EN_HNP_BIT		= 0x00000800,
+	USB3_HWP6_EN_HNP_SHIFT		= 11,
+
+	USB3_HWP6_EN_ADP_BIT		= 0x00001000,
+	USB3_HWP6_EN_ADP_SHIFT		= 12,
+
+	USB3_HWP6_EN_OTG_BIT		= 0x00002000,
+	USB3_HWP6_EN_OTG_SHIFT		= 13,
+
+	USB3_HWP6_EN_BC_BIT		= 0x00004000,
+	USB3_HWP6_EN_BC_SHIFT		= 14,
+
+	USB3_HWP6_EN_BUS_FILTERS_BIT	= 0x00008000,
+	USB3_HWP6_EN_BUS_FILTERS_SHIFT	= 15,
+
+	USB3_HWP6_RAM0_DEPTH_BITS	= 0xffff0000,
+	USB3_HWP6_RAM0_DEPTH_SHIFT	= 16,
+} ghwparams6_data_t;
+
+/**
+ * This enum represents the bit fields of the Hardware Parameters 7
+ * Register (GHWPARAMS7).
+ */
+typedef enum ghwparams7_data {
+	USB3_HWP7_RAM1_DEPTH_BITS	= 0x0000ffff,
+	USB3_HWP7_RAM1_DEPTH_SHIFT	= 0,
+
+	USB3_HWP7_RAM2_DEPTH_BITS	= 0xffff0000,
+	USB3_HWP7_RAM2_DEPTH_SHIFT	= 16,
+} ghwparams7_data_t;
+
+/**
+ * This enum represents the bit fields of the Hardware Parameters 8
+ * Register (GHWPARAMS8).
+ */
+typedef enum ghwparams8_data {
+	USB3_HWP8_DCACHE_DEPTH_BITS	= 0xffffffff,
+	USB3_HWP8_DCACHE_DEPTH_SHIFT	= 0,
+} ghwparams8_data_t;
+
+/**
+ * This enum represents the bit fields of the Debug Queue/FIFO Space
+ * Register (GDBGFIFOSPACE).
+ */
+typedef enum gdbgfifospace_data {
+	/** FIFO/Queue Select			<i>Access: R_W</i> */
+	USB3_DBGFIFOSPACE_FIFO_QUEUE_SEL_BITS	= 0x000000ff,
+	USB3_DBGFIFOSPACE_FIFO_QUEUE_SEL_SHIFT	= 0,
+
+	/*   0 - 31  TxFIFO Number   */
+	/*  32 - 63  RxFIFO Number   */
+	/*  64 - 95  TxReqQ Number   */
+	/*  96 - 127 RxReqQ Number   */
+	/* 128 - 159 RxInfoQ Number  */
+	/* 160       DescFetchQ      */
+	/* 161       EventQ          */
+	/* 162       ProtocolStatusQ */
+
+	/** Space Available			<i>Access: R</i> */
+	USB3_DBGFIFOSPACE_SPACE_AVAIL_BITS	= 0xffff0000,
+	USB3_DBGFIFOSPACE_SPACE_AVAIL_SHIFT	= 16,
+} gdbgfifospace_data_t;
+
+/**
+ * This enum represents the bit fields of the Debug LTSSM
+ * Register (GDBGLTSSM).
+ */
+typedef enum gdbgltssm_data {
+	/** Pipe Status				<i>Access: R</i> */
+	USB3_DBGLTSSM_PIPE_STATUS_BITS		= 0x0003ffff,
+	USB3_DBGLTSSM_PIPE_STATUS_SHIFT		= 0,
+
+	/** LTDB SubState			<i>Access: R</i> */
+	USB3_DBGLTSSM_LTDB_SUB_STATE_BITS	= 0x003c0000,
+	USB3_DBGLTSSM_LTDB_SUB_STATE_SHIFT	= 18,
+
+	/** LTDB State				<i>Access: R</i> */
+	USB3_DBGLTSSM_LTDB_STATE_BITS		= 0x03c00000,
+	USB3_DBGLTSSM_LTDB_STATE_SHIFT		= 22,
+
+	/** LTDB Timeout			<i>Access: R</i> */
+	USB3_DBGLTSSM_LTDB_TIMEOUT_BIT		= 0x04000000,
+	USB3_DBGLTSSM_LTDB_TIMEOUT_SHIFT		= 26,
+} gdbgltssm_data_t;
+
+/**
+ * This enum represents the bit fields of the Core USB2 PHY Configuration
+ * Registers (GUSB2PHYCFGn).
+ */
+typedef enum gusb2phycfg_data {
+	/** HS/FS Timeout Calibration			<i>Access: R_W</i> */
+	USB3_USB2PHYCFG_TOUT_CAL_BITS		= 0x00000007,
+	USB3_USB2PHYCFG_TOUT_CAL_SHIFT		= 0,
+
+	/** UTMI+ PHY Intf Width (8-bit/16-bit) SelecT	<i>Access: R_W</i> */
+	USB3_USB2PHYCFG_PHY_IF_BIT		= 0x00000008,
+	USB3_USB2PHYCFG_PHY_IF_SHIFT		= 3,
+	/*--------*/
+	/** ULPI DDR Select				<i>Access: R_W</i> */
+	USB3_USB2PHYCFG_DDR_SEL_BIT		= 0x00000008,
+	USB3_USB2PHYCFG_DDR_SEL_SHIFT		= 3,
+
+	/** UTMI+ / ULPI Select				<i>Access: R_W</i> */
+	USB3_USB2PHYCFG_UTMI_ULPI_BIT		= 0x00000010,
+	USB3_USB2PHYCFG_UTMI_ULPI_SHIFT		= 4,
+
+	/** Full-speed Serial Interface Select		<i>Access: R_W</i> */
+	USB3_USB2PHYCFG_FSINTF_BIT		= 0x00000020,
+	USB3_USB2PHYCFG_FSINTF_SHIFT		= 5,
+
+	/** Suspend USB2 Phy				<i>Access: R_W</i> */
+	USB3_USB2PHYCFG_SUS_PHY_BIT		= 0x00000040,
+	USB3_USB2PHYCFG_SUS_PHY_SHIFT		= 6,
+
+	/** USB2.0 HS PHY/USB1.1 FS Serial Xcvr Select	<i>Access: R_W</i> */
+	USB3_USB2PHYCFG_PHY_SEL_BIT		= 0x00000080,
+	USB3_USB2PHYCFG_PHY_SEL_SHIFT		= 7,
+
+	/** Enable UTMI Sleep				<i>Access: R_W</i> */
+	USB3_USB2PHYCFG_ENBL_SLP_M_BIT		= 0x00000100,
+	USB3_USB2PHYCFG_ENBL_SLP_M_SHIFT		= 8,
+
+	/** USB2.0 Turnaround Time			<i>Access: R_W</i> */
+	USB3_USB2PHYCFG_USB_TRD_TIM_BITS		= 0x00003c00,
+	USB3_USB2PHYCFG_USB_TRD_TIM_SHIFT	= 10,
+
+	/** PHY Low-power Clock Select			<i>Access: R_W</i> */
+	USB3_USB2PHYCFG_PHY_LPWR_CLK_SEL_BIT	= 0x00004000,
+	USB3_USB2PHYCFG_PHY_LPWR_CLK_SEL_SHIFT	= 14,
+
+	/** ULPI Auto Resume				<i>Access: R_W</i> */
+	USB3_USB2PHYCFG_ULPI_AUTO_RES_BIT	= 0x00008000,
+	USB3_USB2PHYCFG_ULPI_AUTO_RES_SHIFT	= 15,
+
+	/** ULPI Clock SuspendM				<i>Access: R_W</i> */
+	USB3_USB2PHYCFG_ULPI_CLK_SUS_M_BIT	= 0x00010000,
+	USB3_USB2PHYCFG_ULPI_CLK_SUS_M_SHIFT	= 16,
+
+	/** ULPI External Vbus Drive			<i>Access: R_W</i> */
+	USB3_USB2PHYCFG_ULPI_EXT_VBUS_DRV_BIT	= 0x00020000,
+	USB3_USB2PHYCFG_ULPI_EXT_VBUS_DRV_SHIFT	= 17,
+
+	/** ULPI External Vbus Indicator		<i>Access: R_W</i> */
+	USB3_USB2PHYCFG_ULPI_EXT_VBUS_IND_BIT	= 0x00040000,
+	USB3_USB2PHYCFG_ULPI_EXT_VBUS_IND_SHIFT	= 18,
+
+	/** PHY Interrupt Number			<i>Access: R_W</i> */
+	USB3_USB2PHYCFG_PHY_INTR_NUM_BITS	= 0x01f80000,
+	USB3_USB2PHYCFG_PHY_INTR_NUM_SHIFT	= 19,
+
+	/** OTG Interrupt Number			<i>Access: R_W</i> */
+	USB3_USB2PHYCFG_OTG_INTR_NUM_BITS	= 0x7e000000,
+	USB3_USB2PHYCFG_OTG_INTR_NUM_SHIFT	= 25,
+
+	/** PHY Soft Reset				<i>Access: R_W</i> */
+	USB3_USB2PHYCFG_PHY_SOFT_RST_BIT		= 0x80000000,
+	USB3_USB2PHYCFG_PHY_SOFT_RST_SHIFT	= 31,
+} gusb2phycfg_data_t;
+
+/**
+ * This enum represents the bit fields in the USB2 I2C Control
+ * Registers (GUSB2I2CCTLn).
+ */
+typedef enum gusb2i2cctl_data {
+	/** All bits are reserved */
+	USB3_USB2I2C_RSVD_BITS		= 0xffffffff,
+	USB3_USB2I2C_RSVD_SHIFT		= 0,
+} gusb2i2cctl_data_t;
+
+/**
+ * This enum represents the bit fields in the USB2 Phy Vendor Control
+ * Registers (GUSB2PHYACCn).
+ */
+typedef enum gusb2phyacc_data {
+	/** Register Data			<i>Access: R_W</i> */
+	USB3_USB2PHY_REGDATA_BITS	= 0x000000ff,
+	USB3_USB2PHY_REGDATA_SHIFT	= 0,
+
+	/** UTMI+ Vendor Ctrl Register Address	<i>Access: R_W</i> */
+	USB3_USB2PHY_VCTRL_BITS		= 0x0000ff00,
+	USB3_USB2PHY_VCTRL_SHIFT		= 8,
+	/*--------*/
+	/** ULPI Extended Register Address	<i>Access: R_W</i> */
+	USB3_USB2PHY_EXTREGADDR_BITS	= 0x00003f00,
+	USB3_USB2PHY_EXTREGADDR_SHIFT	= 8,
+
+	/** Register Address			<i>Access: R_W</i> */
+	USB3_USB2PHY_REGADDR_BITS	= 0x003f0000,
+	USB3_USB2PHY_REGADDR_SHIFT	= 16,
+
+	/** Register Write			<i>Access: R_W</i> */
+	USB3_USB2PHY_REGWR_BIT		= 0x00400000,
+	USB3_USB2PHY_REGWR_SHIFT		= 22,
+
+	/** VStatus Busy			<i>Access: RO</i> */
+	USB3_USB2PHY_VSTSBSY_BIT		= 0x00800000,
+	USB3_USB2PHY_VSTSBSY_SHIFT	= 23,
+
+	/** VStatus Done			<i>Access: R_SS_SC</i> */
+	USB3_USB2PHY_VSTSDONE_BIT	= 0x01000000,
+	USB3_USB2PHY_VSTSDONE_SHIFT	= 24,
+
+	/** New Register Request		<i>Access: R_WS_SC</i> */
+	USB3_USB2PHY_NEWREGREQ_BIT	= 0x02000000,
+	USB3_USB2PHY_NEWREGREQ_SHIFT	= 25,
+
+	/** Disable ULPI Drivers		<i>Access: R_WS_SC</i> */
+	USB3_USB2PHY_DIS_ULPI_DRVR_BIT	= 0x04000000,
+	USB3_USB2PHY_DIS_ULPI_DRVR_SHIFT	= 26,
+} gusb2phyacc_data_t;
+
+/**
+ * This enum represents the bit fields of the USB3 Pipe Control
+ * Registers (GUSB3PIPECTLn).
+ */
+typedef enum gusb3pipectl_data {
+	/** Elastic Buffer Mode			<i>Access: R_W</i> */
+	USB3_PIPECTL_ELAS_BUF_MODE_BIT		= 0x00000001,
+	USB3_PIPECTL_ELAS_BUF_MODE_SHIFT		= 0,
+
+	/** Tx De-Emphasis			<i>Access: R_W</i> */
+	USB3_PIPECTL_TX_DEMPH_BITS		= 0x00000006,
+	USB3_PIPECTL_TX_DEMPH_SHIFT		= 1,
+
+	/** Tx Margin				<i>Access: R_W</i> */
+	USB3_PIPECTL_TX_MARGIN_BITS		= 0x00000038,
+	USB3_PIPECTL_TX_MARGIN_SHIFT		= 3,
+
+	/** Tx Swing				<i>Access: R_W</i> */
+	USB3_PIPECTL_TX_SWING_BIT		= 0x00000040,
+	USB3_PIPECTL_TX_SWING_SHIFT		= 6,
+
+	/** Port Operation Direction		<i>Access: R_W</i> */
+	USB3_PIPECTL_PRT_OP_DIR_BITS		= 0x00000180,
+	USB3_PIPECTL_PRT_OP_DIR_SHIFT		= 7,
+
+	/** LFPS Filter				<i>Access: R_W</i> */
+	USB3_PIPECTL_LFPS_FILTER_BIT		= 0x00000200,
+	USB3_PIPECTL_LFPS_FILTER_SHIFT		= 9,
+
+	/** P3 Exit Signal In P2		<i>Access: R_W</i> */
+	USB3_PIPECTL_P3_EX_SIG_P2_BIT		= 0x00000400,
+	USB3_PIPECTL_P3_EX_SIG_P2_SHIFT		= 10,
+
+	/** P3-P2 Transitions OK		<i>Access: R_W</i> */
+	USB3_PIPECTL_P3_P2_TRAN_OK_BIT		= 0x00000800,
+	USB3_PIPECTL_P3_P2_TRAN_OK_SHIFT		= 11,
+
+	/** LFPS P0 Align			<i>Access: R_W</i> */
+	USB3_PIPECTL_LFPS_P0_ALGN_BIT		= 0x00001000,
+	USB3_PIPECTL_LFPS_P0_ALGN_SHIFT		= 12,
+
+	/** Pipe Data Width			<i>Access: R_W</i> */
+	USB3_PIPECTL_DATA_WIDTH_BITS		= 0x00018000,
+	USB3_PIPECTL_DATA_WIDTH_SHIFT		= 15,
+
+	/** Suspend USB3 Phy			<i>Access: R_W</i> */
+	USB3_PIPECTL_SUS_PHY_BIT			= 0x00020000,
+	USB3_PIPECTL_SUS_PHY_SHIFT		= 17,
+
+	/** PHY Soft Reset			<i>Access: R_W</i> */
+	USB3_PIPECTL_PHY_SOFT_RST_BIT		= 0x80000000,
+	USB3_PIPECTL_PHY_SOFT_RST_SHIFT		= 31,
+} gusb3pipectl_data_t;
+
+/**
+ * This enum represents the bit fields in the FIFO Size Registers.
+ */
+typedef enum gfifosize_data {
+	/** Depth				<i>Access: R_W</i> */
+	USB3_FIFOSZ_DEPTH_BITS		= 0x0000ffff,
+	USB3_FIFOSZ_DEPTH_SHIFT		= 0,
+
+	/** Starting Address			<i>Access: RO or R_W</i> */
+	USB3_FIFOSZ_STARTADDR_BITS	= 0xffff0000,
+	USB3_FIFOSZ_STARTADDR_SHIFT	= 16,
+} gfifosize_data_t;
+
+/**
+ * This enum represents the bit fields of the Event Buffer Size
+ * Registers (GEVENTSIZn).
+ */
+typedef enum geventsiz_data {
+	/** Event Buffer Size			<i>Access: R_W</i> */
+	USB3_EVENTSIZ_SIZ_BITS		= 0x0000ffff,
+	USB3_EVENTSIZ_SIZ_SHIFT		= 0,
+
+	/** Event Interrupt Mask (1 == disable)	<i>Access: R_W</i> */
+	USB3_EVENTSIZ_INT_MSK_BIT	= 0x80000000,
+	USB3_EVENTSIZ_INT_MSK_SHIFT	= 31,
+} geventsiz_data_t;
+
+/**
+ * This enum represents the bit fields of the Event Buffer Count
+ * Registers (GEVENTCNTn).
+ */
+typedef enum geventcnt_data {
+	/** Event Count				<i>Access: R_W</i> */
+	USB3_EVENTCNT_CNT_BITS		= 0x0000ffff,
+	USB3_EVENTCNT_CNT_SHIFT		= 0,
+} geventcnt_data_t;
+
+/**
+ * This enum represents the bit fields of a generic Event Buffer entry.
+ */
+typedef enum gevent_data {
+	/** Non-Endpoint Specific Event flag */
+	USB3_EVENT_NON_EP_BIT			= 0x01,
+	USB3_EVENT_NON_EP_SHIFT			= 0,
+
+	/** Non-Endpoint Specific Event Type */
+	USB3_EVENT_INTTYPE_BITS			= 0xfe,
+	USB3_EVENT_INTTYPE_SHIFT			= 1,
+
+	/** Non-Endpoint Specific Event Type values */
+	USB3_EVENT_DEV_INT		= 0,	/** @< */
+	USB3_EVENT_OTG_INT		= 1,	/** @< */
+	USB3_EVENT_CARKIT_INT		= 3,	/** @< */
+	USB3_EVENT_I2C_INT		= 4,
+} gevent_data_t;
+
+/**
+ * This enum represents the non-generic bit fields of an Event Buffer entry
+ * for Device Specific events (DEVT).
+ */
+typedef enum devt_data {
+	/** Device Specific Event Type */
+	USB3_DEVT_BITS				= 0x00000f00,
+	USB3_DEVT_SHIFT				= 8,
+
+	/** Device Specific Event Type values */
+	USB3_DEVT_DISCONN		= 0,	/** @< */
+	USB3_DEVT_USBRESET		= 1,	/** @< */
+	USB3_DEVT_CONNDONE		= 2,	/** @< */
+	USB3_DEVT_ULST_CHNG		= 3,	/** @< */
+	USB3_DEVT_WKUP			= 4,	/** @< */
+	USB3_DEVT_HIBER_REQ		= 5,	/** @< */
+	USB3_DEVT_EOPF			= 6,	/** @< */
+	USB3_DEVT_SOF			= 7,	/** @< */
+	USB3_DEVT_ERRATICERR		= 9,	/** @< */
+	USB3_DEVT_CMD_CMPL		= 10,	/** @< */
+	USB3_DEVT_OVERFLOW		= 11,	/** @< */
+	USB3_DEVT_VNDR_DEV_TST_RCVD	= 12,	/** @< */
+	USB3_DEVT_INACT_TIMEOUT_RCVD	= 13,
+
+	/** Event Information */
+	USB3_DEVT_EVT_INFO_BITS			= 0xffff0000,
+	USB3_DEVT_EVT_INFO_SHIFT			= 16,
+
+	/** USB/Link State */
+	USB3_DEVT_ULST_STATE_BITS		= 0x000f0000,
+	USB3_DEVT_ULST_STATE_SHIFT		= 16,
+
+	/** USB/Link State values in SS */
+	USB3_LINK_STATE_U0		= 0,	/** @< */
+	USB3_LINK_STATE_U1		= 1,	/** @< */
+	USB3_LINK_STATE_U2		= 2,	/** @< */
+	USB3_LINK_STATE_U3		= 3,	/** @< */
+	USB3_LINK_STATE_SS_DIS		= 4,	/** @< */
+	USB3_LINK_STATE_RX_DET		= 5,	/** @< */
+	USB3_LINK_STATE_SS_INACT		= 6,	/** @< */
+	USB3_LINK_STATE_POLL		= 7,	/** @< */
+	USB3_LINK_STATE_RECOV		= 8,	/** @< */
+	USB3_LINK_STATE_HRESET		= 9,	/** @< */
+	USB3_LINK_STATE_CMPLY		= 10,	/** @< */
+	USB3_LINK_STATE_LPBK		= 11,	/** @< */
+	USB3_LINK_STATE_RESET		= 14,	/** @< */
+	USB3_LINK_STATE_RESUME		= 15,
+
+	/** USB/Link State values in HS/FS/LS */
+	USB3_LINK_STATE_ON		    = 0,	/** @< */
+	USB3_LINK_STATE_SLEEP		= 2,	/** @< */
+	USB3_LINK_STATE_SUSPEND		= 3,	/** @< */
+	USB3_LINK_STATE_EARLY_SUSPEND	= 5,
+
+	USB3_DEVT_ULST_SS_BIT			= 0x00100000,
+	USB3_DEVT_ULST_SS_SHIFT			= 20,
+
+#define USB3_DEVT_HIBER_STATE_BITS	USB3_DEVT_ULST_STATE_BITS
+#define USB3_DEVT_HIBER_STATE_SHIFT	USB3_DEVT_ULST_STATE_SHIFT
+
+#define USB3_DEVT_HIBER_SS_BIT		USB3_DEVT_ULST_SS_BIT
+#define USB3_DEVT_HIBER_SS_SHIFT    USB3_DEVT_ULST_SS_SHIFT
+
+	USB3_DEVT_HIBER_HIRD_BITS		= 0x0f000000,
+	USB3_DEVT_HIBER_HIRD_SHIFT		= 24,
+} devt_data_t;
+
+/**
+ * This enum represents the bit fields of an Event Buffer entry for
+ * Endpoint Specific events (DEPEVT).
+ */
+typedef enum depevt_data {
+	/** Endpoint Number */
+	USB3_DEPEVT_EPNUM_BITS			= 0x0000003e,
+	USB3_DEPEVT_EPNUM_SHIFT			= 1,
+
+	/** Endpoint Event Type */
+	USB3_DEPEVT_INTTYPE_BITS			= 0x000003c0,
+	USB3_DEPEVT_INTTYPE_SHIFT		= 6,
+
+	/** Endpoint Event Type values */
+	USB3_DEPEVT_XFER_CMPL		    = 1,	/** @< */
+	USB3_DEPEVT_XFER_IN_PROG		= 2,	/** @< */
+	USB3_DEPEVT_XFER_NRDY		    = 3,	/** @< */
+	USB3_DEPEVT_FIFOXRUN		    = 4,	/** @< */
+	USB3_DEPEVT_STRM_EVT		    = 6,	/** @< */
+	USB3_DEPEVT_EPCMD_CMPL		    = 7,
+
+	/** Event Status for Start Xfer Command */
+	USB3_DEPEVT_NO_MORE_RSCS_BIT		= 0x00001000,
+	USB3_DEPEVT_NO_MORE_RSCS_SHIFT		= 12,
+	USB3_DEPEVT_ISOC_TIME_PASSED_BIT    = 0x00002000,
+	USB3_DEPEVT_ISOC_TIME_PASSED_SHIFT	= 13,
+
+	/** Event Status for Stream Event */
+	USB3_DEPEVT_STRM_EVT_BITS		= 0x0000f000,
+	USB3_DEPEVT_STRM_EVT_SHIFT		= 12,
+
+	/** Stream Event Status values */
+	USB3_DEPEVT_STRM_FOUND		= 1,	/** @< */
+	USB3_DEPEVT_STRM_NOT_FOUND	= 2,
+
+	/** Event Status for Xfer Complete or Xfer In Progress Event */
+	USB3_DEPEVT_BUS_ERR_BIT			= 0x00001000,
+	USB3_DEPEVT_BUS_ERR_SHIFT		= 12,
+	USB3_DEPEVT_SHORT_PKT_BIT		= 0x00002000,
+	USB3_DEPEVT_SHORT_PKT_SHIFT		= 13,
+	USB3_DEPEVT_IOC_BIT			    = 0x00004000,
+	USB3_DEPEVT_IOC_SHIFT			= 14,
+	USB3_DEPEVT_LST_BIT			    = 0x00008000,
+	USB3_DEPEVT_LST_SHIFT			= 15,
+#define USB3_DEPEVT_MISSED_ISOC_BIT	    USB3_DEPEVT_LST_BIT
+#define USB3_DEPEVT_MISSED_ISOC_SHIFT	USB3_DEPEVT_LST_SHIFT
+
+	/** Event Status for Xfer Not Ready Event */
+	USB3_DEPEVT_CTRL_BITS			    = 0x00003000,
+	USB3_DEPEVT_CTRL_SHIFT			    = 12,
+	USB3_DEPEVT_XFER_ACTIVE_BIT		    = 0x00008000,
+	USB3_DEPEVT_XFER_ACTIVE_SHIFT		= 15,
+
+	/** Xfer Not Ready Event Status values */
+	USB3_DEPEVT_CTRL_SETUP		= 0,	/** @< */
+	USB3_DEPEVT_CTRL_DATA		= 1,	/** @< */
+	USB3_DEPEVT_CTRL_STATUS		= 2,
+
+	/** Stream ID */
+	USB3_DEPEVT_STRM_ID_BITS			= 0xffff0000,
+	USB3_DEPEVT_STRM_ID_SHIFT		    = 16,
+
+	/** Isoc uFrame Number (for Xfer Not Ready on Isoc EP) */
+	USB3_DEPEVT_ISOC_UFRAME_NUM_BITS    = 0xffff0000,
+	USB3_DEPEVT_ISOC_UFRAME_NUM_SHIFT   = 16,
+
+	/** Xfer Resource Index (for Start Xfer Command) */
+	USB3_DEPEVT_XFER_RSC_IDX_BITS		= 0x007f0000,
+	USB3_DEPEVT_XFER_RSC_IDX_SHIFT		= 16,
+
+	/** Current Data Sequence Number (for Get Endpoint State Command) */
+	USB3_DEPEVT_CUR_DAT_SEQ_NUM_BITS    = 0x001f0000,
+	USB3_DEPEVT_CUR_DAT_SEQ_NUM_SHIFT	= 16,
+
+	/** Flow Control State (for Get Endpoint State Command) */
+	USB3_DEPEVT_FLOW_CTRL_BIT		= 0x00200000,
+	USB3_DEPEVT_FLOW_CTRL_SHIFT		= 21,
+} depevt_data_t;
+
+/**
+ * This enum represents the non-generic bit fields of an Event Buffer entry
+ * for other Core events (GEVT).
+ */
+typedef enum gevt_data {
+	/** PHY Port Number */
+	USB3_GINT_PHY_PORT_BITS		= 0xf00,
+	USB3_GINT_PHY_PORT_SHIFT		= 8,
+} gevt_data_t;
+
+/**
+ * This struct represents the 32-bit register fields of the Event Buffer
+ * Registers (GEVENTBUFn).
+ */
+typedef struct geventbuf_data {
+	/** Event Buffer Address Register Low Word */
+	volatile uint32_t geventadr_lo;
+
+	/** Event Buffer Address Register High Word */
+	volatile uint32_t geventadr_hi;
+
+	/** Event Buffer Size Register.
+	 * Fields defined in enum @ref geventsiz_data. */
+	volatile uint32_t geventsiz;
+
+	/** Event Buffer Count Register.
+	 * Fields defined in enum @ref geventcnt_data. */
+	volatile uint32_t geventcnt;
+} geventbuf_data_t;
+
+#define USB3_CORE_REG_BASE	0xC000
+
+/**
+ * Core Global Registers	<i>Offsets 100h-5FCh</i>.
+ *
+ * The dwc_usb3_core_global_regs structure defines the size
+ * and relative field offsets for the Core Global Registers.
+ */
+typedef struct usb3_core_global_regs {
+
+#define USB3_CORE_GLOBAL_REG_OFFSET	0x100
+
+	/** Core BIU Configuration 0 Register	<i>Offset: 100h</i>.
+	 * Fields defined in enum @ref gsbuscfg0_data. */
+	volatile uint32_t gsbuscfg0;
+
+	/** Core BIU Configuration 1 Register	<i>Offset: 104h</i>.
+	 * Fields defined in enum @ref gsbuscfg1_data. */
+	volatile uint32_t gsbuscfg1;
+
+	/** Core Tx Threshold Control Register	<i>Offset: 108h</i>.
+	 * Fields defined in enum @ref gtxthrcfg_data. */
+	volatile uint32_t gtxthrcfg;
+
+	/** Core Threshold Control Register	<i>Offset: 10Ch</i>.
+	 * Fields defined in enum @ref grxthrcfg_data. */
+	volatile uint32_t grxthrcfg;
+
+	/** Core Control Register		<i>Offset: 110h</i>.
+	 * Fields defined in enum @ref gctl_data. */
+	volatile uint32_t gctl;
+
+	/** Core Interrupt Mask Register	<i>Offset: 114h</i>.
+	 * Fields defined in enum @ref gevten_data. */
+	volatile uint32_t gevten;
+
+	/** Core Status Register		<i>Offset: 118h</i>.
+	 * Fields defined in enum @ref gsts_data. */
+	volatile uint32_t gsts;
+
+	/** reserved				<i>Offset: 11Ch</i> */
+	volatile uint32_t reserved0;
+
+#define USB3_CORE_GSNPSID_REG_OFFSET 0x120
+
+	/** Synopsys ID Register		<i>Offset: 120h</i> */
+	volatile uint32_t gsnpsid;
+
+	/** General Purpose I/O Register	<i>Offset: 124h</i> */
+	volatile uint32_t ggpio;
+
+	/** User ID Register			<i>Offset: 128h</i> */
+	volatile uint32_t guid;
+
+	/** reserved				<i>Offset: 12Ch</i> */
+	volatile uint32_t reserved1;
+
+	/** Bus Error Address Register		<i>Offset: 130h</i> */
+	volatile uint32_t gbuserraddrlo;
+
+	/** Bus Error Address Register		<i>Offset: 134h</i> */
+	volatile uint32_t gbuserraddrhi;
+
+	/** reserved				<i>Offset: 138h-13Ch</i> */
+	volatile uint32_t reserved2[2];
+
+	/** Hardware Parameter 0 Register	<i>Offset: 140h</i>.
+	 * Fields defined in enum @ref ghwparams0_data. */
+	volatile uint32_t ghwparams0;
+
+	/** Hardware Parameter 1 Register	<i>Offset: 144h</i>.
+	 * Fields defined in enum @ref ghwparams1_data. */
+	volatile uint32_t ghwparams1;
+
+	/** Hardware Parameter 2 Register	<i>Offset: 148h</i>.
+	 * Fields defined in enum @ref ghwparams2_data. */
+	volatile uint32_t ghwparams2;
+
+	/** Hardware Parameter 3 Register	<i>Offset: 14Ch</i>.
+	 * Fields defined in enum @ref ghwparams3_data. */
+	volatile uint32_t ghwparams3;
+
+	/** Hardware Parameter 4 Register	<i>Offset: 150h</i>.
+	 * Fields defined in enum @ref ghwparams4_data. */
+	volatile uint32_t ghwparams4;
+
+	/** Hardware Parameter 5 Register	<i>Offset: 154h</i>.
+	 * Fields defined in enum @ref ghwparams5_data. */
+	volatile uint32_t ghwparams5;
+
+	/** Hardware Parameter 6 Register	<i>Offset: 158h</i>.
+	 * Fields defined in enum @ref ghwparams6_data. */
+	volatile uint32_t ghwparams6;
+
+	/** Hardware Parameter 7 Register	<i>Offset: 15Ch</i>.
+	 * Fields defined in enum @ref ghwparams7_data. */
+	volatile uint32_t ghwparams7;
+
+	/** Debug Queue/FIFO Space Register	<i>Offset: 160h</i>.
+	 * Fields defined in enum @ref gdbgfifospace_data. */
+	volatile uint32_t gdbgfifospace;
+
+	/** Debug LTSSM Register		<i>Offset: 164h</i>.
+	 * Fields defined in enum @ref gdbgltssm_data  */
+	volatile uint32_t gdbgltssm;
+
+	/** reserved				<i>Offset: 168h-1FCh</i> */
+	volatile uint32_t reserved3[38];
+
+	/** USB2 Configuration Registers	<i>Offset: 200h-23Ch</i>.
+	 * Fields defined in enum @ref gusb2phycfg_data. */
+	volatile uint32_t gusb2phycfg[16];
+
+	/** USB2 I2C Access Registers		<i>Offset: 240h-27Ch</i>.
+	 * Fields defined in enum @ref gusb2i2cctl_data. */
+	volatile uint32_t gusb2i2cctl[16];
+
+	/** USB2 PHY Vendor Control Registers	<i>Offset: 280h-2BCh</i>.
+	 * Fields defined in enum @ref gusb2phyacc_data. */
+	volatile uint32_t gusb2phyacc[16];
+
+	/** USB3 Pipe Control Registers		<i>Offset: 2C0h-2FCh</i>.
+	 * Fields defined in enum @ref gusb3pipectl_data. */
+	volatile uint32_t gusb3pipectl[16];
+
+	/** Transmit FIFO Size Registers	<i>Offset: 300h-37Ch</i>.
+	 * Fields defined in enum @ref gfifosize_data. */
+	volatile uint32_t gtxfifosiz[32];
+
+	/** Receive FIFO Size Registers		<i>Offset: 380h-3FC0h</i>.
+	 * Fields defined in enum @ref gfifosize_data. */
+	volatile uint32_t grxfifosiz[32];
+
+	/** Event Buffer Registers		<i>Offset: 400h-5FCh</i>.
+	 * Fields defined in struct @ref geventbuf_data. */
+	struct geventbuf_data geventbuf[32];
+
+	/** Hardware Parameter 8 Register	<i>Offset: 600h</i>.
+	 * Fields defined in enum @ref ghwparams8_data. */
+	volatile uint32_t ghwparams8;
+} usb3_core_global_regs_t;
+
+
+/****************************************************************************/
+/* Device Global Registers */
+
+/**
+ * This enum represents the bit fields in the Device Configuration
+ * Register (DCFG).
+ */
+typedef enum dcfg_data {
+	/** Device Speed			<i>Access: R_W</i> */
+	USB3_DCFG_DEVSPD_BITS		= 0x000007,
+	USB3_DCFG_DEVSPD_SHIFT		= 0,
+
+	/** Device Speed values */
+	USB3_SPEED_HS_PHY_30MHZ_OR_60MHZ		= 0,	/** @< */
+	USB3_SPEED_FS_PHY_30MHZ_OR_60MHZ		= 1,	/** @< */
+	USB3_SPEED_LS_PHY_6MHZ			= 2,	/** @< */
+	USB3_SPEED_FS_PHY_48MHZ			= 3,	/** @< */
+	USB3_SPEED_SS_PHY_125MHZ_OR_250MHZ	= 4,
+
+	/** Device Address			<i>Access: R_W</i> */
+	USB3_DCFG_DEVADDR_BITS		= 0x0003f8,
+	USB3_DCFG_DEVADDR_SHIFT		= 3,
+
+	/** Periodic Frame Interval		<i>Access: R_W</i> */
+	USB3_DCFG_PER_FR_INTVL_BITS	= 0x000c00,
+	USB3_DCFG_PER_FR_INTVL_SHIFT	= 10,
+
+	/** Periodic Frame Interval values */
+	USB3_DCFG_PER_FR_INTVL_80		= 0,	/** @< */
+	USB3_DCFG_PER_FR_INTVL_85		= 1,	/** @< */
+	USB3_DCFG_PER_FR_INTVL_90		= 2,	/** @< */
+	USB3_DCFG_PER_FR_INTVL_95		= 3,
+
+	/** Device Interrupt Number		<i>Access: R_W</i> */
+	USB3_DCFG_DEV_INTR_NUM_BITS	= 0x01f000,
+	USB3_DCFG_DEV_INTR_NUM_SHIFT	= 12,
+
+	/** Number of Receive Buffers		<i>Access: R_W</i> */
+	USB3_DCFG_NUM_RCV_BUF_BITS	= 0x3e0000,
+	USB3_DCFG_NUM_RCV_BUF_SHIFT	= 17,
+
+	/** LPM Capable				<i>Access: R_W</i> */
+	USB3_DCFG_LPM_CAP_BIT		= 0x400000,
+	USB3_DCFG_LPM_CAP_SHIFT		= 22,
+} dcfg_data_t;
+
+/**
+ * This enum represents the bit fields in the Device Control
+ * Register (DCTL).
+ */
+typedef enum dctl_data {
+	/** Soft Disconnect			<i>Access: R_W</i> */
+	USB3_DCTL_SFT_DISCONN_BIT		= 0x00000001,
+	USB3_DCTL_SFT_DISCONN_SHIFT		= 0,
+
+	/** Test Control			<i>Access: R_W</i> */
+	USB3_DCTL_TSTCTL_BITS			= 0x0000001e,
+	USB3_DCTL_TSTCTL_SHIFT			= 1,
+
+	/** USB/Link State Change Request	<i>Access: R_W</i> */
+	USB3_DCTL_ULST_CHNG_REQ_BITS		= 0x000001e0,
+	USB3_DCTL_ULST_CHNG_REQ_SHIFT		= 5,
+
+	/** Requested Link State Transition/Action In SS Mode */
+	USB3_LINK_STATE_REQ_NO_ACTION		= 0,
+	USB3_LINK_STATE_REQ_SS_DISABLED		= 4,
+	USB3_LINK_STATE_REQ_RX_DETECT		= 5,
+	USB3_LINK_STATE_REQ_INACTIVE		= 6,
+	USB3_LINK_STATE_REQ_RECOVERY		= 8,
+	USB3_LINK_STATE_REQ_COMPLIANCE		= 10,
+	USB3_LINK_STATE_REQ_LOOPBACK		= 11,
+	USB3_LINK_STATE_REQ_HOST_MODE_ONLY	= 15,
+
+	/** Requested Link State Transition/Action In HS/FS/LS Mode */
+	USB3_LINK_STATE_REQ_REMOTE_WAKEUP	= 8,
+
+	/** U1/U2 control			<i>Access: R_W</i> */
+	USB3_DCTL_ACCEPT_U1_EN_BIT		= 0x00000200,
+	USB3_DCTL_ACCEPT_U1_EN_SHIFT		= 9,
+	USB3_DCTL_INIT_U1_EN_BIT			= 0x00000400,
+	USB3_DCTL_INIT_U1_EN_SHIFT		= 10,
+	USB3_DCTL_ACCEPT_U2_EN_BIT		= 0x00000800,
+	USB3_DCTL_ACCEPT_U2_EN_SHIFT		= 11,
+	USB3_DCTL_INIT_U2_EN_BIT			= 0x00001000,
+	USB3_DCTL_INIT_U2_EN_SHIFT		= 12,
+
+	/** Controller Save State		<i>Access: R_W</i> */
+	USB3_DCTL_CSS_BIT			= 0x00010000,
+	USB3_DCTL_CSS_SHIFT			= 16,
+
+	/** Controller Restore State		<i>Access: R_W</i> */
+	USB3_DCTL_CRS_BIT			= 0x00020000,
+	USB3_DCTL_CRS_SHIFT			= 17,
+
+	/** L1 Hibernation Enable		<i>Access: R_W</i> */
+	USB3_DCTL_L1_HIBER_EN_BIT		= 0x00040000,
+	USB3_DCTL_L1_HIBER_EN_RES_SHIFT		= 18,
+
+	/** Keep Connect (for hibernation)	<i>Access: R_W</i> */
+	USB3_DCTL_KEEP_CONNECT_BIT		= 0x00080000,
+	USB3_DCTL_KEEP_CONNECT_SHIFT		= 19,
+
+	/** LPM Response			<i>Access: R_W</i> */
+	USB3_DCTL_APP_L1_RES_BIT			= 0x00800000,
+	USB3_DCTL_APP_L1_RES_SHIFT		= 23,
+
+	/* HIRD Threshold			<i>Access: R_W</i> */
+	USB3_DCTL_HIRD_THR_BITS			= 0x1f000000,
+	USB3_DCTL_HIRD_THR_SHIFT			= 24,
+
+	/** Light Soft Reset			<i>Access: R_W</i> */
+	USB3_DCTL_LSFT_RST_BIT			= 0x20000000,
+	USB3_DCTL_LSFT_RST_SHIFT			= 29,
+
+	/** Core Soft Reset			<i>Access: R_W</i> */
+	USB3_DCTL_CSFT_RST_BIT			= 0x40000000,
+	USB3_DCTL_CSFT_RST_SHIFT			= 30,
+
+	/** Run/Stop				<i>Access: R_W</i> */
+	USB3_DCTL_RUN_STOP_BIT			= 0x80000000,
+	USB3_DCTL_RUN_STOP_SHIFT			= 31,
+} dctl_data_t;
+
+/**
+ * This enum represents the bit fields of the Device Event Enable
+ * Register (DEVTEN).
+ */
+typedef enum devten_data {
+	/** Disconnect Detected Event Enable	<i>Access: R_W</i> */
+	USB3_DEVTEN_DISCONN_BIT		= 0x0001,
+	USB3_DEVTEN_DISCONN_SHIFT	= 0,
+
+	/** USB Reset Enable			<i>Access: R_W</i> */
+	USB3_DEVTEN_USBRESET_BIT		= 0x0002,
+	USB3_DEVTEN_USBRESET_SHIFT	= 1,
+
+	/** Connect Done Enable			<i>Access: R_W</i> */
+	USB3_DEVTEN_CONNDONE_BIT		= 0x0004,
+	USB3_DEVTEN_CONNDONE_SHIFT	= 2,
+
+	/** USB/Link State Change Event Enable	<i>Access: R_W</i> */
+	USB3_DEVTEN_ULST_CHNG_BIT	= 0x0008,
+	USB3_DEVTEN_ULST_CHNG_SHIFT	= 3,
+
+	/** Resume/Remote-Wakeup Event Enable	<i>Access: R_W</i> */
+	USB3_DEVTEN_WKUP_BIT		= 0x0010,
+	USB3_DEVTEN_WKUP_SHIFT		= 4,
+
+	/** Hibernation Request Event Enable	<i>Access: R_W</i> */
+	USB3_DEVTEN_HIBER_REQ_EVT_BIT	= 0x0020,
+	USB3_DEVTEN_HIBER_REQ_EVT_SHIFT	= 5,
+
+	/** End of Periodic Frame Event Enable	<i>Access: R_W</i> */
+	USB3_DEVTEN_EOPF_BIT		= 0x0040,
+	USB3_DEVTEN_EOPF_SHIFT		= 6,
+
+	/** Start of (Micro)Frame Enable	<i>Access: R_W</i> */
+	USB3_DEVTEN_SOF_BIT		= 0x0080,
+	USB3_DEVTEN_SOF_SHIFT		= 7,
+
+	/** Erratic Error Event Enable		<i>Access: R_W</i> */
+	USB3_DEVTEN_ERRATICERR_BIT	= 0x0200,
+	USB3_DEVTEN_ERRATICERR_SHIFT	= 9,
+
+	/** U2 Inactivity Timeout Enable	<i>Access: R_W</i> */
+	USB3_DEVTEN_INACT_TIMEOUT_BIT	= 0x2000,
+	USB3_DEVTEN_INACT_TIMEOUT_SHIFT	= 13,
+} devten_data_t;
+
+/**
+ * This enum represents the bit fields in the Device Status
+ * Register (DSTS).
+ */
+typedef enum dsts_data {
+	/** Connected Speed			<i>Access: RO</i>.
+	 * (see enum @ref dcfg_data for values) */
+	USB3_DSTS_CONNSPD_BITS		= 0x00000007,
+	USB3_DSTS_CONNSPD_SHIFT		= 0,
+
+	/** (Micro)Frame Number of Received SOF	<i>Access: RO</i> */
+	USB3_DSTS_SOF_FN_BITS		= 0x0001fff8,
+	USB3_DSTS_SOF_FN_SHIFT		= 3,
+
+	/** RX Fifo Empty			<i>Access: RO</i> */
+	USB3_DSTS_RXFIFO_EMPTY_BIT	= 0x00020000,
+	USB3_DSTS_RXFIFO_EMPTY_SHIFT	= 17,
+
+	/** USB/Link State			<i>Access: RO</i> */
+	USB3_DSTS_USBLNK_STATE_BITS	= 0x003c0000,
+	USB3_DSTS_USBLNK_STATE_SHIFT	= 18,
+
+	/** USB/Link State values same as for devt_data_t */
+
+	/** Device Controller Halted		<i>Access: RO</i> */
+	USB3_DSTS_DEV_CTRL_HLT_BIT	= 0x00400000,
+	USB3_DSTS_DEV_CTRL_HLT_SHIFT	= 22,
+
+	/** Core Idle				<i>Access: RO</i> */
+	USB3_DSTS_CORE_IDLE_BIT		= 0x00800000,
+	USB3_DSTS_CORE_IDLE_SHIFT	= 23,
+
+	/** Save State Status			<i>Access: RO</i> */
+	USB3_DSTS_SSS_BIT		= 0x01000000,
+	USB3_DSTS_SSS_SHIFT		= 24,
+
+	/** Restore State Status		<i>Access: RO</i> */
+	USB3_DSTS_RSS_BIT		= 0x02000000,
+	USB3_DSTS_RSS_SHIFT		= 25,
+
+	/** Save/Restore Error			<i>Access: RO</i> */
+	USB3_DSTS_SRE_BIT		= 0x10000000,
+	USB3_DSTS_SRE_SHIFT		= 28,
+
+	/** Link-state Not Ready		<i>Access: RO</i> */
+	USB3_DSTS_LNR_BIT		= 0x20000000,
+	USB3_DSTS_LNR_SHIFT		= 29,
+} dsts_data_t;
+
+/**
+ * This enum represents the bit fields in the Device Generic Command Parameter
+ * Register (DGCMDPARn) for the various commands.
+ */
+typedef enum dgcmdpar_data {
+	/** Force Link PM Accept
+	 * (for USB3_DGCMD_XMIT_SET_LINK_FUNC_LMP command) */
+	USB3_DGCMDPAR_FORCE_LINK_PM_ACCEPT_BIT	= 0x0001,
+	USB3_DGCMDPAR_FORCE_LINK_PM_ACCEPT_SHIFT	= 0,
+
+	/** Vendor Specific Test Select
+	 * (for USB3_DGCMD_XMIT_VEND_DEV_TST_LMP command) */
+	USB3_DGCMDPAR_VEND_SPEC_TST_BITS		= 0x00ff,
+	USB3_DGCMDPAR_VEND_SPEC_TST_SHIFT	= 0,
+
+	/** Interface Number (for USB3_DGCMD_XMIT_RMT_WKUP_SIG command) */
+	USB3_DGCMDPAR_INTF_NUM_BITS		= 0x00ff,
+	USB3_DGCMDPAR_INTF_NUM_SHIFT		= 0,
+
+	/** Best Effort Latency Tolerance Value
+	 * (for USB3_DGCMD_XMIT_LAT_TOL_MSG command) */
+	USB3_DGCMDPAR_BELT_VALUE_BITS		= 0x03ff,
+	USB3_DGCMDPAR_BELT_VALUE_SHIFT		= 0,
+
+	/** Best Effort Latency Tolerance Scale
+	 * (for USB3_DGCMD_XMIT_LAT_TOL_MSG command) */
+	USB3_DGCMDPAR_BELT_SCALE_BITS		= 0x0c00,
+	USB3_DGCMDPAR_BELT_SCALE_SHIFT		= 10,
+
+	/** Latency Scale values (ns) */
+	USB3_LATENCY_VALUE_MULT_1024	= 1,	/** @< */
+	USB3_LATENCY_VALUE_MULT_32768	= 2,	/** @< */
+	USB3_LATENCY_VALUE_MULT_1048576	= 3,
+
+	/** Bus Interval Adjustment
+	 * (for USB3_DGCMD_XMIT_BUS_INTVL_ADJ_MSG command) */
+	USB3_DGCMDPAR_BUS_INTVL_ADJ_BITS		= 0xffff,
+	USB3_DGCMDPAR_BUS_INTVL_ADJ_SHIFT	= 0,
+
+	/** Bus Interval Adjustment values (units) */
+	USB3_BUS_INTVL_ADJ_DEC_1		= 0xffff,	/** @< */
+	USB3_BUS_INTVL_ADJ_DEC_32768	= 0x8000,	/** @< */
+	USB3_BUS_INTVL_ADJ_INC_32767	= 0x7fff,	/** @< */
+	USB3_BUS_INTVL_ADJ_NO_CHNG	= 0x0000,
+
+	USB3_DGCMDPAR_HOST_ROLE_REQ_INITIATE	= 0x01,
+	USB3_DGCMDPAR_HOST_ROLE_REQ_CONFIRM	= 0x02,
+} dgcmdpar_data_t;
+
+/**
+ * This enum represents the bit fields in the Device Generic Command
+ * Register (DGCMDn).
+ */
+typedef enum dgcmd_data {
+	/** Command Type			<i>Access: R_W</i> */
+	USB3_DGCMD_TYP_BITS			= 0x0ff,
+	USB3_DGCMD_TYP_SHIFT			= 0,
+
+	/** Command Type values */
+	USB3_DGCMD_XMIT_SET_LINK_FUNC_LMP		= 1,	/** @< */
+	USB3_DGCMD_SET_PERIODIC_PARAMS			= 2,	/** @< */
+	USB3_DGCMD_XMIT_FUNC_WAKE_DEV_NOTIF		= 3,	/** @< */
+	USB3_DGCMD_SET_SCRATCHPAD_ARRAY_ADR_LO		= 4,	/** @< */
+	USB3_DGCMD_SET_SCRATCHPAD_ARRAY_ADR_HI		= 5,	/** @< */
+	USB3_DGCMD_XMIT_HOST_ROLE_REQUEST		= 6,	/** @< */
+	USB3_DGCMD_SET_EP_NRDY				= 12,	/** @< */
+	USB3_DGCMD_RUN_SOC_BUS_LOOPBK_TST		= 16,	/** @< */
+
+	/** Command Interrupt on Complete	<i>Access: R_W</i> */
+	USB3_DGCMD_IOC_BIT			= 0x100,
+	USB3_DGCMD_IOC_SHIFT			= 8,
+
+	/** Command Active			<i>Access: R_W</i> */
+	USB3_DGCMD_ACT_BIT			= 0x400,
+	USB3_DGCMD_ACT_SHIFT			= 10,
+
+	/** Command Status			<i>Access: R_W</i> */
+	USB3_DGCMD_STS_BITS			= 0xf000,
+	USB3_DGCMD_STS_SHIFT			= 12,
+
+	/** Command Status values */
+	USB3_DGCMD_STS_ERROR				= 15,
+} dgcmd_data_t;
+
+/**
+ * This enum represents the bit fields in the Device Endpoint Mapping
+ * Registers (DEPMAPn).
+ */
+typedef enum depmap_data {
+	/** Resource Number			<i>Access: R_W / RO</i> */
+	USB3_EPMAP_RES_NUM_BITS		= 0x1f,
+	USB3_EPMAP_RES_NUM_SHIFT		= 0,
+} depmap_data_t;
+
+/**
+ * Device Global Registers	<i>Offsets 700h-7FCh</i>.
+ *
+ * The following structures define the size and relative field offsets
+ * for the Device Mode Global Registers.
+ */
+typedef struct usb3_dev_global_regs {
+
+#define USB3_DEV_GLOBAL_REG_OFFSET	0x700
+
+	/** Device Configuration Register		<i>Offset: 700h</i>.
+	 * Fields defined in enum @ref dcfg_data. */
+	volatile uint32_t dcfg;
+
+	/** Device Control Register			<i>Offset: 704h</i>.
+	 * Fields defined in enum @ref dctl_data. */
+	volatile uint32_t dctl;
+
+	/** Device All Endpoints Interrupt Mask Register <i>Offset: 708h</i>.
+	 * Fields defined in enum @ref devten_data. */
+	volatile uint32_t devten;
+
+	/** Device Status Register			<i>Offset: 70Ch</i>.
+	 * Fields defined in enum @ref dsts_data. */
+	volatile uint32_t dsts;
+
+	/** Device Generic Command Parameter Register	<i>Offset: 710h</i>.
+	 * Fields defined in enum @ref dgcmdpar_data. */
+	volatile uint32_t dgcmdpar;
+
+	/** Device Generic Command Register		<i>Offset: 714h</i>.
+	 * Fields defined in enum @ref dgcmd_data. */
+	volatile uint32_t dgcmd;
+
+	/** reserved				     <i>Offset: 718h-71Ch</i> */
+	volatile uint32_t reserved[2];
+
+	/** Device Active Logical Endpoint Enable Register <i>Offset: 720h</i>.
+	 * One bit per logical endpoint, bit0=EP0 ... bit31=EP31. */
+	volatile uint32_t dalepena;
+} usb3_dev_global_regs_t;
+
+
+/****************************************************************************/
+/* Device Endpoint Specific Registers */
+
+/**
+ * This enum represents the bit fields in the Device Endpoint Command
+ * Parameter 1 Register (DEPCMDPAR1n) for the Set Endpoint Configuration
+ * (DEPCFG) command.
+ */
+typedef enum depcfgpar1_data {
+	/** Interrupt number */
+	USB3_EPCFG1_INTRNUM_BITS		= 0x0000003f,
+	USB3_EPCFG1_INTRNUM_SHIFT	= 0,
+
+	/** Stream Completed */
+	USB3_EPCFG1_XFER_CMPL_BIT	= 0x00000100,
+	USB3_EPCFG1_XFER_CMPL_SHIFT	= 8,
+
+	/** Stream In Progress */
+	USB3_EPCFG1_XFER_IN_PROG_BIT	= 0x00000200,
+	USB3_EPCFG1_XFER_IN_PROG_SHIFT	= 9,
+
+	/** Stream Not Ready */
+	USB3_EPCFG1_XFER_NRDY_BIT	= 0x00000400,
+	USB3_EPCFG1_XFER_NRDY_SHIFT	= 10,
+
+	/** Rx FIFO Underrun / Tx FIFO Overrun */
+	USB3_EPCFG1_FIFOXRUN_BIT		= 0x00000800,
+	USB3_EPCFG1_FIFOXRUN_SHIFT	= 11,
+
+	/** Back-to-Back Setup Packets Received	 */
+	USB3_EPCFG1_SETUP_PNDG_BIT	= 0x00001000,
+	USB3_EPCFG1_SETUP_PNDG_SHIFT	= 12,
+
+	/** Endpoint Command Complete */
+	USB3_EPCFG1_EPCMD_CMPL_BIT	= 0x00002000,
+	USB3_EPCFG1_EPCMD_CMPL_SHIFT	= 13,
+
+	/** Endpoint bInterval */
+	USB3_EPCFG1_BINTERVAL_BITS	= 0x00ff0000,
+	USB3_EPCFG1_BINTERVAL_SHIFT	= 16,
+
+	/** Endpoint Stream Capability */
+	USB3_EPCFG1_STRM_CAP_BIT		= 0x01000000,
+	USB3_EPCFG1_STRM_CAP_SHIFT	= 24,
+
+	/** Endpoint Direction */
+	USB3_EPCFG1_EP_DIR_BIT		= 0x02000000,
+	USB3_EPCFG1_EP_DIR_SHIFT		= 25,
+
+	/** Endpoint Number */
+	USB3_EPCFG1_EP_NUM_BITS		= 0x3c000000,
+	USB3_EPCFG1_EP_NUM_SHIFT		= 26,
+} depcfgpar1_data_t;
+
+/**
+ * This enum represents the bit fields in the Device Endpoint Command
+ * Parameter 0 Register (DEPCMDPAR0n) for the Set Endpoint Configuration
+ * (DWC_EPCMD_SET_EP_CFG) command.
+ */
+typedef enum depcfgpar0_data {
+	/** Endpoint Type			<i>Access: R_W</i> */
+	USB3_EPCFG0_EPTYPE_BITS			= 0x00000006,
+	USB3_EPCFG0_EPTYPE_SHIFT        = 1,
+
+	/** Endpoint Type values */
+	USB3_EP_TYPE_CONTROL	        = 0,	/** @< */
+	USB3_EP_TYPE_ISOC		        = 1,	/** @< */
+	USB3_EP_TYPE_BULK		        = 2,	/** @< */
+	USB3_EP_TYPE_INTR		        = 3,
+
+	/** Maximum Packet Size			<i>Access: R_W</i> */
+	USB3_EPCFG0_MPS_BITS			= 0x00003ff8,
+	USB3_EPCFG0_MPS_SHIFT			= 3,
+
+	/** Flow Control State			<i>Access: R_W</i> */
+	USB3_EPCFG0_FLOW_CTRL_STATE_BIT		= 0x00010000,
+	USB3_EPCFG0_FLOW_CTRL_STATE_SHIFT	= 16,
+
+	/** Tx Fifo Number (IN endpoints only)	<i>Access: R_W</i> */
+	USB3_EPCFG0_TXFNUM_BITS			    = 0x003e0000,
+	USB3_EPCFG0_TXFNUM_SHIFT			= 17,
+
+	/** Burst Size				<i>Access: R_W</i> */
+	USB3_EPCFG0_BRSTSIZ_BITS			= 0x03c00000,
+	USB3_EPCFG0_BRSTSIZ_SHIFT		    = 22,
+
+	/** Data Sequence Num (old)		<i>Access: R_W</i> */
+	USB3_EPCFG0_DSNUM_BITS			= 0x7c000000,
+	USB3_EPCFG0_DSNUM_SHIFT			= 26,
+
+	/** Ignore Data Sequence Num (old)	<i>Access: R_W</i> */
+	USB3_EPCFG0_IGN_DSNUM_BIT		= 0x80000000,
+	USB3_EPCFG0_IGN_DSNUM_SHIFT		= 31,
+
+	/** Config Action (new)			<i>Access: R_W</i> */
+	USB3_EPCFG0_CFG_ACTION_BITS		= 0xc0000000,
+	USB3_EPCFG0_CFG_ACTION_SHIFT		= 30,
+
+	/** Config Action values (new) */
+	USB3_CFG_ACTION_INIT		= 0,	/** @< */
+	USB3_CFG_ACTION_RESTORE		= 1,	/** @< */
+	USB3_CFG_ACTION_MODIFY		= 2,
+} depcfgpar0_data_t;
+
+/**
+ * This enum represents the bit fields in the Device Endpoint Command
+ * Register (DEPCMDn).
+ */
+typedef enum depcmd_data {
+	/** Command Type			<i>Access: R_W</i> */
+	USB3_EPCMD_TYP_BITS		= 0x0ff,
+	USB3_EPCMD_TYP_SHIFT		= 0,
+
+	/** Command Type values */
+	USB3_EPCMD_SET_EP_CFG	= 1,	/** @< */
+	USB3_EPCMD_SET_XFER_CFG	= 2,	/** @< */
+	USB3_EPCMD_GET_EP_STATE	= 3,	/** @< */
+	USB3_EPCMD_SET_STALL	= 4,	/** @< */
+	USB3_EPCMD_CLR_STALL	= 5,	/** @< */
+	USB3_EPCMD_START_XFER	= 6,	/** @< */
+	USB3_EPCMD_UPDATE_XFER	= 7,	/** @< */
+	USB3_EPCMD_END_XFER	= 8,	/** @< */
+	USB3_EPCMD_START_NEW_CFG	= 9,
+
+	/** Command Interrupt on Complete	<i>Access: R_W</i> */
+	USB3_EPCMD_IOC_BIT		= 0x100,
+	USB3_EPCMD_IOC_SHIFT		= 8,
+
+	/** Command Active			<i>Access: R_W</i> */
+	USB3_EPCMD_ACT_BIT		= 0x400,
+	USB3_EPCMD_ACT_SHIFT		= 10,
+
+	/** High Priority / Force RM Bit	<i>Access: R_W</i> */
+	USB3_EPCMD_HP_FRM_BIT		= 0x800,
+	USB3_EPCMD_HP_FRM_SHIFT		= 11,
+
+	/** Command Completion Status		<i>Access: R_W</i> */
+	USB3_EPCMD_CMPL_STS_BITS		= 0xf000,
+	USB3_EPCMD_CMPL_STS_SHIFT	= 12,
+
+	/** Stream Number or uFrame (input)	<i>Access: R_W</i> */
+	USB3_EPCMD_STR_NUM_OR_UF_BITS	= 0xffff0000,
+	USB3_EPCMD_STR_NUM_OR_UF_SHIFT	= 16,
+
+	/** Transfer Resource Index (output)	<i>Access: R_W</i> */
+	USB3_EPCMD_XFER_RSRC_IDX_BITS	= 0x007f0000,
+	USB3_EPCMD_XFER_RSRC_IDX_SHIFT	= 16,
+} depcmd_data_t;
+
+/**
+ * Device Endpoint Specific Registers <i>Offsets 800h-9ECh for OUT,
+ *						 810h-9FCh for IN</i>.
+ * There will be one set of endpoint registers per logical endpoint
+ * implemented.
+ */
+typedef struct usb3_dev_ep_regs {
+
+#define USB3_DEV_OUT_EP_REG_OFFSET	0x800
+#define USB3_DEV_IN_EP_REG_OFFSET	0x810
+#define USB3_EP_REG_OFFSET		    0x20
+
+	/** Device Endpoint Command Parameter 2 Register <i>Offset: 800h/810h +
+	 *					(ep_num * 20h) + 00h</i> */
+	volatile uint32_t depcmdpar2;
+
+	/** Device Endpoint Command Parameter 1 Register <i>Offset: 800h/810h +
+	 *					(ep_num * 20h) + 04h</i> */
+	volatile uint32_t depcmdpar1;
+
+	/** Device Endpoint Command Parameter 0 Register <i>Offset: 800h/810h +
+	 *					(ep_num * 20h) + 08h</i> */
+	volatile uint32_t depcmdpar0;
+
+	/** Device Endpoint Command Register	<i>Offset: 800h/810h +
+	 *					(ep_num * 20h) + 0Ch</i>.
+	 * Fields defined in enum @ref depcmd_data. */
+	volatile uint32_t depcmd;
+
+	/** reserved				<i>Offset: 800h/810h +
+	 *					(ep_num * 20h) + 10h-1Ch</i> */
+	volatile uint32_t reserved[4];
+} usb3_dev_ep_regs_t;
+
+
+/****************************************************************************/
+/* DMA Descriptor Specific Structures */
+
+/**
+ * This enum represents the bit fields in the DMA Descriptor
+ * Status quadlet.
+ */
+typedef enum desc_sts_data {
+	/** Transfer Count */
+	USB3_DSCSTS_XFRCNT_MAX	= 0x1000000,	//16MB
+	USB3_DSCSTS_XFRCNT_BITS	= 0x00ffffff,
+	USB3_DSCSTS_XFRCNT_SHIFT	= 0,
+
+	/** Packet Count Minus 1 (for HS IN transfers) */
+	USB3_DSCSTS_PCM1_BITS	= 0x03000000,
+	USB3_DSCSTS_PCM1_SHIFT	= 24,
+
+	/** Transfer Request Block Response */
+	USB3_DSCSTS_TRBRSP_BITS	= 0xf0000000,
+	USB3_DSCSTS_TRBRSP_SHIFT	= 28,
+
+	USB3_TRBRSP_MISSED_ISOC_IN	= 1,
+	USB3_TRBRSP_SETUP_PEND		= 2,
+	USB3_TRBRSP_XFER_IN_PROG		= 4,
+} desc_sts_data_t;
+
+/**
+ * This enum represents the bit fields in the DMA Descriptor
+ * Control quadlet.
+ */
+typedef enum desc_ctl_data {
+	/** Hardware-Owned bit */
+	USB3_DSCCTL_HWO_BIT		= 0x00000001,
+	USB3_DSCCTL_HWO_SHIFT		= 0,
+
+	/** Last Descriptor bit */
+	USB3_DSCCTL_LST_BIT		= 0x00000002,
+	USB3_DSCCTL_LST_SHIFT		= 1,
+
+	/** Chain Buffer bit */
+	USB3_DSCCTL_CHN_BIT		= 0x00000004,
+	USB3_DSCCTL_CHN_SHIFT		= 2,
+
+	/** Continue on Short Packet bit */
+	USB3_DSCCTL_CSP_BIT		= 0x00000008,
+	USB3_DSCCTL_CSP_SHIFT		= 3,
+
+	/** Transfer Request Block Control field */
+	USB3_DSCCTL_TRBCTL_BITS		= 0x000003f0,
+	USB3_DSCCTL_TRBCTL_SHIFT		= 4,
+
+	/** Transfer Request Block Control types */
+	USB3_DSCCTL_TRBCTL_NORMAL		= 1,	/** @< */
+	USB3_DSCCTL_TRBCTL_SETUP			= 2,	/** @< */
+	USB3_DSCCTL_TRBCTL_STATUS_2		= 3,	/** @< */
+	USB3_DSCCTL_TRBCTL_STATUS_3		= 4,	/** @< */
+	USB3_DSCCTL_TRBCTL_CTLDATA_1ST		= 5,	/** @< */
+	USB3_DSCCTL_TRBCTL_ISOC_1ST		= 6,	/** @< */
+	USB3_DSCCTL_TRBCTL_ISOC			= 7,	/** @< */
+	USB3_DSCCTL_TRBCTL_LINK			= 8,
+
+	/** Interrupt on Short Packet bit */
+	USB3_DSCCTL_ISP_BIT		        = 0x00000400,
+	USB3_DSCCTL_ISP_SHIFT		    = 10,
+#define USB3_DSCCTL_IMI_BIT	    USB3_DSCCTL_ISP_BIT
+#define USB3_DSCCTL_IMI_SHIFT	USB3_DSCCTL_ISP_SHIFT
+
+	/** Interrupt on Completion bit */
+	USB3_DSCCTL_IOC_BIT		        = 0x00000800,
+	USB3_DSCCTL_IOC_SHIFT		    = 11,
+
+	/** Stream ID / SOF Number */
+	USB3_DSCCTL_STRMID_SOFN_BITS	= 0x3fffc000,
+	USB3_DSCCTL_STRMID_SOFN_SHIFT	= 14,
+} desc_ctl_data_t;
+
+/**
+ * DMA Descriptor structure
+ *
+ * DMA Descriptor structure contains 4 quadlets:
+ * Buffer Pointer Low address, Buffer Pointer High address, Status, and Control.
+ */
+typedef struct usb3_dma_desc {
+	/** Buffer Pointer - Low address quadlet */
+	uint32_t	bptl;
+
+	/** Buffer Pointer - High address quadlet */
+	uint32_t	bpth;
+
+	/** Status quadlet. Fields defined in enum @ref desc_sts_data. */
+	uint32_t	status;
+
+	/** Control quadlet. Fields defined in enum @ref desc_ctl_data. */
+	uint32_t	control;
+} usb3_dma_desc_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __USB3_HW_H__ */
+
diff -uraN u-boot-2016.11/drivers/usb/gadget/udc3/usb3_intr.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/usb3_intr.c
--- u-boot-2016.11/drivers/usb/gadget/udc3/usb3_intr.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/usb3_intr.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,145 @@
+#include "usb3_hw.h"
+#include "usb3_drv.h"
+#include <common.h>
+extern void usb3_handle_dev_intr(usb3_pcd_t *pcd, uint32_t event);
+extern int usb3_handle_ep_intr(usb3_pcd_t *pcd, uint32_t physep, uint32_t event);
+int usb_connected = 0;
+
+void ena_eventbuf_intr(usb3_device_t *dev)
+{
+	uint32_t eventsiz;
+
+	eventsiz =
+	      usb3_rd32(&dev->core_global_regs->geventbuf[0].geventsiz);
+	eventsiz &= ~USB3_EVENTSIZ_INT_MSK_BIT;
+	usb3_wr32(&dev->core_global_regs->geventbuf[0].geventsiz,
+		 eventsiz);
+}
+
+void dis_eventbuf_intr(usb3_device_t *dev)
+{
+	uint32_t eventsiz;
+
+	eventsiz =
+	      usb3_rd32(&dev->core_global_regs->geventbuf[0].geventsiz);
+	eventsiz |= USB3_EVENTSIZ_INT_MSK_BIT;
+	usb3_wr32(&dev->core_global_regs->geventbuf[0].geventsiz,
+		 eventsiz);
+}
+
+void usb3_dis_flush_eventbuf_intr(usb3_device_t *dev)
+{
+	uint32_t cnt;
+	uint32_t gevntsize;
+
+	dis_eventbuf_intr(dev);
+	cnt = usb3_rd32(&dev->core_global_regs->geventbuf[0].geventcnt);
+	usb3_wr32(&dev->core_global_regs->geventbuf[0].geventcnt, cnt);
+
+	if (0 != cnt) {
+		gevntsize = sizeof(dev->event_buf[0]) * USB3_EVENT_BUF_SIZE;
+		usb_info("evnt count 0x%x, evnt buf size 0x%x\n", cnt, gevntsize);
+		dev->event_ptr += cnt % gevntsize;
+	}
+}
+
+int get_eventbuf_count(usb3_device_t *dev)
+{
+	uint32_t cnt;
+
+	cnt = usb3_rd32(&dev->core_global_regs->geventbuf[0].geventcnt);
+
+	return cnt & USB3_EVENTCNT_CNT_BITS;
+}
+
+void update_eventbuf_count(usb3_device_t *dev, int cnt)
+{
+	usb3_wr32(&dev->core_global_regs->geventbuf[0].geventcnt, cnt);
+}
+
+uint32_t get_eventbuf_event(usb3_device_t *dev, int size)
+{
+	uint32_t event;
+
+	event = *dev->event_ptr++;
+
+	if (dev->event_ptr >= dev->event_buf + size)
+		dev->event_ptr = dev->event_buf;
+	return event;
+}
+
+void usb3_init_eventbuf(usb3_device_t *dev, uint32_t size, phys_addr_t dma_addr)
+{
+	dma_addr = map_to_dma_addr(dma_addr);
+
+	usb3_wr32(&dev->core_global_regs->geventbuf[0].geventadr_lo,
+		dma_addr & 0xffffffff);
+
+	usb3_wr32(&dev->core_global_regs->geventbuf[0].geventadr_hi, 0);
+	usb3_wr32(&dev->core_global_regs->geventbuf[0].geventsiz,
+		 size << 2);
+
+	usb3_wr32(&dev->core_global_regs->geventbuf[0].geventcnt, 0);
+}
+
+void usb3_enable_device_interrupts(usb3_device_t *dev)
+{
+	uint32_t eventsiz;
+
+	/* Clear any pending interrupts */
+	usb3_dis_flush_eventbuf_intr(dev);
+	/**
+	 * This routine enables the Event Buffer interrupt.
+	 */
+	eventsiz =
+		usb3_rd32(&dev->core_global_regs->geventbuf[0].geventsiz);
+	eventsiz &= ~USB3_EVENTSIZ_INT_MSK_BIT;
+	usb3_wr32(&dev->core_global_regs->geventbuf[0].geventsiz,
+			eventsiz);
+	/* Enable device interrupts */
+	usb3_wr32(&dev->pcd.dev_global_regs->devten,
+		 USB3_DEVTEN_DISCONN_BIT | USB3_DEVTEN_CONNDONE_BIT  | USB3_DEVTEN_USBRESET_BIT | USB3_DEVTEN_HIBER_REQ_EVT_BIT | USB3_DEVTEN_WKUP_BIT | USB3_DEVTEN_EOPF_BIT);
+}
+
+void usb3_handle_event(usb3_device_t *dev)
+{
+	usb3_pcd_t *pcd = &dev->pcd;
+	uint32_t event, count, physep;
+	int intr, i;
+    intr=0;
+
+        invalidate_dcache_all();
+		count = get_eventbuf_count(dev);
+		if ((count & USB3_EVENTCNT_CNT_BITS) == USB3_EVENTCNT_CNT_BITS
+			|| count >= USB3_EVENT_BUF_SIZE * 4) {
+				update_eventbuf_count(dev, count);
+				count = 0;
+		}
+
+		for (i = 0; i < count; i += 4) {
+			event = get_eventbuf_event(dev, USB3_EVENT_BUF_SIZE);
+			update_eventbuf_count(dev, 4);
+			if (event == 0) {
+				/* Ignore null events */
+				continue;
+			}
+
+			if (event & USB3_EVENT_NON_EP_BIT) {
+				intr = event & USB3_EVENT_INTTYPE_BITS;
+
+				if (intr ==
+					(USB3_EVENT_DEV_INT << USB3_EVENT_INTTYPE_SHIFT)) {
+					usb3_handle_dev_intr(pcd, event);
+				} else {
+					/* @todo Handle non-Device interrupts
+					* (OTG, CarKit, I2C)
+					*/
+				}
+			} else {
+				physep = (event >> USB3_DEPEVT_EPNUM_SHIFT) &
+					(USB3_DEPEVT_EPNUM_BITS >> USB3_DEPEVT_EPNUM_SHIFT);
+				usb3_handle_ep_intr(pcd, physep, event);
+			}
+		}
+}
+
diff -uraN u-boot-2016.11/drivers/usb/gadget/udc3/usb3_pcd.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/usb3_pcd.c
--- u-boot-2016.11/drivers/usb/gadget/udc3/usb3_pcd.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/usb3_pcd.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,1325 @@
+#include "usb3.h"
+#include "usb3_hw.h"
+#include "usb3_drv.h"
+#include "usb3_prot.h"
+#include "usb3_pcd.h"
+#include <linux/string.h>
+
+extern void usb3_bulk_out_transfer(void *dev);
+
+const struct usb_interface_descriptor
+intf = {
+	sizeof(struct usb_interface_descriptor), /* bLength */
+	UDESC_INTERFACE, /* bDescriptorType */
+
+	0, /* bInterfaceNumber */
+	0, /* bAlternateSetting */
+	2, /* bNumEndpoints */
+	USB_CLASS_VENDOR_SPEC, /* bInterfaceClass */
+	USB_SC_VENDOR_SPEC, /* bInterfaceSubClass */
+	USB_PR_VENDOR_SPEC, /* bInterfaceProtocol */
+	0, /* iInterface */
+};
+
+/* Two endpoint descriptors: bulk-in, bulk-out. */
+
+const struct usb_ss_ep_comp_descriptor
+ep_comp = {
+	sizeof(struct usb_ss_ep_comp_descriptor), /* bLength */
+	UDESC_SS_USB_COMPANION, /* bDescriptorType */
+	0, /* bMaxBurst */
+	0, /* bmAttributes */
+	0, /* wBytesPerInterval */
+};
+
+const struct usb_endpoint_descriptor
+hs_bulk_in = {
+	sizeof(struct usb_endpoint_descriptor), /* bLength */
+	UDESC_ENDPOINT, /* bDescriptorType */
+
+	UE_DIR_IN | USB3_BULK_IN_EP, /* bEndpointAddress */
+	USB_ENDPOINT_XFER_BULK, /* bmAttributes */
+	0x200, /* wMaxPacketSize: 512 of high-speed */
+	0, /* bInterval */
+};
+
+const struct usb_endpoint_descriptor
+hs_bulk_out = {
+	sizeof(struct usb_endpoint_descriptor), /* bLength */
+	UDESC_ENDPOINT, /* bDescriptorType */
+
+	UE_DIR_OUT | USB3_BULK_OUT_EP, /* bEndpointAddress */
+	USB_ENDPOINT_XFER_BULK, /* bmAttributes */
+	0x200, /* wMaxPacketSize: 512 of high-speed */
+	1, /* bInterval */
+};
+
+const struct usb_endpoint_descriptor
+ss_bulk_in = {
+	sizeof(struct usb_endpoint_descriptor), /* bLength */
+	UDESC_ENDPOINT, /* bDescriptorType */
+
+	UE_DIR_IN | USB3_BULK_IN_EP, /* bEndpointAddress */
+	USB_ENDPOINT_XFER_BULK, /* bmAttributes */
+	0x400, /* wMaxPacketSize: 1024 of super-speed */
+	0, /* bInterval */
+};
+
+const struct usb_endpoint_descriptor
+ss_bulk_out = {
+	sizeof(struct usb_endpoint_descriptor), /* bLength */
+	UDESC_ENDPOINT, /* bDescriptorType */
+
+	UE_DIR_OUT | USB3_BULK_OUT_EP, /* bEndpointAddress */
+	USB_ENDPOINT_XFER_BULK, /* bmAttributes */
+	0x400, /* wMaxPacketSize: 1024 of super-speed */
+	0, /* bInterval */
+};
+
+/** The BOS Descriptor */
+
+const struct usb_dev_cap_20_ext_desc
+cap1 = {
+	sizeof(struct usb_dev_cap_20_ext_desc),	/* bLength */
+	UDESC_DEVICE_CAPABILITY,		/* bDescriptorType */
+	USB_DEVICE_CAPABILITY_20_EXTENSION,	/* bDevCapabilityType */
+	0x2,				/* bmAttributes */
+};
+
+const struct usb_dev_cap_ss_usb
+cap2 = {
+	sizeof(struct usb_dev_cap_ss_usb),	/* bLength */
+	UDESC_DEVICE_CAPABILITY,		/* bDescriptorType */
+	USB_DEVICE_CAPABILITY_SS_USB,		/* bDevCapabilityType */
+	0x0,					/* bmAttributes */
+	(USB_DC_SS_USB_SPEED_SUPPORT_SS |
+	    USB_DC_SS_USB_SPEED_SUPPORT_HIGH),   /* wSpeedsSupported */
+	0x2,					/* bFunctionalitySupport */
+	/* @todo set these to correct value */
+	0xa,					/* bU1DevExitLat */
+	0x100,				/* wU2DevExitLat */
+};
+
+const struct usb_dev_cap_container_id
+cap3 = {
+	sizeof(struct usb_dev_cap_container_id),/* bLength */
+	UDESC_DEVICE_CAPABILITY,		/* bDescriptorType */
+	USB_DEVICE_CAPABILITY_CONTAINER_ID,	/* bDevCapabilityType */
+	0,					/* bReserved */
+	/* @todo Create UUID */
+	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, /* containerID */
+};
+
+const struct wusb_bos_desc
+bos = {
+	sizeof(struct wusb_bos_desc),		/* bLength */
+	UDESC_BOS,				/* bDescriptorType */
+	(sizeof(struct wusb_bos_desc)	/* wTotalLength */
+	    + sizeof(cap1) + sizeof(cap2) + sizeof(cap3)),
+	3,					/* bNumDeviceCaps */
+};
+
+usb3_pcd_ep_t *usb3_get_out_ep(usb3_pcd_t *pcd, uint32_t ep_num)
+{
+	if (ep_num == 0) {
+		return &pcd->ep0;
+	} else {
+		return &pcd->out_ep;
+	}
+}
+
+usb3_pcd_ep_t *usb3_get_in_ep(usb3_pcd_t *pcd, uint32_t ep_num)
+{
+	if (ep_num == 0) {
+		return &pcd->ep0;
+	} else {
+		return &pcd->in_ep;
+	}
+}
+
+usb3_pcd_ep_t *usb3_get_ep_by_addr(usb3_pcd_t *pcd, uint16_t index)
+{
+	uint32_t ep_num = UE_GET_ADDR(index);
+
+	if (UE_GET_DIR(index) == UE_DIR_IN) {
+		return usb3_get_in_ep(pcd, ep_num);
+	} else {
+		return usb3_get_out_ep(pcd, ep_num);
+	}
+}
+
+
+void usb3_ep_clear_stall(usb3_pcd_t *pcd, usb3_pcd_ep_t *ep)
+{
+	usb3_dev_ep_regs_t *ep_reg;
+
+	if (ep->is_in) {
+		ep_reg = ep->in_ep_reg;
+	} else {
+		ep_reg = ep->out_ep_reg;
+	}
+
+	usb3_dep_cstall(pcd, ep_reg);
+}
+
+
+uint32_t usb3_get_device_speed(usb3_pcd_t *pcd)
+{
+	uint32_t dsts;
+	uint32_t speed = USB_SPEED_UNKNOWN;
+
+	dsts = usb3_rd32(&pcd->dev_global_regs->dsts);
+
+	switch ((dsts >> USB3_DSTS_CONNSPD_SHIFT) &
+		(USB3_DSTS_CONNSPD_BITS >> USB3_DSTS_CONNSPD_SHIFT)) {
+	case USB3_SPEED_HS_PHY_30MHZ_OR_60MHZ:
+		speed = USB_SPEED_HIGH;
+		break;
+
+	case USB3_SPEED_FS_PHY_30MHZ_OR_60MHZ:
+	case USB3_SPEED_FS_PHY_48MHZ:
+		speed = USB_SPEED_FULL;
+		break;
+
+	case USB3_SPEED_LS_PHY_6MHZ:
+		speed = USB_SPEED_LOW;
+		break;
+
+	case USB3_SPEED_SS_PHY_125MHZ_OR_250MHZ:
+		speed = USB_SPEED_SUPER;
+		break;
+	}
+
+	return speed;
+}
+
+void usb3_pcd_set_speed(usb3_pcd_t *pcd, int speed)
+{
+	/* Set the MPS of EP0 based on the connection speed */
+	switch (speed) {
+	case USB_SPEED_SUPER:
+		pcd->ep0.maxpacket = 512;
+		pcd->in_ep.maxpacket  = USB3_MAX_PACKET_SIZE;
+		pcd->out_ep.maxpacket = USB3_MAX_PACKET_SIZE;
+		break;
+
+	case USB_SPEED_HIGH:
+		pcd->ep0.maxpacket = 64;
+		pcd->in_ep.maxpacket  = USB2_HS_MAX_PACKET_SIZE;
+		pcd->out_ep.maxpacket = USB2_HS_MAX_PACKET_SIZE;
+		break;
+
+	case USB_SPEED_FULL:
+		pcd->ep0.maxpacket = 64;
+		pcd->in_ep.maxpacket  = USB2_FS_MAX_PACKET_SIZE;
+		pcd->out_ep.maxpacket = USB2_FS_MAX_PACKET_SIZE;
+		break;
+
+	case USB_SPEED_LOW:
+		pcd->ep0.maxpacket = 8;
+		pcd->in_ep.maxpacket  = 0;
+		pcd->out_ep.maxpacket = 0;
+		break;
+	}
+}
+
+void usb3_ep_set_stall(usb3_pcd_t *pcd, usb3_pcd_ep_t *ep)
+{
+	usb3_dev_ep_regs_t *ep_reg;
+
+	if (ep->is_in) {
+		ep_reg = ep->in_ep_reg;
+	} else {
+		ep_reg = ep->out_ep_reg;
+	}
+
+	usb3_dep_sstall(pcd, ep_reg);
+}
+
+static void ep0_do_stall(usb3_pcd_t *pcd)
+{
+	usb3_pcd_ep_t *ep0 = &pcd->ep0;
+
+	/* Stall EP0 IN & OUT simultanelusly */
+	ep0->is_in = 1;
+	usb3_ep_set_stall(pcd, ep0);
+	ep0->is_in = 0;
+	usb3_ep_set_stall(pcd, ep0);
+
+	/* Prepare for the next setup transfer */
+	ep0->stopped = 1;
+	pcd->ep0state = EP0_IDLE;
+	usb3_ep0_out_start(pcd);
+}
+
+static void do_clear_halt(usb3_pcd_t *pcd, usb3_pcd_ep_t *ep)
+{
+	usb3_ep_clear_stall(pcd, ep);
+
+	if (ep->stopped) {
+		ep->stopped = 0;
+	}
+}
+
+void usb3_pcd_ep_enable(usb3_pcd_t *pcd, usb3_pcd_ep_t *ep)
+{
+	/*
+	 * Activate the EP
+	 */
+	ep->stopped = 0;
+	ep->xfer_started = 0;
+
+	/* Set initial data PID. */
+	if (ep->type == USB3_EP_TYPE_BULK)
+		ep->data_pid_start = 0;
+
+	usb3_ep_activate(pcd, ep);
+}
+
+static void usb3_do_get_status(usb3_pcd_t *pcd)
+{
+	usb_device_request_t ctrl = pcd->ep0_setup_pkt->req;
+	uint8_t *status = pcd->ep0_status_buf;
+	usb3_pcd_ep_t *ep;
+
+	if (ctrl.wLength != 2) {
+		ep0_do_stall(pcd);
+		return;
+	}
+
+	switch (UT_GET_RECIPIENT(ctrl.bmRequestType)) {
+	case UT_DEVICE:
+		*status = 0; /* Bus powered */
+
+		if (pcd->speed == USB_SPEED_SUPER) {
+			if (pcd->state == USB3_STATE_CONFIGURED) {
+				if (usb3_u1_enabled(pcd))
+					*status |= 1 << 2;
+
+				if (usb3_u2_enabled(pcd))
+					*status |= 1 << 3;
+
+				*status |= pcd->ltm_enable << 4;
+			}
+		}
+
+		*(status + 1) = 0;
+		break;
+
+	case UT_INTERFACE:
+		*status = 0;
+		*(status + 1) = 0;
+		break;
+
+	case UT_ENDPOINT:
+		ep = usb3_get_ep_by_addr(pcd, ctrl.wIndex);
+
+		/* @todo check for EP stall */
+		*status = ep->stopped;
+		*(status + 1) = 0;
+		break;
+
+	default:
+		ep0_do_stall(pcd);
+		return;
+	}
+
+	pcd->ep0_req.bufdma = status;
+	pcd->ep0_req.length = 2;
+	pcd->ep0_req.actual = 0;
+	usb3_ep0_start_transfer(pcd, &pcd->ep0_req);
+}
+
+static void usb3_do_clear_feature(usb3_pcd_t *pcd)
+{
+	usb_device_request_t ctrl = pcd->ep0_setup_pkt->req;
+	usb3_pcd_ep_t *ep;
+
+	switch (UT_GET_RECIPIENT(ctrl.bmRequestType)) {
+	case UT_DEVICE:
+		switch (ctrl.wValue) {
+		case UF_DEVICE_REMOTE_WAKEUP:
+			break;
+
+		case UF_TEST_MODE:
+			/* @todo Add CLEAR_FEATURE for TEST modes. */
+			break;
+
+		case UF_U1_ENABLE:
+			if (pcd->speed != USB_SPEED_SUPER ||
+			    pcd->state != USB3_STATE_CONFIGURED) {
+				ep0_do_stall(pcd);
+				return;
+			}
+			usb3_disable_u1(pcd);
+			break;
+
+		case UF_U2_ENABLE:
+			if (pcd->speed != USB_SPEED_SUPER ||
+			    pcd->state != USB3_STATE_CONFIGURED) {
+				ep0_do_stall(pcd);
+				return;
+			}
+			usb3_disable_u2(pcd);
+			break;
+
+		case UF_LTM_ENABLE:
+			if (pcd->speed != USB_SPEED_SUPER ||
+			    pcd->state != USB3_STATE_CONFIGURED ||
+			    ctrl.wIndex != 0) {
+				ep0_do_stall(pcd);
+				return;
+			}
+			pcd->ltm_enable = 0;
+			break;
+
+		default:
+			ep0_do_stall(pcd);
+			return;
+		}
+		break;
+
+	case UT_INTERFACE:
+		/* if FUNCTION_SUSPEND ... */
+		if (ctrl.wValue) {
+			ep0_do_stall(pcd);
+			return;
+		}
+        break;
+
+	case UT_ENDPOINT:
+		ep = usb3_get_ep_by_addr(pcd, ctrl.wIndex);
+		if (ctrl.wValue != UF_ENDPOINT_HALT) {
+			ep0_do_stall(pcd);
+			return;
+		}
+		do_clear_halt(pcd, ep);
+		break;
+	}
+
+	pcd->ep0.is_in = 1;
+	pcd->ep0state = EP0_IN_WAIT_NRDY;
+}
+
+static void usb3_do_set_feature(usb3_pcd_t *pcd)
+{
+	usb_device_request_t ctrl = pcd->ep0_setup_pkt->req;
+	usb3_pcd_ep_t *ep;
+
+	switch (UT_GET_RECIPIENT(ctrl.bmRequestType)) {
+	case UT_DEVICE:
+		switch (ctrl.wValue) {
+		case UF_DEVICE_REMOTE_WAKEUP:
+			break;
+
+		case UF_TEST_MODE:
+			break;
+
+		case UF_DEVICE_B_HNP_ENABLE:
+			break;
+
+		case UOTG_NTF_HOST_REL:
+			break;
+
+		case UOTG_B3_RSP_ENABLE:
+			break;
+
+		case UF_DEVICE_A_HNP_SUPPORT:
+			/* RH port supports HNP */
+			break;
+
+		case UF_DEVICE_A_ALT_HNP_SUPPORT:
+			/* other RH port does */
+			break;
+
+		case UF_U1_ENABLE:
+			if (pcd->speed != USB_SPEED_SUPER ||
+			    pcd->state != USB3_STATE_CONFIGURED) {
+				ep0_do_stall(pcd);
+				return;
+			}
+			usb3_enable_u1(pcd);
+			break;
+
+		case UF_U2_ENABLE:
+			if (pcd->speed != USB_SPEED_SUPER ||
+			    pcd->state != USB3_STATE_CONFIGURED) {
+				ep0_do_stall(pcd);
+				return;
+			}
+			usb3_enable_u2(pcd);
+			break;
+
+		case UF_LTM_ENABLE:
+			if (pcd->speed != USB_SPEED_SUPER ||
+			    pcd->state != USB3_STATE_CONFIGURED ||
+			    ctrl.wIndex != 0) {
+				ep0_do_stall(pcd);
+				return;
+			}
+			pcd->ltm_enable = 1;
+			break;
+
+		default:
+			ep0_do_stall(pcd);
+			return;
+		}
+		break;
+
+	case UT_INTERFACE:
+		/* if FUNCTION_SUSPEND ... */
+		if (ctrl.wValue) {
+			ep0_do_stall(pcd);
+			return;
+		}
+        break;
+
+	case UT_ENDPOINT:
+		ep = usb3_get_ep_by_addr(pcd, ctrl.wIndex);
+		if (ctrl.wValue != UF_ENDPOINT_HALT) {
+			ep0_do_stall(pcd);
+			return;
+		}
+		ep->stopped = 1;
+		usb3_ep_set_stall(pcd, ep);
+		break;
+	}
+
+	pcd->ep0.is_in = 1;
+	pcd->ep0state = EP0_IN_WAIT_NRDY;
+}
+
+static void usb3_do_set_address(usb3_pcd_t *pcd)
+{
+	usb_device_request_t ctrl = pcd->ep0_setup_pkt->req;
+
+	if (ctrl.bmRequestType == UT_DEVICE) {
+		usb3_set_address(pcd, ctrl.wValue);
+		pcd->ep0.is_in = 1;
+		pcd->ep0state = EP0_IN_WAIT_NRDY;
+		if (ctrl.wValue) {
+			pcd->state = USB3_STATE_ADDRESSED;
+		} else {
+			pcd->state = USB3_STATE_DEFAULT;
+		}
+	}
+}
+
+static void usb3_do_set_config(usb3_pcd_t *pcd)
+{
+	usb_device_request_t ctrl = pcd->ep0_setup_pkt->req;
+	uint16_t wvalue = ctrl.wValue;
+	usb3_pcd_ep_t *ep;
+
+	if (ctrl.bmRequestType != (UT_WRITE | UT_STANDARD |
+		UT_DEVICE)) {
+		ep0_do_stall(pcd);
+		return;
+	}
+
+	if (!wvalue ||(wvalue == CONFIG_VALUE)) {
+		pcd->new_config = wvalue;
+		/* Set new configuration */
+		if (wvalue) {
+			/* Activate bulk in endpoint */
+			ep = &pcd->in_ep;
+			usb3_pcd_ep_enable(pcd, ep);
+
+			/* Activate bulk out endpoint */
+			ep = &pcd->out_ep;
+			usb3_pcd_ep_enable(pcd, ep);
+
+			/* Prepare for next bulk transfer */
+			usb3_bulk_out_transfer((void *)pcd);
+			usb3_bulk_in_transfer((void *)pcd, "start download process.");
+			pcd->state = USB3_STATE_CONFIGURED;
+		} else {
+			pcd->state = USB3_STATE_ADDRESSED;
+		}
+
+		pcd->ep0.is_in = 1;
+		pcd->ep0state = EP0_IN_WAIT_NRDY;
+	} else {
+		ep0_do_stall(pcd);
+	}
+}
+
+static void usb3_do_get_config(usb3_pcd_t *pcd)
+{
+	usb_device_request_t ctrl = pcd->ep0_setup_pkt->req;
+	uint8_t *status = pcd->ep0_status_buf;
+
+	if (ctrl.bmRequestType != (UT_READ | UT_STANDARD |
+			UT_DEVICE)) {
+		ep0_do_stall(pcd);
+		return;
+	}
+
+	/* Notify host the current config value */
+	*status = pcd->new_config;
+
+	pcd->ep0_req.bufdma = status;
+	pcd->ep0_req.length = 1;
+	pcd->ep0_req.actual = 0;
+	usb3_ep0_start_transfer(pcd, &pcd->ep0_req);
+}
+
+static void usb3_do_get_descriptor(usb3_pcd_t *pcd)
+{
+	usb_device_request_t ctrl = pcd->ep0_setup_pkt->req;
+	usb3_device_t *usb3_dev = pcd->usb3_dev;
+	uint8_t dt = ctrl.wValue >> 8;
+	uint8_t index = (uint8_t)ctrl.wValue;
+	uint16_t len = ctrl.wLength;
+	uint8_t *buf = pcd->ep0_status_buf;
+	uint16_t value = 0;
+
+	if (ctrl.bmRequestType != (UT_READ | UT_STANDARD |
+			UT_DEVICE)) {
+		ep0_do_stall(pcd);
+		return;
+	}
+
+	switch (dt) {
+	case UDESC_DEVICE:
+        {
+		struct usb_device_descriptor *dev =
+			(struct usb_device_descriptor *)usb3_dev->dev_desc;
+
+		dev->bLength = sizeof(struct usb_device_descriptor);
+		dev->bDescriptorType = UDESC_DEVICE;
+
+		dev->bDeviceClass = 0;
+		dev->bDeviceSubClass = 0;
+		dev->bDeviceProtocol = 0;
+
+		if (pcd->speed == USB_SPEED_SUPER) {
+			dev->bcdUSB = 0x300;
+			dev->bMaxPacketSize0 = 9; // NOTE! 2 ^ 9 = 512 for USB3
+		} else if (pcd->speed == USB_SPEED_HIGH) {
+			dev->bcdUSB = 0x0200;
+			dev->bMaxPacketSize0 = pcd->ep0.maxpacket;
+		} else {
+			dev->bcdUSB = 0x0110;
+			dev->bMaxPacketSize0 = pcd->ep0.maxpacket;
+		}
+
+		dev->idVendor =  0x1D6B;
+		dev->idProduct = 0xA001;
+		dev->bcdDevice = 0x0100;
+
+		dev->iManufacturer = STRING_MANUFACTURER;
+		dev->iProduct = STRING_PRODUCT;
+		dev->iSerialNumber = 0;
+
+		dev->bNumConfigurations = 1;
+
+		value = sizeof(struct usb_device_descriptor);
+		usb3_memcpy((void *)buf, (void *)dev, value);
+	}
+	break;
+
+	case UDESC_DEVICE_QUALIFIER:
+	{
+		struct usb_qualifier_descriptor *qual =
+			(struct usb_qualifier_descriptor *)buf;
+		struct usb_device_descriptor *dev =
+			(struct usb_device_descriptor *)usb3_dev->dev_desc;
+
+		qual->bLength = sizeof(*qual);
+		qual->bDescriptorType = UDESC_DEVICE_QUALIFIER;
+		qual->bcdUSB = dev->bcdUSB;
+		qual->bDeviceClass = dev->bDeviceClass;
+		qual->bDeviceSubClass = dev->bDeviceSubClass;
+		qual->bDeviceProtocol = dev->bDeviceProtocol;
+		qual->bMaxPacketSize0 = dev->bMaxPacketSize0;
+		qual->bNumConfigurations = 1;
+		qual->bRESERVED = 0;
+
+		value = sizeof(usb_qualifier_descriptor_t);
+        }
+        break;
+
+	case UDESC_CONFIG:
+        {
+		struct usb_config_descriptor *config =
+			(struct usb_config_descriptor *)buf;
+
+		config->bLength = sizeof(*config);
+		config->bDescriptorType = UDESC_CONFIG;
+		config->bNumInterfaces = 1;
+		config->bConfigurationValue = CONFIG_VALUE;
+		config->iConfiguration = 0;
+		config->bmAttributes = USB_CONFIG_ATT_ONE;
+
+		if (pcd->speed == USB_SPEED_SUPER) {
+			config->bMaxPower = USB_CONFIG_VBUS_DRAW / 8;
+		} else {
+			config->bMaxPower = USB_CONFIG_VBUS_DRAW / 2;
+		}
+
+		buf += sizeof(*config);
+		usb3_memcpy((void *)buf, (void *)&intf, sizeof(intf));
+		buf += sizeof(intf);
+
+		switch (pcd->speed) {
+		case USB_SPEED_SUPER:
+			usb3_memcpy((void *)buf, (void *)&ss_bulk_in, sizeof(ss_bulk_in));
+			buf += sizeof(ss_bulk_in);
+			usb3_memcpy((void *)buf, (void *)&ep_comp, sizeof(ep_comp));
+			buf += sizeof(ep_comp);
+			usb3_memcpy((void *)buf, (void *)&ss_bulk_out, sizeof(ss_bulk_out));
+			buf += sizeof(ss_bulk_out);
+			usb3_memcpy((void *)buf, (void *)&ep_comp, sizeof(ep_comp));
+
+			config->wTotalLength = sizeof(*config) + sizeof(intf)
+				+ sizeof(ss_bulk_in) + sizeof(ep_comp)
+				+ sizeof(ss_bulk_out) + sizeof(ep_comp);
+			break;
+
+		default: /* HS/FS */
+		{
+			struct usb_endpoint_descriptor *endp =
+				(struct usb_endpoint_descriptor *)buf;
+
+			usb3_memcpy((void *)buf, (void *)&hs_bulk_in, sizeof(hs_bulk_in));
+			(endp++)->wMaxPacketSize = pcd->in_ep.maxpacket;
+			buf += sizeof(hs_bulk_in);
+			usb3_memcpy((void *)buf, (void *)&hs_bulk_out, sizeof(hs_bulk_out));
+			(endp++)->wMaxPacketSize = pcd->out_ep.maxpacket;
+		}
+			config->wTotalLength = sizeof(*config) + sizeof(intf)
+				+ sizeof(hs_bulk_in) + sizeof(hs_bulk_out);
+			break;
+		}
+		value = config->wTotalLength;
+	}
+	break;
+
+	case UDESC_STRING:
+        {
+		switch (index) {
+		case STRING_LANGUAGE:
+			buf[0] = 0x04;
+			buf[1] = UDESC_STRING;
+			buf[2] = 0x09;
+			buf[3] = 0x04;
+
+			value = 0x04;
+			break;
+
+		case STRING_MANUFACTURER:
+			buf[0] = usb3_dev->string_manu_len + 2;
+			buf[1] = UDESC_STRING;
+			usb3_memcpy((void *)(buf+2), (void *)usb3_dev->string_manu,
+				usb3_dev->string_manu_len);
+
+			value = usb3_dev->string_manu_len + 2;
+			break;
+
+		case STRING_PRODUCT:
+			buf[0] = usb3_dev->string_prod_len + 2;
+			buf[1] = UDESC_STRING;
+
+			usb3_memcpy((void *)(buf+2), (void *)usb3_dev->string_prod,
+				usb3_dev->string_prod_len);
+
+			value = usb3_dev->string_prod_len + 2;
+			break;
+
+		default:
+			ep0_do_stall(pcd);
+			return;
+		}
+	}
+	break;
+
+	case UDESC_BOS:
+		if (pcd->speed != USB_SPEED_SUPER) {
+		/*
+			* The USB compliance test (USB 2.0 Command Verifier)
+			* issues this request. We should not run into the
+			* default path here. But return for now until
+			* the superspeed support is added.
+			*/
+		}
+
+		value = bos.wTotalLength;
+
+		usb3_memcpy((void *)buf, (void *)&bos, sizeof(bos));
+		buf += sizeof(bos);
+		usb3_memcpy((void *)buf, (void *)&cap1, sizeof(cap1));
+		buf += sizeof(cap1);
+		usb3_memcpy((void *)buf, (void *)&cap2, sizeof(cap2));
+		buf += sizeof(cap2);
+		usb3_memcpy((void *)buf, (void *)&cap3, sizeof(cap3));
+
+		break;
+
+	default:
+		ep0_do_stall(pcd);
+		return;
+	}
+
+	pcd->ep0_req.bufdma = pcd->ep0_status_buf;
+	pcd->ep0_req.length = value < len ? value : len;
+	pcd->ep0_req.actual = 0;
+	usb3_ep0_start_transfer(pcd, &pcd->ep0_req);
+}
+
+void usb3_do_setup(usb3_pcd_t *pcd)
+{
+	usb_device_request_t ctrl = pcd->ep0_setup_pkt->req;
+	usb3_pcd_ep_t *ep0 = &pcd->ep0;
+	uint16_t wlength;
+
+	wlength = ctrl.wLength;
+
+	ep0->stopped = 0;
+	ep0->three_stage = 1;
+
+	if (ctrl.bmRequestType & UE_DIR_IN) {
+		ep0->is_in = 1;
+		pcd->ep0state = EP0_IN_DATA_PHASE;
+	} else {
+		ep0->is_in = 0;
+		pcd->ep0state = EP0_OUT_DATA_PHASE;
+	}
+
+	if (wlength == 0) {
+		ep0->is_in = 1;
+		pcd->ep0state = EP0_IN_WAIT_NRDY;
+		ep0->three_stage = 0;
+	}
+
+	if ((UT_GET_TYPE(ctrl.bmRequestType)) != UT_STANDARD) {
+		ep0_do_stall(pcd);
+		return;
+	}
+
+	switch (ctrl.bRequest) {
+	case UR_GET_STATUS:
+		usb3_do_get_status(pcd);
+		break;
+
+	case UR_CLEAR_FEATURE:
+		usb3_do_clear_feature(pcd);
+		break;
+
+	case UR_SET_FEATURE:
+		usb3_do_set_feature(pcd);
+		break;
+
+	case UR_SET_ADDRESS:
+		usb3_do_set_address(pcd);
+		break;
+
+	case UR_SET_CONFIG:
+		usb3_do_set_config(pcd);
+
+		/* Must wait until SetConfig before accepting U1/U2 link
+		 * control, otherwise we have problems with VIA hubs
+		 */
+		usb3_accept_u1(pcd);
+		usb3_accept_u2(pcd);
+
+		usb_info("usb enum done\n");
+
+        pcd->ltm_enable = 0;
+		break;
+
+	case UR_GET_CONFIG:
+		usb3_do_get_config(pcd);
+		break;
+
+	case UR_GET_DESCRIPTOR:
+		usb3_do_get_descriptor(pcd);
+		break;
+
+	case UR_SET_SEL:
+		/* For now this is a no-op */
+		pcd->ep0_req.bufdma = pcd->ep0_status_buf;
+		pcd->ep0_req.length = USB3_STATUS_BUF_SIZE;
+		pcd->ep0_req.actual = 0;
+		ep0->send_zlp = 0;
+		usb3_ep0_start_transfer(pcd, &pcd->ep0_req);
+		break;
+
+	case UR_SET_ISOC_DELAY:
+		/* For now this is a no-op */
+		pcd->ep0.is_in = 1;
+		pcd->ep0state = EP0_IN_WAIT_NRDY;
+		break;
+
+	default:
+		ep0_do_stall(pcd);
+		break;
+	}
+}
+
+void usb3_os_get_trb(usb3_pcd_t *pcd, usb3_pcd_ep_t *ep,
+			 usb3_pcd_req_t *req)
+{
+	/* If EP0, fill request with EP0 IN/OUT data TRB */
+	if (ep == &pcd->ep0) {
+		if (ep->is_in) {
+			req->trb = pcd->ep0_in_desc;
+			req->trbdma = (phys_addr_t)pcd->ep0_in_desc;
+		} else {
+			req->trb = pcd->ep0_out_desc;
+			req->trbdma = (phys_addr_t)pcd->ep0_out_desc;
+		}
+	/* Else fill request with TRB from the non-EP0 allocation */
+	} else {
+		req->trb = ep->ep_desc;
+		req->trbdma = (phys_addr_t)ep->ep_desc;
+	}
+}
+
+void usb3_ep0_start_transfer(usb3_pcd_t *pcd, usb3_pcd_req_t *req)
+{
+	usb3_pcd_ep_t *ep0 = &pcd->ep0;
+	usb3_dev_ep_regs_t *ep_reg;
+	usb3_dma_desc_t *desc;
+	phys_addr_t desc_dma;
+	uint32_t desc_type, len;
+	uint8_t tri;
+
+	/* Get the DMA Descriptor (TRB) for this request */
+	usb3_os_get_trb(pcd, ep0, req);
+	desc = req->trb;
+	desc_dma = req->trbdma;
+
+	if (ep0->is_in) {
+		/*
+		 * Start DMA on EP0-IN
+		 */
+		ep_reg = ep0->in_ep_reg;
+
+		/* DMA Descriptor (TRB) setup */
+		len = req->length;
+
+		if (pcd->ep0state == EP0_IN_STATUS_PHASE) {
+			if (ep0->three_stage)
+				desc_type = USB3_DSCCTL_TRBCTL_STATUS_3;
+			else
+				desc_type = USB3_DSCCTL_TRBCTL_STATUS_2;
+		} else {
+			desc_type = USB3_DSCCTL_TRBCTL_CTLDATA_1ST;
+		}
+
+		usb3_fill_desc(desc, (phys_addr_t)req->bufdma,
+				   len, 0, desc_type,
+				   USB3_DSCCTL_IOC_BIT | USB3_DSCCTL_ISP_BIT |
+				   USB3_DSCCTL_LST_BIT, 1);
+		/* Issue "DEPSTRTXFER" command to EP0-IN */
+		tri = usb3_dep_startxfer(pcd, ep_reg, desc_dma, 0);
+		ep0->tri_in = tri;
+	} else {
+		/*
+		 * Start DMA on EP0-OUT
+		 */
+		ep_reg = ep0->out_ep_reg;
+
+		/* DMA Descriptor (TRB) setup */
+		len = (req->length + ep0->maxpacket - 1) &
+			~(ep0->maxpacket - 1);
+
+		if (pcd->ep0state == EP0_OUT_STATUS_PHASE) {
+			if (ep0->three_stage)
+				desc_type = USB3_DSCCTL_TRBCTL_STATUS_3;
+			else
+				desc_type = USB3_DSCCTL_TRBCTL_STATUS_2;
+		} else {
+			desc_type = USB3_DSCCTL_TRBCTL_CTLDATA_1ST;
+		}
+
+		usb3_fill_desc(desc, (phys_addr_t)req->bufdma,
+				   len, 0, desc_type,
+				   USB3_DSCCTL_IOC_BIT | USB3_DSCCTL_ISP_BIT |
+				   USB3_DSCCTL_LST_BIT, 1);
+		/* Issue "DEPSTRTXFER" command to EP0-OUT */
+		tri = usb3_dep_startxfer(pcd, ep_reg, desc_dma, 0);
+		ep0->tri_out = tri;
+	}
+}
+
+static void ep0_continue_transfer(usb3_pcd_t *pcd, usb3_pcd_req_t *req)
+{
+	usb3_pcd_ep_t *ep0 = &pcd->ep0;
+	usb3_dev_ep_regs_t *ep_reg;
+	usb3_dma_desc_t *desc;
+	phys_addr_t desc_dma;
+	uint8_t tri;
+
+	/* It can be called to send a 0-length packet after the end of a transfer, so the code here
+	 * only supports that case.
+	 */
+
+	if (ep0->is_in) {
+		desc = pcd->ep0_in_desc;
+		desc_dma = (phys_addr_t)(pcd->ep0_in_desc);
+		ep_reg = ep0->in_ep_reg;
+
+		/* DMA Descriptor Setup */
+		usb3_fill_desc(desc, (phys_addr_t)req->bufdma,
+				   0, 0, USB3_DSCCTL_TRBCTL_NORMAL,
+				   USB3_DSCCTL_IOC_BIT | USB3_DSCCTL_ISP_BIT |
+				   USB3_DSCCTL_LST_BIT, 1);
+
+		tri = usb3_dep_startxfer(pcd, ep_reg, desc_dma, 0);
+		ep0->tri_in = tri;
+	}
+}
+
+void usb3_ep_start_transfer(usb3_pcd_t *pcd, usb3_pcd_ep_t *ep)
+{
+	usb3_pcd_req_t *req = &ep->req;
+	usb3_dev_ep_regs_t *ep_reg;
+	usb3_dma_desc_t *desc;
+	phys_addr_t desc_dma;
+	uint32_t len;
+	uint8_t tri;
+
+	/* Get the TRB for this request */
+	usb3_os_get_trb(pcd, ep, req);
+
+	ep->send_zlp = 0;
+	desc = req->trb;
+	desc_dma = req->trbdma;
+
+	if (ep->is_in) {
+		/* For IN, TRB length is just xfer length */
+		len = req->length;
+	} else {
+		/* For OUT, TRB length must be multiple of maxpacket */
+		/* Must be power of 2, use cheap AND */
+		len = (req->length + ep->maxpacket - 1)
+			& ~(ep->maxpacket - 1);
+
+		req->length = len;
+	}
+
+	/* DMA Descriptor Setup */
+	usb3_fill_desc(desc, (phys_addr_t)req->bufdma,
+			   len, 0, USB3_DSCCTL_TRBCTL_NORMAL,
+			   USB3_DSCCTL_ISP_BIT | USB3_DSCCTL_IOC_BIT |
+			   USB3_DSCCTL_LST_BIT, 1);
+
+	if (ep->is_in) {
+		/*
+		 * Start DMA on EPn-IN
+		 */
+		ep_reg = ep->in_ep_reg;
+		/* Issue "DEPSTRTXFER" command to EP */
+		//			printf("\n########%s,%d\n",__func__,__LINE__);
+		tri = usb3_dep_startxfer(pcd, ep_reg,
+				desc_dma, 0);
+		ep->tri_in = tri;
+	} else {
+		/*
+		 * Start DMA on EPn-OUT
+		 */
+		ep_reg = ep->out_ep_reg;
+#if 1
+		if (ep->xfer_started) {
+			/* Issue "DEPUPDTXFER" command to EP */
+			usb3_dep_updatexfer(pcd, ep_reg,
+						ep->tri_out);
+		} else {
+#endif
+			/* Issue "DEPSTRTXFER" command to EP */
+			tri = usb3_dep_startxfer(pcd, ep_reg,
+						desc_dma, 0);
+			ep->tri_out = tri;
+			ep->xfer_started = 1;
+		}
+	}
+}
+
+void usb3_bulk_out_transfer(void *dev)
+{
+	usb3_pcd_t *pcd = (usb3_pcd_t *)dev;
+	usb3_pcd_ep_t *ep = &pcd->out_ep;
+	usb3_pcd_req_t *req = &ep->req;
+
+	/* req->actual = 0; */
+	req->length = ep->maxpacket;
+	req->bufdma = pcd->ss_bulk_buf;
+	req->complete = usb3_handle_protocol;
+
+	usb3_ep_start_transfer(pcd, ep);
+
+	return;
+}
+
+void usb3_bulk_out_continue_transfer(void *dev)
+{
+	usb3_pcd_t *pcd = (usb3_pcd_t *)dev;
+	usb3_pcd_ep_t *ep = &pcd->out_ep;
+
+	usb3_ep_start_transfer(pcd, ep);
+}
+
+void usb_tx_status_complete(void *dev)
+{
+}
+
+void usb3_bulk_in_transfer(void *dev, const char *status)
+{
+	usb3_pcd_t *pcd = (usb3_pcd_t *)dev;
+	usb3_pcd_ep_t *ep = &pcd->in_ep;
+	usb3_pcd_req_t *req = &ep->req;
+	int len;
+
+	len = strlen(status)+1;
+	memset(req->bufdma, 0, 512);
+	memcpy(req->bufdma,status,len);
+	req->length = len;
+
+	/* req->actual = 0; */
+	req->complete = usb_tx_status_complete;
+
+	usb3_ep_start_transfer(pcd, ep);
+}
+
+static void ep0_complete_request(usb3_pcd_t *pcd, usb3_pcd_req_t *req,
+				usb3_dma_desc_t *desc, int status)
+{
+	usb3_pcd_ep_t *ep = &pcd->ep0;
+
+	if (!req)
+		return;
+
+	if (pcd->ep0state == EP0_OUT_DATA_PHASE ||
+		pcd->ep0state == EP0_IN_DATA_PHASE) {
+		if (ep->is_in) {
+			if (usb3_get_xfercnt(desc) == 0) {
+				pcd->ep0.is_in = 0;
+				pcd->ep0state = EP0_OUT_WAIT_NRDY;
+			}
+		} else {
+			pcd->ep0.is_in = 1;
+			pcd->ep0state = EP0_IN_WAIT_NRDY;
+		}
+	}
+}
+
+static void setup_in_status_phase(usb3_pcd_t *pcd, void *buf)
+{
+	usb3_pcd_ep_t *ep0 = &pcd->ep0;
+
+	if (pcd->ep0state == EP0_STALL) {
+		return;
+	}
+
+	ep0->is_in = 1;
+	pcd->ep0state = EP0_IN_STATUS_PHASE;
+
+	pcd->ep0_req.bufdma = buf;
+	pcd->ep0_req.length = 0;
+	pcd->ep0_req.actual = 0;
+	usb3_ep0_start_transfer(pcd, &pcd->ep0_req);
+}
+
+static void setup_out_status_phase(usb3_pcd_t *pcd, void *buf)
+{
+	usb3_pcd_ep_t *ep0 = &pcd->ep0;
+
+	if (pcd->ep0state == EP0_STALL) {
+		return;
+	}
+
+	ep0->is_in = 0;
+	pcd->ep0state = EP0_OUT_STATUS_PHASE;
+
+	pcd->ep0_req.bufdma = buf;
+	pcd->ep0_req.length = 0;
+	pcd->ep0_req.actual = 0;
+	usb3_ep0_start_transfer(pcd, &pcd->ep0_req);
+}
+
+void usb3_handle_ep0(usb3_pcd_t *pcd, usb3_pcd_req_t *req,
+			 uint32_t event)
+{
+	usb3_pcd_ep_t *ep0 = &pcd->ep0;
+	usb3_dma_desc_t *desc;
+	uint32_t byte_count, len;
+	uint32_t status;
+
+	switch (pcd->ep0state) {
+	case EP0_IN_DATA_PHASE:
+		if (!req)
+			req = &pcd->ep0_req;
+		desc = pcd->ep0_in_desc;
+
+		if (dwc_usb3_is_hwo(desc)) {
+			goto out;
+		}
+
+		status = usb3_get_xfersts(desc);
+		if (status & USB3_TRBRSP_SETUP_PEND) {
+			/* Start of a new Control transfer */
+			desc->status = 0;
+		}
+
+		byte_count = req->length - usb3_get_xfercnt(desc);
+		req->actual += byte_count;
+		req->bufdma += byte_count;
+
+		if (req->actual < req->length) {
+			/* IN CONTINUE, Stall EP0 */
+			ep0_do_stall(pcd);
+		} else if (ep0->send_zlp) {
+			/* CONTINUE TRANSFER IN ZLP */
+			ep0_continue_transfer(pcd, req);
+			ep0->send_zlp = 0;
+		} else {
+			/* COMPLETE IN TRANSFER */
+			ep0_complete_request(pcd, req, desc, 0);
+		}
+
+		break;
+
+	case EP0_OUT_DATA_PHASE:
+		if (!req)
+			req = &pcd->ep0_req;
+		desc = pcd->ep0_out_desc;
+
+		if (dwc_usb3_is_hwo(desc)) {
+			goto out;
+		}
+
+		status = usb3_get_xfersts(desc);
+		if (status & USB3_TRBRSP_SETUP_PEND) {
+			/* Start of a new Control transfer */
+		}
+
+		len = (req->length + ep0->maxpacket - 1) &
+			~(ep0->maxpacket - 1);
+		byte_count = len - usb3_get_xfercnt(desc);
+		req->actual += byte_count;
+		req->bufdma += byte_count;
+
+		if (ep0->send_zlp) {
+			/* CONTINUE TRANSFER OUT ZLP */
+			ep0_continue_transfer(pcd, req);
+			ep0->send_zlp = 0;
+
+		} else {
+			/* COMPLETE OUT TRANSFER */
+			ep0_complete_request(pcd, req, desc, 0);
+		}
+
+		break;
+
+	case EP0_IN_WAIT_NRDY:
+	case EP0_OUT_WAIT_NRDY:
+		if (ep0->is_in)
+			setup_in_status_phase(pcd, pcd->ep0_setup_pkt);
+		else
+			setup_out_status_phase(pcd, pcd->ep0_setup_pkt);
+
+		break;
+
+	case EP0_IN_STATUS_PHASE:
+	case EP0_OUT_STATUS_PHASE:
+		if (ep0->is_in)
+			desc = pcd->ep0_in_desc;
+		else
+			desc = pcd->ep0_out_desc;
+		ep0_complete_request(pcd, req, desc, 0);
+
+		pcd->ep0state = EP0_IDLE;
+		ep0->stopped = 1;
+		ep0->is_in = 0;	/* OUT for next SETUP */
+
+		/* Prepare for more SETUP Packets */
+		usb3_ep0_out_start(pcd);
+		break;
+
+	case EP0_STALL:
+		break;
+
+	case EP0_IDLE:
+		break;
+	}
+out:
+	return;
+}
+
+void usb3_os_handle_ep0(usb3_pcd_t *pcd, uint32_t event)
+{
+	usb3_pcd_req_t *req = NULL;
+
+	if (pcd->ep0state == EP0_IDLE) {
+		usb3_do_setup(pcd);
+	} else {
+		usb3_handle_ep0(pcd, req, event);
+	}
+}
+
+void usb3_request_done(usb3_pcd_t *pcd, usb3_pcd_ep_t *ep,
+			   usb3_pcd_req_t *req, int status)
+{
+
+	if (ep != &pcd->ep0)
+		req->trb = NULL;
+	if (req->complete)
+		req->complete(pcd);
+
+	req->actual = 0;
+
+	return;
+}
+extern int usb_out_open;
+int usb3_ep_complete_request(usb3_pcd_t *pcd,
+                 usb3_pcd_ep_t *ep, uint32_t event)
+{
+	usb3_pcd_req_t *req = &ep->req;
+	usb3_dma_desc_t *desc = req->trb;
+	uint32_t byte_count;
+	int error = USB_NO_ERR;
+
+	ep->send_zlp = 0;
+
+	if (!desc) {
+		return USB_PROCESS_ERR;
+	}
+#if 0
+	if (dwc_usb3_is_hwo(desc)) {
+		return USB_PROCESS_ERR;
+	}
+#endif
+	if (ep->is_in) {
+		/* IN endpoint */
+		if (usb3_get_xfercnt(desc) == 0) {
+			req->actual += req->length;
+		}
+		/* Reset IN tri */
+		ep->tri_in = 0;
+
+		/* Complete the IN request */
+		usb3_request_done(pcd, ep, req, 0);
+	} else {   /* OUT endpoint */
+		byte_count = req->length -
+					usb3_get_xfercnt(desc);
+		req->actual += byte_count;
+		req->bufdma += byte_count;
+		pcd->file_received += byte_count;
+		/* Reset OUT tri */
+		ep->tri_out = 0;
+
+		/* OUT transfer complete or not */
+		if ((byte_count < ep->maxpacket) ||
+			(pcd->file_capacity <= pcd->file_received - FRAME_HEAD_LEN)) {
+			/* Complete the OUT request */
+			usb3_request_done(pcd, ep, req, 0);
+		} else {
+			usb3_bulk_out_continue_transfer((void *)pcd);
+		}
+	}
+
+	return error;
+}
+
diff -uraN u-boot-2016.11/drivers/usb/gadget/udc3/usb3_pcd.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/usb3_pcd.h
--- u-boot-2016.11/drivers/usb/gadget/udc3/usb3_pcd.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/usb3_pcd.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,20 @@
+#ifndef __USB3_PCD_H__
+#define __USB3_PCD_H__
+
+usb3_pcd_ep_t *usb3_get_out_ep(usb3_pcd_t *pcd, uint32_t ep_num);
+usb3_pcd_ep_t *usb3_get_in_ep(usb3_pcd_t *pcd, uint32_t ep_num);
+usb3_pcd_ep_t *usb3_get_ep_by_addr(usb3_pcd_t *pcd, uint16_t index);
+void usb3_ep_clear_stall(usb3_pcd_t *pcd, usb3_pcd_ep_t *ep);
+uint32_t usb3_get_device_speed(usb3_pcd_t *pcd);
+void usb3_pcd_set_speed(usb3_pcd_t *pcd, int speed);
+void usb3_ep_set_stall(usb3_pcd_t *pcd, usb3_pcd_ep_t *ep);
+void usb3_bulk_in_transfer(void *dev, const char *status);
+void usb3_bulk_out_transfer_cmd(void *dev);
+int usb3_bulk_out_transfer_data(void *dev);
+void usb3_bulk_out_transfer(void *dev);
+void usb3_ep_start_transfer(usb3_pcd_t *pcd, usb3_pcd_ep_t *ep);
+int usb3_ep_complete_request(usb3_pcd_t *pcd,
+                 usb3_pcd_ep_t *ep, uint32_t event);
+void usb3_os_handle_ep0(usb3_pcd_t *pcd, uint32_t event);
+
+#endif /* __USB3_PCD_H__ */
diff -uraN u-boot-2016.11/drivers/usb/gadget/udc3/usb3_pcd_intr.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/usb3_pcd_intr.c
--- u-boot-2016.11/drivers/usb/gadget/udc3/usb3_pcd_intr.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/usb3_pcd_intr.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,147 @@
+#include "usb3_drv.h"
+#include "usb3_pcd.h"
+
+static void handle_usb_reset_intr(usb3_pcd_t *pcd)
+{
+	usb3_pcd_ep_t *ep;
+
+	/* Clear stall on each EP */
+	ep = &pcd->in_ep;
+	if (ep->stopped)
+		usb3_ep_clear_stall(pcd, ep);
+
+	ep = &pcd->out_ep;
+	if (ep->stopped)
+		usb3_ep_clear_stall(pcd, ep);
+
+	/* Set Device Address to 0 */
+	usb3_set_address(pcd, 0);
+
+	pcd->ltm_enable = 0;
+}
+
+static void handle_connect_done_intr(usb3_pcd_t *pcd)
+{
+	usb3_pcd_ep_t *ep0 = &pcd->ep0;
+	uint32_t diepcfg0, doepcfg0, diepcfg1, doepcfg1;
+	usb3_dev_ep_regs_t *ep_reg;
+	int speed;
+
+	ep0->stopped = 0;
+	speed = usb3_get_device_speed(pcd);
+	pcd->speed = speed;
+
+	usb3_pcd_set_speed(pcd, speed);
+
+	/*
+	 * Set the MPS of EP0 based on the connection speed
+	 */
+	diepcfg0 = USB3_EP_TYPE_CONTROL << USB3_EPCFG0_EPTYPE_SHIFT;
+	diepcfg0 |= USB3_CFG_ACTION_MODIFY << USB3_EPCFG0_CFG_ACTION_SHIFT;
+	diepcfg1 = USB3_EPCFG1_XFER_CMPL_BIT | USB3_EPCFG1_XFER_IN_PROG_BIT | USB3_EPCFG1_XFER_NRDY_BIT |
+		   USB3_EPCFG1_EP_DIR_BIT;
+
+	doepcfg0 = USB3_EP_TYPE_CONTROL << USB3_EPCFG0_EPTYPE_SHIFT;
+	doepcfg0 |= USB3_CFG_ACTION_MODIFY << USB3_EPCFG0_CFG_ACTION_SHIFT;
+	doepcfg1 = USB3_EPCFG1_XFER_CMPL_BIT | USB3_EPCFG1_XFER_IN_PROG_BIT | USB3_EPCFG1_XFER_NRDY_BIT;
+
+	switch (speed) {
+	case USB_SPEED_SUPER:
+		diepcfg0 |= 512 << USB3_EPCFG0_MPS_SHIFT;
+		doepcfg0 |= 512 << USB3_EPCFG0_MPS_SHIFT;
+		break;
+
+	case USB_SPEED_HIGH:
+	case USB_SPEED_FULL:
+		diepcfg0 |= 64 << USB3_EPCFG0_MPS_SHIFT;
+		doepcfg0 |= 64 << USB3_EPCFG0_MPS_SHIFT;
+		break;
+
+	case USB_SPEED_LOW:
+		diepcfg0 |= 8 << USB3_EPCFG0_MPS_SHIFT;
+		doepcfg0 |= 8 << USB3_EPCFG0_MPS_SHIFT;
+		break;
+	}
+
+	diepcfg0 |= ep0->tx_fifo_num << USB3_EPCFG0_TXFNUM_SHIFT;
+
+	/* Issue "DEPCFG" command to EP0-OUT */
+	ep_reg = &pcd->out_ep_regs[0];
+	usb3_dep_cfg(pcd, ep_reg, doepcfg0, doepcfg1, 0);
+
+	/* Issue "DEPCFG" command to EP0-IN */
+	ep_reg = &pcd->in_ep_regs[0];
+	usb3_dep_cfg(pcd, ep_reg, diepcfg0, diepcfg1, 0);
+
+	pcd->state = USB3_STATE_DEFAULT;
+}
+
+int usb3_handle_ep_intr(usb3_pcd_t *pcd, uint32_t physep, uint32_t event)
+{
+	usb3_pcd_ep_t *ep;
+	int epnum, is_in;
+	int error = USB_NO_ERR;
+
+	/* Physical Out EPs are even, physical In EPs are odd */
+	is_in = physep & 1;
+	epnum = (physep >> 1) & 0xf;
+
+	/* Get EP pointer */
+	if (is_in) {
+		ep = usb3_get_in_ep(pcd, epnum);
+	} else {
+		ep = usb3_get_out_ep(pcd, epnum);
+	}
+//printf("\n##########%s,%d,event=0x%x\n",__func__,__LINE__,event);
+	switch (event & USB3_DEPEVT_INTTYPE_BITS) {
+	case USB3_DEPEVT_XFER_CMPL << USB3_DEPEVT_INTTYPE_SHIFT:
+		ep->xfer_started = 0;
+
+		/* Complete the transfer */
+		if (0 == epnum) {
+			usb3_os_handle_ep0(pcd, event);
+		} else {
+//printf("\n##########%s,%d,event=0x%x\n",__func__,__LINE__,event);
+			error = usb3_ep_complete_request(pcd, ep, event);
+		}
+		break;
+
+	case USB3_DEPEVT_XFER_NRDY << USB3_DEPEVT_INTTYPE_SHIFT:
+		if (0 == epnum) {
+			switch (pcd->ep0state) {
+			case EP0_IN_WAIT_NRDY:
+				if (is_in) {
+					usb3_os_handle_ep0(pcd, event);
+				}
+				break;
+			case EP0_OUT_WAIT_NRDY:
+				if (!is_in) {
+					usb3_os_handle_ep0(pcd, event);
+				}
+				break;
+			default:
+				break;
+			}
+		}
+		break;
+	}
+
+	return error;
+}
+
+void usb3_handle_dev_intr(usb3_pcd_t *pcd, uint32_t event)
+{
+	uint32_t dint = (event >> USB3_DEVT_SHIFT) &
+			(USB3_DEVT_BITS >> USB3_DEVT_SHIFT);
+
+	switch (dint) {
+	case USB3_DEVT_USBRESET:
+		handle_usb_reset_intr(pcd);
+		break;
+
+	case USB3_DEVT_CONNDONE:
+		handle_connect_done_intr(pcd);
+		break;
+	}
+}
+
diff -uraN u-boot-2016.11/drivers/usb/gadget/udc3/usb3_prot.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/usb3_prot.c
--- u-boot-2016.11/drivers/usb/gadget/udc3/usb3_prot.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/usb3_prot.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,174 @@
+#include "usb3.h"
+#include "usb3_drv.h"
+#include "usb3_pcd.h"
+#include "usb3_prot.h"
+#include "onchiprom.h"
+
+#include <common.h>
+#include <linux/string.h>
+
+#define USTART  0xFA
+#define UHEAD   0xFE
+#define UDATA   0xDA
+#define UTAIL   0xED
+#define UCMD    0XAB
+#define UREQ    0XFB
+
+
+char uACK[2] = {0xAA,'\0'};
+char uNAK[2] = {0x55,'\0'};
+char tx_state[200];
+static phys_addr_t  rx_addr;
+static uint32_t  rx_length;
+extern int usb_connected;
+int usb_out_open = 0;
+
+void usb3_bulk_out_transfer_cmd(void *dev)
+{
+	usb3_pcd_t *pcd = (usb3_pcd_t *)dev;
+	usb3_pcd_ep_t *ep = &pcd->out_ep;
+	usb3_pcd_req_t *req = &ep->req;
+
+	memset(pcd->ss_bulk_buf, 0x0, USB3_BULK_BUF_SIZE);
+	/* req->actual = 0; */
+	req->length = ep->maxpacket;
+	req->bufdma =  pcd->ss_bulk_buf;
+	req->complete = usb3_handle_protocol;
+	usb3_ep_start_transfer(pcd, ep);
+
+	return;
+}
+
+void usb3_handle_data(void *dev)
+{
+	usb3_pcd_t *pcd = (usb3_pcd_t *)dev;
+	usb3_pcd_ep_t *ep = &pcd->out_ep;
+	usb3_pcd_req_t *req = &ep->req;
+
+	if (req->actual > rx_length) {
+		req->actual = rx_length;
+	}
+
+	rx_addr += req->actual;
+	rx_length -= req->actual;
+
+	if (rx_length > 0) {
+		usb3_bulk_out_transfer_data(dev);
+	} else {
+		usb3_bulk_out_transfer_cmd(dev);
+	}
+}
+
+int usb3_bulk_out_transfer_data(void *dev)
+{
+	usb3_pcd_t *pcd = (usb3_pcd_t *)dev;
+	usb3_pcd_ep_t *ep = &pcd->out_ep;
+	usb3_pcd_req_t *req = &ep->req;
+
+	/* req->actual = 0; */
+
+	/* For DWC3 controller,If CHN=0 and HWO=0 for the TRB, this field represents the total remaining Buffer
+	 * Descriptor buffer size in bytes. Valid Range: 0 bytes to (16 MB - 1 byte).
+	 * The hardware decrements this field to represent the remaining buffer size after data is
+	 * transferred.
+	 * Note: for bulk transfer, max length = 16MB - maxpacket;
+	 * */
+	if(rx_length >= (USB3_DSCSTS_XFRCNT_MAX - ep->maxpacket)) {
+		req->length = USB3_DSCSTS_XFRCNT_MAX - ep->maxpacket;
+	} else {
+		req->length = rx_length;
+	}
+
+	req->bufdma = (uint8_t *)rx_addr;
+	req->complete = usb3_handle_data;
+
+	usb3_ep_start_transfer(pcd, ep);
+
+	return USB_NO_ERR;
+}
+
+void udc_puts(const char *s)
+{
+	if (strlen(s) > 200)
+		return;
+	else {
+		if (usb_out_open == 1) {
+			strcat(tx_state, s);
+		}
+	}
+}
+
+typedef int (*USB3_HANDLE_REQUEST)(uint8_t * const buff, unsigned int * bufflen);
+USB3_HANDLE_REQUEST handle_request = NULL;
+void SetUSB3CallBackFunc(USB3_HANDLE_REQUEST func)
+{
+	handle_request = func;
+}
+
+void usb3_handle_protocol(void *dev)
+{
+	usb3_pcd_t *pcd = (usb3_pcd_t *)dev;
+	int ret;
+	char *buf = (char *)pcd->ss_bulk_buf;
+
+	if (buf[0]==USTART) {
+		usb3_bulk_out_transfer_cmd(pcd);
+		usb3_bulk_in_transfer(dev, uACK);
+	} else if(buf[0]==UHEAD) {
+		rx_addr = (buf[5] <<24)|(buf[6] <<16)|(buf[7] <<8)|(buf[8]);
+		rx_length =(buf[1]<<24)|(buf[2] <<16)|(buf[3] <<8)|(buf[4]);
+		if (rx_addr == rx_length) {
+			usb3_bulk_out_transfer_cmd(pcd);
+			usb_connected = 1;
+			usb_out_open = 1;
+		} else {
+			usb3_bulk_out_transfer_data(pcd);
+		}
+		usb3_bulk_in_transfer(dev, uACK);
+		return;
+
+	} else if(buf[0]==UCMD) {
+		strcat(tx_state, " ");
+
+#if 0
+		usb_out_open = 0;
+		puts ((const char *)(buf+3) ? (const char *)(buf+3) : "NULL");
+		puts ("\n");
+#endif
+		usb_out_open = 1;
+		ret = run_command(buf+3,0);
+		if (ret) {
+			usb3_bulk_in_transfer(dev, "[EOT](ERROR)\r\n");
+		} else {
+			strcat(tx_state, "[EOT](OK)\r\n");
+			usb3_bulk_out_transfer_cmd(pcd);
+			usb3_bulk_in_transfer(dev, tx_state);
+			memset(tx_state, 0, 200);
+		}
+	} else if (buf[0]==UTAIL) {
+		if(rx_length>0) {
+			usb3_bulk_out_transfer_cmd(pcd);
+			usb3_bulk_in_transfer(dev, uNAK);
+		} else {
+			usb3_bulk_in_transfer(dev, uACK);
+			usb3_bulk_out_transfer_cmd(pcd);
+		}
+	} else if (buf[0]==UREQ) {
+		usb_out_open = 0;
+		if (handle_request != NULL) {
+			usb3_pcd_ep_t *ep = &pcd->in_ep;
+			usb3_pcd_req_t *req = &ep->req;
+
+			memset(req->bufdma, 0, 512);
+			req->length = 0;
+			ret = (*handle_request)(req->bufdma, &req->length);
+
+			/* req->actual = 0; */
+			extern void usb_tx_status_complete(void *dev);
+			req->complete = usb_tx_status_complete;
+			usb3_ep_start_transfer(pcd, ep);
+
+			usb3_bulk_out_transfer_cmd(pcd);
+		}
+	}
+}
diff -uraN u-boot-2016.11/drivers/usb/gadget/udc3/usb3_prot.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/usb3_prot.h
--- u-boot-2016.11/drivers/usb/gadget/udc3/usb3_prot.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/gadget/udc3/usb3_prot.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,45 @@
+#ifndef __USB3_PROT_H__
+#define __USB3_PROT_H__
+
+
+/* FILE FRAME: TYPE(1)+SEQ(1)+CSEQ(1)+FILE(1)+LENGTH(4)+ADDRESS(4)+CRC(2) */
+/* DATA FRAME: TYPE(1)+SEQ(1)+CSEQ(1)+DATA(0~1024)+CRC(2) */
+/* EOT  FRAME: TYPE(1)+SEQ(1)+CSEQ(1)+CRC(2) */
+#define	FRAME_HEAD			0
+#define	FRAME_SEQ			1
+#define	FRAME_CSEQ			2
+#define	FRAME_TYPE			3
+#define	FRAME_DATA_START		3
+#define	FRAME_LENGTH			4
+#define	FRAME_ADDRESS			8
+
+#define	FRAME_FILE			0xFE
+#define	FRAME_DATA			0xDA
+#define	FRAME_EOT			0xED
+#define FRAME_INQUIRE			0xCD
+
+#define	USB3_RESPONSE_ACK		0xAA
+#define	USB3_RESPONSE_NAK		0x55
+
+#define FRAME_FILE_LEN			14
+#define FRAME_EOT_LEN			5
+
+#define FRAME_HEAD_LEN			5
+#define FRAME_DATA_LEN			1024
+
+#define	FILE_RAMINIT			1
+#define	FILE_USB			2
+
+#define	USB3_XFR_PROT_OK		0
+#define	USB3_XFR_PROT_ERR		1
+#define	USB3_XFR_PROT_SKIP		2
+#define	USB3_XFR_PROT_COMPLETE		3
+#define USB3_XFR_PROT_INPROGRESS	4
+#define USB3_XFR_PROT_WAIT		0x05
+#define USB3_XFR_PROT_INQUIRE		0x06
+#define USB3_XFR_PROT_ADDR_ERROR	0x07
+
+
+void usb3_handle_protocol(void *dev);
+
+#endif /* __USB3_PROT_H__ */
diff -uraN u-boot-2016.11/drivers/usb/host/xhci.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/host/xhci.c
--- u-boot-2016.11/drivers/usb/host/xhci.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/host/xhci.c	2021-06-07 13:01:32.000000000 +0300
@@ -30,6 +30,7 @@
 #include <asm/unaligned.h>
 #include <linux/errno.h>
 #include "xhci.h"
+#include "../drivers/phy/goke/usb.h"
 
 #ifndef CONFIG_USB_MAX_CONTROLLER_COUNT
 #define CONFIG_USB_MAX_CONTROLLER_COUNT 1
@@ -257,6 +258,172 @@
 	return index;
 }
 
+/*
+ * Convert bInterval expressed in microframes (in 1-255 range) to exponent of
+ * microframes, rounded down to nearest power of 2.
+ */
+static unsigned int xhci_microframes_to_exponent(unsigned int desc_interval,
+						 unsigned int min_exponent,
+						 unsigned int max_exponent)
+{
+	unsigned int interval;
+
+	interval = fls(desc_interval) - 1;
+	interval = clamp_val(interval, min_exponent, max_exponent);
+	if ((1 << interval) != desc_interval)
+		debug("rounding interval to %d microframes, "\
+		      "ep desc says %d microframes\n",
+		      1 << interval, desc_interval);
+
+	return interval;
+}
+
+static unsigned int xhci_parse_microframe_interval(struct usb_device *udev,
+	struct usb_endpoint_descriptor *endpt_desc)
+{
+	if (endpt_desc->bInterval == 0)
+		return 0;
+
+	return xhci_microframes_to_exponent(endpt_desc->bInterval, 0, 15);
+}
+
+static unsigned int xhci_parse_frame_interval(struct usb_device *udev,
+	struct usb_endpoint_descriptor *endpt_desc)
+{
+	return xhci_microframes_to_exponent(endpt_desc->bInterval * 8, 3, 10);
+}
+
+/*
+ * Convert interval expressed as 2^(bInterval - 1) == interval into
+ * straight exponent value 2^n == interval.
+ */
+static unsigned int xhci_parse_exponent_interval(struct usb_device *udev,
+	struct usb_endpoint_descriptor *endpt_desc)
+{
+	unsigned int interval;
+
+	interval = clamp_val(endpt_desc->bInterval, 1, 16) - 1;
+	if (interval != endpt_desc->bInterval - 1)
+		debug("ep %#x - rounding interval to %d %sframes\n",
+		      endpt_desc->bEndpointAddress, 1 << interval,
+		      udev->speed == USB_SPEED_FULL ? "" : "micro");
+
+	if (udev->speed == USB_SPEED_FULL) {
+		/*
+		 * Full speed isoc endpoints specify interval in frames,
+		 * not microframes. We are using microframes everywhere,
+		 * so adjust accordingly.
+		 */
+		interval += 3;	/* 1 frame = 2^3 uframes */
+	}
+
+	return interval;
+}
+
+/*
+ * Return the polling or NAK interval.
+ *
+ * The polling interval is expressed in "microframes". If xHCI's Interval field
+ * is set to N, it will service the endpoint every 2^(Interval)*125us.
+ *
+ * The NAK interval is one NAK per 1 to 255 microframes, or no NAKs if interval
+ * is set to 0.
+ */
+static unsigned int xhci_get_endpoint_interval(struct usb_device *udev,
+	struct usb_endpoint_descriptor *endpt_desc)
+{
+	unsigned int interval = 0;
+
+	switch (udev->speed) {
+	case USB_SPEED_HIGH:
+		/* Max NAK rate */
+		if (usb_endpoint_xfer_control(endpt_desc) ||
+		    usb_endpoint_xfer_bulk(endpt_desc)) {
+			interval = xhci_parse_microframe_interval(udev,
+								  endpt_desc);
+			break;
+		}
+		/* Fall through - SS and HS isoc/int have same decoding */
+
+	case USB_SPEED_SUPER:
+		if (usb_endpoint_xfer_int(endpt_desc) ||
+		    usb_endpoint_xfer_isoc(endpt_desc)) {
+			interval = xhci_parse_exponent_interval(udev,
+								endpt_desc);
+		}
+		break;
+
+	case USB_SPEED_FULL:
+		if (usb_endpoint_xfer_isoc(endpt_desc)) {
+			interval = xhci_parse_exponent_interval(udev,
+								endpt_desc);
+			break;
+		}
+		/*
+		 * Fall through for interrupt endpoint interval decoding
+		 * since it uses the same rules as low speed interrupt
+		 * endpoints.
+		 */
+
+	case USB_SPEED_LOW:
+		if (usb_endpoint_xfer_int(endpt_desc) ||
+		    usb_endpoint_xfer_isoc(endpt_desc)) {
+			interval = xhci_parse_frame_interval(udev, endpt_desc);
+		}
+		break;
+
+	default:
+		BUG();
+	}
+
+	return interval;
+}
+
+/*
+ * The "Mult" field in the endpoint context is only set for SuperSpeed isoc eps.
+ * High speed endpoint descriptors can define "the number of additional
+ * transaction opportunities per microframe", but that goes in the Max Burst
+ * endpoint context field.
+ */
+static u32 xhci_get_endpoint_mult(struct usb_device *udev,
+	struct usb_endpoint_descriptor *endpt_desc,
+	struct usb_ss_ep_comp_descriptor *ss_ep_comp_desc)
+{
+	if (udev->speed < USB_SPEED_SUPER ||
+	    !usb_endpoint_xfer_isoc(endpt_desc))
+		return 0;
+
+	return ss_ep_comp_desc->bmAttributes;
+}
+
+/*
+ * Return the maximum endpoint service interval time (ESIT) payload.
+ * Basically, this is the maxpacket size, multiplied by the burst size
+ * and mult size.
+ */
+static u32 xhci_get_max_esit_payload(struct usb_device *udev,
+	struct usb_endpoint_descriptor *endpt_desc,
+	struct usb_ss_ep_comp_descriptor *ss_ep_comp_desc)
+{
+	int max_burst;
+	int max_packet;
+
+	/* Only applies for interrupt or isochronous endpoints */
+	if (usb_endpoint_xfer_control(endpt_desc) ||
+	    usb_endpoint_xfer_bulk(endpt_desc))
+		return 0;
+
+	/* SuperSpeed Isoc ep with less than 48k per esit */
+	if (udev->speed >= USB_SPEED_SUPER)
+		return le16_to_cpu(ss_ep_comp_desc->wBytesPerInterval);
+
+	max_packet = usb_endpoint_maxp(endpt_desc);
+	max_burst = usb_endpoint_maxp_mult(endpt_desc);
+
+	/* A 0 in max burst means 1 transfer per ESIT */
+	return max_packet * max_burst;
+}
+
 /**
  * Issue a configure endpoint command or evaluate context command
  * and wait for it to finish.
@@ -324,6 +491,10 @@
 	int slot_id = udev->slot_id;
 	struct xhci_virt_device *virt_dev = ctrl->devs[slot_id];
 	struct usb_interface *ifdesc;
+	u32 max_esit_payload;
+	unsigned int interval;
+	unsigned int mult;
+	unsigned int avg_trb_len;
 
 	out_ctx = virt_dev->out_ctx;
 	in_ctx = virt_dev->in_ctx;
@@ -350,17 +521,33 @@
 	xhci_slot_copy(ctrl, in_ctx, out_ctx);
 	slot_ctx = xhci_get_slot_ctx(ctrl, in_ctx);
 	slot_ctx->dev_info &= ~(LAST_CTX_MASK);
-	slot_ctx->dev_info |= cpu_to_le32(LAST_CTX(max_ep_flag + 1) | 0);
+	slot_ctx->dev_info |= cpu_to_le32(LAST_CTX((unsigned int)max_ep_flag + 1) | 0);
 
 	xhci_endpoint_copy(ctrl, in_ctx, out_ctx, 0);
 
 	/* filling up ep contexts */
 	for (cur_ep = 0; cur_ep < num_of_ep; cur_ep++) {
 		struct usb_endpoint_descriptor *endpt_desc = NULL;
+		struct usb_ss_ep_comp_descriptor *ss_ep_comp_desc = NULL;
 
 		endpt_desc = &ifdesc->ep_desc[cur_ep];
+		ss_ep_comp_desc = &ifdesc->ss_ep_comp_desc[cur_ep];
 		trb_64 = 0;
 
+		/*
+		 * Get values to fill the endpoint context, mostly from ep
+		 * descriptor. The average TRB buffer lengt for bulk endpoints
+		 * is unclear as we have no clue on scatter gather list entry
+		 * size. For Isoc and Int, set it to max available.
+		 * See xHCI 1.1 spec 4.14.1.1 for details.
+		 */
+		max_esit_payload = xhci_get_max_esit_payload(udev, endpt_desc,
+							     ss_ep_comp_desc);
+		interval = xhci_get_endpoint_interval(udev, endpt_desc);
+		mult = xhci_get_endpoint_mult(udev, endpt_desc,
+					      ss_ep_comp_desc);
+		avg_trb_len = max_esit_payload;
+
 		ep_index = xhci_get_ep_index(endpt_desc);
 		ep_ctx[ep_index] = xhci_get_ep_ctx(ctrl, in_ctx, ep_index);
 
@@ -372,6 +559,11 @@
 		/*NOTE: ep_desc[0] actually represents EP1 and so on */
 		dir = (((endpt_desc->bEndpointAddress) & (0x80)) >> 7);
 		ep_type = (((endpt_desc->bmAttributes) & (0x3)) | (dir << 2));
+
+		ep_ctx[ep_index]->ep_info =
+			cpu_to_le32(EP_MAX_ESIT_PAYLOAD_HI(max_esit_payload) |
+			EP_INTERVAL(interval) | EP_MULT(mult));
+
 		ep_ctx[ep_index]->ep_info2 =
 			cpu_to_le32(ep_type << EP_TYPE_SHIFT);
 		ep_ctx[ep_index]->ep_info2 |=
@@ -386,6 +578,10 @@
 				virt_dev->eps[ep_index].ring->enqueue;
 		ep_ctx[ep_index]->deq = cpu_to_le64(trb_64 |
 				virt_dev->eps[ep_index].ring->cycle_state);
+
+		ep_ctx[ep_index]->tx_info =
+			cpu_to_le32(EP_MAX_ESIT_PAYLOAD_LO(max_esit_payload) |
+			EP_AVG_TRB_LENGTH(avg_trb_len));
 	}
 
 	return xhci_configure_endpoints(udev, false);
@@ -547,16 +743,13 @@
 	int max_packet_size;
 	int hw_max_packet_size;
 	int ret = 0;
-	struct usb_interface *ifdesc;
-
-	ifdesc = &udev->config.if_desc[0];
 
 	out_ctx = ctrl->devs[slot_id]->out_ctx;
 	xhci_inval_cache((uintptr_t)out_ctx->bytes, out_ctx->size);
 
 	ep_ctx = xhci_get_ep_ctx(ctrl, out_ctx, ep_index);
 	hw_max_packet_size = MAX_PACKET_DECODED(le32_to_cpu(ep_ctx->ep_info2));
-	max_packet_size = usb_endpoint_maxp(&ifdesc->ep_desc[0]);
+	max_packet_size = udev->descriptor.bMaxPacketSize0;
 	if (hw_max_packet_size != max_packet_size) {
 		debug("Max Packet Size for ep 0 changed.\n");
 		debug("Max packet size in usb_device = %d\n", max_packet_size);
@@ -568,7 +761,8 @@
 				ctrl->devs[slot_id]->out_ctx, ep_index);
 		in_ctx = ctrl->devs[slot_id]->in_ctx;
 		ep_ctx = xhci_get_ep_ctx(ctrl, in_ctx, ep_index);
-		ep_ctx->ep_info2 &= cpu_to_le32(~MAX_PACKET_MASK);
+		ep_ctx->ep_info2 &= cpu_to_le32(~(MAX_PACKET_MASK <<
+					MAX_PACKET_SHIFT));
 		ep_ctx->ep_info2 |= cpu_to_le32(MAX_PACKET(max_packet_size));
 
 		/*
@@ -1068,6 +1262,8 @@
 
 	*controller = NULL;
 
+	phy_usb_init(index);
+
 	if (xhci_hcd_init(index, &hccr, (struct xhci_hcor **)&hcor) != 0)
 		return -ENODEV;
 
diff -uraN u-boot-2016.11/drivers/usb/host/xhci.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/host/xhci.h
--- u-boot-2016.11/drivers/usb/host/xhci.h	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/host/xhci.h	2021-06-07 13:01:32.000000000 +0300
@@ -23,12 +23,14 @@
 #include <linux/list.h>
 #include <linux/compat.h>
 
+#include <usb.h>
+
 #define MAX_EP_CTX_NUM		31
 #define XHCI_ALIGNMENT		64
 /* Generic timeout for XHCI events */
 #define XHCI_TIMEOUT		5000
 /* Max number of USB devices for any host controller - limit in section 6.1 */
-#define MAX_HC_SLOTS            256
+#define MAX_HC_SLOTS            16
 /* Section 5.3.3 - MaxPorts */
 #define MAX_HC_PORTS            127
 
@@ -665,8 +667,9 @@
 #define GET_MAX_PACKET(p)	((p) & 0x7ff)
 
 /* tx_info bitmasks */
-#define AVG_TRB_LENGTH_FOR_EP(p)	((p) & 0xffff)
-#define MAX_ESIT_PAYLOAD_FOR_EP(p)	(((p) & 0xffff) << 16)
+#define EP_AVG_TRB_LENGTH(p)		((p) & 0xffff)
+#define EP_MAX_ESIT_PAYLOAD_LO(p)	(((p) & 0xffff) << 16)
+#define EP_MAX_ESIT_PAYLOAD_HI(p)	((((p) >> 16) & 0xff) << 24)
 #define CTX_TO_MAX_ESIT_PAYLOAD(p)	(((p) >> 16) & 0xffff)
 
 /* deq bitmasks */
diff -uraN u-boot-2016.11/drivers/usb/host/xhci-ring.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/host/xhci-ring.c
--- u-boot-2016.11/drivers/usb/host/xhci-ring.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/drivers/usb/host/xhci-ring.c	2021-06-07 13:01:32.000000000 +0300
@@ -337,7 +337,7 @@
 
 	if ((total_packet_count - packets_transferred) > 31)
 		return 31 << 17;
-	return (total_packet_count - packets_transferred) << 17;
+	return (total_packet_count - (unsigned int)packets_transferred) << 17;
 }
 
 /**
diff -uraN u-boot-2016.11/dts/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/dts/.gitignore
--- u-boot-2016.11/dts/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/dts/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1,2 +0,0 @@
-*.dtb
-*.dtb.S
diff -uraN u-boot-2016.11/examples/api/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/examples/api/.gitignore
--- u-boot-2016.11/examples/api/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/examples/api/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1,2 +0,0 @@
-demo
-demo.bin
diff -uraN u-boot-2016.11/examples/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/examples/Makefile
--- u-boot-2016.11/examples/Makefile	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/examples/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -7,7 +7,8 @@
 ifdef FTRACE
 subdir-ccflags-y += -finstrument-functions -DFTRACE
 endif
-
+ifndef CONFIG_GK_MC
 subdir-y += standalone
+endif
 subdir-$(CONFIG_API) += api
 endif
diff -uraN u-boot-2016.11/examples/standalone/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/examples/standalone/.gitignore
--- u-boot-2016.11/examples/standalone/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/examples/standalone/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1,11 +0,0 @@
-/atmel_df_pow2
-/hello_world
-/interrupt
-/mem_to_mem_idma2intr
-/sched
-/smc91111_eeprom
-/smc911x_eeprom
-/test_burst
-/timer
-*.bin
-*.srec
diff -uraN u-boot-2016.11/examples/standalone/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/examples/standalone/Makefile
--- u-boot-2016.11/examples/standalone/Makefile	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/examples/standalone/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -23,14 +23,14 @@
 
 extra-y += $(addsuffix .srec,$(extra-y)) $(addsuffix .bin,$(extra-y))
 clean-files  := *.srec *.bin
-
+ifndef CONFIG_GK_MC
 COBJS	:= $(ELF:=.o)
-
 LIB	= $(obj)/libstubs.o
+LIBOBJS-y += stubs.o
+endif
 
 LIBOBJS-$(CONFIG_PPC) += ppc_longjmp.o ppc_setjmp.o
 LIBOBJS-$(CONFIG_8xx) += test_burst_lib.o
-LIBOBJS-y += stubs.o
 
 .SECONDARY: $(call objectify,$(COBJS))
 targets += $(patsubst $(obj)/%,%,$(LIB)) $(COBJS) $(LIBOBJS-y)
diff -uraN u-boot-2016.11/fs/ext4/ext4_common.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/fs/ext4/ext4_common.c
--- u-boot-2016.11/fs/ext4/ext4_common.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/fs/ext4/ext4_common.c	2021-06-07 13:01:32.000000000 +0300
@@ -1572,7 +1572,7 @@
 
 int ext4fs_read_inode(struct ext2_data *data, int ino, struct ext2_inode *inode)
 {
-	struct ext2_block_group blkgrp;
+	struct ext2_block_group *blkgrp;
 	struct ext2_sblock *sblock = &data->sblock;
 	struct ext_filesystem *fs = get_fs();
 	int log2blksz = get_fs()->dev_desc->log2blksz;
@@ -1580,17 +1580,28 @@
 	long int blkno;
 	unsigned int blkoff;
 
+	/* Allocate blkgrp based on gdsize (for 64-bit support). */
+	blkgrp = zalloc(get_fs()->gdsize);
+	if (!blkgrp)
+		return 0;
+
 	/* It is easier to calculate if the first inode is 0. */
 	ino--;
 	status = ext4fs_blockgroup(data, ino / le32_to_cpu
-				   (sblock->inodes_per_group), &blkgrp);
-	if (status == 0)
+				   (sblock->inodes_per_group), blkgrp);
+	if (status == 0) {
+		free(blkgrp);
 		return 0;
+	}
 
 	inodes_per_block = EXT2_BLOCK_SIZE(data) / fs->inodesz;
-	blkno = ext4fs_bg_get_inode_table_id(&blkgrp, fs) +
+	blkno = ext4fs_bg_get_inode_table_id(blkgrp, fs) +
 	    (ino % le32_to_cpu(sblock->inodes_per_group)) / inodes_per_block;
 	blkoff = (ino % inodes_per_block) * fs->inodesz;
+
+	/* Free blkgrp as it is no longer required. */
+	free(blkgrp);
+
 	/* Read the inode. */
 	status = ext4fs_devread((lbaint_t)blkno << (LOG2_BLOCK_SIZE(data) -
 				log2blksz), blkoff,
diff -uraN u-boot-2016.11/fs/ext4/ext4fs.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/fs/ext4/ext4fs.c
--- u-boot-2016.11/fs/ext4/ext4fs.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/fs/ext4/ext4fs.c	2021-06-07 13:01:32.000000000 +0300
@@ -62,6 +62,7 @@
 	lbaint_t delayed_skipfirst = 0;
 	lbaint_t delayed_next = 0;
 	char *delayed_buf = NULL;
+	char *start_buf = buf;
 	short status;
 
 	/* Adjust len so it we can't read past the end of the file. */
@@ -127,6 +128,8 @@
 					(blockend >> log2blksz);
 			}
 		} else {
+			int n;
+			int n_left;
 			if (previous_block_number != -1) {
 				/* spill */
 				status = ext4fs_devread(delayed_start,
@@ -137,7 +140,12 @@
 					return -1;
 				previous_block_number = -1;
 			}
-			memset(buf, 0, blocksize - skipfirst);
+			/* Zero no more than `len' bytes. */
+			n = blocksize - skipfirst;
+			n_left = len - ( buf - start_buf );
+			if (n > n_left)
+				n = n_left;
+			memset(buf, 0, n);
 		}
 		buf += blocksize - skipfirst;
 	}
diff -uraN u-boot-2016.11/fs/ext4/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/fs/ext4/Makefile
--- u-boot-2016.11/fs/ext4/Makefile	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/fs/ext4/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -11,3 +11,4 @@
 
 obj-y := ext4fs.o ext4_common.o dev.o
 obj-$(CONFIG_EXT4_WRITE) += ext4_write.o ext4_journal.o crc16.o
+obj-$(CONFIG_EXT4_SPARSE) += unsparse.o
diff -uraN u-boot-2016.11/fs/ext4/unsparse.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/fs/ext4/unsparse.c
--- u-boot-2016.11/fs/ext4/unsparse.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/fs/ext4/unsparse.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,360 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+ 
+#include <common.h>
+#include <command.h>
+#include <div64.h>
+#include <mmc.h>
+#include <image-sparse.h>
+
+/******************************************************************************/
+#ifdef CONFIG_CMD_UFS
+#include <ufs.h>
+#define UFS_BLKSIZE_SHIFT  (12)
+#endif
+
+#define EMMC_BLKSIZE_SHIFT           (9)
+#define SZ_1M_SHIFT                  (20)
+
+/* #define DEBUG_EXT4 */
+
+/******************************************************************************/
+void print_header_info(sparse_header_t *header)
+{
+#ifdef DEBUG_EXT4
+	printf("sparse header info:\n");
+	printf("magic: 0x%x\n", header->magic);
+	printf("major_version: 0x%x\n", header->major_version);
+	printf("minor_version: 0x%x\n", header->minor_version);
+	printf("file_hdr_sz: %d\n", header->file_hdr_sz);
+	printf("chunk_hdr_sz: %d\n", header->chunk_hdr_sz);
+	printf("blk_sz: %d\n", header->blk_sz);
+	printf("total_blks: %d\n", header->total_blks);
+	printf("total_chunks: %d\n", header->total_chunks);
+	printf("image_checksum: %d\n", header->image_checksum);
+#endif
+}
+
+/******************************************************************************/
+void print_chunk_info(chunk_header_t *chunk)
+{
+#ifdef DEBUG_EXT4
+	printf("chunk header info:\n");
+	printf("chunk_type: 0x%x\n", chunk->chunk_type);
+	printf("chunk_sz: 0x%d\n", chunk->chunk_sz);
+	printf("total_sz: 0x%d\n", chunk->total_sz);
+#endif
+}
+
+int get_unspare_header_info(const u8 *pbuf,sparse_header_t *sparse_header)
+{
+	sparse_header_t *header = NULL;
+	header = memcpy(sparse_header, pbuf,sizeof(sparse_header_t));
+
+	if (!is_sparse_image(sparse_header)) {
+		printf("Invalid sparse format.\n");
+		return 1;
+	}
+	print_header_info(header);
+	return 0;
+
+}
+
+/******************************************************************************/
+int ext4_unsparse(struct mmc *mmc, u32 dev, u8 *pbuf, u32 blk, u32 cnt)
+{
+	u32 i, num;
+	u64 dense_len = 0;
+	u64 sparse_len = 0;
+	u64 img_size;
+	u32 chunk_len;
+	s32 percent_complete = -1;
+	chunk_header_t *chunk = NULL;
+	sparse_header_t *header = (sparse_header_t *)pbuf;
+
+	if (!is_sparse_image(header)) {
+		printf("Invalid sparse format.\n");
+		return 1;
+	}
+
+	/* check header->blk_sz align to emmc block size */
+	if (header->blk_sz & ((1 << EMMC_BLKSIZE_SHIFT) - 1)) {
+		printf("image blk size %d is not aligned to 512Byte.\n",
+		       header->blk_sz);
+		return 1;
+	}
+
+	/* check fs img's real size is larger than partition size */
+	img_size = (u64)(header->total_blks * header->blk_sz);
+	if ((img_size >> EMMC_BLKSIZE_SHIFT) > (u64)cnt) {
+		printf("partition size %d MB not enough.\n",
+		       (int)(cnt >> (SZ_1M_SHIFT - EMMC_BLKSIZE_SHIFT)));
+		print_header_info(header);
+		return 1;
+	}
+
+	/* skip the sparse header,to visit first chunk */
+	pbuf += header->file_hdr_sz;
+
+	/* to visit each chunk */
+	for (i = 0; i < header->total_chunks; i++) {
+
+		/* here the chunk_header */
+		chunk = (chunk_header_t *)pbuf;
+
+		/* go to next chunk's data */
+		pbuf += header->chunk_hdr_sz;
+
+		switch (chunk->chunk_type) {
+		case CHUNK_TYPE_RAW:
+
+			/* to calculate the length of each chunk */
+			chunk_len = chunk->chunk_sz * header->blk_sz;
+
+			/* verify every chunk to asure it is valid */
+			if (chunk->total_sz
+			    != (chunk_len + header->chunk_hdr_sz)) {
+				printf("No.%d chunk size error.\n", i);
+				print_chunk_info(chunk);
+				return 1;
+			}
+
+			dense_len += chunk_len;
+			sparse_len += chunk_len;
+
+			if (sparse_len > ((u64)cnt << EMMC_BLKSIZE_SHIFT)) {
+				printf("error: sparse size %d MB is "
+				       "larger than partiton size %d MB.\n",
+				       (int)(sparse_len >> SZ_1M_SHIFT),
+				       (int)(cnt >> (SZ_1M_SHIFT
+						     - EMMC_BLKSIZE_SHIFT)));
+				print_chunk_info(chunk);
+				return 1;
+			}
+
+			num = blk_dwrite(mmc_get_blk_desc(mmc), blk,
+					 (chunk_len >> EMMC_BLKSIZE_SHIFT), pbuf);
+			if (num != (chunk_len >> EMMC_BLKSIZE_SHIFT)) {
+				printf("Raw data: No.%d blocks written: %s.\n",
+				       num, "ERROR");
+				return 1;
+			}
+
+			pbuf += chunk_len;
+			blk  += (chunk_len >> EMMC_BLKSIZE_SHIFT);
+			break;
+
+		case CHUNK_TYPE_DONT_CARE:
+			if (chunk->total_sz != header->chunk_hdr_sz) {
+				printf("No.%d chunk size error.\n", i);
+				print_chunk_info(chunk);
+				return 1;
+			}
+
+			chunk_len = chunk->chunk_sz * header->blk_sz;
+			sparse_len += chunk_len;
+
+			if (sparse_len > ((u64)cnt << EMMC_BLKSIZE_SHIFT)) {
+				printf("error: sparse size %d MB is "
+				       "larger than partiton size %d MB.\n",
+				       (int)(sparse_len >> SZ_1M_SHIFT),
+				       (int)(cnt >> (SZ_1M_SHIFT
+						     - EMMC_BLKSIZE_SHIFT)));
+				print_chunk_info(chunk);
+				return 1;
+			}
+
+			blk  += (chunk_len >> EMMC_BLKSIZE_SHIFT);
+			break;
+
+		default:
+			printf("sparse: unknow chunk type %04x.\n",
+			       chunk->chunk_type);
+			return 1;
+		}
+
+		{
+			u64 n = (u64)(sparse_len >> EMMC_BLKSIZE_SHIFT) * 100;
+			int percent;
+			do_div(n, cnt);
+			percent = (int)n;
+
+			if (percent != percent_complete) {
+				percent_complete = percent;
+				printf("\rWriting at %d blk# "
+				       "-- %3d%% complete.",
+				       (int)(blk
+					     + (sparse_len >> EMMC_BLKSIZE_SHIFT)),
+				       percent);
+			}
+		}
+
+	}
+	puts("\n");
+
+	if (((u64)cnt << EMMC_BLKSIZE_SHIFT) != sparse_len) {
+		printf("error: partition size %d MB != ext4 image size %d MB\n",
+		       (int)(cnt >> (SZ_1M_SHIFT - EMMC_BLKSIZE_SHIFT)),
+		       (int)(sparse_len >> SZ_1M_SHIFT));
+		return 1;
+	}
+
+	printf("sparse: %d MB / %d MB.\n", (int)(dense_len >> SZ_1M_SHIFT),
+	       (int)(sparse_len >> SZ_1M_SHIFT));
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_UFS
+/******************************************************************************/
+int ufs_ext4_unsparse(const u8 *pbuf, u32 blk, u32 cnt)
+{
+	u32 i, num;
+	u64 dense_len = 0;
+	u64 sparse_len = 0;
+	u64 img_size;
+	u32 chunk_len;
+	s32 percent_complete = -1;
+	chunk_header_t *chunk = NULL;
+	sparse_header_t *header = (sparse_header_t *)pbuf;
+
+	if (!is_sparse_image(header)) {
+		printf("Invalid sparse format.\n");
+		return 1;
+	}
+
+	/* check header->blk_sz align to emmc block size */
+	if (header->blk_sz & ((1 << UFS_BLKSIZE_SHIFT) - 1)) {
+		printf("image blk size %d is not aligned to 512Byte.\n",
+		       header->blk_sz);
+		return 1;
+	}
+
+	/* check fs img's real size is larger than partition size */
+	img_size = (u64)(header->total_blks * header->blk_sz);
+	if ((img_size >> UFS_BLKSIZE_SHIFT) > (u64)cnt) {
+		printf("partition size %d MB not enough.\n",
+		       (int)(cnt >> (SZ_1M_SHIFT - UFS_BLKSIZE_SHIFT)));
+		print_header_info(header);
+		return 1;
+	}
+
+	/* skip the sparse header,to visit first chunk */
+	pbuf += header->file_hdr_sz;
+
+	/* to visit each chunk */
+	for (i = 0; i < header->total_chunks; i++) {
+
+		/* here the chunk_header */
+		chunk = (chunk_header_t *)pbuf;
+
+		/* go to next chunk's data */
+		pbuf += header->chunk_hdr_sz;
+
+		switch (chunk->chunk_type) {
+		case CHUNK_TYPE_RAW:
+
+			/* to calculate the length of each chunk */
+			chunk_len = chunk->chunk_sz * header->blk_sz;
+
+			/* verify every chunk to asure it is valid */
+			if (chunk->total_sz
+			    != (chunk_len + header->chunk_hdr_sz)) {
+				printf("No.%d chunk size error.\n", i);
+				print_chunk_info(chunk);
+				return 1;
+			}
+
+			dense_len += chunk_len;
+			sparse_len += chunk_len;
+
+			if (sparse_len > ((u64)cnt << UFS_BLKSIZE_SHIFT)) {
+				printf("error: sparse size %d MB is "
+				       "larger than partiton size %d MB.\n",
+				       (int)(sparse_len >> SZ_1M_SHIFT),
+				       (int)(cnt >> (SZ_1M_SHIFT
+						     - UFS_BLKSIZE_SHIFT)));
+				print_chunk_info(chunk);
+				return 1;
+			}
+
+			if (ufs_write_storage((uint64_t)pbuf,
+					      (blk << UFS_BLKSIZE_SHIFT),
+					      chunk_len) == 0)
+				num = chunk_len >> UFS_BLKSIZE_SHIFT;
+			else
+				num = 0;
+
+			if (num != (chunk_len >> UFS_BLKSIZE_SHIFT)) {
+				printf("Raw data: No.%d blocks written: %s.\n",
+				       num, "ERROR");
+				return 1;
+			}
+
+			pbuf += chunk_len;
+			blk  += (chunk_len >> UFS_BLKSIZE_SHIFT);
+			break;
+
+		case CHUNK_TYPE_DONT_CARE:
+			if (chunk->total_sz != header->chunk_hdr_sz) {
+				printf("No.%d chunk size error.\n", i);
+				print_chunk_info(chunk);
+				return 1;
+			}
+
+			chunk_len = chunk->chunk_sz * header->blk_sz;
+			sparse_len += chunk_len;
+
+			if (sparse_len > ((u64)cnt << UFS_BLKSIZE_SHIFT)) {
+				printf("error: sparse size %d MB is "
+				       "larger than partiton size %d MB.\n",
+				       (int)(sparse_len >> SZ_1M_SHIFT),
+				       (int)(cnt >> (SZ_1M_SHIFT
+						     - UFS_BLKSIZE_SHIFT)));
+				print_chunk_info(chunk);
+				return 1;
+			}
+
+			blk  += (chunk_len >> UFS_BLKSIZE_SHIFT);
+			break;
+
+		default:
+			printf("sparse: unknown chunk type %04x.\n",
+			       chunk->chunk_type);
+			return 1;
+		}
+
+		{
+			u64 n = (u64)(sparse_len >> UFS_BLKSIZE_SHIFT) * 100;
+			int percent;
+
+			do_div(n, cnt);
+			percent = (int)n;
+
+			if (percent != percent_complete) {
+				percent_complete = percent;
+				printf("\rWriting at %d blk# "
+				       "-- %3d%% complete.",
+				       (int)(blk
+					     + (sparse_len >> UFS_BLKSIZE_SHIFT)),
+				       percent);
+			}
+		}
+
+	}
+	puts("\n");
+
+	if (((u64)cnt << UFS_BLKSIZE_SHIFT) != sparse_len) {
+		printf("error: partition size %d MB != ext4 image size %d MB\n",
+		       (int)(cnt >> (SZ_1M_SHIFT - UFS_BLKSIZE_SHIFT)),
+		       (int)(sparse_len >> SZ_1M_SHIFT));
+		return 1;
+	}
+
+	printf("sparse: %d MB / %d MB.\n", (int)(dense_len >> SZ_1M_SHIFT),
+	       (int)(sparse_len >> SZ_1M_SHIFT));
+
+	return 0;
+}
+#endif
diff -uraN u-boot-2016.11/fs/ext4/unsparse.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/fs/ext4/unsparse.h
--- u-boot-2016.11/fs/ext4/unsparse.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/fs/ext4/unsparse.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,12 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+ 
+#ifndef __UNSPARSE__
+#define __UNSPARSE__
+
+int get_unspare_header_info(const u8 *pbuf,sparse_header_t *sparse_header);
+void print_chunk_info(chunk_header_t *chunk);
+int ext4_unsparse(struct mmc *mmc, u32 dev, u8 *pbuf,u32 blk, u32 cnt);
+void print_header_info(sparse_header_t *header);
+#endif
diff -uraN u-boot-2016.11/fs/fat/fat.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/fs/fat/fat.c
--- u-boot-2016.11/fs/fat/fat.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/fs/fat/fat.c	2021-06-07 13:01:32.000000000 +0300
@@ -98,7 +98,7 @@
 
 	/* Read the partition table, if present */
 	if (part_get_info(dev_desc, part_no, &info)) {
-		if (part_no != 0) {
+		if (part_no != 1) {
 			printf("** Partition %d not valid on device %d **\n",
 					part_no, dev_desc->devnum);
 			return -1;
@@ -1327,7 +1327,6 @@
 int file_fat_read_at(const char *filename, loff_t pos, void *buffer,
 		     loff_t maxsize, loff_t *actread)
 {
-	printf("reading %s\n", filename);
 	return do_fat_read_at(filename, pos, buffer, maxsize, LS_NO, 0,
 			      actread);
 }
diff -uraN u-boot-2016.11/fs/fs.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/fs/fs.c
--- u-boot-2016.11/fs/fs.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/fs/fs.c	2021-06-07 13:01:32.000000000 +0300
@@ -291,13 +291,57 @@
 	return ret;
 }
 
-int fs_read(const char *filename, ulong addr, loff_t offset, loff_t len,
-	    loff_t *actread)
+#ifdef CONFIG_LMB
+/* Check if a file may be read to the given address */
+static int fs_read_lmb_check(const char *filename, ulong addr, loff_t offset,
+			     loff_t len, struct fstype_info *info)
+{
+	struct lmb lmb;
+	int ret;
+	loff_t size;
+	loff_t read_len;
+
+	/* get the actual size of the file */
+	ret = info->size(filename, &size);
+	if (ret)
+		return ret;
+	if (offset >= size) {
+		/* offset >= EOF, no bytes will be written */
+		return 0;
+	}
+	read_len = size - offset;
+
+	/* limit to 'len' if it is smaller */
+	if (len && len < read_len)
+		read_len = len;
+
+	lmb_init_and_reserve(&lmb, gd->bd->bi_dram[0].start,
+			     gd->bd->bi_dram[0].size, (void *)gd->fdt_blob);
+	lmb_dump_all(&lmb);
+
+	if (lmb_alloc_addr(&lmb, addr, read_len) == addr)
+		return 0;
+
+	printf("** Reading file would overwrite reserved memory **\n");
+	return -ENOSPC;
+}
+#endif
+
+static int _fs_read(const char *filename, ulong addr, loff_t offset, loff_t len,
+		    int do_lmb_check, loff_t *actread)
 {
 	struct fstype_info *info = fs_get_info(fs_type);
 	void *buf;
 	int ret;
 
+#ifdef CONFIG_LMB
+	if (do_lmb_check) {
+		ret = fs_read_lmb_check(filename, addr, offset, len, info);
+		if (ret)
+			return ret;
+	}
+#endif
+
 	/*
 	 * We don't actually know how many bytes are being read, since len==0
 	 * means read the whole file.
@@ -314,6 +358,12 @@
 	return ret;
 }
 
+int fs_read(const char *filename, ulong addr, loff_t offset, loff_t len,
+	    loff_t *actread)
+{
+	return _fs_read(filename, addr, offset, len, 0, actread);
+}
+
 int fs_write(const char *filename, ulong addr, loff_t offset, loff_t len,
 	     loff_t *actwrite)
 {
@@ -404,7 +454,7 @@
 		pos = 0;
 
 	time = get_timer(0);
-	ret = fs_read(filename, addr, pos, bytes, &len_read);
+	ret = _fs_read(filename, addr, pos, bytes, 1, &len_read);
 	time = get_timer(time);
 	if (ret < 0)
 		return 1;
diff -uraN u-boot-2016.11/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/.gitignore
--- u-boot-2016.11/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1,86 +0,0 @@
-#
-# NOTE! Don't add files that are generated in specific
-# subdirectories here. Add them in the ".gitignore" file
-# in that subdirectory instead.
-#
-# Normal rules
-#
-.*
-*.o
-*.o.*
-*.a
-*.s
-*.su
-*.mod.c
-*.i
-*.lst
-*.order
-*.elf
-*.swp
-*.bin
-*.patch
-*.cfgtmp
-
-# host programs on Cygwin
-*.exe
-
-# Build tree
-/build-*
-
-#
-# Top-level generic files
-#
-/MLO*
-/SPL
-/System.map
-/u-boot*
-/boards.cfg
-
-#
-# git files that we don't want to ignore even it they are dot-files
-#
-!.gitignore
-!.mailmap
-
-#
-# Generated files
-#
-/LOG
-/spl/
-/tpl/
-/defconfig
-
-#
-# Generated include files
-#
-/include/config/
-/include/generated/
-
-# stgit generated dirs
-patches-*
-.stgit-edit.txt
-
-# quilt's files
-patches
-series
-
-# gdb files
-.gdb_history
-
-# cscope files
-cscope.*
-
-# tags files
-/tags
-/ctags
-/etags
-
-# gnu global files
-GPATH
-GRTAGS
-GSYMS
-GTAGS
-
-*.orig
-*~
-\#*#
diff -uraN u-boot-2016.11/include/asm-generic/atomic-long.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/asm-generic/atomic-long.h
--- u-boot-2016.11/include/asm-generic/atomic-long.h	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/asm-generic/atomic-long.h	2021-06-07 13:01:32.000000000 +0300
@@ -66,6 +66,7 @@
 	atomic64_sub(i, v);
 }
 
+#ifndef __UBOOT__
 static inline int atomic_long_sub_and_test(long i, atomic_long_t *l)
 {
 	atomic64_t *v = (atomic64_t *)l;
@@ -135,6 +136,7 @@
 	(atomic64_cmpxchg((atomic64_t *)(l), (old), (new)))
 #define atomic_long_xchg(v, new) \
 	(atomic64_xchg((atomic64_t *)(v), (new)))
+#endif  /*  __UBOOT__ */
 
 #else  /*  BITS_PER_LONG == 64  */
 
diff -uraN u-boot-2016.11/include/audio_ao.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/audio_ao.h
--- u-boot-2016.11/include/audio_ao.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/audio_ao.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __AUDIO_AO_H__
+#define __AUDIO_AO_H__
+
+typedef enum AUDIO_SAMPLE_RATE_E {
+	AUDIO_SAMPLE_RATE_8000   = 8000,    /* 8K samplerate*/
+	AUDIO_SAMPLE_RATE_12000  = 12000,   /* 12K samplerate*/
+	AUDIO_SAMPLE_RATE_11025  = 11025,   /* 11.025K samplerate*/
+	AUDIO_SAMPLE_RATE_16000  = 16000,   /* 16K samplerate*/
+	AUDIO_SAMPLE_RATE_22050  = 22050,   /* 22.050K samplerate*/
+	AUDIO_SAMPLE_RATE_24000  = 24000,   /* 24K samplerate*/
+	AUDIO_SAMPLE_RATE_32000  = 32000,   /* 32K samplerate*/
+	AUDIO_SAMPLE_RATE_44100  = 44100,   /* 44.1K samplerate*/
+	AUDIO_SAMPLE_RATE_48000  = 48000,   /* 48K samplerate*/
+	AUDIO_SAMPLE_RATE_BUTT,
+} AUDIO_SAMPLE_RATE_E;
+
+#endif
+
diff -uraN u-boot-2016.11/include/common.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/common.h
--- u-boot-2016.11/include/common.h	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/common.h	2021-06-07 13:01:32.000000000 +0300
@@ -621,6 +621,7 @@
 void	serial_putc   (const char);
 void	serial_putc_raw(const char);
 void	serial_puts   (const char *);
+void	serial_puts_to_tool(const char *);
 int	serial_getc   (void);
 int	serial_tstc   (void);
 
@@ -854,7 +855,7 @@
 void srand(unsigned int seed);
 unsigned int rand(void);
 unsigned int rand_r(unsigned int *seedp);
-
+void udc_connect(void);
 /*
  * STDIO based functions (can always be used)
  */
@@ -875,6 +876,7 @@
 int	printf(const char *fmt, ...)
 		__attribute__ ((format (__printf__, 1, 2)));
 int	vprintf(const char *fmt, va_list args);
+void	print_to_tool(const char *fmt, ...);
 #else
 #define	putc(...) do { } while (0)
 #define puts(...) do { } while (0)
@@ -902,6 +904,9 @@
 int	ftstc(int file);
 int	fgetc(int file);
 
+void add_shutdown(void (*shutdown)(void));
+void do_shutdown(void);
+
 /* lib/gzip.c */
 int gzip(void *dst, unsigned long *lenp,
 		unsigned char *src, unsigned long srclen);
@@ -936,6 +941,15 @@
 int cpu_release(int nr, int argc, char * const argv[]);
 #endif
 
+#define BOOT_MEDIA_UNKNOWN        (0)
+#define BOOT_MEDIA_UFS            (1)
+#define BOOT_MEDIA_NAND           (2)
+#define BOOT_MEDIA_SPIFLASH       (3)
+#define BOOT_MEDIA_EMMC           (4)
+
+/* get uboot start media. */
+int get_boot_media(void);
+unsigned int get_ddr_size(void);
 #endif /* __ASSEMBLY__ */
 
 #ifdef CONFIG_PPC
diff -uraN u-boot-2016.11/include/config_defaults.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/config_defaults.h
--- u-boot-2016.11/include/config_defaults.h	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/config_defaults.h	2021-06-07 13:01:32.000000000 +0300
@@ -11,6 +11,8 @@
 
 /* Support bootm-ing different OSes */
 #define CONFIG_BOOTM_LINUX 1
+
+#ifndef CONFIG_MINI_BOOT
 #define CONFIG_BOOTM_NETBSD 1
 #define CONFIG_BOOTM_PLAN9 1
 #define CONFIG_BOOTM_RTEMS 1
@@ -19,5 +21,6 @@
 #define CONFIG_GZIP 1
 #define CONFIG_ZLIB 1
 #define CONFIG_PARTITIONS 1
+#endif
 
 #endif
diff -uraN u-boot-2016.11/include/config_distro_defaults.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/config_distro_defaults.h
--- u-boot-2016.11/include/config_distro_defaults.h	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/config_distro_defaults.h	2021-06-07 13:01:32.000000000 +0300
@@ -12,7 +12,7 @@
  * features required by distros to support boards in a standardised and
  * consistent manner.
  */
-
+#ifndef CONFIG_MINI_BOOT
 #define CONFIG_BOOTP_BOOTPATH
 #define CONFIG_BOOTP_DNS
 #define CONFIG_BOOTP_GATEWAY
@@ -32,4 +32,6 @@
 #define CONFIG_SUPPORT_RAW_INITRD
 #define CONFIG_ENV_VARS_UBOOT_CONFIG
 
+#endif
+
 #endif	/* _CONFIG_CMD_DISTRO_DEFAULTS_H */
diff -uraN u-boot-2016.11/include/configs/gk7202v300.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/configs/gk7202v300.h
--- u-boot-2016.11/include/configs/gk7202v300.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/configs/gk7202v300.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,247 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __GK7202V300_H
+#define __GK7202V300_H
+
+#include <linux/sizes.h>
+#include <asm/arch/platform.h>
+
+/* ---------------------Physical Memory Map----------------------- */
+#define PHYS_SDRAM_1                0x40000000
+#define PHYS_SDRAM_1_SIZE           0x4000000
+
+#define CONFIG_SYS_TEXT_BASE        0x40800000
+#define CONFIG_SYS_TEXT_BASE_ORI    0x40700000
+
+#define CONFIG_NR_DRAM_BANKS        1
+
+#define CONFIG_SYS_SDRAM_BASE       PHYS_SDRAM_1
+
+#define CONFIG_SYS_INIT_SP_ADDR     0x04014000
+
+#define CONFIG_SYS_LOAD_ADDR        (CONFIG_SYS_SDRAM_BASE + 0x80000)
+#define CONFIG_SYS_GBL_DATA_SIZE    128
+
+#define CONFIG_SYS_MALLOC_LEN       (CONFIG_ENV_SIZE + SZ_128K)
+
+#define CONFIG_SYS_CACHELINE_SIZE   64
+
+/* base on needs #define CONFIG_REMAKE_ELF */
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+#define CONFIG_BOARD_EARLY_INIT_F
+
+
+/* Generic Timer Definitions */
+#define COUNTER_FREQUENCY       0x1800000
+
+#define CONFIG_SYS_TIMER_RATE       3000000
+#define CONFIG_SYS_TIMER_COUNTER    (TIMER0_REG_BASE + REG_TIMER_VALUE)
+#define CONFIG_SYS_TIMER_COUNTS_DOWN
+
+/* PL011 Serial Configuration */
+#define CONFIG_CUR_UART_BASE        UART0_REG_BASE
+
+#define CONFIG_BAUDRATE         115200
+#define CONFIG_CONS_INDEX       0
+#define CONFIG_PL01X_SERIAL
+#define CONFIG_PL011_SERIAL
+#define CONFIG_PL011_CLOCK      24000000
+#define CONFIG_PL01x_PORTS {(void *)CONFIG_CUR_UART_BASE}
+
+/*
+*-----------------------------------------------------------------------
+* Flash Memory Configuration
+*-----------------------------------------------------------------------
+*/
+#ifdef CONFIG_FMC
+#define CONFIG_FMC_REG_BASE       FMC_REG_BASE
+#define CONFIG_FMC_BUFFER_BASE    FMC_MEM_BASE
+#define CONFIG_FMC_MAX_CS_NUM     1
+#endif
+
+#ifdef CONFIG_FMC_SPI_NOR
+#define CONFIG_CMD_SF
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_SPI_NOR_MAX_CHIP_NUM 1
+#define CONFIG_SPI_NOR_QUIET_TEST
+#endif
+
+#ifndef CONFIG_MINI_BOOT
+
+#ifdef CONFIG_FMC_SPI_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_SPI_NAND_MAX_CHIP_NUM    1
+#define CONFIG_SYS_MAX_NAND_DEVICE  CONFIG_SPI_NAND_MAX_CHIP_NUM
+#define CONFIG_SYS_NAND_MAX_CHIPS   CONFIG_SPI_NAND_MAX_CHIP_NUM
+#define CONFIG_SYS_NAND_BASE        FMC_MEM_BASE
+
+#endif
+
+#ifdef CONFIG_FMC_NAND
+/* base on needs #define CONFIG_NAND_EDO_MODE */
+#define CONFIG_CMD_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_NAND_MAX_CHIP_NUM    1
+#define CONFIG_SYS_MAX_NAND_DEVICE  CONFIG_NAND_MAX_CHIP_NUM
+#define CONFIG_SYS_NAND_MAX_CHIPS   CONFIG_NAND_MAX_CHIP_NUM
+#define CONFIG_SYS_NAND_BASE        FMC_MEM_BASE
+#endif
+
+#define CONFIG_SYS_FAULT_ECHO_LINK_DOWN
+
+/*
+*-----------------------------------------------------------------------
+* Fast ethernet Configuration
+*-----------------------------------------------------------------------
+*/
+#ifdef CONFIG_NET_FEMAC
+#define INNER_PHY
+#define SFV_MII_MODE              0
+#define SFV_RMII_MODE             1
+#define BSPETH_MII_RMII_MODE_U           SFV_MII_MODE
+#define BSPETH_MII_RMII_MODE_D           SFV_MII_MODE
+#define SFV_PHY_U             0
+#define SFV_PHY_D             2
+#endif
+
+/*
+*-----------------------------------------------------------------------
+* SD/MMC configuration
+*-----------------------------------------------------------------------
+*/
+#ifdef CONFIG_MMC
+#define CONFIG_SUPPORT_EMMC_BOOT
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_SYS_MMC_ENV_DEV  0
+#define CONFIG_EXT4_SPARSE
+#define CONFIG_SDHCI
+#define CONFIG_GK_SDHCI
+#define CONFIG_GK_SDHCI_MAX_FREQ  150000000
+#define CONFIG_BOUNCE_BUFFER
+#define CONFIG_FS_EXT4
+#define CONFIG_SDHCI_ADMA
+#endif
+
+#define CONFIG_MISC_INIT_R
+
+/* Command line configuration */
+#define CONFIG_MENU
+#define CONFIG_CMD_UNZIP
+#define CONFIG_CMD_ENV
+
+#define CONFIG_MTD_PARTITIONS
+
+/* BOOTP options */
+#define CONFIG_BOOTP_BOOTFILESIZE
+
+#include <config_distro_defaults.h>
+
+/* Initial environment variables */
+
+/*
+ * Defines where the kernel and FDT will be put in RAM
+ */
+
+/* Assume we boot with root on the seventh partition of eMMC */
+#define CONFIG_BOOTARGS "console=ttyAMA0,115200n8 root=/dev/mtdblock2 rw"
+#define CONFIG_SYS_USB_XHCI_MAX_ROOT_PORTS 2
+#define BOOT_TARGET_DEVICES(func) \
+	func(USB, usb, 0) \
+	func(MMC, mmc, 1) \
+	func(DHCP, dhcp, na)
+#include <config_distro_bootcmd.h>
+
+/* allow change env */
+#define  CONFIG_ENV_OVERWRITE
+
+#define CONFIG_COMMAND_HISTORY
+
+#endif
+
+/* env in flash instead of CFG_ENV_IS_NOWHERE */
+#define CONFIG_ENV_OFFSET       0x80000      /* environment starts here */
+
+#define CONFIG_ENV_SIZE         0x40000
+#define CONFIG_ENV_SECT_SIZE        0x10000
+#define CONFIG_ENV_VARS_UBOOT_CONFIG
+
+/* kernel parameter list phy addr */
+#define CFG_BOOT_PARAMS         (CONFIG_SYS_SDRAM_BASE + 0x0100)
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE       1024    /* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE       (CONFIG_SYS_CBSIZE + \
+		    sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_BARGSIZE     CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_SYS_MAXARGS      64  /* max command args */
+
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_DDR_TRAINING_V2
+
+/* base on needs #define DDR_SCRAMB_ENABLE */
+
+#define CONFIG_PRODUCTNAME "gk7202v300"
+
+
+/* the flag for auto update. 1:enable; 0:disable */
+#define CONFIG_AUTO_UPDATE          1
+
+#if (CONFIG_AUTO_UPDATE == 1)
+#define CONFIG_AUTO_UPDATE_ADAPTATION   1
+/* base on needs #define CONFIG_AUTO_SD_UPDATE     1 */
+/* base on needs #define CONFIG_AUTO_USB_UPDATE    1 */
+
+#ifndef CONFIG_MINI_BOOT
+#define CONFIG_CMD_FAT          1
+#endif
+#endif
+
+/*---------------------------------------------------------------------
+ * sdcard system updae
+ * ---------------------------------------------------------------------*/
+#ifdef CONFIG_AUTO_SD_UPDATE
+
+#ifndef CONFIG_SDHCI
+#define CONFIG_SDHCI
+#endif
+
+#ifndef CONFIG_GENERIC_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_MMC
+#endif
+
+#ifndef CONFIG_MMC
+#define CONFIG_MMC      1
+#endif
+#endif
+
+#ifndef CONFIG_FMC
+#define CONFIG_EMMC
+#endif
+
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_CMDLINE_TAG
+
+#define COMPRESSED_SIZE_OFFSET      0X0
+#define UNCOMPRESSED_SIZE_OFFSET    0X4
+
+/* base on needs #define CONFIG_OSD_ENABLE */ /* For VO */
+#define CONFIG_OSD_ENABLE /* For VO */
+/* base on needs #define CONFIG_CIPHER_ENABLE */
+#define CONFIG_CIPHER_ENABLE
+
+#define CONFIG_CMD_UGZIP
+
+/* base on needs #define CONFIG_AUDIO_ENABLE */
+
+#endif /* __GK7202V300_H */
diff -uraN u-boot-2016.11/include/configs/gk7205v200.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/configs/gk7205v200.h
--- u-boot-2016.11/include/configs/gk7205v200.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/configs/gk7205v200.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,247 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __GK7205V200_H
+#define __GK7205V200_H
+
+#include <linux/sizes.h>
+#include <asm/arch/platform.h>
+
+/* ---------------------Physical Memory Map----------------------- */
+#define PHYS_SDRAM_1                0x40000000
+#define PHYS_SDRAM_1_SIZE           0x4000000
+
+#define CONFIG_SYS_TEXT_BASE        0x40800000
+#define CONFIG_SYS_TEXT_BASE_ORI    0x40700000
+
+#define CONFIG_NR_DRAM_BANKS        1
+
+#define CONFIG_SYS_SDRAM_BASE       PHYS_SDRAM_1
+
+#define CONFIG_SYS_INIT_SP_ADDR     0x04014000
+
+#define CONFIG_SYS_LOAD_ADDR        (CONFIG_SYS_SDRAM_BASE + 0x80000)
+#define CONFIG_SYS_GBL_DATA_SIZE    128
+
+#define CONFIG_SYS_MALLOC_LEN       (CONFIG_ENV_SIZE + SZ_128K)
+
+#define CONFIG_SYS_CACHELINE_SIZE   64
+
+/* base on needs #define CONFIG_REMAKE_ELF */
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+#define CONFIG_BOARD_EARLY_INIT_F
+
+
+/* Generic Timer Definitions */
+#define COUNTER_FREQUENCY       0x1800000
+
+#define CONFIG_SYS_TIMER_RATE       3000000
+#define CONFIG_SYS_TIMER_COUNTER    (TIMER0_REG_BASE + REG_TIMER_VALUE)
+#define CONFIG_SYS_TIMER_COUNTS_DOWN
+
+/* PL011 Serial Configuration */
+#define CONFIG_CUR_UART_BASE        UART0_REG_BASE
+
+#define CONFIG_BAUDRATE         115200
+#define CONFIG_CONS_INDEX       0
+#define CONFIG_PL01X_SERIAL
+#define CONFIG_PL011_SERIAL
+#define CONFIG_PL011_CLOCK      24000000
+#define CONFIG_PL01x_PORTS {(void *)CONFIG_CUR_UART_BASE}
+
+/*
+*-----------------------------------------------------------------------
+* Flash Memory Configuration
+*-----------------------------------------------------------------------
+*/
+#ifdef CONFIG_FMC
+#define CONFIG_FMC_REG_BASE       FMC_REG_BASE
+#define CONFIG_FMC_BUFFER_BASE    FMC_MEM_BASE
+#define CONFIG_FMC_MAX_CS_NUM     1
+#endif
+
+#ifdef CONFIG_FMC_SPI_NOR
+#define CONFIG_CMD_SF
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_SPI_NOR_MAX_CHIP_NUM 1
+#define CONFIG_SPI_NOR_QUIET_TEST
+#endif
+
+#ifndef CONFIG_MINI_BOOT
+
+#ifdef CONFIG_FMC_SPI_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_SPI_NAND_MAX_CHIP_NUM    1
+#define CONFIG_SYS_MAX_NAND_DEVICE  CONFIG_SPI_NAND_MAX_CHIP_NUM
+#define CONFIG_SYS_NAND_MAX_CHIPS   CONFIG_SPI_NAND_MAX_CHIP_NUM
+#define CONFIG_SYS_NAND_BASE        FMC_MEM_BASE
+
+#endif
+
+#ifdef CONFIG_FMC_NAND
+/* base on needs #define CONFIG_NAND_EDO_MODE */
+#define CONFIG_CMD_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_NAND_MAX_CHIP_NUM    1
+#define CONFIG_SYS_MAX_NAND_DEVICE  CONFIG_NAND_MAX_CHIP_NUM
+#define CONFIG_SYS_NAND_MAX_CHIPS   CONFIG_NAND_MAX_CHIP_NUM
+#define CONFIG_SYS_NAND_BASE        FMC_MEM_BASE
+#endif
+
+#define CONFIG_SYS_FAULT_ECHO_LINK_DOWN
+
+/*
+*-----------------------------------------------------------------------
+* Fast ethernet Configuration
+*-----------------------------------------------------------------------
+*/
+#ifdef CONFIG_NET_FEMAC
+#define INNER_PHY
+#define SFV_MII_MODE              0
+#define SFV_RMII_MODE             1
+#define BSPETH_MII_RMII_MODE_U           SFV_MII_MODE
+#define BSPETH_MII_RMII_MODE_D           SFV_MII_MODE
+#define SFV_PHY_U             0
+#define SFV_PHY_D             2
+#endif
+
+/*
+*-----------------------------------------------------------------------
+* SD/MMC configuration
+*-----------------------------------------------------------------------
+*/
+#ifdef CONFIG_MMC
+#define CONFIG_SUPPORT_EMMC_BOOT
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_SYS_MMC_ENV_DEV  0
+#define CONFIG_EXT4_SPARSE
+#define CONFIG_SDHCI
+#define CONFIG_GK_SDHCI
+#define CONFIG_GK_SDHCI_MAX_FREQ  150000000
+#define CONFIG_BOUNCE_BUFFER
+#define CONFIG_FS_EXT4
+#define CONFIG_SDHCI_ADMA
+#endif
+
+#define CONFIG_MISC_INIT_R
+
+/* Command line configuration */
+#define CONFIG_MENU
+#define CONFIG_CMD_UNZIP
+#define CONFIG_CMD_ENV
+
+#define CONFIG_MTD_PARTITIONS
+
+/* BOOTP options */
+#define CONFIG_BOOTP_BOOTFILESIZE
+
+#include <config_distro_defaults.h>
+
+/* Initial environment variables */
+
+/*
+ * Defines where the kernel and FDT will be put in RAM
+ */
+
+/* Assume we boot with root on the seventh partition of eMMC */
+#define CONFIG_BOOTARGS "console=ttyAMA0,115200n8 root=/dev/mtdblock2 rw"
+#define CONFIG_SYS_USB_XHCI_MAX_ROOT_PORTS 2
+#define BOOT_TARGET_DEVICES(func) \
+	func(USB, usb, 0) \
+	func(MMC, mmc, 1) \
+	func(DHCP, dhcp, na)
+#include <config_distro_bootcmd.h>
+
+/* allow change env */
+#define  CONFIG_ENV_OVERWRITE
+
+#define CONFIG_COMMAND_HISTORY
+
+#endif
+
+/* env in flash instead of CFG_ENV_IS_NOWHERE */
+#define CONFIG_ENV_OFFSET       0x80000      /* environment starts here */
+
+#define CONFIG_ENV_SIZE         0x40000
+#define CONFIG_ENV_SECT_SIZE        0x10000
+#define CONFIG_ENV_VARS_UBOOT_CONFIG
+
+/* kernel parameter list phy addr */
+#define CFG_BOOT_PARAMS         (CONFIG_SYS_SDRAM_BASE + 0x0100)
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE       1024    /* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE       (CONFIG_SYS_CBSIZE + \
+		    sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_BARGSIZE     CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_SYS_MAXARGS      64  /* max command args */
+
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_DDR_TRAINING_V2
+
+/* base on needs #define DDR_SCRAMB_ENABLE */
+
+#define CONFIG_PRODUCTNAME "gk7205v200"
+
+
+/* the flag for auto update. 1:enable; 0:disable */
+#define CONFIG_AUTO_UPDATE          1
+
+#if (CONFIG_AUTO_UPDATE == 1)
+#define CONFIG_AUTO_UPDATE_ADAPTATION   1
+/* base on needs #define CONFIG_AUTO_SD_UPDATE     1 */
+/* base on needs #define CONFIG_AUTO_USB_UPDATE    1 */
+
+#ifndef CONFIG_MINI_BOOT
+#define CONFIG_CMD_FAT          1
+#endif
+#endif
+
+/*---------------------------------------------------------------------
+ * sdcard system updae
+ * ---------------------------------------------------------------------*/
+#ifdef CONFIG_AUTO_SD_UPDATE
+
+#ifndef CONFIG_SDHCI
+#define CONFIG_SDHCI
+#endif
+
+#ifndef CONFIG_GENERIC_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_MMC
+#endif
+
+#ifndef CONFIG_MMC
+#define CONFIG_MMC      1
+#endif
+#endif
+
+#ifndef CONFIG_FMC
+#define CONFIG_EMMC
+#endif
+
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_CMDLINE_TAG
+
+#define COMPRESSED_SIZE_OFFSET      0X0
+#define UNCOMPRESSED_SIZE_OFFSET    0X4
+
+/* base on needs #define CONFIG_OSD_ENABLE */ /* For VO */
+#define CONFIG_OSD_ENABLE /* For VO */
+/* base on needs #define CONFIG_CIPHER_ENABLE */
+#define CONFIG_CIPHER_ENABLE
+
+#define CONFIG_CMD_UGZIP
+
+/* base on needs #define CONFIG_AUDIO_ENABLE */
+
+#endif /* __GK7205V200_H */
diff -uraN u-boot-2016.11/include/configs/gk7205v300.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/configs/gk7205v300.h
--- u-boot-2016.11/include/configs/gk7205v300.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/configs/gk7205v300.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,237 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __GK7205V300_H
+#define __GK7205V300_H
+
+#include <linux/sizes.h>
+#include <asm/arch/platform.h>
+
+/* ---------------------Physical Memory Map----------------------- */
+#define PHYS_SDRAM_1                0x40000000
+#define PHYS_SDRAM_1_SIZE           0x08000000
+#define CONFIG_SYS_TEXT_BASE        0x40800000
+#define CONFIG_SYS_TEXT_BASE_ORI    0x40700000
+
+#define CONFIG_NR_DRAM_BANKS        1
+
+#define CONFIG_SYS_SDRAM_BASE       PHYS_SDRAM_1
+
+#define CONFIG_SYS_INIT_SP_ADDR     0x04014000
+
+#define CONFIG_SYS_LOAD_ADDR        (CONFIG_SYS_SDRAM_BASE + 0x80000)
+#define CONFIG_SYS_GBL_DATA_SIZE    128
+
+#define CONFIG_SYS_MALLOC_LEN       (CONFIG_ENV_SIZE + SZ_128K)
+
+#define CONFIG_SYS_CACHELINE_SIZE   64
+
+/* base on needs #define CONFIG_REMAKE_ELF */
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+#define CONFIG_BOARD_EARLY_INIT_F
+
+
+/* Generic Timer Definitions */
+#define COUNTER_FREQUENCY       0x1800000
+
+#define CONFIG_SYS_TIMER_RATE       3000000
+#define CONFIG_SYS_TIMER_COUNTER    (TIMER0_REG_BASE + REG_TIMER_VALUE)
+#define CONFIG_SYS_TIMER_COUNTS_DOWN
+
+/* PL011 Serial Configuration */
+#define CONFIG_CUR_UART_BASE        UART0_REG_BASE
+
+#define CONFIG_BAUDRATE         115200
+#define CONFIG_CONS_INDEX       0
+#define CONFIG_PL01X_SERIAL
+#define CONFIG_PL011_SERIAL
+#define CONFIG_PL011_CLOCK      24000000
+#define CONFIG_PL01x_PORTS {(void *)CONFIG_CUR_UART_BASE}
+
+/*
+*-----------------------------------------------------------------------
+* Flash Memory Configuration
+*-----------------------------------------------------------------------
+*/
+#ifdef CONFIG_FMC
+#define CONFIG_FMC_REG_BASE       FMC_REG_BASE
+#define CONFIG_FMC_BUFFER_BASE    FMC_MEM_BASE
+#define CONFIG_FMC_MAX_CS_NUM     1
+#endif
+
+#ifdef CONFIG_FMC_SPI_NOR
+#define CONFIG_CMD_SF
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_SPI_NOR_MAX_CHIP_NUM 1
+#define CONFIG_SPI_NOR_QUIET_TEST
+#endif
+
+#ifdef CONFIG_FMC_SPI_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_SPI_NAND_MAX_CHIP_NUM    1
+#define CONFIG_SYS_MAX_NAND_DEVICE  CONFIG_SPI_NAND_MAX_CHIP_NUM
+#define CONFIG_SYS_NAND_MAX_CHIPS   CONFIG_SPI_NAND_MAX_CHIP_NUM
+#define CONFIG_SYS_NAND_BASE        FMC_MEM_BASE
+
+#endif
+
+#ifdef CONFIG_FMC_NAND
+/* base on needs #define CONFIG_NAND_EDO_MODE */
+#define CONFIG_CMD_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_NAND_MAX_CHIP_NUM    1
+#define CONFIG_SYS_MAX_NAND_DEVICE  CONFIG_NAND_MAX_CHIP_NUM
+#define CONFIG_SYS_NAND_MAX_CHIPS   CONFIG_NAND_MAX_CHIP_NUM
+#define CONFIG_SYS_NAND_BASE        FMC_MEM_BASE
+#endif
+
+#define CONFIG_SYS_FAULT_ECHO_LINK_DOWN
+
+/*
+*-----------------------------------------------------------------------
+* Fast ethernet Configuration
+*-----------------------------------------------------------------------
+*/
+#ifdef CONFIG_NET_FEMAC
+#define INNER_PHY
+#define SFV_MII_MODE              0
+#define SFV_RMII_MODE             1
+#define BSPETH_MII_RMII_MODE_U           SFV_MII_MODE
+#define BSPETH_MII_RMII_MODE_D           SFV_MII_MODE
+#define SFV_PHY_U             0
+#define SFV_PHY_D             2
+#endif
+
+/*
+*-----------------------------------------------------------------------
+* SD/MMC configuration
+*-----------------------------------------------------------------------
+*/
+#ifdef CONFIG_MMC
+#define CONFIG_SUPPORT_EMMC_BOOT
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_SYS_MMC_ENV_DEV  0
+#define CONFIG_EXT4_SPARSE
+#define CONFIG_SDHCI
+#define CONFIG_GK_SDHCI
+#define CONFIG_GK_SDHCI_MAX_FREQ  90000000
+#define CONFIG_BOUNCE_BUFFER
+#define CONFIG_FS_EXT4
+#define CONFIG_SDHCI_ADMA
+#endif
+
+#define CONFIG_MISC_INIT_R
+
+/* Command line configuration */
+#define CONFIG_MENU
+#define CONFIG_CMD_UNZIP
+#define CONFIG_CMD_ENV
+
+#define CONFIG_MTD_PARTITIONS
+
+/* BOOTP options */
+#define CONFIG_BOOTP_BOOTFILESIZE
+
+#include <config_distro_defaults.h>
+
+/* Initial environment variables */
+
+/*
+ * Defines where the kernel and FDT will be put in RAM
+ */
+
+/* Assume we boot with root on the seventh partition of eMMC */
+#define CONFIG_BOOTARGS "console=ttyAMA0,115200n8 root=/dev/mtdblock2 rw"
+#define CONFIG_SYS_USB_XHCI_MAX_ROOT_PORTS 2
+#define BOOT_TARGET_DEVICES(func) \
+	func(USB, usb, 0) \
+	func(MMC, mmc, 1) \
+	func(DHCP, dhcp, na)
+#include <config_distro_bootcmd.h>
+
+/* allow change env */
+#define  CONFIG_ENV_OVERWRITE
+
+#define CONFIG_COMMAND_HISTORY
+
+/* env in flash instead of CFG_ENV_IS_NOWHERE */
+#define CONFIG_ENV_OFFSET       0x80000      /* environment starts here */
+
+#define CONFIG_ENV_SIZE         0x40000
+#define CONFIG_ENV_SECT_SIZE        0x10000
+#define CONFIG_ENV_VARS_UBOOT_CONFIG
+
+/* kernel parameter list phy addr */
+#define CFG_BOOT_PARAMS         (CONFIG_SYS_SDRAM_BASE + 0x0100)
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE       1024    /* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE       (CONFIG_SYS_CBSIZE + \
+		    sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_BARGSIZE     CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_SYS_MAXARGS      64  /* max command args */
+
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_DDR_TRAINING_V2
+
+/* base on needs #define DDR_SCRAMB_ENABLE */
+
+#define CONFIG_PRODUCTNAME "gk7205v300"
+
+
+/* the flag for auto update. 1:enable; 0:disable */
+#define CONFIG_AUTO_UPDATE          1
+
+#if (CONFIG_AUTO_UPDATE == 1)
+#define CONFIG_AUTO_UPDATE_ADAPTATION   1
+/* base on needs #define CONFIG_AUTO_SD_UPDATE     1 */
+/* base on needs #define CONFIG_AUTO_USB_UPDATE        1 */
+
+#define CONFIG_CMD_FAT          1
+#endif
+
+/*---------------------------------------------------------------------
+ * sdcard system updae
+ * ---------------------------------------------------------------------*/
+#ifdef CONFIG_AUTO_SD_UPDATE
+
+#ifndef CONFIG_SDHCI
+#define CONFIG_SDHCI
+#endif
+
+#ifndef CONFIG_GENERIC_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_MMC
+#endif
+
+#ifndef CONFIG_MMC
+#define CONFIG_MMC      1
+#endif
+#endif
+
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_CMDLINE_TAG
+
+#define COMPRESSED_SIZE_OFFSET      0X0
+#define UNCOMPRESSED_SIZE_OFFSET    0X4
+
+/* base on needs #define CONFIG_OSD_ENABLE */ /* For VO */
+#define CONFIG_OSD_ENABLE /* For VO */
+/* base on needs #define CONFIG_CIPHER_ENABLE */
+#define CONFIG_CIPHER_ENABLE
+
+#define CONFIG_CMD_UGZIP
+
+/* base on needs #define CONFIG_AUDIO_ENABLE */
+#define CONFIG_AUDIO_ENABLE
+
+#endif /* __GK7205V300_H */
diff -uraN u-boot-2016.11/include/configs/gk7605v100.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/configs/gk7605v100.h
--- u-boot-2016.11/include/configs/gk7605v100.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/configs/gk7605v100.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,234 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __GK7605V100_H
+#define __GK7605V100_H
+
+#include <linux/sizes.h>
+#include <asm/arch/platform.h>
+
+/* ---------------------Physical Memory Map----------------------- */
+#define PHYS_SDRAM_1                0x40000000
+#define PHYS_SDRAM_1_SIZE           0x20000000
+#define CONFIG_SYS_TEXT_BASE        0x40800000
+#define CONFIG_SYS_TEXT_BASE_ORI    0x40700000
+
+#define CONFIG_NR_DRAM_BANKS        1
+
+#define CONFIG_SYS_SDRAM_BASE       PHYS_SDRAM_1
+
+#define CONFIG_SYS_INIT_SP_ADDR     0x04014000
+
+#define CONFIG_SYS_LOAD_ADDR        (CONFIG_SYS_SDRAM_BASE + 0x80000)
+#define CONFIG_SYS_GBL_DATA_SIZE    128
+
+#define CONFIG_SYS_MALLOC_LEN       (CONFIG_ENV_SIZE + SZ_128K)
+
+#define CONFIG_SYS_CACHELINE_SIZE   64
+
+/* base on needs #define CONFIG_REMAKE_ELF */
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+#define CONFIG_BOARD_EARLY_INIT_F
+
+
+/* Generic Timer Definitions */
+#define COUNTER_FREQUENCY       0x1800000
+
+#define CONFIG_SYS_TIMER_RATE       3000000
+#define CONFIG_SYS_TIMER_COUNTER    (TIMER0_REG_BASE + REG_TIMER_VALUE)
+#define CONFIG_SYS_TIMER_COUNTS_DOWN
+
+/* PL011 Serial Configuration */
+#define CONFIG_CUR_UART_BASE        UART0_REG_BASE
+
+#define CONFIG_BAUDRATE         115200
+#define CONFIG_CONS_INDEX       0
+#define CONFIG_PL01X_SERIAL
+#define CONFIG_PL011_SERIAL
+#define CONFIG_PL011_CLOCK      24000000
+#define CONFIG_PL01x_PORTS {(void *)CONFIG_CUR_UART_BASE}
+
+/*
+*-----------------------------------------------------------------------
+* Flash Memory Configuration
+*-----------------------------------------------------------------------
+*/
+#ifdef CONFIG_FMC
+#define CONFIG_FMC_REG_BASE       FMC_REG_BASE
+#define CONFIG_FMC_BUFFER_BASE    FMC_MEM_BASE
+#define CONFIG_FMC_MAX_CS_NUM     1
+#endif
+
+#ifdef CONFIG_FMC_SPI_NOR
+#define CONFIG_CMD_SF
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_SPI_NOR_MAX_CHIP_NUM 1
+#define CONFIG_SPI_NOR_QUIET_TEST
+#endif
+
+#ifdef CONFIG_FMC_SPI_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_SPI_NAND_MAX_CHIP_NUM    1
+#define CONFIG_SYS_MAX_NAND_DEVICE  CONFIG_SPI_NAND_MAX_CHIP_NUM
+#define CONFIG_SYS_NAND_MAX_CHIPS   CONFIG_SPI_NAND_MAX_CHIP_NUM
+#define CONFIG_SYS_NAND_BASE        FMC_MEM_BASE
+
+#endif
+
+#ifdef CONFIG_FMC_NAND
+/* base on needs #define CONFIG_NAND_EDO_MODE */
+#define CONFIG_CMD_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_NAND_MAX_CHIP_NUM    1
+#define CONFIG_SYS_MAX_NAND_DEVICE  CONFIG_NAND_MAX_CHIP_NUM
+#define CONFIG_SYS_NAND_MAX_CHIPS   CONFIG_NAND_MAX_CHIP_NUM
+#define CONFIG_SYS_NAND_BASE        FMC_MEM_BASE
+#endif
+
+#define CONFIG_SYS_FAULT_ECHO_LINK_DOWN
+
+/*
+*-----------------------------------------------------------------------
+* Fast ethernet Configuration
+*-----------------------------------------------------------------------
+*/
+#ifdef CONFIG_NET_FEMAC
+#define INNER_PHY
+#define SFV_MII_MODE              0
+#define SFV_RMII_MODE             1
+#define BSPETH_MII_RMII_MODE_U           SFV_MII_MODE
+#define BSPETH_MII_RMII_MODE_D           SFV_MII_MODE
+#define SFV_PHY_U             0
+#define SFV_PHY_D             2
+#endif
+
+/*
+*-----------------------------------------------------------------------
+* SD/MMC configuration
+*-----------------------------------------------------------------------
+*/
+#ifdef CONFIG_MMC
+#define CONFIG_SUPPORT_EMMC_BOOT
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_SYS_MMC_ENV_DEV  0
+#define CONFIG_EXT4_SPARSE
+#define CONFIG_SDHCI
+#define CONFIG_GK_SDHCI
+#define CONFIG_GK_SDHCI_MAX_FREQ  90000000
+#define CONFIG_BOUNCE_BUFFER
+#define CONFIG_FS_EXT4
+#define CONFIG_SDHCI_ADMA
+#endif
+
+#define CONFIG_MISC_INIT_R
+
+/* Command line configuration */
+#define CONFIG_MENU
+#define CONFIG_CMD_UNZIP
+#define CONFIG_CMD_ENV
+
+#define CONFIG_MTD_PARTITIONS
+
+/* BOOTP options */
+#define CONFIG_BOOTP_BOOTFILESIZE
+
+#include <config_distro_defaults.h>
+
+/* Initial environment variables */
+
+/*
+ * Defines where the kernel and FDT will be put in RAM
+ */
+
+/* Assume we boot with root on the seventh partition of eMMC */
+#define CONFIG_BOOTARGS "console=ttyAMA0,115200n8 root=/dev/mtdblock2 rw"
+#define CONFIG_SYS_USB_XHCI_MAX_ROOT_PORTS 2
+#define BOOT_TARGET_DEVICES(func) \
+	func(USB, usb, 0) \
+	func(MMC, mmc, 1) \
+	func(DHCP, dhcp, na)
+#include <config_distro_bootcmd.h>
+
+/* allow change env */
+#define  CONFIG_ENV_OVERWRITE
+
+#define CONFIG_COMMAND_HISTORY
+
+/* env in flash instead of CFG_ENV_IS_NOWHERE */
+#define CONFIG_ENV_OFFSET       0x80000      /* environment starts here */
+
+#define CONFIG_ENV_SIZE         0x40000
+#define CONFIG_ENV_SECT_SIZE        0x10000
+#define CONFIG_ENV_VARS_UBOOT_CONFIG
+
+/* kernel parameter list phy addr */
+#define CFG_BOOT_PARAMS         (CONFIG_SYS_SDRAM_BASE + 0x0100)
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE       1024    /* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE       (CONFIG_SYS_CBSIZE + \
+		    sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_BARGSIZE     CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_SYS_MAXARGS      64  /* max command args */
+
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_DDR_TRAINING_V2
+
+/* base on needs #define DDR_SCRAMB_ENABLE */
+
+#define CONFIG_PRODUCTNAME "gk7605v100"
+
+
+/* the flag for auto update. 1:enable; 0:disable */
+#define CONFIG_AUTO_UPDATE          1
+
+#if (CONFIG_AUTO_UPDATE == 1)
+#define CONFIG_AUTO_UPDATE_ADAPTATION   1
+/* base on needs #define CONFIG_AUTO_SD_UPDATE     1 */
+/* base on needs #define CONFIG_AUTO_USB_UPDATE        1 */
+
+#define CONFIG_CMD_FAT          1
+#endif
+
+/*---------------------------------------------------------------------
+ * sdcard system updae
+ * ---------------------------------------------------------------------*/
+#ifdef CONFIG_AUTO_SD_UPDATE
+
+#ifndef CONFIG_SDHCI
+#define CONFIG_SDHCI
+#endif
+
+#ifndef CONFIG_GENERIC_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_MMC
+#endif
+
+#ifndef CONFIG_MMC
+#define CONFIG_MMC      1
+#endif
+#endif
+
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_CMDLINE_TAG
+
+#define COMPRESSED_SIZE_OFFSET      0X0
+#define UNCOMPRESSED_SIZE_OFFSET    0X4
+
+/* base on needs #define CONFIG_OSD_ENABLE */ /* For VO */
+/* base on needs #define CONFIG_CIPHER_ENABLE */
+
+#define CONFIG_CMD_UGZIP
+
+/* base on needs #define CONFIG_AUDIO_ENABLE */
+
+#endif /* __GK7605V100_H */
diff -uraN u-boot-2016.11/include/cpu_common.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/cpu_common.h
--- u-boot-2016.11/include/cpu_common.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/cpu_common.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __CPU_COMMON_H__
+#define __CPU_COMMON_H__
+
+#include <command.h>
+
+#ifdef CONFIG_EMMC
+extern int target_dev;
+extern int target_paratition;
+#endif 
+
+void reset_cpu(ulong addr);
+void uart_early_init(void);
+void uart_early_puts(const char *ss);
+extern unsigned char input_data[];
+extern unsigned char input_data_end[];
+extern unsigned long _armboot_start;
+extern int sdhci_add_port(int index, u32 regbase, u32 freq);
+extern int bsp_mmc_init(int index);
+
+#if (CONFIG_AUTO_UPDATE == 1)
+extern int do_auto_update(void);
+extern int do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[]);
+#endif /* CONFIG_AUTO_UPDATE */
+
+#ifdef CONFIG_GENERIC_MMC
+extern int mci_probe(int dev_num);
+#endif /* CONFIG_GENERIC_MMC */
+
+#ifdef CONFIG_SUPPORT_EMMC_BOOT
+extern int mci_add_port(int index, u32 reg_base, u32 freq);
+#endif /* CONFIG_SUPPORT_EMMC_BOOT */
+
+#ifdef CONFIG_AUTO_SD_UPDATE
+extern int mci_add_port(int index, u32 reg_base, u32 freq);
+#endif /* CONFIG_AUTO_SD_UPDATE */
+
+extern int mmc_phy_init(void);
+
+#ifdef CONFIG_CMD_NAND
+extern int nand_saveenv(void);
+extern void nand_env_relocate_spec(void);
+#endif /* CONFIG_CMD_NAND */
+
+#ifdef CONFIG_ENV_IS_IN_SPI_FLASH
+extern int sf_saveenv(void);
+extern void sf_env_relocate_spec(void);
+#endif /* CONFIG_ENV_IS_IN_SPI_FLASH */
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+extern int emmc_saveenv(void);
+extern void emmc_env_relocate_spec(void);
+#endif /* CONFIG_ENV_IS_IN_MMC */
+
+#ifdef CONFIG_ENV_IS_IN_UFS
+extern int ufs_saveenv(void);
+extern void ufs_env_relocate_spec(void);
+#endif /* CONFIG_ENV_IS_IN_UFS */
+
+#endif /* __CPU_COMMON_H__ */
+
diff -uraN u-boot-2016.11/include/environment.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/environment.h
--- u-boot-2016.11/include/environment.h	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/environment.h	2021-06-07 13:01:32.000000000 +0300
@@ -179,7 +179,7 @@
 extern void env_reloc(void);
 #endif
 
-#ifdef CONFIG_ENV_IS_IN_MMC
+#if 0
 #include <mmc.h>
 
 extern int mmc_get_env_addr(struct mmc *mmc, int copy, u32 *env_addr);
diff -uraN u-boot-2016.11/include/fmc_common.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/fmc_common.h
--- u-boot-2016.11/include/fmc_common.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/fmc_common.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,538 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __FMC_COMMON_H__
+#define __FMC_COMMON_H__
+
+/*****************************************************************************/
+#define _32B					32
+#define _64B					64
+#define _128B					128
+#define _218B					218
+#define _224B					224
+#define _232B					232
+#define _256B					256
+#define _448B					448
+#define _512B					512
+#define _640B					640
+#define _744B					744
+#define _1K					1024
+#define _1280B					1280
+#define _2K					2048
+#define _4K					4096
+#define _8K					8192
+#define _16K					16384
+#define _32K					32768
+#define _64K					0x10000UL
+#define _128K					0x20000UL
+#define _256K					0x40000UL
+#define _512K					0x80000UL
+#define _1M					0x100000UL
+#define _2M					0x200000UL
+#define _4M					0x400000UL
+#define _8M					0x800000UL
+#define _16M					0x1000000UL
+#define _32M					0x2000000UL
+#define _64M					0x4000000UL
+#define _128M					0x8000000UL
+#define _256M					0x10000000UL
+#define _512M					0x20000000UL
+#define _1G					0x40000000ULL
+#define _2G					0x80000000ULL
+#define _4G					0x100000000ULL
+#define _8G					0x200000000ULL
+#define _16G					0x400000000ULL
+#define _64G					0x1000000000ULL
+
+#define ECC_TYPE_0BIT				0x0
+#define ECC_TYPE_8BIT				0x1
+#define ECC_TYPE_16BIT				0x2
+#define ECC_TYPE_24BIT				0x3
+#define ECC_TYPE_28BIT				0x4
+#define ECC_TYPE_40BIT				0x5
+#define ECC_TYPE_64BIT				0x6
+
+#define PAGE_SIZE_2KB				0x0
+#define PAGE_SIZE_4KB				0x1
+#define PAGE_SIZE_8KB				0x2
+#define PAGE_SIZE_16KB				0x3
+
+/* id len */
+#define _2B					2
+#define _3B					3
+#define _4B					4
+#define _5B					5
+#define _6B					6
+#define _7B					7
+#define _8B					8
+#define _9B					9
+#define _10B					10
+#define _11B					11
+#define _12B					12
+
+#ifdef CONFIG_FMC
+/*****************************************************************************/
+/* FMC REG */
+/*****************************************************************************/
+#define FMC_CFG					0x00
+#define fmc_cfg_spi_nand_sel(_type)		(((_size) & 0x3) << 11)
+#define fmc_cfg_spi_nor_addr_mode(_mode)	((_mode) << 10)
+#define fmc_cfg_block_size(_size)		(((_size) & 0x3) << 8)
+#define fmc_cfg_ecc_type(_type)			(((_type) & 0x7) << 5)
+#define fmc_cfg_page_size(_size)		(((_size) & 0x3) << 3)
+#define fmc_cfg_flash_sel(_type)		(((_type) & 0x3) << 1)
+#define fmc_cfg_op_mode(_mode)			((_mode) & 0x1)
+
+#define SPI_NAND_MFR_OTHER			0x0
+#define SPI_NAND_MFR_WINBOND			0x1
+#define SPI_NAND_MFR_ESMT			0x2
+#define SPI_NAND_MFR_MICRON			0x3
+
+#define SPI_NAND_SEL_SHIFT			11
+#define SPI_NAND_SEL_MASK			(0x3 << SPI_NAND_SEL_SHIFT)
+
+#define SPI_NOR_ADDR_MODE_3_BYTES		0x0
+#define SPI_NOR_ADDR_MODE_4_BYTES		0x1
+
+#define SPI_NOR_ADDR_MODE_SHIFT			10
+#define SPI_NOR_ADDR_MODE_MASK			(0x1 << SPI_NOR_ADDR_MODE_SHIFT)
+
+#define BLOCK_SIZE_64_PAGE			0x0
+#define BLOCK_SIZE_128_PAGE			0x1
+#define BLOCK_SIZE_256_PAGE			0x2
+#define BLOCK_SIZE_512_PAGE			0x3
+
+#define _64_PAGES				64
+#define _128_PAGES				128
+#define _256_PAGES				256
+#define _512_PAGES				512
+
+#define EB_NORMAL				28
+#define EB_2K_16_BIT				4
+#define EB_4K_16_BIT				12
+
+#define BLOCK_SIZE_MASK				(0x3 << 8)
+
+#define ECC_TYPE_SHIFT				5
+#define ECC_TYPE_MASK				(0x7 << ECC_TYPE_SHIFT)
+
+#define PAGE_SIZE_SHIFT				3
+#define PAGE_SIZE_MASK				(0x3 << PAGE_SIZE_SHIFT)
+
+#define FLASH_TYPE_SPI_NOR			0x0
+#define FLASH_TYPE_SPI_NAND			0x1
+#define FLASH_TYPE_NAND				0x2
+#define FLASH_TYPE_DEFAULT			0x3
+
+#define FLASH_SEL_SHIFT				1
+#define FLASH_SEL_MASK				(0x3 << FLASH_SEL_SHIFT)
+
+#define OP_MODE_BOOT				0x0
+#define OP_MODE_NORMAL				0x1
+
+#define OP_MODE_MASK				0x1
+
+/*****************************************************************************/
+#define FMC_GLOBAL_CFG				0x04
+#define FMC_GLOBAL_CFG_WP_ENABLE		(1 << 6)
+#define FMC_GLOBAL_CFG_RANDOMIZER_EN		(1 << 2)
+
+/*****************************************************************************/
+#define FMC_SPI_TIMING_CFG			0x08
+#define timing_cfg_tcsh(_n)			(((_n) & 0xf) << 8)
+#define timing_cfg_tcss(_n)			(((_n) & 0xf) << 4)
+#define timing_cfg_tshsl(_n)			((_n) & 0xf)
+
+#define CS_HOLD_TIME				0x6
+#define CS_SETUP_TIME				0x6
+#define CS_DESELECT_TIME			0xf
+
+/*****************************************************************************/
+#define FMC_PND_PWIDTH_CFG			0x0c
+#define pwidth_cfg_rw_hcnt(_n)			(((_n) & 0xf) << 8)
+#define pwidth_cfg_r_lcnt(_n)			(((_n) & 0xf) << 4)
+#define pwidth_cfg_w_lcnt(_n)			((_n) & 0xf)
+
+#ifdef CONFIG_NAND_EDO_MODE
+#define RW_H_WIDTH				0x3
+#define R_L_WIDTH				0x2
+#define W_L_WIDTH				0x2
+#define NAND_EDO_MODE_SHIFT		9
+#define NAND_EDO_MODE_MASK		(1<<NAND_EDO_MODE_SHIFT)
+#define set_nand_edo_mode_en(reg)	((reg) | NAND_EDO_MODE_MASK)
+#else
+#define RW_H_WIDTH				0xa
+#define R_L_WIDTH				0xa
+#define W_L_WIDTH				0xa
+#endif
+/*****************************************************************************/
+#define FMC_INT					0x18
+#define FMC_INT_AHB_OP				(1 << 7)
+#define FMC_INT_WR_LOCK				(1 << 6)
+#define FMC_INT_DMA_ERR				(1 << 5)
+#define FMC_INT_ERR_ALARM			(1 << 4)
+#define FMC_INT_ERR_INVALID			(1 << 3)
+#define FMC_INT_ERR_VALID			(1 << 2)
+#define FMC_INT_OP_FAIL				(1 << 1)
+#define FMC_INT_OP_DONE				(1 << 0)
+
+/*****************************************************************************/
+#define FMC_INT_EN				0x1c
+#define FMC_INT_EN_AHB_OP			(1 << 7)
+#define FMC_INT_EN_WR_LOCK			(1 << 6)
+#define FMC_INT_EN_DMA_ERR			(1 << 5)
+#define FMC_INT_EN_ERR_ALARM			(1 << 4)
+#define FMC_INT_EN_ERR_INVALID			(1 << 3)
+#define FMC_INT_EN_ERR_VALID			(1 << 2)
+#define FMC_INT_EN_OP_FAIL			(1 << 1)
+#define FMC_INT_EN_OP_DONE			(1 << 0)
+
+/*****************************************************************************/
+#define FMC_INT_CLR				0x20
+#define FMC_INT_CLR_AHB_OP			(1 << 7)
+#define FMC_INT_CLR_WR_LOCK			(1 << 6)
+#define FMC_INT_CLR_DMA_ERR			(1 << 5)
+#define FMC_INT_CLR_ERR_ALARM			(1 << 4)
+#define FMC_INT_CLR_ERR_INVALID			(1 << 3)
+#define FMC_INT_CLR_ERR_VALID			(1 << 2)
+#define FMC_INT_CLR_OP_FAIL			(1 << 1)
+#define FMC_INT_CLR_OP_DONE			(1 << 0)
+
+#define FMC_INT_CLR_ALL				0xff
+
+/*****************************************************************************/
+#define FMC_CMD					0x24
+#define fmc_cmd_cmd2(_cmd)			(((_cmd) & 0xff) << 8)
+#define fmc_cmd_cmd1(_cmd)			((_cmd) & 0xff)
+
+/*****************************************************************************/
+#define FMC_ADDRH				0x28
+#define fmc_addrh_set(_addr)			((_addr) & 0xff)
+
+/*****************************************************************************/
+#define FMC_ADDRL				0x2c
+#define fmc_addrl_block_h_mask(_page)		(((_page) & 0xffff) << 16)
+#define fmc_addrl_block_l_mask(_page)		((_page) & 0xffc0)
+
+#define READ_ID_ADDR				0x00
+#define PROTECT_ADDR				0xa0
+#define FEATURE_ADDR				0xb0
+#define STATUS_ADDR				0xc0
+
+/*****************************************************************************/
+#define FMC_OP_CFG				0x30
+#define op_cfg_fm_cs(_cs)			((_cs) << 11)
+#define op_cfg_force_cs_en(_en)			((_en) << 10)
+#define op_cfg_mem_if_type(_type)		(((_type) & 0x7) << 7)
+#define op_cfg_addr_num(_addr)			(((_addr) & 0x7) << 4)
+#define op_cfg_dummy_num(_dummy)		((_dummy) & 0xf)
+#define OP_CFG_OEN_EN				(0x1 << 13)
+
+#define IF_TYPE_STD				0x0
+#define IF_TYPE_DUAL				0x1
+#define IF_TYPE_DIO				0x2
+#define IF_TYPE_QUAD				0x3
+#define IF_TYPE_QIO				0x4
+#define IF_TYPE_DTR				0x4
+
+#define IF_TYPE_SHIFT				7
+#define IF_TYPE_MASK				(0x7 << IF_TYPE_SHIFT)
+
+#define READ_ID_ADDR_NUM			1
+#define FEATURES_OP_ADDR_NUM			1
+#define STD_OP_ADDR_NUM				3
+
+/*****************************************************************************/
+#define FMC_SPI_OP_ADDR				0x34
+
+/*****************************************************************************/
+#define FMC_DATA_NUM				0x38
+#define fmc_data_num_cnt(_n)			((_n) & 0x3fff)
+
+#define SPI_NOR_SR_LEN				1 /* Status Register length */
+#define SPI_NOR_CR_LEN				1 /* Config Register length */
+#define FEATURES_DATA_LEN			1
+#define READ_OOB_BB_LEN				1
+#define MAX_SPI_NOR_ID_LEN			8
+#define MAX_NAND_ID_LEN				8
+#define MAX_SPI_NAND_ID_LEN			3
+
+#define PROTECT_BRWD_MASK			(1 << 7)
+#define PROTECT_BP3_MASK			(1 << 6)
+#define PROTECT_BP2_MASK			(1 << 5)
+#define PROTECT_BP1_MASK			(1 << 4)
+#define PROTECT_BP0_MASK			(1 << 3)
+
+#define any_bp_enable(_val) ((PROTECT_BP3_MASK & _val) || \
+		(PROTECT_BP2_MASK & _val) || (PROTECT_BP1_MASK & _val) || \
+		(PROTECT_BP0_MASK & _val))
+
+#define ALL_BP_MASK				(PROTECT_BP3_MASK \
+						| PROTECT_BP2_MASK \
+						| PROTECT_BP1_MASK \
+						| PROTECT_BP0_MASK)
+
+#define FEATURE_ECC_ENABLE			(1 << 4)
+#define FEATURE_QE_ENABLE			(1 << 0)
+
+/* read nand id or nand status, return from nand data length */
+#define MAX_NANDINFO_LEN			0x10
+
+/*****************************************************************************/
+#define FMC_OP					0x3c
+#define fmc_op_dummy_en(_en)			((_en) << 8)
+#define fmc_op_cmd1_en(_en)			((_en) << 7)
+#define fmc_op_addr_en(_en)			((_en) << 6)
+#define fmc_op_write_data_en(_en)		((_en) << 5)
+#define fmc_op_cmd2_en(_en)			((_en) << 4)
+#define fmc_op_wait_ready_en(_en)		((_en) << 3)
+#define fmc_op_read_data_en(_en)		((_en) << 2)
+#define fmc_op_read_status_en(_en)		((_en) << 1)
+#define FMC_OP_REG_OP_START			1
+
+/*****************************************************************************/
+#define FMC_DMA_LEN				0x40
+#define fmc_dma_len_set(_len)			((_len) & 0x0fffffff)
+#define byte_to_mb(_x)				((_x) >> 20)
+/*****************************************************************************/
+#define FMC_DMA_AHB_CTRL			0x48
+#define FMC_DMA_AHB_CTRL_DMA_PP_EN		(1 << 3)
+#define FMC_DMA_AHB_CTRL_BURST16_EN		(1 << 2)
+#define FMC_DMA_AHB_CTRL_BURST8_EN		(1 << 1)
+#define FMC_DMA_AHB_CTRL_BURST4_EN		1
+
+#define ALL_BURST_ENABLE			(FMC_DMA_AHB_CTRL_BURST16_EN \
+						| FMC_DMA_AHB_CTRL_BURST8_EN \
+						| FMC_DMA_AHB_CTRL_BURST4_EN)
+
+#define FMC_DMA_ADDR_OFFSET			4096
+
+/*****************************************************************************/
+#define FMC_DMA_SADDR_D0			0x4c
+
+/*****************************************************************************/
+#define FMC_DMA_SADDR_D1			0x50
+
+/*****************************************************************************/
+#define FMC_DMA_SADDR_D2			0x54
+
+/*****************************************************************************/
+#define FMC_DMA_SADDR_D3			0x58
+
+/*****************************************************************************/
+#define FMC_DMA_SADDR_OOB			0x5c
+
+/*****************************************************************************/
+#define FMC_DMA_SADDRH_D0			0x200
+#define FMC_DMA_SADDRH_SHIFT		0x3LL
+#define FMC_DMA_SADDRH_MASK			(FMC_DMA_SADDRH_SHIFT << 32)
+
+/*****************************************************************************/
+#define FMC_DMA_SADDRH_OOB			0x210
+
+/*****************************************************************************/
+#define FMC_DMA_BLK_SADDR			0x60
+#define fmc_dma_blk_saddr_set(_addr)		((_addr) & 0xffffff)
+
+/*****************************************************************************/
+#define FMC_DMA_BLK_LEN				0x64
+#define fmc_dma_blk_len_set(_len)		((_len) & 0xffff)
+
+/*****************************************************************************/
+#define FMC_OP_CTRL				0x68
+#define op_ctrl_rd_opcode(_code)		(((_code) & 0xff) << 16)
+#define op_ctrl_wr_opcode(_code)		(((_code) & 0xff) << 8)
+#define op_ctrl_rd_op_sel(_op)			(((_op) & 0x3) << 4)
+#define op_ctrl_dma_op(_type)			((_type) << 2)
+#define op_ctrl_rw_op(_op)			((_op) << 1)
+#define OP_CTRL_DMA_OP_READY			1
+
+#define RD_OP_READ_ALL_PAGE			0x0
+#define RD_OP_READ_OOB				0x1
+#define RD_OP_BLOCK_READ			0x2
+
+#define RD_OP_SHIFT				4
+#define RD_OP_MASK				(0x3 << RD_OP_SHIFT)
+
+#define OP_TYPE_DMA				0x0
+#define OP_TYPE_REG				0x1
+
+#define RW_OP_READ				0x0
+#define RW_OP_WRITE				0x1
+
+/*****************************************************************************/
+#define FMC_OP_PARA				0x70
+#define FMC_OP_PARA_RD_OOB_ONLY			(1 << 1)
+
+/*****************************************************************************/
+#define FMC_BOOT_SET				0x74
+#define FMC_BOOT_SET_DEVICE_ECC_EN		(1 << 3)
+#define FMC_BOOT_SET_BOOT_QUAD_EN		(1 << 1)
+
+/*****************************************************************************/
+#define FMC_STATUS				0xac
+
+#define GET_OP					0
+#define SET_OP					1
+
+#define STATUS_ECC_MASK				(0x3 << 4)
+#define STATUS_P_FAIL_MASK			(1 << 3)
+#define STATUS_E_FAIL_MASK			(1 << 2)
+#define STATUS_WEL_MASK				(1 << 1)
+#define STATUS_OIP_MASK				(1 << 0)
+
+/*****************************************************************************/
+#define FMC_VERSION				0xbc
+
+/* Fmc IP version */
+#define FMC_VER_100				0x100
+
+#endif /* End of CONFIG_FMC */
+
+/*****************************************************************************/
+#define DISABLE					0
+#define ENABLE					1
+
+/*****************************************************************************/
+/* DMA address align with 32 bytes. */
+#define FMC_DMA_ALIGN				32
+
+#define FMC_CHIP_DELAY				25
+
+#define TMP_BUF_LEN				128
+/*****************************************************************************/
+#define fmc_read(_host, _reg) \
+	readl((uintptr_t)((char *)_host->regbase + (_reg)))
+
+#define fmc_write(_host, _reg, _value) \
+	writel((u_int)(_value), (uintptr_t)((char *)_host->regbase + (_reg)))
+
+#define get_page_index(host) \
+		((host->addr_value[0] >> 16) | (host->addr_value[1] << 16))
+
+/*****************************************************************************/
+#define db_msg(_fmt, arg...) \
+	printf("%s(%d): " _fmt, __func__, __LINE__, ##arg);
+
+#define db_bug(fmt, args...) \
+	do { \
+		printf("%s(%d): BUG: " fmt, __FILE__, __LINE__, ##args); \
+		while (1) ; \
+	} while (0)
+
+/*****************************************************************************/
+
+#ifdef CONFIG_MINI_BOOT
+#define FMC_INFO    0
+#else
+#define FMC_INFO    1
+#endif
+
+#define BT_DBG		0 /* Boot init debug print */
+#define ER_DBG		0 /* Erase debug print */
+#define WR_DBG		0 /* Write debug print */
+#define RD_DBG		0 /* Read debug print */
+#define QE_DBG		0 /* Quad Enable debug print */
+#define OP_DBG		0 /* OP command debug print */
+#define DMA_DB		0 /* DMA read or write debug print */
+#define AC_DBG		0 /* 3-4byte Address Cycle */
+#define SR_DBG		0 /* Status Register debug print */
+#define CR_DBG		0 /* Config Register debug print */
+#define FT_DBG		0 /* Features debug print */
+#define WE_DBG		0 /* Write Enable debug print */
+#define BP_DBG		0 /* Block Protection debug print */
+#define EC_DBG		0 /* enable/disable ecc0 and randomizer */
+#define DTR_DB		0 /* 4DTR debug print */
+#define RST_DB		0 /* enable/disable reset pin */
+#define REG_DB		0 /* operation debug print */
+
+#define fmc_pr(_type, _fmt, arg...) \
+	do { \
+		if (_type) \
+			db_msg(_fmt, ##arg) \
+	} while (0)
+
+/*****************************************************************************/
+#define FMC_WAIT_TIMEOUT	400000  /* 4s equals 400000*10us */
+
+#define fmc_cmd_wait_cpu_finish(_host) \
+	do { \
+		unsigned regval, timeout = FMC_WAIT_TIMEOUT; \
+		do { \
+			udelay(10);\
+			regval = fmc_read((_host), FMC_OP); \
+			--timeout; \
+		} while ((regval & FMC_OP_REG_OP_START) && timeout); \
+		if (!timeout) \
+			db_msg("Error: Wait cmd cpu finish timeout!\n"); \
+	} while (0)
+
+/*****************************************************************************/
+#define fmc_dma_wait_int_finish(_host) \
+	do { \
+		unsigned regval, timeout = FMC_WAIT_TIMEOUT; \
+		do { \
+			udelay(10);\
+			regval = fmc_read((_host), FMC_INT); \
+			--timeout; \
+		} while ((!(regval & FMC_INT_OP_DONE) && timeout)); \
+		if (!timeout) { \
+			debug_register_dump(); \
+			db_msg("Error: Wait dma int finish timeout!\n"); \
+		} \
+	} while (0)
+
+/*****************************************************************************/
+#define fmc_dma_wait_cpu_finish(_host) \
+	do { \
+		unsigned regval, timeout = FMC_WAIT_TIMEOUT; \
+		do { \
+			udelay(10);\
+			regval = fmc_read((_host), FMC_OP_CTRL); \
+			--timeout; \
+		} while ((regval & OP_CTRL_DMA_OP_READY) && timeout); \
+		if (!timeout) { \
+			debug_register_dump(); \
+			db_msg("Error: Wait dma cpu finish timeout!\n"); \
+		} \
+	} while (0)
+
+/*****************************************************************************/
+#define clk_2x(_clk)    (((_clk) + 1) >> 1)
+#define clk_4x(_clk)    (((_clk) + 1) >> 2)
+
+enum OP {
+	READ = 1,
+	WRITE,
+	ERASE,
+};
+
+/*****************************************************************************/
+struct fmc_cmd_op {
+	unsigned char cs;
+	unsigned char cmd;
+	unsigned char l_cmd;
+	unsigned char addr_h;
+	unsigned int addr_l;
+	unsigned int data_no;
+	unsigned short option;
+	unsigned short op_cfg;
+};
+/*****************************************************************************/
+char *ulltostr(unsigned long long size);
+
+void debug_register_dump(void);
+
+int fmc_ip_ver_check(void);
+
+void fmc_dev_type_switch(unsigned char type);
+
+void *get_fmc_ip(void);
+
+unsigned char *get_cs_number(unsigned char cs);
+
+unsigned int get_fmc_boot_mode (void);
+
+#endif /* End of __FMC_COMMON_H__ */
+
diff -uraN u-boot-2016.11/include/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/.gitignore
--- u-boot-2016.11/include/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1,5 +0,0 @@
-/autoconf.mk*
-/bmp_logo.h
-/bmp_logo_data.h
-/config.h
-/license.h
diff -uraN u-boot-2016.11/include/gk7205v200_vo.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/gk7205v200_vo.h
--- u-boot-2016.11/include/gk7205v200_vo.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/gk7205v200_vo.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,147 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __VENDOR_VO_H__
+#define __VENDOR_VO_H__
+
+#define CFG_MAXARGS 10
+
+#define PIC_MAX_WIDTH   1920
+#define PIC_MAX_HEIGHT  1080
+#define PIC_MIN_LENTH   16
+
+/* VO video output interface type */
+#define VO_INTF_CVBS        (0x01L<<0)
+#define VO_INTF_YPBPR       (0x01L<<1)
+#define VO_INTF_VGA         (0x01L<<2)
+#define VO_INTF_BT656       (0x01L<<3)
+#define VO_INTF_BT1120      (0x01L<<4)
+#define VO_INTF_HDMI        (0x01L<<5)
+#define VO_INTF_LCD         (0x01L<<6)
+#define VO_INTF_BT656_H     (0x01L<<7)
+#define VO_INTF_BT656_L     (0x01L<<8)
+#define VO_INTF_LCD_6BIT    (0x01L<<9)
+#define VO_INTF_LCD_8BIT    (0x01L<<10)
+#define VO_INTF_LCD_16BIT   (0x01L<<11)
+#define VO_INTF_LCD_18BIT   (0x01L<<12)
+#define VO_INTF_LCD_24BIT   (0x01L<<13)
+#define VO_INTF_MIPI        (0x01L<<14)
+#define VO_INTF_MIPI_SLAVE  (0x01L<<15)
+
+typedef enum {
+    VO_OUTPUT_PAL = 0,               /* PAL standard*/
+    VO_OUTPUT_NTSC,                  /* NTSC standard */
+
+    VO_OUTPUT_1080P24,               /* 1920 x 1080 at 24 Hz. */
+    VO_OUTPUT_1080P25,               /* 1920 x 1080 at 25 Hz. */
+    VO_OUTPUT_1080P30,               /* 1920 x 1080 at 30 Hz. */
+
+    VO_OUTPUT_720P50,                /* 1280 x  720 at 50 Hz. */
+    VO_OUTPUT_720P60,                /* 1280 x  720 at 60 Hz. */
+    VO_OUTPUT_1080I50,               /* 1920 x 1080 at 50 Hz, interlace. */
+    VO_OUTPUT_1080I60,               /* 1920 x 1080 at 60 Hz, interlace. */
+    VO_OUTPUT_1080P50,               /* 1920 x 1080 at 50 Hz. */
+    VO_OUTPUT_1080P60,               /* 1920 x 1080 at 60 Hz. */
+
+    VO_OUTPUT_576P50,                /* 720  x  576 at 50 Hz. */
+    VO_OUTPUT_480P60,                /* 720  x  480 at 60 Hz. */
+
+    VO_OUTPUT_800x600_60,            /* VESA 800 x 600 at 60 Hz (non-interlaced) */
+    VO_OUTPUT_1024x768_60,           /* VESA 1024 x 768 at 60 Hz (non-interlaced) */
+    VO_OUTPUT_1280x1024_60,          /* VESA 1280 x 1024 at 60 Hz (non-interlaced) */
+    VO_OUTPUT_1366x768_60,           /* VESA 1366 x 768 at 60 Hz (non-interlaced) */
+    VO_OUTPUT_1440x900_60,           /* VESA 1440 x 900 at 60 Hz (non-interlaced) CVT Compliant */
+    VO_OUTPUT_1280x800_60,           /* 1280*800@60Hz VGA@60Hz*/
+    VO_OUTPUT_1600x1200_60,          /* VESA 1600 x 1200 at 60 Hz (non-interlaced) */
+    VO_OUTPUT_1680x1050_60,          /* VESA 1680 x 1050 at 60 Hz (non-interlaced) */
+    VO_OUTPUT_1920x1200_60,          /* VESA 1920 x 1600 at 60 Hz (non-interlaced) CVT (Reduced Blanking)*/
+    VO_OUTPUT_640x480_60,            /* VESA 640 x 480 at 60 Hz (non-interlaced) CVT */
+    VO_OUTPUT_960H_PAL,              /* ITU-R BT.1302 960 x 576 at 50 Hz (interlaced)*/
+    VO_OUTPUT_960H_NTSC,             /* ITU-R BT.1302 960 x 480 at 60 Hz (interlaced)*/
+    VO_OUTPUT_1920x2160_30,          /* 1920x2160_30 */
+    VO_OUTPUT_2560x1440_30,          /* 2560x1440_30 */
+    VO_OUTPUT_2560x1440_60,          /* 2560x1440_60 */
+    VO_OUTPUT_2560x1600_60,          /* 2560x1600_60 */
+    VO_OUTPUT_3840x2160_24,          /* 3840x2160_24 */
+    VO_OUTPUT_3840x2160_25,          /* 3840x2160_25 */
+    VO_OUTPUT_3840x2160_30,          /* 3840x2160_30 */
+    VO_OUTPUT_3840x2160_50,          /* 3840x2160_50 */
+    VO_OUTPUT_3840x2160_60,          /* 3840x2160_60 */
+    VO_OUTPUT_4096x2160_24,          /* 4096x2160_24 */
+    VO_OUTPUT_4096x2160_25,          /* 4096x2160_25 */
+    VO_OUTPUT_4096x2160_30,          /* 4096x2160_30 */
+    VO_OUTPUT_4096x2160_50,          /* 4096x2160_50 */
+    VO_OUTPUT_4096x2160_60,          /* 4096x2160_60 */
+    VO_OUTPUT_320x240_60,            /* For ota5182 at 60 Hz (8bit)  */
+    VO_OUTPUT_320x240_50,            /* For ili9342 at 50 Hz (6bit)  */
+    VO_OUTPUT_240x320_50,            /* For ili9341 at 50 Hz (6bit)  */
+    VO_OUTPUT_240x320_60,            /* For ili9341 at 60 Hz (16bit) */
+    VO_OUTPUT_800x600_50,            /* For LCD     at 50 Hz (24bit) */
+    VO_OUTPUT_720x1280_60,           /* For MIPI DSI Tx 720 x1280 at 60 Hz */
+    VO_OUTPUT_1080x1920_60,          /* For MIPI DSI Tx 1080x1920 at 60 Hz */
+    VO_OUTPUT_7680x4320_30,          /* For HDMI2.0 at 30 Hz         */
+    VO_OUTPUT_USER,                  /* User timing. */
+
+    VO_OUTPUT_BUTT
+} vo_intf_sync;
+
+typedef enum {
+    VO_DEV_DHD0  = 0,        /* high definition device */
+    VO_DEV_BUTT
+} vo_dev;
+
+typedef enum {
+    VO_GRAPHC_G0 = 0,
+    VO_GRAPHC_G1 = 1,
+    VO_GRAPHC_BUTT
+} vo_graphic;
+
+typedef enum {
+    VO_LAYER_VHD0 = 0,
+    VO_LAYER_VHD1 = 1,
+    VO_LAYER_VP = 2,
+    VO_LAYER_VSD0 = 3,
+    VO_LAYER_G0 = 4,    /* fb0 */
+    VO_LAYER_G1 = 5,    /* fb2 */
+    VO_LAYER_HC0 = 6,   /* G2 is HC0 --- fb3 */
+    VO_LAYER_HC1 = 7,   /* G3 is HC1  --- fb4 */
+    VO_LAYER_G4 = 8,    /* fb1 */
+    VO_LAYER_WBC_G0 = 9,
+    VO_LAYER_WBC_G4 = 10,
+    VO_LAYER_WBC_D = 11,
+    VO_LAYER_BUTT
+} gk_vo_layer;
+
+#define VO_LAYER_G2 VO_LAYER_HC0
+
+typedef enum {
+    VO_CSC_MATRIX_IDENTITY = 0,       /* Identity CSC matrix. */
+
+    VO_CSC_MATRIX_BT601_TO_BT709,     /* BT601 to BT709 */
+    VO_CSC_MATRIX_BT709_TO_BT601,     /* BT709 to BT601 */
+
+    VO_CSC_MATRIX_BT601_TO_RGB_PC,    /* BT601 to RGB */
+    VO_CSC_MATRIX_BT709_TO_RGB_PC,    /* BT709 to RGB */
+
+    VO_CSC_MATRIX_RGB_TO_BT601_PC,    /* RGB to BT601 FULL */
+    VO_CSC_MATRIX_RGB_TO_BT709_PC,    /* RGB to BT709 FULL */
+
+    VO_CSC_MATRIX_RGB_TO_BT2020_PC,   /* RGB to BT.2020 */
+    VO_CSC_MATRIX_BT2020_TO_RGB_PC,   /* BT.2020 to RGB */
+
+    VO_CSC_MATRIX_RGB_TO_BT601_TV,    /* RGB to BT601 LIMIT */
+    VO_CSC_MATRIX_RGB_TO_BT709_TV,    /* RGB to BT709 LIMIT */
+
+    VO_CSC_MATRIX_BUTT
+} vo_csc_matrix;
+
+typedef struct {
+    unsigned int x;
+    unsigned int y;
+    unsigned int w;
+    unsigned int h;
+} gk_vo_rect;
+
+#endif
+
diff -uraN u-boot-2016.11/include/image.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/image.h
--- u-boot-2016.11/include/image.h	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/image.h	2021-06-07 13:01:32.000000000 +0300
@@ -67,13 +67,15 @@
 #  endif
 # else
 #  define CONFIG_CRC32		/* FIT images need CRC32 support */
+#ifndef CONFIG_GK_MC
 #  define CONFIG_MD5		/* and MD5 */
 #  define CONFIG_SHA1		/* and SHA1 */
 #  define CONFIG_SHA256		/* and SHA256 */
-#  define IMAGE_ENABLE_CRC32	1
 #  define IMAGE_ENABLE_MD5	1
 #  define IMAGE_ENABLE_SHA1	1
 #  define IMAGE_ENABLE_SHA256	1
+#endif
+#  define IMAGE_ENABLE_CRC32	1
 # endif
 
 #ifdef CONFIG_FIT_DISABLE_SHA256
@@ -164,6 +166,7 @@
 	IH_OS_OSE,			/* OSE		*/
 	IH_OS_PLAN9,			/* Plan 9	*/
 	IH_OS_OPENRTOS,		/* OpenRTOS	*/
+	IH_OS_TEE,			/* Trusted Execution Environment */
 
 	IH_OS_COUNT,
 };
@@ -861,12 +864,14 @@
 #define FIT_IMAGES_PATH		"/images"
 #define FIT_CONFS_PATH		"/configurations"
 
-/* hash/signature node */
+/* hash/signature/key node */
 #define FIT_HASH_NODENAME	"hash"
 #define FIT_ALGO_PROP		"algo"
 #define FIT_VALUE_PROP		"value"
 #define FIT_IGNORE_PROP		"uboot-ignore"
 #define FIT_SIG_NODENAME	"signature"
+#define FIT_KEY_REQUIRED	"required"
+#define FIT_KEY_HINT		"key-name-hint"
 
 /* image node */
 #define FIT_DATA_PROP		"data"
@@ -987,6 +992,25 @@
 int fit_check_format(const void *fit);
 
 int fit_conf_find_compat(const void *fit, const void *fdt);
+
+/**
+ * fit_conf_get_node - get node offset for configuration of a given unit name
+ * @fit: pointer to the FIT format image header
+ * @conf_uname: configuration node unit name (NULL to use default)
+ *
+ * fit_conf_get_node() finds a configuration (within the '/configurations'
+ * parent node) of a provided unit name. If configuration is found its node
+ * offset is returned to the caller.
+ *
+ * When NULL is provided in second argument fit_conf_get_node() will search
+ * for a default configuration node instead. Default configuration node unit
+ * name is retrieved from FIT_DEFAULT_PROP property of the '/configurations'
+ * node.
+ *
+ * returns:
+ *     configuration node offset when found (>=0)
+ *     negative number on failure (FDT_ERR_* code)
+ */
 int fit_conf_get_node(const void *fit, const char *conf_uname);
 
 /**
diff -uraN u-boot-2016.11/include/linux/mtd/mtd.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/linux/mtd/mtd.h
--- u-boot-2016.11/include/linux/mtd/mtd.h	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/linux/mtd/mtd.h	2021-06-07 13:01:32.000000000 +0300
@@ -151,6 +151,7 @@
 
 	uint32_t oobsize;   // Amount of OOB data per block (e.g. 16)
 	uint32_t oobavail;  // Available OOB bytes per block
+	uint32_t oobused;   /* yaffs2 use oob size, it smaller than oobsize */
 
 	/*
 	 * If erasesize is a power of 2 then the shift is stored in
@@ -341,6 +342,31 @@
 int mtd_block_isbad(struct mtd_info *mtd, loff_t ofs);
 int mtd_block_markbad(struct mtd_info *mtd, loff_t ofs);
 
+/*
+ *  this interface for Tool and application used.
+ */
+struct mtd_info_ex
+{
+	u_char    type;      /* chip type  MTD_NORFLASH / MTD_NANDFLASH */
+	uint64_t  chipsize;  /* total size of the nand/spi chip */
+	uint32_t erasesize;
+	uint32_t pagesize;
+	uint32_t numchips;  /* number of nand chips */
+
+	uint32_t oobsize;
+	uint32_t addrcycle;
+	uint32_t ecctype;
+
+	u_char    ids[8];
+	uint32_t id_length;
+	char      name[16]; /* chip names */
+	int hostver; /* host controller version */
+};
+
+extern struct mtd_info_ex * get_nand_info(void);
+
+extern struct mtd_info_ex * get_spiflash_info(void);
+
 #ifndef __UBOOT__
 static inline int mtd_suspend(struct mtd_info *mtd)
 {
diff -uraN u-boot-2016.11/include/linux/mtd/nand.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/linux/mtd/nand.h
--- u-boot-2016.11/include/linux/mtd/nand.h	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/linux/mtd/nand.h	2021-06-07 13:01:32.000000000 +0300
@@ -18,6 +18,7 @@
 
 #include <config.h>
 
+#include <asm/cache.h>
 #include <linux/compat.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/flashchip.h>
@@ -804,6 +805,9 @@
 #define NAND_MFR_SANDISK	0x45
 #define NAND_MFR_INTEL		0x89
 #define NAND_MFR_ATO		0x9b
+#define NAND_MFR_HEYANGTEK	0xc9
+#define NAND_MFR_DOSILICON	0xe5
+#define NAND_MFR_FIDELIX	0xf8
 
 /* The maximum expected count of bytes in the NAND ID sequence */
 #define NAND_MAX_ID_LEN 8
@@ -1101,4 +1105,19 @@
 				void *ecc, int ecclen,
 				void *extraoob, int extraooblen,
 				int threshold);
+
+static inline char *get_ecctype_str(int ecctype)
+{
+#if defined(CONFIG_FMC_SPI_NAND)
+	static char *ecctype_string[] = {
+		"None", "1bit/512Byte", "4bits/512Byte", "8bits/512Byte",
+		"24bits/1K", "unknown", "40bits/1K", "unknown"};
+	return ecctype_string[(ecctype + 1) / 2];
+#else
+	static char *ecctype_string[] = {
+		"None", "1bit/512Byte", "4bits/512Byte", "8bits/512Byte",
+		"24bits/1K", "40bits/1K", "unknown", "unknown"};
+	return ecctype_string[((unsigned int)ecctype & 0x0F)];
+#endif
+}
 #endif /* __LINUX_MTD_NAND_H */
diff -uraN u-boot-2016.11/include/linux/string.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/linux/string.h
--- u-boot-2016.11/include/linux/string.h	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/linux/string.h	2021-06-07 13:01:32.000000000 +0300
@@ -13,7 +13,7 @@
 extern char * strtok(char *,const char *);
 extern char * strsep(char **,const char *);
 extern __kernel_size_t strspn(const char *,const char *);
-
+void udc_puts(const char *s);
 
 /*
  * Include machine specific inline routines
diff -uraN u-boot-2016.11/include/linux/usb/ch9.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/linux/usb/ch9.h
--- u-boot-2016.11/include/linux/usb/ch9.h	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/linux/usb/ch9.h	2021-06-07 13:01:32.000000000 +0300
@@ -418,6 +418,12 @@
 #define USB_ENDPOINT_XFER_INT		3
 #define USB_ENDPOINT_MAX_ADJUSTABLE	0x80
 
+#define USB_ENDPOINT_MAXP_MASK		0x07ff
+#define USB_EP_MAXP_MULT_SHIFT		11
+#define USB_EP_MAXP_MULT_MASK		(3 << USB_EP_MAXP_MULT_SHIFT)
+#define USB_EP_MAXP_MULT(m)		\
+	(((m) & USB_EP_MAXP_MULT_MASK) >> USB_EP_MAXP_MULT_SHIFT)
+
 /* The USB 3.0 spec redefines bits 5:4 of bmAttributes as interrupt ep type. */
 #define USB_ENDPOINT_INTRTYPE		0x30
 #define USB_ENDPOINT_INTR_PERIODIC	(0 << 4)
@@ -625,6 +631,20 @@
 	return __le16_to_cpu(get_unaligned(&epd->wMaxPacketSize));
 }
 
+/**
+ * usb_endpoint_maxp_mult - get endpoint's transactional opportunities
+ * @epd: endpoint to be checked
+ *
+ * Return @epd's wMaxPacketSize[12:11] + 1
+ */
+static inline int
+usb_endpoint_maxp_mult(const struct usb_endpoint_descriptor *epd)
+{
+	int maxp = __le16_to_cpu(epd->wMaxPacketSize);
+
+	return USB_EP_MAXP_MULT(maxp) + 1;
+}
+
 static inline int usb_endpoint_interrupt_type(
 		const struct usb_endpoint_descriptor *epd)
 {
diff -uraN u-boot-2016.11/include/lmb.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/lmb.h
--- u-boot-2016.11/include/lmb.h	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/lmb.h	2021-06-07 13:01:32.000000000 +0300
@@ -32,6 +32,8 @@
 extern struct lmb lmb;
 
 extern void lmb_init(struct lmb *lmb);
+extern void lmb_init_and_reserve(struct lmb *lmb, phys_addr_t base,
+				 phys_size_t size, void *fdt_blob);
 extern long lmb_add(struct lmb *lmb, phys_addr_t base, phys_size_t size);
 extern long lmb_reserve(struct lmb *lmb, phys_addr_t base, phys_size_t size);
 extern phys_addr_t lmb_alloc(struct lmb *lmb, phys_size_t size, ulong align);
@@ -39,6 +41,8 @@
 			    phys_addr_t max_addr);
 extern phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align,
 			      phys_addr_t max_addr);
+extern phys_addr_t lmb_alloc_addr(struct lmb *lmb, phys_addr_t base,
+				  phys_size_t size);
 extern int lmb_is_reserved(struct lmb *lmb, phys_addr_t addr);
 extern long lmb_free(struct lmb *lmb, phys_addr_t base, phys_size_t size);
 
diff -uraN u-boot-2016.11/include/match_table.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/match_table.h
--- u-boot-2016.11/include/match_table.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/match_table.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __MATCH_TABLE_H__
+#define __MATCH_TABLE_H__
+
+/*****************************************************************************/
+struct match_reg_type {
+	int reg;
+	int type;
+};
+
+struct match_type_str {
+	int type;
+	const char *str;
+};
+
+struct match_t {
+	int type;
+	int reg;
+	void *data;
+};
+
+/*****************************************************************************/
+#define match_set_type_reg(_type, _reg)   {(_type), (_reg), (void *)0}
+#define match_set_type_data(_type, _data) {(_type), 0, (void *)(_data)}
+#define match_set(_type, _reg, _data)     {(_type), (_reg), (void *)(_data)}
+
+/*****************************************************************************/
+int reg2type(struct match_reg_type *table, int length, int reg, int def);
+
+int type2reg(struct match_reg_type *table, int length, int type, int def);
+
+int str2type(struct match_type_str *table, int length, const char *str,
+			 int size, int def);
+
+const char *type2str(struct match_type_str *table, int length, int type,
+					 const char *def);
+
+int match_reg_to_type(struct match_t *table, int nr_table, int reg, int def);
+
+int match_type_to_reg(struct match_t *table, int nr_table, int type, int def);
+
+int match_data_to_type(struct match_t *table, int nr_table, const char *data,
+					   int size, int def);
+
+void *match_type_to_data(struct match_t *table, int nr_table, int type,
+						 void *def);
+
+/*****************************************************************************/
+
+#endif /* End of __MATCH_TABLE_H__ */
diff -uraN u-boot-2016.11/include/mmc.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/mmc.h
--- u-boot-2016.11/include/mmc.h	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/mmc.h	2021-06-07 13:01:32.000000000 +0300
@@ -58,6 +58,13 @@
 #define MMC_MODE_8BIT		(1 << 3)
 #define MMC_MODE_SPI		(1 << 4)
 #define MMC_MODE_DDR_52MHz	(1 << 5)
+#define MMC_MODE_HS200_1_8V	(1 << 6)
+#define MMC_MODE_HS200_1_2V	(1 << 7)
+#define MMC_MODE_HS200		(MMC_MODE_HS200_1_8V | MMC_MODE_HS200_1_2V)
+#define MMC_MODE_HS400_1_8V	(1 << 8)
+#define MMC_MODE_HS400_1_2V	(1 << 9)
+#define MMC_MODE_HS400		(MMC_MODE_HS400_1_8V | MMC_MODE_HS400_1_2V)
+#define MMC_MODE_HS400ES	(1 << 10)
 
 #define SD_DATA_4BIT	0x00040000
 
@@ -82,6 +89,8 @@
 #define MMC_CMD_SET_BLOCKLEN		16
 #define MMC_CMD_READ_SINGLE_BLOCK	17
 #define MMC_CMD_READ_MULTIPLE_BLOCK	18
+#define MMC_CMD_SEND_TUNING_BLOCK	19
+#define MMC_CMD_SEND_TUNING_BLOCK_HS200	21
 #define MMC_CMD_SET_BLOCK_COUNT         23
 #define MMC_CMD_WRITE_SINGLE_BLOCK	24
 #define MMC_CMD_WRITE_MULTIPLE_BLOCK	25
@@ -181,6 +190,7 @@
 #define EXT_CSD_BOOT_BUS_WIDTH		177
 #define EXT_CSD_PART_CONF		179	/* R/W */
 #define EXT_CSD_BUS_WIDTH		183	/* R/W */
+#define EXT_CSD_STROBE_SUPPORT		184	/* RO */
 #define EXT_CSD_HS_TIMING		185	/* R/W */
 #define EXT_CSD_REV			192	/* RO */
 #define EXT_CSD_CARD_TYPE		196	/* RO */
@@ -192,6 +202,9 @@
 /*
  * EXT_CSD field definitions
  */
+#define EXT_CSD_WR_REL_VALUE		(0x1f)
+#define EXT_CSD_RST_N_EN_MASK		0x3
+#define EXT_CSD_RST_N_ENABLED		(1<<0)	/* RST_n is enabled on card */
 
 #define EXT_CSD_CMD_SET_NORMAL		(1 << 0)
 #define EXT_CSD_CMD_SET_SECURE		(1 << 1)
@@ -203,12 +216,27 @@
 #define EXT_CSD_CARD_TYPE_DDR_1_2V	(1 << 3)
 #define EXT_CSD_CARD_TYPE_DDR_52	(EXT_CSD_CARD_TYPE_DDR_1_8V \
 					| EXT_CSD_CARD_TYPE_DDR_1_2V)
+#define EXT_CSD_CARD_TYPE_HS200_1_8V    (1<<4)  /* Card can run at 200MHz */
+#define EXT_CSD_CARD_TYPE_HS200_1_2V    (1<<5)  /* Card can run at 200MHz */
+						/* SDR mode @1.2V I/O */
+#define EXT_CSD_CARD_TYPE_HS200		(EXT_CSD_CARD_TYPE_HS200_1_8V \
+					| EXT_CSD_CARD_TYPE_HS200_1_2V)
+#define EXT_CSD_CARD_TYPE_HS400_1_8V    (1<<6)  /* Card can run at 200MHz DDR, 1.8V */
+#define EXT_CSD_CARD_TYPE_HS400_1_2V    (1<<7)  /* Card can run at 200MHz DDR, 1.2V */
+#define EXT_CSD_CARD_TYPE_HS400		(EXT_CSD_CARD_TYPE_HS400_1_8V \
+					| EXT_CSD_CARD_TYPE_HS400_1_2V)
 
 #define EXT_CSD_BUS_WIDTH_1	0	/* Card is in 1 bit mode */
 #define EXT_CSD_BUS_WIDTH_4	1	/* Card is in 4 bit mode */
 #define EXT_CSD_BUS_WIDTH_8	2	/* Card is in 8 bit mode */
 #define EXT_CSD_DDR_BUS_WIDTH_4	5	/* Card is in 4 bit DDR mode */
 #define EXT_CSD_DDR_BUS_WIDTH_8	6	/* Card is in 8 bit DDR mode */
+#define EXT_CSD_BUS_WIDTH_STROBE (1 << 7) /* Enhanced strobe mode */
+
+#define EXT_CSD_TIMING_BC   0   /* Backwards compatility */
+#define EXT_CSD_TIMING_HS   1   /* High speed */
+#define EXT_CSD_TIMING_HS200    2   /* HS200 */
+#define EXT_CSD_TIMING_HS400    3   /* HS400 */
 
 #define EXT_CSD_BOOT_ACK_ENABLE			(1 << 6)
 #define EXT_CSD_BOOT_PARTITION_ENABLE		(1 << 3)
@@ -378,6 +406,9 @@
 	int (*init)(struct mmc *mmc);
 	int (*getcd)(struct mmc *mmc);
 	int (*getwp)(struct mmc *mmc);
+	void (*hs400_enable_es)(struct mmc *mmc, bool enable);
+	int (*execute_tuning)(struct mmc *mmc, unsigned int opcode);
+	int (*card_busy)(struct mmc *mmc);
 };
 #endif
 
@@ -417,6 +448,8 @@
 	int high_capacity;
 	uint bus_width;
 	uint clock;
+#define MMC_HIGH_52_MAX_DTR 52000000
+#define MMC_HS200_MAX_DTR   150000000
 	uint card_caps;
 	uint ocr;
 	uint dsr;
@@ -452,6 +485,21 @@
 #ifdef CONFIG_DM_MMC
 	struct udevice *dev;	/* Device for this MMC controller */
 #endif
+	u8 timing;
+#define MMC_TIMING_LEGACY   0
+#define MMC_TIMING_MMC_HS   1
+#define MMC_TIMING_SD_HS    2
+#define MMC_TIMING_UHS_SDR12    3
+#define MMC_TIMING_UHS_SDR25    4
+#define MMC_TIMING_UHS_SDR50    5
+#define MMC_TIMING_UHS_SDR104   6
+#define MMC_TIMING_UHS_DDR50    7
+#define MMC_TIMING_MMC_DDR52    8
+#define MMC_TIMING_MMC_HS200    9
+#define MMC_TIMING_MMC_HS400    10
+	u8 strobe_enhanced;
+	u8 dev_num;
+	u32 ocr_from_bootrom;
 };
 
 struct mmc_hwpart_conf {
@@ -523,6 +571,8 @@
 int board_mmc_getwp(struct mmc *mmc);
 #endif
 
+int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd);
+int mmc_set_boot_config(struct mmc *mmc);
 int mmc_set_dsr(struct mmc *mmc, u16 val);
 /* Function to change the size of boot partition and rpmb partitions */
 int mmc_boot_partition_size_change(struct mmc *mmc, unsigned long bootsize,
diff -uraN u-boot-2016.11/include/nand.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/nand.h
--- u-boot-2016.11/include/nand.h	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/nand.h	2021-06-07 13:01:32.000000000 +0300
@@ -45,6 +45,8 @@
 extern int nand_curr_device;
 extern struct mtd_info *nand_info[];
 
+extern unsigned int ecc0_flag;
+
 static inline int nand_read(struct mtd_info *info, loff_t ofs, size_t *len,
 			    u_char *buf)
 {
@@ -98,6 +100,13 @@
 
 typedef struct nand_erase_options nand_erase_options_t;
 
+void nand_fill_ecc(struct nand_chip *chip, uint8_t *oob, size_t len);
+
+int nand_read_yaffs_skip_bad(struct mtd_info *mtd, loff_t offset, size_t *length,
+		u_char *buffer);
+int nand_write_yaffs_skip_bad(struct mtd_info *mtd, loff_t offset, size_t *length,
+                u_char *buffer);
+
 int nand_read_skip_bad(struct mtd_info *mtd, loff_t offset, size_t *length,
 		       size_t *actual, loff_t lim, u_char *buffer);
 
diff -uraN u-boot-2016.11/include/netdev.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/netdev.h
--- u-boot-2016.11/include/netdev.h	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/netdev.h	2021-06-07 13:01:32.000000000 +0300
@@ -82,6 +82,7 @@
 int armada100_fec_register(unsigned long base_addr);
 int xilinx_ll_temac_eth_init(bd_t *bis, unsigned long base_addr, int flags,
 						unsigned long ctrl_addr);
+int bspeth_initialize(bd_t *bis);
 /*
  * As long as the Xilinx xps_ll_temac ethernet driver has not its own interface
  * exported by a public hader file, we need a global definition at this point.
diff -uraN u-boot-2016.11/include/nfc_common.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/nfc_common.h
--- u-boot-2016.11/include/nfc_common.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/nfc_common.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,181 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __NFC_COMMON_H__
+#define __NFC_COMMON_H__
+
+/*****************************************************************************/
+#include <asm/io.h>
+#include <common.h>
+#include <linux/mtd/nand.h>
+#include <match_table.h>
+#include <fmc_common.h>
+
+/*****************************************************************************/
+#define _512B                               512
+#define _2K                                 2048
+#define _4K                                 4096
+#define _8K                                 8192
+#define _16K                                16384
+
+/*****************************************************************************/
+#define NAND_PAGE_512B                   0
+#define NAND_PAGE_1K                     1
+#define NAND_PAGE_2K                     2
+#define NAND_PAGE_4K                     3
+#define NAND_PAGE_8K                     4
+#define NAND_PAGE_16K                    5
+#define NAND_PAGE_32K                    6
+
+/*****************************************************************************/
+#define NAND_ECC_NONE                    0
+#define NAND_ECC_0BIT                    0
+#define NAND_ECC_1BIT                    1
+#define NAND_ECC_1BIT_512                1
+#define NAND_ECC_4BIT                    2
+#define NAND_ECC_4BIT_512                2
+#define NAND_ECC_4BYTE                   2
+#define NAND_ECC_8BIT                    2
+#define NAND_ECC_8BIT_512                3
+#define NAND_ECC_8BYTE                   3
+#define NAND_ECC_13BIT                   4
+#define NAND_ECC_16BIT                   5
+#define NAND_ECC_18BIT                   6
+#define NAND_ECC_24BIT                   7
+#define NAND_ECC_27BIT                   8
+#define NAND_ECC_28BIT                   9
+#define NAND_ECC_32BIT                   10
+#define NAND_ECC_40BIT                   11
+#define NAND_ECC_41BIT                   12
+#define NAND_ECC_42BIT                   13
+#define NAND_ECC_48BIT                   14
+#define NAND_ECC_60BIT                   15
+#define NAND_ECC_64BIT                   16
+#define NAND_ECC_72BIT                   17
+#define NAND_ECC_80BIT                   18
+
+#define ERSTR_HARDWARE                   "Hardware configuration error."
+#define ERSTR_DRIVER                     "Driver does not support."
+
+#define DISABLE                          0
+#define ENABLE                           1
+
+#define is_randomizer(_dev)        ((_dev)->flags & NAND_RANDOMIZER)
+#define is_hw_auto(_dev)           ((_dev)->flags & NAND_HW_AUTO)
+#define is_synchronous(_dev)       ((_dev)->flags & NAND_SYNCHRONOUS)
+#define is_config_done(_dev)       ((_dev)->flags & NAND_CONFIG_DONE)
+#define is_synchronous_boot(_dev)  ((_dev)->flags & NAND_SYNCHRONOUS_BOOT)
+
+#define NAND_PAGE_SHIFT                  9 /* 512 */
+
+#if defined(CONFIG_FMC_SPI_NAND) || defined(CONFIG_FMC_NAND)
+/*****************************************************************************/
+enum ecc_type {
+	ET_ECC_NONE    = 0x00,
+	ET_ECC_1BIT    = 0x01,
+	ET_ECC_4BIT    = 0x02,
+	ET_ECC_8BIT    = 0x03,
+	ET_ECC_24BIT1K = 0x04,
+	ET_ECC_40BIT1K = 0x05,
+	ET_ECC_64BIT1K = 0x06,
+};
+
+enum page_type {
+	PT_PAGESIZE_512   = 0x00,
+	PT_PAGESIZE_2K    = 0x01,
+	PT_PAGESIZE_4K    = 0x02,
+	PT_PAGESIZE_8K    = 0x03,
+	PT_PAGESIZE_16K   = 0x04,
+};
+
+struct nand_config_info {
+	unsigned int pagetype;
+	unsigned int ecctype;
+	unsigned int oobsize;
+	struct nand_ecclayout *layout;
+};
+
+struct nfc_host;
+
+struct read_retry_t {
+	int type;
+	int count;
+	int (*set_rr_param)(struct nfc_host *host, int param);
+	int (*get_rr_param)(struct nfc_host *host);
+	int (*reset_rr_param)(struct nfc_host *host);
+	int (*enable_enhanced_slc)(struct nfc_host *host, int enable);
+};
+#endif
+
+/*****************************************************************************/
+struct nand_flash_dev_ex {
+	struct nand_flash_dev flash_dev;
+
+	char *start_type;
+	unsigned char ids[8];  /* 8Byte  */
+	int oobsize;
+	int ecctype;
+
+#define NAND_RANDOMIZER        0x01 /* nand chip need randomizer */
+#define NAND_HW_AUTO           0x02 /* controller support hardware auto config */
+#define NAND_SYNCHRONOUS       0x04 /* nand chip support synchronous */
+#define NAND_ASYNCHRONOUS      0x08 /* nand chip support asynchronous */
+#define NAND_SYNCHRONOUS_BOOT  0x10 /* nand boot from synchronous mode */
+#define NAND_CONFIG_DONE       0x20 /* current controller config finish */
+	int flags;
+	int is_randomizer;
+#define NAND_RR_NONE                   0x00
+#define NAND_RR_HYNIX_BG_BDIE          0x10
+#define NAND_RR_HYNIX_BG_CDIE          0x11
+#define NAND_RR_HYNIX_CG_ADIE          0x12
+#define NAND_RR_MICRON                 0x20
+#define NAND_RR_SAMSUNG                0x30
+#define NAND_RR_TOSHIBA_24NM           0x40
+#define NAND_RR_TOSHIBA_19NM           0x41
+#define NAND_RR_MASK                   0xF0
+	int read_retry_type;
+
+	int hostver; /* host controller version. */
+};
+
+/*****************************************************************************/
+const char *nand_ecc_name(int type);
+
+const char *nand_page_name(int type);
+
+int nandpage_size2type(int size);
+
+int nandpage_type2size(int size);
+
+/*****************************************************************************/
+extern int nand_get_ecctype(void);
+
+extern struct nand_flash_dev *(*get_flash_type)(struct mtd_info *mtd,
+		struct nand_chip *chip, unsigned char *id);
+
+extern int (*nand_oob_resize)(struct mtd_info *mtd);
+
+/*****************************************************************************/
+extern unsigned char match_ecc_type_to_yaffs(unsigned char type);
+
+extern unsigned char match_page_reg_to_type(unsigned char reg);
+
+extern unsigned char match_page_type_to_reg(unsigned char type);
+
+extern const char *match_page_type_to_str(unsigned char type);
+
+/*****************************************************************************/
+extern unsigned char match_ecc_reg_to_type(unsigned char reg);
+
+extern unsigned char match_ecc_type_to_reg(unsigned char type);
+
+extern const char *match_ecc_type_to_str(unsigned char type);
+
+/*****************************************************************************/
+extern unsigned char match_page_size_to_type(unsigned int size);
+
+extern unsigned int match_page_type_to_size(unsigned char type);
+
+#endif /* End of __NFC_COMMON_H__ */
+
diff -uraN u-boot-2016.11/include/sdhci.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/sdhci.h
--- u-boot-2016.11/include/sdhci.h	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/sdhci.h	2021-06-07 13:01:32.000000000 +0300
@@ -12,7 +12,7 @@
 
 #include <asm/io.h>
 #include <mmc.h>
-#include <asm/gpio.h>
+#include <asm-generic/gpio.h>
 
 /*
  * Controller registers
@@ -64,6 +64,7 @@
 #define  SDHCI_CARD_STATE_STABLE	0x00020000
 #define  SDHCI_CARD_DETECT_PIN_LEVEL	0x00040000
 #define  SDHCI_WRITE_PROTECT	0x00080000
+#define  SDHCI_DATA_0_LVL_MASK	0x00100000
 
 #define SDHCI_HOST_CONTROL	0x28
 #define  SDHCI_CTRL_LED		0x01
@@ -98,6 +99,7 @@
 #define  SDHCI_DIV_MASK_LEN	8
 #define  SDHCI_DIV_HI_MASK	0x300
 #define  SDHCI_PROG_CLOCK_MODE  0x0020
+#define  SDHCI_CLOCK_PLL_EN     0x0008
 #define  SDHCI_CLOCK_CARD_EN	0x0004
 #define  SDHCI_CLOCK_INT_STABLE	0x0002
 #define  SDHCI_CLOCK_INT_EN	0x0001
@@ -146,6 +148,15 @@
 #define SDHCI_ACMD12_ERR	0x3C
 
 /* 3E-3F reserved */
+#define SDHCI_HOST_CONTROL2	0x3E
+#define SDHCI_CTRL_UHS_MASK	0x0007
+#define SDHCI_CTRL_UHS_SDR12	0x0000
+#define SDHCI_CTRL_UHS_SDR25	0x0001
+#define SDHCI_CTRL_UHS_SDR50	0x0002
+#define SDHCI_CTRL_UHS_SDR104	0x0003
+#define SDHCI_CTRL_UHS_DDR50	0x0004
+#define SDHCI_CTRL_HS400	0x0007
+#define SDHCI_CTRL_TUNED_CLK	0x0080
 
 #define SDHCI_CAPABILITIES	0x40
 #define  SDHCI_TIMEOUT_CLK_MASK	0x0000003F
@@ -182,6 +193,7 @@
 /* 55-57 reserved */
 
 #define SDHCI_ADMA_ADDRESS	0x58
+#define SDHCI_ADMA_ADDRESS_HI	0x5c
 
 /* 60-FB reserved */
 
@@ -195,6 +207,39 @@
 #define   SDHCI_SPEC_100	0
 #define   SDHCI_SPEC_200	1
 #define   SDHCI_SPEC_300	2
+#define   SDHCI_SPEC_400	3
+#define   SDHCI_SPEC_420	5
+
+/* 0x508 */
+#define SDHCI_MSHC_CTRL         0x508
+#define  SDHCI_CMD_CONFLIT_CHECK	0x01
+
+/* 0x510 */
+#define SDHCI_AXI_MBIIU_CTRL	0x510
+#define  SDHCI_GM_WR_OSRC_LMT	0x03000000
+#define  SDHCI_GM_RD_OSRC_LMT	0x00030000
+#define SDHCI_UNDEFL_INCR_EN	0x00000001
+
+/* 0x52c */
+#define SDHCI_EMMC_CTRL		0x52c
+#define  SDHCI_ENH_STROBE_EN	0x0100
+#define  SDHCI_CARD_IS_EMMC	0x0001
+
+/* 0x540 */
+#define SDHCI_AT_CTRL		0x540
+#define  SDHCI_SAMPLE_EN	0x00000010
+
+/* 0x544 */
+#define SDHCI_AT_STAT		0x544
+#define  SDHCI_PHASE_SEL_MASK	0x000000ff
+
+/* 0x54c */
+#define SDHCI_MULTI_CYCLE	0x54c
+#define  SDHCI_FOUND_EDGE	0x00000800
+#define  SDHCI_DOUT_EN_F_EDGE	0x00000040
+#define  SDHCI_EDGE_DETECT_EN	0x00000100
+#define  SDHCI_DATA_DLY_EN	0x00000008
+#define  SDHCI_CMD_DLY_EN	0x00000004
 
 #define SDHCI_GET_VERSION(x) (x->version & SDHCI_SPEC_VER_MASK)
 
@@ -205,6 +250,8 @@
 #define SDHCI_MAX_DIV_SPEC_200	256
 #define SDHCI_MAX_DIV_SPEC_300	2046
 
+#define SDHCI_DMA_BOUNDARY_SIZE	(0x1 << 27)
+
 /*
  * quirks
  */
@@ -254,12 +301,38 @@
 	struct gpio_desc cd_gpio;		/* Card Detect GPIO */
 
 	void (*set_control_reg)(struct sdhci_host *host);
-	void (*set_clock)(int dev_index, unsigned int div);
+	int (*set_clock)(struct sdhci_host *host, unsigned int clk);
+	int (*execute_tuning)(struct sdhci_host *host, unsigned int opcode);
+	void (*priv_init)(struct sdhci_host *host);
 	uint	voltages;
 
 	struct mmc_config cfg;
+	void *adma_table;
+	unsigned int adma_table_sz;
+	unsigned int desc_sz;
+	unsigned int max_segs;
+	unsigned int max_seg_size;
+	unsigned int type;
+#define MMC_TYPE_MMC    0       /* MMC card */
+#define MMC_TYPE_SD     1       /* SD card */
+	unsigned int is_tuning;
+	unsigned int tuning_phase;
 };
 
+struct sdhci_adma2_64_desc {
+	__le16  cmd;
+	__le16  len;
+	__le32  addr_lo;
+	__le32  addr_hi;
+} __packed __aligned(4);
+
+struct sdhci_adma2_32_desc {
+	__le16  cmd;
+	__le16  len;
+	__le32  addr_lo;
+} __packed __aligned(4);
+
+
 #ifdef CONFIG_MMC_SDHCI_IO_ACCESSORS
 
 static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
@@ -416,4 +489,6 @@
 #else
 #endif
 
+void sdhci_hs400_enhanced_stobe(struct mmc *mmc, bool enable);
+
 #endif /* __SDHCI_HW_H */
diff -uraN u-boot-2016.11/include/serial.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/serial.h
--- u-boot-2016.11/include/serial.h	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/serial.h	2021-06-07 13:01:32.000000000 +0300
@@ -168,6 +168,7 @@
 /* Access the serial operations for a device */
 #define serial_get_ops(dev)	((struct dm_serial_ops *)(dev)->driver->ops)
 
+#ifndef CONFIG_MINI_BOOT
 void amirix_serial_initialize(void);
 void arc_serial_initialize(void);
 void arm_dcc_initialize(void);
@@ -203,7 +204,9 @@
 void ns16550_serial_initialize(void);
 void oc_serial_initialize(void);
 void p3mx_serial_initialize(void);
+#endif
 void pl01x_serial_initialize(void);
+#ifndef CONFIG_MINI_BOOT
 void pxa_serial_initialize(void);
 void s3c24xx_serial_initialize(void);
 void s5p_serial_initialize(void);
@@ -213,5 +216,6 @@
 void sh_serial_initialize(void);
 void uartlite_serial_initialize(void);
 void zynq_serial_initialize(void);
+#endif
 
 #endif
diff -uraN u-boot-2016.11/include/spi_flash.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/spi_flash.h
--- u-boot-2016.11/include/spi_flash.h	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/spi_flash.h	2021-06-07 13:01:32.000000000 +0300
@@ -13,6 +13,52 @@
 #include <dm.h>	/* Because we dereference struct udevice here */
 #include <linux/types.h>
 
+#ifdef CONFIG_SPI_BLOCK_PROTECT
+#define BP_OP_SET	0
+#define BP_OP_GET	1
+
+#define BT_LOC_RDSR	0
+#define BT_LOC_RDCR	1
+
+#define BP_CMP_TOP      0
+#define BP_CMP_BOTTOM   1
+#define BP_CMP_UPDATE_FLAG      0xff
+
+enum block_protection_level {
+	BP_LEVEL_0      = 0,
+	BP_LEVEL_1      = 1,
+	BP_LEVEL_2      = 2,
+	BP_LEVEL_3      = 3,
+	BP_LEVEL_4      = 4,
+	BP_LEVEL_5      = 5,
+	BP_LEVEL_6      = 6,
+	BP_LEVEL_7      = 7,
+	BP_LEVEL_8      = 8,
+	BP_LEVEL_9      = 9,
+	BP_LEVEL_10     = 10,
+	BP_LEVEL_END,
+};
+
+#define BP_LEVEL_MAX    (BP_LEVEL_END - 1)
+
+#define BP_NUM_3	3
+#define BP_NUM_4	4
+#define BP_NUM_5	5
+
+void spi_flash_lock(unsigned char cmp, unsigned char level, unsigned char op);
+
+#endif /* CONFIG_SPI_BLOCK_PROTECT */
+
+#define MID_SPANSION    0x01    /* Spansion Manufacture ID */
+#define MID_WINBOND     0xef    /* Winbond  Manufacture ID */
+#define MID_MXIC        0xc2    /* MXIC Manufacture ID */
+#define MID_MICRON      0x20    /* Micron Manufacture ID */
+#define MID_GD          0xc8    /* GD Manufacture ID */
+#define MID_ESMT        0x8c    /* ESMT Manufacture ID */
+#define MID_CFEON       0x1c    /* CFeon Manufacture ID */
+#define MID_MICRON      0x20    /* Micron Manufacture ID */
+#define MID_PARAGON     0xe0    /* Paragon Manufacture ID */
+
 #ifndef CONFIG_SF_DEFAULT_SPEED
 # define CONFIG_SF_DEFAULT_SPEED	1000000
 #endif
@@ -74,6 +120,7 @@
 	u32 page_size;
 	u32 sector_size;
 	u32 erase_size;
+
 #ifdef CONFIG_SPI_FLASH_BAR
 	u8 bank_read_cmd;
 	u8 bank_write_cmd;
@@ -85,7 +132,12 @@
 	u8 dummy_byte;
 
 	void *memory_map;
+#ifdef CONFIG_SPI_BLOCK_PROTECT
+	unsigned int	bp_level_max;
 
+	void		(*lock)(unsigned char cmp, unsigned char level,
+				unsigned char op);
+#endif
 	int (*flash_lock)(struct spi_flash *flash, u32 ofs, size_t len);
 	int (*flash_unlock)(struct spi_flash *flash, u32 ofs, size_t len);
 	int (*flash_is_locked)(struct spi_flash *flash, u32 ofs, size_t len);
@@ -101,9 +153,10 @@
 	 * if required, perhaps with a way of scanning through the list to
 	 * find the driver that matches the device.
 	 */
-	int (*read)(struct spi_flash *flash, u32 offset, size_t len, void *buf);
+	int (*read)(struct spi_flash *flash, u32 offset, size_t len,
+			unsigned char *buf);
 	int (*write)(struct spi_flash *flash, u32 offset, size_t len,
-			const void *buf);
+			const unsigned char *buf);
 	int (*erase)(struct spi_flash *flash, u32 offset, size_t len);
 #endif
 };
diff -uraN u-boot-2016.11/include/usb.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/usb.h
--- u-boot-2016.11/include/usb.h	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/usb.h	2021-06-07 13:01:32.000000000 +0300
@@ -16,6 +16,7 @@
 #include <usb_defs.h>
 #include <linux/usb/ch9.h>
 #include <asm/cache.h>
+#include <asm/types.h>
 #include <part.h>
 
 /*
diff -uraN u-boot-2016.11/include/vsprintf.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/vsprintf.h
--- u-boot-2016.11/include/vsprintf.h	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/include/vsprintf.h	2021-06-07 13:01:32.000000000 +0300
@@ -214,4 +214,5 @@
 
 bool str2off(const char *p, loff_t *num);
 bool str2long(const char *p, ulong *num);
+char *ultohstr(unsigned long long size);
 #endif
diff -uraN u-boot-2016.11/lib/hw_dec/hw_decompress.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/hw_dec/hw_decompress.c
--- u-boot-2016.11/lib/hw_dec/hw_decompress.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/hw_dec/hw_decompress.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,9 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#if ((defined CONFIG_TARGET_GK7205V200) || \
+	(defined CONFIG_TARGET_GK7205V300) || (defined CONFIG_TARGET_GK7202V300) || \
+	(defined CONFIG_TARGET_GK7605V100))
+#include "hw_decompress_v1.c"
+#endif
\ No newline at end of file
diff -uraN u-boot-2016.11/lib/hw_dec/hw_decompress_gk72x.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/hw_dec/hw_decompress_gk72x.c
--- u-boot-2016.11/lib/hw_dec/hw_decompress_gk72x.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/hw_dec/hw_decompress_gk72x.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <asm/io.h>
+#include <config.h>
+
+#define PERI_CRG100 0x190
+
+#define GZIP_OFFSET PERI_CRG100
+#define GZIP_CLKEN (0x1<<0)
+
+#ifndef GZIP_REG_BASE
+#define GZIP_REG_BASE   0x11310000
+#endif
+
+#define HW_DEC_REG_BASE_ADDR  (GZIP_REG_BASE)
+
+static void disable_decompress_clock(void)
+{
+	unsigned int regval;
+
+	regval = readl(CRG_REG_BASE + GZIP_OFFSET);
+	regval &= ~GZIP_CLKEN;
+	writel(regval, CRG_REG_BASE + GZIP_OFFSET);
+}
+
+static void enable_decompress_clock(void)
+{
+	unsigned int regval;
+
+	regval = readl(CRG_REG_BASE + GZIP_OFFSET);
+	regval |= GZIP_CLKEN;
+	writel(regval, CRG_REG_BASE + GZIP_OFFSET);
+}
diff -uraN u-boot-2016.11/lib/hw_dec/hw_decompress_v1.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/hw_dec/hw_decompress_v1.c
--- u-boot-2016.11/lib/hw_dec/hw_decompress_v1.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/hw_dec/hw_decompress_v1.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,263 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <asm/io.h>
+#ifndef error
+#include <common.h>
+#endif
+#include <compiler.h>
+
+#include "hw_decompress_v1.h"
+
+#if ((defined CONFIG_TARGET_GK7205V200) || \
+	(defined CONFIG_TARGET_GK7205V300) || (defined CONFIG_TARGET_GK7202V300) || \
+	(defined CONFIG_TARGET_GK7605V100))
+#include "hw_decompress_gk72x.c"
+#endif
+
+unsigned int hw_dec_type;
+unsigned int hw_dec_sop;
+unsigned int hw_dec_eop;
+unsigned int hw_dec_cur_blk;
+unsigned int hw_blk_total_num;
+
+void hw_dec_sop_eop_first_set(int block_num)
+{
+	if (block_num == 1) {
+		hw_dec_sop = 1;
+		hw_dec_eop = 1;
+	} else {
+		hw_dec_sop = 1;
+		hw_dec_eop = 0;
+	}
+
+	hw_dec_cur_blk = 0;
+	hw_blk_total_num = block_num;
+}
+
+static inline void hw_dec_work_en_set(int work_en_flg)
+{
+	/* Enable the emar */
+	writel(work_en_flg, HW_DEC_REG_BASE_ADDR + EAMR_WORK_EN_REG_OFST);
+}
+
+static inline void hw_dec_rtn_baddr_set(unsigned int addr)
+{
+	writel(addr, HW_DEC_REG_BASE_ADDR + DPRS_DATA_RTN_BADDR);
+}
+
+static inline void hw_dec_dprs_data_baddr_set(unsigned int addr)
+{
+	writel(addr, HW_DEC_REG_BASE_ADDR + DPRS_DATA_INFO_BADDR);
+}
+
+static inline void hw_dec_data_rtn_len_set(unsigned int len)
+{
+	writel(len, HW_DEC_REG_BASE_ADDR + DPRS_DATA_RTN_LEN);
+}
+
+static inline void hw_dec_dprs_data_len_set(unsigned int len)
+{
+	writel(len, HW_DEC_REG_BASE_ADDR + DPRS_DATA_INFO_LEN);
+}
+
+static inline void hw_dec_crc_check_en(unsigned int crc_en)
+{
+	writel(crc_en, HW_DEC_REG_BASE_ADDR + CRC_CHECK_EN);
+}
+
+static inline void hw_dec_data_crc32_set(unsigned int crc32)
+{
+	writel(crc32, HW_DEC_REG_BASE_ADDR + DPRS_DATA_CRC32);
+}
+
+static inline unsigned int hw_dec_buf_status_get(void)
+{
+	return readl(HW_DEC_REG_BASE_ADDR + BUF_INFO);
+}
+
+static inline unsigned int hw_dec_dprs_rtn_status_get(void)
+{
+	return readl(HW_DEC_REG_BASE_ADDR + DPRS_RTN_INFO);
+}
+
+static inline void hw_dec_buf_status_clr(void)
+{
+	writel(0x1, HW_DEC_REG_BASE_ADDR + BUF_INFO_CLR);
+}
+
+static inline void hw_dec_dprs_rtn_status_clr(void)
+{
+	writel(0x1, HW_DEC_REG_BASE_ADDR + RLT_INFO_CLR);
+}
+
+static void hw_dec_intr_en_set(int blk_intr_en, int task_intr_en)
+{
+	u_intr_en intr_en;
+	intr_en.bits.task_intrpt_en = task_intr_en;
+	intr_en.bits.block_intrpt_en = blk_intr_en;
+	writel(intr_en.u32, HW_DEC_REG_BASE_ADDR + INT_EN_REG_ADDR);
+}
+
+static inline unsigned int hw_dec_intr_status_get(void)
+{
+	return readl(HW_DEC_REG_BASE_ADDR + INT_STATUS_REG_ADDR);
+}
+
+static void hw_dec_block_intr_status_clr(void)
+{
+	u_intr_clr intr_clr;
+
+	intr_clr.u32 = readl(HW_DEC_REG_BASE_ADDR + INT_CLEAR_REG_ADDR);
+	intr_clr.bits.block_intrpt_clr = 0x1;
+	writel(intr_clr.u32, HW_DEC_REG_BASE_ADDR + INT_CLEAR_REG_ADDR);
+}
+
+static void hw_dec_task_intr_status_clr(void)
+{
+	u_intr_clr intr_clr;
+
+	intr_clr.u32 = readl(HW_DEC_REG_BASE_ADDR + INT_CLEAR_REG_ADDR);
+	intr_clr.bits.task_intrpt_clr = 0x1;
+	writel(intr_clr.u32, HW_DEC_REG_BASE_ADDR + INT_CLEAR_REG_ADDR);
+}
+
+int hw_dec_intr_proc(int irq, void *para)
+{
+	u_buf_status buf_status;
+	u_intr_status intr_status;
+	u_dprs_rtn_status dprs_status;
+	int ret = 0;
+
+	intr_status.u32 = hw_dec_intr_status_get();
+	if (intr_status.bits.block_intrpt) {
+		buf_status.u32 = hw_dec_buf_status_get();
+		if (buf_status.bits.aval_flg)
+			hw_dec_buf_status_clr();
+
+		hw_dec_block_intr_status_clr();
+	}
+
+	if (intr_status.bits.task_intrpt) {
+		dprs_status.u32 = hw_dec_dprs_rtn_status_get();
+		if (dprs_status.bits.aval_flg) {
+			if (dprs_status.bits.err_info)
+				ret = -2; /* -2:failed */
+
+			hw_dec_dprs_rtn_status_clr();
+		}
+
+		hw_dec_task_intr_status_clr();
+		goto out;
+	}
+
+	ret = -1;
+out:
+	return ret;
+}
+
+void hw_dec_start(unsigned int src_baddr,
+			unsigned int dst_baddr,
+			unsigned int src_len,
+			unsigned int dst_len,
+			unsigned int crc_en,
+			unsigned int crc32,
+			unsigned int dec_type)
+{
+	unsigned int val;
+
+	if (hw_dec_sop) {
+		if (!dec_type) {
+			/* set the parameters of output buffer */
+			hw_dec_rtn_baddr_set(dst_baddr);
+			hw_dec_data_rtn_len_set(dst_len);
+		} else {
+			/* set the parameter of output buffer */
+			hw_dec_dprs_data_baddr_set(dst_baddr);
+			hw_dec_dprs_data_len_set(page_nr(dst_len) * 4); /* 4:Align */
+		}
+	}
+
+	/* set the parameter of input buffer */
+	writel(src_baddr, HW_DEC_REG_BASE_ADDR + DPRS_DATA_SRC_BADDR);
+
+	val = src_len |
+		(hw_dec_sop << 28) | (hw_dec_eop << 29) | (!dec_type << 31); /* 28,29,31 Move Left bit */
+	writel(val, HW_DEC_REG_BASE_ADDR + DPRS_DATA_SRC_LEN);
+
+	hw_dec_crc_check_en(crc_en);
+}
+
+static inline void delay(unsigned int num)
+{
+	volatile unsigned int i;
+
+	for (i = 0; i < (100 * num); i++) /* 100: Cycle */
+		__asm__ __volatile__("nop");
+}
+
+int hw_dec_wait_finish(void)
+{
+	int ret;
+	int times = 0;
+
+	do {
+		ret = hw_dec_intr_proc(HW_DEC_INTR, NULL);
+		times++;
+		if (times > 2000000) { /* 2000000 ms */
+			error("hardware decompress overtime!\n");
+			break;
+		}
+		delay(1);
+	} while (-1 == ret);
+
+	return ret;
+}
+
+int hw_dec_decompress(unsigned char *dst, int *dstlen,
+			unsigned char *src, int srclen,
+			void *unused)
+{
+	int ret;
+
+	hw_dec_sop_eop_first_set(1);
+	hw_dec_start((unsigned int)(uintptr_t)src, (unsigned int)(uintptr_t)dst,
+				 srclen, *dstlen, 1, 0, hw_dec_type);
+
+	ret = hw_dec_wait_finish();
+
+	*dstlen = readl(HW_DEC_REG_BASE_ADDR + DPRS_RTN_LEN);
+
+	if (ret)
+		return -1;
+
+	return 0;
+}
+
+void hw_dec_init(void)
+{
+	/* enable decompress clock */
+	enable_decompress_clock();
+	/* Init the emar interface */
+	writel(0, HW_DEC_REG_BASE_ADDR + EAMR_RID_REG_OFST);
+	writel(0x3, HW_DEC_REG_BASE_ADDR + EAMR_ROSD_REG_OFST);
+	writel(0, HW_DEC_REG_BASE_ADDR + EAMR_WID_REG_OFST);
+	writel(0x3, HW_DEC_REG_BASE_ADDR + EAMR_WOSD_REG_OFST);
+
+	/* Enable interrupt */
+	hw_dec_intr_en_set(0x1, 0x1);
+
+	/* Enable emar */
+	hw_dec_work_en_set(0x1);
+}
+
+void hw_dec_uinit(void)
+{
+	hw_dec_work_en_set(0x0);
+	hw_dec_intr_en_set(0x0, 0x0);
+
+	/* disable decompress clock */
+	disable_decompress_clock();
+}
+
diff -uraN u-boot-2016.11/lib/hw_dec/hw_decompress_v1.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/hw_dec/hw_decompress_v1.h
--- u-boot-2016.11/lib/hw_dec/hw_decompress_v1.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/hw_dec/hw_decompress_v1.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,132 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#ifndef __HW_DECOMPRESS_V1_H__
+#define __HW_DECOMPRESS_V1_H__
+
+#define PAGE_SIZE       4096
+#define page_nr(x) (((x) + PAGE_SIZE - 1) / PAGE_SIZE)
+
+/* The base address for emar */
+#define HW_DEC_REG_BASE_ADDR    (GZIP_REG_BASE)
+
+/* The global init registers for emar interface */
+#define EAMR_RID_REG_OFST   0x0108UL
+#define EAMR_ROSD_REG_OFST  0x010CUL
+#define EAMR_WID_REG_OFST   0x0110UL
+#define EAMR_WOSD_REG_OFST  0x0114UL
+
+/* The enable register */
+#define EAMR_WORK_EN_REG_OFST 0x0100UL
+
+#define DPRS_DATA_SRC_BADDR 0x2040UL
+#define DPRS_DATA_SRC_LEN   0x2044UL
+
+/* Decompress parameter reigsters for page address */
+#define DPRS_DATA_RTN_BADDR 0x2020UL
+#define DPRS_DATA_RTN_LEN   0x2024UL
+
+/* Decompress parameter registers for page data */
+#define DPRS_DATA_INFO_BADDR 0x2028UL
+#define DPRS_DATA_INFO_LEN  0x202CUL
+
+#define DPRS_DATA_CRC32     0x2030UL
+
+#define CRC_CHECK_EN        0x4000UL
+
+/* The status registers */
+#define BUF_INFO            0x2080UL
+#define DPRS_RTN_INFO       0x2084UL
+#define DPRS_RTN_LEN        0x2088UL
+#define BUF_INFO_CLR        0x2090UL
+#define RLT_INFO_CLR        0x2094UL
+
+/* The intr registers */
+#define INT_EN_REG_ADDR     0x0128UL
+#define INT_STATUS_REG_ADDR 0x0124UL
+#define INT_CLEAR_REG_ADDR  0x0130UL
+
+#define TASK_MODE_REG       0x2134UL
+
+/* Define the union u_dprs_data_buf_info */
+typedef union {
+	/* Define the struct bits */
+	struct {
+		unsigned int    buf_len: 24; /* [23..0] */
+		unsigned int    buf_id: 2; /* [25..24] */
+		unsigned int    reserved_1: 2; /* [27..26] */
+		unsigned int    eop: 1; /* [28] */
+		unsigned int    sop: 1; /* [29] */
+		unsigned int    reserved_0: 1; /* [30] */
+		unsigned int    mode: 1; /* [31] */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    u32;
+} u_dprs_data_buf_info;
+
+typedef union {
+	struct {
+		unsigned int buf_id: 2; /* [1:0] */
+		unsigned int rsv: 29;   /* [30:2] */
+		unsigned int aval_flg: 1;   /* [31] */
+	} bits;
+	unsigned int u32;
+} u_buf_status;
+
+typedef union {
+	struct {
+		unsigned int err_info: 8;   /* [7:0] */
+		unsigned int rsv: 23;   /* [30:8] */
+		unsigned int aval_flg: 1;   /* [31] */
+	} bits;
+
+	unsigned int u32;
+} u_dprs_rtn_status;
+
+/* Define the union U_INT_EN */
+typedef union {
+	/* Define the struct bits */
+	struct {
+		unsigned int    task_intrpt_en: 1; /* [0] */
+		unsigned int    block_intrpt_en: 1; /* [1] */
+		unsigned int    reserved_0: 30; /* [31..2] */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    u32;
+} u_intr_en;
+
+typedef union {
+	/* Define the struct bits */
+	struct {
+		unsigned int    task_intrpt: 1; /* [0] */
+		unsigned int    block_intrpt: 1; /* [1] */
+		unsigned int    reserved_0: 30; /* [31..2] */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    u32;
+} u_intr_status;
+
+typedef union {
+	/* Define the struct bits */
+	struct {
+		unsigned int    task_intrpt_clr: 1; /* [0] */
+		unsigned int    block_intrpt_clr: 1; /* [1] */
+		unsigned int    reserved_0: 30; /* [31..2] */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    u32;
+} u_intr_clr;
+
+extern unsigned int hw_dec_type;
+
+void hw_dec_init(void);
+int hw_dec_decompress(unsigned char *dst, int *dstlen,
+		      unsigned char *src, int srclen,
+		      void *unused);
+void hw_dec_uinit(void);
+
+#endif
diff -uraN u-boot-2016.11/lib/hw_dec/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/hw_dec/Makefile
--- u-boot-2016.11/lib/hw_dec/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/hw_dec/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1 @@
+obj-y += hw_decompress.o
diff -uraN u-boot-2016.11/lib/Kconfig gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/Kconfig
--- u-boot-2016.11/lib/Kconfig	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/Kconfig	2021-06-07 13:01:32.000000000 +0300
@@ -196,6 +196,13 @@
 
 endmenu
 
+config HWDEC
+	bool "hw decompress"
+	default y
+	depends on TARGET_GK7205V200 || TARGET_GK7205V300 || TARGET_GK7202V300 || TARGET_GK7605V100
+	help
+	  hw decompress.
+
 source lib/efi/Kconfig
 source lib/efi_loader/Kconfig
 
diff -uraN u-boot-2016.11/lib/lmb.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/lmb.c
--- u-boot-2016.11/lib/lmb.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/lmb.c	2021-06-07 13:01:32.000000000 +0300
@@ -105,6 +105,19 @@
 	lmb->reserved.size = 0;
 }
 
+/* Initialize the struct, add memory and call arch/board reserve functions */
+void lmb_init_and_reserve(struct lmb *lmb, phys_addr_t base, phys_size_t size,
+			  void *fdt_blob)
+{
+	lmb_init(lmb);
+	lmb_add(lmb, base, size);
+	arch_lmb_reserve(lmb);
+	board_lmb_reserve(lmb);
+
+	if (IMAGE_ENABLE_OF_LIBFDT && fdt_blob)
+		boot_fdt_add_mem_rsv_regions(lmb, fdt_blob);
+}
+
 /* This routine called with relocation disabled. */
 static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
 {
@@ -320,6 +333,32 @@
 		}
 	}
 	return 0;
+}
+
+/*
+ * Try to allocate a specific address range: must be in defined memory but not
+ * reserved
+ */
+phys_addr_t lmb_alloc_addr(struct lmb *lmb, phys_addr_t base, phys_size_t size)
+{
+	long rgn;
+
+	/* Check if the requested address is in one of the memory regions */
+	rgn = lmb_overlaps_region(&lmb->memory, base, size);
+	if (rgn >= 0) {
+		/*
+		 * Check if the requested end address is in the same memory
+		 * region we found.
+		 */
+		if (lmb_addrs_overlap(lmb->memory.region[rgn].base,
+				      lmb->memory.region[rgn].size,
+				      base + size - 1, 1)) {
+			/* ok, reserve the memory */
+			if (lmb_reserve(lmb, base, size) >= 0)
+				return base;
+		}
+	}
+	return 0;
 }
 
 int lmb_is_reserved(struct lmb *lmb, phys_addr_t addr)
diff -uraN u-boot-2016.11/lib/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/Makefile
--- u-boot-2016.11/lib/Makefile	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -19,8 +19,10 @@
 
 obj-$(CONFIG_AES) += aes.o
 obj-$(CONFIG_USB_TTY) += circbuf.o
+ifndef CONFIG_GK_MC
 obj-y += crc7.o
 obj-y += crc8.o
+endif
 obj-y += crc16.o
 obj-$(CONFIG_ERRNO_STR) += errno_str.o
 obj-$(CONFIG_FIT) += fdtdec_common.o
@@ -32,7 +34,9 @@
 obj-$(CONFIG_LMB) += lmb.o
 obj-y += ldiv.o
 obj-$(CONFIG_LZ4) += lz4_wrapper.o
+ifndef CONFIG_GK_MC
 obj-$(CONFIG_MD5) += md5.o
+endif
 obj-y += net_utils.o
 obj-$(CONFIG_PHYSMEM) += physmem.o
 obj-y += qsort.o
@@ -44,10 +48,13 @@
 obj-y += list_sort.o
 endif
 
+obj-$(CONFIG_HWDEC) += hw_dec/
+
 obj-$(CONFIG_$(SPL_)RSA) += rsa/
+ifndef CONFIG_GK_MC
 obj-$(CONFIG_$(SPL_)SHA1) += sha1.o
 obj-$(CONFIG_$(SPL_)SHA256) += sha256.o
-
+endif
 obj-$(CONFIG_SPL_SAVEENV) += qsort.o
 obj-$(CONFIG_$(SPL_)OF_LIBFDT) += libfdt/
 ifneq ($(CONFIG_SPL_BUILD)$(CONFIG_SPL_OF_PLATDATA),yy)
@@ -94,7 +101,11 @@
 endif
 else
 # Main U-Boot always uses the full printf support
+#ifndef CONFIG_MINI_BOOT
 obj-y += vsprintf.o panic.o strto.o strmhz.o
+#endif
+
 endif
+obj-$(CONFIG_CMD_NAND) +=match_table.o
 
 subdir-ccflags-$(CONFIG_CC_OPTIMIZE_LIBS_FOR_SPEED) += -O2
diff -uraN u-boot-2016.11/lib/match_table.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/match_table.c
--- u-boot-2016.11/lib/match_table.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/match_table.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,93 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <linux/string.h>
+
+#include <match_table.h>
+
+/*****************************************************************************/
+int reg2type(struct match_reg_type *table, int length, int reg, int def)
+{
+	while (length-- > 0) {
+		if (table->reg == reg)
+			return table->type;
+		table++;
+	}
+	return def;
+}
+
+int type2reg(struct match_reg_type *table, int length, int type, int def)
+{
+	while (length-- > 0) {
+		if (table->type == type)
+			return table->reg;
+		table++;
+	}
+	return def;
+}
+
+int str2type(struct match_type_str *table, int length, const char *str,
+			 int size, int def)
+{
+	while (length-- > 0) {
+		if (!strncmp(table->str, str, size))
+			return table->type;
+		table++;
+	}
+	return def;
+}
+
+const char *type2str(struct match_type_str *table, int length, int type,
+					 const char *def)
+{
+	while (length-- > 0) {
+		if (table->type == type)
+			return table->str;
+		table++;
+	}
+	return def;
+}
+
+int match_reg_to_type(struct match_t *table, int nr_table, int reg, int def)
+{
+	while (nr_table-- > 0) {
+		if (table->reg == reg)
+			return table->type;
+		table++;
+	}
+	return def;
+}
+
+int match_type_to_reg(struct match_t *table, int nr_table, int type, int def)
+{
+	while (nr_table-- > 0) {
+		if (table->type == type)
+			return table->reg;
+		table++;
+	}
+	return def;
+}
+
+int match_data_to_type(struct match_t *table, int nr_table, const char *data,
+					   int size, int def)
+{
+	while (nr_table-- > 0) {
+		if (!memcmp(table->data, data, size))
+			return table->type;
+		table++;
+	}
+	return def;
+}
+
+void *match_type_to_data(struct match_t *table, int nr_table, int type,
+						 void *def)
+{
+	while (nr_table-- > 0) {
+		if (table->type == type)
+			return table->data;
+		table++;
+	}
+	return def;
+}
+
diff -uraN u-boot-2016.11/lib/rsa/rsa-sign.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/rsa/rsa-sign.c
--- u-boot-2016.11/lib/rsa/rsa-sign.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/rsa/rsa-sign.c	2021-06-07 13:01:32.000000000 +0300
@@ -488,8 +488,8 @@
 	}
 
 	if (!ret) {
-		ret = fdt_setprop_string(keydest, node, "key-name-hint",
-				 info->keyname);
+		ret = fdt_setprop_string(keydest, node, FIT_KEY_HINT,
+					 info->keyname);
 	}
 	if (!ret)
 		ret = fdt_setprop_u32(keydest, node, "rsa,num-bits", bits);
@@ -511,7 +511,7 @@
 					 info->algo->name);
 	}
 	if (!ret && info->require_keys) {
-		ret = fdt_setprop_string(keydest, node, "required",
+		ret = fdt_setprop_string(keydest, node, FIT_KEY_REQUIRED,
 					 info->require_keys);
 	}
 done:
diff -uraN u-boot-2016.11/lib/uuid.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/uuid.c
--- u-boot-2016.11/lib/uuid.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/uuid.c	2021-06-07 13:01:32.000000000 +0300
@@ -239,6 +239,8 @@
 	unsigned int *ptr = (unsigned int *)&uuid;
 	int i;
 
+	srand(get_ticks() + rand());
+
 	/* Set all fields randomly */
 	for (i = 0; i < sizeof(struct uuid) / sizeof(*ptr); i++)
 		*(ptr + i) = cpu_to_be32(rand());
diff -uraN u-boot-2016.11/lib/vsprintf.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/vsprintf.c
--- u-boot-2016.11/lib/vsprintf.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/vsprintf.c	2021-06-07 13:01:32.000000000 +0300
@@ -775,3 +775,16 @@
 	*num = simple_strtoul(p, &endptr, 16);
 	return *p != '\0' && *endptr == '\0';
 }
+
+char *ultohstr(unsigned long long size)
+{
+	int ix;
+	static char buffer[20];
+	char *fmt[] = {
+		"%u", "%uK", "%uM", "%uG", "%uT", "%uT"};
+	for (ix = 0; (ix < 5) && !(size & 0x3FF) && size; ix++) {
+		size = (size >> 10);
+	}
+	sprintf(buffer, fmt[ix], size);
+	return buffer;
+}
diff -uraN u-boot-2016.11/lib/zlib/inffast.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/zlib/inffast.c
--- u-boot-2016.11/lib/zlib/inffast.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/lib/zlib/inffast.c	2021-06-07 13:01:32.000000000 +0300
@@ -12,25 +12,6 @@
 
 #ifndef ASMINF
 
-/* Allow machine dependent optimization for post-increment or pre-increment.
-   Based on testing to date,
-   Pre-increment preferred for:
-   - PowerPC G3 (Adler)
-   - MIPS R5000 (Randers-Pehrson)
-   Post-increment preferred for:
-   - none
-   No measurable difference:
-   - Pentium III (Anderson)
-   - M68060 (Nikl)
- */
-#ifdef POSTINC
-#  define OFF 0
-#  define PUP(a) *(a)++
-#else
-#  define OFF 1
-#  define PUP(a) *++(a)
-#endif
-
 /*
    Decode literal, length, and distance codes and write out the resulting
    literal and match bytes until either not enough input or output is
@@ -97,7 +78,7 @@
 
     /* copy state to local variables */
     state = (struct inflate_state FAR *)strm->state;
-    in = strm->next_in - OFF;
+    in = strm->next_in;
     last = in + (strm->avail_in - 5);
     if (in > last && strm->avail_in > 5) {
         /*
@@ -107,7 +88,7 @@
 	strm->avail_in = 0xffffffff - (uintptr_t)in;
         last = in + (strm->avail_in - 5);
     }
-    out = strm->next_out - OFF;
+    out = strm->next_out;
     beg = out - (start - strm->avail_out);
     end = out + (strm->avail_out - 257);
 #ifdef INFLATE_STRICT
@@ -128,9 +109,9 @@
        input data or output space */
     do {
         if (bits < 15) {
-            hold += (unsigned long)(PUP(in)) << bits;
+            hold += (unsigned long)(*in++) << bits;
             bits += 8;
-            hold += (unsigned long)(PUP(in)) << bits;
+            hold += (unsigned long)(*in++) << bits;
             bits += 8;
         }
         this = lcode[hold & lmask];
@@ -143,14 +124,14 @@
             Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
                     "inflate:         literal '%c'\n" :
                     "inflate:         literal 0x%02x\n", this.val));
-            PUP(out) = (unsigned char)(this.val);
+            *out++ = (unsigned char)(this.val);
         }
         else if (op & 16) {                     /* length base */
             len = (unsigned)(this.val);
             op &= 15;                           /* number of extra bits */
             if (op) {
                 if (bits < op) {
-                    hold += (unsigned long)(PUP(in)) << bits;
+                    hold += (unsigned long)(*in++) << bits;
                     bits += 8;
                 }
                 len += (unsigned)hold & ((1U << op) - 1);
@@ -159,9 +140,9 @@
             }
             Tracevv((stderr, "inflate:         length %u\n", len));
             if (bits < 15) {
-                hold += (unsigned long)(PUP(in)) << bits;
+                hold += (unsigned long)(*in++) << bits;
                 bits += 8;
-                hold += (unsigned long)(PUP(in)) << bits;
+                hold += (unsigned long)(*in++) << bits;
                 bits += 8;
             }
             this = dcode[hold & dmask];
@@ -174,10 +155,10 @@
                 dist = (unsigned)(this.val);
                 op &= 15;                       /* number of extra bits */
                 if (bits < op) {
-                    hold += (unsigned long)(PUP(in)) << bits;
+                    hold += (unsigned long)(*in++) << bits;
                     bits += 8;
                     if (bits < op) {
-                        hold += (unsigned long)(PUP(in)) << bits;
+                        hold += (unsigned long)(*in++) << bits;
                         bits += 8;
                     }
                 }
@@ -200,13 +181,13 @@
                         state->mode = BAD;
                         break;
                     }
-                    from = window - OFF;
+                    from = window;
                     if (write == 0) {           /* very common case */
                         from += wsize - op;
                         if (op < len) {         /* some from window */
                             len -= op;
                             do {
-                                PUP(out) = PUP(from);
+                                *out++ = *from++;
                             } while (--op);
                             from = out - dist;  /* rest from output */
                         }
@@ -217,14 +198,14 @@
                         if (op < len) {         /* some from end of window */
                             len -= op;
                             do {
-                                PUP(out) = PUP(from);
+                                *out++ = *from++;
                             } while (--op);
-                            from = window - OFF;
+                            from = window;
                             if (write < len) {  /* some from start of window */
                                 op = write;
                                 len -= op;
                                 do {
-                                    PUP(out) = PUP(from);
+                                    *out++ = *from++;
                                 } while (--op);
                                 from = out - dist;      /* rest from output */
                             }
@@ -235,21 +216,21 @@
                         if (op < len) {         /* some from window */
                             len -= op;
                             do {
-                                PUP(out) = PUP(from);
+                                *out++ = *from++;
                             } while (--op);
                             from = out - dist;  /* rest from output */
                         }
                     }
                     while (len > 2) {
-                        PUP(out) = PUP(from);
-                        PUP(out) = PUP(from);
-                        PUP(out) = PUP(from);
+                        *out++ = *from++;
+                        *out++ = *from++;
+                        *out++ = *from++;
                         len -= 3;
                     }
                     if (len) {
-                        PUP(out) = PUP(from);
+                        *out++ = *from++;
                         if (len > 1)
-                            PUP(out) = PUP(from);
+                            *out++ = *from++;
                     }
                 }
                 else {
@@ -259,25 +240,25 @@
                     from = out - dist;          /* copy direct from output */
                     /* minimum length is three */
 		    /* Align out addr */
-		    if (!((long)(out - 1 + OFF) & 1)) {
-			PUP(out) = PUP(from);
+		    if (!((long)(out - 1) & 1)) {
+			*out++ = *from++;
 			len--;
 		    }
-		    sout = (unsigned short *)(out - OFF);
+		    sout = (unsigned short *)(out);
 		    if (dist > 2 ) {
 			unsigned short *sfrom;
 
-			sfrom = (unsigned short *)(from - OFF);
+			sfrom = (unsigned short *)(from);
 			loops = len >> 1;
 			do
-			    PUP(sout) = get_unaligned(++sfrom);
+			    *sout++ = get_unaligned(++sfrom);
 			while (--loops);
-			out = (unsigned char *)sout + OFF;
-			from = (unsigned char *)sfrom + OFF;
+			out = (unsigned char *)sout;
+			from = (unsigned char *)sfrom;
 		    } else { /* dist == 1 or dist == 2 */
 			unsigned short pat16;
 
-			pat16 = *(sout-2+2*OFF);
+			pat16 = *(sout-2);
 			if (dist == 1)
 #if defined(__BIG_ENDIAN)
 			    pat16 = (pat16 & 0xff) | ((pat16 & 0xff ) << 8);
@@ -288,12 +269,12 @@
 #endif
 			loops = len >> 1;
 			do
-			    PUP(sout) = pat16;
+			    *sout++ = pat16;
 			while (--loops);
-			out = (unsigned char *)sout + OFF;
+			out = (unsigned char *)sout;
 		    }
 		    if (len & 1)
-			PUP(out) = PUP(from);
+			*out++ = *from++;
                 }
             }
             else if ((op & 64) == 0) {          /* 2nd level distance code */
@@ -329,8 +310,8 @@
     hold &= (1U << bits) - 1;
 
     /* update state and return */
-    strm->next_in = in + OFF;
-    strm->next_out = out + OFF;
+    strm->next_in = in;
+    strm->next_out = out;
     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
     strm->avail_out = (unsigned)(out < end ?
                                  257 + (end - out) : 257 - (out - end));
diff -uraN u-boot-2016.11/.mailmap gk7205v100_u-boot-2016.11_sdk-C00SPC020/.mailmap
--- u-boot-2016.11/.mailmap	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/.mailmap	1970-01-01 03:00:00.000000000 +0300
@@ -1,35 +0,0 @@
-#
-# This list is used by git-shortlog to fix a few botched name translations
-# in the git archive, either because the author's full name was messed up
-# and/or not always written the same way, making contributions from the
-# same person appearing not to be so or badly displayed.
-#
-# This file can be modified by hand or updated by the following command:
-#  scripts/mailmapper > tmp; mv tmp .mailmap
-#
-
-Allen Martin <amartin@nvidia.com>
-Andreas Biemann <andreas.devel@googlemail.com>
-Andreas Biemann <andreas@biessmann.org>
-Aneesh V <aneesh@ti.com>
-Dirk Behme <dirk.behme@googlemail.com>
-Fabio Estevam <fabio.estevam@nxp.com>
-Jagan Teki <402jagan@gmail.com>
-Jagan Teki <jaganna@gmail.com>
-Jagan Teki <jaganna@xilinx.com>
-Jagan Teki <jagannadh.teki@gmail.com>
-Jagan Teki <jagannadha.sutradharudu-teki@xilinx.com>
-Markus Klotzbuecher <mk@denx.de>
-Prabhakar Kushwaha <prabhakar@freescale.com>
-Rajeshwari Shinde <rajeshwari.s@samsung.com>
-Ricardo Ribalda <ricardo.ribalda@uam.es>
-Ricardo Ribalda <ricardo.ribalda@gmail.com>
-Sandeep Paulraj <s-paulraj@ti.com>
-Shaohui Xie <Shaohui.Xie@freescale.com>
-Stefan Roese <stroese>
-Stefano Babic <sbabic@denx.de>
-TsiChung Liew <Tsi-Chung.Liew@freescale.com>
-Wolfgang Denk <wdenk>
-York Sun <yorksun@freescale.com>
-York Sun <york.sun@nxp.com>
-ukasz Majewski <l.majewski@samsung.com>
diff -uraN u-boot-2016.11/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/Makefile
--- u-boot-2016.11/Makefile	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/Makefile	2021-06-07 13:01:31.000000000 +0300
@@ -624,24 +624,35 @@
 #########################################################################
 # U-Boot objects....order is important (i.e. start must be first)
 
+ifdef CONFIG_MINI_BOOT
+export ENABLE_MINI_BOOT := y
+endif
+
 HAVE_VENDOR_COMMON_LIB = $(if $(wildcard $(srctree)/board/$(VENDOR)/common/Makefile),y,n)
 
 libs-y += lib/
 libs-$(HAVE_VENDOR_COMMON_LIB) += board/$(VENDOR)/common/
 libs-$(CONFIG_OF_EMBED) += dts/
+ifndef CONFIG_MINI_BOOT
 libs-y += fs/
 libs-y += net/
 libs-y += disk/
+endif
 libs-y += drivers/
+ifndef CONFIG_MINI_BOOT
 libs-y += drivers/dma/
 libs-y += drivers/gpio/
 libs-y += drivers/i2c/
 libs-y += drivers/mmc/
+endif
 libs-y += drivers/mtd/
+ifndef CONFIG_MINI_BOOT
 libs-$(CONFIG_CMD_NAND) += drivers/mtd/nand/
 libs-y += drivers/mtd/onenand/
+endif
 libs-$(CONFIG_CMD_UBI) += drivers/mtd/ubi/
 libs-y += drivers/mtd/spi/
+ifndef CONFIG_MINI_BOOT
 libs-y += drivers/net/
 libs-y += drivers/net/phy/
 libs-y += drivers/pci/
@@ -657,26 +668,35 @@
 libs-$(CONFIG_SYS_FSL_DDR) += drivers/ddr/fsl/
 libs-$(CONFIG_SYS_FSL_MMDC) += drivers/ddr/fsl/
 libs-$(CONFIG_ALTERA_SDRAM) += drivers/ddr/altera/
+endif
+libs-y += drivers/ddr/goke/$(SOC)/
 libs-y += drivers/serial/
+ifndef CONFIG_MINI_BOOT
 libs-y += drivers/usb/dwc3/
 libs-y += drivers/usb/common/
 libs-y += drivers/usb/emul/
 libs-y += drivers/usb/eth/
 libs-y += drivers/usb/gadget/
+libs-$(CONFIG_PHY_VENDOR_USB) += drivers/usb/gadget/udc3/
 libs-y += drivers/usb/gadget/udc/
 libs-y += drivers/usb/host/
 libs-y += drivers/usb/musb/
 libs-y += drivers/usb/musb-new/
 libs-y += drivers/usb/phy/
 libs-y += drivers/usb/ulpi/
+endif
 libs-y += cmd/
 libs-y += common/
 libs-$(CONFIG_API) += api/
 libs-$(CONFIG_HAS_POST) += post/
+ifndef CONFIG_MINI_BOOT
 libs-y += test/
 libs-y += test/dm/
 libs-$(CONFIG_UT_ENV) += test/env/
 libs-$(CONFIG_UT_OVERLAY) += test/overlay/
+endif
+
+sinclude Makefile-product
 
 libs-y += $(if $(BOARDDIR),board/$(BOARDDIR)/)
 
@@ -846,6 +866,12 @@
 	$(call if_changed,copy)
 endif
 
+.PHONY: u-boot-z.bin
+u-boot-z.bin: $(CURDIR)/u-boot.bin
+	cp -raf $(KBUILD_SRC)/arch/$(ARCH)/cpu/$(CPU)/$(SOC) $(CURDIR)
+	make -C $(CURDIR)/$(SOC) CROSS_COMPILE=$(CROSS_COMPILE) \
+		BINIMAGE=$(CURDIR)/u-boot.bin SRCDIR=$(KBUILD_SRC) OUTDIR=$(CURDIR)
+
 %.imx: %.bin
 	$(Q)$(MAKE) $(build)=arch/arm/imx-common $@
 
diff -uraN u-boot-2016.11/Makefile-product gk7205v100_u-boot-2016.11_sdk-C00SPC020/Makefile-product
--- u-boot-2016.11/Makefile-product	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/Makefile-product	2021-06-07 13:01:31.000000000 +0300
@@ -0,0 +1,57 @@
+# FOR AUDIO
+ifeq ($(CONFIG_AUDIO_ENABLE), y)
+ifeq ($(CONFIG_PRODUCTNAME),"gk7205v200")
+libs-y += product/audio/acodec/v750/
+libs-y += product/audio/ao/gk7205v200/
+else ifeq ($(CONFIG_PRODUCTNAME),"gk7205v300")
+libs-y += product/audio/acodec/v750/
+libs-y += product/audio/ao/gk7205v200/
+else ifeq ($(CONFIG_PRODUCTNAME),"gk7202v300")
+libs-y += product/audio/acodec/v750/
+libs-y += product/audio/ao/gk7205v200/
+else ifeq ($(CONFIG_PRODUCTNAME),"gk7605v100")
+libs-y += product/audio/acodec/v750/
+libs-y += product/audio/ao/gk7205v200/
+endif
+endif
+
+ifeq ($(CONFIG_OSD_ENABLE),y)
+# FOR DEC of all chip
+ifneq ($(CONFIG_PRODUCTNAME),"gk7205v200")
+ifneq ($(CONFIG_PRODUCTNAME),"gk7205v300")
+ifneq ($(CONFIG_PRODUCTNAME),"gk7202v300")
+ifneq ($(CONFIG_PRODUCTNAME),"gk7605v100")
+libs-y += ./product/osd/dec/
+endif
+endif
+endif
+endif
+
+# FOR VO,HDMI,MIPI_Tx
+ifeq ($(CONFIG_PRODUCTNAME),"gk7205v300")
+libs-y += ./product/osd/vo/gk7205v200/
+else ifeq ($(CONFIG_PRODUCTNAME),"gk7205v200")
+libs-y += ./product/osd/vo/gk7205v200/
+else ifeq ($(CONFIG_PRODUCTNAME),"gk7202v300")
+libs-y += ./product/osd/vo/gk7205v200/
+else ifeq ($(CONFIG_PRODUCTNAME),"gk7605v100")
+libs-y += ./product/osd/vo/gk7205v200/
+else
+$(warning "warning: "$(CONFIG_PRODUCTNAME)" is invalid")
+endif
+endif
+
+ifndef CONFIG_MINI_BOOT
+ifdef CONFIG_CIPHER_ENABLE
+libs-y += product/otp/
+libs-y += product/cipher/
+endif
+endif
+
+ifeq ($(CONFIG_AUTO_UPDATE),y)
+libs-y += product/update/
+endif
+
+ifeq ($(CONFIG_GK_I2C),y)
+libs-y += product/i2c/
+endif
diff -uraN u-boot-2016.11/net/net.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/net/net.c
--- u-boot-2016.11/net/net.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/net/net.c	2021-06-07 13:01:32.000000000 +0300
@@ -1210,6 +1210,10 @@
 			return;
 		}
 
+		if (ntohs(ip->udp_len) < UDP_HDR_SIZE || ntohs(ip->udp_len) > ntohs(ip->ip_len)) {
+			return;
+		}
+
 		debug_cond(DEBUG_DEV_PKT,
 			   "received UDP (to=%pI4, from=%pI4, len=%d)\n",
 			   &dst_ip, &src_ip, len);
diff -uraN u-boot-2016.11/net/nfs.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/net/nfs.c
--- u-boot-2016.11/net/nfs.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/net/nfs.c	2021-06-07 13:01:32.000000000 +0300
@@ -566,11 +566,15 @@
 	}
 
 	if (supported_nfs_versions & NFSV2_FLAG) {
+		if (((uchar *)&(rpc_pkt.u.reply.data[0]) - (uchar *)(&rpc_pkt) + NFS_FHSIZE) > len)
+			return -NFS_RPC_DROP;
 		memcpy(filefh, rpc_pkt.u.reply.data + 1, NFS_FHSIZE);
 	} else {  /* NFSV3_FLAG */
 		filefh3_length = ntohl(rpc_pkt.u.reply.data[1]);
 		if (filefh3_length > NFS3_FHSIZE)
 			filefh3_length  = NFS3_FHSIZE;
+		if (((uchar *)&(rpc_pkt.u.reply.data[0]) - (uchar *)(&rpc_pkt) + filefh3_length) > len)
+			return -NFS_RPC_DROP;
 		memcpy(filefh, rpc_pkt.u.reply.data + 2, filefh3_length);
 	}
 
@@ -634,6 +638,9 @@
 	/* new path length */
 	rlen = ntohl(rpc_pkt.u.reply.data[1 + nfsv3_data_offset]);
 
+	if (((uchar *)&(rpc_pkt.u.reply.data[0]) - (uchar *)(&rpc_pkt) + rlen) > len)
+		return -NFS_RPC_DROP;
+
 	if (*((char *)&(rpc_pkt.u.reply.data[2 + nfsv3_data_offset])) != '/') {
 		int pathlen;
 
@@ -701,6 +708,9 @@
 			&(rpc_pkt.u.reply.data[4 + nfsv3_data_offset]);
 	}
 
+	if (((uchar *)&(rpc_pkt.u.reply.data[0]) - (uchar *)(&rpc_pkt) + rlen) > len)
+			return -9999;
+
 	if (store_block(data_ptr, nfs_offset, rlen))
 			return -9999;
 
@@ -732,6 +742,9 @@
 
 	debug("%s\n", __func__);
 
+	if (len > sizeof(struct rpc_t))
+		return;
+
 	if (dest != nfs_our_port)
 		return;
 
diff -uraN u-boot-2016.11/product/audio/acodec/v750/acodec.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/acodec/v750/acodec.c
--- u-boot-2016.11/product/audio/acodec/v750/acodec.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/acodec/v750/acodec.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,583 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <common.h>
+#include <command.h>
+#include <version.h>
+#include <asm/io.h>
+#include <asm/arch/platform.h>
+#include <config.h>
+
+#include "type.h"
+#include "audio_ao.h"
+#include "acodec_def.h"
+#include "acodec.h"
+
+#define IO_ADDRESS(x) (x)
+//#define DEBUG_ACODEC
+
+void *g_acodec_crg_reg = NULL;
+
+static unsigned long ulAcodecBase;
+
+unsigned int ACODEC_HAL_ReadReg(unsigned int u32Offset)
+{
+	return (*(volatile unsigned int*)((unsigned long)ulAcodecBase + (unsigned int)u32Offset));
+}
+
+void ACODEC_HAL_WriteReg(unsigned int u32Offset, unsigned int u32Value)
+{
+	*(volatile unsigned int*)((unsigned long)(ulAcodecBase) + (unsigned int)(u32Offset)) = u32Value;
+#ifdef DEBUG_ACODEC
+	printf("### fun:%s line:%d ulAcodecBase :%8lx u32Offset :%x value: %8x\n", __FUNCTION__, __LINE__, ulAcodecBase, u32Offset, u32Value);
+#endif
+}
+
+void ACODEC_HAL_DUMP(unsigned int u32Offset)
+{
+	printf("addr: %8lx  value: %x\n",((unsigned long)ulAcodecBase + (unsigned int)u32Offset),\
+			ACODEC_HAL_ReadReg( u32Offset));
+}
+
+
+static inline void acodec_RegWrite32(unsigned long value, unsigned long mask,
+		unsigned long addr)
+{
+	unsigned long t;
+
+	t = readl((const volatile void*)addr);
+	t &= ~mask;
+	t |= value & mask;
+	writel(t, (volatile void*)addr);
+}
+
+static inline void acodec_regsetbit(
+		unsigned long value,
+		unsigned long offset,
+		unsigned long addr)
+{
+	unsigned long t, mask;
+
+	mask = 1 << offset;
+	t = readl(addr);
+	t &= ~mask;
+	t |= (value << offset) & mask;
+	writel(t, addr);
+}
+
+static inline void GK_RegRead(unsigned long *pvalue, unsigned long addr)
+{
+	*pvalue = readl((const volatile void *)addr);
+}
+
+static void acodec_ana_power_on(void)
+{
+	ACODEC_ANAREG0_U   acodec_anareg0;
+	ACODEC_ANAREG1_U   acodec_anareg1;
+	ACODEC_ANAREG2_U   acodec_anareg2;
+	ACODEC_ANAREG3_U   acodec_anareg3;
+	ACODEC_ANAREG4_U   acodec_anareg4;
+	ACODEC_ANAREG5_U   acodec_anareg5;
+
+#if 1
+	acodec_anareg0.ul32 = ACODEC_ANAREG0_DEFAULT;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG0_ADDR, acodec_anareg0.ul32);
+	acodec_anareg1.ul32 = ACODEC_ANAREG1_DEFAULT;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG1_ADDR, acodec_anareg1.ul32);
+	acodec_anareg2.ul32 = ACODEC_ANAREG2_DEFAULT;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG2_ADDR, acodec_anareg2.ul32);
+	acodec_anareg3.ul32 = ACODEC_ANAREG3_DEFAULT;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG3_ADDR, acodec_anareg3.ul32);
+	acodec_anareg4.ul32 = ACODEC_ANAREG4_DEFAULT;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG4_ADDR, acodec_anareg4.ul32);
+	acodec_anareg5.ul32 = ACODEC_ANAREG5_DEFAULT;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG5_ADDR, acodec_anareg5.ul32);
+#endif
+
+	/************* depop *************/
+
+	/* 1. */
+
+	/* 2. */
+	acodec_anareg3.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG3_ADDR);
+	acodec_anareg3.bits.rstn = 0x1;
+	acodec_anareg3.bits.pd_dac_clk = 0x0;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG3_ADDR, acodec_anareg3.ul32);
+
+	/* 3. */
+	acodec_anareg3.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG3_ADDR);
+	acodec_anareg3.bits.pop_rst = 0x1;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG3_ADDR, acodec_anareg3.ul32);
+
+	/* 4. */
+
+	/* 5. */
+	acodec_anareg0.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG0_ADDR);
+	acodec_anareg0.bits.pd_ctcm_rx = 0x0;
+	acodec_anareg0.bits.pd_ctcm_tx = 0x0;
+	acodec_anareg0.bits.pd_dac_vref = 0x0;
+	acodec_anareg0.bits.pd_ibias = 0x0;
+	acodec_anareg0.bits.pd_ldo = 0x0;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG0_ADDR, acodec_anareg0.ul32);
+
+	/* 6. */
+	acodec_anareg3.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG3_ADDR);
+	acodec_anareg3.bits.pd_dacl_dff = 0x0;
+	acodec_anareg3.bits.pd_dacr_dff = 0x0;
+	acodec_anareg3.bits.mute_dacl = 0x0;
+	acodec_anareg3.bits.mute_dacr = 0x0;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG3_ADDR, acodec_anareg3.ul32);
+
+	/* 7. */
+	acodec_anareg3.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG3_ADDR);
+	acodec_anareg3.bits.pu_pop_pullb_reg = 0x1;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG3_ADDR, acodec_anareg3.ul32);
+
+	/* 8. */
+	acodec_anareg0.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG0_ADDR);
+	acodec_anareg0.bits.pd_vref = 0x0;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG0_ADDR, acodec_anareg0.ul32);
+	acodec_anareg2.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG2_ADDR);
+	acodec_anareg2.bits.vref_pu_pdb = 0x1;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG2_ADDR, acodec_anareg2.ul32);
+
+	udelay(20 * 1000);
+
+	/* 9. */
+	acodec_anareg3.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG3_ADDR);
+	acodec_anareg3.bits.pop_rst = 0x0;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG3_ADDR, acodec_anareg3.ul32);
+
+	/* 10. */
+	acodec_anareg0.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG0_ADDR);
+	acodec_anareg0.bits.pd_lineoutl = 0x0;
+	acodec_anareg0.bits.pd_lineoutr = 0x0;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG0_ADDR, acodec_anareg0.ul32);
+
+	udelay(10 * 1000);
+
+	/* 11. */
+	acodec_anareg3.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG3_ADDR);
+	acodec_anareg3.bits.pop_lineout_pull_en = 0x0;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG3_ADDR, acodec_anareg3.ul32);
+
+	/* 12. */
+	acodec_anareg0.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG0_ADDR);
+	acodec_anareg0.bits.pd_micbias1 = 0x0;
+	acodec_anareg0.bits.pd_micbias2 = 0x0;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG0_ADDR, acodec_anareg0.ul32);
+
+	/* 13. */
+	acodec_anareg1.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG1_ADDR);
+	acodec_anareg1.bits.pd_rctune = 0x0;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG1_ADDR, acodec_anareg1.ul32);
+
+	/* 14. */
+	acodec_anareg1.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG1_ADDR);
+	acodec_anareg1.bits.en_rctune = 0x1;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG1_ADDR, acodec_anareg1.ul32);
+
+	udelay(1 * 1000);
+
+	/* 15. */
+	acodec_anareg0.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG0_ADDR);
+	acodec_anareg0.bits.pd_linein_l = 0x0;
+	acodec_anareg0.bits.pd_linein_r = 0x0;
+	acodec_anareg0.bits.pd_adcl = 0x0;
+	acodec_anareg0.bits.pd_adcr = 0x0;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG0_ADDR, acodec_anareg0.ul32);
+
+	/* 16. */
+	acodec_anareg3.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG3_ADDR);
+	acodec_anareg3.bits.rstb_dac = 0x1;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG3_ADDR, acodec_anareg3.ul32);
+
+}
+
+static void acodec_ana_power_down(void)
+{
+	int i = 0;
+	unsigned int value = 0x0;
+	ACODEC_ANAREG0_U   acodec_anareg0;
+	ACODEC_ANAREG1_U   acodec_anareg1;
+	ACODEC_ANAREG2_U   acodec_anareg2;
+	ACODEC_ANAREG3_U   acodec_anareg3;
+	ACODEC_ANAREG4_U   acodec_anareg4;
+	ACODEC_ANAREG5_U   acodec_anareg5;
+
+	/************* depop *************/
+
+	/* 1. */
+	acodec_anareg0.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG0_ADDR);
+	acodec_anareg0.bits.pd_linein_l = 0x1;
+	acodec_anareg0.bits.pd_linein_r = 0x1;
+	acodec_anareg0.bits.pd_adcl = 0x1;
+	acodec_anareg0.bits.pd_adcr = 0x1;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG0_ADDR, acodec_anareg0.ul32);
+
+	/* 2. */
+	acodec_anareg0.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG0_ADDR);
+	acodec_anareg0.bits.pd_micbias1 = 0x1;
+	acodec_anareg0.bits.pd_micbias2 = 0x1;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG0_ADDR, acodec_anareg0.ul32);
+
+	/* 3. */
+	acodec_anareg3.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG3_ADDR);
+	acodec_anareg3.bits.rstb_dac = 0x0;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG3_ADDR, acodec_anareg3.ul32);
+
+	/* 4. */
+	acodec_anareg3.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG3_ADDR);
+	acodec_anareg3.bits.pop_lineout_pull_en = 0x1;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG3_ADDR, acodec_anareg3.ul32);
+
+	/* 5. */
+	acodec_anareg0.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG0_ADDR);
+	acodec_anareg0.bits.pd_lineoutl = 0x1;
+	acodec_anareg0.bits.pd_lineoutr = 0x1;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG0_ADDR, acodec_anareg0.ul32);
+
+	/* 6. */
+	acodec_anareg0.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG0_ADDR);
+	acodec_anareg0.bits.pd_dac_vref = 0x1;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG0_ADDR, acodec_anareg0.ul32);
+
+	/* 7. */
+	acodec_anareg0.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG0_ADDR);
+	acodec_anareg0.bits.pd_vref = 0x1;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG0_ADDR, acodec_anareg0.ul32);
+
+	value = 0x800;
+	for (i = 0; i < 12; i++)
+	{
+		acodec_anareg4.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG4_ADDR);
+		acodec_anareg4.bits.vref_pd_res_sel = acodec_anareg4.bits.vref_pd_res_sel | value;
+		ACODEC_HAL_WriteReg(ACODEC_ANAREG4_ADDR, acodec_anareg4.ul32);
+		value = value >> 1;
+		udelay(1 * 1000);
+	}
+
+	acodec_anareg2.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG2_ADDR);
+	acodec_anareg2.bits.vref_pu_pdb = 0x0;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG2_ADDR, acodec_anareg2.ul32);
+
+	/* 8. */
+	value = 0x80;
+	for (i = 0; i < 8; i++)
+	{
+		acodec_anareg4.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG4_ADDR);
+		acodec_anareg4.bits.pop_res_sel = acodec_anareg4.bits.pop_res_sel | value;
+		ACODEC_HAL_WriteReg(ACODEC_ANAREG4_ADDR, acodec_anareg4.ul32);
+		value = value >> 1;
+		udelay(1 * 1000);
+	}
+
+	/* 9. */
+	acodec_anareg3.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG3_ADDR);
+	acodec_anareg3.bits.pu_pop_pullb_reg = 0x0;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG3_ADDR, acodec_anareg3.ul32);
+
+	/* 10. */
+	acodec_anareg0.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG0_ADDR);
+	acodec_anareg0.bits.pd_ctcm_rx = 0x1;
+	acodec_anareg0.bits.pd_ctcm_tx = 0x1;
+	acodec_anareg0.bits.pd_ibias = 0x1;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG0_ADDR, acodec_anareg0.ul32);
+
+#if 1
+	acodec_anareg0.ul32 = ACODEC_ANAREG0_DEFAULT;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG0_ADDR, acodec_anareg0.ul32);
+	acodec_anareg1.ul32 = ACODEC_ANAREG1_DEFAULT;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG1_ADDR, acodec_anareg1.ul32);
+	acodec_anareg2.ul32 = ACODEC_ANAREG2_DEFAULT;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG2_ADDR, acodec_anareg2.ul32);
+	acodec_anareg3.ul32 = ACODEC_ANAREG3_DEFAULT;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG3_ADDR, acodec_anareg3.ul32);
+	acodec_anareg4.ul32 = ACODEC_ANAREG4_DEFAULT;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG4_ADDR, acodec_anareg4.ul32);
+	acodec_anareg5.ul32 = ACODEC_ANAREG5_DEFAULT;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG5_ADDR, acodec_anareg5.ul32);
+#endif
+}
+
+
+static int acodec_soft_reset(void)
+{
+	ACODEC_DIGCTRL1_U   acodec_digctrl1;
+	ACODEC_DIGCTRL2_U   acodec_digctrl2;
+	ACODEC_DIGCTRL3_U   acodec_digctrl3;
+	ACODEC_DIGCTRL4_U   acodec_digctrl4;
+	ACODEC_DIGCTRL5_U   acodec_digctrl5;
+
+	ACODEC_ANAREG0_U   acodec_anareg0;
+	ACODEC_ANAREG1_U   acodec_anareg1;
+	ACODEC_ANAREG2_U   acodec_anareg2;
+	ACODEC_ANAREG3_U   acodec_anareg3;
+	ACODEC_ANAREG4_U   acodec_anareg4;
+	ACODEC_ANAREG5_U   acodec_anareg5;
+
+	acodec_anareg0.ul32 = 0x1C1C0000;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG0_ADDR, acodec_anareg0.ul32);
+
+	acodec_anareg1.ul32 = 0xDF605E66;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG1_ADDR, acodec_anareg1.ul32);
+
+	acodec_anareg2.ul32 = 0x00255544;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG2_ADDR, acodec_anareg2.ul32);
+
+	acodec_anareg3.ul32 = 0x072D0451;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG3_ADDR, acodec_anareg3.ul32);
+
+	acodec_anareg4.ul32 = 0x00000000;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG4_ADDR, acodec_anareg4.ul32);
+
+	acodec_anareg5.ul32 = 0x00000000;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG5_ADDR, acodec_anareg5.ul32);
+
+	acodec_digctrl1.ul32 = 0xff035a00;
+	ACODEC_HAL_WriteReg(ACODEC_DIGCTRL1_ADDR, acodec_digctrl1.ul32);
+
+	acodec_digctrl2.ul32 = 0x08000001;
+	ACODEC_HAL_WriteReg(ACODEC_DIGCTRL2_ADDR, acodec_digctrl2.ul32);
+
+	acodec_digctrl3.ul32 = 0x06062424;
+	ACODEC_HAL_WriteReg(ACODEC_DIGCTRL3_ADDR, acodec_digctrl3.ul32);
+
+	acodec_digctrl4.ul32 = 0x1e1ec001;
+	ACODEC_HAL_WriteReg(ACODEC_DIGCTRL4_ADDR, acodec_digctrl4.ul32);
+
+	acodec_digctrl5.ul32 = 0x24242424;
+	ACODEC_HAL_WriteReg(ACODEC_DIGCTRL5_ADDR, acodec_digctrl5.ul32);
+
+	return 0;
+}
+
+static int acodec_geti2sfs(ACODEC_FS_E enAcodecFs)
+{
+	switch(enAcodecFs)
+	{
+		case ACODEC_FS_8000:
+		case ACODEC_FS_11025:
+		case ACODEC_FS_12000:
+			return ACODEC_I2S_FS_8000;
+		case ACODEC_FS_16000:
+		case ACODEC_FS_22050:
+		case ACODEC_FS_24000:
+			return ACODEC_I2S_FS_16000;
+		case ACODEC_FS_32000:
+		case ACODEC_FS_44100:
+		case ACODEC_FS_48000:
+			return ACODEC_I2S_FS_32000;
+		case ACODEC_FS_64000:
+		case ACODEC_FS_96000:
+			return ACODEC_I2S_FS_64000;
+		default:
+			printf("Unsupport samplerate %d.\n", enAcodecFs);
+			return ACODEC_I2S_FS_BUTT;
+	}
+}
+
+static int acodec_getadcmodesel(ACODEC_FS_E enAcodecFs)
+{
+	switch(enAcodecFs)
+	{
+		case ACODEC_FS_8000:
+		case ACODEC_FS_16000:
+		case ACODEC_FS_32000:
+		case ACODEC_FS_64000:
+			return ACODEC_ADC_MODESEL_4096;
+		case ACODEC_FS_11025:
+		case ACODEC_FS_12000:
+		case ACODEC_FS_22050:
+		case ACODEC_FS_24000:
+		case ACODEC_FS_44100:
+		case ACODEC_FS_48000:
+		case ACODEC_FS_96000:
+			return ACODEC_ADC_MODESEL_6144;
+		default:
+			printf("Unsupport samplerate %d.\n", enAcodecFs);
+			return ACODEC_I2S_FS_BUTT;
+	}
+}
+
+static ACODEC_FS_E acodec_getacodecfs(AUDIO_SAMPLE_RATE_E enSample)
+{
+	ACODEC_FS_E enAcodecFs = ACODEC_FS_BUTT;
+	switch(enSample)
+	{
+		case AUDIO_SAMPLE_RATE_8000:
+			enAcodecFs = ACODEC_FS_8000;
+			break;
+
+		case AUDIO_SAMPLE_RATE_11025:
+			enAcodecFs = ACODEC_FS_11025;
+			break;
+
+		case AUDIO_SAMPLE_RATE_12000:
+			enAcodecFs = ACODEC_FS_12000;
+			break;
+
+		case AUDIO_SAMPLE_RATE_16000:
+			enAcodecFs = ACODEC_FS_16000;
+			break;
+
+		case AUDIO_SAMPLE_RATE_22050:
+			enAcodecFs = ACODEC_FS_22050;
+			break;
+
+		case AUDIO_SAMPLE_RATE_24000:
+			enAcodecFs = ACODEC_FS_24000;
+			break;
+
+		case AUDIO_SAMPLE_RATE_32000:
+			enAcodecFs = ACODEC_FS_32000;
+			break;
+
+		case AUDIO_SAMPLE_RATE_44100:
+			enAcodecFs = ACODEC_FS_44100;
+			break;
+
+		case AUDIO_SAMPLE_RATE_48000:
+			enAcodecFs = ACODEC_FS_48000;
+			break;
+
+		default:
+			printf("Unsupport samplerate %d.\n", enSample);
+			break;
+	}
+
+	return enAcodecFs;
+}
+
+
+int acodec_i2s_set(AUDIO_SAMPLE_RATE_E enSample)
+{
+	ACODEC_FS_E enAcodecFs = ACODEC_FS_BUTT;
+	ACODEC_DIGCTRL1_U   unDigctrl1;
+	ACODEC_ANAREG1_U    unAnaReg1;
+
+	enAcodecFs = acodec_getacodecfs(enSample);
+	if(enAcodecFs == ACODEC_FS_BUTT)
+	{
+		printf("%s: not support enSample:%d.\n", __FUNCTION__, enSample);
+		return -1;
+	}
+
+	unDigctrl1.ul32 = ACODEC_HAL_ReadReg(ACODEC_DIGCTRL1_ADDR);
+	unDigctrl1.bits.i2s1_fs_sel = acodec_geti2sfs(enAcodecFs);
+	ACODEC_HAL_WriteReg(ACODEC_DIGCTRL1_ADDR, unDigctrl1.ul32);
+
+	unAnaReg1.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG1_ADDR);
+	unAnaReg1.bits.mode_adcr = acodec_getadcmodesel(enAcodecFs);
+	unAnaReg1.bits.mode_adcl = acodec_getadcmodesel(enAcodecFs);
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG1_ADDR, unAnaReg1.ul32);
+
+	//rctune
+	unAnaReg1.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG1_ADDR);
+	unAnaReg1.bits.en_rctune = 0;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG1_ADDR, unAnaReg1.ul32);
+
+	udelay(30);
+	unAnaReg1.ul32 = ACODEC_HAL_ReadReg(ACODEC_ANAREG1_ADDR);
+	unAnaReg1.bits.en_rctune = 1;
+	ACODEC_HAL_WriteReg(ACODEC_ANAREG1_ADDR, unAnaReg1.ul32);
+
+	return 0;
+}
+
+int acodec_device_init(void)
+{
+	AUDIO_REG_1_U       acodec_audio_reg;
+	ACODEC_DIGCTRL1_U   acodec_digctrl1;
+	ACODEC_DIGCTRL2_U   acodec_digctrl2;
+	ACODEC_DIGCTRL3_U   acodec_digctrl3;
+
+	unsigned int aiao_crg = 0;
+	unsigned int aiao_cfg = 0;
+
+	ulAcodecBase = (unsigned int)IO_ADDRESS(ACODEC_REGS_BASE);
+	if (ulAcodecBase == 0)
+	{
+		printf("could not ioremap acodec regs!");
+		return -1;
+	}
+
+	g_acodec_crg_reg = (void *)IO_ADDRESS(ACODEC_REGS_CRG);
+	if (g_acodec_crg_reg == NULL)
+	{
+		printf("could not ioremap acodec regs!");
+		return -1;
+	}
+
+	udelay(1 * 1000);
+
+	// audio crg
+	acodec_regsetbit(1, 1, (unsigned long)((gk_uintptr_t)g_acodec_crg_reg));
+	acodec_regsetbit(1, 2, (unsigned long)((gk_uintptr_t)g_acodec_crg_reg));
+
+	// aiao clk
+	aiao_crg = (unsigned int)IO_ADDRESS(AIAO_CLK_TX0_CRG);
+	*(volatile unsigned int*)((unsigned long)(aiao_crg)) = 0x00152EF0;
+	aiao_cfg = (unsigned int)IO_ADDRESS(AIAO_CLK_TX0_CFG);
+	*(volatile unsigned int*)((unsigned long)(aiao_cfg)) = 0x00000115;
+
+	udelay(50 * 1000);
+
+	// acodec mux
+	acodec_audio_reg.ul32 = 0xf;
+	ACODEC_HAL_WriteReg(ACODEC_AUDIO_REG, acodec_audio_reg.ul32);
+
+	// digctrl
+	acodec_digctrl1.ul32 = 0xff035a00;
+	ACODEC_HAL_WriteReg(ACODEC_DIGCTRL1_ADDR, acodec_digctrl1.ul32);
+
+	acodec_digctrl2.ul32 = 0x08000001;
+	ACODEC_HAL_WriteReg(ACODEC_DIGCTRL2_ADDR, acodec_digctrl2.ul32);
+
+	acodec_digctrl3.ul32 = 0x7e7e2424;
+	ACODEC_HAL_WriteReg(ACODEC_DIGCTRL3_ADDR, acodec_digctrl3.ul32);
+
+	udelay(1 * 1000);
+
+	acodec_ana_power_on();
+
+	udelay(1 * 1000);
+
+	acodec_soft_reset();
+
+	printf("acodec inited!\n");
+
+	return 0;
+}
+
+int acodec_device_exit(void)
+{
+	ACODEC_DIGCTRL3_U   acodec_digctrl3;
+
+	unsigned int aiao_crg = 0;
+	unsigned int aiao_cfg = 0;
+
+	acodec_soft_reset();
+
+	udelay(1 * 1000);
+
+	acodec_ana_power_down();
+
+	// digctrl
+	acodec_digctrl3.ul32 = 0x7f7f2424;
+	ACODEC_HAL_WriteReg(ACODEC_DIGCTRL3_ADDR, acodec_digctrl3.ul32);
+
+	// audio crg
+	acodec_regsetbit(0, 1, (unsigned long)((gk_uintptr_t)g_acodec_crg_reg));
+	acodec_regsetbit(0, 2, (unsigned long)((gk_uintptr_t)g_acodec_crg_reg));
+
+	// aiao clk
+	aiao_crg = (unsigned int)IO_ADDRESS(AIAO_CLK_TX0_CRG);
+	*(volatile unsigned int*)((unsigned long)(aiao_crg)) = 0x00152EF0;
+	aiao_cfg = (unsigned int)IO_ADDRESS(AIAO_CLK_TX0_CFG);
+	*(volatile unsigned int*)((unsigned long)(aiao_cfg)) = 0x00000115;
+
+	printf("acodec exited!\n");
+	return 0;
+}
diff -uraN u-boot-2016.11/product/audio/acodec/v750/acodec_def.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/acodec/v750/acodec_def.h
--- u-boot-2016.11/product/audio/acodec/v750/acodec_def.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/acodec/v750/acodec_def.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,359 @@
+#ifndef _ACODEC_DEF_H_
+#define _ACODEC_DEF_H_
+
+
+#define ACODEC_REGS_CRG  0x1201019C  //aio crg
+#define AIAO_CLK_TX0_CRG 0x100E0140
+#define AIAO_CLK_TX0_CFG 0x100E0144
+#define AIAO_REGS_BASE   0x100E0000
+
+#define AIAO_CLK_TX0_CRG_OFFSET 0x140
+#define AIAO_CLK_TX0_CFG_OFFSET 0x144
+
+#define ACODEC_CRG_BASE    0x12010000
+#define ACODEC_CRG_OFFSET  0x019C
+#define ACODEC_REGS_OFFSET 0x0
+
+#define ACODEC_REGS_BASE 0x100F0000
+
+/*acodec analog register*/
+#define ACODEC_ANAREG0_ADDR (0x00)
+#define ACODEC_ANAREG1_ADDR (0x04)
+#define ACODEC_ANAREG2_ADDR (0x08)
+#define ACODEC_ANAREG3_ADDR (0x0C)
+#define ACODEC_ANAREG4_ADDR (0x10)
+#define ACODEC_ANAREG5_ADDR (0x14)
+
+/*acodec dig control register*/
+#define ACODEC_DIGCTRL1_ADDR (0xCC)
+#define ACODEC_DIGCTRL2_ADDR (0xD0)
+#define ACODEC_DIGCTRL3_ADDR (0xD4)
+#define ACODEC_DIGCTRL4_ADDR (0xD8)
+#define ACODEC_DIGCTRL5_ADDR (0xDC)
+
+/*default value of acodec analog register*/
+#define ACODEC_ANAREG0_DEFAULT 0x3434DFFF
+#define ACODEC_ANAREG1_DEFAULT 0xDF605E65
+#define ACODEC_ANAREG2_DEFAULT 0x00255548
+#define ACODEC_ANAREG3_DEFAULT 0x04293B50
+#define ACODEC_ANAREG4_DEFAULT 0x00000000
+#define ACODEC_ANAREG5_DEFAULT 0x00000000
+
+#define ACODEC_AUDIO_REG (0xE0)
+
+/* Define the union ACODEC_ANAREG0_U */
+typedef union ACODEC_ANAREG0_u
+{
+	/* Define the struct bits */
+	struct
+	{
+		unsigned int    mute_linein_r         : 1   ; /* [0]  */
+		unsigned int    mute_linein_l         : 1   ; /* [1]  */
+		unsigned int    pd_linein_r           : 1   ; /* [2]  */
+		unsigned int    pd_linein_l           : 1   ; /* [3]  */
+		unsigned int    pd_adcr               : 1   ; /* [4]  */
+		unsigned int    pd_adcl               : 1   ; /* [5]  */
+		unsigned int    pd_lineoutr           : 1   ; /* [6]  */
+		unsigned int    pd_lineoutl           : 1   ; /* [7]  */
+		unsigned int    pd_vref               : 1   ; /* [8]  */
+		unsigned int    pd_ibias              : 1   ; /* [9]  */
+		unsigned int    pd_ctcm_rx            : 1   ; /* [10]  */
+		unsigned int    pd_ctcm_tx            : 1   ; /* [11]  */
+		unsigned int    pd_dac_vref           : 1   ; /* [12]  */
+		unsigned int    pd_ldo                : 1   ; /* [13]  */
+		unsigned int    pd_micbias2           : 1   ; /* [14]  */
+		unsigned int    pd_micbias1           : 1   ; /* [15]  */
+		unsigned int    linein_l_sel          : 3   ; /* [18..16]  */
+		unsigned int    linein_l_gain         : 5   ; /* [23..19]  */
+		unsigned int    linein_r_sel          : 3   ; /* [26..24]  */
+		unsigned int    linein_r_gain         : 5   ; /* [31..27]  */
+
+	} bits;
+	unsigned int ul32;
+
+} ACODEC_ANAREG0_U;
+
+/* Define the union ACODEC_ANAREG1_U */
+typedef union ACODEC_ANAREG1_u
+{
+	/* Define the struct bits */
+	struct
+	{
+		unsigned int    pd_rctune             : 1   ; /* [0]  */
+		unsigned int    en_rctune             : 1   ; /* [1]  */
+		unsigned int    adc_tune_sel          : 1   ; /* [2]  */
+		unsigned int    adc_tune_code         : 5   ; /* [7..3]  */
+		unsigned int    byp_adc_dwa           : 1   ; /* [8]  */
+		unsigned int    adc_the_clk_phsel     : 1   ; /* [9]  */
+		unsigned int    adc_bin_clk_phsel     : 1   ; /* [10]  */
+		unsigned int    adc_chop_clk_phsel    : 1   ; /* [11]  */
+		unsigned int    linein_chop_clk_sel   : 2   ; /* [13..12]  */
+		unsigned int    adc_chop_clk_sel      : 2   ; /* [15..14]  */
+		unsigned int    boost_adcr            : 1   ; /* [16]  */
+		unsigned int    boost_adcl            : 1   ; /* [17]  */
+		unsigned int    mode_adcr             : 1   ; /* [18]  */
+		unsigned int    mode_adcl             : 1   ; /* [19]  */
+		unsigned int    adc_dac_ib_sel        : 2   ; /* [21..20]  */
+		unsigned int    adc_fls_vref          : 2   ; /* [23..22]  */
+		unsigned int    adc_mis_selp          : 4   ; /* [27..24]  */
+		unsigned int    adc_mis_seln          : 4   ; /* [31..28]  */
+
+	} bits;
+	unsigned int ul32;
+
+} ACODEC_ANAREG1_U;
+
+/* Define the union ACODEC_ANAREG2_U */
+typedef union ACODEC_ANAREG2_u
+{
+	/* Define the struct bits */
+	struct
+	{
+		unsigned int    ana_loop              : 1   ; /* [0]  */
+		unsigned int    fs_vref               : 1   ; /* [1]  */
+		unsigned int    vref_pu_pdb           : 1   ; /* [2]  */
+		unsigned int    ldo_bk_en             : 1   ; /* [3]  */
+		unsigned int    ss_sel_vref           : 4   ; /* [7..4]  */
+		unsigned int    ibadj_linein          : 2   ; /* [9..8]  */
+		unsigned int    ibadj_adc             : 2   ; /* [11..10]  */
+		unsigned int    ibadj_ctcm            : 2   ; /* [13..12]  */
+		unsigned int    ibadj_micbias         : 2   ; /* [15..14]  */
+		unsigned int    ibadj_dac_vref        : 2   ; /* [17..16]  */
+		unsigned int    ibadj_lineout         : 2   ; /* [19..18]  */
+		unsigned int    ldo_sel               : 2   ; /* [21..20]  */
+		unsigned int    byp_chop_linein       : 1   ; /* [22]  */
+		unsigned int    byp_chop_adc          : 1   ; /* [23]  */
+		unsigned int    byp_chop_dac_vref     : 1   ; /* [24]  */
+		unsigned int    byp_chop_ctcm_tx      : 1   ; /* [25]  */
+		unsigned int    byp_chop_ctcm_rx      : 1   ; /* [26]  */
+		unsigned int    micbias_adj           : 3   ; /* [29..27]  */
+		unsigned int    reserved_0            : 2   ; /* [31..30]  */
+
+	} bits;
+	unsigned int ul32;
+
+} ACODEC_ANAREG2_U;
+
+/* Define the union ACODEC_ANAREG3_U */
+typedef union ACODEC_ANAREG3_u
+{
+	/* Define the struct bits */
+	struct
+	{
+		unsigned int    rstn                  : 1   ; /* [0]  */
+		unsigned int    ctrl_mclk_ph          : 1   ; /* [1]  */
+		unsigned int    ctrl_clk_dac_ph       : 1   ; /* [2]  */
+		unsigned int    ctrl_clk_adc_ph       : 1   ; /* [3]  */
+		unsigned int    sel_clk_chop_dac_vref : 2   ; /* [5..4]  */
+		unsigned int    sel_clk_chop_ctcm     : 2   ; /* [7..6]  */
+		unsigned int    mute_dacr             : 1   ; /* [8]  */
+		unsigned int    mute_dacl             : 1   ; /* [9]  */
+		unsigned int    rstb_dac              : 1   ; /* [10]  */
+		unsigned int    pd_dacr_dff           : 1   ; /* [11]  */
+		unsigned int    pd_dacl_dff           : 1   ; /* [12]  */
+		unsigned int    pd_dac_clk            : 1   ; /* [13]  */
+		unsigned int    reserved_0            : 2   ; /* [15..14]  */
+		unsigned int    pop_sel_0h1s          : 1   ; /* [16]  */
+		unsigned int    pop_lineout_pull_en   : 1   ; /* [17]  */
+		unsigned int    pu_pop_pullb_reg      : 1   ; /* [18]  */
+		unsigned int    pop_r_track_l_en      : 1   ; /* [19]  */
+		unsigned int    pullout_weak          : 1   ; /* [20]  */
+		unsigned int    pop_spd_cfg           : 2   ; /* [22..21]  */
+		unsigned int    reserved_1            : 1   ; /* [23]  */
+		unsigned int    pop_dis               : 1   ; /* [24]  */
+		unsigned int    pop_rst               : 1   ; /* [25]  */
+		unsigned int    pop_pdm_dly_cfg       : 2   ; /* [27..26]  */
+		unsigned int    reserved_2            : 4   ; /* [31..28]  */
+
+	} bits;
+	unsigned int ul32;
+
+} ACODEC_ANAREG3_U;
+
+/* Define the union ACODEC_ANAREG4_U */
+typedef union ACODEC_ANAREG4_u
+{
+	/* Define the struct bits */
+	struct
+	{
+		unsigned int    reserved_0            : 8   ; /* [7..0]  */
+		unsigned int    vref_pd_res_sel       : 12  ; /* [19..8]  */
+		unsigned int    reserved_1            : 4   ; /* [23..20]  */
+		unsigned int    pop_res_sel           : 8   ; /* [31..24]  */
+
+	} bits;
+	unsigned int ul32;
+
+} ACODEC_ANAREG4_U;
+
+/* Define the union ACODEC_ANAREG5_U */
+typedef union ACODEC_ANAREG5_u
+{
+	/* Define the struct bits */
+	struct
+	{
+		unsigned int    reserved              : 8   ; /* [7..0]  */
+
+	} bits;
+	unsigned int ul32;
+
+} ACODEC_ANAREG5_U;
+
+/* Define the union ACODEC_DIGCTRL1_U */
+typedef union ACODEC_DIGCTRL1_u
+{
+	/* Define the struct bits */
+	struct
+	{
+		unsigned int    reserved_0            : 8   ; /* [7..0]  */
+		unsigned int    i2s2_fs_sel           : 5   ; /* [12..8]  */
+		unsigned int    i2s1_fs_sel           : 5   ; /* [17..13]  */
+		unsigned int    dig_loop              : 1   ; /* [18]  */
+		unsigned int    dig_bypass            : 1   ; /* [19]  */
+		unsigned int    i2s2_data_bits        : 2   ; /* [21..20]  */
+		unsigned int    i2s1_data_bits        : 2   ; /* [23..22]  */
+		unsigned int    adcr_en               : 1   ; /* [24]  */
+		unsigned int    adcl_en               : 1   ; /* [25]  */
+		unsigned int    dacr_en               : 1   ; /* [26]  */
+		unsigned int    dacl_en               : 1   ; /* [27]  */
+		unsigned int    adcr_rst_n            : 1   ; /* [28]  */
+		unsigned int    adcl_rst_n            : 1   ; /* [29]  */
+		unsigned int    dacr_rst_n            : 1   ; /* [30]  */
+		unsigned int    dacl_rst_n            : 1   ; /* [31]  */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    ul32;
+
+} ACODEC_DIGCTRL1_U;
+
+/* Define the union ACODEC_DIGCTRL2_U */
+typedef union ACODEC_DIGCTRL2_u
+{
+	/* Define the struct bits */
+	struct
+	{
+		unsigned int    dacr_lrsel            : 1   ; /* [0]  */
+		unsigned int    dacr_i2ssel           : 1   ; /* [1]  */
+		unsigned int    dacl_lrsel            : 1   ; /* [2]  */
+		unsigned int    dal_i2ssel            : 1   ; /* [3]  */
+		unsigned int    reserved_0            : 15  ; /* [18..4]  */
+		unsigned int    dacr_deemph           : 2   ; /* [20..19]  */
+		unsigned int    dacl_deemph           : 2   ; /* [22..21]  */
+		unsigned int    muter_rate            : 2   ; /* [24..23]  */
+		unsigned int    mutel_rate            : 2   ; /* [26..25]  */
+		unsigned int    dacvu                 : 1   ; /* [27]  */
+		unsigned int    sunmuter              : 1   ; /* [28]  */
+		unsigned int    sunmutel              : 1   ; /* [29]  */
+		unsigned int    smuter                : 1   ; /* [30]  */
+		unsigned int    smutel                : 1   ; /* [31]  */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    ul32;
+
+} ACODEC_DIGCTRL2_U;
+
+/* Define the union ACODEC_DIGCTRL3_U */
+typedef union ACODEC_DIGCTRL3_u
+{
+	/* Define the struct bits */
+	struct
+	{
+		unsigned int    dacl2dacr_vol         : 7   ; /* [6..0]  */
+		unsigned int    dacl2dacr_en          : 1   ; /* [7]  */
+		unsigned int    dacr2dacl_vol         : 7   ; /* [14..8]  */
+		unsigned int    dacr2dacl_en          : 1   ; /* [15]  */
+		unsigned int    dacr_vol              : 7   ; /* [22..16]  */
+		unsigned int    dacr_mute             : 1   ; /* [23]  */
+		unsigned int    dacl_vol              : 7   ; /* [30..24]  */
+		unsigned int    dacl_mute             : 1   ; /* [31]  */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    ul32;
+
+} ACODEC_DIGCTRL3_U;
+
+/* Define the union ACODEC_DIGCTRL4_U */
+typedef union ACODEC_DIGCTRL4_u
+{
+	/* Define the struct bits */
+	struct
+	{
+		unsigned int    adcr_lrsel            : 1   ; /* [0]  */
+		unsigned int    adcr_i2ssel           : 1   ; /* [1]  */
+		unsigned int    adcl_lrsel            : 1   ; /* [2]  */
+		unsigned int    adcl_i2ssel           : 1   ; /* [3]  */
+		unsigned int    reserved_0            : 10  ; /* [13..4]  */
+		unsigned int    adcr_hpf_en           : 1   ; /* [14]  */
+		unsigned int    adcl_hpf_en           : 1   ; /* [15]  */
+		unsigned int    adcr_vol              : 7   ; /* [22..16]  */
+		unsigned int    adcr_mute             : 1   ; /* [23]  */
+		unsigned int    adcl_vol              : 7   ; /* [30..24]  */
+		unsigned int    adcl_mute             : 1   ; /* [31]  */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    ul32;
+
+} ACODEC_DIGCTRL4_U;
+
+/* Define the union ACODEC_DIGCTRL5_U */
+typedef union ACODEC_DIGCTRL5_u
+{
+	/* Define the struct bits */
+	struct
+	{
+		unsigned int    adcr2dacr_vol         : 7   ; /* [6..0]  */
+		unsigned int    adcr2dacr_en          : 1   ; /* [7]  */
+		unsigned int    adcl2dacr_vol         : 7   ; /* [14..8]  */
+		unsigned int    adcl2dacr_en          : 1   ; /* [15]  */
+		unsigned int    adcr2dacl_vol         : 7   ; /* [22..16]  */
+		unsigned int    adcr2dacl_en          : 1   ; /* [23]  */
+		unsigned int    adcl2dacl_vol         : 7   ; /* [30..24]  */
+		unsigned int    adcl2dacl_en          : 1   ; /* [31]  */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    ul32;
+
+} ACODEC_DIGCTRL5_U;
+
+/* Define the union AUDIO_REG_1_U */
+typedef union
+{
+	/* Define the struct bits */
+	struct
+	{
+		unsigned int    pad_tx_en            : 1   ; /* [0]  */
+		unsigned int    audio_rx_bclk_sel    : 1   ; /* [1]  */
+		unsigned int    rx_sd_sel            : 1   ; /* [2]  */
+		unsigned int    audio_mclk_sel       : 1   ; /* [3]  */
+		unsigned int    reserved_0           : 28  ; /* [31..4]  */
+	} bits;
+
+	/* Define an unsigned member */
+	unsigned int    ul32;
+
+} AUDIO_REG_1_U;
+
+//==============================================================================
+/* Define the global struct */
+typedef struct
+{
+	volatile ACODEC_ANAREG0_U       AUDIO_ANA_CTRL_0;
+	volatile ACODEC_ANAREG1_U       AUDIO_ANA_CTRL_1;
+	volatile ACODEC_ANAREG2_U       AUDIO_ANA_CTRL_2;
+	volatile ACODEC_ANAREG3_U       AUDIO_ANA_CTRL_3;
+	volatile ACODEC_ANAREG4_U       AUDIO_ANA_CTRL_4;
+	volatile ACODEC_ANAREG5_U       AUDIO_ANA_CTRL_5;
+	volatile ACODEC_DIGCTRL1_U      AUDIO_CTRL_REG_1;
+	volatile ACODEC_DIGCTRL2_U      AUDIO_DAC_REG_0;
+	volatile ACODEC_DIGCTRL3_U      AUDIO_DAC_REG_1;
+	volatile ACODEC_DIGCTRL4_U      AUDIO_ADC_REG_0;
+	volatile ACODEC_DIGCTRL5_U      AUDIO_ADC_REG_1;
+	volatile AUDIO_REG_1_U          AUDIO_REG_1;
+} S_ACODEC_REGS_TYPE;
+#endif /* End of #ifndef _ACODEC_H */
+
diff -uraN u-boot-2016.11/product/audio/acodec/v750/acodec.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/acodec/v750/acodec.h
--- u-boot-2016.11/product/audio/acodec/v750/acodec.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/acodec/v750/acodec.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,46 @@
+#ifndef _ACODEC_H_
+#define _ACODEC_H_
+
+typedef enum ACODEC_FS_E
+{
+	ACODEC_FS_8000  =   0x1,
+	ACODEC_FS_11025 =   0x2,
+	ACODEC_FS_12000 =   0x3,
+	ACODEC_FS_16000 =   0x4,
+	ACODEC_FS_22050 =   0x5,
+	ACODEC_FS_24000 =   0x6,
+	ACODEC_FS_32000 =   0x7,
+	ACODEC_FS_44100 =   0x8,
+	ACODEC_FS_48000 =   0x9,
+	ACODEC_FS_64000 =   0xa,
+	ACODEC_FS_96000 =   0xb,
+
+	ACODEC_FS_BUTT = 0x1c,
+} ACODEC_FS_E;
+
+typedef enum ACODEC_I2S_FS_E
+{
+	ACODEC_I2S_FS_8000  =   0x18,
+	ACODEC_I2S_FS_11025 =   0x18,
+	ACODEC_I2S_FS_12000 =   0x18,
+	ACODEC_I2S_FS_16000 =   0x19,
+	ACODEC_I2S_FS_22050 =   0x19,
+	ACODEC_I2S_FS_24000 =   0x19,
+	ACODEC_I2S_FS_32000 =   0x1a,
+	ACODEC_I2S_FS_44100 =   0x1a,
+	ACODEC_I2S_FS_48000 =   0x1a,
+	ACODEC_I2S_FS_64000 =   0x1b,
+	ACODEC_I2S_FS_96000 =   0x1b,
+
+	ACODEC_I2S_FS_BUTT = 0x1c,
+} ACODEC_I2S_FS_E;
+
+typedef enum ACODEC_ADC_MODESEL_E
+{
+	ACODEC_ADC_MODESEL_6144  =   0x0,
+	ACODEC_ADC_MODESEL_4096  =   0x1,
+
+	ACODEC_ADC_MODESEL_BUTT = 0xff,
+} ACODEC_ADC_MODESEL_E;
+
+#endif /* End of #ifndef _ACODEC_H_ */
diff -uraN u-boot-2016.11/product/audio/acodec/v750/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/acodec/v750/Makefile
--- u-boot-2016.11/product/audio/acodec/v750/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/acodec/v750/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,25 @@
+sinclude $(TOPDIR)/config.mk
+
+#LIB := $(obj)libacodec.a
+
+obj-y += acodec.o
+
+
+#COBJS	:= $(COBJS-y)
+#SRCS	:= $(COBJS:.o=.c)
+#OBJS	:= $(addprefix $(obj),$(COBJS))
+
+#all:	$(LIB)
+
+#$(LIB):	$(obj).depend $(OBJS)
+#	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+#include $(SRCTREE)/rules.mk
+
+#sinclude $(obj).depend
+
+#########################################################################
+
diff -uraN u-boot-2016.11/product/audio/acodec/v750/type.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/acodec/v750/type.h
--- u-boot-2016.11/product/audio/acodec/v750/type.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/acodec/v750/type.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __GK_TYPE_H__
+#define __GK_TYPE_H__
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+typedef unsigned char           GK_U8;
+typedef unsigned short          GK_U16;
+typedef unsigned int            GK_U32;
+
+typedef signed char             GK_S8;
+typedef short                   GK_S16;
+typedef int                     GK_S32;
+
+typedef unsigned long           GK_UL;
+typedef signed long             GK_SL;
+
+typedef float               GK_FLOAT;
+typedef double                  GK_DOUBLE;
+
+#ifndef _M_IX86
+typedef unsigned long long  GK_U64;
+typedef long long           GK_S64;
+#else
+typedef unsigned __int64    GK_U64;
+typedef __int64             GK_S64;
+#endif
+
+typedef char                    GK_CHAR;
+#define GK_VOID                 void
+
+typedef GK_U32                  GK_HANDLE;
+
+typedef enum {
+	GK_FALSE = 0,
+	GK_TRUE  = 1,
+} GK_BOOL;
+
+#ifndef NULL
+#define NULL    0L
+#endif
+
+#define GK_NULL     0L
+#define GK_SUCCESS  0
+#define GK_FAILURE  (-1)
+
+typedef unsigned char           gk_uchar;
+typedef unsigned char           gk_u8;
+typedef unsigned short          gk_u16;
+typedef unsigned int            gk_u32;
+typedef unsigned long long      gk_u64;
+typedef unsigned long           gk_ulong;
+
+typedef char                    gk_char;
+typedef signed char             gk_s8;
+typedef short                   gk_s16;
+typedef int                     gk_s32;
+typedef long long               gk_s64;
+typedef long                    gk_slong;
+
+typedef float                   gk_float;
+typedef double                  gk_double;
+
+typedef void                    gk_void;
+
+typedef unsigned long           gk_size_t;
+typedef unsigned long           gk_length_t;
+
+typedef gk_u32                  gk_handle;
+
+typedef GK_BOOL                 gk_bool;
+typedef uintptr_t               gk_uintptr_t;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __GK_TYPE_H__ */
diff -uraN u-boot-2016.11/product/audio/ao/gk7205v200/aiao_ext.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/ao/gk7205v200/aiao_ext.h
--- u-boot-2016.11/product/audio/ao/gk7205v200/aiao_ext.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/ao/gk7205v200/aiao_ext.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __AIAO_EXT_H__
+#define __AIAO_EXT_H__
+
+typedef struct AIO_DRV_DEV_CTX_S
+{
+	struct
+	{
+		GK_U32          u32BufSize;
+		GK_U32          u32PhyAddr;
+		GK_U8*          pu8VirAddr;
+
+		GK_U32          u32RptrOffSet;
+		GK_U32          u32WptrOffSet;
+
+	} stCirBuf;
+
+	AIO_ATTR_S          stAioAttr;
+	GK_BOOL             bEnable;
+
+	GK_U64              u64LastPts;
+	GK_U32              u32FrmTime;
+	GK_U32              u32MaxFrmTime;
+	GK_U32              u32IsrTime;
+	GK_U32              u32MaxIsrTime;
+	GK_U32              u32AioFifoLen;
+	GK_U32              u32FifoLenBase;
+	GK_U32              u32FifoShift;
+	GK_U32              u32TransLen;
+
+	GK_S32              as32ChnIndex[AIO_MAX_CHN_NUM];
+
+	GK_U32              u32IntCnt;
+	GK_U32              u32fifoIntCnt;
+	GK_U32              u32buffIntCnt;
+	AUDIO_TRACK_MODE_E  enTrackMode;
+	GK_BOOL             bMute;
+	AUDIO_FADE_S        stFade;
+	GK_S32              s32Volume;
+	GK_BOOL             bMicInl;
+	GK_BOOL             bMicInr;
+}AIO_DRV_DEV_CTX_S;
+
+#endif
diff -uraN u-boot-2016.11/product/audio/ao/gk7205v200/aiao_hal.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/ao/gk7205v200/aiao_hal.c
--- u-boot-2016.11/product/audio/ao/gk7205v200/aiao_hal.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/ao/gk7205v200/aiao_hal.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,1093 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+#include <common.h>
+#include <command.h>
+#include <version.h>
+#include <asm/io.h>
+#include <asm/arch/platform.h>
+	//#include <asm/sizes.h>
+#include <config.h>
+
+#include "type.h"
+#include "board.h"
+#include "aiao_hal.h"
+#include "aiao_reg.h"
+#include "aiao_ext.h"
+
+#define IO_ADDRESS(x) (x)
+	//#define DEBUG_AO
+
+	static AIO_STATE_S s_stAioState[AIO_MAX_NUM];
+	static GK_UL u32AioBase;
+	static GK_UL u32CrgBase;
+	void *g_acodec_ctrl0_reg = NULL;
+	void *g_acodec_fast_reg = NULL;
+
+#define AIAO_HAL_WRITE_REG(u32Offset, value) \
+	(*(volatile GK_U32*)((GK_UL)u32AioBase + (GK_U32)u32Offset) = (value))
+
+#define AIAO_HAL_READ_REG(u32Offset) \
+	(*(volatile GK_U32*)((GK_UL)u32AioBase + (GK_U32)u32Offset))
+
+#define AIAO_HAL_WRITE_CRG_REG(u32RegAddr, value) \
+	(*(volatile GK_U32*)((GK_UL)u32CrgBase + (GK_U32)(u32RegAddr - CRG_REGS_ADDR)) = (value))
+
+#define AIAO_HAL_READ_CRG_REG(u32RegAddr) \
+	(*(volatile GK_U32*)((GK_UL)u32CrgBase + (GK_U32)(u32RegAddr - CRG_REGS_ADDR)))
+
+	GK_U32 AIAO_HAL_ReadReg(GK_U32 u32Offset)
+	{
+		return (*(volatile GK_U32*)((GK_UL)u32AioBase + (GK_U32)u32Offset));
+	}
+
+	GK_VOID AIAO_HAL_WriteReg(GK_U32 u32Offset, GK_U32 u32Value)
+	{
+		*(volatile GK_U32*)((GK_UL)(u32AioBase) + (GK_U32)(u32Offset)) = u32Value;
+	}
+
+	static inline void acodec_Ctr0setbit(
+			unsigned long value,
+			unsigned long offset,
+			unsigned long addr)
+	{
+		unsigned long t, mask;
+
+		mask = 1 << offset;
+		t = readl((GK_U32*)((gk_uintptr_t)addr));
+		t &= ~mask;
+		t |= (value << offset) & mask;
+		writel(t, (GK_U32*)((gk_uintptr_t)addr));
+	}
+
+	GK_S32 AIAO_HAL_SysInit(GK_VOID)
+	{
+		u32AioBase = (GK_U32)IO_ADDRESS(AIAO_REG_BASE);
+		if (0 == u32AioBase)
+		{
+			return GK_FAILURE;
+		}
+
+		u32CrgBase = (GK_U32)IO_ADDRESS(CRG_REGS_ADDR);
+		if (0 == u32CrgBase)
+		{
+			return GK_FAILURE;
+		}
+
+		return GK_SUCCESS;
+	}
+
+	GK_S32 AIAO_HAL_CheckAiAoClk(const AIO_ATTR_S *pstAttr0, const AIO_ATTR_S *pstAttr1)
+	{
+		GK_U32 u32ChnCnt0,u32ChnCnt1;
+
+		if(1 == pstAttr0->u32ChnCnt)
+		{
+			u32ChnCnt0 = 2;
+		}
+		else
+		{
+			u32ChnCnt0 = pstAttr0->u32ChnCnt;
+		}
+
+		if(1 == pstAttr1->u32ChnCnt)
+		{
+			u32ChnCnt1 = 2;
+		}
+		else
+		{
+			u32ChnCnt1 = pstAttr1->u32ChnCnt;
+		}
+
+		if ((u32ChnCnt0 * AIO_GET_BITCNT(pstAttr0->enBitwidth))
+				!= (u32ChnCnt1 * AIO_GET_BITCNT(pstAttr1->enBitwidth)))
+		{
+			printf("(chncnt*bitwidth)Fs of AI and AO should be same when u32ClkSel=1\n");
+			return GK_FAILURE;
+		}
+
+		if (pstAttr0->enSamplerate != pstAttr1->enSamplerate)
+		{
+			printf("samplerate of AI and AO should be same when u32ClkSel=1\n");
+			return GK_FAILURE;
+		}
+
+		return GK_SUCCESS;
+	}
+
+	static GK_S32 AIAOGetMclkCfg(AUDIO_DEV AudioDev, const AIO_ATTR_S *pstAttr,
+			GK_S32 *ps32MClkSel, GK_BOOL *pbMclkSetted)
+	{
+
+		*pbMclkSetted = GK_FALSE;
+
+		switch (pstAttr->enSamplerate)
+		{
+			case AUDIO_SAMPLE_RATE_8000:
+			case AUDIO_SAMPLE_RATE_16000:
+			case AUDIO_SAMPLE_RATE_32000:
+				{
+					if ((AUDIO_BIT_WIDTH_24 == pstAttr->enBitwidth)
+							||((AUDIO_BIT_WIDTH_16 == pstAttr->enBitwidth)&&(2 == pstAttr->u32EXFlag)))
+					{
+						*ps32MClkSel  = AIO_MCLK_48K_1800;
+					}
+					else
+					{
+						*ps32MClkSel  = AIO_MCLK_32K_1800;
+					}
+					break;
+				}
+
+			case AUDIO_SAMPLE_RATE_12000:
+			case AUDIO_SAMPLE_RATE_24000:
+			case AUDIO_SAMPLE_RATE_48000:
+				{
+					*ps32MClkSel  = AIO_MCLK_48K_1800;
+					break;
+				}
+
+			case AUDIO_SAMPLE_RATE_11025:
+			case AUDIO_SAMPLE_RATE_22050:
+			case AUDIO_SAMPLE_RATE_44100:
+				{
+					*ps32MClkSel  = AIO_MCLK_441K_1800;
+					break;
+				}
+			default:
+				{
+					printf( "not support this sample rate \n");
+					return -1;
+				}
+		}
+
+		return GK_SUCCESS;
+	}
+
+	static GK_S32 AIAOGetBclkFsclkDivCfg(const AIO_ATTR_S *pstAttr,
+			GK_S32 s32MClkSel, GK_S32 *ps32BClkSel, GK_S32 *ps32LrClkSel)
+	{
+		GK_U32 u32MclkRateNum;
+		GK_U32 u32FsBit;
+
+		if(1 == pstAttr->u32ChnCnt)
+		{
+			if ((AUDIO_BIT_WIDTH_16 == pstAttr->enBitwidth)&&(2 == pstAttr->u32EXFlag))
+			{
+				u32FsBit = 2 * AIO_GET_BITCNT(AUDIO_BIT_WIDTH_24);
+			}
+			else
+			{
+				u32FsBit = 2 * AIO_GET_BITCNT(pstAttr->enBitwidth);
+			}
+		}
+		else
+		{
+			if ((AUDIO_BIT_WIDTH_16 == pstAttr->enBitwidth)&&(2 == pstAttr->u32EXFlag))
+			{
+				u32FsBit = pstAttr->u32ChnCnt * AIO_GET_BITCNT(AUDIO_BIT_WIDTH_24);
+			}
+			else
+			{
+				u32FsBit = pstAttr->u32ChnCnt * AIO_GET_BITCNT(pstAttr->enBitwidth);
+			}
+		}
+		switch (s32MClkSel)
+		{
+			case AIO_MCLK_48K_1800:
+				{
+					u32MclkRateNum = 48000 * 256;
+					break;
+				}
+
+			case AIO_MCLK_32K_1800:
+				{
+					u32MclkRateNum = 32000 * 256;
+					break;
+				}
+
+			case AIO_MCLK_441K_1800:
+				{
+					u32MclkRateNum = 44100 * 256;
+					break;
+				}
+
+			default:
+				{
+					printf("not support this mclk\n");
+					return GK_FAILURE;
+				}
+		}
+
+		if (0 != (u32MclkRateNum % (u32FsBit * pstAttr->enSamplerate)))
+		{
+
+			printf( "can not get the bclk_division ratio\n");
+			return GK_FAILURE;
+		}
+
+		switch (u32MclkRateNum / (u32FsBit * pstAttr->enSamplerate))
+		{
+
+			case 1:
+				*ps32BClkSel = SYS_AIO_BS_CLK1;
+				break;
+			case 2:
+				*ps32BClkSel = SYS_AIO_BS_CLK2;
+				break;
+			case 3:
+				*ps32BClkSel = SYS_AIO_BS_CLK3;
+				break;
+			case 4:
+				*ps32BClkSel = SYS_AIO_BS_CLK4;
+				break;
+			case 6:
+				*ps32BClkSel = SYS_AIO_BS_CLK6;
+				break;
+			case 8:
+				*ps32BClkSel = SYS_AIO_BS_CLK8;
+				break;
+			case 12:
+				*ps32BClkSel = SYS_AIO_BS_CLK12;
+				break;
+			case 16:
+				*ps32BClkSel = SYS_AIO_BS_CLK16;
+				break;
+			case 24:
+				*ps32BClkSel = SYS_AIO_BS_CLK24;
+				break;
+			case 32:
+				*ps32BClkSel = SYS_AIO_BS_CLK32;
+				break;
+			case 48:
+				*ps32BClkSel = SYS_AIO_BS_CLK48;
+				break;
+			case 64:
+				*ps32BClkSel = SYS_AIO_BS_CLK64;
+				break;
+			default:
+				printf("not support this bclk_division ratio\n");
+				return GK_FAILURE;
+		}
+
+		switch (u32FsBit)
+		{
+			case 256:
+				{
+					*ps32LrClkSel = SYS_AIO_SAMPLE_CLK256;
+					break;
+				}
+			case 128:
+				{
+					*ps32LrClkSel = SYS_AIO_SAMPLE_CLK128;
+					break;
+				}
+			case 64:
+				{
+					*ps32LrClkSel = SYS_AIO_SAMPLE_CLK64;
+					break;
+				}
+			case 32:
+				{
+					*ps32LrClkSel = SYS_AIO_SAMPLE_CLK32;
+					break;
+				}
+			case 16:
+				{
+					*ps32LrClkSel = SYS_AIO_SAMPLE_CLK16;
+					break;
+				}
+			default:
+				{
+					printf("not support this fsclk_division ratio\n");
+					return GK_FAILURE;
+				}
+		}
+
+		return GK_SUCCESS;
+	}
+
+	GK_VOID AOP_HAL_IntEn(GK_U32 u32ChnId, GK_BOOL bEn)
+	{
+		U_AIAO_INT_ENA unTmp;
+
+		if (u32ChnId >= AO_DEV_MAX_NUM)
+		{
+			printf( "AoDev%u is invalid!\n", u32ChnId);
+			//return GK_FAILURE;
+		}
+
+		unTmp.u32 = AIAO_HAL_READ_REG(AIAO_INT_ENA_REG);
+
+		switch (u32ChnId)
+		{
+			case 0:
+				unTmp.bits.tx_ch0_int_ena = bEn;
+				break;
+#if 0
+			case 1:
+				unTmp.bits.tx_ch1_int_ena = bEn;
+#endif
+				break;
+			default:
+				break;
+		}
+
+		AIAO_HAL_WRITE_REG(AIAO_INT_ENA_REG, unTmp.u32);
+#ifdef DEBUG_AO
+		printf("%s %d AIAO_INT_ENA_REG = 0x%0x \n",__func__, __LINE__,  unTmp.u32);
+#endif
+	}
+
+
+	GK_VOID AOP_HAL_SetBufferAddr(GK_U32 u32ChnId, GK_U32 u32Value)
+	{
+		if (u32ChnId >= AO_DEV_MAX_NUM)
+		{
+			printf("AoDev%u is invalid!\n", u32ChnId);
+			//return GK_FAILURE;
+		}
+
+		AIAO_HAL_WriteReg(AOP_BUFF_SADDR_REG(u32ChnId), u32Value);
+#ifdef DEBUG_AO
+		printf("%s %d 0x%0x = 0x%0x \n",__func__, __LINE__, AOP_BUFF_SADDR_REG(u32ChnId), u32Value);
+#endif
+	}
+
+	GK_VOID AOP_HAL_SetBufferSize(GK_U32 u32ChnId, GK_U32 u32Value)
+	{
+		U_TX_BUFF_SIZE unTmp;
+
+		if (u32ChnId >= AO_DEV_MAX_NUM)
+		{
+			printf("AoDev%u is invalid!\n", u32ChnId);
+			//return GK_FAILURE;
+		}
+
+		unTmp.u32 = AIAO_HAL_ReadReg(AOP_BUFF_SIZE_REG(u32ChnId));
+
+		unTmp.bits.tx_buff_size = u32Value;
+
+		AIAO_HAL_WriteReg(AOP_BUFF_SIZE_REG(u32ChnId), unTmp.u32);
+#ifdef DEBUG_AO
+		printf("%s %d 0x%0x = 0x%0x \n",__func__, __LINE__, AOP_BUFF_SIZE_REG(u32ChnId), unTmp.u32);
+#endif
+	}
+
+	GK_VOID AOP_HAL_SetBuffWptr(GK_U32 u32ChnId, GK_U32 u32Value)
+	{
+		U_TX_BUFF_WPTR unTmp;
+
+		if (u32ChnId >= AO_DEV_MAX_NUM)
+		{
+			printf("AoDev%u is invalid!\n", u32ChnId);
+			//return GK_FAILURE;
+		}
+
+		unTmp.u32 = AIAO_HAL_ReadReg(AOP_BUFF_WPTR_REG(u32ChnId));
+
+		unTmp.bits.tx_buff_wptr = u32Value;
+
+		AIAO_HAL_WriteReg(AOP_BUFF_WPTR_REG(u32ChnId), unTmp.u32);
+#ifdef DEBUG_AO
+		printf("%s %d 0x%0x = 0x%0x \n",__func__, __LINE__, AOP_BUFF_WPTR_REG(u32ChnId), unTmp.u32);
+#endif
+	}
+
+	GK_VOID AOP_HAL_SetBuffRptr(GK_U32 u32ChnId, GK_U32 u32Value)
+	{
+		U_TX_BUFF_RPTR unTmp;
+
+		if (u32ChnId >= AO_DEV_MAX_NUM)
+		{
+			printf("AoDev%u is invalid!\n", u32ChnId);
+			//return GK_FAILURE;
+		}
+
+		unTmp.u32 = AIAO_HAL_ReadReg(AOP_BUFF_RPTR_REG(u32ChnId));
+
+		unTmp.bits.tx_buff_rptr = u32Value;
+
+		AIAO_HAL_WriteReg(AOP_BUFF_RPTR_REG(u32ChnId), unTmp.u32);
+#ifdef DEBUG_AO
+		printf("%s %d 0x%0x = 0x%0x \n",__func__, __LINE__, AOP_BUFF_RPTR_REG(u32ChnId), unTmp.u32);
+#endif
+	}
+
+
+	GK_VOID AOP_HAL_SetTransSize(GK_U32 u32ChnId, GK_U32 u32Value)
+	{
+		U_TX_TRANS_SIZE unTmp;
+
+		if (u32ChnId >= AO_DEV_MAX_NUM)
+		{
+			printf("AoDev%u is invalid!\n", u32ChnId);
+			//return GK_FAILURE;
+		}
+
+		unTmp.u32 = AIAO_HAL_ReadReg(AOP_TRANS_SIZE_REG(u32ChnId));
+
+		unTmp.bits.tx_trans_size = u32Value;
+
+		AIAO_HAL_WriteReg(AOP_TRANS_SIZE_REG(u32ChnId), unTmp.u32);
+#ifdef DEBUG_AO
+		printf("%s %d 0x%0x = 0x%0x \n",__func__, __LINE__, AOP_TRANS_SIZE_REG(u32ChnId), unTmp.u32);
+#endif
+	}
+
+	GK_VOID AOP_HAL_SetTxStart(GK_U32 u32ChnId, GK_BOOL bEn)
+	{
+		U_TX_DSP_CTRL unTmp;
+
+		if (u32ChnId >= AO_DEV_MAX_NUM)
+		{
+			printf("AoDev%u is invalid!\n", u32ChnId);
+			//return GK_FAILURE;
+		}
+
+		unTmp.u32 = AIAO_HAL_READ_REG(AOP_CTRL_REG(u32ChnId));
+
+		unTmp.bits.tx_enable = bEn;
+
+		AIAO_HAL_WRITE_REG(AOP_CTRL_REG(u32ChnId), unTmp.u32);
+#ifdef DEBUG_AO
+		printf("%s %d 0x%0x = 0x%0x \n",__func__, __LINE__, AOP_CTRL_REG(u32ChnId), unTmp.u32);
+#endif
+	}
+
+	GK_U32 AOP_HAL_GetDisDone(GK_U32 u32ChnId)
+	{
+		U_TX_DSP_CTRL unTmp;
+
+		GK_U32 u32Status = 0;
+
+		if (u32ChnId >= AO_DEV_MAX_NUM)
+		{
+			printf("AoDev%u is invalid!\n", u32ChnId);
+			return GK_FAILURE;
+		}
+
+		unTmp.u32 = AIAO_HAL_ReadReg(AOP_CTRL_REG(u32ChnId));
+
+		u32Status = unTmp.bits.tx_disable_done;
+
+		return u32Status;
+	}
+
+	GK_VOID AOP_HAL_SetChildIntMask(GK_U32 u32ChnId)
+	{
+		U_TX_INT_ENA unTmp;
+
+		if (u32ChnId >= AO_DEV_MAX_NUM)
+		{
+			printf("AoDev%u is invalid!\n", u32ChnId);
+			//return GK_FAILURE;
+		}
+
+		unTmp.u32 = AIAO_HAL_READ_REG(AOP_INT_ENA_REG(u32ChnId));
+
+		unTmp.bits.tx_trans_int_ena       = 1;
+		unTmp.bits.tx_empty_int_ena       = 1;
+		unTmp.bits.tx_alempty_int_ena     = 0;
+		unTmp.bits.tx_bfifo_empty_int_ena = 1;
+		unTmp.bits.tx_ififo_empty_int_ena = 1;
+		unTmp.bits.tx_stop_int_ena        = 0;
+		unTmp.bits.tx_mfade_int_ena       = 0;
+		unTmp.bits.tx_dat_break_int_ena   = 0;
+		unTmp.bits.Reserved_0             = 0;
+		AIAO_HAL_WRITE_REG(AOP_INT_ENA_REG(u32ChnId), unTmp.u32);
+#ifdef DEBUG_AO
+		printf("%s %d 0x%0x = 0x%0x \n",__func__, __LINE__, AOP_INT_ENA_REG(u32ChnId), unTmp.u32);
+#endif
+	}
+
+	GK_VOID AOP_HAL_ClrChildIntAllStatus(GK_U32 u32ChnId)
+	{
+		U_TX_INT_CLR u32IntMask;
+
+		if (u32ChnId >= AO_DEV_MAX_NUM)
+		{
+			printf("AoDev%u is invalid!\n", u32ChnId);
+			//return GK_FAILURE;
+		}
+
+		u32IntMask.bits.tx_trans_int_clear       = 1;
+		u32IntMask.bits.tx_empty_int_clear       = 1;
+		u32IntMask.bits.tx_alempty_int_clear     = 1;
+		u32IntMask.bits.tx_bfifo_empty_int_clear = 1;
+		u32IntMask.bits.tx_ififo_empty_int_clear = 1;
+		u32IntMask.bits.tx_stop_int_clear        = 1;
+		u32IntMask.bits.tx_mfade_int_clear       = 1;
+		u32IntMask.bits.tx_dat_break_int_clear   = 1;
+
+		AIAO_HAL_WRITE_REG(AOP_INT_CLR_REG(u32ChnId), u32IntMask.u32);
+
+	}
+	/**************/
+	GK_S32 AOP_HAL_SetVolume(GK_U32 u32ChnId, GK_S32 s32VolumeDb)
+	{
+		U_TX_DSP_CTRL unTmp;
+
+		if (u32ChnId >= AO_DEV_MAX_NUM)
+		{
+			printf("AoDev%u is invalid!\n", u32ChnId);
+			return GK_FAILURE;
+		}
+
+		/*0x7F->6db 0x7E->5db 0x29->-80db 0~0x28 mute */
+		if(-121 > s32VolumeDb || 6 < s32VolumeDb)
+		{
+			printf("AoDev%u volume %d error\n", u32ChnId,s32VolumeDb);
+			return GK_FAILURE;
+		}
+
+		unTmp.u32 = AIAO_HAL_READ_REG(AOP_CTRL_REG(u32ChnId));
+
+		unTmp.bits.volume = 0x7F -(6 -s32VolumeDb);
+
+		AIAO_HAL_WRITE_REG(AOP_CTRL_REG(u32ChnId), unTmp.u32);
+
+		return GK_SUCCESS;
+	}
+#if 0
+	GK_S32 AOP_HAL_SetMute(GK_U32 u32ChnId, GK_BOOL bMute,  AUDIO_FADE_S *pstFade)
+	{
+		U_TX_DSP_CTRL unTmp;
+
+		if (u32ChnId >= AO_DEV_MAX_NUM)
+		{
+			printf("AoDev%d is invalid!\n", u32ChnId);
+			return GK_FAILURE;
+		}
+
+		if((GK_TRUE != bMute) && (GK_FALSE != bMute))
+		{
+			printf("AoDev%d set mute param error\n", u32ChnId);
+			return GK_FAILURE;
+		}
+
+		if(GK_NULL != pstFade)
+		{
+			if((GK_TRUE != pstFade->bFade) && (GK_FALSE != pstFade->bFade))
+			{
+				printf("AoDev%d set mute param error\n", u32ChnId);
+				return GK_FAILURE;
+			}
+
+			if((AUDIO_FADE_RATE_BUTT <= pstFade->enFadeInRate) || ( AUDIO_FADE_RATE_BUTT <= pstFade->enFadeOutRate))
+			{
+				printf("AoDev%d set mute param error\n", u32ChnId);
+				return GK_FAILURE;
+			}
+		}
+
+		unTmp.u32 = AIAO_HAL_READ_REG(AOP_CTRL_REG(u32ChnId));
+
+		unTmp.bits.mute_en = bMute;
+
+		if(GK_NULL != pstFade)
+		{
+			unTmp.bits.mute_fade_en  = pstFade->bFade;
+			unTmp.bits.fade_in_rate  = pstFade->enFadeInRate;
+			unTmp.bits.fade_out_rate = pstFade->enFadeOutRate;
+		}
+
+		AIAO_HAL_WRITE_REG(AOP_CTRL_REG(u32ChnId), unTmp.u32);
+
+		return GK_SUCCESS;
+	}
+#endif
+	static GK_S32 AOPSetSysCtl(AUDIO_DEV AudioDevId, AIO_TYPE_E enAioType, const AIO_ATTR_S *pstAttr)
+	{
+		GK_S32 s32MClkSel = 0, s32LrClkSel = 0, s32BClkSel = 0;
+		GK_BOOL bMclkSetted;
+		GK_S32 s32Ret = GK_SUCCESS;
+
+		U_I2S_CRG_CFG0 I2SCrg_cfg0;
+		U_I2S_CRG_CFG1 I2SCrg_cfg1;
+		U_AIAO_SWITCH_TX_BCLK switch_tx_bclk;
+
+		I2SCrg_cfg1.u32 = AIAO_HAL_READ_REG(AOP_I2S_REG_CFG1(AudioDevId));
+#ifdef DEBUG_AO
+		printf("%s %d read 0x%0x = 0x%0x \n",__func__, __LINE__, AOP_I2S_REG_CFG1(AudioDevId), I2SCrg_cfg1.u32);
+#endif
+		/* get clock value */
+		s32Ret = AIAOGetMclkCfg(AudioDevId, pstAttr, &s32MClkSel, &bMclkSetted);
+		s32Ret |= AIAOGetBclkFsclkDivCfg(pstAttr, s32MClkSel, &s32BClkSel, &s32LrClkSel);
+		if (GK_SUCCESS != s32Ret)
+		{
+			return GK_FAILURE;
+		}
+
+		I2SCrg_cfg0.bits.aiao_mclk_div = s32MClkSel;
+		I2SCrg_cfg0.bits.Reserved_0    = 0;
+		AIAO_HAL_WRITE_REG(AOP_I2S_REG_CFG0(AudioDevId),I2SCrg_cfg0.u32);
+#ifdef DEBUG_AO
+		printf("%s %d 0x%0x = 0x%0x \n",__func__, __LINE__, AOP_I2S_REG_CFG0(AudioDevId), I2SCrg_cfg0.u32);
+#endif
+		I2SCrg_cfg1.bits.aiao_bclk_div      = s32BClkSel;
+		I2SCrg_cfg1.bits.aiao_fsclk_div     = s32LrClkSel;
+
+		if(AIO_IS_MASTER_MODE(pstAttr->enWorkmode))
+		{
+			I2SCrg_cfg1.bits.aiao_bclk_oen = 0;
+			I2SCrg_cfg1.bits.aiao_bclk_sel = 0;
+		}
+		else if(AIO_IS_SLAVE_MODE(pstAttr->enWorkmode))
+		{
+			I2SCrg_cfg1.bits.aiao_bclk_oen = 1;
+			I2SCrg_cfg1.bits.aiao_bclk_sel = 1;
+		}
+		else
+		{
+			printf( "invalid aio workmode:%d\n", pstAttr->enWorkmode);
+			return GK_FAILURE;
+		}
+
+		I2SCrg_cfg1.bits.aiao_cken          = 1;
+		I2SCrg_cfg1.bits.aiao_srst_req      = 0;
+		//I2SCrg_cfg1.bits.aiao_bclk_oen      = 0;
+		//I2SCrg_cfg1.bits.aiao_bclk_sel      = 0;
+		I2SCrg_cfg1.bits.aiao_bclkin_pctrl  = 0;
+		I2SCrg_cfg1.bits.aiao_bclkout_pctrl = 0;
+
+		AIAO_HAL_WRITE_REG(AOP_I2S_REG_CFG1(AudioDevId),I2SCrg_cfg1.u32 );
+#ifdef DEBUG_AO
+		printf("%s %d 0x%0x = 0x%0x \n",__func__, __LINE__, AOP_I2S_REG_CFG1(AudioDevId), I2SCrg_cfg1.u32);
+#endif
+
+		switch_tx_bclk.u32 = AIAO_HAL_READ_REG(AOP_SWITCH_TX_BCLK);
+		switch(AudioDevId)
+		{
+			case 0:
+				{
+					switch_tx_bclk.bits.inner_bclk_ws_sel_tx_00 = 0x8;
+					break;
+				}
+#if 0
+			case 1:
+				{
+					switch_tx_bclk.bits.inner_bclk_ws_sel_tx_01 = 0x9;
+					break;
+				}
+#endif
+			default:
+				{
+					printf("invalid ao dev:%d\n",AudioDevId);
+					return GK_FAILURE;
+				}
+		}
+		AIAO_HAL_WRITE_REG(AOP_SWITCH_TX_BCLK, switch_tx_bclk.u32);
+#ifdef DEBUG_AO
+		printf("%s %d 0x2065002c switch_tx_bclk.u32:0x%0x \n",__func__, __LINE__, switch_tx_bclk.u32);
+#endif
+
+		return s32Ret;
+	}
+
+
+	GK_S32 CHECK_AO_ATTR(const AIO_ATTR_S *pAttr)
+	{
+		if (AIO_IS_MASTER_MODE(pAttr->enWorkmode))
+		{
+			if (pAttr->enSamplerate != AUDIO_SAMPLE_RATE_8000\
+					&& pAttr->enSamplerate != AUDIO_SAMPLE_RATE_12000\
+					&& pAttr->enSamplerate != AUDIO_SAMPLE_RATE_11025\
+					&& pAttr->enSamplerate != AUDIO_SAMPLE_RATE_16000\
+					&& pAttr->enSamplerate != AUDIO_SAMPLE_RATE_22050\
+					&& pAttr->enSamplerate != AUDIO_SAMPLE_RATE_24000\
+					&& pAttr->enSamplerate != AUDIO_SAMPLE_RATE_32000\
+					&& pAttr->enSamplerate != AUDIO_SAMPLE_RATE_44100\
+					&& pAttr->enSamplerate != AUDIO_SAMPLE_RATE_48000)
+			{
+				printf( "invalid enSamplerate\n");
+				return GK_FAILURE;
+			}
+		}
+
+		if ( pAttr->u32ChnCnt != 1 && pAttr->u32ChnCnt != 2 )
+		{
+			printf( "invalid u32ChnCnt:%u\n", pAttr->u32ChnCnt);
+			return GK_FAILURE;
+		}
+
+		if(1 == pAttr->u32ChnCnt && AUDIO_SOUND_MODE_STEREO == pAttr->enSoundmode)
+		{
+			printf("when chn=1,can't use STEREO mode\n");
+			return GK_FAILURE;
+		}
+
+		if ( pAttr->enBitwidth != AUDIO_BIT_WIDTH_16)
+		{
+			printf("invalid enBitwidth:%d\n",pAttr->enBitwidth);
+			return GK_FAILURE;
+		}
+
+		if (AIO_IS_I2S_MODE(pAttr->enWorkmode))
+		{
+			if (pAttr->u32ChnCnt * AIO_GET_BITCNT(pAttr->enBitwidth) > AIO_ONE_FIFO_BITWIDTH*2)
+			{
+				printf("I2S mode, not support chncnt:%u * bitwidth:%dbit \n",
+						pAttr->u32ChnCnt, AIO_GET_BITCNT(pAttr->enBitwidth));
+				return GK_FAILURE;
+			}
+
+		}
+		else if (AIO_IS_PCM_MODE(pAttr->enWorkmode))
+		{
+			if (pAttr->u32ChnCnt * AIO_GET_BITCNT(pAttr->enBitwidth) > 256)
+			{
+				printf( "PCM mode, not support chncnt:%u * bitwidth:%dbit \n",
+						pAttr->u32ChnCnt, AIO_GET_BITCNT(pAttr->enBitwidth));
+				return GK_FAILURE;
+			}
+		}
+
+		if (pAttr->enWorkmode < 0 || pAttr->enWorkmode >= AIO_MODE_BUTT)
+		{
+			printf( "invalid enWorkmode\n");
+			return GK_FAILURE;
+		}
+		if (pAttr->enSoundmode < 0 || pAttr->enSoundmode >= AUDIO_SOUND_MODE_BUTT)
+		{
+			printf("invalid enSoundmode\n");
+			return GK_FAILURE;
+		}
+		if (pAttr->u32FrmNum > MAX_AUDIO_FRAME_NUM || pAttr->u32FrmNum < 2)
+		{
+			printf("invalid u32FrmNum\n");
+			return GK_FAILURE;
+		}
+		if (pAttr->u32PtNumPerFrm > MAX_AO_POINT_NUM || pAttr->u32PtNumPerFrm < MIN_AUDIO_POINT_NUM)
+		{
+			printf("u32PtNumPerFrm %u is invalid!\n", pAttr->u32PtNumPerFrm);
+			return GK_FAILURE;
+		}
+		if (pAttr->u32ClkSel != 0 && pAttr->u32ClkSel != 1)
+		{
+			printf("invalid u32ClkSel\n");
+			return GK_FAILURE;
+		}
+
+		return GK_SUCCESS;
+	}
+
+
+	GK_S32 AOP_HAL_SetDevAttr(GK_U32 u32ChnId, AIO_ATTR_S *pstAttr)
+	{
+		GK_S32 s32Ret;
+		AIO_ATTR_S *pstAiAttr = NULL;
+		U_TX_IF_ATTRI stAopAttrReg;
+		U_TX_DSP_CTRL   stAopCtrlReg;
+
+		if (u32ChnId >= AO_DEV_MAX_NUM)
+		{
+			printf("AoDev%u is invalid!\n", u32ChnId);
+			return GK_FAILURE;
+		}
+
+		/* check AO attr */
+		s32Ret = CHECK_AO_ATTR(pstAttr);
+		if (GK_SUCCESS != s32Ret)
+		{
+			return s32Ret;
+		}
+
+		if ((1 == pstAttr->u32ClkSel)&& (0 == u32ChnId) )
+		{
+			pstAiAttr = &s_stAioState[u32ChnId].stAiAttr;
+			s32Ret = AIAO_HAL_CheckAiAoClk(pstAiAttr, pstAttr);
+			if (GK_SUCCESS != s32Ret)
+			{
+				return GK_FAILURE;
+			}
+		}
+
+		s32Ret = AOPSetSysCtl(u32ChnId, AIO_TYPE_AO, pstAttr);
+		if (GK_SUCCESS != s32Ret)
+		{
+			return s32Ret;
+		}
+
+		stAopAttrReg.u32 = AIAO_HAL_READ_REG(AOP_INF_ATTRI_REG(u32ChnId));
+		stAopCtrlReg.u32 = AIAO_HAL_READ_REG(AOP_CTRL_REG(u32ChnId));
+
+		stAopAttrReg.bits.tx_underflow_ctrl = 1;  /* send the last data */
+		stAopAttrReg.bits.Reserved_1 = 0;
+		stAopAttrReg.bits.Reserved_0 = 0;
+
+		if (AIO_MODE_I2S_SLAVE == pstAttr->enWorkmode
+				|| AIO_MODE_I2S_MASTER == pstAttr->enWorkmode)
+		{
+			stAopAttrReg.bits.tx_mode  = 0; /* I2S mode */
+			stAopAttrReg.bits.tx_sd_offset = 0;
+		}
+		else if (AIO_MODE_PCM_SLAVE_STD == pstAttr->enWorkmode
+				|| AIO_MODE_PCM_MASTER_STD == pstAttr->enWorkmode)
+		{
+			stAopAttrReg.bits.tx_mode  = 1; /* PCM standard mode */
+			stAopAttrReg.bits.tx_sd_offset = 1;
+		}
+		else if (AIO_MODE_PCM_SLAVE_NSTD == pstAttr->enWorkmode
+				|| AIO_MODE_PCM_MASTER_NSTD == pstAttr->enWorkmode)
+		{
+			stAopAttrReg.bits.tx_mode  = 1; /* PCM non standard mode */
+			stAopAttrReg.bits.tx_sd_offset = 0;
+		}
+		else
+		{
+			return GK_FAILURE;
+		}
+
+		if (1 == pstAttr->u32ChnCnt)
+		{
+			stAopAttrReg.bits.tx_ch_num = 0;
+		}
+		else if (2 == pstAttr->u32ChnCnt)
+		{
+			stAopAttrReg.bits.tx_ch_num = 1;
+		}
+		else if (8 == pstAttr->u32ChnCnt)
+		{
+			stAopAttrReg.bits.tx_ch_num = 3;
+		}
+		else
+		{
+			return GK_FAILURE;
+		}
+
+		if (AUDIO_BIT_WIDTH_8 == pstAttr->enBitwidth)
+		{
+			stAopAttrReg.bits.tx_i2s_precision  = 0;
+		}
+		else if (AUDIO_BIT_WIDTH_16 == pstAttr->enBitwidth)
+		{
+			stAopAttrReg.bits.tx_i2s_precision  = 1;
+		}
+		else if (AUDIO_BIT_WIDTH_24 == pstAttr->enBitwidth)
+		{
+			stAopAttrReg.bits.tx_i2s_precision  = 2;
+		}
+		else
+		{
+			return GK_FAILURE;
+		}
+
+		switch(u32ChnId)
+		{
+			case 0:
+				stAopAttrReg.bits.tx_sd_source_sel = 0;
+				break;
+#if 0
+			case 1:
+				stAopAttrReg.bits.tx_sd_source_sel = 1;
+				break;
+#endif
+			default:
+				return GK_FAILURE;
+		}
+		stAopAttrReg.bits.tx_sd0_sel = 0;
+		stAopAttrReg.bits.tx_sd1_sel = 1;
+		stAopAttrReg.bits.tx_sd2_sel = 2;
+		stAopAttrReg.bits.tx_sd3_sel = 3;
+
+		stAopAttrReg.bits.tx_trackmode = 0;
+		AIAO_HAL_WRITE_REG(AOP_INF_ATTRI_REG(u32ChnId), stAopAttrReg.u32);
+#ifdef DEBUG_AO
+		printf("%s %d 0x%0x = 0x%0x \n",__func__, __LINE__, AOP_INF_ATTRI_REG(u32ChnId), stAopAttrReg.u32);
+#endif
+		stAopCtrlReg.bits.mute_en      = 0;
+		stAopCtrlReg.bits.mute_fade_en = 0;
+		stAopCtrlReg.bits.Reserved_3   = 0;
+		stAopCtrlReg.bits.volume       = 0x79;  /*0db*/
+		stAopCtrlReg.bits.Reserved_2   = 0;
+		stAopCtrlReg.bits.fade_in_rate = 0;
+		stAopCtrlReg.bits.fade_out_rate= 0;
+		stAopCtrlReg.bits.Reserved_1   = 0;
+		stAopCtrlReg.bits.bypass_en    = 0;
+		stAopCtrlReg.bits.tx_enable    = 0;
+		stAopCtrlReg.bits.Reserved_0   = 0;
+
+		AIAO_HAL_WRITE_REG(AOP_CTRL_REG(u32ChnId), stAopCtrlReg.u32);
+#ifdef DEBUG_AO
+		printf("%s %d 0x%0x = 0x%0x \n",__func__, __LINE__, AOP_CTRL_REG(u32ChnId), stAopCtrlReg.u32);
+#endif
+
+		return GK_SUCCESS;
+	}
+#if 0
+	GK_S32 AOP_HAL_ClrAoAttr(GK_U32 u32ChnId)
+	{
+		if (u32ChnId >= AO_DEV_MAX_NUM)
+		{
+			printf("AoDev%d is invalid!\n", u32ChnId);
+			return GK_FAILURE;
+		}
+
+		return GK_SUCCESS;
+	}
+#endif
+	GK_S32 AOP_HAL_DevEnable(GK_U32 u32ChnId)
+	{
+		//int index = 0;
+		//unsigned int *p_dac_reg1 = NULL;
+		U_I2S_CRG_CFG1 I2SCrg_cfg1;
+
+		AOP_HAL_SetChildIntMask(u32ChnId);
+
+		AOP_HAL_IntEn(u32ChnId, GK_TRUE);
+
+		/* open blck and ws */
+		I2SCrg_cfg1.u32 = AIAO_HAL_READ_REG(AOP_I2S_REG_CFG1(u32ChnId));
+		I2SCrg_cfg1.bits.aiao_bclk_en  = 1;
+		I2SCrg_cfg1.bits.aiao_ws_en    = 1;
+		I2SCrg_cfg1.bits.aiao_srst_req = 0;
+		I2SCrg_cfg1.bits.aiao_cken     = 1;
+		AIAO_HAL_WRITE_REG(AOP_I2S_REG_CFG1(u32ChnId), I2SCrg_cfg1.u32);
+#ifdef DEBUG_AO
+		printf("%s %d 0x%0x = 0x%0x \n",__func__, __LINE__, AOP_I2S_REG_CFG1(u32ChnId), I2SCrg_cfg1.u32);
+#endif
+		AOP_HAL_SetTxStart(u32ChnId, GK_TRUE);
+#if 0
+		/* popfree close */
+		acodec_Ctr0setbit(0, 18, (unsigned long)g_acodec_ctrl0_reg);
+		acodec_Ctr0setbit(0, 16, (unsigned long)g_acodec_ctrl0_reg);
+
+		/* unmute */
+		acodec_Ctr0setbit(0, 13, (unsigned long)g_acodec_ctrl0_reg);
+		acodec_Ctr0setbit(0, 14, (unsigned long)g_acodec_ctrl0_reg);
+#endif
+		return GK_SUCCESS;
+
+	}
+
+	GK_VOID AOP_HAL_DevDisable(GK_U32 u32ChnId)
+	{
+		GK_U32 u32Cnt = 0;
+		U_I2S_CRG_CFG1 I2SCrg_cfg1;
+
+		AOP_HAL_SetTxStart(u32ChnId, GK_FALSE);
+
+		AOP_HAL_IntEn(u32ChnId, GK_FALSE);
+
+		AOP_HAL_ClrChildIntAllStatus(u32ChnId);
+
+		while(!AOP_HAL_GetDisDone(u32ChnId))
+		{
+			if (u32Cnt++ > 100)
+			{
+				I2SCrg_cfg1.u32 = AIAO_HAL_READ_REG(AOP_I2S_REG_CFG1(u32ChnId));
+				I2SCrg_cfg1.bits.aiao_srst_req = 1;
+				I2SCrg_cfg1.bits.aiao_cken     = 0;
+				AIAO_HAL_WRITE_REG(AOP_I2S_REG_CFG1(u32ChnId), I2SCrg_cfg1.u32);
+
+				udelay(10000);
+
+				I2SCrg_cfg1.u32 = AIAO_HAL_READ_REG(AOP_I2S_REG_CFG1(u32ChnId));
+				I2SCrg_cfg1.bits.aiao_cken     = 1;
+				I2SCrg_cfg1.bits.aiao_srst_req = 0;
+				AIAO_HAL_WRITE_REG(AOP_I2S_REG_CFG1(u32ChnId), I2SCrg_cfg1.u32);
+				printf("Can't get ao stop flag. Ao clock is not config, please check your clock!\n");
+				break;
+			}
+			udelay(10000);
+		}
+#if 0
+		/* popfree open */
+		acodec_Ctr0setbit(1, 18, (unsigned long)g_acodec_ctrl0_reg);
+		acodec_Ctr0setbit(1, 16, (unsigned long)g_acodec_ctrl0_reg);
+
+		/* mute */
+		acodec_Ctr0setbit(1, 13, (unsigned long)g_acodec_ctrl0_reg);
+		acodec_Ctr0setbit(1, 14, (unsigned long)g_acodec_ctrl0_reg);
+#endif
+
+		I2SCrg_cfg1.u32 = AIAO_HAL_READ_REG(AOP_I2S_REG_CFG1(u32ChnId));
+		I2SCrg_cfg1.bits.aiao_bclk_en  = 0;
+		I2SCrg_cfg1.bits.aiao_ws_en    = 0;
+		I2SCrg_cfg1.bits.aiao_cken      = 0;
+		I2SCrg_cfg1.bits.aiao_srst_req = 1;
+		AIAO_HAL_WRITE_REG(AOP_I2S_REG_CFG1(u32ChnId), I2SCrg_cfg1.u32);
+	}
+
+	GK_S32 SYS_HAL_ApllClkEn(GK_BOOL bClkEn)
+	{
+		if(bClkEn == GK_TRUE)
+		{
+
+		}
+		return 0;
+	}
+
+
+	GK_S32 SYS_HAL_AioClkSel(GK_U32 u32ClkSel)
+	{
+		acodec_Ctr0setbit(u32ClkSel << 5, 0x1 << 5, IO_ADDRESS(CRG_PERCTL103_ADDR));
+
+		return 0;
+	}
+
+	GK_S32 SYS_HAL_AioResetSel(GK_BOOL bReset)
+	{
+		GK_U32 u32Tmp = (bReset == GK_TRUE) ? 1 : 0;
+
+		acodec_Ctr0setbit(u32Tmp, 0, IO_ADDRESS(CRG_PERCTL103_ADDR));
+
+		return 0;
+	}
+
+	GK_S32 SYS_HAL_AioClkEn(GK_BOOL bClkEn)
+	{
+		GK_U32 u32Tmp = (bClkEn == GK_TRUE) ? 1 : 0;
+
+		acodec_Ctr0setbit(u32Tmp, 1, IO_ADDRESS(CRG_PERCTL103_ADDR));
+		acodec_Ctr0setbit(u32Tmp, 2, IO_ADDRESS(CRG_PERCTL103_ADDR));
+
+		return 0;
+	}
+
+	GK_S32 SYS_HAL_AcodecResetSel(GK_BOOL bReset)
+	{
+		GK_U32 u32Tmp = (bReset == GK_TRUE) ? 1 : 0;
+
+		acodec_Ctr0setbit(u32Tmp, 3, IO_ADDRESS(CRG_PERCTL103_ADDR));
+		acodec_Ctr0setbit(u32Tmp, 4, IO_ADDRESS(CRG_PERCTL103_ADDR));
+
+		return 0;
+	}
+
+	int AIAO_ModInit(void)
+	{
+#if 1
+		GK_BOOL bReset;
+		GK_BOOL bClkEn;
+
+		bReset = GK_FALSE;
+		bClkEn = GK_TRUE;
+
+		SYS_HAL_AioClkEn(bClkEn);
+		SYS_HAL_AioResetSel(bReset);
+#endif
+		return GK_SUCCESS;
+	}
+
+
+	void  AIAO_ModExit(void)
+	{
+		GK_BOOL bReset = GK_TRUE;
+		GK_BOOL bClkEn = GK_FALSE;
+
+		SYS_HAL_AioResetSel(bReset);
+		SYS_HAL_AioClkEn(bClkEn);
+
+		return ;
+	}
+
+
diff -uraN u-boot-2016.11/product/audio/ao/gk7205v200/aiao_hal.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/ao/gk7205v200/aiao_hal.h
--- u-boot-2016.11/product/audio/ao/gk7205v200/aiao_hal.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/ao/gk7205v200/aiao_hal.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,198 @@
+#ifndef __AIAO_HAL_H__
+#define __AIAO_HAL_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+#include "audio_ao.h"
+
+#define AIO_DATA_WIDTH_8BIT     0x0
+#define AIO_DATA_WIDTH_16BIT    0x1
+#define AIO_DATA_WIDTH_18BIT    0x2
+#define AIO_DATA_WIDTH_20BIT    0x3
+#define AIO_DATA_WIDTH_24BIT    0x4
+#define AIO_DATA_WIDTH_32BIT    0x5
+
+#define AIO_PCM_DATA_WIDTH_8BIT     0x0
+#define AIO_PCM_DATA_WIDTH_16BIT    0x1
+#define AIO_PCM_DATA_WIDTH_32BIT    0x2
+#define AIO_PCM_DATA_WIDTH_64BIT    0x3
+#define AIO_PCM_DATA_WIDTH_128BIT   0x4
+
+
+#define AIO_CHN_NUM_2CHN        0x0
+#define AIO_CHN_NUM_4CHN        0x1
+#define AIO_CHN_NUM_8CHN        0x2
+#define AIO_CHN_NUM_16CHN       0x3
+
+#define AIO_ONE_FIFO_BITWIDTH       128
+#define AIO_GET_BITCNT(enBitwidth)  (8<<(enBitwidth))
+#define AIO_TIME_DIFF_US(a, b) (((a.tv_sec) - (b.tv_sec))*1000000 + ((a.tv_usec) - (b.tv_usec)))
+
+#define AIO_IS_PCM_MODE(mode) \
+	(AIO_MODE_PCM_SLAVE_STD == (mode)  || AIO_MODE_PCM_SLAVE_NSTD == (mode)  \
+	 || AIO_MODE_PCM_MASTER_STD == (mode) || AIO_MODE_PCM_MASTER_NSTD == (mode))
+#define AIO_IS_I2S_MODE(mode) \
+	(AIO_MODE_I2S_MASTER == (mode) || AIO_MODE_I2S_SLAVE == (mode))
+#define AIO_IS_MASTER_MODE(mode) \
+	(AIO_MODE_I2S_MASTER == (mode) || AIO_MODE_PCM_MASTER_STD == (mode) || AIO_MODE_PCM_MASTER_NSTD == (mode))
+#define AIO_IS_SLAVE_MODE(mode) \
+	(AIO_MODE_I2S_SLAVE == (mode) || AIO_MODE_PCM_SLAVE_STD == (mode) || AIO_MODE_PCM_SLAVE_NSTD == (mode))
+
+
+#define AIP0_INTMASK    1
+#define AOP0_INTMASK    1
+#define AOP1_INTMASK    1
+
+#define AI_DEV_MAX_NUM          1
+#define AO_DEV_MIN_NUM          0
+#define AO_DEV_MAX_NUM          1
+#define AIO_MAX_NUM             1
+#define AIO_MAX_CHN_NUM         2
+
+#define MAX_AUDIO_FRAME_NUM    50       /*max count of audio frame in Buffer */
+#define MAX_AUDIO_POINT_BYTES  4        /*max bytes of one sample point(now 32bit max)*/
+
+#define MAX_VOICE_POINT_NUM    480      /*max sample per frame for voice encode */
+
+#define MAX_AUDIO_POINT_NUM    2048     /*max sample per frame for all encoder(aacplus:2048)*/
+#define MAX_AO_POINT_NUM       4096     /* from h3:support 4096 framelen*/
+#define MIN_AUDIO_POINT_NUM    80       /*min sample per frame*/
+#define MAX_AI_POINT_NUM    2048     /*max sample per frame for all encoder(aacplus:2048)*/
+
+	/*max length of audio frame by bytes, one frame contain many sample point */
+#define MAX_AUDIO_FRAME_LEN    (MAX_AUDIO_POINT_BYTES*MAX_AO_POINT_NUM)
+
+	/* 1800M */
+	/*(MCLK0/AIO Clock Source Frequency) x 2^27*/
+#define AIO_MCLK_48K_1800       0x000DFB24  /* 48k * 256 */
+#define AIO_MCLK_441K_1800      0x000CD856  /* 44.1k * 256 */
+#define AIO_MCLK_32K_1800       0x00095218  /* 32k * 256 */
+
+	typedef GK_S32 AUDIO_DEV;
+
+	typedef enum AIO_TYPE_E
+	{
+		AIO_TYPE_AI = 0,
+		AIO_TYPE_AO,
+		AIO_TYPE_BUTT
+	} AIO_TYPE_E;
+
+	typedef enum AIO_SOUND_MODE_E
+	{
+		AUDIO_SOUND_MODE_MONO   =0,/*mono*/
+		AUDIO_SOUND_MODE_STEREO =1,/*stereo*/
+		AUDIO_SOUND_MODE_BUTT
+	} AUDIO_SOUND_MODE_E;
+
+	typedef enum AIO_MODE_E
+	{
+		AIO_MODE_I2S_MASTER  = 0,   /* AIO I2S master mode */
+		AIO_MODE_I2S_SLAVE,         /* AIO I2S slave mode */
+		AIO_MODE_PCM_SLAVE_STD,     /* AIO PCM slave standard mode */
+		AIO_MODE_PCM_SLAVE_NSTD,    /* AIO PCM slave non-standard mode */
+		AIO_MODE_PCM_MASTER_STD,    /* AIO PCM master standard mode */
+		AIO_MODE_PCM_MASTER_NSTD,   /* AIO PCM master non-standard mode */
+		AIO_MODE_BUTT
+	} AIO_MODE_E;
+
+	typedef enum AUDIO_BIT_WIDTH_E
+	{
+		AUDIO_BIT_WIDTH_8   = 0,   /* 8bit width */
+		AUDIO_BIT_WIDTH_16  = 1,   /* 16bit width*/
+		AUDIO_BIT_WIDTH_24  = 2,   /* 24bit width*/
+		AUDIO_BIT_WIDTH_BUTT,
+	} AUDIO_BIT_WIDTH_E;
+
+	typedef enum AUDIO_FADE_RATE_E
+	{
+		AUDIO_FADE_RATE_1    = 0,
+		AUDIO_FADE_RATE_2    = 1,
+		AUDIO_FADE_RATE_4    = 2,
+		AUDIO_FADE_RATE_8   = 3,
+		AUDIO_FADE_RATE_16  = 4,
+		AUDIO_FADE_RATE_32  = 5,
+		AUDIO_FADE_RATE_64  = 6,
+		AUDIO_FADE_RATE_128 = 7,
+
+		AUDIO_FADE_RATE_BUTT
+	} AUDIO_FADE_RATE_E;
+
+	typedef enum AUDIO_TRACK_MODE_E
+	{
+		AUDIO_TRACK_NORMAL      = 0,
+		AUDIO_TRACK_BOTH_LEFT   = 1,
+		AUDIO_TRACK_BOTH_RIGHT  = 2,
+		AUDIO_TRACK_EXCHANGE    = 3,
+		AUDIO_TRACK_MIX         = 4,
+		AUDIO_TRACK_LEFT_MUTE   = 5,
+		AUDIO_TRACK_RIGHT_MUTE  = 6,
+		AUDIO_TRACK_BOTH_MUTE   = 7,
+
+		AUDIO_TRACK_BUTT
+	} AUDIO_TRACK_MODE_E;
+
+	typedef struct AUDIO_FADE_S
+	{
+		GK_BOOL         bFade;
+		AUDIO_FADE_RATE_E enFadeInRate;
+		AUDIO_FADE_RATE_E enFadeOutRate;
+	} AUDIO_FADE_S;
+
+	typedef struct AIO_ATTR_S
+	{
+		AUDIO_SAMPLE_RATE_E enSamplerate;   /* sample rate */
+		AUDIO_BIT_WIDTH_E   enBitwidth;     /* bitwidth */
+		AIO_MODE_E          enWorkmode;     /* master or slave mode */
+		AUDIO_SOUND_MODE_E  enSoundmode;    /* momo or steror */
+		GK_U32              u32EXFlag;      /* expand 8bit to 16bit,use AI_EXPAND(only valid for AI 8bit) */
+		GK_U32              u32FrmNum;      /* frame num in buf[2,MAX_AUDIO_FRAME_NUM] */
+		GK_U32              u32PtNumPerFrm; /* point num per frame (80/160/240/320/480/1024/2048)
+											   (ADPCM IMA should add 1 point, AMR only support 160) */
+		GK_U32              u32ChnCnt;      /* channle number on FS, valid value:1/2/4/8 */
+		GK_U32              u32ClkSel;      /* 0: AI and AO clock is separate
+1: AI and AO clock is inseparate, AI use AO's clock
+*/
+	} AIO_ATTR_S;
+
+	typedef struct AIO_STATE_S
+	{
+		GK_BOOL             bInitialized;   /*initialed flag*/
+		GK_BOOL             bAiConfig;
+		GK_BOOL             bAoConfig;
+		AIO_ATTR_S          stAiAttr;
+		AIO_ATTR_S          stAoAttr;
+	} AIO_STATE_S;
+
+
+	/*****************************************************************************
+Description  : AIO IP Driver API
+	 *****************************************************************************/
+	GK_U32              AIO_HAL_ReadReg(GK_U32 u32Offset);
+	GK_VOID             AIO_HAL_WriteReg(GK_U32 u32Offset, GK_U32 u32Value);
+
+	GK_VOID             AOP_HAL_SetBufferAddr(GK_U32 u32ChnId, GK_U32 u32Value);
+	GK_VOID             AOP_HAL_SetBufferSize(GK_U32 u32ChnId, GK_U32 u32Value);
+	GK_VOID             AOP_HAL_SetBuffWptr(GK_U32 u32ChnId, GK_U32 u32Value);
+	GK_VOID             AOP_HAL_SetBuffRptr(GK_U32 u32ChnId, GK_U32 u32Value);
+	GK_VOID             AOP_HAL_SetTransSize(GK_U32 u32ChnId, GK_U32 u32Value);
+	GK_S32              AOP_HAL_SetDevAttr(GK_U32 u32ChnId, AIO_ATTR_S *pstAttr);
+	GK_S32              AOP_HAL_DevEnable(GK_U32 u32ChnId);
+	GK_VOID             AOP_HAL_DevDisable(GK_U32 u32ChnId);
+	GK_S32              AOP_HAL_SetVolume(GK_U32 u32ChnId, GK_S32 s32VolumeDb);
+
+	int    AIAO_ModInit(void);
+	void   AIAO_ModExit(void);
+	GK_S32 AIAO_HAL_SysInit(GK_VOID);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+
+#endif
diff -uraN u-boot-2016.11/product/audio/ao/gk7205v200/aiao_reg.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/ao/gk7205v200/aiao_reg.h
--- u-boot-2016.11/product/audio/ao/gk7205v200/aiao_reg.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/ao/gk7205v200/aiao_reg.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,1328 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __AIAO_REG_H__
+#define __AIAO_REG_H__
+
+
+#include <asm/io.h>
+//******************************************************************************
+
+
+#define BUFFER_ADDR_ALIGN          128
+#define BUFFER_ADDR_SIZE_BASE      128
+
+/******************************************************************************/
+/*                                   AIO REG DEFINE                          */
+/******************************************************************************/
+
+#define AIAO_MAX_REG_SIZE          (64*1024)
+#define AIAO_REG_BASE              (0x100e0000)
+//#define MISC_REG_BASE              (0x12030000)//(0x20120000)
+
+#define AIAO_INT_ENA_REG           (0x0)
+#define AIAO_INT_STATUS_REG        (0x4)
+#define AIAO_INT_RAW_REG           (0x8)
+
+#define AIAO_I2S00_REG_CFG0        (0x0100)
+#define AIAO_I2S00_REG_CFG1        (0x0104)
+#define AIAO_I2S08_REG_CFG0        (0x0140)
+#define AIAO_I2S08_REG_CFG1        (0x0144)
+#define AIAO_I2S09_REG_CFG0        (0x0148)
+#define AIAO_I2S09_REG_CFG1        (0x014c)
+
+#define AIP_I2S_REG_CFG0(n)        (0x0100+8*n)
+#define AIP_I2S_REG_CFG1(n)        (0x0104+8*n)
+#define AOP_I2S_REG_CFG0(n)        (0x0140+8*n)
+#define AOP_I2S_REG_CFG1(n)        (0x0144+8*n)
+
+#define AIP_SWITCH_RX_BCLK         (0x0028)
+#define AOP_SWITCH_TX_BCLK         (0x002c)
+#define AIO_SOFT_RESET_STATUS      (0x0030)
+
+/* n = 0*/
+#define AIP_INF_ATTRI_REG(n)      (0x1000+0x100*n)
+#define AIP_CTRL_REG(n)           (0x1004+0x100*n)
+#define AIP_BUFF_SADDR_REG(n)     (0x1080+0x100*n)
+#define AIP_BUFF_SIZE_REG(n)      (0x1084+0x100*n)
+#define AIP_BUFF_WPTR_REG(n)      (0x1088+0x100*n)
+#define AIP_BUFF_RPTR_REG(n)      (0x108c+0x100*n)
+#define AIP_BUFF_ALFULL_TH_REG(n) (0x1090+0x100*n)
+#define AIP_TRANS_SIZE_REG(n)     (0x1094+0x100*n)
+#define AIP_WPTR_TMP_REG(n)       (0x1098+0x100*n)
+
+#define AIP_INT_ENA_REG(n)        (0x10A0+0x100*n)
+#define AIP_INT_RAW_REG(n)        (0x10A4+0x100*n)
+#define AIP_INT_STATUS_REG(n)     (0x10A8+0x100*n)
+#define AIP_INT_CLR_REG(n)        (0x10AC+0x100*n)
+
+#define AOP_INF_ATTRI_REG(m)      (0x2000+0x100*m)
+#define AOP_CTRL_REG(m)           (0x2004+0x100*m)
+
+#define AOP_BUFF_SADDR_REG(m)     (0x2080+0x100*m)
+#define AOP_BUFF_SIZE_REG(m)      (0x2084+0x100*m)
+#define AOP_BUFF_WPTR_REG(m)      (0x2088+0x100*m)
+#define AOP_BUFF_RPTR_REG(m)      (0x208C+0x100*m)
+#define AOP_BUFF_ALEMPTY_TH_REG(m)(0x2090+0x100*m)
+#define AOP_TRANS_SIZE_REG(m)     (0x2094+0x100*m)
+#define AOP_RPTR_TMP_REG(m)       (0x2098+0x100*m)
+
+
+#define AOP_INT_ENA_REG(m)        (0x20A0+0x100*m)
+#define AOP_INT_RAW_REG(m)        (0x20A4+0x100*m)
+#define AOP_INT_STATUS_REG(m)     (0x20A8+0x100*m)
+#define AOP_INT_CLR_REG(m)        (0x20AC+0x100*m)
+
+#define AIO_BUS_WRITE_REQUEST      0xFF00
+#define AIO_BUS_READ_REQUEST       0xFF04
+#define AIO_BUS_READ_DATA          0xFF08
+#define AIO_BUS_WRITE_DATA         0xFF0C
+#define AIO_BUS_BVALID             0xFF10
+
+/******************************************************************************/
+/*                 AIO register bit field define                              */
+/******************************************************************************/
+
+
+
+
+/************************************************************************/
+#define  AIAO_SPDIF_SUPPORT
+#define  AIAO_TX_DSP_SUPPORT
+
+/***************************** Macro Definition ******************************/
+
+// Define the union U_AIAO_SYS_CRG
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int aiao_cken             : 1; // [0]
+		unsigned int Reserved_0            : 3; // [3..1]
+		unsigned int aiao_srst_req         : 1; // [4]
+		unsigned int Reserved_1            : 3; // [7..5]
+		unsigned int aiao_clk_sel          : 1; // [8]
+		unsigned int Reserved_2            : 3; // [11..9]
+		unsigned int aiaoclk_skipcfg       : 5; // [16..12]
+		unsigned int aiaoclk_loaden        : 1; // [17]
+		unsigned int Reserved_3            : 14;// [31..18]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_S40_AIAO_SYS_CRG;
+
+// Define the union U_AIAO_INT_ENA
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int rx_ch0_int_ena        : 1; // [0]
+		unsigned int rx_ch1_int_ena        : 1; // [1]
+		unsigned int rx_ch2_int_ena        : 1; // [2]
+		unsigned int rx_ch3_int_ena        : 1; // [3]
+		unsigned int rx_ch4_int_ena        : 1; // [4]
+		unsigned int rx_ch5_int_ena        : 1; // [5]
+		unsigned int rx_ch6_int_ena        : 1; // [6]
+		unsigned int rx_ch7_int_ena        : 1; // [7]
+		unsigned int Reserved_1            : 8; // [15..8]
+		unsigned int tx_ch0_int_ena        : 1; // [16]
+		unsigned int tx_ch1_int_ena        : 1; // [17]
+		unsigned int tx_ch2_int_ena        : 1; // [18]
+		unsigned int tx_ch3_int_ena        : 1; // [19]
+		unsigned int tx_ch4_int_ena        : 1; // [20]
+		unsigned int tx_ch5_int_ena        : 1; // [21]
+		unsigned int tx_ch6_int_ena        : 1; // [22]
+		unsigned int tx_ch7_int_ena        : 1; // [23]
+		unsigned int spdiftx_ch0_int_ena   : 1; // [24]
+		unsigned int spdiftx_ch1_int_ena   : 1; // [25]
+		unsigned int spdiftx_ch2_int_ena   : 1; // [26]
+		unsigned int spdiftx_ch3_int_ena   : 1; // [27]
+		unsigned int Reserved_0            : 4; // [31..28]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_AIAO_INT_ENA;
+
+// Define the union U_AIAO_INT_STATUS
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int rx_ch0_int_status     : 1; // [0]
+		unsigned int rx_ch1_int_status     : 1; // [1]
+		unsigned int rx_ch2_int_status     : 1; // [2]
+		unsigned int rx_ch3_int_status     : 1; // [3]
+		unsigned int rx_ch4_int_status     : 1; // [4]
+		unsigned int rx_ch5_int_status     : 1; // [5]
+		unsigned int rx_ch6_int_status     : 1; // [6]
+		unsigned int rx_ch7_int_status     : 1; // [7]
+		unsigned int Reserved_1            : 8; // [15..8]
+		unsigned int tx_ch0_int_status     : 1; // [16]
+		unsigned int tx_ch1_int_status     : 1; // [17]
+		unsigned int tx_ch2_int_status     : 1; // [18]
+		unsigned int tx_ch3_int_status     : 1; // [19]
+		unsigned int tx_ch4_int_status     : 1; // [20]
+		unsigned int tx_ch5_int_status     : 1; // [21]
+		unsigned int tx_ch6_int_status     : 1; // [22]
+		unsigned int tx_ch7_int_status     : 1; // [23]
+		unsigned int spdiftx_ch0_int_status  : 1; // [24]
+		unsigned int spdiftx_ch1_int_status  : 1; // [25]
+		unsigned int spdiftx_ch2_int_status  : 1; // [26]
+		unsigned int spdiftx_ch3_int_status  : 1; // [27]
+		unsigned int Reserved_0            : 4; // [31..28]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_AIAO_INT_STATUS;
+
+// Define the union U_AIAO_INT_RAW
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int rx_ch0_int_raw        : 1; // [0]
+		unsigned int rx_ch1_int_raw        : 1; // [1]
+		unsigned int rx_ch2_int_raw        : 1; // [2]
+		unsigned int rx_ch3_int_raw        : 1; // [3]
+		unsigned int rx_ch4_int_raw        : 1; // [4]
+		unsigned int rx_ch5_int_raw        : 1; // [5]
+		unsigned int rx_ch6_int_raw        : 1; // [6]
+		unsigned int rx_ch7_int_raw        : 1; // [7]
+		unsigned int Reserved_1            : 8; // [15..8]
+		unsigned int tx_ch0_int_raw        : 1; // [16]
+		unsigned int tx_ch1_int_raw        : 1; // [17]
+		unsigned int tx_ch2_int_raw        : 1; // [18]
+		unsigned int tx_ch3_int_raw        : 1; // [19]
+		unsigned int tx_ch4_int_raw        : 1; // [20]
+		unsigned int tx_ch5_int_raw        : 1; // [21]
+		unsigned int tx_ch6_int_raw        : 1; // [22]
+		unsigned int tx_ch7_int_raw        : 1; // [23]
+		unsigned int spdiftx_ch0_int_raw   : 1; // [24]
+		unsigned int spdiftx_ch1_int_raw   : 1; // [25]
+		unsigned int spdiftx_ch2_int_raw   : 1; // [26]
+		unsigned int spdiftx_ch3_int_raw   : 1; // [27]
+		unsigned int Reserved_0            : 4; // [31..28]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_AIAO_INT_RAW;
+
+// Define the union U_HW_CAPABILITY
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int rx_ch0_cap            : 1; // [0]
+		unsigned int rx_ch1_cap            : 1; // [1]
+		unsigned int rx_ch2_cap            : 1; // [2]
+		unsigned int rx_ch3_cap            : 1; // [3]
+		unsigned int rx_ch4_cap            : 1; // [4]
+		unsigned int rx_ch5_cap            : 1; // [5]
+		unsigned int rx_ch6_cap            : 1; // [6]
+		unsigned int rx_ch7_cap            : 1; // [7]
+		unsigned int Reserved_1            : 8; // [15..8]
+		unsigned int tx_ch0_cap            : 1; // [16]
+		unsigned int tx_ch1_cap            : 1; // [17]
+		unsigned int tx_ch2_cap            : 1; // [18]
+		unsigned int tx_ch3_cap            : 1; // [19]
+		unsigned int tx_ch4_cap            : 1; // [20]
+		unsigned int tx_ch5_cap            : 1; // [21]
+		unsigned int tx_ch6_cap            : 1; // [22]
+		unsigned int tx_ch7_cap            : 1; // [23]
+		unsigned int spdiftx_ch0_cap       : 1; // [24]
+		unsigned int spdiftx_ch1_cap       : 1; // [25]
+		unsigned int spdiftx_ch2_cap       : 1; // [26]
+		unsigned int spdiftx_ch3_cap       : 1; // [27]
+		unsigned int Reserved_0            : 4; // [31..28]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_HW_CAPABILITY;
+
+// Define the union U_SPDIF_TX_MUX
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int spdif_tx_0_port_sel   : 3; // [2..0]
+		unsigned int spdif_tx_0_port_en    : 1; // [3]
+		unsigned int Reserved_3            : 4; // [7..4]
+		unsigned int spdif_tx_1_port_sel   : 3; // [10..8]
+		unsigned int spdif_tx_1_port_en    : 1; // [11]
+		unsigned int Reserved_2            : 4; // [15..12]
+		unsigned int spdif_tx_2_port_sel   : 3; // [18..16]
+		unsigned int spdif_tx_2_port_en    : 1; // [19]
+		unsigned int Reserved_1            : 4; // [23..20]
+		unsigned int spdif_tx_3_port_sel   : 3; // [26..24]
+		unsigned int spdif_tx_3_port_en    : 1; // [27]
+		unsigned int Reserved_0            : 4; // [31..28]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIF_TX_MUX;
+
+// Define the union U_I2S_CRG_CFG0
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int aiao_mclk_div         : 27; // [26..0]
+		unsigned int Reserved_0            : 5; // [31..27]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_I2S_CRG_CFG0;
+
+// Define the union U_I2S_CRG_CFG1
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int aiao_bclk_div         : 4; // [3..0]
+		unsigned int aiao_fsclk_div        : 3; // [6..4]
+		unsigned int Reserved_1            : 1; // [7]
+		unsigned int aiao_cken             : 1; // [8]
+		unsigned int aiao_srst_req         : 1; // [9]
+		unsigned int aiao_bclk_oen         : 1; // [10]
+		unsigned int aiao_bclk_sel         : 1; // [11]
+		unsigned int aiao_bclkin_pctrl     : 1; // [12]
+		unsigned int aiao_bclkout_pctrl    : 1; // [13]
+		unsigned int aiao_bclk_en          : 1; // [14]
+		unsigned int aiao_ws_en            : 1; // [15]
+		unsigned int Reserved_0            : 16; // [31..16]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_I2S_CRG_CFG1;
+
+
+// Define the union U_SPDIF_CRG_CFG0
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int aiao_mclk_div_spdif   : 27; // [26..0]
+		unsigned int Reserved_0            : 5; // [31..27]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIF_CRG_CFG0;
+
+// Define the union U_SPDIF_CRG_CFG1_03
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int aiao_bclk_div_spdif   : 4; // [3..0]
+		unsigned int aiao_fsclk_div_spdif  : 3; // [6..4]
+		unsigned int Reserved_1            : 1; // [7]
+		unsigned int aiao_cken_spdif       : 1; // [8]
+		unsigned int aiao_srst_req_spdif   : 1; // [9]
+		unsigned int Reserved_0            : 22; // [31..10]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIF_CRG_CFG1;
+
+// Define the union U_AIAO_RXSWITCH_CFG
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int inner_bclk_ws_sel_rx_00  : 4; // [3..0]
+		unsigned int inner_bclk_ws_sel_rx_01  : 4; // [7..4]
+		unsigned int inner_bclk_ws_sel_rx_02  : 4; // [11..8]
+		unsigned int inner_bclk_ws_sel_rx_03  : 4; // [15..12]
+		unsigned int inner_bclk_ws_sel_rx_04  : 4; // [19..16]
+		unsigned int inner_bclk_ws_sel_rx_05  : 4; // [23..20]
+		unsigned int inner_bclk_ws_sel_rx_06  : 4; // [27..24]
+		unsigned int inner_bclk_ws_sel_rx_07  : 4; // [31..28]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_AIAO_SWITCH_RX_BCLK;
+
+// Define the union U_AIAO_TXSWITCH_CFG
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int inner_bclk_ws_sel_tx_00  : 4; // [3..0]
+		unsigned int inner_bclk_ws_sel_tx_01  : 4; // [7..4]
+		unsigned int inner_bclk_ws_sel_tx_02  : 4; // [11..8]
+		unsigned int inner_bclk_ws_sel_tx_03  : 4; // [15..12]
+		unsigned int inner_bclk_ws_sel_tx_04  : 4; // [19..16]
+		unsigned int inner_bclk_ws_sel_tx_05  : 4; // [23..20]
+		unsigned int inner_bclk_ws_sel_tx_06  : 4; // [27..24]
+		unsigned int inner_bclk_ws_sel_tx_07  : 4; // [31..28]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_AIAO_SWITCH_TX_BCLK;
+
+// Define the union U_RX_IF_ATTRI
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int rx_mode               : 2; // [1..0]
+		unsigned int rx_i2s_precision      : 2; // [3..2]
+		unsigned int rx_ch_num             : 2; // [5..4]
+		unsigned int Reserved_1            : 1; // [6]
+		unsigned int rx_multislot_en       : 1; // [7]
+		unsigned int rx_sd_offset          : 8; // [15..8]
+		unsigned int rx_trackmode          : 3; // [18..16]
+		unsigned int Reserved_0            : 1; // [19]
+		unsigned int rx_sd_source_sel      : 4; // [23..20]
+		unsigned int rx_sd0_sel            : 2; // [25..24]
+		unsigned int rx_sd1_sel            : 2; // [27..26]
+		unsigned int rx_sd2_sel            : 2; // [29..28]
+		unsigned int rx_sd3_sel            : 2; // [31..30]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_RX_IF_ATTRI;
+
+// Define the union U_RX_DSP_CTRL
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int mute_en               : 1; // [0]
+		unsigned int mute_fade_en          : 1; // [1]
+		unsigned int pause_en              : 1; // [2]
+		unsigned int pause_fade_en         : 1; // [3]
+		unsigned int Reserved_3            : 4; // [7..4]
+		unsigned int volume                : 7; // [14..8]
+		unsigned int Reserved_2            : 1; // [15]
+		unsigned int fade_in_rate          : 4; // [19..16]
+		unsigned int fade_out_rate         : 4; // [23..20]
+		unsigned int Reserved_1            : 3; // [26..24]
+		unsigned int bypass_en             : 1; // [27]
+		unsigned int rx_enable             : 1; // [28]
+		unsigned int rx_disable_done       : 1; // [29]
+		unsigned int Reserved_0            : 2; // [31..30]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_RX_DSP_CTRL;
+
+// Define the union U_RX_WS_CNT
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int ws_count              : 24; // [23..0]
+		unsigned int Reserved_0            : 8; // [31..24]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_RX_WS_CNT;
+
+// Define the union U_RX_BCLK_CNT
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int bclk_count            : 24; // [23..0]
+		unsigned int Reserved_0            : 8; // [31..24]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_RX_BCLK_CNT;
+
+// Define the union U_RX_BUFF_SIZE
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int rx_buff_size          : 24; // [23..0]
+		unsigned int Reserved_0            : 8; // [31..24]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_RX_BUFF_SIZE;
+
+// Define the union U_RX_BUFF_WPTR
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int rx_buff_wptr          : 24; // [23..0]
+		unsigned int Reserved_0            : 8; // [31..24]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_RX_BUFF_WPTR;
+
+// Define the union U_RX_BUFF_RPTR
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int rx_buff_rptr          : 24; // [23..0]
+		unsigned int Reserved_0            : 8; // [31..24]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_RX_BUFF_RPTR;
+
+// Define the union U_RX_BUFF_ALFULL_TH
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int rx_buff_alfull_th     : 24; // [23..0]
+		unsigned int Reserved_0            : 8; // [31..24]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_RX_BUFF_ALFULL_TH;
+
+// Define the union U_RX_TRANS_SIZE
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int rx_trans_size         : 24; // [23..0]
+		unsigned int Reserved_0            : 8; // [31..24]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_RX_TRANS_SIZE;
+
+// Define the union U_RX_WPTR_TMP
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int rx_wptr_tmp           : 24; // [23..0]
+		unsigned int Reserved_0            : 8; // [31..24]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_RX_WPTR_TMP;
+
+// Define the union U_RX_INT_ENA
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int rx_trans_int_ena      : 1; // [0]
+		unsigned int rx_full_int_ena       : 1; // [1]
+		unsigned int rx_alfull_int_ena     : 1; // [2]
+		unsigned int rx_bfifo_full_int_ena  : 1; // [3]
+		unsigned int rx_ififo_full_int_ena  : 1; // [4]
+		unsigned int rx_stop_int_ena       : 1; // [5]
+		unsigned int Reserved_0            : 26; // [31..6]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_RX_INT_ENA;
+
+// Define the union U_RX_INT_RAW
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int rx_trans_int_raw      : 1; // [0]
+		unsigned int rx_full_int_raw       : 1; // [1]
+		unsigned int rx_alfull_int_raw     : 1; // [2]
+		unsigned int rx_bfifo_full_int_raw  : 1; // [3]
+		unsigned int rx_ififo_full_int_raw  : 1; // [4]
+		unsigned int rx_stop_int_raw       : 1; // [5]
+		unsigned int Reserved_0            : 26; // [31..6]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_RX_INT_RAW;
+
+// Define the union U_RX_INT_STATUS
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int rx_trans_int_status   : 1; // [0]
+		unsigned int rx_full_int_status    : 1; // [1]
+		unsigned int rx_alfull_int_status  : 1; // [2]
+		unsigned int rx_bfifo_full_int_status  : 1; // [3]
+		unsigned int rx_ififo_full_int_status  : 1; // [4]
+		unsigned int rx_stop_int_status    : 1; // [5]
+		unsigned int Reserved_0            : 26; // [31..6]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_RX_INT_STATUS;
+
+// Define the union U_RX_INT_CLR
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int rx_trans_int_clear    : 1; // [0]
+		unsigned int rx_full_int_clear     : 1; // [1]
+		unsigned int rx_alfull_int_clear   : 1; // [2]
+		unsigned int rx_bfifo_full_int_clear  : 1; // [3]
+		unsigned int rx_ififo_full_int_clear  : 1; // [4]
+		unsigned int rx_stop_int_clear     : 1; // [5]
+		unsigned int Reserved_0            : 26; // [31..6]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_RX_INT_CLR;
+
+// Define the union U_TX_IF_ATTRI
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int tx_mode               : 2; // [1..0]
+		unsigned int tx_i2s_precision      : 2; // [3..2]
+		unsigned int tx_ch_num             : 2; // [5..4]
+		unsigned int tx_underflow_ctrl     : 1; // [6]
+		unsigned int Reserved_1            : 1; // [7]
+		unsigned int tx_sd_offset          : 8; // [15..8]
+		unsigned int tx_trackmode          : 3; // [18..16]
+		unsigned int Reserved_0            : 1; // [19]
+		unsigned int tx_sd_source_sel      : 4; // [23..20]
+		unsigned int tx_sd0_sel            : 2; // [25..24]
+		unsigned int tx_sd1_sel            : 2; // [27..26]
+		unsigned int tx_sd2_sel            : 2; // [29..28]
+		unsigned int tx_sd3_sel            : 2; // [31..30]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_TX_IF_ATTRI;
+
+// Define the union U_TX_DSP_CTRL
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int    mute_en               : 1   ; // [0]
+		unsigned int    mute_fade_en          : 1   ; // [1]
+		unsigned int    Reserved_3            : 6   ; // [7..2]
+		unsigned int    volume                : 7   ; // [14..8]
+		unsigned int    Reserved_2            : 1   ; // [15]
+		unsigned int    fade_in_rate          : 4   ; // [19..16]
+		unsigned int    fade_out_rate         : 4   ; // [23..20]
+		unsigned int    Reserved_1            : 3   ; // [26..24]
+		unsigned int    bypass_en             : 1   ; // [27]
+		unsigned int    tx_enable             : 1   ; // [28]
+		unsigned int    tx_disable_done       : 1   ; // [29]
+		unsigned int    Reserved_0            : 2   ; // [31..30]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_TX_DSP_CTRL;
+
+// Define the union U_TX_DSP_STATUS
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int    mute_fade_vol         : 7   ; // [6..0]
+		unsigned int    Reserved_0            : 25  ; // [31..7]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_TX_DSP_STATUS;
+
+// Define the union U_TX_WS_CNT
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int ws_count              : 24; // [23..0]
+		unsigned int Reserved_0            : 8; // [31..24]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_TX_WS_CNT;
+
+// Define the union U_TX_BCLK_CNT
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int bclk_count            : 24; // [23..0]
+		unsigned int Reserved_0            : 8; // [31..24]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_TX_BCLK_CNT;
+
+// Define the union U_TX_BUFF_SIZE
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int tx_buff_size          : 24; // [23..0]
+		unsigned int Reserved_0            : 8; // [31..24]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_TX_BUFF_SIZE;
+
+// Define the union U_TX_BUFF_WPTR
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int tx_buff_wptr          : 24; // [23..0]
+		unsigned int Reserved_0            : 8; // [31..24]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_TX_BUFF_WPTR;
+
+// Define the union U_TX_BUFF_RPTR
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int tx_buff_rptr          : 24; // [23..0]
+		unsigned int Reserved_0            : 8; // [31..24]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_TX_BUFF_RPTR;
+
+// Define the union U_TX_BUFF_ALEMPTY_TH
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int tx_buff_alempty_th    : 24; // [23..0]
+		unsigned int Reserved_0            : 8; // [31..24]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_TX_BUFF_ALEMPTY_TH;
+
+// Define the union U_TX_TRANS_SIZE
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int tx_trans_size         : 24; // [23..0]
+		unsigned int Reserved_0            : 8; // [31..24]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_TX_TRANS_SIZE;
+
+// Define the union U_TX_RPTR_TMP
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int tx_rptr_tmp           : 24; // [23..0]
+		unsigned int Reserved_0            : 8; // [31..24]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_TX_RPTR_TMP;
+
+// Define the union U_TX_INT_ENA
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int    tx_trans_int_ena      : 1   ; // [0]
+		unsigned int    tx_empty_int_ena      : 1   ; // [1]
+		unsigned int    tx_alempty_int_ena    : 1   ; // [2]
+		unsigned int    tx_bfifo_empty_int_ena  : 1   ; // [3]
+		unsigned int    tx_ififo_empty_int_ena  : 1   ; // [4]
+		unsigned int    tx_stop_int_ena       : 1   ; // [5]
+		unsigned int    tx_mfade_int_ena      : 1   ; // [6]
+		unsigned int    tx_dat_break_int_ena  : 1   ; // [7]
+		unsigned int    Reserved_0            : 24  ; // [31..8]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_TX_INT_ENA;
+
+// Define the union U_TX_INT_RAW
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int    tx_trans_int_raw      : 1   ; // [0]
+		unsigned int    tx_empty_int_raw      : 1   ; // [1]
+		unsigned int    tx_alempty_int_raw    : 1   ; // [2]
+		unsigned int    tx_bfifo_empty_int_raw  : 1   ; // [3]
+		unsigned int    tx_ififo_empty_int_raw  : 1   ; // [4]
+		unsigned int    tx_stop_int_raw       : 1   ; // [5]
+		unsigned int    tx_mfade_int_raw      : 1   ; // [6]
+		unsigned int    tx_dat_break_int_raw  : 1   ; // [7]
+		unsigned int    Reserved_0            : 24  ; // [31..8]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_TX_INT_RAW;
+
+// Define the union U_TX_INT_STATUS
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int    tx_trans_int_status   : 1   ; // [0]
+		unsigned int    tx_empty_int_status   : 1   ; // [1]
+		unsigned int    tx_alempty_int_status  : 1   ; // [2]
+		unsigned int    tx_bfifo_empty_int_status  : 1   ; // [3]
+		unsigned int    tx_ififo_empty_int_status  : 1   ; // [4]
+		unsigned int    tx_stop_int_status    : 1   ; // [5]
+		unsigned int    tx_mfade_int_status   : 1   ; // [6]
+		unsigned int    tx_dat_break_int_status  : 1   ; // [7]
+		unsigned int    Reserved_0            : 24  ; // [31..8]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_TX_INT_STATUS;
+
+// Define the union U_TX_INT_CLR
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int    tx_trans_int_clear    : 1   ; // [0]
+		unsigned int    tx_empty_int_clear    : 1   ; // [1]
+		unsigned int    tx_alempty_int_clear  : 1   ; // [2]
+		unsigned int    tx_bfifo_empty_int_clear  : 1   ; // [3]
+		unsigned int    tx_ififo_empty_int_clear  : 1   ; // [4]
+		unsigned int    tx_stop_int_clear     : 1   ; // [5]
+		unsigned int    tx_mfade_int_clear    : 1   ; // [6]
+		unsigned int    tx_dat_break_int_clear  : 1   ; // [7]
+		unsigned int    Reserved_0            : 24  ; // [31..8]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_TX_INT_CLR;
+
+// Define the union U_SPDIFTX_IF_ATTRI
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int    Reserved_2            : 2   ; // [1..0]
+		unsigned int    tx_i2s_precision      : 2   ; // [3..2]
+		unsigned int    tx_ch_num             : 2   ; // [5..4]
+		unsigned int    Reserved_1            : 10  ; // [15..6]
+		unsigned int    tx_trackmode          : 3   ; // [18..16]
+		unsigned int    Reserved_0            : 13  ; // [31..19]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIFTX_IF_ATTRI;
+
+// Define the union U_SPDIFTX_DSP_CTRL
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int    mute_en               : 1   ; // [0]
+		unsigned int    mute_fade_en          : 1   ; // [1]
+		unsigned int    Reserved_3            : 6   ; // [7..2]
+		unsigned int    volume                : 7   ; // [14..8]
+		unsigned int    Reserved_2            : 1   ; // [15]
+		unsigned int    fade_in_rate          : 4   ; // [19..16]
+		unsigned int    fade_out_rate         : 4   ; // [23..20]
+		unsigned int    Reserved_1            : 3   ; // [26..24]
+		unsigned int    bypass_en             : 1   ; // [27]
+		unsigned int    tx_enable             : 1   ; // [28]
+		unsigned int    tx_disable_done       : 1   ; // [29]
+		unsigned int    Reserved_0            : 2   ; // [31..30]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIFTX_DSP_CTRL;
+
+// Define the union U_SPDIFTX_DSP_STATUS
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int    mute_fade_vol         : 7   ; // [6..0]
+		unsigned int    Reserved_0            : 25  ; // [31..7]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIFTX_DSP_STATUS;
+
+// Define the union U_SPDIFTX_WS_CNT
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int ws_count              : 24; // [23..0]
+		unsigned int Reserved_0            : 8; // [31..24]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIFTX_WS_CNT;
+
+// Define the union U_SPDIFTX_BCLK_CNT
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int bclk_count            : 24; // [23..0]
+		unsigned int Reserved_0            : 8; // [31..24]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIFTX_BCLK_CNT;
+
+// Define the union U_SPDIFTX_BUFF_SIZE
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int tx_buff_size          : 24; // [23..0]
+		unsigned int Reserved_0            : 8; // [31..24]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIFTX_BUFF_SIZE;
+
+// Define the union U_SPDIFTX_BUFF_WPTR
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int tx_buff_wptr          : 24; // [23..0]
+		unsigned int Reserved_0            : 8; // [31..24]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIFTX_BUFF_WPTR;
+
+// Define the union U_SPDIFTX_BUFF_RPTR
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int tx_buff_rptr          : 24; // [23..0]
+		unsigned int Reserved_0            : 8; // [31..24]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIFTX_BUFF_RPTR;
+
+// Define the union U_SPDIFTX_BUFF_ALEMPTY_TH
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int tx_buff_alempty_th    : 24; // [23..0]
+		unsigned int Reserved_0            : 8; // [31..24]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIFTX_BUFF_ALEMPTY_TH;
+
+// Define the union U_SPDIFTX_TRANS_SIZE
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int tx_trans_size         : 24; // [23..0]
+		unsigned int Reserved_0            : 8; // [31..24]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIFTX_TRANS_SIZE;
+
+// Define the union U_SPDIFTX_RPTR_TMP
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int tx_rptr_tmp           : 24; // [23..0]
+		unsigned int Reserved_0            : 8; // [31..24]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIFTX_RPTR_TMP;
+
+// Define the union U_SPDIFTX_INT_ENA
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int    tx_trans_int_ena      : 1   ; // [0]
+		unsigned int    tx_empty_int_ena      : 1   ; // [1]
+		unsigned int    tx_alempty_int_ena    : 1   ; // [2]
+		unsigned int    tx_bfifo_empty_int_ena  : 1   ; // [3]
+		unsigned int    tx_ififo_empty_int_ena  : 1   ; // [4]
+		unsigned int    tx_stop_int_ena       : 1   ; // [5]
+		unsigned int    tx_mfade_int_ena      : 1   ; // [6]
+		unsigned int    tx_dat_break_int_ena  : 1   ; // [7]
+		unsigned int    Reserved_0            : 24  ; // [31..8]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIFTX_INT_ENA;
+
+// Define the union U_SPDIFTX_INT_RAW
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int    tx_trans_int_raw      : 1   ; // [0]
+		unsigned int    tx_empty_int_raw      : 1   ; // [1]
+		unsigned int    tx_alempty_int_raw    : 1   ; // [2]
+		unsigned int    tx_bfifo_empty_int_raw  : 1   ; // [3]
+		unsigned int    tx_ififo_empty_int_raw  : 1   ; // [4]
+		unsigned int    tx_stop_int_raw       : 1   ; // [5]
+		unsigned int    tx_mfade_int_raw      : 1   ; // [6]
+		unsigned int    tx_dat_break_int_raw  : 1   ; // [7]
+		unsigned int    Reserved_0            : 24  ; // [31..8]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIFTX_INT_RAW;
+
+// Define the union U_SPDIFTX_INT_STATUS
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int    tx_trans_int_status   : 1   ; // [0]
+		unsigned int    tx_empty_int_status   : 1   ; // [1]
+		unsigned int    tx_alempty_int_status  : 1   ; // [2]
+		unsigned int    tx_bfifo_empty_int_status  : 1   ; // [3]
+		unsigned int    tx_ififo_empty_int_status  : 1   ; // [4]
+		unsigned int    tx_stop_int_status    : 1   ; // [5]
+		unsigned int    tx_mfade_int_status   : 1   ; // [6]
+		unsigned int    tx_dat_break_int_status  : 1   ; // [7]
+		unsigned int    Reserved_0            : 24  ; // [31..8]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIFTX_INT_STATUS;
+
+// Define the union U_SPDIFTX_INT_CLR
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int    tx_trans_int_clear    : 1   ; // [0]
+		unsigned int    tx_empty_int_clear    : 1   ; // [1]
+		unsigned int    tx_alempty_int_clear  : 1   ; // [2]
+		unsigned int    tx_bfifo_empty_int_clear  : 1   ; // [3]
+		unsigned int    tx_ififo_empty_int_clear  : 1   ; // [4]
+		unsigned int    tx_stop_int_clear     : 1   ; // [5]
+		unsigned int    tx_mfade_int_clear    : 1   ; // [6]
+		unsigned int    tx_dat_break_int_clear  : 1   ; // [7]
+		unsigned int    Reserved_0            : 24  ; // [31..8]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIFTX_INT_CLR;
+
+// Define the union U_SPDIF_CTRL
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int spdif_en              : 1; // [0]
+		unsigned int Reserved_0            : 31; // [31..1]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIF_CTRL;
+
+// Define the union U_SPDIF_CONFIG
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int txdata_en             : 1; // [0]
+		unsigned int mode                  : 2; // [2..1]
+		unsigned int Reserved_0            : 29; // [31..3]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIF_CONFIG;
+
+// Define the union U_SPDIF_INTRUPT
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int lfifo_empty_intr      : 1; // [0]
+		unsigned int rfifo_empty_intr      : 1; // [1]
+		unsigned int lfifo_single_intr     : 1; // [2]
+		unsigned int rfifo_single_intr     : 1; // [3]
+		unsigned int Reserved_0            : 28; // [31..4]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIF_INTRUPT;
+
+// Define the union U_SPDIF_INTR_MASK
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int lfifo_empty_mask      : 1; // [0]
+		unsigned int rfifo_empty__mask     : 1; // [1]
+		unsigned int lfifo_single__mask    : 1; // [2]
+		unsigned int rfifo_single__mask    : 1; // [3]
+		unsigned int Reserved_0            : 28; // [31..4]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIF_INTR_MASK;
+
+// Define the union U_SPDIF_INTR_STATE
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int lfifo_empty_state     : 1; // [0]
+		unsigned int rfifo_empty_state     : 1; // [1]
+		unsigned int lfifo_single_state    : 1; // [2]
+		unsigned int rfifo_single_state    : 1; // [3]
+		unsigned int Reserved_0            : 28; // [31..4]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIF_INTR_STATE;
+
+// Define the union U_SPDIF_CH_STATUS1
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int l_use_a               : 1; // [0]
+		unsigned int l_use_b               : 1; // [1]
+		unsigned int l_use_c               : 1; // [2]
+		unsigned int l_use_d               : 3; // [5..3]
+		unsigned int l_use_mode            : 2; // [7..6]
+		unsigned int r_use_a               : 1; // [8]
+		unsigned int r_use_b               : 1; // [9]
+		unsigned int r_use_c               : 1; // [10]
+		unsigned int r_use_d               : 3; // [13..11]
+		unsigned int r_use_mode            : 2; // [15..14]
+		unsigned int Reserved_0            : 16; // [31..16]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIF_CH_STATUS1;
+
+// Define the union U_SPDIF_CH_STATUS2
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int l_category_code       : 8; // [7..0]
+		unsigned int r_category_code       : 8; // [15..8]
+		unsigned int Reserved_0            : 16; // [31..16]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIF_CH_STATUS2;
+
+// Define the union U_SPDIF_CH_STATUS3
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int l_src_nb              : 4; // [3..0]
+		unsigned int l_ch_nb               : 4; // [7..4]
+		unsigned int r_src_nb              : 4; // [11..8]
+		unsigned int r_ch_nb               : 4; // [15..12]
+		unsigned int Reserved_0            : 16; // [31..16]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIF_CH_STATUS3;
+
+// Define the union U_SPDIF_CH_STATUS4
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int l_freq                : 4; // [3..0]
+		unsigned int l_clk_accuracy        : 2; // [5..4]
+		unsigned int Reserved_1            : 2; // [7..6]
+		unsigned int r_freq                : 4; // [11..8]
+		unsigned int r_clk_accuracy        : 2; // [13..12]
+		unsigned int Reserved_0            : 18; // [31..14]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIF_CH_STATUS4;
+
+// Define the union U_SPDIF_CH_STATUS5
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int l_bit_max             : 1; // [0]
+		unsigned int l_bit_width           : 3; // [3..1]
+		unsigned int l_org_freq            : 4; // [7..4]
+		unsigned int r_bit_max             : 1; // [8]
+		unsigned int r_bit_width           : 3; // [11..9]
+		unsigned int r_org_freq            : 4; // [15..12]
+		unsigned int Reserved_0            : 16; // [31..16]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_SPDIF_CH_STATUS5;
+
+// Define the union U_AIO_CRG35
+typedef union
+{
+	// Define the struct bits
+	struct
+	{
+		unsigned int aio_hrst_req          : 1; // [0]
+		unsigned int aio_hcken             : 1; // [1]
+		unsigned int aio_cksel             : 2; // [3..2]
+		unsigned int Reserved              : 28; // [31..4]
+	} bits;
+
+	// Define an unsigned member
+	unsigned int u32;
+} U_AIO_CRG35;
+
+
+#endif  // __AIAO_REG_H__
+
diff -uraN u-boot-2016.11/product/audio/ao/gk7205v200/amp.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/ao/gk7205v200/amp.c
--- u-boot-2016.11/product/audio/ao/gk7205v200/amp.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/ao/gk7205v200/amp.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,147 @@
+#include <common.h>
+#include <asm/io.h>
+
+#include "amp_reg.h"
+
+//#define DEBUG_AMP
+
+static inline void amp_RegWrite32(unsigned long value, unsigned long mask,
+		unsigned long addr)
+{
+	unsigned long t;
+
+	t = readl((const volatile void*)addr);
+	t &= ~mask;
+	t |= value & mask;
+	writel(t, (volatile void*)addr);
+
+#ifdef DEBUG_AMP
+	printf("### fun:%s line:%d addr :%8lx mask:%8lx value: %8lx\n", __FUNCTION__, __LINE__, addr, mask, value);
+#endif
+}
+
+#if defined(AO_PRODUCT_GK7205V200)
+static void amp_unmute_mux_gk7205v200_demo(void)
+{
+	// gk7205v200 demo
+	amp_RegWrite32(0x1000, 0xffff, IOCFG_AHB_GPIO1_0_ADDR);
+	amp_RegWrite32(0x1, 0x1, GPIO_REGS_ADDR + 0x1400);
+	amp_RegWrite32(0x1, 0x1, GPIO_REGS_ADDR + 0x1004);
+#ifdef DEBUG_AMP
+	printf("gk7205v200_demo amp unmute ok!\n");
+#endif
+}
+
+static void amp_mute_mux_gk7205v200_demo(void)
+{
+	// gk7205v200 demo
+	amp_RegWrite32(0x1000, 0xffff, IOCFG_AHB_GPIO1_0_ADDR);
+	amp_RegWrite32(0x0, 0x1, GPIO_REGS_ADDR + 0x1400);
+	amp_RegWrite32(0x0, 0x1, GPIO_REGS_ADDR + 0x1004);
+#ifdef DEBUG_AMP
+	printf("gk7205v200_demo amp mute ok!\n");
+#endif
+}
+#endif
+
+#if defined(AO_PRODUCT_GK7205V300)
+static void amp_unmute_mux_gk7205v300_demo(void)
+{
+	// gk7205v300 demo
+	amp_RegWrite32(0x1000, 0xffffffff, IOCFG_AHB_GPIO1_0_ADDR);
+	amp_RegWrite32(0x1, 0x1, GPIO_REGS_ADDR + 0x1400);
+	amp_RegWrite32(0x1, 0x1, GPIO_REGS_ADDR + 0x1004);
+#ifdef DEBUG_AMP
+	printf("gk7205v300_demo amp unmute ok!\n");
+#endif
+}
+
+static void amp_mute_mux_gk7205v300_demo(void)
+{
+	// gk7205v300 demo
+	amp_RegWrite32(0x1000, 0xffffffff, IOCFG_AHB_GPIO1_0_ADDR);
+	amp_RegWrite32(0x0, 0x1, GPIO_REGS_ADDR + 0x1400);
+	amp_RegWrite32(0x0, 0x1, GPIO_REGS_ADDR + 0x1004);
+#ifdef DEBUG_AMP
+	printf("gk7205v300_demo amp mute ok!\n");
+#endif
+}
+#endif
+
+#if defined(AO_PRODUCT_GK7202V300)
+static void amp_unmute_mux_gk7202v300_demo(void)
+{
+	// gk7202v300 demo
+	amp_RegWrite32(0x1E02, 0xffffffff, IOCFG_AHB_GPIO1_5_ADDR);
+	amp_RegWrite32(0x1 << 5, 0x1 << 5, GPIO_REGS_ADDR + 0x1400);
+	amp_RegWrite32(0x1 << 5, 0x1 << 5, GPIO_REGS_ADDR + 0x1080);
+#ifdef DEBUG_AMP
+	printf("gk7202v300_demo amp unmute ok!\n");
+#endif
+}
+
+static void amp_mute_mux_gk7202v300_demo(void)
+{
+	// gk7202v300 demo
+	amp_RegWrite32(0x1E02, 0xffffffff, IOCFG_AHB_GPIO1_5_ADDR);
+	amp_RegWrite32(0x0 << 5, 0x1 << 5, GPIO_REGS_ADDR + 0x1400);
+	amp_RegWrite32(0x0 << 5, 0x1 << 5, GPIO_REGS_ADDR + 0x1080);
+#ifdef DEBUG_AMP
+	printf("gk7202v300_demo amp mute ok!\n");
+#endif
+}
+#endif
+
+#if defined(AO_PRODUCT_GK7605V100)
+static void amp_unmute_mux_gk7605v100_demo(void)
+{
+	// gk7605v100 demo
+	amp_RegWrite32(0x1000, 0xffffffff, IOCFG_AHB_GPIO1_0_ADDR);
+	amp_RegWrite32(0x1, 0x1, GPIO_REGS_ADDR + 0x1400);
+	amp_RegWrite32(0x1, 0x1, GPIO_REGS_ADDR + 0x1004);
+#ifdef DEBUG_AMP
+	printf("gk7605v100_demo amp unmute ok!\n");
+#endif
+}
+
+static void amp_mute_mux_gk7605v100_demo(void)
+{
+	// gk7605v100 demo
+	amp_RegWrite32(0x1000, 0xffffffff, IOCFG_AHB_GPIO1_0_ADDR);
+	amp_RegWrite32(0x0, 0x1, GPIO_REGS_ADDR + 0x1400);
+	amp_RegWrite32(0x0, 0x1, GPIO_REGS_ADDR + 0x1004);
+#ifdef DEBUG_AMP
+	printf("gk7605v100_demo amp mute ok!\n");
+#endif
+}
+#endif
+
+void amp_unmute(void)
+{
+#if defined(AO_PRODUCT_GK7205V200)
+	amp_unmute_mux_gk7205v200_demo();
+#elif defined(AO_PRODUCT_GK7205V300)
+	amp_unmute_mux_gk7205v300_demo();
+#elif defined(AO_PRODUCT_GK7202V300)
+	amp_unmute_mux_gk7202v300_demo();
+#elif defined(AO_PRODUCT_GK7605V100)
+	amp_unmute_mux_gk7605v100_demo();
+#else
+	printf("amp_unmute fail!\n");
+#endif
+}
+
+void amp_mute(void)
+{
+#if defined(AO_PRODUCT_GK7205V200)
+	amp_mute_mux_gk7205v200_demo();
+#elif defined(AO_PRODUCT_GK7205V300)
+	amp_mute_mux_gk7205v300_demo();
+#elif defined(AO_PRODUCT_GK7202V300)
+	amp_mute_mux_gk7202v300_demo();
+#elif defined(AO_PRODUCT_GK7605V100)
+	amp_mute_mux_gk7605v100_demo();
+#else
+	printf("amp_mute fail!\n");
+#endif
+}
diff -uraN u-boot-2016.11/product/audio/ao/gk7205v200/amp_reg.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/ao/gk7205v200/amp_reg.h
--- u-boot-2016.11/product/audio/ao/gk7205v200/amp_reg.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/ao/gk7205v200/amp_reg.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,18 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __AMP_REG_H__
+#define __AMP_REG_H__
+
+#define GPIO_REGS_ADDR            (0x120b0000)
+#define IOCFG_CORE_REGS_ADDR      (0x120c0000)
+
+
+#define IOCFG_AHB_GPIO1_0_ADDR    (0x0000 + IOCFG_CORE_REGS_ADDR)
+
+
+#define IOCFG_AHB_GPIO1_5_ADDR    (0x0014 + IOCFG_CORE_REGS_ADDR)
+
+#endif
+
diff -uraN u-boot-2016.11/product/audio/ao/gk7205v200/ao.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/ao/gk7205v200/ao.c
--- u-boot-2016.11/product/audio/ao/gk7205v200/ao.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/ao/gk7205v200/ao.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,64 @@
+#include <common.h>
+#include <command.h>
+#include <version.h>
+#include <asm/io.h>
+#include <asm/arch/platform.h>
+#include <config.h>
+
+#include "type.h"
+#include "board.h"
+#include "aiao_hal.h"
+
+int start_ao( unsigned int u32Addr, unsigned int u32Size,
+		AUDIO_SAMPLE_RATE_E enSample, unsigned int u32Chncnt, unsigned int u32Vol)
+{
+	GK_U32 u32ChnId = 0;
+	GK_U32 u32TransSize = 0;
+	AIO_ATTR_S stAttr;
+
+	if(u32Chncnt == 1)
+	{
+		stAttr.enSoundmode = AUDIO_SOUND_MODE_MONO;
+	}
+	else if(u32Chncnt == 2)
+	{
+		stAttr.enSoundmode = AUDIO_SOUND_MODE_STEREO;
+	}
+	else
+	{
+		printf("u32Chncnt:%u is invalid!\n", u32Chncnt);
+		return GK_FAILURE;
+	}
+	stAttr.enBitwidth = AUDIO_BIT_WIDTH_16;
+	stAttr.enSamplerate = enSample;
+	stAttr.u32ChnCnt = u32Chncnt;
+	stAttr.u32ClkSel = 0;
+	stAttr.u32EXFlag = 0;
+	stAttr.u32FrmNum = 30;
+	stAttr.u32PtNumPerFrm = 320;
+	stAttr.enWorkmode = AIO_MODE_I2S_MASTER;
+	u32TransSize = stAttr.u32PtNumPerFrm<<stAttr.enBitwidth;
+
+	AIAO_ModInit();
+	AIAO_HAL_SysInit();
+	AOP_HAL_SetDevAttr(u32ChnId, &stAttr);
+	AOP_HAL_SetBufferAddr(u32ChnId, u32Addr);
+	AOP_HAL_SetBufferSize(u32ChnId, u32Size);
+	AOP_HAL_SetBuffWptr(u32ChnId, u32Size - 32);
+	AOP_HAL_SetBuffRptr(u32ChnId, 0);
+	AOP_HAL_SetTransSize(u32ChnId, u32TransSize);
+	AOP_HAL_SetVolume(u32ChnId, u32Vol);
+	AOP_HAL_DevEnable(u32ChnId);
+
+	return GK_SUCCESS;
+}
+
+int stop_ao(void)
+{
+	GK_U32 u32ChnId = 0;
+	AOP_HAL_DevDisable(u32ChnId);
+	AIAO_ModExit();
+
+	return GK_SUCCESS;
+}
+
diff -uraN u-boot-2016.11/product/audio/ao/gk7205v200/board.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/ao/gk7205v200/board.h
--- u-boot-2016.11/product/audio/ao/gk7205v200/board.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/ao/gk7205v200/board.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,400 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __GK_BOARD_H__
+#define __GK_BOARD_H__
+
+/***************************************/
+#define DDR_BUS_FR                (310000000) /* ddr bus freq:310M */
+
+/***************************************/
+#define DDRC0_REG_ADDR            0x120d0000 /* base addr of DDRCB */
+#define DDRC_REGS_SIZE            0x10000
+
+#define DDRC0_REG_STAT_CFG_ADDR   (DDRC0_REG_ADDR + 0x260)
+#define DDRC0_REG_STAT_WRITE_ADDR (DDRC0_REG_ADDR + 0x264)
+#define DDRC0_REG_STAT_READ_ADDR  (DDRC0_REG_ADDR + 0x268)
+
+/***************************************/
+#define OTP_REGS_ADDR             0x100A0000
+#define OTP_REGS_SIZE             0X10000
+
+/***************************************/
+#define CRG_REGS_ADDR             0x12010000
+#define CRG_REGS_SIZE             0X10000
+
+/***************************************/
+#define SYS_REGS_ADDR             0x12020000
+#define SYS_REGS_SIZE             0x8000
+
+/***************************************/
+#define MISC_REGS_ADDR            0x12028000
+#define MISC_REGS_SIZE            0x8000
+
+/***************************************/
+#define VOU_REGS_ADDR             0x11280000
+#define VOU_REGS_SIZE             0x40000
+
+/***************************************/
+#define VGS0_REGS_ADDR            0x11300000
+#define VGS_REGS_SIZE             0x10000
+
+/***************************************/
+#define GDC0_BASE_ADDR            0x11110000
+#define GDC_REGS_SIZE             0x10000
+
+/***************************************/
+#define VPSS0_REGS_ADDR           0x11400000
+#define VPSS_REGS_SIZE            0x10000
+
+/***************************************/
+#define VI_CAP0_REGS_ADDR         0x11000000
+#define VI_PROC0_REGS_ADDR        0x11200000
+
+/***************************************/
+#define VEDU_0_REGS_ADDR          0x11410000
+#define VEDU_REGS_SIZE            0x10000
+
+/***************************************/
+#define JPEGU_REGS_ADDR           0x11420000
+#define JPEGU_REGS_SIZE           0x10000
+
+/****************************************/
+/* 0x11260000 ~ 0x1126FFFF */
+#define JPEGD_REGS_ADDR           (0x11260000)
+#define JPEGD_REGS_SIZE           0x10000
+
+/***************************************/
+#define IVE_REGS_ADDR             0x11320000
+#define IVE_REGS_SIZE             0x10000
+#define IVE_CRG_RESET_REGS_ADDR   0x120100c0
+
+#define SVP_NNIE_0_REGS_ADDR      0x11100000
+#define SVP_NNIE_0_REGS_SIZE      0x10000
+
+/***************************************/
+/* Interrupt Request Number  */
+#define VOU_IRQ_NR                (40 + 32)
+#define VOU1_IRQ_NR               (41 + 32)
+#define VI_CAP0_IRQ_NR            (43 + 32)
+#define VI_PROC0_IRQ_NR           (44 + 32)
+#define VPSS0_IRQ_NR              (46 + 32)
+#define VGS0_IRQ_NR               (49 + 32)
+#define AIO_IRQ_NR                (42 + 32)
+#define VEDU_0_IRQ_NR             (47 + 32)
+#define JPEGU_IRQ_NR              (48 + 32)
+#define IVE_IRQ_NR                (51 + 32)
+
+/****************/
+#define SYS_PERCTL0_ADDR          (0x0 + SYS_REGS_ADDR)
+#define SYS_PERCTL1_ADDR          (0x4 + SYS_REGS_ADDR)
+#define SYS_PERCTL2_ADDR          (0x8 + SYS_REGS_ADDR)
+#define SYS_PERCTL3_ADDR          (0xc + SYS_REGS_ADDR)
+#define SYS_PERCTL4_ADDR          (0x10 + SYS_REGS_ADDR)
+#define SYS_PERCTL5_ADDR          (0x14 + SYS_REGS_ADDR)
+#define SYS_PERCTL6_ADDR          (0x18 + SYS_REGS_ADDR)
+#define SYS_PERCTL7_ADDR          (0x1c + SYS_REGS_ADDR)
+#define SYS_PERCTL8_ADDR          (0x20 + SYS_REGS_ADDR)
+#define SYS_PERCTL9_ADDR          (0x24 + SYS_REGS_ADDR)
+#define SYS_PERCTL10_ADDR         (0x28 + SYS_REGS_ADDR)
+#define SYS_PERCTL11_ADDR         (0x2C + SYS_REGS_ADDR)
+#define SYS_PERCTL12_ADDR         (0x30 + SYS_REGS_ADDR)
+#define SYS_PERCTL13_ADDR         (0x34 + SYS_REGS_ADDR)
+#define SYS_PERCTL14_ADDR         (0x38 + SYS_REGS_ADDR)
+#define SYS_PERCTL15_ADDR         (0x3C + SYS_REGS_ADDR)
+#define SYS_PERCTL16_ADDR         (0x40 + SYS_REGS_ADDR)
+#define SYS_PERCTL17_ADDR         (0x44 + SYS_REGS_ADDR)
+#define SYS_PERCTL18_ADDR         (0x48 + SYS_REGS_ADDR)
+#define SYS_PERCTL19_ADDR         (0x4c + SYS_REGS_ADDR)
+#define SYS_PERCTL20_ADDR         (0x50 + SYS_REGS_ADDR)
+#define SYS_PERCTL21_ADDR         (0x54 + SYS_REGS_ADDR)
+#define SYS_PERCTL22_ADDR         (0x58 + SYS_REGS_ADDR)
+#define SYS_PERCTL23_ADDR         (0x5c + SYS_REGS_ADDR)
+#define SYS_PERCTL24_ADDR         (0x60 + SYS_REGS_ADDR)
+#define SYS_PERCTL25_ADDR         (0x64 + SYS_REGS_ADDR)
+#define SYS_PERCTL26_ADDR         (0x68 + SYS_REGS_ADDR)
+#define SYS_PERCTL27_ADDR         (0x6C + SYS_REGS_ADDR)
+#define SYS_PERCTL28_ADDR         (0x70 + SYS_REGS_ADDR)
+#define SYS_PERCTL29_ADDR         (0x74 + SYS_REGS_ADDR)
+#define SYS_PERCTL30_ADDR         (0x78 + SYS_REGS_ADDR)
+#define SYS_PERCTL31_ADDR         (0x7C + SYS_REGS_ADDR)
+#define SYS_PERCTL32_ADDR         (0x80 + SYS_REGS_ADDR)
+#define SYS_PERCTL33_ADDR         (0x84 + SYS_REGS_ADDR)
+#define SYS_PERCTL34_ADDR         (0x88 + SYS_REGS_ADDR)
+#define SYS_PERCTL35_ADDR         (0x8C + SYS_REGS_ADDR)
+#define SYS_PERCTL36_ADDR         (0x90 + SYS_REGS_ADDR)
+#define SYS_PERCTL37_ADDR         (0x94 + SYS_REGS_ADDR)
+#define SYS_PERCTL38_ADDR         (0x98 + SYS_REGS_ADDR)
+#define SYS_PERCTL39_ADDR         (0x9C + SYS_REGS_ADDR)
+#define SYS_PERCTL40_ADDR         (0xa0 + SYS_REGS_ADDR)
+#define SYS_PERCTL41_ADDR         (0xa4 + SYS_REGS_ADDR)
+#define SYS_PERCTL42_ADDR         (0xa8 + SYS_REGS_ADDR)
+#define SYS_PERCTL43_ADDR         (0xaC + SYS_REGS_ADDR)
+#define SYS_PERCTL44_ADDR         (0xb0 + SYS_REGS_ADDR)
+#define SYS_PERCTL45_ADDR         (0xb4 + SYS_REGS_ADDR)
+#define SYS_PERCTL46_ADDR         (0xb8 + SYS_REGS_ADDR)
+#define SYS_PERCTL47_ADDR         (0xbC + SYS_REGS_ADDR)
+#define SYS_PERCTL48_ADDR         (0xc0 + SYS_REGS_ADDR)
+#define SYS_PERCTL49_ADDR         (0xc4 + SYS_REGS_ADDR)
+#define SYS_PERCTL50_ADDR         (0xc8 + SYS_REGS_ADDR)
+#define SYS_PERCTL51_ADDR         (0xcC + SYS_REGS_ADDR)
+#define SYS_PERCTL52_ADDR         (0xd0 + SYS_REGS_ADDR)
+#define SYS_PERCTL53_ADDR         (0xd4 + SYS_REGS_ADDR)
+#define SYS_PERCTL54_ADDR         (0xd8 + SYS_REGS_ADDR)
+#define SYS_PERCTL55_ADDR         (0xdC + SYS_REGS_ADDR)
+#define SYS_PERCTL56_ADDR         (0xe0 + SYS_REGS_ADDR)
+#define SYS_PERCTL57_ADDR         (0xe4 + SYS_REGS_ADDR)
+#define SYS_PERCTL58_ADDR         (0xe8 + SYS_REGS_ADDR)
+#define SYS_PERCTL59_ADDR         (0xeC + SYS_REGS_ADDR)
+#define SYS_PERCTL60_ADDR         (0xf0 + SYS_REGS_ADDR)
+#define SYS_PERCTL61_ADDR         (0xf4 + SYS_REGS_ADDR)
+#define SYS_PERCTL62_ADDR         (0xf8 + SYS_REGS_ADDR)
+#define SYS_PERCTL63_ADDR         (0xfC + SYS_REGS_ADDR)
+#define SYS_PERCTL64_ADDR         (0x100 + SYS_REGS_ADDR)
+#define SYS_PERCTL65_ADDR         (0x104 + SYS_REGS_ADDR)
+#define SYS_PERCTL66_ADDR         (0x108 + SYS_REGS_ADDR)
+#define SYS_PERCTL67_ADDR         (0x10c + SYS_REGS_ADDR)
+#define SYS_PERCTL68_ADDR         (0x110 + SYS_REGS_ADDR)
+#define SYS_PERCTL69_ADDR         (0x114 + SYS_REGS_ADDR)
+#define SYS_PERCTL70_ADDR         (0x118 + SYS_REGS_ADDR)
+#define SYS_PERCTL71_ADDR         (0x11c + SYS_REGS_ADDR)
+#define SYS_PERCTL72_ADDR         (0x120 + SYS_REGS_ADDR)
+#define SYS_PERCTL73_ADDR         (0x124 + SYS_REGS_ADDR)
+#define SYS_PERCTL74_ADDR         (0x128 + SYS_REGS_ADDR)
+#define SYS_PERCTL75_ADDR         (0x12C + SYS_REGS_ADDR)
+#define SYS_PERCTL76_ADDR         (0x130 + SYS_REGS_ADDR)
+#define SYS_PERCTL77_ADDR         (0x134 + SYS_REGS_ADDR)
+#define SYS_PERCTL78_ADDR         (0x138 + SYS_REGS_ADDR)
+#define SYS_PERCTL79_ADDR         (0x13C + SYS_REGS_ADDR)
+#define SYS_PERCTL80_ADDR         (0x140 + SYS_REGS_ADDR)
+#define SYS_PERCTL81_ADDR         (0x144 + SYS_REGS_ADDR)
+#define SYS_PERCTL82_ADDR         (0x148 + SYS_REGS_ADDR)
+#define SYS_PERCTL83_ADDR         (0x14c + SYS_REGS_ADDR)
+#define SYS_PERCTL84_ADDR         (0x150 + SYS_REGS_ADDR)
+#define SYS_PERCTL85_ADDR         (0x154 + SYS_REGS_ADDR)
+#define SYS_PERCTL86_ADDR         (0x158 + SYS_REGS_ADDR)
+#define SYS_PERCTL87_ADDR         (0x15c + SYS_REGS_ADDR)
+#define SYS_PERCTL88_ADDR         (0x160 + SYS_REGS_ADDR)
+#define SYS_PERCTL89_ADDR         (0x164 + SYS_REGS_ADDR)
+#define SYS_PERCTL90_ADDR         (0x168 + SYS_REGS_ADDR)
+#define SYS_PERCTL91_ADDR         (0x16C + SYS_REGS_ADDR)
+#define SYS_PERCTL92_ADDR         (0x170 + SYS_REGS_ADDR)
+#define SYS_PERCTL93_ADDR         (0x174 + SYS_REGS_ADDR)
+#define SYS_PERCTL94_ADDR         (0x178 + SYS_REGS_ADDR)
+#define SYS_PERCTL95_ADDR         (0x17C + SYS_REGS_ADDR)
+#define SYS_PERCTL96_ADDR         (0x180 + SYS_REGS_ADDR)
+#define SYS_PERCTL97_ADDR         (0x184 + SYS_REGS_ADDR)
+#define SYS_PERCTL98_ADDR         (0x188 + SYS_REGS_ADDR)
+#define SYS_PERCTL99_ADDR         (0x18C + SYS_REGS_ADDR)
+#define SYS_PERCTL100_ADDR        (0x190 + SYS_REGS_ADDR)
+#define SYS_PERCTL101_ADDR        (0x194 + SYS_REGS_ADDR)
+#define SYS_PERCTL102_ADDR        (0x198 + SYS_REGS_ADDR)
+#define SYS_PERCTL103_ADDR        (0x19C + SYS_REGS_ADDR)
+#define SYS_PERCTL104_ADDR        (0x1a0 + SYS_REGS_ADDR)
+#define SYS_PERCTL105_ADDR        (0x1a4 + SYS_REGS_ADDR)
+#define SYS_PERCTL106_ADDR        (0x1a8 + SYS_REGS_ADDR)
+#define SYS_PERCTL107_ADDR        (0x1aC + SYS_REGS_ADDR)
+#define SYS_PERCTL108_ADDR        (0x1b0 + SYS_REGS_ADDR)
+#define SYS_PERCTL109_ADDR        (0x1b4 + SYS_REGS_ADDR)
+#define SYS_PERCTL110_ADDR        (0x1b8 + SYS_REGS_ADDR)
+#define SYS_PERCTL111_ADDR        (0x1bC + SYS_REGS_ADDR)
+#define SYS_PERCTL112_ADDR        (0x1c0 + SYS_REGS_ADDR)
+#define SYS_PERCTL113_ADDR        (0x1c4 + SYS_REGS_ADDR)
+#define SYS_PERCTL114_ADDR        (0x1c8 + SYS_REGS_ADDR)
+#define SYS_PERCTL115_ADDR        (0x1cC + SYS_REGS_ADDR)
+#define SYS_PERCTL116_ADDR        (0x1d0 + SYS_REGS_ADDR)
+#define SYS_PERCTL117_ADDR        (0x1d4 + SYS_REGS_ADDR)
+#define SYS_PERCTL118_ADDR        (0x1d8 + SYS_REGS_ADDR)
+#define SYS_PERCTL119_ADDR        (0x1dC + SYS_REGS_ADDR)
+#define SYS_PERCTL120_ADDR        (0x1e0 + SYS_REGS_ADDR)
+#define SYS_PERCTL121_ADDR        (0x1e4 + SYS_REGS_ADDR)
+#define SYS_PERCTL122_ADDR        (0x1e8 + SYS_REGS_ADDR)
+#define SYS_PERCTL123_ADDR        (0x1eC + SYS_REGS_ADDR)
+#define SYS_PERCTL124_ADDR        (0x1f0 + SYS_REGS_ADDR)
+#define SYS_PERCTL125_ADDR        (0x1f4 + SYS_REGS_ADDR)
+#define SYS_PERCTL126_ADDR        (0x1f8 + SYS_REGS_ADDR)
+#define SYS_PERCTL127_ADDR        (0x1fC + SYS_REGS_ADDR)
+/****************/
+
+/****************/
+#define CRG_PERCTL0_ADDR          (0x0 + CRG_REGS_ADDR)
+#define CRG_PERCTL1_ADDR          (0x4 + CRG_REGS_ADDR)
+#define CRG_PERCTL2_ADDR          (0x8 + CRG_REGS_ADDR)
+#define CRG_PERCTL3_ADDR          (0xc + CRG_REGS_ADDR)
+#define CRG_PERCTL4_ADDR          (0x10 + CRG_REGS_ADDR)
+#define CRG_PERCTL5_ADDR          (0x14 + CRG_REGS_ADDR)
+#define CRG_PERCTL6_ADDR          (0x18 + CRG_REGS_ADDR)
+#define CRG_PERCTL7_ADDR          (0x1c + CRG_REGS_ADDR)
+#define CRG_PERCTL8_ADDR          (0x20 + CRG_REGS_ADDR)
+#define CRG_PERCTL9_ADDR          (0x24 + CRG_REGS_ADDR)
+#define CRG_PERCTL10_ADDR         (0x28 + CRG_REGS_ADDR)
+#define CRG_PERCTL11_ADDR         (0x2C + CRG_REGS_ADDR)
+#define CRG_PERCTL12_ADDR         (0x30 + CRG_REGS_ADDR)
+#define CRG_PERCTL13_ADDR         (0x34 + CRG_REGS_ADDR)
+#define CRG_PERCTL14_ADDR         (0x38 + CRG_REGS_ADDR)
+#define CRG_PERCTL15_ADDR         (0x3C + CRG_REGS_ADDR)
+#define CRG_PERCTL16_ADDR         (0x40 + CRG_REGS_ADDR)
+#define CRG_PERCTL17_ADDR         (0x44 + CRG_REGS_ADDR)
+#define CRG_PERCTL18_ADDR         (0x48 + CRG_REGS_ADDR)
+#define CRG_PERCTL19_ADDR         (0x4c + CRG_REGS_ADDR)
+#define CRG_PERCTL20_ADDR         (0x50 + CRG_REGS_ADDR)
+#define CRG_PERCTL21_ADDR         (0x54 + CRG_REGS_ADDR)
+#define CRG_PERCTL22_ADDR         (0x58 + CRG_REGS_ADDR)
+#define CRG_PERCTL23_ADDR         (0x5c + CRG_REGS_ADDR)
+#define CRG_PERCTL24_ADDR         (0x60 + CRG_REGS_ADDR)
+#define CRG_PERCTL25_ADDR         (0x64 + CRG_REGS_ADDR)
+#define CRG_PERCTL26_ADDR         (0x68 + CRG_REGS_ADDR)
+#define CRG_PERCTL27_ADDR         (0x6C + CRG_REGS_ADDR)
+#define CRG_PERCTL28_ADDR         (0x70 + CRG_REGS_ADDR)
+#define CRG_PERCTL29_ADDR         (0x74 + CRG_REGS_ADDR)
+#define CRG_PERCTL30_ADDR         (0x78 + CRG_REGS_ADDR)
+#define CRG_PERCTL31_ADDR         (0x7C + CRG_REGS_ADDR)
+#define CRG_PERCTL32_ADDR         (0x80 + CRG_REGS_ADDR)
+#define CRG_PERCTL33_ADDR         (0x84 + CRG_REGS_ADDR)
+#define CRG_PERCTL34_ADDR         (0x88 + CRG_REGS_ADDR)
+#define CRG_PERCTL35_ADDR         (0x8C + CRG_REGS_ADDR)
+#define CRG_PERCTL36_ADDR         (0x90 + CRG_REGS_ADDR)
+#define CRG_PERCTL37_ADDR         (0x94 + CRG_REGS_ADDR)
+#define CRG_PERCTL38_ADDR         (0x98 + CRG_REGS_ADDR)
+#define CRG_PERCTL39_ADDR         (0x9C + CRG_REGS_ADDR)
+#define CRG_PERCTL40_ADDR         (0xa0 + CRG_REGS_ADDR)
+#define CRG_PERCTL41_ADDR         (0xa4 + CRG_REGS_ADDR)
+#define CRG_PERCTL42_ADDR         (0xa8 + CRG_REGS_ADDR)
+#define CRG_PERCTL43_ADDR         (0xaC + CRG_REGS_ADDR)
+#define CRG_PERCTL44_ADDR         (0xb0 + CRG_REGS_ADDR)
+#define CRG_PERCTL45_ADDR         (0xb4 + CRG_REGS_ADDR)
+#define CRG_PERCTL46_ADDR         (0xb8 + CRG_REGS_ADDR)
+#define CRG_PERCTL47_ADDR         (0xbC + CRG_REGS_ADDR)
+#define CRG_PERCTL48_ADDR         (0xc0 + CRG_REGS_ADDR)
+#define CRG_PERCTL49_ADDR         (0xc4 + CRG_REGS_ADDR)
+#define CRG_PERCTL50_ADDR         (0xc8 + CRG_REGS_ADDR)
+#define CRG_PERCTL51_ADDR         (0xcC + CRG_REGS_ADDR)
+#define CRG_PERCTL52_ADDR         (0xd0 + CRG_REGS_ADDR)
+#define CRG_PERCTL53_ADDR         (0xd4 + CRG_REGS_ADDR)
+#define CRG_PERCTL54_ADDR         (0xd8 + CRG_REGS_ADDR)
+#define CRG_PERCTL55_ADDR         (0xdC + CRG_REGS_ADDR)
+#define CRG_PERCTL56_ADDR         (0xe0 + CRG_REGS_ADDR)
+#define CRG_PERCTL57_ADDR         (0xe4 + CRG_REGS_ADDR)
+#define CRG_PERCTL58_ADDR         (0xe8 + CRG_REGS_ADDR)
+#define CRG_PERCTL59_ADDR         (0xeC + CRG_REGS_ADDR)
+#define CRG_PERCTL60_ADDR         (0xf0 + CRG_REGS_ADDR)
+#define CRG_PERCTL61_ADDR         (0xf4 + CRG_REGS_ADDR)
+#define CRG_PERCTL62_ADDR         (0xf8 + CRG_REGS_ADDR)
+#define CRG_PERCTL63_ADDR         (0xfC + CRG_REGS_ADDR)
+#define CRG_PERCTL64_ADDR         (0x100 + CRG_REGS_ADDR)
+#define CRG_PERCTL65_ADDR         (0x104 + CRG_REGS_ADDR)
+#define CRG_PERCTL66_ADDR         (0x108 + CRG_REGS_ADDR)
+#define CRG_PERCTL67_ADDR         (0x10c + CRG_REGS_ADDR)
+#define CRG_PERCTL68_ADDR         (0x110 + CRG_REGS_ADDR)
+#define CRG_PERCTL69_ADDR         (0x114 + CRG_REGS_ADDR)
+#define CRG_PERCTL70_ADDR         (0x118 + CRG_REGS_ADDR)
+#define CRG_PERCTL71_ADDR         (0x11c + CRG_REGS_ADDR)
+#define CRG_PERCTL72_ADDR         (0x120 + CRG_REGS_ADDR)
+#define CRG_PERCTL73_ADDR         (0x124 + CRG_REGS_ADDR)
+#define CRG_PERCTL74_ADDR         (0x128 + CRG_REGS_ADDR)
+#define CRG_PERCTL75_ADDR         (0x12C + CRG_REGS_ADDR)
+#define CRG_PERCTL76_ADDR         (0x130 + CRG_REGS_ADDR)
+#define CRG_PERCTL77_ADDR         (0x134 + CRG_REGS_ADDR)
+#define CRG_PERCTL78_ADDR         (0x138 + CRG_REGS_ADDR)
+#define CRG_PERCTL79_ADDR         (0x13C + CRG_REGS_ADDR)
+#define CRG_PERCTL80_ADDR         (0x140 + CRG_REGS_ADDR)
+#define CRG_PERCTL81_ADDR         (0x144 + CRG_REGS_ADDR)
+#define CRG_PERCTL82_ADDR         (0x148 + CRG_REGS_ADDR)
+#define CRG_PERCTL83_ADDR         (0x14c + CRG_REGS_ADDR)
+#define CRG_PERCTL84_ADDR         (0x150 + CRG_REGS_ADDR)
+#define CRG_PERCTL85_ADDR         (0x154 + CRG_REGS_ADDR)
+#define CRG_PERCTL86_ADDR         (0x158 + CRG_REGS_ADDR)
+#define CRG_PERCTL87_ADDR         (0x15c + CRG_REGS_ADDR)
+#define CRG_PERCTL88_ADDR         (0x160 + CRG_REGS_ADDR)
+#define CRG_PERCTL89_ADDR         (0x164 + CRG_REGS_ADDR)
+#define CRG_PERCTL90_ADDR         (0x168 + CRG_REGS_ADDR)
+#define CRG_PERCTL91_ADDR         (0x16C + CRG_REGS_ADDR)
+#define CRG_PERCTL92_ADDR         (0x170 + CRG_REGS_ADDR)
+#define CRG_PERCTL93_ADDR         (0x174 + CRG_REGS_ADDR)
+#define CRG_PERCTL94_ADDR         (0x178 + CRG_REGS_ADDR)
+#define CRG_PERCTL95_ADDR         (0x17C + CRG_REGS_ADDR)
+#define CRG_PERCTL96_ADDR         (0x180 + CRG_REGS_ADDR)
+#define CRG_PERCTL97_ADDR         (0x184 + CRG_REGS_ADDR)
+#define CRG_PERCTL98_ADDR         (0x188 + CRG_REGS_ADDR)
+#define CRG_PERCTL99_ADDR         (0x18C + CRG_REGS_ADDR)
+#define CRG_PERCTL100_ADDR        (0x190 + CRG_REGS_ADDR)
+#define CRG_PERCTL101_ADDR        (0x194 + CRG_REGS_ADDR)
+#define CRG_PERCTL102_ADDR        (0x198 + CRG_REGS_ADDR)
+#define CRG_PERCTL103_ADDR        (0x19C + CRG_REGS_ADDR)
+#define CRG_PERCTL104_ADDR        (0x1a0 + CRG_REGS_ADDR)
+#define CRG_PERCTL105_ADDR        (0x1a4 + CRG_REGS_ADDR)
+#define CRG_PERCTL106_ADDR        (0x1a8 + CRG_REGS_ADDR)
+#define CRG_PERCTL107_ADDR        (0x1aC + CRG_REGS_ADDR)
+#define CRG_PERCTL108_ADDR        (0x1b0 + CRG_REGS_ADDR)
+#define CRG_PERCTL109_ADDR        (0x1b4 + CRG_REGS_ADDR)
+#define CRG_PERCTL110_ADDR        (0x1b8 + CRG_REGS_ADDR)
+#define CRG_PERCTL111_ADDR        (0x1bC + CRG_REGS_ADDR)
+#define CRG_PERCTL112_ADDR        (0x1c0 + CRG_REGS_ADDR)
+#define CRG_PERCTL113_ADDR        (0x1c4 + CRG_REGS_ADDR)
+#define CRG_PERCTL114_ADDR        (0x1c8 + CRG_REGS_ADDR)
+#define CRG_PERCTL115_ADDR        (0x1cC + CRG_REGS_ADDR)
+#define CRG_PERCTL116_ADDR        (0x1d0 + CRG_REGS_ADDR)
+#define CRG_PERCTL117_ADDR        (0x1d4 + CRG_REGS_ADDR)
+#define CRG_PERCTL118_ADDR        (0x1d8 + CRG_REGS_ADDR)
+#define CRG_PERCTL119_ADDR        (0x1dC + CRG_REGS_ADDR)
+#define CRG_PERCTL120_ADDR        (0x1e0 + CRG_REGS_ADDR)
+#define CRG_PERCTL121_ADDR        (0x1e4 + CRG_REGS_ADDR)
+#define CRG_PERCTL122_ADDR        (0x1e8 + CRG_REGS_ADDR)
+#define CRG_PERCTL123_ADDR        (0x1eC + CRG_REGS_ADDR)
+#define CRG_PERCTL124_ADDR        (0x1f0 + CRG_REGS_ADDR)
+#define CRG_PERCTL125_ADDR        (0x1f4 + CRG_REGS_ADDR)
+#define CRG_PERCTL126_ADDR        (0x1f8 + CRG_REGS_ADDR)
+#define CRG_PERCTL127_ADDR        (0x1fC + CRG_REGS_ADDR)
+/****************/
+
+#define MISC_CTL18_ADDR           (0x18 + MISC_REGS_ADDR)
+#define MISC_CTL12C_ADDR          (0x12C + MISC_REGS_ADDR)
+#define MISC_CTL98_ADDR           (0x98 + MISC_REGS_ADDR)
+#define MISC_CTL9C_ADDR           (0x9C + MISC_REGS_ADDR)
+
+/****************/
+
+/* For the following function
+ ** typedef GK_S32 FN_SYS_ViDivSel(GK_S32 s32ViDev, GK_U32 u32DivSel);
+ ** typedef GK_S32 FN_SYS_ViClkSel(GK_S32 s32ViDev, GK_BOOL bSelf);
+ */
+#define SYS_VI_DIV_SEL2           0x00 /* 2 division  */
+#define SYS_VI_DIV_SEL4           0x01 /* 4 division  */
+#define SYS_VI_DIV_SEL1           0x02 /* no division */
+
+/* For the following function
+ ** typedef GK_S32 FN_SYS_VoDivSel(GK_S32 s32ViDev, GK_U32 u32DivSel);
+ */
+#define SYS_VO_DIV_SEL1           0x00 /* 1 division  */
+#define SYS_VO_DIV_SEL2           0x01 /* 2 division  */
+#define SYS_VO_DIV_SEL4           0x02 /* 4 division  */
+
+/* For the following function
+ ** typedef GK_S32 FN_SYS_AioSampleClkDivSel(GK_U32 u32DivSel);
+ */
+#define SYS_AIO_SAMPLE_CLK16      0x0 /* 16 division */
+#define SYS_AIO_SAMPLE_CLK32      0x01 /* 32 division */
+#define SYS_AIO_SAMPLE_CLK48      0x02 /* 48 division */
+#define SYS_AIO_SAMPLE_CLK64      0x03 /* 64 division */
+#define SYS_AIO_SAMPLE_CLK128     0x04 /* 128 division */
+#define SYS_AIO_SAMPLE_CLK256     0x05 /* 256 division */
+
+/* For the following function
+ ** typedef GK_S32 FN_SYS_AioBitStreamClkDivSel(GK_U32 u32DivSel);
+ */
+#define SYS_AIO_BS_CLK1           0x00 /* 1 division */
+#define SYS_AIO_BS_CLK2           0x02 /* 2 division */
+#define SYS_AIO_BS_CLK3           0x01 /* 3 division */
+#define SYS_AIO_BS_CLK4           0x03 /* 4 division */
+#define SYS_AIO_BS_CLK6           0x04 /* 6 division */
+#define SYS_AIO_BS_CLK8           0x05 /* 8 division */
+#define SYS_AIO_BS_CLK12          0x06 /* 12 division */
+#define SYS_AIO_BS_CLK16          0x07 /* 16 division */
+#define SYS_AIO_BS_CLK24          0x08 /* 24 division */
+#define SYS_AIO_BS_CLK32          0x09 /* 32 division */
+#define SYS_AIO_BS_CLK48          0x0a /* 48 division */
+#define SYS_AIO_BS_CLK64          0x0b /* 64 division */
+
+#endif /* __GK_BOARD_H__ */
+
diff -uraN u-boot-2016.11/product/audio/ao/gk7205v200/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/ao/gk7205v200/Makefile
--- u-boot-2016.11/product/audio/ao/gk7205v200/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/ao/gk7205v200/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,40 @@
+sinclude $(TOPDIR)/config.mk
+
+#LIB := $(obj)libao.a
+
+ifeq ($(CONFIG_PRODUCTNAME), "gk7205v200")
+	cflags-y  += -DAO_PRODUCT_GK7205V200
+else ifeq ($(CONFIG_PRODUCTNAME), "gk7205v300")
+	cflags-y  += -DAO_PRODUCT_GK7205V300
+else ifeq ($(CONFIG_PRODUCTNAME), "gk7202v300")
+	cflags-y  += -DAO_PRODUCT_GK7202V300
+else ifeq ($(CONFIG_PRODUCTNAME), "gk7605v100")
+	cflags-y  += -DAO_PRODUCT_GK7605V100
+endif
+
+ccflags-y  += $(cflags-y)
+HOSTCFLAGS += $(cflags-y)
+CPPFLAGS   += $(cflags-y)
+
+obj-y += amp.o
+obj-y += aiao_hal.o
+obj-y += ao.o
+
+#COBJS	:= $(COBJS-y)
+#SRCS	:= $(COBJS:.o=.c)
+#OBJS	:= $(addprefix $(obj),$(COBJS))
+
+#all:	$(LIB)
+
+#$(LIB):	$(obj).depend $(OBJS)
+#	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+#include $(SRCTREE)/rules.mk
+
+#sinclude $(obj).depend
+
+#########################################################################
+
diff -uraN u-boot-2016.11/product/audio/ao/gk7205v200/type.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/ao/gk7205v200/type.h
--- u-boot-2016.11/product/audio/ao/gk7205v200/type.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/audio/ao/gk7205v200/type.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __GK_TYPE_H__
+#define __GK_TYPE_H__
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+typedef unsigned char           GK_U8;
+typedef unsigned short          GK_U16;
+typedef unsigned int            GK_U32;
+
+typedef signed char             GK_S8;
+typedef short                   GK_S16;
+typedef int                     GK_S32;
+
+typedef unsigned long           GK_UL;
+typedef signed long             GK_SL;
+
+typedef float               GK_FLOAT;
+typedef double                  GK_DOUBLE;
+
+#ifndef _M_IX86
+typedef unsigned long long  GK_U64;
+typedef long long           GK_S64;
+#else
+typedef unsigned __int64    GK_U64;
+typedef __int64             GK_S64;
+#endif
+
+typedef char                    GK_CHAR;
+#define GK_VOID                 void
+
+typedef GK_U32                  GK_HANDLE;
+
+typedef enum {
+	GK_FALSE = 0,
+	GK_TRUE  = 1,
+} GK_BOOL;
+
+#ifndef NULL
+#define NULL    0L
+#endif
+
+#define GK_NULL     0L
+#define GK_SUCCESS  0
+#define GK_FAILURE  (-1)
+
+typedef unsigned char           gk_uchar;
+typedef unsigned char           gk_u8;
+typedef unsigned short          gk_u16;
+typedef unsigned int            gk_u32;
+typedef unsigned long long      gk_u64;
+typedef unsigned long           gk_ulong;
+
+typedef char                    gk_char;
+typedef signed char             gk_s8;
+typedef short                   gk_s16;
+typedef int                     gk_s32;
+typedef long long               gk_s64;
+typedef long                    gk_slong;
+
+typedef float                   gk_float;
+typedef double                  gk_double;
+
+typedef void                    gk_void;
+
+typedef unsigned long           gk_size_t;
+typedef unsigned long           gk_length_t;
+
+typedef gk_u32                  gk_handle;
+
+typedef GK_BOOL                 gk_bool;
+typedef uintptr_t               gk_uintptr_t;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __GK_TYPE_H__ */
diff -uraN u-boot-2016.11/product/cipher/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/Makefile
--- u-boot-2016.11/product/cipher/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,49 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+cflags-y     += -I$(srctree)/product/cipher/v2/api
+cflags-y     += -I$(srctree)/product/cipher/v2/drv/platform
+cflags-y     += -I$(srctree)/product/cipher/v2/drv/rng
+cflags-y     += -I$(srctree)/product/cipher/v2/drv/rsa
+cflags-y     += -I$(srctree)/product/cipher/v2/drv/compat
+cflags-y     += -I$(srctree)/product/cipher/v2/drv/sm2
+cflags-y     += -I$(srctree)/product/cipher/v2/drv/spacc
+cflags-y     += -I$(srctree)/product/cipher/v2/drv/include
+cflags-y     += -I$(srctree)/product/opt
+
+ccflags-y  += $(cflags-y)
+HOSTCFLAGS += $(cflags-y)
+CPPFLAGS   += $(cflags-y)
+
+obj-y    += v2/api/ree_mpi_cipher.o \
+            v2/api/ree_mpi_hash.o \
+            v2/api/ree_mpi_rng.o \
+            v2/api/ree_mpi_rsa.o \
+            v2/drv/drv_cipher_intf.o \
+            v2/drv/rng/drv_rng.o \
+            v2/drv/rsa/drv_rsa.o \
+            v2/drv/spacc/spacc_body.o \
+            v2/drv/spacc/spacc_intf.o \
+            v2/drv/compat/drv_klad.o \
+            v2/drv/compat/drv_compat.o \
+            v2/drv/platform/cipher_adapt.o
diff -uraN u-boot-2016.11/product/cipher/v2/api/cipher_osal.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/api/cipher_osal.h
--- u-boot-2016.11/product/cipher/v2/api/cipher_osal.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/api/cipher_osal.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,130 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __CIPHER_OSAL_H__
+#define __CIPHER_OSAL_H__
+
+#ifndef GK_MINIBOOT_SUPPORT
+#include <common.h>
+#else
+#include "string.h"
+#include "stdio.h"
+#endif
+#include "common.h"
+#include "malloc.h"
+#include "types.h"
+#include "drv_cipher.h"
+#include "drv_cipher_ioctl.h"
+#include "mpi_cipher.h"
+#define CIPHER_KLAD_SUPPORT
+#define HASH_BLOCK_SIZE                     128
+#define HASH_RESULT_MAX_LEN                 64
+#define HASH_RESULT_MAX_LEN_IN_WORD         16
+
+#define GK_ERR_CIPHER_NOT_INIT              (gk_s32)(0x804D0001)
+#define GK_ERR_CIPHER_INVALID_HANDLE        (gk_s32)(0x804D0002)
+#define GK_ERR_CIPHER_INVALID_POINT         (gk_s32)(0x804D0003)
+#define GK_ERR_CIPHER_INVALID_PARA          (gk_s32)(0x804D0004)
+#define GK_ERR_CIPHER_FAILED_INIT           (gk_s32)(0x804D0005)
+#define GK_ERR_CIPHER_FAILED_GETHANDLE      (gk_s32)(0x804D0006)
+#define GK_ERR_CIPHER_FAILED_RELEASEHANDLE  (gk_s32)(0x804D0007)
+#define GK_ERR_CIPHER_FAILED_CONFIGAES      (gk_s32)(0x804D0008)
+#define GK_ERR_CIPHER_FAILED_CONFIGDES      (gk_s32)(0x804D0009)
+#define GK_ERR_CIPHER_FAILED_ENCRYPT        (gk_s32)(0x804D000A)
+#define GK_ERR_CIPHER_FAILED_DECRYPT        (gk_s32)(0x804D000B)
+#define GK_ERR_CIPHER_BUSY                  (gk_s32)(0x804D000C)
+#define GK_ERR_CIPHER_NO_AVAILABLE_RNG      (gk_s32)(0x804D000D)
+
+#define cipher_cpu_to_be16(v)               (((v) << 8) | ((v) >> 8))
+
+#define cipher_cpu_to_be32(v)                                   \
+    ((((gk_u32)(v)) >> 24) | ((((gk_u32)(v)) >> 8) & 0xff00) |  \
+     ((((gk_u32)(v)) << 8) & 0xff0000) | (((gk_u32)(v)) << 24))
+
+#define cipher_cpu_to_be64(x)                                           \
+    ((((gk_u64)(x) & (gk_u64)0x00000000000000ffULL) << 56) |            \
+     (((gk_u64)(x) & (gk_u64)0x000000000000ff00ULL) << 40) |            \
+     (((gk_u64)(x) & (gk_u64)0x0000000000ff0000ULL) << 24) |            \
+     (((gk_u64)(x) & (gk_u64)0x00000000ff000000ULL) << 8)  |            \
+     (((gk_u64)(x) & (gk_u64)0x000000ff00000000ULL) >> 8)  |            \
+     (((gk_u64)(x) & (gk_u64)0x0000ff0000000000ULL) >> 24) |            \
+     (((gk_u64)(x) & (gk_u64)0x00ff000000000000ULL) >> 40) |            \
+     (((gk_u64)(x) & (gk_u64)0xff00000000000000ULL) >> 56))
+
+#define cipher_min(a, b) ((a) < (b) ? (a) : (b))
+
+#define UMAP_DEVNAME_CIPHER "cipher"
+#define UMAP_CIPHER_MINOR_BASE              50
+
+#define get_ulong_low(dw) (unsigned int)(dw)
+#define get_ulong_high(dw) 0
+#define make_ulong(low, high) (low)
+
+#define GK_PRINT printf
+#define gk_err_cipher(fmt...)       GK_PRINT(fmt)
+#define gk_info_cipher(fmt...)      // GK_PRINT(fmt)
+
+/* ************************* params check api ******************** */
+#define inlet_var_over_max_return(val, max)    \
+    do {                                       \
+        if ((val) > (max)) {                   \
+            gk_err_cipher("inlet param %s = 0x%x overflow, must less than %s(0x%x).\n", \
+                #val, val, #max, max);         \
+            return GK_ERR_CIPHER_INVALID_PARA; \
+        }                                      \
+    } while (0)
+
+#define inlet_var_is_zero_return(val)                           \
+    do {                                                        \
+        if ((val) == 0) {                                       \
+            gk_err_cipher("inlet param " #val " is zero\n");    \
+            return GK_ERR_CIPHER_INVALID_PARA;                  \
+        }                                                       \
+    } while (0)
+
+#define inlet_var_is_null_return(p)                         \
+    do {                                                    \
+        if ((p) == GK_NULL) {                               \
+            gk_err_cipher("inlet param " #p " is null\n");  \
+            return GK_ERR_CIPHER_INVALID_POINT;             \
+        }                                                   \
+    } while (0)
+
+#define CIPHER_MUTEX gk_void *
+#define cipher_mutex_init(x)
+#define cipher_mutex_lock(x)
+#define cipher_mutex_unlock(x)
+#define cipher_mutex_destroy(x)
+
+#define cipher_open(a, b, c)            (cipher_module_init(), 1)
+#define cipher_close(x)                 (cipher_module_exit())
+#define cipher_ioctl(dev, cmd, argp)    drv_cipher_ioctl(cmd, argp, NULL)
+
+#define cipher_malloc(x) malloc(x)
+#define cipher_free(x) free(x)
+
+gk_void *crypto_memset(gk_void *dst, unsigned int dlen, unsigned val, unsigned int len);
+int crypto_memcmp(const gk_void *a, const gk_void *b, unsigned len);
+gk_void *crypto_memcpy(gk_void *dst, unsigned dstlen, const gk_void *src, unsigned len);
+
+gk_s32 mpi_cipher_get_random_number(gk_u32 *random_number, gk_u32 time_out_us);
+
+extern gk_s32 g_cipher_dev_fd;
+extern gk_s32 g_cipher_init_counter;
+
+#define check_cipher_not_open_return()              \
+    do {                                            \
+        if (g_cipher_init_counter < 0) {            \
+            gk_err_cipher("CIPHER is not open.\n"); \
+            return GK_ERR_CIPHER_NOT_INIT;          \
+        }                                           \
+    } while (0)
+
+typedef struct {
+    gk_void *start_vir_addr;
+    gk_size_t start_phy_addr;
+    gk_u32 mmz_size;
+} cipher_mmz_buf_t;
+
+#endif
diff -uraN u-boot-2016.11/product/cipher/v2/api/mpi_cipher.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/api/mpi_cipher.h
--- u-boot-2016.11/product/cipher/v2/api/mpi_cipher.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/api/mpi_cipher.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,765 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __GK_CIPHER_H__
+#define __GK_CIPHER_H__
+
+#include "types.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/* CIPHER set IV for first package */
+#define GK_CIPHER_IV_CHG_ONE_PKG           1
+
+/* CIPHER set IV for all package */
+#define GK_CIPHER_IV_CHG_ALL_PKG           2
+
+#define GK_CIPHER_MAX_IV_SIZE_IN_WORD       4
+#define GK_CIPHER_MAX_KEY_SIZE_IN_WORD      8
+#define GK_CIPHER_SM1_KEY_SIZE_IN_WORD      4
+#define GK_CIPHER_SM4_KEY_SIZE_IN_WORD      4
+
+/* enum typedef */
+/* Cipher work mode. */
+typedef enum {
+    GK_CIPHER_WORK_MODE_ECB     = 0x0,  /* Electronic codebook (ECB) mode, ECB has been considered insecure and it is
+                                           recommended not to use it. */
+    GK_CIPHER_WORK_MODE_CBC,            /* Cipher block chaining (CBC) mode. */
+    GK_CIPHER_WORK_MODE_CFB,            /* Cipher feedback (CFB) mode. */
+    GK_CIPHER_WORK_MODE_OFB,            /* Output feedback (OFB) mode. */
+    GK_CIPHER_WORK_MODE_CTR,            /* Counter (CTR) mode. */
+    GK_CIPHER_WORK_MODE_CCM,            /* Counter (CCM) mode. */
+    GK_CIPHER_WORK_MODE_GCM,            /* Counter (GCM) mode. */
+    GK_CIPHER_WORK_MODE_CBC_CTS,        /* Cipher block chaining CipherStealing mode. */
+    GK_CIPHER_WORK_MODE_BUTT,
+    GK_CIPHER_WORK_MODE_INVALID = 0xffffffff,
+} gk_cipher_work_mode;
+
+/* Cipher algorithm. */
+typedef enum {
+    GK_CIPHER_ALG_AES           = 0x0,  /* Advanced encryption standard (AES) algorithm */
+    GK_CIPHER_ALG_SM1           = 0x1,  /* SM1 algorithm. */
+    GK_CIPHER_ALG_SM4           = 0x2,  /* SM4 algorithm. */
+    GK_CIPHER_ALG_DMA           = 0x3,  /* DMA copy. */
+    GK_CIPHER_ALG_BUTT          = 0x4,
+    GK_CIPHER_ALG_INVALID       = 0xffffffff,
+} gk_cipher_alg;
+
+/* Key length. */
+typedef enum {
+    GK_CIPHER_KEY_DEFAULT       = 0x0,  /* Default key length, AES-16, SM1-48, SM4-16 */
+    GK_CIPHER_KEY_AES_128BIT    = 0x0,  /* 128-bit key for the AES algorithm */
+    GK_CIPHER_KEY_AES_192BIT    = 0x1,  /* 192-bit key for the AES algorithm */
+    GK_CIPHER_KEY_AES_256BIT    = 0x2,  /* 256-bit key for the AES algorithm */
+    GK_CIPHER_KEY_LEN_BUTT      = 0x3,
+    GK_CIPHER_KEY_INVALID       = 0xffffffff,
+} gk_cipher_key_len;
+
+/* Cipher bit width. */
+typedef enum {
+    GK_CIPHER_BIT_WIDTH_128BIT  = 0x0,  /* 128-bit width */
+    GK_CIPHER_BIT_WIDTH_64BIT   = 0x1,  /* 64-bit width */
+    GK_CIPHER_BIT_WIDTH_8BIT    = 0x2,  /* 8-bit width */
+    GK_CIPHER_BIT_WIDTH_1BIT    = 0x3,  /* 1-bit width */
+    GK_CIPHER_BIT_WIDTH_BUTT    = 0x4,
+    GK_CIPHER_BIT_WIDTH_INVALID = 0xffffffff,
+} gk_cipher_bit_width;
+
+/* Key ladder selecting parameters. */
+typedef enum {
+    GK_CIPHER_KEY_SRC_USER      = 0x0,  /* User Key. */
+    GK_CIPHER_KEY_SRC_KLAD_1,           /* KLAD Key 1. */
+    GK_CIPHER_KEY_SRC_KLAD_2,           /* KLAD Key 2. */
+    GK_CIPHER_KEY_SRC_KLAD_3,           /* KLAD Key 3. */
+    GK_CIPHER_KEY_SRC_BUTT,
+    GK_CIPHER_KEY_SRC_INVALID   = 0xffffffff,
+} gk_cipher_ca_type;
+
+/* Klad target. */
+typedef enum {
+    GK_CIPHER_KLAD_TARGET_AES   = 0x0,  /* Klad for AES. */
+    GK_CIPHER_KLAD_TARGET_RSA,          /* Klad for RSA. */
+    GK_CIPHER_KLAD_TARGET_BUTT,
+} gk_cipher_klad_target;
+
+/* Encryption/Decryption type selecting. */
+typedef enum {
+    GK_CIPHER_TYPE_NORMAL       = 0x0,
+    GK_CIPHER_TYPE_COPY_AVOID,
+    GK_CIPHER_TYPE_BUTT,
+    GK_CIPHER_TYPE_INVALID      = 0xffffffff,
+} gk_cipher_type;
+
+/* SM1 round config */
+typedef enum {
+    GK_CIPHER_SM1_ROUND_08      = 0x00, /* SM1 round 08. */
+    GK_CIPHER_SM1_ROUND_10      = 0x01, /* SM1 round 10. */
+    GK_CIPHER_SM1_ROUND_12      = 0x02, /* SM1 round 12. */
+    GK_CIPHER_SM1_ROUND_14      = 0x03, /* SM1 round 14. */
+    GK_CIPHER_SM1_ROUND_BUTT,
+    GK_CIPHER_SM1_ROUND_INVALID = 0xffffffff,
+} gk_cipher_sm1_round;
+
+/* Hash algrithm type. */
+typedef enum {
+    GK_CIPHER_HASH_TYPE_SHA1,
+    GK_CIPHER_HASH_TYPE_SHA224,
+    GK_CIPHER_HASH_TYPE_SHA256,
+    GK_CIPHER_HASH_TYPE_SHA384,
+    GK_CIPHER_HASH_TYPE_SHA512,
+    GK_CIPHER_HASH_TYPE_HMAC_SHA1,
+    GK_CIPHER_HASH_TYPE_HMAC_SHA224,
+    GK_CIPHER_HASH_TYPE_HMAC_SHA256,
+    GK_CIPHER_HASH_TYPE_HMAC_SHA384,
+    GK_CIPHER_HASH_TYPE_HMAC_SHA512,
+    GK_CIPHER_HASH_TYPE_SM3,
+    GK_CIPHER_HASH_TYPE_BUTT,
+    GK_CIPHER_HASH_TYPE_INVALID = 0xffffffff,
+} gk_cipher_hash_type;
+
+/* Rsa encrypt and decrypt scheme. */
+typedef enum {
+    GK_CIPHER_RSA_ENCRYPT_SCHEME_NO_PADDING  = 0x00, /* without padding. */
+    GK_CIPHER_RSA_ENCRYPT_SCHEME_BLOCK_TYPE_0,       /* PKCS#1 block type 0 padding. */
+    GK_CIPHER_RSA_ENCRYPT_SCHEME_BLOCK_TYPE_1,       /* PKCS#1 block type 1padding. */
+    GK_CIPHER_RSA_ENCRYPT_SCHEME_BLOCK_TYPE_2,       /* PKCS#1 block type 2 padding. */
+    GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA1,    /* PKCS#1 RSAES-OAEP-SHA1 padding. */
+    GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA224,  /* PKCS#1 RSAES-OAEP-SHA224 padding. */
+    GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA256,  /* PKCS#1 RSAES-OAEP-SHA256   padding. */
+    GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA384,  /* PKCS#1 RSAES-OAEP-SHA384   padding. */
+    GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA512,  /* PKCS#1 RSAES-OAEP-SHA512   padding. */
+    GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_PKCS1_V1_5,   /* PKCS#1 RSAES-PKCS1_V1_5    padding. */
+    GK_CIPHER_RSA_ENCRYPT_SCHEME_BUTT,
+    GK_CIPHER_RSA_ENCRYPT_SCHEME_INVALID    = 0xffffffff,
+} gk_cipher_rsa_encrypt_scheme;
+
+/* Rsa sign and verify scheme. */
+typedef enum {
+    GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA1 = 0x100, /* PKCS#1 RSASSA_PKCS1_V15_SHA1 signature. */
+    GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA224,       /* PKCS#1 RSASSA_PKCS1_V15_SHA224 signature. */
+    GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA256,       /* PKCS#1 RSASSA_PKCS1_V15_SHA256 signature. */
+    GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA384,       /* PKCS#1 RSASSA_PKCS1_V15_SHA384 signature. */
+    GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA512,       /* PKCS#1 RSASSA_PKCS1_V15_SHA512 signature. */
+    GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA1,         /* PKCS#1 RSASSA_PKCS1_PSS_SHA1 signature. */
+    GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA224,       /* PKCS#1 RSASSA_PKCS1_PSS_SHA224 signature. */
+    GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA256,       /* PKCS#1 RSASSA_PKCS1_PSS_SHA256 signature. */
+    GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA384,       /* PKCS#1 RSASSA_PKCS1_PSS_SHA1 signature. */
+    GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA512,       /* PKCS#1 RSASSA_PKCS1_PSS_SHA256 signature. */
+    GK_CIPHER_RSA_SIGN_SCHEME_BUTT,
+    GK_CIPHER_RSA_SIGN_SCHEME_INVALID               = 0xffffffff,
+} gk_cipher_rsa_sign_scheme;
+
+/* struct define. */
+/* Cipher control parameters. */
+typedef struct {
+    /* Initial Vector change flag, 0-don't set, 1-set IV for first package, 2-set IV for each package.  */
+    gk_u32 bits_iv      : 2;
+    gk_u32 bits_resv    : 30;             /* Reserved. */
+} gk_cipher_ctrl_chg_flag;
+
+/* Structure of the cipher type */
+typedef struct {
+    gk_cipher_type cipher_type;
+} gk_cipher_attr;
+
+/* Structure of the cipher control information */
+typedef struct {
+    gk_u32 key[GK_CIPHER_MAX_KEY_SIZE_IN_WORD];   /* Key input */
+    gk_u32 iv[GK_CIPHER_MAX_IV_SIZE_IN_WORD];     /* Initialization vector (IV) */
+    gk_bool key_by_ca;                  /* Encryption using advanced conditional access (CA) or decryption using keys */
+    gk_cipher_ca_type ca_type;          /* Select keyladder type when using advanced CA */
+    gk_cipher_alg alg;                  /* Cipher algorithm */
+    gk_cipher_bit_width bit_width;      /* Bit width for encryption or decryption */
+    gk_cipher_work_mode work_mode;      /* Operating mode */
+    gk_cipher_key_len key_len;          /* Key length */
+    gk_cipher_ctrl_chg_flag chg_flags;  /* control information exchange choices, we default all woulde be change
+                                                except they have been in the choices */
+} gk_cipher_ctrl;
+
+/* Structure of the cipher AES control information */
+typedef struct {
+    gk_u32 even_key[GK_CIPHER_MAX_KEY_SIZE_IN_WORD];   /* Key input, default use this key. */
+    gk_u32 odd_key[GK_CIPHER_MAX_KEY_SIZE_IN_WORD];    /* Key input, only valid for Multi encrypt/decrypt. */
+    gk_u32 iv[GK_CIPHER_MAX_IV_SIZE_IN_WORD];          /* Initialization vector (IV) */
+    gk_cipher_bit_width bit_width;           /* Bit width for encryption or decryption */
+    gk_cipher_key_len key_len;               /* Key length */
+    gk_cipher_ctrl_chg_flag chg_flags;       /* control information exchange choices, we default all woulde be change
+                                                except they have been in the choices */
+} gk_cipher_ctrl_aes;
+
+/* Structure of the cipher AES CCM/GCM control information */
+typedef struct {
+    gk_u32 key[GK_CIPHER_MAX_KEY_SIZE_IN_WORD];    /* Key input */
+    gk_u32 iv[GK_CIPHER_MAX_IV_SIZE_IN_WORD];      /* Initialization vector (IV) */
+    gk_cipher_key_len key_len;           /* Key length */
+    gk_u32 iv_len;                       /* IV lenght for CCM/GCM, which is an element of {7, 8, 9, 10, 11, 12, 13}
+                                            for CCM, and is an element of [1-16] for GCM. */
+    gk_u32 tag_len;                      /* Tag lenght for CCM which is an element of {4, 6, 8, 10, 12, 14, 16}. */
+    gk_u32 aad_len;                      /* Associated data for CCM and GCM. */
+    gk_phys_addr_t aad_phys_addr;        /* Physical address of Associated data  for CCM and GCM. */
+} gk_cipher_ctrl_aes_ccm_gcm;
+
+/* Structure of the cipher SM1 control information */
+typedef struct {
+    gk_u32 ek[GK_CIPHER_SM1_KEY_SIZE_IN_WORD];         /* Key of EK input */
+    gk_u32 ak[GK_CIPHER_SM1_KEY_SIZE_IN_WORD];         /* Key of AK input */
+    gk_u32 sk[GK_CIPHER_SM1_KEY_SIZE_IN_WORD];         /* Key of SK input */
+    gk_u32 iv[GK_CIPHER_MAX_IV_SIZE_IN_WORD];          /* Initialization vector (IV) */
+    gk_cipher_bit_width bit_width;           /* Bit width for encryption or decryption */
+    gk_cipher_sm1_round sm1_round;           /* SM1 round number, should be 8, 10, 12 or 14. */
+    gk_cipher_ctrl_chg_flag chg_flags;       /* control information exchange choices, we default all woulde be change
+                                                except they have been in the choices */
+} gk_cipher_ctrl_sm1;
+
+/* Structure of the cipher SM4 control information */
+typedef struct {
+    gk_u32 key[GK_CIPHER_SM4_KEY_SIZE_IN_WORD];        /* Key input */
+    gk_u32 iv[GK_CIPHER_MAX_IV_SIZE_IN_WORD];          /* Initialization vector (IV) */
+    gk_cipher_ctrl_chg_flag chg_flags;       /* control information exchange choices, we default all woulde be change
+                                                except they have been in the choices */
+} gk_cipher_ctrl_sm4;
+
+/* Expand Structure of the cipher control information */
+typedef struct {
+    gk_cipher_alg alg;              /* Cipher algorithm */
+    gk_cipher_work_mode work_mode;  /* Operating mode */
+    gk_bool key_by_ca;              /* Encryption using advanced conditional access (CA) or decryption using keys */
+    /*  Parameter for special algorithm
+        for AES, the pointer should point to gk_cipher_ctrl_aes;
+        for AES_CCM or AES_GCM, the pointer should point to gk_cipher_ctrl_aes_ccm_gcm;
+        for SM1, the pointer should point to gk_cipher_ctrl_sm1;
+        for SM4, the pointer should point to gk_cipher_ctrl_sm4;
+    */
+    gk_void *param;
+    gk_u32 param_size;
+} gk_cipher_ctrl_ex;
+
+/* Cipher data */
+typedef struct {
+    gk_phys_addr_t src_phys_addr;   /* phy address of the original data */
+    gk_phys_addr_t dst_phys_addr;   /* phy address of the purpose data */
+    gk_u32 byte_len;                /* Cigher data length. */
+    gk_bool odd_key;                /* Use odd key or even key. */
+} gk_cipher_data;
+
+/* Hash init struct input */
+typedef struct {
+    gk_u8 *hmac_key;
+    gk_u32 hmac_key_len;
+    gk_cipher_hash_type sha_type;
+} gk_cipher_hash_attr;
+
+/* RSA public key struct */
+typedef struct {
+    gk_u8 *n;         /* Point to public modulus N */
+    gk_u8 *e;         /* Point to public exponent E */
+    gk_u16 n_len;     /* Length of public modulus N, max value is 512Byte */
+    gk_u16 e_len;     /* Length of public exponent E, max value is 512Byte */
+} gk_cipher_rsa_pub_key;
+
+/* RSA private key struct */
+typedef struct {
+    gk_u8 *n;         /* Public modulus N. */
+    gk_u8 *e;         /* Public exponent E. */
+    gk_u8 *d;         /* Private exponent D. */
+    gk_u8 *p;         /* 1st prime factor P. */
+    gk_u8 *q;         /* 2nd prime factor Q. */
+    gk_u8 *dp;        /* descript:d % (p - 1) is DP. */
+    gk_u8 *dq;        /* descript:d % (q - 1) is DQ. */
+    gk_u8 *qp;        /* descript:1 / (q % p) is QP. */
+    gk_u16 n_len;     /* Length of public modulus */
+    gk_u16 e_len;     /* Length of public exponent */
+    gk_u16 d_len;     /* Length of private exponent */
+    gk_u16 p_len;     /* Length of 1st prime factor,should be half of n_len */
+    gk_u16 q_len;     /* Length of 2nd prime factor,should be half of n_len */
+    gk_u16 dp_len;    /* Length of D % (P - 1),should be half of n_len */
+    gk_u16 dq_len;    /* Length of D % (Q - 1),should be half of n_len */
+    gk_u16 qp_len;    /* Length of 1 / (Q % P),should be half of n_len */
+} gk_cipher_rsa_private_key;
+
+/* RSA public key encryption struct input */
+typedef struct {
+    gk_cipher_rsa_encrypt_scheme scheme;    /* RSA encryption scheme */
+    gk_cipher_rsa_pub_key pub_key;          /* RSA public key struct */
+} gk_cipher_rsa_pub_encrypt;
+
+/* RSA private key decryption struct input */
+typedef struct {
+    gk_cipher_rsa_encrypt_scheme scheme;    /* RSA encryption scheme */
+    gk_cipher_rsa_private_key private_key;  /* RSA private key struct */
+    gk_cipher_ca_type ca_type;              /* CA type */
+} gk_cipher_rsa_private_encrypt;
+
+typedef struct {
+    const gk_u8 *in;                        /* Input data to be cryption. */
+    gk_u32 in_len;                          /* Length of input data. */
+    gk_u8 *out;                             /* Output data. */
+    gk_u32 out_buf_len;                     /* Length of output buffer. */
+    gk_u32 *out_len;                        /* Length of output valid data. */
+} gk_cipher_rsa_crypt;
+
+/* RSA signature struct input */
+typedef struct {
+    gk_cipher_rsa_sign_scheme scheme;       /* RSA signature scheme */
+    gk_cipher_rsa_private_key private_key;  /* RSA private key struct */
+    gk_cipher_ca_type ca_type;              /* CA type */
+} gk_cipher_rsa_sign;
+
+/* RSA signature verify struct input */
+typedef struct {
+    gk_cipher_rsa_sign_scheme scheme;       /* RSA signature scheme */
+    gk_cipher_rsa_pub_key pub_key;          /* RSA public key struct */
+} gk_cipher_rsa_verify;
+
+typedef struct {
+    const gk_u8 *in;                    /* Input data to be cryption. */
+    gk_u32 in_len;                      /* Length of input data. */
+    const gk_u8 *hash_data;             /* Hash data. */
+    gk_u32 hash_data_len;               /* Length of hash data. */
+    gk_u8 *sign;                        /* Sign output data. */
+    gk_u32 sign_buf_len;                /* Length of sign output buffer. */
+    gk_u32 *sign_len;                   /* Length of sign output valid data. */
+} gk_cipher_sign_data;
+
+typedef struct {
+    const gk_u8 *in;                    /* Input data to be cryption. */
+    gk_u32 in_len;                      /* Length of input data. */
+    const gk_u8 *hash_data;             /* Hash data. */
+    gk_u32 hash_data_len;               /* Length of hash data. */
+    gk_u8 *sign;                        /* Input sign data. */
+    gk_u32 sign_len;                    /* Length of input sign data. */
+} gk_cipher_verify_data;
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      CIPHER */
+/** @{ */  /** <!-- [CIPHER] */
+/* ---CIPHER---*/
+/**
+\attention
+This API is used to start the cipher device.
+
+\param N/A
+\retval ::GK_SUCCESS  Call this API successful.
+\retval ::GK_FAILURE  Call this API fails.
+\retval ::GK_ERR_CIPHER_FAILED_INIT  The cipher device fails to be initialized.
+\see
+N/A
+*/
+gk_s32 gk_api_cipher_init(gk_void);
+
+/**
+\brief  Deinit the cipher device.
+\attention \n
+This API is used to stop the cipher device.
+If this API is called repeatedly, GK_SUCCESS is returned, but only the first operation takes effect.
+\param N/A
+\retval ::GK_SUCCESS  Call this API successful.
+\retval ::GK_FAILURE  Call this API fails.
+\retval ::GK_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.
+\see \n
+N/A
+*/
+gk_s32 gk_api_cipher_deinit(gk_void);
+
+/**
+\brief Obtain a cipher handle for encryption and decryption.
+
+\param[in] cipher attributes
+\param[out] phCipher Cipher handle
+\retval ::GK_SUCCESS Call this API successful.
+\retval ::GK_FAILURE Call this API fails.
+\retval ::GK_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.
+\retval ::GK_ERR_CIPHER_INVALID_POINT  The pointer is null.
+\retval ::GK_ERR_CIPHER_FAILED_GETHANDLE  The cipher handle fails to be obtained,
+                                          because there are no available cipher handles.
+\see \n
+N/A
+*/
+gk_s32 gk_api_cipher_create_handle(gk_handle* handle, const gk_cipher_attr *cipher_attr);
+
+/**
+\attention \n
+This API is used to destroy existing cipher handles.
+
+\param[in] hCipher Cipher handle
+\retval ::GK_SUCCESS  Call this API successful.
+\retval ::GK_FAILURE  Call this API fails.
+\retval ::GK_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.
+\see \n
+N/A
+*/
+gk_s32 gk_api_cipher_destroy_handle(gk_handle handle);
+
+/**
+\brief Configures the cipher control information.
+\attention \n
+Before encryption or decryption, you must call this API to configure the cipher control information.
+The first 64-bit data and the last 64-bit data should not be the same when using TDES algorithm.
+
+\param[in] hCipher Cipher handle.
+\param[in] pstCtrl Cipher control information.
+\retval ::GK_SUCCESS Call this API successful.
+\retval ::GK_FAILURE Call this API fails.
+\retval ::GK_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.
+\retval ::GK_ERR_CIPHER_INVALID_POINT  The pointer is null.
+\retval ::GK_ERR_CIPHER_INVALID_PARA  The parameter is invalid.
+\retval ::GK_ERR_CIPHER_INVALID_HANDLE  The handle is invalid.
+\see \n
+N/A
+*/
+gk_s32 gk_api_cipher_config_handle(gk_handle handle, gk_cipher_ctrl* cipher_ctrl);
+
+/**
+\brief Configures the cipher control information.
+\attention \n
+Before encryption or decryption, you must call this API to configure the cipher control information.
+The first 64-bit data and the last 64-bit data should not be the same when using TDES algorithm.
+
+\param[in] hCipher Cipher handle.
+\param[in] pstExCtrl Cipher control information.
+\retval ::GK_SUCCESS Call this API successful.
+\retval ::GK_FAILURE Call this API fails.
+\retval ::GK_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.
+\retval ::GK_ERR_CIPHER_INVALID_POINT  The pointer is null.
+\retval ::GK_ERR_CIPHER_INVALID_PARA  The parameter is invalid.
+\retval ::GK_ERR_CIPHER_INVALID_HANDLE  The handle is invalid.
+\see \n
+N/A
+*/
+gk_s32 gk_api_cipher_config_handle_ex(gk_handle handle, gk_cipher_ctrl_ex* ctrl_ex);
+
+/**
+\brief Performs encryption.
+
+\attention \n
+This API is used to perform encryption by using the cipher module.
+The length of the encrypted data should be a multiple of 8 in TDES mode and 16 in AES mode.
+Besides, the length can not be bigger than 0xFFFFF.After this operation, the result will affect next operation.
+If you want to remove vector,
+you need to config IV(config pstCtrl->chg_flags.bit1IV with 1) by transfering gk_api_cipher_config_handle.
+\param[in] hCipher Cipher handle
+\param[in] u32SrcPhyAddr Physical address of the source data
+\param[in] u32DestPhyAddr Physical address of the target data
+\param[in] u32ByteLength   Length of the encrypted data
+\retval ::GK_SUCCESS  Call this API successful.
+\retval ::GK_FAILURE  Call this API fails.
+\retval ::GK_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.
+\retval ::GK_ERR_CIPHER_INVALID_PARA  The parameter is invalid.
+\retval ::GK_ERR_CIPHER_INVALID_HANDLE  The handle is invalid.
+\see \n
+N/A
+*/
+gk_s32 gk_api_cipher_encrypt(gk_handle handle, gk_size_t src_phy_addr, gk_size_t dest_phy_addr, gk_u32 byte_len);
+
+/**
+\brief Performs decryption.
+
+\attention \n
+This API is used to perform decryption by using the cipher module.
+The length of the decrypted data should be a multiple of 8 in TDES mode and 16 in AES mode.
+Besides, the length can not be bigger than 0xFFFFF.
+After this operation, the result will affect next operation.
+If you want to remove vector,
+you need to config IV(config pstCtrl->chg_flags.bit1IV with 1) by transfering gk_api_cipher_config_handle.
+\param[in] hCipher Cipher handle.
+\param[in] u32SrcPhyAddr Physical address of the source data.
+\param[in] u32DestPhyAddr Physical address of the target data.
+\param[in] u32ByteLength Length of the decrypted data
+\retval ::GK_SUCCESS Call this API successful.
+\retval ::GK_FAILURE Call this API fails.
+\retval ::GK_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.
+\retval ::GK_ERR_CIPHER_INVALID_PARA  The parameter is invalid.
+\retval ::GK_ERR_CIPHER_INVALID_HANDLE  The handle is invalid.
+\see \n
+N/A
+*/
+gk_s32 gk_api_cipher_decrypt(gk_handle handle, gk_size_t src_phy_addr, gk_size_t dest_phy_addr, gk_u32 byte_len);
+
+/**
+\brief Encrypt multiple packaged data.
+\attention \n
+You can not encrypt more than 128 data package one time.
+When GK_ERR_CIPHER_BUSY return, the data package you send will not be deal,
+the customer should decrease the number of data package or run cipher again.
+Note: When encrypting more than one packaged data,
+every one package will be calculated using initial vector configured by gk_api_cipher_config_handle.
+Previous result will not affect the later result.
+\param[in] hCipher cipher handle
+\param[in] pstDataPkg data package ready for cipher
+\param[in] u32DataPkgNum  number of package ready for cipher
+\retval ::GK_SUCCESS  Call this API successful.
+\retval ::GK_FAILURE  Call this API fails.
+\retval ::GK_ERR_CIPHER_NOT_INIT  cipher device have not been initialized
+\retval ::GK_ERR_CIPHER_INVALID_PARA  parameter error
+\retval ::GK_ERR_CIPHER_INVALID_HANDLE  handle invalid
+\retval ::GK_ERR_CIPHER_BUSY  hardware is busy, it can not deal with all data package once time
+\see \n
+N/A
+*/
+gk_s32 gk_api_cipher_encrypt_multi_pack(gk_handle handle, gk_cipher_data *data_pkg, gk_u32 data_pkg_num);
+
+/**
+\brief Decrypt multiple packaged data.
+\attention \n
+You can not decrypt more than 128 data package one time.
+When GK_ERR_CIPHER_BUSY return, the data package you send will not be deal,
+the custmer should decrease the number of data package or run cipher again.
+Note: When decrypting more than one packaged data,
+every one package will be calculated using initial vector configured by gk_api_cipher_config_handle.
+Previous result will not affect the later result.
+\param[in] hCipher cipher handle
+\param[in] pstDataPkg data package ready for cipher
+\param[in] u32DataPkgNum  number of package ready for cipher
+\retval ::GK_SUCCESS  Call this API successful.
+\retval ::GK_FAILURE  Call this API fails.
+\retval ::GK_ERR_CIPHER_NOT_INIT  cipher device have not been initialized
+\retval ::GK_ERR_CIPHER_INVALID_PARA  parameter error
+\retval ::GK_ERR_CIPHER_INVALID_HANDLE  handle invalid
+\retval ::GK_ERR_CIPHER_BUSY  hardware is busy, it can not deal with all data package once time
+\see \n
+N/A
+*/
+gk_s32 gk_api_cipher_decrypt_multi_pack(gk_handle handle, gk_cipher_data *data_pkg, gk_u32 data_pkg_num);
+
+/**
+\brief Get the cipher control information.
+
+\param[in] hCipher Cipher handle.
+\param[in] pstCtrl Cipher control information.
+\retval ::GK_SUCCESS Call this API successful.
+\retval ::GK_FAILURE Call this API fails.
+\retval ::GK_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.
+\retval ::GK_ERR_CIPHER_INVALID_POINT  The pointer is null.
+\retval ::GK_ERR_CIPHER_INVALID_PARA  The parameter is invalid.
+\retval ::GK_ERR_CIPHER_INVALID_HANDLE  The handle is invalid.
+\see \n
+N/A
+*/
+gk_s32 gk_api_cipher_get_handle_cfg(gk_handle handle, gk_cipher_ctrl* cipher_ctrl);
+
+/**
+\brief Get the tag data of CCM/GCM.
+
+\attention \n
+This API is used to get the tag data of CCM/GCM.
+\param[in] hCipher cipher handle
+\param[out] pu8Tag tag data of CCM/GCM
+\retval ::GK_SUCCESS  Call this API succussful.
+\retval ::GK_FAILURE  Call this API fails.
+\retval ::GK_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.
+\retval ::GK_ERR_CIPHER_INVALID_PARA  The parameter is invalid.
+\see \n
+N/A
+*/
+gk_s32 gk_api_cipher_get_tag(gk_handle handle, gk_u8 *tag, gk_u32 *tag_len);
+
+/**
+\brief Encrypt the clean key data by KLAD.
+\attention \n
+N/A
+\param[in] enRootKey klad root key.
+\param[in] pu8CleanKey clean key.
+\param[in] enTarget the module who to use this key.
+\param[out] pu8EcnryptKey encrypt key.
+\param[in] u32KeyLen clean key.
+\retval ::GK_SUCCESS Call this API successful.
+\retval ::GK_FAILURE Call this API fails.
+\retval ::GK_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.
+\retval ::GK_ERR_CIPHER_INVALID_POINT  The pointer is null.
+\retval ::GK_ERR_CIPHER_INVALID_PARA  The parameter is invalid.
+\retval ::GK_ERR_CIPHER_INVALID_HANDLE  The handle is invalid.
+\see \n
+N/A
+*/
+gk_s32 gk_api_cipher_klad_encrypt_key(gk_cipher_ca_type root_key,
+                                      gk_cipher_klad_target klad_target,
+                                      gk_u8 *clean_key,
+                                      gk_u8* enc_key,
+                                      gk_u32 key_len);
+
+/**
+\brief Get the random number.
+
+\attention \n
+This API is used to obtain the random number from the hardware.
+
+\param[out] pu32RandomNumber Point to the random number.
+\retval ::GK_SUCCESS  Call this API successful.
+\retval ::GK_FAILURE  Call this API fails.
+
+\see \n
+N/A
+*/
+gk_s32 gk_api_cipher_get_random_number(gk_u32 *random_number);
+
+/**
+\brief Init the hash module, if other program is using the hash module, the API will return failure.
+
+\attention \n
+N/A
+
+\param[in] pstHashAttr: The hash calculating structure input.
+\param[out] pHashHandle: The output hash handle.
+\retval ::GK_SUCCESS  Call this API successful.
+\retval ::GK_FAILURE  Call this API fails.
+
+\see \n
+N/A
+*/
+gk_s32 gk_api_cipher_hash_init(gk_cipher_hash_attr *hash_attr, gk_handle *hash_handle);
+
+/**
+\brief Calculate the hash, if the size of the data to be calculated is very big and the DDR ram is not enough,
+       this API can calculate the data one block by one block.
+       Attention: The input block length must be 64bytes aligned except for the last block.
+
+\attention \n
+N/A
+
+\param[in] hHashHandl:  Hash handle.
+\param[in] pu8InputData:  The input data buffer.
+\param[in] u32InputDataLen:  The input data length.
+                             Attention: the block length input must be 64bytes aligned except the last block!
+\retval ::GK_SUCCESS  Call this API successful.
+\retval ::GK_FAILURE  Call this API fails.
+
+\see \n
+N/A
+*/
+gk_s32 gk_api_cipher_hash_update(gk_handle hash_handle, gk_u8 *input_data, gk_u32 input_data_len);
+
+/**
+\brief Get the final hash value, after calculate all of the data,
+       call this API to get the final hash value and close the handle.
+       If there is some reason need to interrupt the calculation,
+       this API should also be call to close the handle.
+
+\attention \n
+N/A
+
+\param[in] hHashHandle:  Hash handle.
+\param[out] pu8OutputHash:  The final output hash value.
+
+\retval ::GK_SUCCESS  Call this API successful.
+\retval ::GK_FAILURE  Call this API fails.
+
+\see \n
+N/A
+*/
+gk_s32 gk_api_cipher_hash_final(gk_handle hash_handle, gk_u8 *output_hash);
+
+/*
+ * brief RSA encryption a plaintext with a RSA public key.
+ *
+ * attention \n
+ * N/A
+ *
+ * param[in]  rsa_encrypt:    encryption struct.
+ * param[in]  rsa_data:       rsa data struct.
+ * retval ::GK_SUCCESS        Call this API successful.
+ * retval ::GK_FAILURE        Call this API fails.
+ *
+ * see \n
+ * N/A
+ */
+gk_s32 gk_api_cipher_rsa_pub_encrypt(const gk_cipher_rsa_pub_encrypt *rsa_encrypt,
+                                     gk_cipher_rsa_crypt *rsa_data);
+
+/*
+ * brief RSA decryption a ciphertext with a RSA private key.
+ *
+ * attention \n
+ * N/A
+ *
+ * param[in]  rsa_decrypt:    decryption struct.
+ * param[in]  rsa_data:       rsa data struct.
+ * retval ::GK_SUCCESS        Call this API successful.
+ * retval ::GK_FAILURE        Call this API fails.
+ *
+ * see \n
+ * N/A
+ */
+gk_s32 gk_api_cipher_rsa_private_decrypt(const gk_cipher_rsa_private_encrypt *rsa_decrypt,
+                                         gk_cipher_rsa_crypt *rsa_data);
+
+/*
+ * brief RSA signature a context with appendix, where a signer's RSA private key is used.
+ *
+ * attention \n
+ * N/A
+ * param[in]  rsa_sign:       signature struct.
+ * param[in]  sign_data:      sign data struct.
+ * retval ::GK_SUCCESS        Call this API successful.
+ * retval ::GK_FAILURE        Call this API fails.
+ * see \n
+ * N/A
+ */
+gk_s32 gk_api_cipher_rsa_sign(const gk_cipher_rsa_sign *rsa_sign,
+                              gk_cipher_sign_data *sign_data);
+
+/*
+ * brief RSA signature verification a context with appendix, where a signer's RSA public key is used.
+ *
+ * attention \n
+ * N/A
+ *
+ * param[in] rsa_verify:      signature verification struct.
+ * param[in] verify_data:     verify data struct;
+ * retval ::GK_SUCCESS        Call this API successful.
+ * retval ::GK_FAILURE        Call this API fails.
+ *
+ * see \n
+ * N/A
+ */
+gk_s32 gk_api_cipher_rsa_verify(const gk_cipher_rsa_verify *rsa_verify,
+                                gk_cipher_verify_data *verify_data);
+
+/*
+ * brief RSA encryption a plaintext with a RSA private key.
+ *
+ * attention \n
+ * N/A
+ *
+ * param[in]  rsa_encrypt:    encryption struct.
+ * param[in]  rsa_data:       rsa data struct.
+ * retval ::GK_SUCCESS        Call this API successful.
+ * retval ::GK_FAILURE        Call this API fails.
+ *
+ * see \n
+ * N/A
+ */
+gk_s32 gk_api_cipher_rsa_private_encrypt(const gk_cipher_rsa_private_encrypt *rsa_encrypt,
+                                         gk_cipher_rsa_crypt *rsa_data);
+
+/*
+ * brief RSA decryption a ciphertext with a RSA public key.
+ *
+ * attention \n
+ * N/A
+ *
+ * param[in]  rsa_decrypt:    decryption struct.
+ * param[in]  rsa_data:       rsa data struct.
+ * retval ::GK_SUCCESS        Call this API successful.
+ * retval ::GK_FAILURE        Call this API fails.
+ *
+ * see \n
+ * N/A
+ */
+gk_s32 gk_api_cipher_rsa_pub_decrypt(const gk_cipher_rsa_pub_encrypt *rsa_decrypt,
+                                     gk_cipher_rsa_crypt *rsa_data);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __GK_CIPHER_H__ */
+
diff -uraN u-boot-2016.11/product/cipher/v2/api/ree_mpi_cipher.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/api/ree_mpi_cipher.c
--- u-boot-2016.11/product/cipher/v2/api/ree_mpi_cipher.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/api/ree_mpi_cipher.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,430 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "cipher_osal.h"
+
+#define CIPHER_MIN_CRYPT_LEN 8
+#define CIPHER_MAX_CRYPT_LEN 0xfffff
+
+#define gk_cipher_lock()
+#define gk_cipher_unlock()
+#define gk_hash_lock()
+#define gk_hash_unlock()
+
+gk_s32 g_cipher_dev_fd = -1;
+gk_s32 g_cipher_init_counter = -1;
+
+gk_s32 gk_api_cipher_init(gk_void)
+{
+    gk_cipher_lock();
+
+    if (g_cipher_init_counter > 0) {
+        g_cipher_init_counter++;
+        gk_cipher_unlock();
+        return GK_SUCCESS;
+    }
+
+    g_cipher_dev_fd = cipher_open("/dev/" UMAP_DEVNAME_CIPHER, O_RDWR, 0);
+    if (g_cipher_dev_fd < 0) {
+        gk_err_cipher("Open CIPHER err.\n");
+        gk_cipher_unlock();
+        return GK_ERR_CIPHER_FAILED_INIT;
+    }
+
+    g_cipher_init_counter = 1;
+    gk_cipher_unlock();
+
+    return GK_SUCCESS;
+}
+
+gk_s32 gk_api_cipher_deinit(gk_void)
+{
+    gk_cipher_lock();
+
+    check_cipher_not_open_return();
+
+    if (g_cipher_init_counter > 0)
+        g_cipher_init_counter--;
+
+    if (g_cipher_init_counter != 0) {
+        gk_cipher_unlock();
+        return GK_SUCCESS;
+    }
+
+    cipher_close(g_cipher_dev_fd);
+
+    g_cipher_init_counter = -1;
+
+    gk_cipher_unlock();
+
+    return GK_SUCCESS;
+}
+
+gk_s32 gk_api_cipher_create_handle(gk_handle *handle, const gk_cipher_attr *cipher_attr)
+{
+    gk_s32 ret;
+    cipher_handle_s ci_handle;
+
+    check_cipher_not_open_return();
+    inlet_var_is_null_return(handle);
+    inlet_var_is_null_return(cipher_attr);
+
+    crypto_memset(&ci_handle, sizeof(ci_handle), 0, sizeof(ci_handle));
+    crypto_memcpy(&ci_handle.cipher_atts, sizeof(ci_handle.cipher_atts),
+        cipher_attr, sizeof(gk_cipher_attr));
+    ret = cipher_ioctl(g_cipher_dev_fd, CMD_CIPHER_CREATEHANDLE, &ci_handle);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    *handle = ci_handle.ci_handle;
+
+    return ret;
+}
+
+gk_s32 gk_api_cipher_destroy_handle(gk_handle handle)
+{
+    check_cipher_not_open_return();
+    return cipher_ioctl(g_cipher_dev_fd, CMD_CIPHER_DESTROYHANDLE, &handle);
+}
+
+gk_s32 gk_api_cipher_config_handle(gk_handle handle, gk_cipher_ctrl *cipher_ctrl)
+{
+    cipher_config_ctrl_ex_s configdata;
+
+    check_cipher_not_open_return();
+    inlet_var_is_null_return(cipher_ctrl);
+
+    crypto_memset(&configdata, sizeof(configdata), 0, sizeof(cipher_config_ctrl_ex_s));
+
+    crypto_memcpy(&configdata.key, sizeof(configdata.key),
+        cipher_ctrl->key, sizeof(cipher_ctrl->key));
+    crypto_memcpy(&configdata.iv, sizeof(configdata.iv),
+        cipher_ctrl->iv, sizeof(cipher_ctrl->iv));
+    configdata.key_by_ca = cipher_ctrl->key_by_ca;
+    configdata.ca_type = cipher_ctrl->ca_type;
+    configdata.ci_alg = cipher_ctrl->alg;
+    configdata.bit_width = cipher_ctrl->bit_width;
+    configdata.work_mode = cipher_ctrl->work_mode;
+    configdata.key_len = cipher_ctrl->key_len;
+    configdata.change_flags = cipher_ctrl->chg_flags;
+    configdata.ci_handle = handle;
+
+    return cipher_ioctl(g_cipher_dev_fd, CMD_CIPHER_CONFIGHANDLE_EX, &configdata);
+}
+
+static gk_void mpi_cipher_config_aes(gk_cipher_ctrl_ex *ctrl_ex,
+                                     cipher_config_ctrl_ex_s *configdata)
+{
+    if ((ctrl_ex->work_mode == GK_CIPHER_WORK_MODE_CCM) ||
+        (ctrl_ex->work_mode == GK_CIPHER_WORK_MODE_GCM)) {
+        gk_cipher_ctrl_aes_ccm_gcm *aes_ccm_gcm_ctrl =
+            (gk_cipher_ctrl_aes_ccm_gcm *)ctrl_ex->param;
+
+        crypto_memcpy(&configdata->key, sizeof(configdata->key),
+            aes_ccm_gcm_ctrl->key, sizeof(aes_ccm_gcm_ctrl->key));
+        crypto_memcpy(&configdata->iv, sizeof(configdata->iv),
+            aes_ccm_gcm_ctrl->iv, sizeof(aes_ccm_gcm_ctrl->iv));
+
+        configdata->bit_width = GK_CIPHER_BIT_WIDTH_128BIT;
+        configdata->key_len = aes_ccm_gcm_ctrl->key_len;
+        configdata->iv_len = aes_ccm_gcm_ctrl->iv_len;
+        configdata->tag_len = aes_ccm_gcm_ctrl->tag_len;
+        configdata->aphy_addr = aes_ccm_gcm_ctrl->aad_phys_addr;
+        configdata->aphy_addr_high = get_ulong_high(aes_ccm_gcm_ctrl->aad_phy_addr);
+        configdata->alen = aes_ccm_gcm_ctrl->aad_len;
+        configdata->change_flags.bits_iv = 1;
+    } else {
+        gk_cipher_ctrl_aes *aes_ctrl = (gk_cipher_ctrl_aes *)ctrl_ex->param;
+
+        crypto_memcpy(&configdata->key, sizeof(configdata->key),
+            aes_ctrl->even_key, sizeof(aes_ctrl->even_key));
+        crypto_memcpy(&configdata->odd_key, sizeof(configdata->odd_key),
+            aes_ctrl->odd_key, sizeof(aes_ctrl->odd_key));
+        crypto_memcpy(&configdata->iv, sizeof(configdata->iv),
+            aes_ctrl->iv, sizeof(aes_ctrl->iv));
+
+        configdata->bit_width = aes_ctrl->bit_width;
+        configdata->key_len = aes_ctrl->key_len;
+        configdata->change_flags = aes_ctrl->chg_flags;
+        configdata->iv_len = 16; /* 16 - aes iv len */
+    }
+}
+
+static gk_void mpi_cipher_config_sm1(gk_cipher_ctrl_ex *ctrl_ex,
+                                     cipher_config_ctrl_ex_s *configdata)
+{
+    gk_cipher_ctrl_sm1 *sm1_ctrl = (gk_cipher_ctrl_sm1 *)ctrl_ex->param;
+
+    crypto_memcpy(&configdata->key[0], sizeof(sm1_ctrl->ek),
+        sm1_ctrl->ek, sizeof(sm1_ctrl->ek));
+    crypto_memcpy(&configdata->key[4], sizeof(sm1_ctrl->ak), /* 4 - sm1 ak index */
+        sm1_ctrl->ak, sizeof(sm1_ctrl->ak));
+    crypto_memcpy(&configdata->key[8], sizeof(sm1_ctrl->sk), /* 8 - sm1 sk index */
+        sm1_ctrl->sk, sizeof(sm1_ctrl->sk));
+    crypto_memcpy(&configdata->iv, sizeof(configdata->iv),
+        sm1_ctrl->iv, sizeof(sm1_ctrl->iv));
+
+    configdata->sm1_round = sm1_ctrl->sm1_round;
+    configdata->key_len = GK_CIPHER_KEY_DEFAULT;
+    configdata->change_flags = sm1_ctrl->chg_flags;
+    configdata->bit_width = sm1_ctrl->bit_width;
+    configdata->iv_len = 16; /* 16 - sm1 iv len */
+}
+
+static gk_void mpi_cipher_config_sm4(gk_cipher_ctrl_ex *ctrl_ex,
+                                     cipher_config_ctrl_ex_s *configdata)
+{
+    gk_cipher_ctrl_sm4 *sm4_ctrl = (gk_cipher_ctrl_sm4 *)ctrl_ex->param;
+
+    crypto_memcpy(&configdata->key, sizeof(configdata->key),
+        sm4_ctrl->key, sizeof(sm4_ctrl->key));
+    crypto_memcpy(&configdata->iv, sizeof(configdata->iv),
+        sm4_ctrl->iv, sizeof(sm4_ctrl->iv));
+
+    configdata->key_len = GK_CIPHER_KEY_DEFAULT;
+    configdata->change_flags = sm4_ctrl->chg_flags;
+    configdata->bit_width = GK_CIPHER_BIT_WIDTH_128BIT;
+    configdata->iv_len = 16; /* 16 - sm4 iv len */
+}
+
+gk_s32 gk_api_cipher_config_handle_ex(gk_handle handle, gk_cipher_ctrl_ex *ctrl_ex)
+{
+    cipher_config_ctrl_ex_s configdata;
+
+    check_cipher_not_open_return();
+    inlet_var_is_null_return(ctrl_ex);
+
+    if ((ctrl_ex->alg != GK_CIPHER_ALG_DMA) && (ctrl_ex->param == NULL)) {
+        gk_err_cipher("para ctrl_ex param is invalid.\n");
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    crypto_memset(&configdata, sizeof(configdata), 0, sizeof(cipher_config_ctrl_ex_s));
+    configdata.ci_handle = handle;
+    configdata.ci_alg = ctrl_ex->alg;
+    configdata.work_mode = ctrl_ex->work_mode;
+    configdata.key_by_ca = ctrl_ex->key_by_ca;
+
+    /* ****************************************************************************
+     * for AES, the pointer should point to gk_cipher_ctrl_aes;
+     * for AES_CCM or AES_GCM, the pointer should point to gk_cipher_ctrl_aes_ccm_gcm;
+     * for DES, the pointer should point to GK_CIPHER_CTRL_DES_S;
+     * for 3DES, the pointer should point to GK_CIPHER_CTRL_3DES_S;
+     * for SM1, the pointer should point to gk_cipher_ctrl_sm1;
+     * for SM4, the pointer should point to gk_cipher_ctrl_sm4;
+     */
+    switch (ctrl_ex->alg) {
+        case GK_CIPHER_ALG_AES:
+            mpi_cipher_config_aes(ctrl_ex, &configdata);
+            break;
+        case GK_CIPHER_ALG_SM1:
+            mpi_cipher_config_sm1(ctrl_ex, &configdata);
+            break;
+        case GK_CIPHER_ALG_SM4:
+            mpi_cipher_config_sm4(ctrl_ex, &configdata);
+            break;
+        case GK_CIPHER_ALG_DMA:
+            break;
+        default:
+            gk_err_cipher("para set CIPHER alg is invalid.\n");
+            return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    return cipher_ioctl(g_cipher_dev_fd, CMD_CIPHER_CONFIGHANDLE_EX, &configdata);
+}
+
+gk_s32 gk_api_cipher_encrypt(gk_handle handle, gk_size_t src_phy_addr, gk_size_t dest_phy_addr, gk_u32 byte_len)
+{
+    cipher_data_s ci_data;
+
+    check_cipher_not_open_return();
+    ci_data.src_phy_addr = get_ulong_low(src_phy_addr);
+    ci_data.src_phy_addr_high = get_ulong_high(src_phy_addr);
+    ci_data.dest_phy_addr = get_ulong_low(dest_phy_addr);
+    ci_data.dest_phy_addr_high = get_ulong_high(dest_phy_addr);
+
+    ci_data.data_length = byte_len;
+    ci_data.ci_handle = handle;
+
+    return cipher_ioctl(g_cipher_dev_fd, CMD_CIPHER_ENCRYPT, &ci_data);
+}
+
+gk_s32 gk_api_cipher_decrypt(gk_handle handle, gk_size_t src_phy_addr, gk_size_t dest_phy_addr, gk_u32 byte_len)
+{
+    cipher_data_s ci_data;
+
+    check_cipher_not_open_return();
+
+    ci_data.src_phy_addr = get_ulong_low(src_phy_addr);
+    ci_data.src_phy_addr_high = get_ulong_high(src_phy_addr);
+    ci_data.dest_phy_addr = get_ulong_low(dest_phy_addr);
+    ci_data.dest_phy_addr_high = get_ulong_high(dest_phy_addr);
+    ci_data.data_length = byte_len;
+    ci_data.ci_handle = handle;
+
+    return cipher_ioctl(g_cipher_dev_fd, CMD_CIPHER_DECRYPT, &ci_data);
+}
+
+gk_s32 gk_api_cipher_encrypt_multi_pack(gk_handle handle, gk_cipher_data *data_pkg, gk_u32 data_pkg_num)
+{
+    cipher_pkg_s ci_pkg;
+    gk_cipher_data *ci_data = NULL;
+    gk_u32 len;
+    gk_s32 ret;
+
+    check_cipher_not_open_return();
+    inlet_var_is_null_return(data_pkg);
+    inlet_var_is_zero_return(data_pkg_num);
+    inlet_var_over_max_return(data_pkg_num, MAX_MULTI_PKG_NUM);
+
+    len = sizeof(gk_cipher_data) * data_pkg_num;
+    ci_data = cipher_malloc(len);
+    if (ci_data == GK_NULL) {
+        gk_err_cipher("Error, malloc pkg buffer failed\n");
+        return GK_FAILURE;
+    }
+    crypto_memcpy(ci_data, len, data_pkg, len);
+
+    ci_pkg.ci_handle = handle;
+    ci_pkg.cipher_data = ci_data;
+    ci_pkg.pkg_num = data_pkg_num;
+    ci_pkg.user_bit_width = sizeof(gk_size_t);
+    ret = cipher_ioctl(g_cipher_dev_fd, CMD_CIPHER_ENCRYPTMULTI, &ci_pkg);
+
+    cipher_free(ci_data);
+    ci_data = GK_NULL;
+
+    return ret;
+}
+
+gk_s32 gk_api_cipher_decrypt_multi_pack(gk_handle handle, gk_cipher_data *data_pkg, gk_u32 data_pkg_num)
+{
+    cipher_pkg_s ci_pkg;
+    gk_cipher_data *ci_data = NULL;
+    gk_u32 len;
+    gk_s32 ret;
+
+    check_cipher_not_open_return();
+    inlet_var_is_null_return(data_pkg);
+    inlet_var_is_zero_return(data_pkg_num);
+    inlet_var_over_max_return(data_pkg_num, MAX_MULTI_PKG_NUM);
+
+    len = sizeof(gk_cipher_data) * data_pkg_num;
+    ci_data = cipher_malloc(len);
+    if (ci_data == GK_NULL) {
+        gk_err_cipher("Error, malloc pkg buffer failed\n");
+        return GK_FAILURE;
+    }
+    crypto_memcpy(ci_data, len, data_pkg, len);
+
+    ci_pkg.ci_handle = handle;
+    ci_pkg.cipher_data = ci_data;
+    ci_pkg.pkg_num = data_pkg_num;
+    ci_pkg.user_bit_width = sizeof(gk_size_t);
+
+    ret = cipher_ioctl(g_cipher_dev_fd, CMD_CIPHER_DECRYPTMULTI, &ci_pkg);
+
+    cipher_free(ci_data);
+    ci_data = GK_NULL;
+
+    return ret;
+}
+
+gk_s32 gk_api_cipher_get_handle_cfg(gk_handle handle, gk_cipher_ctrl *cipher_ctrl)
+{
+    gk_s32 ret;
+    cipher_config_ctrl_ex_s configdata;
+
+    check_cipher_not_open_return();
+    inlet_var_is_null_return(cipher_ctrl);
+
+    crypto_memset(&configdata, sizeof(configdata), 0, sizeof(cipher_config_ctrl_ex_s));
+    configdata.ci_handle = handle;
+    ret = cipher_ioctl(g_cipher_dev_fd, CMD_CIPHER_GETHANDLECONFIG_EX, &configdata);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    crypto_memcpy(cipher_ctrl->key, sizeof(cipher_ctrl->key),
+        &configdata.key, sizeof(cipher_ctrl->key));
+    crypto_memcpy(cipher_ctrl->iv, sizeof(cipher_ctrl->iv),
+        &configdata.iv, sizeof(configdata.iv));
+
+    cipher_ctrl->key_by_ca = configdata.key_by_ca;
+    cipher_ctrl->ca_type = configdata.ca_type;
+    cipher_ctrl->alg = configdata.ci_alg;
+    cipher_ctrl->bit_width = configdata.bit_width;
+    cipher_ctrl->work_mode = configdata.work_mode;
+    cipher_ctrl->key_len = configdata.key_len;
+    cipher_ctrl->chg_flags = configdata.change_flags;
+
+    return GK_SUCCESS;
+}
+
+#ifdef CIPHER_KLAD_SUPPORT
+gk_s32 gk_api_cipher_klad_encrypt_key(gk_cipher_ca_type root_key,
+                                      gk_cipher_klad_target klad_target,
+                                      gk_u8 *clean_key,
+                                      gk_u8 *enc_key,
+                                      gk_u32 key_len)
+{
+    gk_s32 ret = GK_SUCCESS;
+    cipher_klad_key_s ci_klad;
+    gk_u32 i;
+
+    check_cipher_not_open_return();
+    memset(&ci_klad, 0, sizeof(cipher_klad_key_s));
+
+    if ((clean_key == GK_NULL) || (enc_key == GK_NULL)) {
+        gk_err_cipher("invalid para.\n");
+        return GK_FAILURE;
+    }
+
+    if ((key_len == 0) || (key_len % 16 != 0)) { /* key_len must multiples of 16 */
+        gk_err_cipher("invalid key len 0x%x.\n", key_len);
+        return GK_FAILURE;
+    }
+
+    if ((root_key >= GK_CIPHER_KEY_SRC_BUTT) || (klad_target >= GK_CIPHER_KLAD_TARGET_BUTT)) {
+        gk_err_cipher("invalid para.\n");
+        return GK_FAILURE;
+    }
+
+    ci_klad.root_key = root_key;
+    ci_klad.klad_target = klad_target;
+
+    for (i = 0; i < key_len / 16; i++) { /* 16 groups */
+        memcpy(ci_klad.clean_key, clean_key + i * 16, 16); /* 16 groups */
+        ret = cipher_ioctl(g_cipher_dev_fd, CMD_CIPHER_KLAD_KEY, &ci_klad);
+        if (ret != GK_SUCCESS) {
+            return ret;
+        }
+        memcpy(enc_key + i * 16, ci_klad.encrypt_key, 16); /* 16 groups */
+    }
+
+    return ret;
+}
+#endif
+
+gk_s32 gk_api_cipher_get_tag(gk_handle handle, gk_u8 *tag, gk_u32 *tag_len)
+{
+    cipher_tag_s ci_tag;
+    gk_s32 ret;
+
+    check_cipher_not_open_return();
+    inlet_var_is_null_return(tag);
+    inlet_var_is_null_return(tag_len);
+
+    crypto_memset(&ci_tag, sizeof(cipher_tag_s), 0, sizeof(cipher_tag_s));
+    ci_tag.ci_handle = handle;
+    ret = cipher_ioctl(g_cipher_dev_fd, CMD_CIPHER_GETTAG, &ci_tag);
+    if (ret == GK_SUCCESS) {
+        inlet_var_over_max_return(ci_tag.tag_len, *tag_len);
+        crypto_memcpy(tag, *tag_len, ci_tag.tag, ci_tag.tag_len);
+        *tag_len = ci_tag.tag_len;
+    }
+
+    return ret;
+}
diff -uraN u-boot-2016.11/product/cipher/v2/api/ree_mpi_hash.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/api/ree_mpi_hash.c
--- u-boot-2016.11/product/cipher/v2/api/ree_mpi_hash.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/api/ree_mpi_hash.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,784 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "cipher_osal.h"
+
+#define HASH_MAX_BLOCK_SIZE     256
+#define SHA1_RESULT_SIZE        20
+#define SHA224_RESULT_SIZE      28
+#define SHA256_RESULT_SIZE      32
+#define SHA384_RESULT_SIZE      48
+#define SHA512_RESULT_SIZE      64
+
+#define SPACC_HASH_CHN          1
+#define HASH_CHANNAL_MAX_NUM    8
+
+#define SHA1_H0                 0x67452301
+#define SHA1_H1                 0xefcdab89
+#define SHA1_H2                 0x98badcfe
+#define SHA1_H3                 0x10325476
+#define SHA1_H4                 0xc3d2e1f0
+
+#define SHA224_H0               0xc1059ed8
+#define SHA224_H1               0x367cd507
+#define SHA224_H2               0x3070dd17
+#define SHA224_H3               0xf70e5939
+#define SHA224_H4               0xffc00b31
+#define SHA224_H5               0x68581511
+#define SHA224_H6               0x64f98fa7
+#define SHA224_H7               0xbefa4fa4
+
+#define SHA256_H0               0x6a09e667
+#define SHA256_H1               0xbb67ae85
+#define SHA256_H2               0x3c6ef372
+#define SHA256_H3               0xa54ff53a
+#define SHA256_H4               0x510e527f
+#define SHA256_H5               0x9b05688c
+#define SHA256_H6               0x1f83d9ab
+#define SHA256_H7               0x5be0cd19
+
+#define SHA384_H0               0xcbbb9d5dc1059ed8ULL
+#define SHA384_H1               0x629a292a367cd507ULL
+#define SHA384_H2               0x9159015a3070dd17ULL
+#define SHA384_H3               0x152fecd8f70e5939ULL
+#define SHA384_H4               0x67332667ffc00b31ULL
+#define SHA384_H5               0x8eb44a8768581511ULL
+#define SHA384_H6               0xdb0c2e0d64f98fa7ULL
+#define SHA384_H7               0x47b5481dbefa4fa4ULL
+
+#define SHA512_H0               0x6a09e667f3bcc908ULL
+#define SHA512_H1               0xbb67ae8584caa73bULL
+#define SHA512_H2               0x3c6ef372fe94f82bULL
+#define SHA512_H3               0xa54ff53a5f1d36f1ULL
+#define SHA512_H4               0x510e527fade682d1ULL
+#define SHA512_H5               0x9b05688c2b3e6c1fULL
+#define SHA512_H6               0x1f83d9abfb41bd6bULL
+#define SHA512_H7               0x5be0cd19137e2179ULL
+
+#define SM3_H0                  0x7380166F
+#define SM3_H1                  0x4914B2B9
+#define SM3_H2                  0x172442D7
+#define SM3_H3                  0xDA8A0600
+#define SM3_H4                  0xA96F30BC
+#define SM3_H5                  0x163138AA
+#define SM3_H6                  0xE38DEE4D
+#define SM3_H7                  0xB0FB0E4E
+
+
+typedef struct {
+    gk_handle handle;
+    gk_cipher_hash_type sha_type;
+
+    gk_u8 is_used;
+    gk_u8 block_size;
+    gk_u8 sha_len;
+    gk_u8 last_block_size;
+
+    gk_u32 total_data_len;
+    gk_u32 sha_val[HASH_RESULT_MAX_LEN_IN_WORD];
+    gk_u8 last_block[HASH_MAX_BLOCK_SIZE];
+    gk_u8 mac[HASH_MAX_BLOCK_SIZE];
+} hash_info_s;
+
+#define GK_ID_HASH              101
+static hash_info_s g_cipher_hash_data[HASH_CHANNAL_MAX_NUM];
+
+static gk_s32 hash_check_handle(gk_handle hash_handle)
+{
+    if ((handle_get_mod_id(hash_handle)) != GK_ID_HASH ||
+        (handle_get_pri_data(hash_handle) != 0)) {
+        gk_err_cipher("invalid cipher handle 0x%x\n", hash_handle);
+        return GK_ERR_CIPHER_INVALID_HANDLE;
+    }
+
+    if (handle_get_chn_id(hash_handle) >= HASH_CHANNAL_MAX_NUM) {
+        gk_err_cipher("chan %d is too large, max: %d\n",
+            handle_get_chn_id(hash_handle), HASH_CHANNAL_MAX_NUM);
+        return GK_ERR_CIPHER_INVALID_HANDLE;
+    }
+
+    if (g_cipher_hash_data[handle_get_chn_id(hash_handle)].is_used == GK_FALSE) {
+        gk_err_cipher("chan %d is not open\n", handle_get_chn_id(hash_handle));
+        return GK_ERR_CIPHER_INVALID_HANDLE;
+    }
+    return GK_SUCCESS;
+}
+
+static gk_u32 hash_msg_padding(gk_u8 *msg, gk_u32 byte_len, gk_u32 total_len, gk_u32 block_size)
+{
+    gk_u32 tmp;
+    gk_u32 padding_len;
+
+    if (block_size == 0) {
+        gk_err_cipher("Bloc size is zero !\n");
+        return GK_FAILURE;
+    }
+
+    tmp = total_len % block_size;
+    if (block_size == 64) { /* 64 block size */
+        padding_len = (tmp < 56) ? (56 - tmp) : (120 - tmp); /* 56, 120 */
+        padding_len += 8; /* 8 padding len */
+    } else {
+        padding_len = (tmp < 112) ? (112 - tmp) : (240 - tmp); /* 112, 240 */
+        padding_len += 16; /* 16 padding len */
+    }
+
+    /* Format(binary): {data|1000...00| fix_data_len(bits)} */
+    msg[byte_len++] = 0x80;
+    crypto_memset(&msg[byte_len], HASH_BLOCK_SIZE * 2, 0, padding_len - 1 - 8); /* 2, 8 */
+    byte_len += padding_len - 1 - 8; /* 8 */
+
+    /* write 8 bytes fix data length */
+    msg[byte_len++] = 0x00;
+    msg[byte_len++] = 0x00;
+    msg[byte_len++] = 0x00;
+    msg[byte_len++] = (gk_u8)((total_len >> 29) & 0x07); /* 29 right shift */
+    msg[byte_len++] = (gk_u8)((total_len >> 21) & 0xff); /* 21 right shift */
+    msg[byte_len++] = (gk_u8)((total_len >> 13) & 0xff); /* 13 right shift */
+    msg[byte_len++] = (gk_u8)((total_len >> 5) & 0xff);  /* 5  right shift */
+    msg[byte_len++] = (gk_u8)((total_len << 3) & 0xff);  /* 3  right shift */
+
+    return byte_len;
+}
+
+static gk_void hash_config_info_sha1(cipher_hash_data_s *hash_data, hash_info_s *hash_info)
+{
+    hash_data->sha_type = GK_CIPHER_HASH_TYPE_SHA1;
+    hash_info->sha_len = SHA1_RESULT_SIZE;
+    hash_info->block_size = 64; /* 64 sha1 block size */
+    hash_info->sha_val[0] = cipher_cpu_to_be32(SHA1_H0); /* 0 sha1 index */
+    hash_info->sha_val[1] = cipher_cpu_to_be32(SHA1_H1); /* 1 sha1 index */
+    hash_info->sha_val[2] = cipher_cpu_to_be32(SHA1_H2); /* 2 sha1 index */
+    hash_info->sha_val[3] = cipher_cpu_to_be32(SHA1_H3); /* 3 sha1 index */
+    hash_info->sha_val[4] = cipher_cpu_to_be32(SHA1_H4); /* 4 sha1 index */
+}
+
+static gk_void hash_config_info_sha224(cipher_hash_data_s *hash_data, hash_info_s *hash_info)
+{
+    hash_data->sha_type = GK_CIPHER_HASH_TYPE_SHA224;
+    hash_info->sha_len = SHA224_RESULT_SIZE;
+    hash_info->block_size = 64; /* 64 sha224 block size */
+    hash_info->sha_val[0] = cipher_cpu_to_be32(SHA224_H0); /* 0 sha224 index */
+    hash_info->sha_val[1] = cipher_cpu_to_be32(SHA224_H1); /* 1 sha224 index */
+    hash_info->sha_val[2] = cipher_cpu_to_be32(SHA224_H2); /* 2 sha224 index */
+    hash_info->sha_val[3] = cipher_cpu_to_be32(SHA224_H3); /* 3 sha224 index */
+    hash_info->sha_val[4] = cipher_cpu_to_be32(SHA224_H4); /* 4 sha224 index */
+    hash_info->sha_val[5] = cipher_cpu_to_be32(SHA224_H5); /* 5 sha224 index */
+    hash_info->sha_val[6] = cipher_cpu_to_be32(SHA224_H6); /* 6 sha224 index */
+    hash_info->sha_val[7] = cipher_cpu_to_be32(SHA224_H7); /* 7 sha224 index */
+}
+
+static gk_void hash_config_info_sha256(cipher_hash_data_s *hash_data, hash_info_s *hash_info)
+{
+    hash_data->sha_type = GK_CIPHER_HASH_TYPE_SHA256;
+    hash_info->sha_len = SHA256_RESULT_SIZE;
+    hash_info->block_size = 64; /* 64 sha256 block size */
+    hash_info->sha_val[0] = cipher_cpu_to_be32(SHA256_H0); /* 0 sha256 index */
+    hash_info->sha_val[1] = cipher_cpu_to_be32(SHA256_H1); /* 1 sha256 index */
+    hash_info->sha_val[2] = cipher_cpu_to_be32(SHA256_H2); /* 2 sha256 index */
+    hash_info->sha_val[3] = cipher_cpu_to_be32(SHA256_H3); /* 3 sha256 index */
+    hash_info->sha_val[4] = cipher_cpu_to_be32(SHA256_H4); /* 4 sha256 index */
+    hash_info->sha_val[5] = cipher_cpu_to_be32(SHA256_H5); /* 5 sha256 index */
+    hash_info->sha_val[6] = cipher_cpu_to_be32(SHA256_H6); /* 6 sha256 index */
+    hash_info->sha_val[7] = cipher_cpu_to_be32(SHA256_H7); /* 7 sha256 index */
+}
+
+static gk_void hash_config_info_sha384(cipher_hash_data_s *hash_data, hash_info_s *hash_info)
+{
+    gk_u64 hash_h;
+
+    hash_data->sha_type = GK_CIPHER_HASH_TYPE_SHA384;
+    hash_info->sha_len = SHA384_RESULT_SIZE;
+    hash_info->block_size = 128; /* 128 sha384 block size */
+    hash_h = cipher_cpu_to_be64(SHA384_H0);
+    crypto_memcpy(&hash_info->sha_val[0], sizeof(gk_u64), &hash_h, sizeof(gk_u64));  /* 0  sha384 index */
+    hash_h = cipher_cpu_to_be64(SHA384_H1);
+    crypto_memcpy(&hash_info->sha_val[2], sizeof(gk_u64), &hash_h, sizeof(gk_u64));  /* 2  sha384 index */
+    hash_h = cipher_cpu_to_be64(SHA384_H2);
+    crypto_memcpy(&hash_info->sha_val[4], sizeof(gk_u64), &hash_h, sizeof(gk_u64));  /* 4  sha384 index */
+    hash_h = cipher_cpu_to_be64(SHA384_H3);
+    crypto_memcpy(&hash_info->sha_val[6], sizeof(gk_u64), &hash_h, sizeof(gk_u64));  /* 6  sha384 index */
+    hash_h = cipher_cpu_to_be64(SHA384_H4);
+    crypto_memcpy(&hash_info->sha_val[8], sizeof(gk_u64), &hash_h, sizeof(gk_u64));  /* 8  sha384 index */
+    hash_h = cipher_cpu_to_be64(SHA384_H5);
+    crypto_memcpy(&hash_info->sha_val[10], sizeof(gk_u64), &hash_h, sizeof(gk_u64)); /* 10 sha384 index */
+    hash_h = cipher_cpu_to_be64(SHA384_H6);
+    crypto_memcpy(&hash_info->sha_val[12], sizeof(gk_u64), &hash_h, sizeof(gk_u64)); /* 12 sha384 index */
+    hash_h = cipher_cpu_to_be64(SHA384_H7);
+    crypto_memcpy(&hash_info->sha_val[14], sizeof(gk_u64), &hash_h, sizeof(gk_u64)); /* 14 sha384 index */
+}
+
+static gk_void hash_config_info_sha512(cipher_hash_data_s *hash_data, hash_info_s *hash_info)
+{
+    gk_u64 hash_h;
+
+    hash_data->sha_type = GK_CIPHER_HASH_TYPE_SHA512;
+    hash_info->sha_len = SHA512_RESULT_SIZE;
+    hash_info->block_size = 128; /* 128 sha384 block size */
+    hash_h = cipher_cpu_to_be64(SHA512_H0);
+    crypto_memcpy(&hash_info->sha_val[0], sizeof(gk_u64), &hash_h, sizeof(gk_u64));  /* 0  sha384 index */
+    hash_h = cipher_cpu_to_be64(SHA512_H1);
+    crypto_memcpy(&hash_info->sha_val[2], sizeof(gk_u64), &hash_h, sizeof(gk_u64));  /* 2  sha384 index */
+    hash_h = cipher_cpu_to_be64(SHA512_H2);
+    crypto_memcpy(&hash_info->sha_val[4], sizeof(gk_u64), &hash_h, sizeof(gk_u64));  /* 4  sha384 index */
+    hash_h = cipher_cpu_to_be64(SHA512_H3);
+    crypto_memcpy(&hash_info->sha_val[6], sizeof(gk_u64), &hash_h, sizeof(gk_u64));  /* 6  sha384 index */
+    hash_h = cipher_cpu_to_be64(SHA512_H4);
+    crypto_memcpy(&hash_info->sha_val[8], sizeof(gk_u64), &hash_h, sizeof(gk_u64));  /* 8  sha384 index */
+    hash_h = cipher_cpu_to_be64(SHA512_H5);
+    crypto_memcpy(&hash_info->sha_val[10], sizeof(gk_u64), &hash_h, sizeof(gk_u64)); /* 10 sha384 index */
+    hash_h = cipher_cpu_to_be64(SHA512_H6);
+    crypto_memcpy(&hash_info->sha_val[12], sizeof(gk_u64), &hash_h, sizeof(gk_u64)); /* 12 sha384 index */
+    hash_h = cipher_cpu_to_be64(SHA512_H7);
+    crypto_memcpy(&hash_info->sha_val[14], sizeof(gk_u64), &hash_h, sizeof(gk_u64)); /* 14 sha384 index */
+}
+
+static gk_void hash_config_info_sm3(cipher_hash_data_s *hash_data, hash_info_s *hash_info)
+{
+    hash_data->sha_type = GK_CIPHER_HASH_TYPE_SM3;
+    hash_info->sha_len = SHA256_RESULT_SIZE;
+    hash_info->block_size = 64; /* 64 sm3 block size */
+    hash_info->sha_val[0] = cipher_cpu_to_be32(SM3_H0); /* 0 sm3 index */
+    hash_info->sha_val[1] = cipher_cpu_to_be32(SM3_H1); /* 1 sm3 index */
+    hash_info->sha_val[2] = cipher_cpu_to_be32(SM3_H2); /* 2 sm3 index */
+    hash_info->sha_val[3] = cipher_cpu_to_be32(SM3_H3); /* 3 sm3 index */
+    hash_info->sha_val[4] = cipher_cpu_to_be32(SM3_H4); /* 4 sm3 index */
+    hash_info->sha_val[5] = cipher_cpu_to_be32(SM3_H5); /* 5 sm3 index */
+    hash_info->sha_val[6] = cipher_cpu_to_be32(SM3_H6); /* 6 sm3 index */
+    hash_info->sha_val[7] = cipher_cpu_to_be32(SM3_H7); /* 7 sm3 index */
+}
+
+static gk_s32 hash_config_info(gk_cipher_hash_type sha_type,
+    cipher_hash_data_s *hash_data, hash_info_s *hash_info)
+{
+    switch (sha_type) {
+        case GK_CIPHER_HASH_TYPE_SHA1:
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA1:
+            hash_config_info_sha1(hash_data, hash_info);
+            break;
+        case GK_CIPHER_HASH_TYPE_SHA224:
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA224:
+            hash_config_info_sha224(hash_data, hash_info);
+            break;
+        case GK_CIPHER_HASH_TYPE_SHA256:
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA256:
+            hash_config_info_sha256(hash_data, hash_info);
+            break;
+        case GK_CIPHER_HASH_TYPE_SHA384:
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA384:
+            hash_config_info_sha384(hash_data, hash_info);
+            break;
+        case GK_CIPHER_HASH_TYPE_SHA512:
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA512:
+            hash_config_info_sha512(hash_data, hash_info);
+            break;
+        case GK_CIPHER_HASH_TYPE_SM3:
+            hash_config_info_sm3(hash_data, hash_info);
+            break;
+        default:
+            gk_err_cipher("Invaid sha type %d\n", sha_type);
+            return GK_FAILURE;
+    }
+    return GK_SUCCESS;
+}
+
+static gk_s32 cipher_hash_init(gk_cipher_hash_attr *hash_attr, gk_handle *hash_handle)
+{
+    gk_s32 ret;
+    cipher_hash_data_s hash_data;
+    gk_u32 soft_id;
+    hash_info_s *hash_info = NULL;
+
+    for (soft_id = 0; soft_id < HASH_CHANNAL_MAX_NUM; soft_id++) {
+        if (!g_cipher_hash_data[soft_id].is_used)
+            break;
+    }
+
+    if (soft_id >= HASH_CHANNAL_MAX_NUM) {
+        gk_err_cipher("Hash module is busy!\n");
+        return GK_FAILURE;
+    }
+
+    hash_info = &g_cipher_hash_data[soft_id];
+    crypto_memset(hash_info, sizeof(hash_info_s), 0, sizeof(hash_info_s));
+    crypto_memset(&hash_data, sizeof(hash_data), 0, sizeof(cipher_hash_data_s));
+    hash_info->sha_type = hash_attr->sha_type;
+    hash_data.hard_chn = SPACC_HASH_CHN;
+    ret = hash_config_info(hash_info->sha_type, &hash_data, hash_info);
+    if (ret != GK_SUCCESS)
+        return ret;
+
+    ret = cipher_ioctl(g_cipher_dev_fd, CMD_CIPHER_CALCHASHINIT, &hash_data);
+    if (ret == GK_SUCCESS) {
+        hash_info->is_used = GK_TRUE;
+        *hash_handle = gk_handle_make_handle(GK_ID_HASH, 0, soft_id);
+    }
+
+    return ret;
+}
+
+static gk_s32 cipher_hash_update_block(hash_info_s *hash_info, gk_u8 *input_data, gk_u32 input_data_len)
+{
+    gk_s32 ret;
+    cipher_hash_data_s hash_data;
+
+    crypto_memset(&hash_data, sizeof(hash_data), 0, sizeof(hash_data));
+    hash_data.sha_type = hash_info->sha_type;
+    hash_data.hard_chn = SPACC_HASH_CHN;
+    crypto_memcpy(&hash_data.sha_val, sizeof(hash_data.sha_val), hash_info->sha_val, sizeof(hash_info->sha_val));
+
+    hash_data.data_len = input_data_len;
+    hash_data.data_phy = get_ulong_low((gk_size_t)(uintptr_t)input_data);
+    hash_data.data_phy_high = get_ulong_high((gk_size_t)(uintptr_t)input_data);
+    ret = cipher_ioctl(g_cipher_dev_fd, CMD_CIPHER_CALCHASHUPDATE, &hash_data);
+    if (ret != GK_SUCCESS) {
+        gk_err_cipher("Error, ioctl for hash update failed!\n");
+        hash_info->is_used = GK_FALSE;
+        return ret;
+    }
+
+    crypto_memcpy(hash_info->sha_val, sizeof(hash_info->sha_val), &hash_data.sha_val, sizeof(hash_data.sha_val));
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 cipher_hash_updata_tail(hash_info_s *hash_info,
+    gk_u8 *data_phy, gk_u8 *input_data, gk_u32 input_data_len)
+{
+    gk_s32 ret = GK_SUCCESS;
+
+    /* process the tail of last update */
+    if (hash_info->last_block_size > 0) {
+        crypto_memcpy(hash_info->last_block + hash_info->last_block_size, HASH_BLOCK_SIZE,
+            input_data, hash_info->block_size - hash_info->last_block_size);
+        crypto_memcpy(data_phy, hash_info->block_size, hash_info->last_block, hash_info->block_size);
+        ret = cipher_hash_update_block(hash_info, data_phy, hash_info->block_size);
+        if (ret != GK_SUCCESS) {
+            gk_err_cipher("Error, ioctl for hash update failed!\n");
+            return ret;
+        }
+        input_data_len -= hash_info->block_size - hash_info->last_block_size;
+        input_data += hash_info->block_size - hash_info->last_block_size;
+    }
+
+    if (input_data_len >= hash_info->block_size) {
+        gk_u32 size;
+        size = input_data_len - (input_data_len % hash_info->block_size);
+        ret = cipher_hash_update_block(hash_info, input_data, size);
+        if (ret != GK_SUCCESS) {
+            gk_err_cipher("Error, ioctl for hash update failed!\n");
+            return ret;
+        }
+        input_data_len -= size;
+        input_data += size;
+    }
+
+    /* save tail data */
+    crypto_memset(hash_info->last_block, HASH_MAX_BLOCK_SIZE, 0, HASH_MAX_BLOCK_SIZE);
+    hash_info->last_block_size = input_data_len;
+    crypto_memcpy(hash_info->last_block, HASH_BLOCK_SIZE, input_data, input_data_len);
+
+    return ret;
+}
+
+static gk_s32 cipher_hash_update(gk_handle ci_hash_id, gk_u8 *input_data, gk_u32 input_data_len)
+{
+    gk_s32 ret = GK_SUCCESS;
+    hash_info_s *hash_info = GK_NULL;
+    gk_u8 *data_phy = GK_NULL;
+    gk_u32 size, hash_handle;
+
+    inlet_var_is_null_return(input_data);
+
+    if (input_data_len == 0)
+        return GK_SUCCESS;
+
+    if (hash_check_handle(ci_hash_id) != GK_SUCCESS)
+        return GK_ERR_CIPHER_INVALID_HANDLE;
+    hash_handle = handle_get_chn_id(ci_hash_id);
+    hash_info = (hash_info_s *)&g_cipher_hash_data[hash_handle];
+    if ((input_data_len + hash_info->total_data_len < input_data_len) ||
+        (input_data_len + hash_info->last_block_size < input_data_len)) {
+        gk_err_cipher("Error, input len is too large!\n");
+        return GK_FAILURE;
+    }
+
+    data_phy = (gk_u8 *)memalign(ARCH_DMA_MINALIGN, HASH_MAX_BLOCK_SIZE);
+    if (data_phy == GK_NULL) {
+        gk_err_cipher("Error, memalign for data_phy failed!\n");
+        hash_info->is_used = GK_FALSE;
+        return GK_FAILURE;
+    }
+    crypto_memset(data_phy, HASH_MAX_BLOCK_SIZE, 0, HASH_MAX_BLOCK_SIZE);
+
+    hash_info->total_data_len += input_data_len;
+    size = hash_info->last_block_size + input_data_len;
+    if (size < hash_info->block_size) {
+        crypto_memcpy(hash_info->last_block + hash_info->last_block_size,
+            HASH_BLOCK_SIZE, input_data, input_data_len);
+        hash_info->last_block_size += input_data_len;
+        goto free_data_phy;
+    }
+
+    ret = cipher_hash_updata_tail(hash_info, data_phy, input_data, input_data_len);
+    if (ret != GK_SUCCESS) {
+        gk_err_cipher("updata tail failed, ret %d\n", ret);
+        hash_info->is_used = GK_FALSE;
+    }
+
+free_data_phy:
+    free(data_phy);
+    data_phy = GK_NULL;
+    return ret;
+}
+
+static gk_s32 cipher_hash_final(gk_handle ci_hash_id, gk_u8 *output_hash)
+{
+    gk_s32 ret;
+    hash_info_s *hash_info = GK_NULL;
+    cipher_hash_data_s hash_data;
+    gk_u32 tmp;
+    gk_u8 *data_phy = GK_NULL;
+    gk_u32 hash_handle;
+
+    inlet_var_is_null_return(output_hash);
+
+    if (hash_check_handle(ci_hash_id) != GK_SUCCESS)
+        return GK_ERR_CIPHER_INVALID_HANDLE;
+    hash_handle = handle_get_chn_id(ci_hash_id);
+    hash_info = (hash_info_s *)&g_cipher_hash_data[hash_handle];
+
+    data_phy = (gk_u8 *)memalign(ARCH_DMA_MINALIGN, HASH_MAX_BLOCK_SIZE);
+    if (data_phy == NULL) {
+        gk_err_cipher("memalign for data phy failed!\n");
+        hash_info->is_used = GK_FALSE;
+        return GK_ERR_CIPHER_INVALID_POINT;
+    }
+    crypto_memset(data_phy, HASH_MAX_BLOCK_SIZE, 0, HASH_MAX_BLOCK_SIZE);
+
+    crypto_memset(&hash_data, sizeof(cipher_hash_data_s), 0, sizeof(cipher_hash_data_s));
+
+    tmp = hash_msg_padding(hash_info->last_block,
+        hash_info->last_block_size, hash_info->total_data_len, hash_info->block_size);
+
+    crypto_memcpy(data_phy, tmp, hash_info->last_block, tmp);
+
+    hash_data.sha_type = hash_info->sha_type;
+    hash_data.data_len = tmp;
+    hash_data.data_phy = get_ulong_low((gk_size_t)(uintptr_t)data_phy);
+    hash_data.data_phy_high = get_ulong_high((gk_size_t)(uintptr_t)data_phy);
+    crypto_memcpy(hash_data.sha_val, sizeof(hash_data.sha_val),
+        hash_info->sha_val, sizeof(hash_info->sha_val));
+    hash_data.hard_chn = SPACC_HASH_CHN;
+
+    ret = cipher_ioctl(g_cipher_dev_fd, CMD_CIPHER_CALCHASHFINAL, &hash_data);
+    crypto_memcpy(output_hash, HASH_RESULT_MAX_LEN, hash_data.sha_val, hash_info->sha_len);
+    hash_info->is_used = GK_FALSE;
+
+    free(data_phy);
+    data_phy = GK_NULL;
+
+    return ret;
+}
+
+static gk_s32 cipher_hmac_key_init(gk_cipher_hash_attr *hash_attr,
+                                   gk_u8 hmac_key[HASH_MAX_BLOCK_SIZE])
+{
+    gk_handle hash_handle = 0;
+    gk_s32 ret;
+
+    if ((hash_attr->sha_type == GK_CIPHER_HASH_TYPE_HMAC_SHA384) ||
+        (hash_attr->sha_type == GK_CIPHER_HASH_TYPE_HMAC_SHA512)) {
+        if (hash_attr->hmac_key_len <= 128) { /* key length is less than 128bytes, copy directly */
+            crypto_memcpy(hmac_key, HASH_MAX_BLOCK_SIZE, hash_attr->hmac_key, hash_attr->hmac_key_len);
+            return GK_SUCCESS;
+        }
+    } else {
+        if (hash_attr->hmac_key_len <= 64) { /* key length is less than 64bytes, copy directly */
+            crypto_memcpy(hmac_key, HASH_MAX_BLOCK_SIZE, hash_attr->hmac_key, hash_attr->hmac_key_len);
+            return GK_SUCCESS;
+        }
+    }
+
+    /* key length more than 64bytes, calcute the hash result */
+    ret = cipher_hash_init(hash_attr, &hash_handle) ||
+          cipher_hash_update(hash_handle, hash_attr->hmac_key, hash_attr->hmac_key_len) ||
+          cipher_hash_final(hash_handle, hmac_key);
+    if (ret != GK_SUCCESS) {
+        gk_err_cipher("hash final failed\n");
+        return ret;
+    }
+    return ret;
+}
+
+static gk_s32 cipher_hmac_init(gk_cipher_hash_attr *hash_attr, gk_handle *hash_handle)
+{
+    gk_s32 ret;
+    gk_u32 i, soft_id;
+    gk_u8 *key_pad = GK_NULL;
+    hash_info_s *hash_info = NULL;
+
+    inlet_var_is_null_return(hash_attr->hmac_key);
+    inlet_var_is_zero_return(hash_attr->hmac_key_len);
+
+    key_pad = (gk_u8 *)memalign(ARCH_DMA_MINALIGN, HASH_MAX_BLOCK_SIZE);
+    if (key_pad == GK_NULL) {
+        gk_err_cipher("memalign for key_pad failed!\n");
+        return GK_FAILURE;
+    }
+
+    memset(key_pad, 0, HASH_MAX_BLOCK_SIZE);
+
+    /* Init hmac key */
+    ret = cipher_hmac_key_init(hash_attr, key_pad);
+    if (ret != GK_SUCCESS) {
+        gk_err_cipher("Hmac key initial failed!\n");
+        goto free_key_pad;
+    }
+
+    /* hash i_key_pad and message start */
+    ret = cipher_hash_init(hash_attr, hash_handle);
+    if (ret != GK_SUCCESS) {
+        gk_err_cipher("hash i_key_pad and message start failed!\n");
+        goto free_key_pad;
+    }
+    soft_id = handle_get_chn_id(*hash_handle);
+    hash_info = (hash_info_s *)&g_cipher_hash_data[soft_id];
+    crypto_memcpy(hash_info->mac, sizeof(hash_info->mac), key_pad, hash_info->block_size);
+
+    /* generate i_key_pad */
+    for (i = 0; i < hash_info->block_size; i++)
+        key_pad[i] ^= 0x36;
+
+    /* hash i_key_pad update */
+    ret = cipher_hash_update(*hash_handle, key_pad, hash_info->block_size);
+    if (ret != GK_SUCCESS) {
+        gk_err_cipher("cipher hash update failed!\n");
+        goto free_key_pad;
+    }
+
+free_key_pad:
+    free(key_pad);
+    key_pad = GK_NULL;
+    return ret;
+}
+
+static gk_s32 cipher_hmac_update(gk_handle ci_hash_id, gk_u8 *input_data, gk_u32 input_data_len)
+{
+    return cipher_hash_update(ci_hash_id, input_data, input_data_len);
+}
+
+static gk_s32 cipher_hmac_o_key_pad(gk_cipher_hash_attr *hash_attr,
+    hash_info_s *hash_info, gk_u8 *output_data, gk_u8 *hash_sum, gk_u8 *key_pad)
+{
+    gk_u32 i;
+    gk_s32 ret;
+    gk_handle hash_handle;
+    gk_u32 sha_size;
+
+    /* generate o_key_pad */
+    for (i = 0; i < hash_info->block_size; i++)
+        key_pad[i] ^= 0x5c;
+
+    if (hash_attr->sha_type == GK_CIPHER_HASH_TYPE_HMAC_SHA224)
+        sha_size = SHA224_RESULT_SIZE;
+    else if (hash_attr->sha_type == GK_CIPHER_HASH_TYPE_HMAC_SHA384)
+        sha_size = SHA384_RESULT_SIZE;
+    else
+        sha_size = hash_info->sha_len;
+
+    /* hash o_key_pad + hash_sum start */
+    ret = cipher_hash_init(hash_attr, &hash_handle) ||
+          cipher_hash_update(hash_handle, key_pad, hash_info->block_size) ||
+          cipher_hash_update(hash_handle, hash_sum, sha_size) ||
+          cipher_hash_final(hash_handle, output_data);
+
+    return ret;
+}
+
+static gk_s32 cipher_hmac_final(gk_handle ci_hash_id, gk_u8 *output_data)
+{
+    gk_s32 ret;
+    gk_handle hash_handle;
+    gk_cipher_hash_attr hash_attr;
+    gk_u8 *hash_sum = GK_NULL;
+    gk_u8 *key_pad = GK_NULL;
+    hash_info_s *hash_info = GK_NULL;
+
+    if (hash_check_handle(ci_hash_id) != GK_SUCCESS)
+        return GK_ERR_CIPHER_INVALID_HANDLE;
+    hash_handle = handle_get_chn_id(ci_hash_id);
+    hash_info = (hash_info_s *)&g_cipher_hash_data[hash_handle];
+
+    key_pad = (gk_u8 *)memalign(ARCH_DMA_MINALIGN, HASH_MAX_BLOCK_SIZE);
+    if (key_pad == GK_NULL) {
+        gk_err_cipher("memalign for key_pad failed!\n");
+        hash_info->is_used = GK_FALSE;
+        return GK_FAILURE;
+    }
+
+    hash_sum = (gk_u8 *)memalign(ARCH_DMA_MINALIGN, HASH_RESULT_MAX_LEN);
+    if (hash_sum == GK_NULL) {
+        gk_err_cipher("memalign for key_pad failed!\n");
+        hash_info->is_used = GK_FALSE;
+        ret = GK_FAILURE;
+        goto free_key_pad;
+    }
+
+    crypto_memset(key_pad, HASH_MAX_BLOCK_SIZE, 0, HASH_MAX_BLOCK_SIZE);
+    crypto_memset(hash_sum, HASH_RESULT_MAX_LEN, 0, HASH_RESULT_MAX_LEN);
+    crypto_memset(&hash_attr, sizeof(hash_attr), 0, sizeof(gk_cipher_hash_attr));
+    hash_attr.sha_type = hash_info->sha_type;
+    crypto_memcpy(key_pad, HASH_MAX_BLOCK_SIZE, hash_info->mac, hash_info->block_size);
+
+    /* hash i_key_pad + message finished */
+    ret = cipher_hash_final(ci_hash_id, hash_sum);
+    if (ret != GK_SUCCESS) {
+        gk_err_cipher("Hash Final i_key_pad + message failure, ret=%d\n", ret);
+        hash_info->is_used = GK_FALSE;
+        goto free_hash_sum;
+    }
+
+    /* hash o_key_pad + message finished */
+    ret = cipher_hmac_o_key_pad(&hash_attr, hash_info, output_data, hash_sum, key_pad);
+    if (ret != GK_SUCCESS) {
+        gk_err_cipher("Hash Final o_key_pad + message failure, ret=%d\n", ret);
+        hash_info->is_used = GK_FALSE;
+        goto free_hash_sum;
+    }
+
+free_hash_sum:
+    free(hash_sum);
+    hash_sum = GK_NULL;
+
+free_key_pad:
+    free(key_pad);
+    key_pad = GK_NULL;
+    return ret;
+}
+
+gk_s32 gk_api_cipher_hash_init(gk_cipher_hash_attr *hash_attr, gk_handle *hash_handle)
+{
+    gk_s32 ret;
+
+    check_cipher_not_open_return();
+    inlet_var_is_null_return(hash_attr);
+    inlet_var_is_null_return(hash_handle);
+
+    switch (hash_attr->sha_type) {
+        case GK_CIPHER_HASH_TYPE_SHA1:
+        case GK_CIPHER_HASH_TYPE_SHA224:
+        case GK_CIPHER_HASH_TYPE_SHA256:
+        case GK_CIPHER_HASH_TYPE_SHA384:
+        case GK_CIPHER_HASH_TYPE_SHA512:
+        case GK_CIPHER_HASH_TYPE_SM3:
+            ret = cipher_hash_init(hash_attr, hash_handle);
+            break;
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA1:
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA224:
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA256:
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA384:
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA512:
+            ret = cipher_hmac_init(hash_attr, hash_handle);
+            break;
+        default:
+            gk_err_cipher("Invalid sha type %d!\n", hash_attr->sha_type);
+            return GK_FAILURE;
+    }
+
+    if (ret != GK_SUCCESS) {
+        gk_err_cipher("hash init failed, hash type: %d\n", hash_attr->sha_type);
+        return ret;
+    }
+
+    return ret;
+}
+
+gk_s32 gk_api_cipher_hash_update(gk_handle hash_handle, gk_u8 *input_data, gk_u32 input_data_len)
+{
+    gk_s32 ret;
+    gk_u32 soft_id;
+    hash_info_s *hash_info = GK_NULL;
+
+    check_cipher_not_open_return();
+    inlet_var_is_null_return(input_data);
+
+    if (hash_check_handle(hash_handle) != GK_SUCCESS)
+        return GK_ERR_CIPHER_INVALID_HANDLE;
+
+    soft_id = handle_get_chn_id(hash_handle);
+    hash_info = (hash_info_s *)&g_cipher_hash_data[soft_id];
+
+    switch (hash_info->sha_type) {
+        case GK_CIPHER_HASH_TYPE_SHA1:
+        case GK_CIPHER_HASH_TYPE_SHA224:
+        case GK_CIPHER_HASH_TYPE_SHA256:
+        case GK_CIPHER_HASH_TYPE_SHA384:
+        case GK_CIPHER_HASH_TYPE_SHA512:
+        case GK_CIPHER_HASH_TYPE_SM3:
+            ret = cipher_hash_update(hash_handle, input_data, input_data_len);
+            break;
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA1:
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA224:
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA256:
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA384:
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA512:
+            ret = cipher_hmac_update(hash_handle, input_data, input_data_len);
+            break;
+        default:
+            gk_err_cipher("Invalid hash type %d!\n", hash_info->sha_type);
+            return GK_FAILURE;
+    }
+
+    if (ret != GK_SUCCESS) {
+        gk_err_cipher("hash update failed, hash type: %d\n", hash_info->sha_type);
+        return ret;
+    }
+
+    return ret;
+}
+
+gk_s32 gk_api_cipher_hash_final(gk_handle hash_handle, gk_u8 *output_hash)
+{
+    gk_s32 ret;
+    gk_u32 soft_id;
+    hash_info_s *hash_info = GK_NULL;
+
+    check_cipher_not_open_return();
+    inlet_var_is_null_return(output_hash);
+
+    if (hash_check_handle(hash_handle) != GK_SUCCESS)
+        return GK_ERR_CIPHER_INVALID_HANDLE;
+
+    soft_id = handle_get_chn_id(hash_handle);
+    hash_info = (hash_info_s *)&g_cipher_hash_data[soft_id];
+
+    switch (hash_info->sha_type) {
+        case GK_CIPHER_HASH_TYPE_SHA1:
+        case GK_CIPHER_HASH_TYPE_SHA224:
+        case GK_CIPHER_HASH_TYPE_SHA256:
+        case GK_CIPHER_HASH_TYPE_SHA384:
+        case GK_CIPHER_HASH_TYPE_SHA512:
+        case GK_CIPHER_HASH_TYPE_SM3:
+            ret = cipher_hash_final(hash_handle, output_hash);
+            break;
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA1:
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA224:
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA256:
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA384:
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA512:
+            ret = cipher_hmac_final(hash_handle, output_hash);
+            break;
+        default:
+            gk_err_cipher("Invalid hash type %d!\n", hash_info->sha_type);
+            return GK_FAILURE;
+    }
+
+    if (ret != GK_SUCCESS) {
+        gk_err_cipher("hash final failed, hash type: %d\n", hash_info->sha_type);
+        return ret;
+    }
+
+    return ret;
+}
diff -uraN u-boot-2016.11/product/cipher/v2/api/ree_mpi_rng.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/api/ree_mpi_rng.c
--- u-boot-2016.11/product/cipher/v2/api/ree_mpi_rng.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/api/ree_mpi_rng.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "cipher_osal.h"
+
+gk_s32 mpi_cipher_get_random_number(gk_u32 *random_number, gk_u32 time_out_us)
+{
+    gk_s32 ret;
+    cipher_rng_s ci_rng;
+
+    inlet_var_is_null_return(random_number);
+
+    ci_rng.ci_rng = 0;
+    ci_rng.time_out_us = time_out_us;
+
+    ret = cipher_ioctl(g_cipher_dev_fd, CMD_CIPHER_GETRANDOMNUMBER, &ci_rng);
+
+    if (ret == GK_SUCCESS)
+        *random_number = ci_rng.ci_rng;
+
+    return ret;
+}
+
+gk_s32 gk_api_cipher_get_random_number(gk_u32 *random_number)
+{
+    check_cipher_not_open_return();
+
+    return mpi_cipher_get_random_number(random_number, 0);
+}
+
diff -uraN u-boot-2016.11/product/cipher/v2/api/ree_mpi_rsa.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/api/ree_mpi_rsa.c
--- u-boot-2016.11/product/cipher/v2/api/ree_mpi_rsa.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/api/ree_mpi_rsa.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,1552 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "cipher_osal.h"
+
+#define rsa_var_null_goto_lab(var, ret, lab) \
+    do { \
+        if ((var) == GK_NULL) { \
+            gk_err_cipher("%s-%d: %s is null\n", __FUNCTION__, __LINE__, #var); \
+            ret = GK_ERR_CIPHER_INVALID_POINT; \
+            goto lab; \
+        } \
+    } while (0);
+
+#define rsa_ret_fail_goto_lab(ret, lab) \
+    do { \
+        if ((ret) != GK_SUCCESS) { \
+            gk_err_cipher("%s-%d: ret 0x%x\n", __FUNCTION__, __LINE__, ret); \
+            goto lab; \
+        } \
+    } while (0);
+
+#define rsa_func_fail_return(val, ret, func) \
+    do { \
+        if (val) { \
+            gk_err_cipher("%s-%d: call %s failed, ret 0x%x\n", __FUNCTION__, __LINE__, #func, ret); \
+            return ret; \
+        } \
+    } while (0)
+
+#define rsa_not_equal_return(var, val, ret) \
+    do { \
+        if ((var) != (val)) { \
+            gk_err_cipher("%s(0x%x) isn't equal 0x%x\n", #var, var, val); \
+            return ret; \
+        } \
+    } while (0)
+
+typedef struct {
+    gk_cipher_hash_type hash_type;
+    gk_u32 hlen;
+    gk_u32 klen;
+    gk_u32 em_bit;
+    gk_u8 key_bt;
+    gk_u8 *in_data;
+    gk_u32 in_len;
+    gk_u8 *out_data;
+    gk_u32 out_len;
+} rsa_padding_s;
+
+typedef struct {
+    gk_u8 *masked_db;
+    gk_u8 *masked_seed;
+    gk_u8 salt[CIPHER_MAX_RSA_KEY_LEN];
+    gk_u32 msb_bits;
+    gk_u32 slen;
+    gk_u32 key_len;
+} rsa_pkcs1_pss_s;
+
+typedef struct {
+    gk_u8 arr_em[CIPHER_MAX_RSA_KEY_LEN];
+    gk_u8 sign_hash[HASH_RESULT_MAX_LEN];
+} rsa_sign_buf;
+
+#define RSA_SIGN                1
+#define ASN1_HASH_SHA1      "\x30\x21\x30\x09\x06\x05\x2b\x0e\x03\x02\x1a\x05\x00\x04\x14"
+#define ASN1_HASH_SHA224    "\x30\x2D\x30\x0d\x06\x09\x60\x86\x48\x01\x65\x03\x04\x02\x04\x05\x00\x04\x1C"
+#define ASN1_HASH_SHA256    "\x30\x31\x30\x0d\x06\x09\x60\x86\x48\x01\x65\x03\x04\x02\x01\x05\x00\x04\x20"
+#define ASN1_HASH_SHA384    "\x30\x41\x30\x0d\x06\x09\x60\x86\x48\x01\x65\x03\x04\x02\x02\x05\x00\x04\x30"
+#define ASN1_HASH_SHA512    "\x30\x51\x30\x0d\x06\x09\x60\x86\x48\x01\x65\x03\x04\x02\x03\x05\x00\x04\x40"
+
+static const gk_s8 g_empty_l_sha1[] =
+    "\xda\x39\xa3\xee\x5e\x6b\x4b\x0d"
+    "\x32\x55\xbf\xef\x95\x60\x18\x90"
+    "\xaf\xd8\x07\x09";
+
+static const gk_s8 g_empty_l_sha224[] =
+    "\xd1\x4a\x02\x8c\x2a\x3a\x2b\xc9"
+    "\x47\x61\x02\xbb\x28\x82\x34\xc4"
+    "\x15\xa2\xb0\x1f\x82\x8e\xa6\x2a"
+    "\xc5\xb3\xe4\x2f";
+
+static const gk_s8 g_empty_l_sha256[] =
+    "\xe3\xb0\xc4\x42\x98\xfc\x1c\x14"
+    "\x9a\xfb\xf4\xc8\x99\x6f\xb9\x24"
+    "\x27\xae\x41\xe4\x64\x9b\x93\x4c"
+    "\xa4\x95\x99\x1b\x78\x52\xb8\x55";
+
+static const gk_s8 g_empty_l_sha384[] =
+    "\x38\xb0\x60\xa7\x51\xac\x96\x38"
+    "\x4c\xd9\x32\x7e\xb1\xb1\xe3\x6a"
+    "\x21\xfd\xb7\x11\x14\xbe\x07\x43"
+    "\x4c\x0c\xc7\xbf\x63\xf6\xe1\xda"
+    "\x27\x4e\xde\xbf\xe7\x6f\x65\xfb"
+    "\xd5\x1a\xd2\xf1\x48\x98\xb9\x5b";
+
+static const gk_s8 g_empty_l_sha512[] =
+    "\xcf\x83\xe1\x35\x7e\xef\xb8\xbd"
+    "\xf1\x54\x28\x50\xd6\x6d\x80\x07"
+    "\xd6\x20\xe4\x05\x0b\x57\x15\xdc"
+    "\x83\xf4\xa9\x21\xd3\x6c\xe9\xce"
+    "\x47\xd0\xd1\x3c\x5d\x85\xf2\xb0"
+    "\xff\x83\x18\xd2\x87\x7e\xec\x2f"
+    "\x63\xb9\x31\xbd\x47\x41\x7a\x81"
+    "\xa5\x38\x32\x7a\xf9\x27\xda\x3e";
+
+static gk_s32 rsa_private(const gk_cipher_rsa_private_key *pri_key,
+    gk_cipher_ca_type ca_type, const gk_u8 *input, gk_u8 *output)
+{
+    cipher_rsa_data_s rsa_data;
+
+    inlet_var_is_null_return(pri_key);
+    inlet_var_is_null_return(pri_key->d);
+    inlet_var_is_null_return(pri_key->n);
+    inlet_var_is_null_return(input);
+    inlet_var_is_null_return(output);
+
+    rsa_data.rsa_n = pri_key->n;
+    rsa_data.rsa_k = pri_key->d;
+    rsa_data.rsa_n_len = pri_key->n_len;
+    rsa_data.rsa_k_len = pri_key->d_len;
+    rsa_data.input_data = (gk_u8 *)input;
+    rsa_data.output_data = output;
+    rsa_data.data_len = pri_key->n_len;
+    rsa_data.ca_type = GK_CIPHER_KEY_SRC_USER;
+
+    return cipher_ioctl(g_cipher_dev_fd, CMD_CIPHER_CALCRSA, &rsa_data);
+}
+
+static gk_s32 rsa_public(const gk_cipher_rsa_pub_key *pub_key, const gk_u8 *input, gk_u8 *output)
+{
+    cipher_rsa_data_s rsa_data;
+
+    inlet_var_is_null_return(pub_key);
+    inlet_var_is_null_return(pub_key->n);
+    inlet_var_is_null_return(pub_key->e);
+    inlet_var_is_null_return(input);
+    inlet_var_is_null_return(output);
+
+    rsa_data.rsa_n = pub_key->n;
+    rsa_data.rsa_k = pub_key->e;
+    rsa_data.rsa_n_len = pub_key->n_len;
+    rsa_data.rsa_k_len = pub_key->e_len;
+    rsa_data.input_data = (gk_u8 *)input;
+    rsa_data.output_data = output;
+    rsa_data.data_len = pub_key->n_len;
+    rsa_data.ca_type = GK_CIPHER_KEY_SRC_USER;
+    return cipher_ioctl(g_cipher_dev_fd, CMD_CIPHER_CALCRSA, &rsa_data);
+}
+
+static gk_s32 rsa_get_attr(gk_u32 scheme, gk_u16 rsa_n_len, rsa_padding_s *pad)
+{
+    gk_s32 ret = GK_SUCCESS;
+
+    inlet_var_over_max_return(rsa_n_len, 512); /* 512 rsa n length */
+
+    pad->klen = rsa_n_len;
+
+    switch (scheme) {
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_NO_PADDING:
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_BLOCK_TYPE_0:
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_BLOCK_TYPE_1:
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_BLOCK_TYPE_2:
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_PKCS1_V1_5:
+            pad->hlen = 0; /* 0 pad hlen */
+            pad->hash_type = GK_CIPHER_HASH_TYPE_BUTT;
+            break;
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA1:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA1:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA1:
+            pad->hlen = 20; /* 20 pad hlen */
+            pad->hash_type = GK_CIPHER_HASH_TYPE_SHA1;
+            break;
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA224:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA224:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA224:
+            pad->hlen = 28; /* 28 pad hlen */
+            pad->hash_type = GK_CIPHER_HASH_TYPE_SHA224;
+            break;
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA256:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA256:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA256:
+            pad->hlen = 32; /* 32 pad hlen */
+            pad->hash_type = GK_CIPHER_HASH_TYPE_SHA256;
+            break;
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA384:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA384:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA384:
+            pad->hlen = 48; /* 48 pad hlen */
+            pad->hash_type = GK_CIPHER_HASH_TYPE_SHA384;
+            break;
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA512:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA512:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA512:
+            pad->hlen = 64; /* 64 pad hlen */
+            pad->hash_type = GK_CIPHER_HASH_TYPE_SHA512;
+            break;
+        default:
+            gk_err_cipher("RSA scheme (0x%x) is invalid.\n", scheme);
+            ret = GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    return ret;
+}
+
+static gk_s32 rsa_pkcs1_mgf1_get_md_len(gk_cipher_hash_type hash_type, gk_u32 *md_len)
+{
+    switch (hash_type) {
+        case GK_CIPHER_HASH_TYPE_SHA1:
+            *md_len = 20; /* 20 md len */
+            break;
+        case GK_CIPHER_HASH_TYPE_SHA224:
+            *md_len = 28; /* 28 md len */
+            break;
+        case GK_CIPHER_HASH_TYPE_SHA256:
+            *md_len = 32; /* 32 md len */
+            break;
+        case GK_CIPHER_HASH_TYPE_SHA384:
+            *md_len = 48; /* 48 md len */
+            break;
+        case GK_CIPHER_HASH_TYPE_SHA512:
+            *md_len = 64; /* 64 md len */
+            break;
+        default:
+            *md_len = 0;
+            gk_err_cipher("hash type is invalid.\n");
+            return GK_ERR_CIPHER_INVALID_PARA;
+    }
+    return GK_SUCCESS;
+}
+
+static gk_s32 rsa_pkcs1_mgf1(gk_cipher_hash_type hash_type,
+    gk_u8 *seed, gk_u32 seed_len, gk_u8 *mask, gk_u32 mask_len)
+{
+    gk_s32 ret = GK_FAILURE;
+    gk_u32 i, out_len;
+    gk_cipher_hash_attr hash_attr;
+    gk_u8 *ptr_cnt = GK_NULL;
+    gk_u8 *ptr_md = GK_NULL;
+    gk_u8 *ptr_seed = GK_NULL;
+
+    ptr_cnt = (gk_u8 *)memalign(ARCH_DMA_MINALIGN, 4); /* 4 align */
+    if (ptr_cnt == GK_NULL) {
+        gk_err_cipher("memalign for ptr_cnt invalid.\n");
+        return GK_ERR_CIPHER_INVALID_POINT;
+    }
+
+    ptr_md = (gk_u8 *)memalign(ARCH_DMA_MINALIGN, HASH_RESULT_MAX_LEN);
+    rsa_var_null_goto_lab(ptr_md, ret, free_ptr_cnt);
+
+    ptr_seed = (gk_u8 *)memalign(ARCH_DMA_MINALIGN, seed_len);
+    rsa_var_null_goto_lab(ptr_md, ret, free_ptr_md);
+
+    crypto_memset(ptr_cnt, 4, 0, 4); /* 4 ptr_cnt size */
+    crypto_memset(ptr_md, HASH_RESULT_MAX_LEN, 0, HASH_RESULT_MAX_LEN);
+    crypto_memcpy(ptr_seed, seed_len, seed, seed_len);
+
+    /* PKCS#1 V2.1 only use sha1 function, Others allow for future expansion */
+    hash_attr.sha_type = hash_type;
+    for (i = 0, out_len = 0; out_len < mask_len; i++) {
+        gk_handle hash_handle;
+        gk_u32 j, md_len;
+
+        ret = rsa_pkcs1_mgf1_get_md_len(hash_type, &md_len);
+        rsa_ret_fail_goto_lab(ret, free_ptr_seed);
+
+        ptr_cnt[0] = (gk_u8)((i >> 24) & 0xFF); /* 0 ptr_cnt index, 24 right shift */
+        ptr_cnt[1] = (gk_u8)((i >> 16) & 0xFF); /* 1 ptr_cnt index, 16 right shift */
+        ptr_cnt[2] = (gk_u8)((i >>  8) & 0xFF); /* 2 ptr_cnt index, 8  right shift */
+        ptr_cnt[3] = (gk_u8)(i & 0xFF);         /* 3 ptr_cnt index */
+
+        ret = gk_api_cipher_hash_init(&hash_attr, &hash_handle) ||
+              gk_api_cipher_hash_update(hash_handle, ptr_seed, seed_len) ||
+              gk_api_cipher_hash_update(hash_handle, ptr_cnt, 4) || /* 4 ptr_cnt size */
+              gk_api_cipher_hash_final(hash_handle, ptr_md);
+        rsa_ret_fail_goto_lab(ret, free_ptr_seed);
+
+        for (j = 0; (j < md_len) && (out_len < mask_len); j++)
+            mask[out_len++] ^= ptr_md[j];
+    }
+
+free_ptr_seed:
+    free(ptr_seed);
+    ptr_seed = GK_NULL;
+
+free_ptr_md:
+    free(ptr_md);
+    ptr_md = GK_NULL;
+
+free_ptr_cnt:
+    free(ptr_cnt);
+    ptr_cnt = GK_NULL;
+    return ret;
+}
+
+static gk_s32 mbedtls_get_random_number(gk_void *param, gk_u8 *rand, size_t size)
+{
+    gk_u32 i;
+    gk_s32 ret;
+    gk_u32 randnum, left_size;
+
+    crypto_memset(rand, size, 0, size);
+    for (i = 0; i < size; i += 4) { /* 4 word bytes */
+        ret = mpi_cipher_get_random_number(&randnum, -1);
+        rsa_func_fail_return(ret != GK_SUCCESS, ret, mpi_cipher_get_random_number);
+
+        left_size = (size - i) > 4 ? 4 : (size - i); /* 4 word bytes */
+        switch (left_size) {
+            case 4: /* left 4 */
+                rand[i + 3] = (gk_u8)(randnum >> 24) & 0xFF; /* 3 rand index, 24 right shift */
+                /* fall through */
+            case 3: /* left 3 */
+                rand[i + 2] = (gk_u8)(randnum >> 16) & 0xFF; /* 2 rand index, 16 right shift */
+                /* fall through */
+            case 2: /* left 2 */
+                rand[i + 1] = (gk_u8)(randnum >> 8) & 0xFF; /* 1 rand index, 8  right shift */
+                /* fall through */
+            case 1: /* left 1 */
+                rand[i + 0] = (gk_u8)(randnum >> 0) & 0xFF; /* 0 rand index */
+                break;
+            default:
+                gk_err_cipher("left size %u is error\n", left_size);
+                return GK_ERR_CIPHER_INVALID_PARA;
+        }
+    }
+
+    /* non-zero random octet string */
+    for (i = 0; i < size; i++) {
+        if (rand[i] != 0x00)
+            continue;
+
+        ret = mpi_cipher_get_random_number(&randnum, -1);
+        rsa_func_fail_return(ret != GK_SUCCESS, ret, mpi_cipher_get_random_number);
+        rand[i] = (gk_u8)(randnum) & 0xFF;
+        i = 0;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_u32 rsa_get_bit_num(gk_u8 *big_num, gk_u32 num_len)
+{
+    static const gk_s8 bits[16] = {0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4}; /* 16 bits size */
+    gk_u32 i;
+
+    inlet_var_is_null_return(big_num);
+
+    for (i = 0; i < num_len; i++) {
+        gk_u32 num;
+        num = bits[(big_num[i] & 0xF0) >> 4]; /* 4 right shift */
+
+        if (num > 0)
+            return (num_len - i - 1) * 8 + num + 4; /* 8, 4 */
+
+        num = bits[big_num[i] & 0xF];
+        if (num > 0)
+            return (num_len - i - 1) * 8 + num; /* 8 */
+    }
+    return 0;
+}
+
+/* PKCS #1: EME-OAEP encoding */
+/* ************************************************************
+                    +----------+---------+--+-------+
+               DB = |  lHash   |    PS   |01|   M   |
+                    +----------+---------+--+-------+
+                                   |
+         +----------+              V
+         |   ptr_seed   |--> MGF ---> xor
+         +----------+              |
+               |                   |
+      +--+     V                   |
+      |00|    xor <----- MGF <-----|
+      +--+     |                   |
+        |      |                   |
+        V      V                   V
+      +--+----------+----------------------------+
+EM =  |00|maskedSeed|          maskedDB          |
+      +--+----------+----------------------------+
+       1     hlen              k - hlen- 1
+
+so: PS_LEN = k - hlen - 1 -  (hlen  + mlen + 1) = k - 2hlen - mlen - 2 > 0
+so: mlen < k - 2hlen - 2
+************************************************************ */
+static gk_s32 rsa_padding_add_pkcs1_oaep(rsa_padding_s *pad)
+{
+    gk_s32 ret;
+    gk_u32 db_len;
+    gk_u8 *ptr_db = GK_NULL;
+    gk_u8 *ptr_seed = GK_NULL;
+    const gk_s8 *l_hash = g_empty_l_sha1;
+
+    /* In the v2.1 of PKCS #1, L is the empty string;    */
+    /* other uses outside the scope of rsa specifications */
+    if (pad->hash_type == GK_CIPHER_HASH_TYPE_SHA224) {
+        l_hash = g_empty_l_sha224;
+    } else if (pad->hash_type == GK_CIPHER_HASH_TYPE_SHA256) {
+        l_hash = g_empty_l_sha256;
+    } else if (pad->hash_type == GK_CIPHER_HASH_TYPE_SHA384) {
+        l_hash = g_empty_l_sha384;
+    } else if (pad->hash_type == GK_CIPHER_HASH_TYPE_SHA512) {
+        l_hash = g_empty_l_sha512;
+    }
+
+    if (pad->in_len > pad->klen - 2 * pad->hlen - 2) { /* 2 */
+        gk_err_cipher("input_len is invalid.\n");
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    pad->out_data[0] = 0;
+    ptr_seed = pad->out_data + 1;
+    ptr_db = pad->out_data + pad->hlen + 1;
+    db_len = pad->klen - pad->hlen - 1;
+
+    /* set lHash */
+    crypto_memcpy(ptr_db, db_len, l_hash, pad->hlen);
+
+    /* set PS with 0x00 */
+    crypto_memset(&ptr_db[pad->hlen], db_len - pad->hlen, 0, db_len - pad->in_len - pad->hlen - 1);
+
+    /* set 0x01 after PS */
+    ptr_db[db_len - pad->in_len - 1] = 0x01;
+
+    /* set M */
+    crypto_memcpy(&ptr_db[db_len - pad->in_len], pad->in_len, pad->in_data, pad->in_len);
+
+    /* compute maskedDB */
+    ret = mbedtls_get_random_number(GK_NULL, ptr_seed, pad->hlen);
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, mbedtls_get_random_number);
+
+    ret = rsa_pkcs1_mgf1(pad->hash_type, ptr_seed, pad->hlen, ptr_db, pad->klen - pad->hlen - 1);
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_pkcs1_mgf1);
+
+    /* compute maskedSeed */
+    ret = rsa_pkcs1_mgf1(pad->hash_type, ptr_db, pad->klen - pad->hlen - 1, ptr_seed, pad->hlen);
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_pkcs1_mgf1);
+
+    pad->out_len = pad->klen;
+
+    return ret;
+}
+
+/* PKCS #1: RSAES-PKCS1-V1_5-ENCRYPT */
+/*************************************************
+formula: EM = 0x00 || 0x02 || PS || 0x00 || M
+
+formula: PS_LEN > 8, mlen < klen - 11
+*************************************************/
+static gk_s32 rsa_padding_add_pkcs1_v15(rsa_padding_s *pad)
+{
+    gk_u32 index = 0;
+    gk_s32 ret;
+
+    if (pad->in_len > pad->klen - 11) { /* 11 */
+        gk_err_cipher("input_len is invalid.\n");
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    pad->out_data[index++] = 0x00;
+    pad->out_data[index++] = 0x02;
+    ret = mbedtls_get_random_number(GK_NULL, &pad->out_data[index], pad->klen - pad->in_len - 3); /* 3 */
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, mbedtls_get_random_number);
+
+    index += pad->klen - pad->in_len - 3; /* 3 */
+    pad->out_data[index++] = 0x00;
+    crypto_memcpy(&pad->out_data[index], pad->klen - index, pad->in_data, pad->in_len);
+
+    pad->out_len = pad->klen;
+
+    return GK_SUCCESS;
+}
+
+/* PKCS #1: block type 0,1,2 message padding */
+/* ************************************************
+formula: EB = 00 || BT || PS || 00 || D
+
+formula: PS_LEN >= 8, mlen < klen - 11
+************************************************ */
+static gk_s32 rsa_padding_add_pkcs1_type(rsa_padding_s *pad)
+{
+    gk_u32 pad_len;
+    gk_u8 *key_eb = GK_NULL;
+    gk_s32 ret;
+
+    if (pad->in_len > pad->klen - 11) { /* 11 */
+        gk_err_cipher("input_len is invalid.\n");
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    key_eb = pad->out_data;
+
+    *(key_eb++) = 0;
+    *(key_eb++) = pad->key_bt; /* Private Key BT (Block Type) */
+
+    /* pad out with 0xff data */
+    pad_len = pad->klen - 3 - pad->in_len; /* 3 */
+    if (pad->key_bt == 0x00) {
+        crypto_memset(key_eb, pad->klen - (gk_u32)(key_eb - pad->out_data), 0x00, pad_len);
+    } else if (pad->key_bt == 0x01) {
+        crypto_memset(key_eb, pad->klen - (gk_u32)(key_eb - pad->out_data), 0xFF, pad_len);
+    } else if (pad->key_bt == 0x02) {
+        ret = mbedtls_get_random_number(GK_NULL, key_eb, pad_len);
+        rsa_func_fail_return(ret != GK_SUCCESS, ret, mbedtls_get_random_number);
+    } else {
+        gk_err_cipher("BT(0x%x) is invalid.\n", pad->key_bt);
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    key_eb += pad_len;
+    *(key_eb++) = 0x00;
+    crypto_memcpy(key_eb, pad->klen - (gk_u32)(key_eb - pad->out_data), pad->in_data, pad->in_len);
+    pad->out_len = pad->klen;
+
+    return GK_SUCCESS;
+}
+
+/* PKCS #1: RSAES-PKCS1-V1_5-Signature */
+/* ********************************************************
+formula: EM = 0x00 || 0x01 || PS || 0x00 || T
+
+T ::= SEQUENCE {
+          digestAlgorithm AlgorithmIdentifier,
+          digest OCTET STRING
+      }
+The first field identifies the hash function and the second
+contains the hash value
+********************************************************* */
+static gk_void rsa_padding_add_emsa_pkcs1_v15_sha1(rsa_padding_s *pad, gk_u8 *p)
+{
+    gk_u32 pad_len, buf_len;
+
+    pad_len = pad->klen - 3 - 35; /* 3, 35 */
+    buf_len = pad->klen - (gk_u32)(p - pad->out_data);
+    crypto_memset(p, buf_len, 0xFF, pad_len);
+    p += pad_len;
+    *p++ = 0;
+    buf_len = pad->klen - (gk_u32)(p - pad->out_data);
+    crypto_memcpy(p, buf_len, ASN1_HASH_SHA1, 15); /* 15 copy size */
+    p += 15; /* 15 p shift */
+    buf_len = pad->klen - (gk_u32)(p - pad->out_data);
+    crypto_memcpy(p, buf_len, pad->in_data, pad->in_len);
+}
+
+static gk_void rsa_padding_add_emsa_pkcs1_v15_sha224(rsa_padding_s *pad, gk_u8 *p)
+{
+    gk_u32 pad_len, buf_len;
+
+    pad_len = pad->klen - 3 - 19 - pad->in_len; /* 3, 19 */
+    buf_len = pad->klen - (gk_u32)(p - pad->out_data);
+    crypto_memset(p, buf_len, 0xFF, pad_len);
+    p += pad_len;
+    *p++ = 0;
+    buf_len = pad->klen - (gk_u32)(p - pad->out_data);
+    crypto_memcpy(p, buf_len, ASN1_HASH_SHA224, 19); /* 19 copy size */
+    p += 19; /* 19 p shift */
+    buf_len = pad->klen - (gk_u32)(p - pad->out_data);
+    crypto_memcpy(p, buf_len, pad->in_data, pad->in_len);
+}
+
+static gk_void rsa_padding_add_emsa_pkcs1_v15_sha256(rsa_padding_s *pad, gk_u8 *p)
+{
+    gk_u32 pad_len, buf_len;
+
+    pad_len = pad->klen - 3 - 19 - pad->in_len; /* 3, 19 */
+    buf_len = pad->klen - (gk_u32)(p - pad->out_data);
+    crypto_memset(p, buf_len, 0xFF, pad_len);
+    p += pad_len;
+    *p++ = 0;
+    buf_len = pad->klen - (gk_u32)(p - pad->out_data);
+    crypto_memcpy(p, buf_len, ASN1_HASH_SHA256, 19); /* 19 copy size */
+    p += 19; /* 19 p shift */
+    buf_len = pad->klen - (gk_u32)(p - pad->out_data);
+    crypto_memcpy(p, buf_len, pad->in_data, pad->in_len);
+}
+
+static gk_void rsa_padding_add_emsa_pkcs1_v15_sha384(rsa_padding_s *pad, gk_u8 *p)
+{
+    gk_u32 pad_len, buf_len;
+
+    pad_len = pad->klen - 3 - 19 - pad->in_len; /* 3, 19 */
+    buf_len = pad->klen - (gk_u32)(p - pad->out_data);
+    crypto_memset(p, buf_len, 0xFF, pad_len);
+    p += pad_len;
+    *p++ = 0;
+    buf_len = pad->klen - (gk_u32)(p - pad->out_data);
+    crypto_memcpy(p, buf_len, ASN1_HASH_SHA384, 19); /* 19 copy size */
+    p += 19; /* 19 p shift */
+    buf_len = pad->klen - (gk_u32)(p - pad->out_data);
+    crypto_memcpy(p, buf_len, pad->in_data, pad->in_len);
+}
+
+static gk_void rsa_padding_add_emsa_pkcs1_v15_sha512(rsa_padding_s *pad, gk_u8 *p)
+{
+    gk_u32 pad_len, buf_len;
+
+    pad_len = pad->klen - 3 - 19 - pad->in_len; /* 3, 19 */
+    buf_len = pad->klen - (gk_u32)(p - pad->out_data);
+    crypto_memset(p, buf_len, 0xFF, pad_len);
+
+    p += pad_len;
+    *p++ = 0;
+    crypto_memcpy(p, pad->klen, ASN1_HASH_SHA512, 19); /* 19 copy size */
+
+    p += 19; /* 19 p shift */
+    buf_len = pad->klen - (gk_u32)(p - pad->out_data);
+    crypto_memcpy(p, buf_len, pad->in_data, pad->in_len);
+}
+
+static gk_s32 rsa_padding_add_emsa_pkcs1_v15(rsa_padding_s *pad)
+{
+    gk_u8 *p = pad->out_data;
+
+    pad->out_len = pad->klen;
+    *p++ = 0;
+    *p++ = RSA_SIGN;
+
+    switch (pad->hash_type) {
+        case GK_CIPHER_HASH_TYPE_SHA1:
+            rsa_padding_add_emsa_pkcs1_v15_sha1(pad, p);
+            break;
+        case GK_CIPHER_HASH_TYPE_SHA224:
+            rsa_padding_add_emsa_pkcs1_v15_sha224(pad, p);
+            break;
+        case GK_CIPHER_HASH_TYPE_SHA256:
+            rsa_padding_add_emsa_pkcs1_v15_sha256(pad, p);
+            break;
+        case GK_CIPHER_HASH_TYPE_SHA384:
+            rsa_padding_add_emsa_pkcs1_v15_sha384(pad, p);
+            break;
+        case GK_CIPHER_HASH_TYPE_SHA512:
+            rsa_padding_add_emsa_pkcs1_v15_sha512(pad, p);
+            break;
+        default:
+            gk_err_cipher("RSA unsuporrt hash type: 0x%x.\n", pad->hash_type);
+            return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    return GK_SUCCESS;
+}
+
+/* *****************************************************************
+                                  +-----------+
+                                  |     M     |
+                                  +-----------+
+                                        |
+                                        V
+                                       Hash
+                                        |
+                                        V
+                         +--------+----------+----------+
+                   M' =  |Padding1|  mHash   |   salt   |
+                         +--------+----------+----------+
+                                        |
+            +--------+----------+       V
+     DB =   |Padding2|maskedseed|      Hash
+            +--------+----------+       |
+                    |                    |
+                    V                    |      +--+
+                    xor <----- MGF <----|      |bc|
+                    |                    |      +--+
+                    |                    |      |
+                    V                    V      V
+            +-------------------+----- -------+--+
+    EM =    |    maskedDB       |  maskedseed |bc|
+            +-------------------+-------------+--+
+ ***************************************************************** */
+static gk_s32 rsa_padding_add_pkcs1_pss_hash(rsa_padding_s *pad, rsa_pkcs1_pss_s *pss)
+{
+    gk_s32 ret;
+    gk_u32 mlen, index;
+    gk_u8 *ptr_m = GK_NULL;
+    gk_handle hash_handle = 0;
+    gk_cipher_hash_attr hash_attr;
+
+    mlen = pss->slen + pad->hlen + 8; /* 8 */
+    ptr_m = (gk_u8 *)memalign(ARCH_DMA_MINALIGN, mlen);
+    rsa_func_fail_return(ptr_m == GK_NULL, GK_ERR_CIPHER_INVALID_POINT, memalign);
+
+    /* M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt */
+    index = 0;
+    crypto_memset(ptr_m, mlen, 0x00, 8); /* 8 clean size */
+    index += 8; /* 8 */
+    crypto_memcpy(&ptr_m[index], mlen - index, pad->in_data, pad->in_len);
+    index += pad->in_len;
+    crypto_memcpy(&ptr_m[index], mlen - index, pss->salt, pss->slen);
+    index += pss->slen;
+
+    crypto_memset(&hash_attr, sizeof(hash_attr), 0, sizeof(gk_cipher_hash_attr));
+    hash_attr.sha_type = pad->hash_type;
+    ret = gk_api_cipher_hash_init(&hash_attr, &hash_handle) ||
+          gk_api_cipher_hash_update(hash_handle, ptr_m, index) ||
+          gk_api_cipher_hash_final(hash_handle, pss->masked_seed);
+    free(ptr_m); /* Must free ptr_m befort return */
+    ptr_m = GK_NULL;
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, gk_api_cipher_hash_final);
+
+    /* formula: maskedDB = DB xor dbMask, DB = PS || 0x01 || salt */
+    index = 0;
+    crypto_memset(&pss->masked_db[index],
+        pss->key_len - index, 0x00, pss->key_len - pss->slen - pad->hlen - 2); /* 2 */
+    index += pss->key_len - pss->slen - pad->hlen - 2; /* 2 */
+    pss->masked_db[index++] = 0x01;
+    crypto_memcpy(&pss->masked_db[index], pss->key_len - index, pss->salt, pss->slen);
+    ret = rsa_pkcs1_mgf1(pad->hash_type,
+        pss->masked_seed, pad->hlen, pss->masked_db, pss->key_len - pad->hlen - 1);
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_pkcs1_mgf1);
+
+    pad->out_data[pss->key_len - 1] = 0xBC;
+
+    if (pss->msb_bits)
+        pad->out_data[0] &= 0xFF >> (8 - pss->msb_bits); /* 8 */
+
+    return ret;
+}
+
+static gk_s32 rsa_padding_add_pkcs1_pss(rsa_padding_s *pad)
+{
+    rsa_pkcs1_pss_s pss;
+    gk_s32 ret;
+
+    crypto_memset(&pss, sizeof(rsa_pkcs1_pss_s), 0, sizeof(rsa_pkcs1_pss_s));
+    pss.slen = pad->hlen;
+    pss.key_len = (pad->em_bit + 7) / 8; /* 7, 8 */
+    pss.msb_bits = (pad->em_bit - 1) & 0x07;
+
+    pad->out_len = pss.key_len;
+
+    if (pss.key_len < (pad->hlen + pss.slen + 2)) { /* 2 */
+        gk_err_cipher("message too long\n");
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    if (pss.msb_bits == 0) {
+        *pad->out_data++ = 0;
+        pss.key_len--;
+    }
+
+    pss.masked_db = pad->out_data;
+    pss.masked_seed = pad->out_data + pss.key_len - pad->hlen - 1;
+
+    /* Generate a random octet string salt of length sLen */
+    ret = mbedtls_get_random_number(GK_NULL, pss.salt, pss.slen);
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, mbedtls_get_random_number);
+
+    return rsa_padding_add_pkcs1_pss_hash(pad, &pss);
+}
+
+static gk_s32 rsa_padding_check_pkcs1_oaep(rsa_padding_s *pad)
+{
+    gk_s32 ret;
+    gk_u32 i;
+    const gk_s8 *l_hash = g_empty_l_sha1;
+    gk_u8 *ptr_seed = GK_NULL;
+    gk_u8 *ptr_db = GK_NULL;
+    gk_u8 *masked_db = GK_NULL;
+
+    if (pad->hash_type == GK_CIPHER_HASH_TYPE_SHA224) {
+        l_hash = g_empty_l_sha224;
+    } else if (pad->hash_type == GK_CIPHER_HASH_TYPE_SHA256) {
+        l_hash = g_empty_l_sha256;
+    } else if (pad->hash_type == GK_CIPHER_HASH_TYPE_SHA384) {
+        l_hash = g_empty_l_sha384;
+    } else if (pad->hash_type == GK_CIPHER_HASH_TYPE_SHA512) {
+        l_hash = g_empty_l_sha512;
+    }
+
+    if (pad->klen < 2 * pad->hlen + 2) { /* 2 */
+        gk_err_cipher("input_len is invalid.\n");
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    if (pad->in_data[0] != 0x00) {
+        gk_err_cipher("EM[0] != 0.\n");
+        return GK_ERR_CIPHER_FAILED_DECRYPT;
+    }
+
+    pad->out_len = 0;
+    masked_db = pad->in_data + pad->hlen + 1;
+    ptr_seed = pad->in_data + 1;
+    ptr_db = pad->in_data + pad->hlen + 1;
+    ret = rsa_pkcs1_mgf1(pad->hash_type, masked_db, pad->klen - pad->hlen - 1, ptr_seed, pad->hlen);
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_pkcs1_mgf1);
+
+    ret = rsa_pkcs1_mgf1(pad->hash_type, ptr_seed, pad->hlen, ptr_db, pad->klen - pad->hlen - 1);
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_pkcs1_mgf1);
+
+    ret = memcmp(ptr_db, l_hash, pad->hlen);
+    rsa_func_fail_return(ret != 0, GK_ERR_CIPHER_FAILED_DECRYPT, memcmp);
+
+    for (i = pad->hlen; i < pad->klen - pad->hlen - 1; i++) {
+        if ((ptr_db[i] == 0x01)) {
+            crypto_memcpy(pad->out_data, pad->klen, ptr_db + i + 1, pad->klen - pad->hlen - i - 2); /* 2 */
+            pad->out_len = pad->klen - pad->hlen - i - 2; /* 2 */
+            break;
+        }
+    }
+    if (i >= pad->klen - pad->hlen - 1) {
+        gk_err_cipher("PS error.\n");
+        return GK_ERR_CIPHER_FAILED_DECRYPT;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 rsa_padding_check_pkcs1_v15(rsa_padding_s *pad)
+{
+    gk_u32 index = 0;
+
+    if (pad->klen < 11) { /* 11 pad->klen max size */
+        gk_err_cipher("input_len is invalid.\n");
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    if (pad->in_data[index] != 0x00) {
+        gk_err_cipher("EM[0] != 0x00.\n");
+        return GK_ERR_CIPHER_FAILED_DECRYPT;
+    }
+
+    index++;
+    if (pad->in_data[index] != 0x02) {
+        gk_err_cipher("EM[1] != 0x02.\n");
+        return GK_ERR_CIPHER_FAILED_DECRYPT;
+    }
+
+    index++;
+    for (; index < pad->klen; index++) {
+        /* The length of PS is large than 8 octets */
+        if ((index >= 10) && (pad->in_data[index] == 0x00)) { /* 10 */
+            crypto_memcpy(pad->out_data, pad->klen, &pad->in_data[index + 1], pad->klen - 1 - index);
+            pad->out_len = pad->klen - 1 - index;
+            break;
+        }
+    }
+
+    if (index >= pad->klen) {
+        gk_err_cipher("PS error.\n");
+        return GK_ERR_CIPHER_FAILED_DECRYPT;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 rsa_padding_check_pkcs1_type(rsa_padding_s *pad)
+{
+    gk_u8 *key_eb = pad->in_data;
+
+    if (*key_eb != 0x00) {
+        gk_err_cipher("EB[0] != 0x00.\n");
+        return GK_ERR_CIPHER_FAILED_DECRYPT;
+    }
+
+    key_eb++;
+    if (*key_eb != pad->key_bt) {
+        gk_err_cipher("EB[1] != BT(0x%x).\n", pad->key_bt);
+        return GK_ERR_CIPHER_FAILED_DECRYPT;
+    }
+
+    key_eb++;
+    if (pad->key_bt == 0x00) {
+        for (; key_eb < pad->in_data + pad->in_len - 1; key_eb++) {
+            if ((*key_eb == 0x00) && (*(key_eb + 1) != 0))
+                break;
+        }
+    } else if (pad->key_bt == 0x01) {
+        for (; key_eb < pad->in_data + pad->in_len - 1; key_eb++) {
+            if (*key_eb == 0xFF) {
+                continue;
+            } else if (*key_eb == 0x00) {
+                break;
+            } else {
+                key_eb = pad->in_data + pad->in_len - 1;
+                break;
+            }
+        }
+    } else if (pad->key_bt == 0x02) {
+        for (; key_eb < pad->in_data + pad->in_len - 1; key_eb++) {
+            if (*key_eb == 0x00)
+                break;
+        }
+    } else {
+        gk_err_cipher("BT(0x%x) is invalid.\n", pad->key_bt);
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    if (key_eb >= (pad->in_data + pad->in_len - 1)) {
+        gk_err_cipher("PS Error.\n");
+        return GK_ERR_CIPHER_FAILED_DECRYPT;
+    }
+
+    key_eb++;
+    pad->out_len = pad->in_data + pad->klen - key_eb;
+    crypto_memcpy(pad->out_data, pad->klen, key_eb, pad->out_len);
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 rsa_padding_check_emsa_pkcs1_v15_type(rsa_padding_s *pad, gk_u8 *p)
+{
+    gk_s32 ret;
+    gk_u32 len;
+
+    len = pad->klen - (gk_u32)(p - pad->in_data);
+
+    switch (pad->hash_type) {
+        case GK_CIPHER_HASH_TYPE_SHA1:
+            rsa_not_equal_return(len, 35, GK_FAILURE); /* 35 len size */
+            ret = memcmp(p, ASN1_HASH_SHA1, 15); /* 15 compare size */
+            rsa_func_fail_return(ret != 0, GK_FAILURE, memcmp);
+            crypto_memcpy(pad->out_data, pad->klen, p + 15, pad->hlen); /* 15 copy shift */
+            break;
+        case GK_CIPHER_HASH_TYPE_SHA224:
+            rsa_not_equal_return(len, (19 + pad->hlen), GK_FAILURE); /* len size: 19 + pad->hlen */
+            ret = memcmp(p, ASN1_HASH_SHA224, 19); /* 19 compare size */
+            rsa_func_fail_return(ret != 0, GK_FAILURE, memcmp);
+            crypto_memcpy(pad->out_data, pad->klen, p + 19, pad->hlen); /* 19 copy shift */
+            break;
+        case GK_CIPHER_HASH_TYPE_SHA256:
+            rsa_not_equal_return(len, (19 + pad->hlen), GK_FAILURE); /* len size: 19 + pad->hlen */
+            ret = memcmp(p, ASN1_HASH_SHA256, 19); /* 19 compare size */
+            rsa_func_fail_return(ret != 0, GK_FAILURE, memcmp);
+            crypto_memcpy(pad->out_data, pad->klen, p + 19, pad->hlen); /* 19 copy shift */
+            break;
+        case GK_CIPHER_HASH_TYPE_SHA384:
+            rsa_not_equal_return(len, (19 + pad->hlen), GK_FAILURE); /* len size: 19 + pad->hlen */
+            ret = memcmp(p, ASN1_HASH_SHA384, 19); /* 19 compare size */
+            rsa_func_fail_return(ret != 0, GK_FAILURE, memcmp);
+            crypto_memcpy(pad->out_data, pad->klen, p + 19, pad->hlen); /* 19 copy shift */
+            break;
+        case GK_CIPHER_HASH_TYPE_SHA512:
+            rsa_not_equal_return(len, (19 + pad->hlen), GK_FAILURE); /* len size: 19 + pad->hlen */
+            ret = memcmp(p, ASN1_HASH_SHA512, 19); /* 19 compare size */
+            rsa_func_fail_return(ret != 0, GK_FAILURE, memcmp);
+            crypto_memcpy(pad->out_data, pad->klen, p + 19, pad->hlen); /* 19 copy shift */
+            break;
+        default:
+            gk_err_cipher("RSA unsuporrt hash type: 0x%x.\n", pad->hash_type);
+            return GK_ERR_CIPHER_INVALID_PARA;
+    }
+    return ret;
+}
+
+static gk_s32 rsa_padding_check_emsa_pkcs1_v15(rsa_padding_s *pad)
+{
+    gk_u8 *p = pad->in_data;
+
+    pad->out_len = pad->hlen;
+
+    /* formula: EM = 01 || PS || 00 || T */
+    if (*p++ != 0) {
+        gk_err_cipher("RSA EM[0] must be 0\n");
+        return GK_FAILURE;
+    }
+
+    if (*p++ != RSA_SIGN) {
+        gk_err_cipher("RSA EM PS error\n");
+        return GK_FAILURE;
+    }
+
+    while (*p != 0) {
+        if (p >= pad->in_data + pad->klen - 1 || *p != 0xFF) {
+            gk_err_cipher("RSA PS error\n");
+            return GK_FAILURE;
+        }
+        p++;
+    }
+    p++; // skip 0x00
+
+    return rsa_padding_check_emsa_pkcs1_v15_type(pad, p);
+}
+
+static gk_s32 rsa_padding_check_pkcs1_pss_hash(rsa_padding_s *pad, gk_u8 *mhash, rsa_pkcs1_pss_s *pss)
+{
+    gk_s32 ret;
+    gk_u32 mlen;
+    gk_u8 *ptr_m = GK_NULL;
+    gk_handle hash_handle = 0;
+    gk_cipher_hash_attr hash_attr;
+    gk_u8 arr_h[HASH_RESULT_MAX_LEN] = {0};
+
+    mlen = pss->slen + pad->hlen + 8; /* 8 */
+    ptr_m = (gk_u8 *)cipher_malloc(mlen);
+    rsa_func_fail_return(ptr_m == GK_NULL, GK_ERR_CIPHER_INVALID_POINT, cipher_malloc);
+    crypto_memset(ptr_m, mlen, 0, mlen);
+
+    /* M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt */
+    crypto_memset(ptr_m, mlen, 0x00, 8); /* 8, 0 counts */
+    crypto_memcpy(&ptr_m[8], mlen - 8, mhash, pad->hlen); /* 8, 0 counts */
+    crypto_memcpy(&ptr_m[8 + pad->hlen], mlen - 8 - pad->hlen, pss->salt, pss->slen); /* 8, 0 counts */
+
+    crypto_memset(&hash_attr, sizeof(hash_attr), 0, sizeof(gk_cipher_hash_attr));
+    hash_attr.sha_type = pad->hash_type;
+    ret = gk_api_cipher_hash_init(&hash_attr, &hash_handle) ||
+          gk_api_cipher_hash_update(hash_handle, ptr_m, mlen) ||
+          gk_api_cipher_hash_final(hash_handle, arr_h);
+    free(ptr_m); /* Must free ptr_m befort return */
+    ptr_m = GK_NULL;
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, gk_api_cipher_hash_final);
+
+    ret = crypto_memcmp(arr_h, pss->masked_seed, pad->hlen);
+    rsa_func_fail_return(ret != 0, GK_FAILURE, crypto_memcmp);
+
+    return ret;
+}
+
+static gk_s32 rsa_padding_check_pkcs1_pss(rsa_padding_s *pad, gk_u8 *mhash)
+{
+    gk_u32 ret;
+    gk_u32 index, tmp_len;
+    rsa_pkcs1_pss_s pss;
+
+    crypto_memset(&pss, sizeof(rsa_pkcs1_pss_s), 0, sizeof(rsa_pkcs1_pss_s));
+    pss.slen = pad->hlen;
+    pss.key_len = (pad->em_bit + 7) / 8; /* 7, 8 */
+    pss.msb_bits = (pad->em_bit - 1) & 0x07;
+
+    if (pss.key_len < (pad->hlen + pss.slen + 2)) { /* 2 */
+        gk_err_cipher("message too long\n");
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    if (pad->in_data[0] & (0xFF << pss.msb_bits)) {
+        gk_err_cipher("inconsistent, EM[0] invalid\n");
+        return GK_FAILURE;
+    }
+
+    if (pss.msb_bits == 0) {
+        pad->in_data++;
+        pss.key_len--;
+    }
+
+    pss.masked_db = pad->in_data;
+    pss.masked_seed = pad->in_data + pss.key_len - pad->hlen - 1;
+
+    if (pad->in_data[pss.key_len - 1] != 0xBC) {
+        gk_err_cipher("inconsistent, EM[key_len - 1] != 0xBC\n");
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    /* formula: maskedDB = DB xor dbMask, DB = PS || 0x01 || salt */
+    ret = rsa_pkcs1_mgf1(pad->hash_type, pss.masked_seed,
+        pad->hlen, pss.masked_db, pss.key_len - pad->hlen - 1);
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_pkcs1_mgf1);
+
+    if (pss.msb_bits)
+        pss.masked_db[0] &= 0xFF >> (8 - pss.msb_bits); /* 8 */
+
+    tmp_len = pss.key_len - pss.slen - pad->hlen - 2; /* 2 */
+    if (tmp_len >= CIPHER_MAX_RSA_KEY_LEN - 1) { /* -1 is for index++, avoid masked_db overflow */
+        gk_err_cipher("operate masked_db maybe overflow %u\n", tmp_len);
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    for (index = 0; index < tmp_len; index++) {
+        if (pss.masked_db[index] != 0x00) {
+            break;
+        }
+    }
+    pss.slen = pss.key_len - pad->hlen - index - 2;
+
+    rsa_not_equal_return(pss.masked_db[index], 0x01, GK_FAILURE);
+    index++;
+    crypto_memcpy(pss.salt, sizeof(pss.salt), &pss.masked_db[index], pss.slen);
+
+    return rsa_padding_check_pkcs1_pss_hash(pad, mhash, &pss);
+}
+
+static gk_s32 rsa_pub_enc_pad_init(rsa_padding_s *pad, const gk_cipher_rsa_pub_encrypt *rsa_enc,
+    gk_cipher_rsa_crypt *rsa_crypt, gk_u8 *arr_em, gk_u32 em_len)
+{
+    gk_s32 ret;
+
+    if (em_len < rsa_crypt->in_len) {
+        gk_err_cipher("buf len %u < in len %u\n", em_len, rsa_crypt->in_len);
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    crypto_memset(pad, sizeof(rsa_padding_s), 0, sizeof(rsa_padding_s));
+    pad->in_data = (gk_u8 *)rsa_crypt->in;
+    pad->in_len = rsa_crypt->in_len;
+    pad->out_data = arr_em;
+    ret = rsa_get_attr(rsa_enc->scheme, rsa_enc->pub_key.n_len, pad);
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_get_attr);
+    inlet_var_over_max_return(pad->in_len, pad->klen);
+
+    return ret;
+}
+
+static gk_s32 rsa_pri_dec_pad_init(rsa_padding_s *pad, const gk_cipher_rsa_private_encrypt *rsa_decrypt,
+    gk_cipher_rsa_crypt *rsa_crypt, gk_u8 *arr_em, gk_u32 em_len)
+{
+    gk_s32 ret;
+
+    if (em_len < rsa_crypt->in_len) {
+        gk_err_cipher("buf len %u < in len %u\n", em_len, rsa_crypt->in_len);
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    crypto_memset(pad, sizeof(rsa_padding_s), 0, sizeof(rsa_padding_s));
+    pad->in_data = arr_em;
+    pad->in_len = rsa_crypt->in_len;
+    pad->out_data = rsa_crypt->out;
+    ret = rsa_get_attr(rsa_decrypt->scheme, rsa_decrypt->private_key.n_len, pad);
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_get_attr);
+    rsa_not_equal_return(pad->in_len, pad->klen, GK_ERR_CIPHER_INVALID_PARA);
+
+    return ret;
+}
+
+static gk_s32 rsa_pri_enc_pad_init(rsa_padding_s *pad, const gk_cipher_rsa_private_encrypt *rsa_encrypt,
+    gk_cipher_rsa_crypt *rsa_crypt, gk_u8 *arr_em, gk_u32 em_len)
+{
+    gk_s32 ret;
+
+    if (em_len < rsa_crypt->in_len) {
+        gk_err_cipher("buf len %u < in len %u\n", em_len, rsa_crypt->in_len);
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    crypto_memset(pad, sizeof(rsa_padding_s), 0, sizeof(rsa_padding_s));
+    pad->in_data = (gk_u8 *)rsa_crypt->in;
+    pad->in_len = rsa_crypt->in_len;
+    pad->out_data = arr_em;
+    ret = rsa_get_attr(rsa_encrypt->scheme, rsa_encrypt->private_key.n_len, pad);
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_get_attr);
+    inlet_var_over_max_return(pad->in_len, pad->klen);
+
+    return ret;
+}
+
+static gk_s32 rsa_pub_dec_pad_init(rsa_padding_s *pad, const gk_cipher_rsa_pub_encrypt *rsa_decrypt,
+    gk_cipher_rsa_crypt *rsa_crypt, gk_u8 *arr_em, gk_u32 em_len)
+{
+    gk_s32 ret;
+
+    if (em_len < rsa_crypt->in_len) {
+        gk_err_cipher("buf len %u < in len %u\n", em_len, rsa_crypt->in_len);
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    crypto_memset(pad, sizeof(rsa_padding_s), 0, sizeof(rsa_padding_s));
+    pad->in_data = arr_em;
+    pad->in_len = rsa_crypt->in_len;
+    pad->out_data = rsa_crypt->out;
+    ret = rsa_get_attr(rsa_decrypt->scheme, rsa_decrypt->pub_key.n_len, pad);
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_get_attr);
+    rsa_not_equal_return(pad->in_len, pad->klen, GK_FAILURE);
+
+    return ret;
+}
+
+static gk_s32 rsa_sign_pad_init(rsa_padding_s *pad,
+    const gk_cipher_rsa_sign *rsa_sign, gk_cipher_sign_data *sign_data, rsa_sign_buf *sign_buf)
+{
+    gk_s32 ret;
+    gk_cipher_hash_attr hash_attr;
+    gk_handle hash_handle;
+
+    crypto_memset(pad, sizeof(rsa_padding_s), 0, sizeof(rsa_padding_s));
+    ret = rsa_get_attr(rsa_sign->scheme, rsa_sign->private_key.n_len, pad);
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_get_attr);
+    pad->out_data = sign_buf->arr_em;
+    pad->in_len = pad->hlen;
+
+    /* hash is NULl, need to calc by self */
+    if (sign_data->hash_data != GK_NULL) {
+        pad->in_data = (gk_u8 *)sign_data->hash_data;
+    } else {
+        hash_attr.sha_type = pad->hash_type;
+        ret = gk_api_cipher_hash_init(&hash_attr, &hash_handle) ||
+              gk_api_cipher_hash_update(hash_handle, (gk_u8 *)sign_data->in, sign_data->in_len) ||
+              gk_api_cipher_hash_final(hash_handle, sign_buf->sign_hash);
+        rsa_func_fail_return(ret != GK_SUCCESS, ret, gk_api_cipher_hash_final);
+        pad->in_data = sign_buf->sign_hash;
+    }
+
+    return ret;
+}
+
+static gk_s32 rsa_verify_pad_init(rsa_padding_s *pad, const gk_cipher_rsa_verify *rsa_verify,
+    gk_cipher_verify_data *verify_data, rsa_sign_buf *sign_buf)
+{
+    gk_s32 ret;
+
+    crypto_memset(pad, sizeof(rsa_padding_s), 0, sizeof(rsa_padding_s));
+    ret = rsa_get_attr(rsa_verify->scheme, rsa_verify->pub_key.n_len, pad);
+    pad->in_data = sign_buf->arr_em;
+    pad->in_len = verify_data->sign_len;
+    pad->out_data = sign_buf->sign_hash;
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_get_attr);
+    rsa_not_equal_return(verify_data->sign_len, pad->klen, GK_FAILURE);
+
+    ret = rsa_public(&rsa_verify->pub_key, verify_data->sign, pad->in_data);
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_public);
+
+    return ret;
+}
+
+static gk_u8 *rsa_verify_get_hash(gk_cipher_verify_data *verify_data,
+    gk_u8 *arr_hash, gk_u32 hash_len, gk_cipher_hash_type hash_type)
+{
+    gk_u8 *ptr_hash = GK_NULL;
+    gk_cipher_hash_attr hash_attr;
+    gk_handle hash_handle;
+
+    if (verify_data->hash_data != GK_NULL) {
+        ptr_hash = (gk_u8 *)verify_data->hash_data;
+    } else {
+        gk_s32 ret;
+
+        crypto_memset(&hash_attr, sizeof(hash_attr), 0, sizeof(gk_cipher_hash_attr));
+        hash_attr.sha_type = hash_type;
+        ret = gk_api_cipher_hash_init(&hash_attr, &hash_handle) ||
+              gk_api_cipher_hash_update(hash_handle, (gk_u8 *)verify_data->in, verify_data->in_len) ||
+              gk_api_cipher_hash_final(hash_handle, arr_hash);
+        if (ret != GK_SUCCESS) {
+            gk_err_cipher("Calucate hash failed.\n");
+            return GK_NULL;
+        }
+        ptr_hash = arr_hash;
+    }
+
+    return ptr_hash;
+}
+
+gk_s32 gk_api_cipher_rsa_pub_encrypt(
+    const gk_cipher_rsa_pub_encrypt *rsa_enc, gk_cipher_rsa_crypt *rsa_crypt)
+{
+    gk_s32 ret;
+    rsa_padding_s pad;
+    gk_u8 arr_em[CIPHER_MAX_RSA_KEY_LEN] = {0};
+
+    check_cipher_not_open_return();
+    inlet_var_is_null_return(rsa_enc);
+    inlet_var_is_null_return(rsa_crypt);
+    inlet_var_is_null_return(rsa_crypt->in);
+    inlet_var_is_zero_return(rsa_crypt->in_len);
+    inlet_var_is_null_return(rsa_crypt->out);
+    inlet_var_is_null_return(rsa_crypt->out_len);
+
+    ret = rsa_pub_enc_pad_init(&pad, rsa_enc, rsa_crypt, arr_em, sizeof(arr_em));
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_pub_enc_pad_init);
+
+    switch (rsa_enc->scheme) {
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_NO_PADDING:
+            /* if input_len < klen, padding 0 before input data */
+            pad.out_len = pad.klen;
+            crypto_memcpy(pad.out_data + (pad.klen - pad.in_len),
+                CIPHER_MAX_RSA_KEY_LEN - (pad.klen - pad.in_len), pad.in_data, pad.in_len);
+            break;
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_BLOCK_TYPE_0:
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_BLOCK_TYPE_1:
+            gk_err_cipher("RSA padding mode error, mode = 0x%x.\n", rsa_enc->scheme);
+            gk_err_cipher("For a public key encryption operation, the block type shall be 02.\n");
+            return GK_ERR_CIPHER_INVALID_PARA;
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_BLOCK_TYPE_2:
+            pad.key_bt = (gk_u8)(rsa_enc->scheme - GK_CIPHER_RSA_ENCRYPT_SCHEME_BLOCK_TYPE_0);
+            ret = rsa_padding_add_pkcs1_type(&pad);
+            rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_padding_add_pkcs1_type);
+            break;
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA1:
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA224:
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA256:
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA384:
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA512:
+            ret = rsa_padding_add_pkcs1_oaep(&pad);
+            rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_padding_add_pkcs1_oaep);
+            break;
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_PKCS1_V1_5:
+            ret = rsa_padding_add_pkcs1_v15(&pad);
+            rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_padding_add_pkcs1_v15);
+            break;
+        default:
+            gk_err_cipher("RSA padding mode error, mode = 0x%x.\n", rsa_enc->scheme);
+            return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    *rsa_crypt->out_len = pad.out_len;
+    return rsa_public(&rsa_enc->pub_key, pad.out_data, rsa_crypt->out);
+}
+
+gk_s32 gk_api_cipher_rsa_private_decrypt(
+    const gk_cipher_rsa_private_encrypt *rsa_decrypt, gk_cipher_rsa_crypt *rsa_crypt)
+{
+    gk_s32 ret;
+    gk_u8 arr_em[CIPHER_MAX_RSA_KEY_LEN] = {0};
+    rsa_padding_s pad;
+
+    check_cipher_not_open_return();
+    inlet_var_is_null_return(rsa_decrypt);
+    inlet_var_is_null_return(rsa_crypt->in);
+    inlet_var_is_null_return(rsa_crypt->out);
+    inlet_var_is_null_return(rsa_crypt->out_len);
+
+    ret = rsa_pri_dec_pad_init(&pad, rsa_decrypt, rsa_crypt, arr_em, sizeof(arr_em));
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_pri_dec_pad_init);
+
+    ret = rsa_private(&rsa_decrypt->private_key, rsa_decrypt->ca_type, rsa_crypt->in, pad.in_data);
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_private);
+
+    switch (rsa_decrypt->scheme) {
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_NO_PADDING:
+            pad.out_len = pad.in_len;
+            crypto_memcpy(pad.out_data, pad.klen, pad.in_data, pad.klen);
+            break;
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_BLOCK_TYPE_0:
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_BLOCK_TYPE_1:
+            gk_err_cipher("RSA padding mode error, mode = 0x%x.\n", rsa_decrypt->scheme);
+            gk_err_cipher("For a private key decryption operation, the block type shall be 02.\n");
+            return GK_ERR_CIPHER_INVALID_PARA;
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_BLOCK_TYPE_2:
+            pad.key_bt = (gk_u8)(rsa_decrypt->scheme - GK_CIPHER_RSA_ENCRYPT_SCHEME_BLOCK_TYPE_0);
+            ret = rsa_padding_check_pkcs1_type(&pad);
+            rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_padding_check_pkcs1_type);
+            break;
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA1:
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA224:
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA256:
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA384:
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA512:
+            ret = rsa_padding_check_pkcs1_oaep(&pad);
+            rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_padding_check_pkcs1_oaep);
+            break;
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_PKCS1_V1_5:
+            ret = rsa_padding_check_pkcs1_v15(&pad);
+            rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_padding_check_pkcs1_oaep);
+            break;
+        default:
+            gk_err_cipher("RSA scheme error, scheme = 0x%x.\n", rsa_decrypt->scheme);
+            return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    *rsa_crypt->out_len = pad.out_len;
+    return ret;
+}
+
+gk_s32 gk_api_cipher_rsa_private_encrypt(
+    const gk_cipher_rsa_private_encrypt *rsa_encrypt, gk_cipher_rsa_crypt *rsa_crypt)
+{
+    gk_s32 ret;
+    rsa_padding_s pad;
+    gk_u8 arr_em[CIPHER_MAX_RSA_KEY_LEN] = {0};
+
+    check_cipher_not_open_return();
+    inlet_var_is_null_return(rsa_encrypt);
+    inlet_var_is_null_return(rsa_crypt->in);
+    inlet_var_is_zero_return(rsa_crypt->in_len);
+    inlet_var_is_null_return(rsa_crypt->out);
+    inlet_var_is_null_return(rsa_crypt->out_len);
+
+    ret = rsa_pri_enc_pad_init(&pad, rsa_encrypt, rsa_crypt, arr_em, sizeof(arr_em));
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_pri_enc_pad_init);
+
+    switch (rsa_encrypt->scheme) {
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_NO_PADDING:
+            /* if input_len < klen, padding 0 before input data */
+            pad.out_len = pad.klen;
+            crypto_memcpy(pad.out_data + (pad.klen - pad.in_len),
+                CIPHER_MAX_RSA_KEY_LEN - (pad.klen - pad.in_len), pad.in_data, pad.in_len);
+            break;
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_BLOCK_TYPE_0:
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_BLOCK_TYPE_1:
+            pad.key_bt = (gk_u8)(rsa_encrypt->scheme - GK_CIPHER_RSA_ENCRYPT_SCHEME_BLOCK_TYPE_0);
+            ret = rsa_padding_add_pkcs1_type(&pad);
+            rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_padding_add_pkcs1_type);
+            break;
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_BLOCK_TYPE_2:
+            gk_err_cipher("RSA padding mode error, mode = 0x%x.\n", rsa_encrypt->scheme);
+            return GK_ERR_CIPHER_INVALID_PARA;
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA1:
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA224:
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA256:
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA384:
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA512:
+            ret = rsa_padding_add_pkcs1_oaep(&pad);
+            rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_padding_add_pkcs1_oaep);
+            break;
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_PKCS1_V1_5:
+            pad.key_bt = 0x01;
+            ret = rsa_padding_add_pkcs1_type(&pad);
+            rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_padding_add_pkcs1_type);
+            break;
+        default:
+            gk_err_cipher("RSA padding mode error, mode = 0x%x.\n", rsa_encrypt->scheme);
+            return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    rsa_not_equal_return(pad.out_len, pad.klen, GK_FAILURE);
+    *rsa_crypt->out_len = pad.out_len;
+
+    return rsa_private(&rsa_encrypt->private_key, rsa_encrypt->ca_type, pad.out_data, rsa_crypt->out);
+}
+
+gk_s32 gk_api_cipher_rsa_pub_decrypt(
+    const gk_cipher_rsa_pub_encrypt *rsa_decrypt, gk_cipher_rsa_crypt *rsa_crypt)
+{
+    gk_s32 ret;
+    gk_u8 arr_em[CIPHER_MAX_RSA_KEY_LEN] = {0};
+    rsa_padding_s pad;
+
+    check_cipher_not_open_return();
+    inlet_var_is_null_return(rsa_decrypt);
+    inlet_var_is_null_return(rsa_crypt->in);
+    inlet_var_is_zero_return(rsa_crypt->in_len);
+    inlet_var_is_null_return(rsa_crypt->out);
+    inlet_var_is_null_return(rsa_crypt->out_len);
+
+    ret = rsa_pub_dec_pad_init(&pad, rsa_decrypt, rsa_crypt, arr_em, sizeof(arr_em));
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_pub_dec_pad_init);
+
+    ret = rsa_public(&rsa_decrypt->pub_key, rsa_crypt->in, pad.in_data);
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_public);
+
+    switch (rsa_decrypt->scheme) {
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_NO_PADDING:
+            pad.out_len = pad.in_len;
+            crypto_memcpy(pad.out_data, pad.klen, pad.in_data, pad.klen);
+            break;
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_BLOCK_TYPE_0:
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_BLOCK_TYPE_1:
+            pad.key_bt = (gk_u8)(rsa_decrypt->scheme - GK_CIPHER_RSA_ENCRYPT_SCHEME_BLOCK_TYPE_0);
+            ret = rsa_padding_check_pkcs1_type(&pad);
+            rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_padding_check_pkcs1_type);
+            break;
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_BLOCK_TYPE_2:
+            gk_err_cipher("RSA padding mode error, mode = 0x%x.\n", rsa_decrypt->scheme);
+            return GK_ERR_CIPHER_INVALID_PARA;
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA1:
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA224:
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA256:
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA384:
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_OAEP_SHA512:
+            ret = rsa_padding_check_pkcs1_oaep(&pad);
+            rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_padding_check_pkcs1_oaep);
+            break;
+        case GK_CIPHER_RSA_ENCRYPT_SCHEME_RSAES_PKCS1_V1_5:
+            pad.key_bt = 0x01;
+            ret = rsa_padding_check_pkcs1_type(&pad);
+            rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_padding_check_pkcs1_type);
+            break;
+        default:
+            gk_err_cipher("RSA scheme error, scheme = 0x%x.\n", rsa_decrypt->scheme);
+            return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    *rsa_crypt->out_len = pad.out_len;
+    return ret;
+}
+
+gk_s32 gk_api_cipher_rsa_sign(
+    const gk_cipher_rsa_sign *rsa_sign, gk_cipher_sign_data *sign_data)
+{
+    gk_s32 ret;
+    rsa_padding_s pad;
+    rsa_sign_buf sign_buf;
+
+    check_cipher_not_open_return();
+    inlet_var_is_null_return(rsa_sign);
+    inlet_var_is_null_return(sign_data->sign);
+    inlet_var_is_null_return(sign_data->sign_len);
+    inlet_var_is_null_return(rsa_sign->private_key.n);
+
+    if ((sign_data->in == GK_NULL || sign_data->in_len == 0) && (sign_data->hash_data == GK_NULL)) {
+        gk_err_cipher("Invalid param\n");
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    memset(&sign_buf, 0, sizeof(rsa_sign_buf));
+    ret = rsa_sign_pad_init(&pad, rsa_sign, sign_data, &sign_buf);
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_sign_pad_init);
+
+    switch (rsa_sign->scheme) {
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA1:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA224:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA256:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA384:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA512:
+            ret = rsa_padding_add_emsa_pkcs1_v15(&pad);
+            rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_padding_add_emsa_pkcs1_v15);
+            break;
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA1:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA224:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA256:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA384:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA512:
+            pad.em_bit = rsa_get_bit_num(rsa_sign->private_key.n, pad.klen);
+            ret = rsa_padding_add_pkcs1_pss(&pad);
+            rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_padding_add_pkcs1_pss);
+            break;
+        default:
+            gk_err_cipher("invalid scheme; 0x%x\n", rsa_sign->scheme);
+            return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    rsa_not_equal_return(pad.out_len, pad.klen, GK_FAILURE);
+    *sign_data->sign_len = pad.out_len;
+
+    return rsa_private(&rsa_sign->private_key, rsa_sign->ca_type, pad.out_data, sign_data->sign);
+}
+
+gk_s32 gk_api_cipher_rsa_verify(
+    const gk_cipher_rsa_verify *rsa_verify, gk_cipher_verify_data *verify_data)
+{
+    gk_s32 ret;
+    rsa_padding_s pad;
+    gk_u8 *ptr_hash = GK_NULL;
+    rsa_sign_buf sign_buf;
+    gk_u8 arr_hash[HASH_RESULT_MAX_LEN] = {0};
+
+    check_cipher_not_open_return();
+    inlet_var_is_null_return(rsa_verify);
+    inlet_var_is_null_return(verify_data->sign);
+
+    if ((verify_data->in == GK_NULL || verify_data->in_len == 0) && (verify_data->hash_data == GK_NULL)) {
+        gk_err_cipher("Invalid param\n");
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    memset(&sign_buf, 0, sizeof(rsa_sign_buf));
+    ret = rsa_verify_pad_init(&pad, rsa_verify, verify_data, &sign_buf);
+    rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_verify_pad_init);
+
+    ptr_hash = rsa_verify_get_hash(verify_data, arr_hash, sizeof(arr_hash), pad.hash_type);
+    rsa_func_fail_return(ptr_hash == GK_NULL, GK_ERR_CIPHER_INVALID_POINT, rsa_verify_get_hash);
+
+    switch (rsa_verify->scheme) {
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA1:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA224:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA256:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA384:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA512:
+            ret = rsa_padding_check_emsa_pkcs1_v15(&pad);
+            rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_padding_check_emsa_pkcs1_v15);
+            ret = memcmp(ptr_hash, pad.out_data, pad.hlen);
+            rsa_func_fail_return(ret != 0, GK_ERR_CIPHER_FAILED_DECRYPT, memcmp);
+            break;
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA1:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA224:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA256:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA384:
+        case GK_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA512:
+            pad.em_bit = rsa_get_bit_num(rsa_verify->pub_key.n, pad.klen);
+            ret = rsa_padding_check_pkcs1_pss(&pad, ptr_hash);
+            rsa_func_fail_return(ret != GK_SUCCESS, ret, rsa_padding_check_pkcs1_pss);
+            break;
+        default:
+            gk_err_cipher("invalid scheme; 0x%x\n", rsa_verify->scheme);
+            return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    return ret;
+}
diff -uraN u-boot-2016.11/product/cipher/v2/api/types.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/api/types.h
--- u-boot-2016.11/product/cipher/v2/api/types.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/api/types.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,130 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __GK_TYPE_H__
+#define __GK_TYPE_H__
+
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+/*--------------------------------------------------------------------------------------------------------------*
+ * Defintion of basic data types. The data types are applicable to both the application layer and kernel codes. *                                             *
+ *--------------------------------------------------------------------------------------------------------------*/
+/*************************** Structure Definition ****************************/
+/** \addtogroup      Common_TYPE */
+/** @{ */  /** <!-- [Common_TYPE] */
+
+typedef unsigned char           gk_u8;
+typedef unsigned char           gk_uchar;
+typedef unsigned short          gk_u16;
+typedef unsigned int            gk_u32;
+typedef unsigned long           gk_ulong;
+
+typedef signed char             gk_s8;
+typedef short                   gk_s16;
+typedef int                     gk_s32;
+typedef long                    gk_slong;
+
+#ifndef _M_IX86
+typedef unsigned long long      gk_u64;
+typedef long long               gk_s64;
+#else
+typedef __int64                 gk_u64;
+typedef __int64                 gk_s64;
+#endif
+
+typedef char                    gk_char;
+typedef char*                   gk_pchar;
+
+typedef unsigned long           gk_ul;
+typedef signed long             gk_sl;
+
+typedef float                   gk_float;
+typedef double                  gk_double;
+#define gk_void                 void
+
+typedef unsigned long           gk_size_t;
+typedef unsigned long           gk_length_t;
+
+typedef gk_u32                  gk_handle;
+
+typedef unsigned int            gk_phys_addr_t;
+
+#ifdef CONFIG_ARCH_LP64_MODE
+typedef unsigned long long      gk_virt_addr_t;
+#else
+typedef unsigned int            gk_virt_addr_t;
+#endif
+
+/** Constant Definition */
+typedef enum {
+    GK_FALSE    = 0,
+    GK_TRUE     = 1,
+} gk_bool;
+
+#ifndef NULL
+#define NULL                0L
+#endif
+
+#define GK_NULL             0L
+#define GK_NULL_PTR         0L
+
+#define GK_SUCCESS          0
+#define GK_FAILURE          (-1)
+
+#define GK_INVALID_HANDLE   0xffffffff
+#define GK_INVALID_PTS      0xffffffff
+#define GK_INVALID_TIME     0xffffffff
+
+#define GK_OS_LINUX         0xabcd
+#define GK_OS_WIN32         0xcdef
+
+#ifdef _WIN32
+#define GK_OS_TYPE          GK_OS_WIN32
+#else
+#define __OS_LINUX__
+#define GK_OS_TYPE          GK_OS_LINUX
+#endif
+
+#ifdef GK_ADVCA_SUPPORT
+#define __INIT__
+#define __EXIT__
+#else
+#define __INIT__  __init
+#define __EXIT__  __exit
+#endif
+
+/**
+
+define of gk_handle :
+bit31                                                           bit0
+  |<----   16bit --------->|<---   8bit    --->|<---  8bit   --->|
+  |--------------------------------------------------------------|
+  |      GK_MOD_ID_E       |  mod defined data |     chnID       |
+  |--------------------------------------------------------------|
+
+mod defined data: private data define by each module(for example: sub-mod id), usually, set to 0.
+*/
+
+#define gk_handle_make_handle(mod, privatedata, chnid) \
+    (gk_handle)((((mod) & 0xffff) << 16) | ((((privatedata) & 0xff) << 8)) | (((chnid) & 0xff)))
+
+#define handle_get_mod_id(handle)     (((handle) >> 16) & 0xffff)
+#define handle_get_pri_data(handle)   (((handle) >> 8) & 0xff)
+#define handle_get_chn_id(handle)     (((handle)) & 0xff)
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __GK_TYPE_H__ */
+
diff -uraN u-boot-2016.11/product/cipher/v2/drv/compat/drv_compat.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/compat/drv_compat.c
--- u-boot-2016.11/product/cipher/v2/drv/compat/drv_compat.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/compat/drv_compat.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "cipher_adapt.h"
+
+gk_s32 gk_drv_compat_init(void)
+{
+    gk_s32 ret;
+
+    ret = drv_klad_init();
+    if (ret != GK_SUCCESS) {
+         return ret;
+    }
+
+    return GK_SUCCESS;
+}
+
+gk_s32 gk_drv_compat_deinit(void)
+{
+    drv_klad_deinit();
+
+    return GK_SUCCESS;
+}
+
diff -uraN u-boot-2016.11/product/cipher/v2/drv/compat/drv_compat.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/compat/drv_compat.h
--- u-boot-2016.11/product/cipher/v2/drv/compat/drv_compat.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/compat/drv_compat.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,12 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef GK_DRV_CPMPAT_H
+#define GK_DRV_CPMPAT_H
+
+s32 gk_drv_compat_init(void);
+s32 gk_drv_compat_deinit(void);
+
+#endif
+
diff -uraN u-boot-2016.11/product/cipher/v2/drv/compat/drv_klad.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/compat/drv_klad.c
--- u-boot-2016.11/product/cipher/v2/drv/compat/drv_klad.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/compat/drv_klad.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,238 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "cipher_adapt.h"
+#include "../../../otp/hal_otp.h"
+
+#define KLAD_REG_BASE_ADDR                      g_klad_base
+#define KLAD_REG_KLAD_CTRL                      (KLAD_REG_BASE_ADDR + 0x00)
+#define KLAD_REG_DAT_IN                         (KLAD_REG_BASE_ADDR + 0x10)
+#define KLAD_REG_ENC_OUT                        (KLAD_REG_BASE_ADDR + 0x20)
+#define KLAD_KEY_LEN                            4
+#define CIPHER_WAIT_IDEL_TIMES                  1000
+
+static gk_void *g_klad_base = GK_NULL;
+
+static gk_s32 hal_cipher_klad_config(gk_u32 chn_id,
+                                     gk_u32 opt_id,
+                                     gk_cipher_klad_target klad_target,
+                                     gk_bool is_decrypt)
+{
+    gk_s32 ret;
+    gk_u32 ctrl;
+
+    /* Load efuse or OTP key to KLAD */
+    ret = hal_efuse_otp_load_cipher_key(chn_id, opt_id);
+    if (ret != GK_SUCCESS)
+        return ret;
+
+    ctrl  = chn_id << 16;               /* 16: klad channel id */
+    ctrl |= (gk_u32)klad_target << 2;   /* 2: cipher klad */
+    ctrl |= (gk_u32)is_decrypt << 1;    /* decrypt */
+    ctrl |= 0x00;                       /* start */
+
+    (gk_void)hal_cipher_write_reg(KLAD_REG_KLAD_CTRL, ctrl);
+
+    return GK_SUCCESS;
+}
+
+static gk_void hal_cipher_start_klad(void)
+{
+    gk_u32 ctrl;
+
+    /* start */
+    (gk_void)hal_cipher_read_reg(KLAD_REG_KLAD_CTRL, &ctrl);
+    ctrl |= 0x01;
+    (gk_void)hal_cipher_write_reg(KLAD_REG_KLAD_CTRL, ctrl);
+}
+
+static gk_void hal_cipher_set_klad_data(gk_u32 *data_input, gk_u32 data_len)
+{
+    gk_u32 i;
+
+    for (i = 0; i < data_len; i++)
+        (gk_void)hal_cipher_write_reg(KLAD_REG_DAT_IN + i * KLAD_KEY_LEN, data_input[i]);
+}
+
+static gk_void hal_cipher_get_klad_data(gk_u32 *data_output)
+{
+    gk_u32 i;
+
+    for (i = 0; i < KLAD_KEY_LEN; i++)
+        (gk_void)hal_cipher_read_reg(KLAD_REG_ENC_OUT + i * KLAD_KEY_LEN, &data_output[i]);
+}
+
+static gk_s32 hal_cipher_wait_klad_done(void)
+{
+    gk_u32 try_count = 0;
+    gk_u32 ctrl;
+
+    do {
+        hal_cipher_read_reg(KLAD_REG_KLAD_CTRL, &ctrl);
+        if ((ctrl & 0x01) == 0x00)
+            return GK_SUCCESS;
+        try_count++;
+    } while (try_count < CIPHER_WAIT_IDEL_TIMES);
+
+    gk_err_cipher("Klad time out!\n");
+
+    return GK_FAILURE;
+}
+
+static gk_void hal_klad_init(gk_void)
+{
+    gk_u32 crg_value;
+    gk_u32 *sys_addr;
+
+    sys_addr = cipher_ioremap_nocache(CIPHER_KLAD_CRG_ADDR_PHY, 0x100);
+    if (sys_addr == GK_NULL) {
+        gk_err_cipher("ERROR: sys_addr ioremap with nocache failed!!\n");
+        return ;
+    }
+
+    hal_cipher_read_reg(sys_addr, &crg_value);
+    crg_value |= KLAD_CRG_RESET_BIT;   /* reset */
+    crg_value |= KLAD_CRG_CLOCK_BIT;   /* set the bit 0, clock opened */
+    hal_cipher_write_reg(sys_addr, crg_value);
+
+    /* clock select and cancel reset 0x30100 */
+    crg_value &= (~KLAD_CRG_RESET_BIT); /* cancel reset */
+    crg_value |= KLAD_CRG_CLOCK_BIT;    /* set the bit 0, clock opened */
+    hal_cipher_write_reg(sys_addr, crg_value);
+
+    cipher_iounmap(sys_addr);
+}
+
+gk_s32 drv_klad_init(gk_void)
+{
+    gk_s32 ret;
+
+    g_klad_base = cipher_ioremap_nocache(CIPHER_KLAD_REG_BASE_ADDR_PHY, 0x100);
+    if (g_klad_base == GK_NULL) {
+        gk_err_cipher("ERROR: osal_ioremap_nocache for KLAD failed!!\n");
+        return GK_FAILURE;
+    }
+
+    ret = hal_efuse_otp_init();
+    if (ret != GK_SUCCESS) {
+        cipher_iounmap(g_klad_base);
+        return ret;
+    }
+
+    hal_klad_init();
+
+    return GK_SUCCESS;
+}
+
+gk_void drv_klad_deinit(gk_void)
+{
+    if (g_klad_base != GK_NULL) {
+        cipher_iounmap(g_klad_base);
+        g_klad_base = GK_NULL;
+    }
+    if (g_efuse_otp_reg_base != GK_NULL) {
+        cipher_iounmap(g_efuse_otp_reg_base);
+        g_efuse_otp_reg_base = GK_NULL;
+    }
+    return ;
+}
+
+static gk_void drv_cipher_invbuf(gk_u8 *buf, gk_u32 u32len)
+{
+    gk_u32 i;
+    gk_u8 ch;
+
+    for (i = 0; i < u32len / 2; i++) { /* 2 */
+        ch = buf[i];
+        buf[i] = buf[u32len - i - 1];
+        buf[u32len - i - 1] = ch;
+    }
+}
+
+gk_s32 drv_cipher_klad_load_key(gk_u32 chn_id,
+                                gk_cipher_ca_type root_key,
+                                gk_cipher_klad_target klad_target,
+                                gk_u8 *data_input,
+                                gk_u32 key_len)
+{
+    gk_s32 ret;
+    gk_u32 i, opt_id;
+    gk_u32 key[KLAD_KEY_LEN] = {0};
+
+    crypto_memset(key, sizeof(key), 0, sizeof(key));
+
+    if ((root_key < GK_CIPHER_KEY_SRC_KLAD_1) ||
+        (root_key > GK_CIPHER_KEY_SRC_KLAD_3)) {
+        gk_err_cipher("Error: Invalid Root Key src 0x%x!\n", root_key);
+        return GK_FAILURE;
+    }
+
+    if (((key_len % 16) != 0) || (key_len == 0)) { /* key 16 align */
+        gk_err_cipher("Error: Invalid key len 0x%x!\n", key_len);
+        return GK_FAILURE;
+    }
+
+    opt_id = root_key - GK_CIPHER_KEY_SRC_KLAD_1 + 1;
+
+    ret = hal_cipher_klad_config(chn_id, opt_id, klad_target, GK_TRUE);
+    if (ret != GK_SUCCESS) {
+        gk_err_cipher("Error: cipher klad config failed!\n");
+        return GK_FAILURE;
+    }
+
+    for (i = 0; i < key_len / 16; i++) { /* key 16 align */
+        crypto_memcpy(key, 16, data_input + i * 16, 16); /* key 16 align */
+        hal_cipher_set_klad_data(key, KLAD_KEY_LEN);
+        hal_cipher_start_klad();
+        ret = hal_cipher_wait_klad_done();
+        if (ret != GK_SUCCESS) {
+            gk_err_cipher("Error: cipher klad wait done failed!\n");
+            return GK_FAILURE;
+        }
+    }
+
+    return GK_SUCCESS;
+
+}
+
+gk_s32 drv_cipher_klad_encrypt_key(gk_cipher_ca_type root_key,
+    gk_cipher_klad_target klad_target, gk_u32 *clean_key, gk_u32 *encrypt_key)
+{
+    gk_s32 ret;
+    gk_u32 opt_id;
+
+    if ((root_key < GK_CIPHER_KEY_SRC_KLAD_1) ||
+        (root_key >= GK_CIPHER_KEY_SRC_BUTT)) {
+        gk_err_cipher("Error: Invalid Root Key src 0x%x!\n", root_key);
+        return GK_FAILURE;
+    }
+
+    if ((clean_key == GK_NULL) || (encrypt_key == GK_NULL)) {
+        gk_err_cipher("Clean key or encrypt key is null.\n");
+        return GK_FAILURE;
+    }
+
+    opt_id = root_key - GK_CIPHER_KEY_SRC_KLAD_1 + 1;
+
+    ret = hal_cipher_klad_config(0, opt_id, GK_CIPHER_KLAD_TARGET_AES, GK_FALSE);
+    if (ret != GK_SUCCESS) {
+        gk_err_cipher("Error: cipher klad config failed!\n");
+        return GK_FAILURE;
+    }
+
+    if (klad_target == GK_CIPHER_KLAD_TARGET_RSA)
+        drv_cipher_invbuf((gk_u8*)clean_key, 16); /* 16 clean key len */
+
+    hal_cipher_set_klad_data(clean_key, KLAD_KEY_LEN);
+    hal_cipher_start_klad();
+    ret = hal_cipher_wait_klad_done();
+    if (ret != GK_SUCCESS) {
+        gk_err_cipher("Error: cipher klad wait done failed!\n");
+        return GK_FAILURE;
+    }
+    hal_cipher_get_klad_data(encrypt_key);
+
+    return GK_SUCCESS;
+}
+
diff -uraN u-boot-2016.11/product/cipher/v2/drv/compat/drv_klad.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/compat/drv_klad.h
--- u-boot-2016.11/product/cipher/v2/drv/compat/drv_klad.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/compat/drv_klad.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef DRV_KLAD_H
+#define DRV_KLAD_H
+
+#include "types.h"
+#include "common.h"
+#include "drv_cipher_ioctl.h"
+
+extern gk_void *g_efuse_otp_reg_base;
+
+gk_s32 drv_klad_init(gk_void);
+gk_void drv_klad_deinit(gk_void);
+
+gk_s32 drv_cipher_klad_load_key(gk_u32 chn_id,
+                                gk_cipher_ca_type root_key,
+                                gk_cipher_klad_target klad_target,
+                                gk_u8 *data_input,
+                                gk_u32 key_len);
+
+gk_s32 drv_cipher_klad_encrypt_key(gk_cipher_ca_type root_key,
+                                   gk_cipher_klad_target klad_target,
+                                   gk_u32 *clean_key,
+                                   gk_u32 *encrypt_key);
+
+#endif
\ No newline at end of file
diff -uraN u-boot-2016.11/product/cipher/v2/drv/drv_cipher_intf.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/drv_cipher_intf.c
--- u-boot-2016.11/product/cipher/v2/drv/drv_cipher_intf.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/drv_cipher_intf.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,204 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "cipher_adapt.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* End of #ifdef __cplusplus */
+
+gk_s32 drv_cipher_ioctl(gk_u32 cmd, gk_void *argp, gk_void *private_data)
+{
+    gk_s32 ret = GK_SUCCESS;
+
+    if (argp == GK_NULL) {
+        gk_err_cipher("Error, argp is NULL!\n");
+        return GK_FAILURE;
+    }
+
+    switch (cmd) {
+        case CMD_CIPHER_CREATEHANDLE: {
+            cipher_handle_s *handle = (cipher_handle_s *)argp;
+            ret = gk_drv_cipher_create_handle(handle,  private_data);
+            break;
+        }
+        case CMD_CIPHER_DESTROYHANDLE: {
+            gk_handle handle = *(gk_handle *)argp;
+            ret = gk_drv_cipher_destory_handle(handle);
+            break;
+        }
+        case CMD_CIPHER_CONFIGHANDLE_EX: {
+            cipher_config_ctrl_ex_s config_ex = *(cipher_config_ctrl_ex_s *)argp;
+            ret = gk_drv_cipher_config_chn_ex(config_ex.ci_handle, &config_ex);
+            break;
+        }
+        case CMD_CIPHER_ENCRYPT: {
+            cipher_data_s *data = (cipher_data_s *)argp;
+            ret = gk_drv_cipher_encrypt(data);
+            break;
+        }
+        case CMD_CIPHER_DECRYPT: {
+            cipher_data_s *data = (cipher_data_s *)argp;
+            ret = gk_drv_cipher_decrypt(data);
+            break;
+        }
+        case CMD_CIPHER_ENCRYPTMULTI: {
+            cipher_pkg_s *pkg = (cipher_pkg_s *)argp;
+            ret = gk_drv_cipher_encrypt_multi(pkg);
+            break;
+        }
+        case CMD_CIPHER_DECRYPTMULTI: {
+            cipher_pkg_s *pkg = (cipher_pkg_s *)argp;
+            ret = gk_drv_cipher_decrypt_multi(pkg);
+            break;
+        }
+#ifdef CIPHER_KLAD_SUPPORT
+        case CMD_CIPHER_KLAD_KEY: {
+            cipher_klad_key_s *klad_data = (cipher_klad_key_s *)argp;
+            ret = gk_drv_cipher_klad_encrypt_key(klad_data);
+            break;
+        }
+#endif
+        case CMD_CIPHER_GETTAG: {
+            cipher_tag_s *tag = (cipher_tag_s *)argp;
+            ret = gk_drv_cipher_get_tag(tag);
+            break;
+        }
+        case CMD_CIPHER_GETRANDOMNUMBER: {
+            cipher_rng_s *rng  = (cipher_rng_s *)argp;
+            ret = gk_drv_cipher_get_random_number(rng);
+            break;
+        }
+        case CMD_CIPHER_GETHANDLECONFIG_EX:  {
+            cipher_config_ctrl_ex_s *data = (cipher_config_ctrl_ex_s *)argp;
+            ret = gk_drv_cipher_get_handle_config_ex(data);
+            break;
+        }
+        case CMD_CIPHER_CALCHASHINIT: {
+            cipher_hash_data_s *hash_data = (cipher_hash_data_s*)argp;
+            ret = gk_drv_cipher_calc_hash_init(hash_data);
+            break;
+        }
+        case CMD_CIPHER_CALCHASHUPDATE: {
+            cipher_hash_data_s *hash_data = (cipher_hash_data_s*)argp;
+            ret = gk_drv_cipher_calc_hash_update(hash_data);
+            break;
+        }
+        case CMD_CIPHER_CALCHASHFINAL: {
+            cipher_hash_data_s *hash_data = (cipher_hash_data_s*)argp;
+            ret = gk_drv_cipher_calc_hash_final(hash_data);
+            break;
+        }
+        case CMD_CIPHER_CALCRSA: {
+            cipher_rsa_data_s *rsa_data = (cipher_rsa_data_s*)argp;
+            ret = gk_drv_cipher_calc_rsa(rsa_data);
+            break;
+        }
+#ifdef CONFIG_COMPAT
+#ifdef CONFIG_RSA_HARDWARE_SUPPORT
+        case CMD_CIPHER_COMPAT_CALCRSA: {
+            cipher_compat_rsa_data_s *compat_rsa_data = (cipher_compat_rsa_data_s*)argp;
+            cipher_rsa_data_s rsa_data;
+
+            rsa_data.input_data = u32_to_point(compat_rsa_data->input_via);
+            rsa_data.output_data = u32_to_point(compat_rsa_data->output_via);
+            rsa_data.rsa_k = u32_to_point(compat_rsa_data->rsa_k_via);
+            rsa_data.rsa_n = u32_to_point(compat_rsa_data->rsa_n_via);
+            rsa_data.rsa_k_len = compat_rsa_data->rsa_k_len;
+            rsa_data.rsa_n_len = compat_rsa_data->rsa_n_len;
+            rsa_data.data_len = compat_rsa_data->data_len;
+
+            ret = gk_drv_cipher_calc_rsa(&rsa_data);
+            break;
+        }
+#endif
+        case CMD_CIPHER_COMPAT_ENCRYPTMULTI: {
+            cipher_compat_pkg_s *compat_pkg = (cipher_compat_pkg_s *)argp;
+            cipher_pkg_s pkg;
+
+            pkg.ci_handle = compat_pkg->ci_handle;
+            pkg.pkg_num = compat_pkg->pkg_num;
+            pkg.cipher_data = u32_to_point(compat_pkg->pkg_via);
+
+            ret = gk_drv_cipher_encrypt_multi(&pkg);
+            break;
+        }
+        case CMD_CIPHER_COMPAT_DECRYPTMULTI: {
+            cipher_compat_pkg_s *compat_pkg = (cipher_compat_pkg_s *)argp;
+            cipher_pkg_s pkg;
+
+            pkg.ci_handle = compat_pkg->ci_handle;
+            pkg.pkg_num = compat_pkg->pkg_num;
+            pkg.cipher_data = u32_to_point(compat_pkg->pkg_via);
+
+            ret = gk_drv_cipher_decrypt_multi(&pkg);
+            break;
+        }
+#endif
+        default:
+            gk_err_cipher("Unsupport cmd, MOD_ID=0x%02X, NR=0x%02x, SIZE=0x%02x!\n",
+                ree_cipher_ioc_type (cmd), ree_cipher_ioc_nr (cmd), ree_cipher_ioc_size(cmd));
+            ret = GK_FAILURE;
+            break;
+    }
+
+    return ret;
+}
+
+gk_s32 cipher_module_init(gk_void)
+{
+    gk_s32 ret;
+
+    ret = drv_cipher_init();
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    ret = drv_rng_init();
+    if (ret != GK_SUCCESS) {
+        (gk_void)drv_cipher_deinit();
+        return ret;
+    }
+
+#ifdef CIPHER_KLAD_SUPPORT
+    ret = gk_drv_compat_init();
+    if (ret != GK_SUCCESS) {
+        (gk_void)drv_cipher_deinit();
+        (gk_void)drv_rng_deinit();
+        return ret;
+    }
+#endif
+
+    ret = drv_rsa_init();
+    if (ret != GK_SUCCESS) {
+        (gk_void)drv_cipher_deinit();
+        (gk_void)drv_rng_deinit();
+#ifdef CIPHER_KLAD_SUPPORT
+        (gk_void)gk_drv_compat_deinit();
+#endif
+        return ret;
+    }
+
+    return GK_SUCCESS;
+}
+
+gk_void cipher_module_exit(gk_void)
+{
+    (gk_void)drv_cipher_deinit();
+    (gk_void)drv_rng_deinit();
+    (gk_void)drv_rsa_deinit();
+
+#ifdef CIPHER_KLAD_SUPPORT
+    (gk_void)gk_drv_compat_deinit();
+#endif
+    return ;
+}
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* End of #ifdef __cplusplus */
diff -uraN u-boot-2016.11/product/cipher/v2/drv/include/drv_cipher.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/include/drv_cipher.h
--- u-boot-2016.11/product/cipher/v2/drv/include/drv_cipher.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/include/drv_cipher.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,253 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __GK_DRV_CIPHER_H__
+#define __GK_DRV_CIPHER_H__
+
+#include "types.h"
+#include "mpi_cipher.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif    /* __cplusplus */
+
+#define MAX_MULTI_PKG_NUM           128
+#define CIPHER_SOFT_CHAN_NUM        8
+#define CIPHER_INVALID_CHN          0xffffffff
+#define CIPHER_MAX_NODE_BUF_SIZE    0xFFFF0   /* 1M-16 */
+#define CIPHER_MAX_RSA_KEY_LEN      512
+#define HASH_OUTPUT_SIZE_WORD       (1600 / 8 / 4)    /* sha3 state */
+
+#define HDCP_KEY_RAM_SIZE           320
+#define HDCP_KEY_PRIME_SIZE         320
+#define HDCP_KEY_TOOL_FILE_SIZE     384
+#define HDCP_KEY_CHIP_FILE_SIZE     (HDCP_KEY_RAM_SIZE + 12)
+
+#define HASH_ALG_SHA2               0x01
+#define HASH_ALG_SHA3               0x02
+#define HASH_ALG_SM3                0x03
+
+#define HASH_MODE_RAW               0x01
+#define HASH_MODE_MAC               0x02
+#define HASH_MODE_SHAKE             0x03
+
+#define CPU_BIT_WIDTH_32            32
+#define CPU_BIT_WIDTH_64            64
+#define MY_CPU_BIT_WIDTH            sizeof(gk_size_t)
+
+typedef enum {
+    GK_DRV_HASH_STEP_UPDATE = 0x0,
+    GK_DRV_HASH_STEP_INIT   = 0x01,
+    GK_DRV_HASH_STEP_FINAL  = 0x02,
+} gk_drv_hash_step_e;
+
+typedef struct {
+    gk_handle ci_handle;
+    gk_cipher_attr cipher_atts;
+} cipher_handle_s;
+
+typedef struct {
+    gk_handle ci_handle;
+    gk_u32 src_phy_addr;
+    gk_u32 src_phy_addr_high;
+    gk_u32 dest_phy_addr;
+    gk_u32 dest_phy_addr_high;
+    gk_u32 data_length;
+} cipher_data_s;
+
+typedef struct {
+    gk_handle ci_handle;
+    gk_u32 pkg_num;
+    gk_u32 user_bit_width;
+    gk_cipher_data* cipher_data;
+} cipher_pkg_s;
+
+typedef struct {
+    gk_handle ci_handle;
+    gk_cipher_ctrl cipher_ctrl;
+} cipher_config_ctrl_s;
+
+typedef struct {
+    gk_handle ci_handle;
+    gk_u32 time_out;
+} cipher_wait_done_s;
+
+typedef struct {
+    gk_handle ci_handle;
+    gk_u32 key[12];                                 /* Key input, EK||AK||SK for SM1, 12 */
+    gk_u32 odd_key[8];                              /* Key input, Old Key, 8 */
+    gk_u32 iv[4];                                   /* Initialization vector (IV), 4 */
+    /* Encryption using advanced conditional access (CA) or decryption using keys */
+    gk_bool key_by_ca;
+    gk_cipher_ca_type ca_type;                /* Select keyladder type when using advanced CA */
+    gk_cipher_alg ci_alg;                     /* Cipher algorithm */
+    gk_cipher_bit_width bit_width;            /* Bit width for encryption or decryption */
+    gk_cipher_work_mode work_mode;            /* Operating mode */
+    gk_cipher_key_len key_len;             /* Key length */
+    /* control information exchange choices,
+     * we default all woulde be change except they have been in the choices */
+    gk_cipher_ctrl_chg_flag change_flags;
+    gk_cipher_sm1_round sm1_round;            /* SM1 round number, should be 8, 10, 12 or 14 */
+    /* IV lenght for CCM/GCM, which is an element of {4, 6, 8, 10, 12, 14, 16} for CCM,
+     * and is an element of [1-16] for GCM */
+    gk_u32 iv_len;
+    /* Tag lenght for CCM which is an element of {4, 6, 8, 10, 12, 14, 16} */
+    gk_u32 tag_len;
+    gk_u32 alen;                                    /* Associated data for CCM and GCM */
+    gk_u32 aphy_addr;
+    gk_u32 aphy_addr_high;                          /* Physical address of Associated data for CCM and GCM */
+} cipher_config_ctrl_ex_s;
+
+typedef struct {
+    gk_cipher_hash_type sha_type;
+    gk_u32 hard_chn;
+    gk_u32 sha_val[16]; /* 16 size */
+    gk_u32 data_phy;
+    gk_u32 data_phy_high;
+    gk_u32 data_len;
+} cipher_hash_data_s;
+
+typedef struct {
+    gk_cipher_hash_attr hash_attr;
+    gk_handle hash_handle;
+} cipher_hash_init_s;
+
+typedef struct {
+    gk_handle hash_handle;
+    gk_u8 *input_data;
+    gk_u32 input_data_len;
+} cipher_hash_update_s;
+
+typedef struct {
+    gk_handle hash_handle;
+    gk_u8 *output_hash;
+} cipher_hash_finish_s;
+
+typedef struct {
+    gk_u32 time_out_us;
+    gk_u32 ci_rng;
+} cipher_rng_s;
+
+typedef struct {
+    gk_handle ci_handle;
+    gk_u32 tag_len;
+    gk_u32 tag[4]; /* 4 tag size */
+} cipher_tag_s;
+
+typedef struct {
+    gk_u8 *input_data;
+    gk_u8 *output_data;
+    gk_u32 data_len;
+    gk_u8 *rsa_n;
+    gk_u8 *rsa_k;
+    gk_u16 rsa_n_len;
+    gk_u16 rsa_k_len;
+    gk_cipher_ca_type ca_type;               /* Select keyladder type when using advanced CA */
+} cipher_rsa_data_s;
+
+/** RSA private key struct */
+typedef struct {
+    gk_u8 *rsa_n;                      /*!<  public modulus    */
+    gk_u8 *rsa_e;                      /*!<  public exponent   */
+    gk_u8 *rsa_d;                      /*!<  private exponent  */
+    gk_u8 *rsa_p;                      /*!<  1st prime factor  */
+    gk_u8 *rsa_q;                      /*!<  2nd prime factor  */
+    gk_u8 *rsa_dp;                     /*!<  D % (P - 1)       */
+    gk_u8 *rsa_dq;                     /*!<  D % (Q - 1)       */
+    gk_u8 *rsa_qp;                     /*!<  1 / (Q % P)       */
+    gk_u16 rsa_n_len;                   /* length of public modulus */
+    gk_u16 rsa_e_len;                   /* length of public exponent */
+    gk_u16 rsa_d_len;                   /* length of private exponent */
+    gk_u16 rsa_p_len;                   /* length of 1st prime factor */
+    gk_u16 rsa_q_len;                   /* length of 2nd prime factor */
+    gk_u16 rsa_dp_len;                  /* length of D % (P - 1) */
+    gk_u16 rsa_dq_len;                  /* length of D % (Q - 1) */
+    gk_u16 rsa_qp_len;                  /* length of 1 / (Q % P) */
+} cipher_rsa_pri_key_s;
+
+typedef struct {
+    cipher_rsa_pri_key_s pri_key;
+    gk_u32 num_bits;
+    gk_u32 exponent;
+} cipher_rsa_key_s;
+
+typedef enum {
+    CIPHER_TEST_PRINT_PHY = 0x01,
+    CIPHER_TEST_PRINT_VIA,
+    CIPHER_TEST_MEMSET,
+    CIPHER_TEST_MEMCMP,
+    CIPHER_TEST_MEMCPY,
+    CIPHER_TEST_MEMCMP_PHY,
+    CIPHER_TEST_READ_REG,
+    CIPHER_TEST_WRITE_REG,
+    CIPHER_TEST_AES  = 0x10,
+    CIPHER_TEST_HMAC,
+    CIPHER_TEST_RSA,
+    CIPHER_TEST_HASH,
+    CIPHER_TEST_DES,
+    CIPHER_TEST_RSA_PRIM,
+    CIPHER_TEST_RSA_KG,
+    CIPHER_TEST_RND,
+    CIPHER_TEST_BUTT,
+} cipher_test_e;
+
+#ifdef CONFIG_COMPAT
+typedef struct {
+    gk_handle ci_handle;
+    gk_u32 pkg_num;
+    gk_u32 pkg_via;
+} cipher_compat_pkg_s;
+
+typedef struct {
+    gk_u32 input_via;
+    gk_u32 output_via;
+    gk_u32 data_len;
+    gk_u32 rsa_n_via;
+    gk_u32 rsa_k_via;
+    gk_u16 rsa_n_len;
+    gk_u16 rsa_k_len;
+} cipher_compat_rsa_data_s;
+#endif
+
+typedef struct {
+    gk_cipher_ca_type root_key;
+    gk_cipher_klad_target klad_target;
+    gk_u32 clean_key[4];   /* 4 key size */
+    gk_u32 encrypt_key[4]; /* 4 key size */
+    gk_u32 key_len;
+} cipher_klad_key_s;
+
+gk_s32 gk_drv_cipher_create_handle(cipher_handle_s *ci_handle, gk_void *file);
+gk_s32 gk_drv_cipher_config_chn(gk_u32 soft_chn_id, gk_cipher_ctrl *config);
+gk_s32 gk_drv_cipher_config_chn_ex(gk_handle ci_handle, cipher_config_ctrl_ex_s *config);
+gk_s32 gk_drv_cipher_get_handle_config(cipher_config_ctrl_s *cipher_config);
+gk_s32 gk_drv_cipher_get_handle_config_ex(cipher_config_ctrl_ex_s *cipher_config);
+gk_s32 gk_drv_cipher_get_iv(gk_u32 chn_id, gk_u32 iv[4]); /* 4 iv size */
+gk_s32 gk_drv_cipher_destory_handle(gk_handle cipher_chn);
+gk_s32 gk_drv_cipher_encrypt(cipher_data_s *ci_data);
+gk_s32 gk_drv_cipher_decrypt(cipher_data_s *ci_data);
+gk_s32 gk_drv_cipher_encrypt_multi(cipher_pkg_s *pkg);
+gk_s32 gk_drv_cipher_decrypt_multi(cipher_pkg_s *pkg);
+gk_s32 gk_drv_cipher_encrypt_multi_asyn(cipher_pkg_s *pkg);
+gk_s32 gk_drv_cipher_decrypt_multi_asyn(cipher_pkg_s *pkg);
+gk_s32 gk_drv_cipher_wait_done(cipher_wait_done_s *wait_done);
+gk_s32 gk_drv_cipher_hash_wait_done(gk_handle handle);
+gk_s32 gk_drv_cipher_get_random_number(cipher_rng_s *rng);
+gk_s32 gk_drv_cipher_soft_reset(gk_void);
+gk_s32 gk_drv_cipher_calc_hash_init(cipher_hash_data_s *cipher_hash_data);
+gk_s32 gk_drv_cipher_calc_hash_update(cipher_hash_data_s *cipher_hash_data);
+gk_s32 gk_drv_cipher_calc_hash_final(cipher_hash_data_s *cipher_hash_data);
+gk_s32 gk_drv_cipher_get_tag(cipher_tag_s *tag);
+gk_s32 gk_drv_cipher_calc_rsa(cipher_rsa_data_s *cipher_rsa_data);
+gk_s32 gk_drv_cipher_klad_encrypt_key(cipher_klad_key_s *klad_key);
+
+gk_void gk_drv_cipher_suspend(gk_void);
+gk_s32 gk_drv_cipher_resume(gk_void);
+
+#ifdef __cplusplus
+}
+#endif    /* __cplusplus */
+
+#endif    /* End of #ifndef __GK_DRV_CIPHER_H__ */
+
diff -uraN u-boot-2016.11/product/cipher/v2/drv/include/drv_cipher_ioctl.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/include/drv_cipher_ioctl.h
--- u-boot-2016.11/product/cipher/v2/drv/include/drv_cipher_ioctl.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/include/drv_cipher_ioctl.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __REE_DRV_CIPHER_IOCTL_H__
+#define __REE_DRV_CIPHER_IOCTL_H__
+
+#include "types.h"
+#include "mpi_cipher.h"
+
+gk_s32 cipher_module_init(gk_void);
+gk_void cipher_module_exit(gk_void);
+gk_s32 drv_cipher_ioctl(gk_u32 cmd, gk_void *argp, gk_void *private_data);
+
+typedef struct {
+    gk_u32 chn_id;
+    gk_char *open_status;
+    gk_char *alg;
+    gk_char *mode;
+    gk_u32 key_len;
+    gk_char *key_from;
+    gk_bool is_decrypt;
+    gk_u32 data_in_size;
+    gk_u32 data_in_addr;
+    gk_u32 data_out_size;
+    gk_u32 data_out_addr;
+    gk_bool in_int_all_en;
+    gk_bool in_int_en;
+    gk_bool in_int_raw;
+    gk_bool out_int_en;
+    gk_bool out_int_raw;
+    gk_u32 out_int_count;       /* CHANn_INT_OCNTCFG */
+    char iv_string[33];         /* 33 iv string size */
+} cipher_chn_status_s;
+
+#define REE_CIPHER_IOC_NA   0U
+#define REE_CIPHER_IOC_W    1U
+#define REE_CIPHER_IOC_R    2U
+#define REE_CIPHER_IOC_RW   3U
+
+#define ree_cipher_ioc(dir, type, nr, size) (((dir) << 30) | ((size) << 16) | ((type) << 8) | ((nr) << 0))
+
+#define ree_cipher_ior(type,  nr, size) ree_cipher_ioc(REE_CIPHER_IOC_R,  (type), (nr), sizeof(size))
+#define ree_cipher_iow(type,  nr, size) ree_cipher_ioc(REE_CIPHER_IOC_W,  (type), (nr), sizeof(size))
+#define ree_cipher_iowr(type, nr, size) ree_cipher_ioc(REE_CIPHER_IOC_RW, (type), (nr), sizeof(size))
+
+#define ree_cipher_ioc_dir(nr)  (((nr) >> 30) & 0x03)
+#define ree_cipher_ioc_type(nr) (((nr) >> 8)  & 0xFF)
+#define ree_cipher_ioc_nr(nr)   (((nr) >> 0)  & 0xFF)
+#define ree_cipher_ioc_size(nr) (((nr) >> 16) & 0x3FFF)
+
+#define GK_ID_CIPHER 100
+
+#ifdef __cplusplus
+extern "C"{
+#endif /* __cplusplus */
+
+
+#define CMD_CIPHER_CREATEHANDLE          ree_cipher_iowr(GK_ID_CIPHER, 0x1,  cipher_handle_s)
+#define CMD_CIPHER_DESTROYHANDLE         ree_cipher_iow(GK_ID_CIPHER,  0x2,  gk_u32)
+#define CMD_CIPHER_CONFIGHANDLE          ree_cipher_iow(GK_ID_CIPHER,  0x3,  cipher_config_ctrl_s)
+#define CMD_CIPHER_ENCRYPT               ree_cipher_iow(GK_ID_CIPHER,  0x4,  cipher_data_s)
+#define CMD_CIPHER_DECRYPT               ree_cipher_iow(GK_ID_CIPHER,  0x5,  cipher_data_s)
+#define CMD_CIPHER_DECRYPTMULTI          ree_cipher_iow(GK_ID_CIPHER,  0x6,  cipher_pkg_s)
+#define CMD_CIPHER_ENCRYPTMULTI          ree_cipher_iow(GK_ID_CIPHER,  0x7,  cipher_pkg_s)
+#define CMD_CIPHER_GETRANDOMNUMBER       ree_cipher_iowr(GK_ID_CIPHER, 0x8,  cipher_rng_s)
+#define CMD_CIPHER_GETHANDLECONFIG       ree_cipher_iowr(GK_ID_CIPHER, 0x9,  cipher_config_ctrl_s)
+#define CMD_CIPHER_CALCHASHINIT          ree_cipher_iowr(GK_ID_CIPHER, 0xa,  cipher_hash_data_s)
+#define CMD_CIPHER_CALCHASHUPDATE        ree_cipher_iowr(GK_ID_CIPHER, 0xb,  cipher_hash_data_s)
+#define CMD_CIPHER_CALCHASHFINAL         ree_cipher_iowr(GK_ID_CIPHER, 0xc,  cipher_hash_data_s)
+#define CMD_CIPHER_CALCRSA               ree_cipher_iowr(GK_ID_CIPHER, 0x10, cipher_rsa_data_s)
+#define CMD_CIPHER_GETTAG                ree_cipher_iowr(GK_ID_CIPHER, 0x11, cipher_tag_s)
+#define CMD_CIPHER_CONFIGHANDLE_EX       ree_cipher_iowr(GK_ID_CIPHER, 0x23, cipher_config_ctrl_ex_s)
+#define CMD_CIPHER_GETHANDLECONFIG_EX    ree_cipher_iowr(GK_ID_CIPHER, 0x24, cipher_config_ctrl_ex_s)
+#define CMD_CIPHER_KLAD_KEY              ree_cipher_iowr(GK_ID_CIPHER, 0x12, cipher_klad_key_s)
+
+#ifdef CONFIG_COMPAT
+#define CMD_CIPHER_COMPAT_DECRYPTMULTI   ree_cipher_iow(GK_ID_CIPHER,  0x6,  cipher_compat_pkg_s)
+#define CMD_CIPHER_COMPAT_ENCRYPTMULTI   ree_cipher_iow(GK_ID_CIPHER,  0x7,  cipher_compat_pkg_s)
+#define CMD_CIPHER_COMPAT_CALCRSA        ree_cipher_iowr(GK_ID_CIPHER, 0x10, cipher_compat_rsa_data_s)
+#endif
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* End of #ifndef __DRV_CIPHER_IOCTL_H__ */
diff -uraN u-boot-2016.11/product/cipher/v2/drv/platform/cipher_adapt.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/platform/cipher_adapt.c
--- u-boot-2016.11/product/cipher/v2/drv/platform/cipher_adapt.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/platform/cipher_adapt.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "cipher_adapt.h"
+
+gk_s32 cipher_mmz_alloc_remap(gk_char *name, cipher_mmz_buf_t *cipher_mmz)
+{
+    if (cipher_mmz->mmz_size == 0) {
+        gk_err_cipher("Error: length of malloc is invalid!\n");
+        return GK_FAILURE;
+    }
+
+    cipher_mmz->start_phy_addr = (gk_size_t)(uintptr_t)memalign(ARCH_DMA_MINALIGN, cipher_mmz->mmz_size);
+
+    if (cipher_mmz->start_phy_addr == 0) {
+        gk_err_cipher("Error: Get phyaddr for cipher input failed!\n");
+        return GK_FAILURE;
+    }
+    cipher_mmz->start_vir_addr = (gk_u8 *)(uintptr_t)cipher_mmz->start_phy_addr;
+
+    return GK_SUCCESS;
+}
+
+gk_void cipher_mmz_release_unmap(cipher_mmz_buf_t *cipher_mmz)
+{
+    if (cipher_mmz->start_phy_addr > 0) {
+        free(cipher_mmz->start_vir_addr);
+        cipher_mmz->start_phy_addr = 0;
+        cipher_mmz->start_vir_addr = NULL;
+    }
+}
+
+gk_s32 cipher_mmz_map(cipher_mmz_buf_t *cipher_mmz)
+{
+    cipher_mmz->start_vir_addr = (gk_u8 *)(uintptr_t)cipher_mmz->start_phy_addr;
+
+    return GK_SUCCESS;
+}
+
+gk_void cipher_mmz_unmap(cipher_mmz_buf_t *cipher_mmz)
+{
+
+}
+
+gk_s32 cipher_waitdone_callback(gk_void *param)
+{
+    gk_bool *done = GK_NULL;
+
+    done = param;
+
+    return  *done != GK_FALSE;
+}
+
+/************************* SYSTEM API ************************/
+gk_void *crypto_memcpy(gk_void *dst, unsigned dstlen, const gk_void *src, unsigned len)
+{
+    if ((dst == NULL) || (src == NULL) || (dstlen < len)) {
+        gk_err_cipher("Error: cipher call %s with invalid parameter.\n", __FUNCTION__);
+        return NULL;
+    }
+
+    return memcpy(dst, src, len);
+}
+
+gk_void *crypto_memset(gk_void *dst, unsigned int dlen, unsigned val, unsigned int len)
+{
+    if ((dst == NULL) || (dlen < len)) {
+        gk_err_cipher("Error: cipher call %s with invalid parameter.\n", __FUNCTION__);
+        return NULL;
+    }
+
+    return memset(dst, val, len);
+}
+
+int crypto_memcmp(const gk_void *a, const gk_void *b, unsigned int len)
+{
+    if ((a == NULL) || (b == NULL)) {
+        gk_err_cipher("Error: cipher call %s with invalid parameter, point is null.\n", __FUNCTION__);
+        return GK_FAILURE;
+    }
+
+    if (a == b) {
+        gk_err_cipher("Error: cipher call %s with invalid parameter, comparing with the same address.\n", __FUNCTION__);
+        return GK_FAILURE;
+    }
+
+    return memcmp(a, b, len);
+}
+
+void hex2str(char buf[2], gk_u8 val) /* 2 buf size */
+{
+    gk_u8 high, low;
+
+    high = (val >> 4) & 0x0F; /* 4 */
+    low = val & 0x0F;
+
+    if (high <= 9) /* 9 */
+        buf[0] = high + '0';
+    else
+        buf[0] = (high - 0x0A) + 'A';
+
+    if (low <= 9) /* 9 */
+        buf[1] = low + '0';
+    else
+        buf[1] = (low - 0x0A) + 'A';
+}
+
+void print_data(const char *name, gk_u8 *data, gk_u32 size)
+{
+    gk_u32 i;
+
+    if (name != GK_NULL)
+        GK_PRINT("[%s]:\n", name);
+
+    for (i = 0; i < size; i++) {
+        if (i % 16 == 0 && i != 0) /* 16 align */
+            GK_PRINT("\n");
+        GK_PRINT("%02X ", data[i]);
+    }
+    GK_PRINT("\n");
+}
diff -uraN u-boot-2016.11/product/cipher/v2/drv/platform/cipher_adapt.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/platform/cipher_adapt.h
--- u-boot-2016.11/product/cipher/v2/drv/platform/cipher_adapt.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/platform/cipher_adapt.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,125 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __CIPHER_ADAPT_H_
+#define __CIPHER_ADAPT_H_
+
+#ifndef GK_MINIBOOT_SUPPORT
+#include <common.h>
+#else
+#include "delay.h"
+#include "malloc.h"
+#include "string.h"
+#include "stdio.h"
+#endif
+#include "malloc.h"
+
+#include "types.h"
+#include "drv_cipher_ioctl.h"
+#include "drv_cipher.h"
+#include "cipher_config.h"
+#include "spacc_intf.h"
+#include "drv_rng.h"
+#include "drv_rsa.h"
+#include "drv_klad.h"
+#include "../../../otp/hal_otp.h"
+#include "drv_compat.h"
+
+/**************************** M A C R O ****************************/
+#define GK_ERR_CIPHER_NOT_INIT                     (gk_s32)(0x804D0001)
+#define GK_ERR_CIPHER_INVALID_HANDLE               (gk_s32)(0x804D0002)
+#define GK_ERR_CIPHER_INVALID_POINT                (gk_s32)(0x804D0003)
+#define GK_ERR_CIPHER_INVALID_PARA                 (gk_s32)(0x804D0004)
+#define GK_ERR_CIPHER_FAILED_INIT                  (gk_s32)(0x804D0005)
+#define GK_ERR_CIPHER_FAILED_GETHANDLE             (gk_s32)(0x804D0006)
+#define GK_ERR_CIPHER_FAILED_RELEASEHANDLE         (gk_s32)(0x804D0007)
+#define GK_ERR_CIPHER_FAILED_CONFIGAES             (gk_s32)(0x804D0008)
+#define GK_ERR_CIPHER_FAILED_CONFIGDES             (gk_s32)(0x804D0009)
+#define GK_ERR_CIPHER_FAILED_ENCRYPT               (gk_s32)(0x804D000A)
+#define GK_ERR_CIPHER_FAILED_DECRYPT               (gk_s32)(0x804D000B)
+#define GK_ERR_CIPHER_BUSY                         (gk_s32)(0x804D000C)
+#define GK_ERR_CIPHER_NO_AVAILABLE_RNG             (gk_s32)(0x804D000D)
+
+#define GK_ID_CIPHER                        100
+
+#define CIPHER_IOR                          _IOWR
+#define CIPHER_IOW                          _IOW
+#define CIPHER_IOWR                         _IOWR
+
+#define CIPHER_IOC_DIR                      _IOC_DIR
+#define CIPHER_IOC_TYPE                     _IOC_TYPE
+#define CIPHER_IOC_NR                       _IOC_NR
+#define CIPHER_IOC_SIZE                     _IOC_SIZE
+#define u32_to_point(addr)                  ((gk_void*)((gk_size_t)(addr)))
+#define point_to_u32(addr)                  ((gk_u32)((gk_size_t)(addr)))
+
+#define hal_cipher_read_reg(addr, result)   (*(result) = *(volatile unsigned int *)(addr))
+#define hal_cipher_write_reg(addr, result)  (*(volatile unsigned int *)(addr) = (result))
+
+#define hal_set_bit(src, bit)               ((src) |= (1 << (bit)))
+#define hal_clear_bit(src, bit)             ((src) &= ~(1 << (bit)))
+
+#define cipher_cpu_to_be16(v) (((v) << 8) | ((v) >> 8))
+#define cipher_cpu_to_be32(v) (((v) >> 24) | (((v) >> 8) & 0xff00) | (((v) << 8) & 0xff0000) | ((v) << 24))
+#define cipher_cpu_to_be64(x) ((gk_u64)(                         \
+    (((x) & 0x00000000000000ffULL) << 56) | (((x) & 0x000000000000ff00ULL) << 40) |   \
+    (((x) & 0x0000000000ff0000ULL) << 24) | (((x) & 0x00000000ff000000ULL) <<  8) |   \
+    (((x) & 0x000000ff00000000ULL) >>  8) | (((x) & 0x0000ff0000000000ULL) >> 24) |   \
+    (((x) & 0x00ff000000000000ULL) >> 40) | (((x) & 0xff00000000000000ULL) >> 56)))
+
+/**************************** S T D L I B ****************************/
+#define cipher_ioremap_nocache(addr, size)  (gk_void*)(addr)
+#define cipher_iounmap(x)
+
+void *crypto_memset(gk_void *dst, unsigned int dlen, unsigned val, unsigned int len);
+int  crypto_memcmp(const gk_void *a, const gk_void *b, unsigned len);
+void *crypto_memcpy(gk_void *dst, unsigned dstlen, const gk_void *src, unsigned len);
+gk_s32 cipher_waitdone_callback(gk_void *param);
+
+#define CIPHER_MUTEX                        gk_void *
+#define cipher_mutex_init(x)
+#define cipher_mutex_lock(x)                0
+#define cipher_mutex_unlock(x)
+
+#define CIPHER_QUEUE_HEAD                   gk_void *
+#define cipher_queue_init(x)
+#define cipher_queue_wait_up(x)
+#define cipher_queue_wait_timeout(head, con, time)
+
+#define cipher_request_irq(irq, func, name)
+#define cipher_free_irq(irq, name)
+#define CIPHER_IRQRETURN_T                  gk_s32
+#define CIPHER_IRQ_HANDLED                  1
+
+#define cipher_copy_from_user(s, d, l)      (memcpy(s, d, l), 0)
+#define cipher_copy_to_user(s, d, l)        (memcpy(s, d, l), 0)
+
+#define cipher_malloc(x)                    malloc(x)
+#define cipher_free(x)                      free(x)
+
+#define cipher_msleep(msec)                 udelay(1000)
+#define GK_PRINT                            printf
+#define gk_err_cipher(fmt...)               GK_PRINT(fmt)
+#define gk_info_cipher(fmt...)              // GK_PRINT(fmt)
+#define CIPHER_PROC_PRINTF                  // osal_seq_printf
+
+#define cipher_min(a, b) ((a) < (b) ? (a) : (b))
+
+void hex2str(char buf[2], gk_u8 val); /* 2 buf size */
+
+/**************************** P R I V A T E ****************************/
+typedef struct {
+    gk_void *start_vir_addr;
+    gk_size_t start_phy_addr;
+    gk_u32 mmz_addr;
+    gk_u32 mmz_size;
+} cipher_mmz_buf_t;
+
+gk_s32  cipher_mmz_alloc_remap(gk_char *name, cipher_mmz_buf_t *cipher_mmz);
+gk_void cipher_mmz_release_unmap(cipher_mmz_buf_t *cipher_mmz);
+gk_s32  cipher_mmz_map(cipher_mmz_buf_t *cipher_mmz);
+gk_void cipher_mmz_unmap(cipher_mmz_buf_t *cipher_mmz);
+
+#endif
+
diff -uraN u-boot-2016.11/product/cipher/v2/drv/platform/cipher_config.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/platform/cipher_config.h
--- u-boot-2016.11/product/cipher/v2/drv/platform/cipher_config.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/platform/cipher_config.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __CIPHER_CONFIG_H_
+#define __CIPHER_CONFIG_H_
+
+#define RSA_ENABLE
+#define OTP_SUPPORT
+#define CIPHER_HASH_SUPPORT
+#define CIPHER_EFUSE_SUPPORT
+#define CIPHER_KLAD_SUPPORT
+
+#define CIPHER_IRQ_NUMBER                       59
+
+#if (defined(CONFIG_TARGET_GK7205V200) || defined(CONFIG_TARGET_GK7205V300) || \
+       defined(CONFIG_TARGET_GK7202V300) || defined(CONFIG_TARGET_GK7605V100))
+#define CIPHER_RNG_REG_BASE_ADDR_PHY            (0x10080000)
+#define CIPHER_CIPHER_REG_BASE_ADDR_PHY         (0x10050000)
+#define CIPHER_RSA_REG_BASE_ADDR_PHY            (0x10070000)
+
+#define CIPHER_RSA_CRG_ADDR_PHY                 (0x120101A0)
+#define RSA_CRG_CLOCK_BIT                       (0x01 << 5)
+#define RSA_CRG_RESET_BIT                       (0x01 << 4)
+#define CIPHER_SPACC_CRG_ADDR_PHY               (0x120101A0)
+#define SPACC_CRG_CLOCK_BIT                     (0x01 << 9)
+#define SPACC_CRG_RESET_BIT                     (0x01 << 8)
+#define CIPHER_RNG_CRG_ADDR_PHY                 (0x120101A0)
+#define RNG_CRG_CLOCK_BIT                       (0x01 << 3)
+#define RNG_CRG_RESET_BIT                       (0x01 << 2)
+
+#define CIPHER_KLAD_REG_BASE_ADDR_PHY           (0x10060000)
+#define CIPHER_OTP_REG_BASE_ADDR_PHY            (0x10090000)
+#define CIPHER_KLAD_CRG_ADDR_PHY                (0x120101A0)
+
+#define KLAD_CRG_CLOCK_BIT                      (0x01 << 1)
+#define KLAD_CRG_RESET_BIT                      (0x01 << 0)
+#endif
+
+#endif
+
diff -uraN u-boot-2016.11/product/cipher/v2/drv/rng/drv_rng.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/rng/drv_rng.c
--- u-boot-2016.11/product/cipher/v2/drv/rng/drv_rng.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/rng/drv_rng.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "cipher_adapt.h"
+
+static gk_void *g_rng_reg_base;
+
+#define REG_RNG_BASE_ADDR                   g_rng_reg_base
+#define SEC_COM_TRNG_CTRL                 (REG_RNG_BASE_ADDR + 0x200)
+#define SEC_COM_TRNG_FIFO_DATA            (REG_RNG_BASE_ADDR + 0x204)
+#define SEC_COM_TRNG_DATA_ST              (REG_RNG_BASE_ADDR + 0x208)
+
+gk_s32 drv_rng_init(gk_void)
+{
+    gk_u32 rng_stat = 0;
+
+    g_rng_reg_base = cipher_ioremap_nocache(CIPHER_RNG_REG_BASE_ADDR_PHY, 0x1000);
+    if (g_rng_reg_base == GK_NULL) {
+        gk_err_cipher("ioremap_nocache sha2 Reg failed\n");
+        return GK_FAILURE;
+    }
+
+    hal_cipher_read_reg(CIPHER_RNG_CRG_ADDR_PHY, &rng_stat);
+    rng_stat |= RNG_CRG_CLOCK_BIT;
+    rng_stat &= ~RNG_CRG_RESET_BIT;
+    hal_cipher_write_reg(CIPHER_RNG_CRG_ADDR_PHY, rng_stat);
+
+    return GK_SUCCESS;
+}
+
+gk_void drv_rng_deinit(gk_void)
+{
+    cipher_iounmap(g_rng_reg_base);
+}
+
+static gk_s32 drv_cipher_get_random_number(cipher_rng_s *rng)
+{
+    gk_u32 rng_stat = 0;
+    gk_u32 time_out = 0;
+
+    if (rng->time_out_us == 0) {
+        /* low 3bit(RNG_data_count[2:0]), indicate how many RNGs in the fifo is available now */
+        hal_cipher_read_reg(SEC_COM_TRNG_DATA_ST, &rng_stat);
+        if (((rng_stat >> 8) & 0x3F) <= 0) /* 8 right shift */
+            return GK_ERR_CIPHER_NO_AVAILABLE_RNG;
+    } else {
+        while (time_out++ < rng->time_out_us) {
+            /* low 3bit(RNG_data_count[2:0]), indicate how many RNGs in the fifo is available now */
+            hal_cipher_read_reg(SEC_COM_TRNG_DATA_ST, &rng_stat);
+            if (((rng_stat >> 8) & 0x3F) > 0) /* 8 right shift */
+                break;
+        }
+
+        if (time_out >= rng->time_out_us)
+            return GK_ERR_CIPHER_NO_AVAILABLE_RNG;
+    }
+
+    hal_cipher_read_reg(SEC_COM_TRNG_FIFO_DATA, &rng->ci_rng);
+
+    return GK_SUCCESS;
+}
+
+gk_u32 drv_cipher_rand(gk_void)
+{
+    cipher_rng_s rng;
+
+    rng.time_out_us = -1;
+    if (drv_cipher_get_random_number(&rng) != GK_SUCCESS)
+        gk_err_cipher("Get random number failed!\n");
+
+    return rng.ci_rng;
+}
+
+gk_s32 gk_drv_cipher_get_random_number(cipher_rng_s *rng)
+{
+    gk_s32 ret;
+
+    if (rng == NULL) {
+        gk_err_cipher("Invalid params!\n");
+        return GK_FAILURE;
+    }
+
+    ret = drv_cipher_get_random_number(rng);
+
+    return ret;
+}
+
diff -uraN u-boot-2016.11/product/cipher/v2/drv/rng/drv_rng.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/rng/drv_rng.h
--- u-boot-2016.11/product/cipher/v2/drv/rng/drv_rng.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/rng/drv_rng.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __DRV_RNG_H__
+#define __DRV_RNG_H__
+
+/* add include here */
+#include "drv_cipher.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Macro Definition ******************************/
+gk_u32 drv_cipher_rand(gk_void);
+gk_s32 drv_rng_init(gk_void);
+gk_void drv_rng_deinit(gk_void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* __DRV_CIPHER_H__ */
diff -uraN u-boot-2016.11/product/cipher/v2/drv/rsa/drv_rsa.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/rsa/drv_rsa.c
--- u-boot-2016.11/product/cipher/v2/drv/rsa/drv_rsa.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/rsa/drv_rsa.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,661 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "cipher_adapt.h"
+#include "drv_rng.h"
+#include "drv_klad.h"
+
+#ifdef RSA_ENABLE
+
+CIPHER_MUTEX g_rsa_mutex_kernel;
+static gk_void *g_rsa_reg_base  = GK_NULL;
+static gk_void *g_rsa_reg_crg   = GK_NULL;
+static gk_u32   g_rsa_done      = GK_FALSE;
+
+#define cipher_rsa_return_invalid_param(param) \
+    do { \
+        if (param) { \
+            gk_err_cipher("Invalid params!\n"); \
+            return GK_ERR_CIPHER_INVALID_PARA; \
+        } \
+    } while (0)
+
+#define RSA_INTERRUPT_ENABLE
+#define RSA_IRQ_NUMBER                          136
+
+#define CIPHER_RSA_REG_BASE_RSA                   g_rsa_reg_base
+#define SEC_RSA_BUSY_REG                          (CIPHER_RSA_REG_BASE_RSA + 0x50)
+#define SEC_RSA_MOD_REG                           (CIPHER_RSA_REG_BASE_RSA + 0x54)
+#define SEC_RSA_WSEC_REG                          (CIPHER_RSA_REG_BASE_RSA + 0x58)
+#define SEC_RSA_WDAT_REG                          (CIPHER_RSA_REG_BASE_RSA + 0x5c)
+#define SEC_RSA_RPKT_REG                          (CIPHER_RSA_REG_BASE_RSA + 0x60)
+#define SEC_RSA_RRSLT_REG                         (CIPHER_RSA_REG_BASE_RSA + 0x64)
+#define SEC_RSA_START_REG                         (CIPHER_RSA_REG_BASE_RSA + 0x68)
+#define SEC_RSA_ADDR_REG                          (CIPHER_RSA_REG_BASE_RSA + 0x6C)
+#define SEC_RSA_ERROR_REG                         (CIPHER_RSA_REG_BASE_RSA + 0x70)
+#define SEC_RSA_CRC16_REG                         (CIPHER_RSA_REG_BASE_RSA + 0x74)
+#define SEC_RSA_KEY_RANDOM_1                      (CIPHER_RSA_REG_BASE_RSA + 0x7c)
+#define SEC_RSA_INT_EN                            (CIPHER_RSA_REG_BASE_RSA + 0x80)
+#define SEC_RSA_INT_STATUS                        (CIPHER_RSA_REG_BASE_RSA + 0x84)
+#define SEC_RSA_INT_RAW                           (CIPHER_RSA_REG_BASE_RSA + 0x88)
+#define SEC_RSA_INT_ERR_CLR                       (CIPHER_RSA_REG_BASE_RSA + 0x8c)
+#define SEC_RSA_KEY_RANDOM_2                      (CIPHER_RSA_REG_BASE_RSA + 0x94)
+#define SEC_RSA_VERSION                           (CIPHER_RSA_REG_BASE_RSA + 0x90)
+
+#define RSA_DATA_CLR               (7 << 4)
+#define RSA_DATA_CLR_KEY           (1 << 4)
+#define RSA_DATA_CLR_INPUT         (2 << 4)
+#define RSA_DATA_CLR_OUTPUT        (4 << 4)
+#define RSA_MOD_SEL                (3 << 0)
+#define RSA_MOD_SEL_OPT            (0 << 0)
+#define RSA_MOD_SEL_KEY_UPDATA     (1 << 0)
+#define RSA_MOD_SEL_RAM_CLAER      (2 << 0)
+#define RSA_MOD_SEL_CRC16          (3 << 0)
+#define RSA_BUSY                   (1 << 0)
+#define RSA_START                  (1 << 0)
+
+#define RSA_RTY_CNT             50000
+#define RSA_TIME_OUT            1000
+
+#define RSA_RETRY_CNT           3
+
+#define CRC16_POLYNOMIAL        0x1021
+
+typedef enum {
+    CIPHER_RSA_DATA_TYPE_CONTEXT,
+    CIPHER_RSA_DATA_TYPE_MODULE,
+    CIPHER_RSA_DATA_TYPE_KEY,
+} cipher_rsa_data_type_e;
+
+typedef enum {
+    CIPHER_RSA_KEY_WIDTH_1K   = 0x00,
+    CIPHER_RSA_KEY_WIDTH_2K   = 0x01,
+    CIPHER_RSA_KEY_WIDTH_4K   = 0x02,
+    CIPHER_RSA_KEY_WIDTH_3K   = 0x03,
+    CIPHER_RSA_KEY_WIDTH_BUTT = 0xff,
+} cipher_rsa_key_width_e;
+
+static gk_void hal_rsa_start(gk_void)
+{
+    hal_cipher_write_reg(SEC_RSA_START_REG, 0x05);
+}
+
+static gk_s32 hal_rsa_wait_free(gk_void)
+{
+    gk_u32 value;
+    gk_u32 try_count = 0;
+
+    do {
+        hal_cipher_read_reg(SEC_RSA_BUSY_REG, &value);
+        if ((value & RSA_BUSY) == 0)
+            return GK_SUCCESS;
+        try_count++;
+        cipher_msleep(1);
+    } while (try_count < RSA_RTY_CNT);
+
+    return GK_FAILURE;
+}
+
+static gk_void hal_rsa_clear_ram(gk_void)
+{
+    gk_u32 value;
+
+    hal_cipher_read_reg(SEC_RSA_MOD_REG, &value);
+    value &= 0x0c;
+    value |= RSA_DATA_CLR_INPUT | RSA_DATA_CLR_OUTPUT | RSA_DATA_CLR_KEY | RSA_MOD_SEL_RAM_CLAER;
+    hal_cipher_write_reg(SEC_RSA_MOD_REG, value);
+}
+
+static gk_void hal_rsa_config_mode(cipher_rsa_key_width_e ken_width)
+{
+    gk_u32 value;
+
+    value = ((gk_u32)ken_width << 2) | RSA_MOD_SEL_OPT; /* 2 left shift */
+    hal_cipher_write_reg(SEC_RSA_MOD_REG, value);
+}
+
+static gk_void hal_rsa_write_data(cipher_rsa_data_type_e data_type,
+                                  gk_u8 *data,
+                                  gk_u32 data_len,
+                                  gk_u32 length,
+                                  gk_u32 random[2]) /* 2 random size */
+{
+    gk_u32 *reg = GK_NULL;
+    gk_u8 *pos = GK_NULL;
+    gk_u32 i, value;
+    gk_bool id = 0;
+
+    if (data_type == CIPHER_RSA_DATA_TYPE_CONTEXT)
+        reg = SEC_RSA_WDAT_REG;
+    else
+        reg = SEC_RSA_WSEC_REG;
+
+    pos = data;
+    for (i = 0; i < length; i += 4) { /* 4 groups */
+        value  = (gk_u32)pos[0];
+        value |= ((gk_u32)pos[1]) << 8;  /* 1 index, 8  left shift */
+        value |= ((gk_u32)pos[2]) << 16; /* 2 index, 16 left shift */
+        value |= ((gk_u32)pos[3]) << 24; /* 3 index, 24 left shift */
+        if (data_type != CIPHER_RSA_DATA_TYPE_CONTEXT)
+            value ^= random[id];
+
+        hal_cipher_write_reg(reg, value);
+        pos += 4; /* 4 groups */
+        id = (gk_u32)id ^ 0x01;
+    }
+}
+
+static gk_void hal_rsa_read_data(gk_u8 *data, gk_u32 data_len, gk_u32 klen)
+{
+    gk_u32 value;
+    gk_u8 *pos = GK_NULL;
+    gk_u32 i;
+
+    pos = data;
+    for (i = 0; i < klen; i += 4) { /* 4 groups */
+        hal_cipher_read_reg(SEC_RSA_RRSLT_REG, &value);
+        pos[0] = (gk_u8)(value & 0xFF);
+        pos[1] = (gk_u8)((value >> 8) & 0xFF);  /* 1 index, 8  right shift */
+        pos[2] = (gk_u8)((value >> 16) & 0xFF); /* 2 index, 16 right shift */
+        pos[3] = (gk_u8)((value >> 24) & 0xFF); /* 3 index, 24 right shift */
+        pos += 4; /* 4 groups */
+    }
+}
+
+static gk_u32 hal_rsa_get_error_code(gk_void)
+{
+    gk_u32 value;
+
+    hal_cipher_read_reg(SEC_RSA_ERROR_REG, &value);
+
+    return value;
+}
+
+static gk_void hal_rsa_disable_int(gk_void)
+{
+    (gk_void)hal_cipher_write_reg(SEC_RSA_INT_EN, 0x00);
+}
+
+static gk_void hal_rsa_enable(gk_void)
+{
+    gk_u32 value;
+
+    hal_cipher_read_reg(g_rsa_reg_crg, &value);
+    hal_set_bit(value, 15); /* 15bit clock opened */
+    hal_cipher_write_reg(g_rsa_reg_crg, value);
+    cipher_msleep(1);
+
+    hal_clear_bit(value, 14); /* 14bit cancel reset */
+    hal_cipher_write_reg(g_rsa_reg_crg, value);
+    cipher_msleep(1);
+
+#ifdef INT_ENABLE
+    hal_rsa_enable_int();
+#endif
+}
+
+static gk_void hal_rsa_disable(gk_void)
+{
+    gk_u32 value;
+
+    hal_cipher_read_reg(g_rsa_reg_crg, &value);
+
+    hal_set_bit(value, 14); /* 14bit reset */
+    hal_cipher_write_reg(g_rsa_reg_crg, value);
+    cipher_msleep(1);
+
+    hal_clear_bit(value, 15); /* 15bit clock closed */
+    hal_cipher_write_reg(g_rsa_reg_crg, value);
+}
+
+#ifdef RSA_RAND_MASK
+
+static gk_u16 g_crc_table[256]; /* 256 table size */
+
+static gk_void drv_rsa_crc16_init(gk_void)
+{
+    gk_u16 remainder;
+    gk_u16 n, m;
+    gk_u16 *table = g_crc_table;
+
+    for (n = 0; n < 256; n++) { /* 256 */
+        remainder = (gk_u16)n << 8; /* 8 left shift */
+        for (m = 8; m > 0; m--) { /* 8 */
+            if (remainder & 0x8000)
+                remainder = (remainder << 1) ^ CRC16_POLYNOMIAL;
+            else
+                remainder = (remainder << 1);
+        }
+        *(table + n) = remainder;
+    }
+}
+
+static gk_u16 drv_rsa_crc16_block(gk_u16 crc, gk_u8 block[8], gk_u8 random[8]) /* 8 */
+{
+    gk_u8 i, j;
+    gk_u8 val;
+
+    for (i = 0; i < 2; i++) { /* 2 */
+        for (j = 0; j < 4; j++) { /* 4 */
+            val = block[i * 4 + 3 - j] ^ random[i * 4 + 3 - j]; /* 4, 3 */
+            crc = (crc << 8) ^ g_crc_table[((crc >> 8) ^ val) & 0xFF]; /* 8 right shift */
+        }
+    }
+
+    return crc;
+}
+
+static gk_u16 drv_rsa_key_crc(gk_u8 *rsa_n, gk_u8 *rsa_k, gk_u32 klen, gk_u32 random[2]) /* 2 */
+{
+    gk_u32 i;
+    gk_u16 crc = 0;
+
+    for (i = 0; i < klen; i += 8) /* 8 */
+        crc = drv_rsa_crc16_block(crc, rsa_n + i, (gk_u8*)random);
+
+    for (i = 0; i < klen; i += 8) /* 8 */
+        crc = drv_rsa_crc16_block(crc, rsa_k + i, (gk_u8*)random);
+
+    return crc;
+}
+#endif
+
+CIPHER_QUEUE_HEAD g_rsa_wait_queue;
+#ifdef INT_ENABLE
+static CIPHER_IRQRETURN_T drv_rsa_isr(gk_s32 irq, gk_void *dev_id)
+{
+    gk_u32 int_stat;
+
+    int_stat = hal_rsa_get_int();
+
+    gk_info_cipher("RSA INT: 0x%x\n", int_stat);
+
+    if (int_stat & 0x01) {
+        g_rsa_done = GK_TRUE;
+        gk_info_cipher("RSA Done\n");
+        cipher_queue_wait_up(&g_rsa_wait_queue);
+    }
+
+    hal_rsa_clr_int();
+
+    return CIPHER_IRQ_HANDLED;
+}
+#endif
+
+gk_s32 drv_rsa_init(gk_void)
+{
+    gk_u32 rsa_stat = 0;
+    gk_u32 rng_stat = 0;
+#ifdef INT_ENABLE
+    gk_s32 ret;
+#endif
+
+    cipher_mutex_init(&g_rsa_mutex_kernel);
+    cipher_queue_init(&g_rsa_wait_queue);
+
+    g_rsa_reg_crg = cipher_ioremap_nocache(CIPHER_RSA_CRG_ADDR_PHY, 16); /* 16 */
+    if (g_rsa_reg_crg == 0) {
+        gk_err_cipher("ioremap_nocache phy addr err:%x.\n", CIPHER_RSA_CRG_ADDR_PHY);
+        return GK_FAILURE;
+    }
+
+    /* rng reset and clock */
+    hal_cipher_read_reg(CIPHER_RNG_CRG_ADDR_PHY, &rng_stat);
+    rng_stat |= RNG_CRG_CLOCK_BIT;
+    rng_stat &= ~RNG_CRG_RESET_BIT;
+    hal_cipher_write_reg(CIPHER_RNG_CRG_ADDR_PHY, rng_stat);
+    cipher_msleep(5); /* sleep 5ms */
+
+    /* rsa reset and clock */
+    hal_cipher_read_reg(CIPHER_RSA_CRG_ADDR_PHY, &rsa_stat);
+    rsa_stat |= RSA_CRG_CLOCK_BIT;
+    rsa_stat |= RSA_CRG_RESET_BIT;
+    hal_cipher_write_reg(CIPHER_RSA_CRG_ADDR_PHY, rsa_stat);
+    cipher_msleep(5); /* sleep 5ms */
+
+    /* rsa cancel reset */
+    rsa_stat &= ~RSA_CRG_RESET_BIT;
+    hal_cipher_write_reg(CIPHER_RSA_CRG_ADDR_PHY, rsa_stat);
+
+    cipher_iounmap(g_rsa_reg_crg);
+    g_rsa_reg_crg = GK_NULL;
+
+    g_rsa_reg_base = cipher_ioremap_nocache(CIPHER_RSA_REG_BASE_ADDR_PHY, 0x1000);
+    if (g_rsa_reg_base == GK_NULL) {
+        gk_err_cipher("ioremap_nocache rsa Reg failed\n");
+        return GK_FAILURE;
+    }
+
+#ifdef INT_ENABLE
+    /* request irq */
+    ret = cipher_request_irq(RSA_IRQ_NUMBER, drv_rsa_isr, "rsa");
+    if (ret != GK_SUCCESS) {
+        hal_rsa_disable_int();
+        gk_err_cipher("Irq request failure, ret=%#x.\n", ret);
+        return GK_FAILURE;
+    }
+    hal_rsa_enable_int();
+#endif
+
+#ifdef RSA_RAND_MASK
+    drv_rsa_crc16_init();
+#endif
+
+    return GK_SUCCESS;
+}
+
+gk_void drv_rsa_deinit(gk_void)
+{
+    hal_rsa_disable_int();
+
+#ifdef INT_ENABLE
+    cipher_free_irq(RSA_IRQ_NUMBER, "rsa");
+#endif
+
+    if (g_rsa_reg_base != GK_NULL) {
+        cipher_iounmap(g_rsa_reg_base);
+        g_rsa_reg_base = GK_NULL;
+    }
+}
+
+static gk_s32 drv_rsa_wait_done(gk_void)
+{
+#ifdef INT_ENABLE
+    if (cipher_queue_wait_timeout(&g_rsa_wait_queue, &g_rsa_done, RSA_TIME_OUT) == 0) {
+        gk_err_cipher("RSA time out! \n");
+        return GK_FAILURE;
+    }
+
+    return GK_SUCCESS;
+#else
+    return hal_rsa_wait_free();
+#endif
+}
+
+static gk_s32 drv_cipher_check_rsa_data(gk_u8 *rsa_n, gk_u8 *rsa_e, gk_u8 *rsa_mc, gk_u32 length)
+{
+    gk_u32 i;
+
+    /* formula: rsa_mc > 0 */
+    for (i = 0; i < length; i++) {
+        if (rsa_mc[i] > 0)
+            break;
+    }
+    if (i >= length) {
+        gk_err_cipher("RSA M/C is zero, error!\n");
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    /* formula: rsa_mc < rsa_n */
+    for (i = 0; i < length; i++) {
+        if (rsa_mc[i] < rsa_n[i])
+            break;
+    }
+    if (i >= length) {
+        gk_err_cipher("RSA M/C is larger than rsa_n, error!\n");
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    /* formula: rsa_e >= 1 */
+    for (i = 0; i < length; i++) {
+        if (rsa_e[i] > 0)
+            break;
+    }
+    if (i >= length) {
+        gk_err_cipher("RSA D/rsa_e is zero, error!\n");
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 drv_cipher_clear_rsa_ram(gk_void)
+{
+    if (hal_rsa_wait_free() != GK_SUCCESS) {
+        gk_err_cipher("RSA is busy and timeout,error!\n");
+        return GK_FAILURE;
+    }
+
+    g_rsa_done = GK_FALSE;
+
+    hal_rsa_clear_ram();
+    hal_rsa_start();
+
+    if (drv_rsa_wait_done() != GK_SUCCESS) {
+        gk_err_cipher("RSA is busy and timeout,error!\n");
+        return GK_FAILURE;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_u8 g_rsa_n[CIPHER_MAX_RSA_KEY_LEN];
+static gk_u8 g_rsa_k[CIPHER_MAX_RSA_KEY_LEN];
+static gk_u8 g_rsa_m[CIPHER_MAX_RSA_KEY_LEN];
+
+static gk_void drv_rsa_rand_mask(cipher_rsa_data_s *rsa_data,
+                                 gk_u32 key_len,
+                                 gk_u32 *random)
+{
+#ifdef RSA_RAND_MASK
+    gk_u16 crc;
+
+    random[0] = drv_cipher_rand();
+    random[1] = drv_cipher_rand();
+    crc = drv_rsa_key_crc(rsa_data->rsa_n, rsa_data->rsa_k, key_len, random);
+    gk_info_cipher("CRC16: 0x%x\n", crc);
+    hal_rsa_set_random(random);
+    hal_rsa_set_crc(crc);
+#endif
+}
+
+static gk_s32 drv_rsa_cipher_klad(cipher_rsa_data_s *rsa_data,
+                                  gk_u32 key_len,
+                                  gk_u32 *random)
+{
+    gk_s32 ret = GK_SUCCESS;
+#ifdef CIPHER_KLAD_SUPPORT
+    if (rsa_data->ca_type != GK_CIPHER_KEY_SRC_USER) {
+        drv_cipher_klad_load_key(0, rsa_data->ca_type,
+            GK_CIPHER_KLAD_TARGET_RSA, rsa_data->rsa_k, rsa_data->rsa_k_len);
+        if (ret != GK_SUCCESS) {
+            gk_err_cipher("drv_cipher_klad_load_key, error!\n");
+            return ret;
+        }
+    } else {
+        hal_rsa_write_data(CIPHER_RSA_DATA_TYPE_KEY, rsa_data->rsa_k,
+            rsa_data->rsa_n_len, key_len, random);
+    }
+#else
+    hal_rsa_write_data(CIPHER_RSA_DATA_TYPE_KEY, rsa_data->rsa_k,
+        rsa_data->rsa_n_len, key_len, random);
+#endif
+    return ret;
+}
+
+static gk_s32 drv_rsa_key_info(cipher_rsa_data_s *rsa_data,
+                               gk_u32 *key_len,
+                               cipher_rsa_key_width_e *key_width)
+{
+    gk_u8 *p = GK_NULL;
+
+    /* Only support the key width of 1024, 2048 and 4096 */
+    if (rsa_data->rsa_n_len <= 128) { /* key n size 128 */
+        *key_len = 128; /* key n size 128 */
+        *key_width = CIPHER_RSA_KEY_WIDTH_1K;
+    } else if (rsa_data->rsa_n_len <= 256) { /* key n size 256 */
+        *key_len = 256; /* key n size 256 */
+        *key_width = CIPHER_RSA_KEY_WIDTH_2K;
+    } else if (rsa_data->rsa_n_len <= 384) { /* key n size 384 */
+        *key_len = 384; /* key n size 384 */
+        *key_width = CIPHER_RSA_KEY_WIDTH_3K;
+    } else if (rsa_data->rsa_n_len <= 512) { /* key n size 512 */
+        *key_len = 512; /* key n size 512 */
+        *key_width = CIPHER_RSA_KEY_WIDTH_4K;
+    } else {
+        gk_err_cipher("rsa_n_len(0x%x) is invalid\n", rsa_data->rsa_n_len);
+        return GK_ERR_CIPHER_INVALID_POINT;
+    }
+
+    /* if dataLen < key_len, padding 0 before data */
+    p = g_rsa_n + (*key_len - rsa_data->rsa_n_len);
+    if (cipher_copy_from_user(p, rsa_data->rsa_n, rsa_data->rsa_n_len)) {
+        gk_err_cipher("copy data from user fail!\n");
+        return GK_FAILURE;
+    }
+
+    p = g_rsa_k + (*key_len - rsa_data->rsa_k_len);
+    if (cipher_copy_from_user(p, rsa_data->rsa_k, rsa_data->rsa_k_len)) {
+        gk_err_cipher("copy data from user fail!\n");
+        return GK_FAILURE;
+    }
+
+    p = g_rsa_m + (*key_len - rsa_data->data_len);
+    if (cipher_copy_from_user(p, rsa_data->input_data, rsa_data->data_len)) {
+        gk_err_cipher("copy data from user fail!\n");
+        return GK_FAILURE;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 drv_cipher_calc_rsa_ex(cipher_rsa_data_s *rsa_data,
+                                     gk_u32 key_len,
+                                     cipher_rsa_key_width_e key_width)
+{
+    gk_u8 err_cnt;
+    gk_s32 ret;
+    gk_u32 err_code;
+    gk_u64 random = 0;
+
+    ret = drv_cipher_check_rsa_data(rsa_data->rsa_n, rsa_data->rsa_k, rsa_data->input_data, key_len);
+    if (ret != GK_SUCCESS) {
+        gk_err_cipher("RSA data invalid!\n");
+        return ret;
+    }
+
+    g_rsa_done = GK_FALSE;
+
+    for (err_cnt = 0; err_cnt < RSA_RETRY_CNT; err_cnt++) {
+        hal_rsa_enable();
+
+        ret = hal_rsa_wait_free();
+        if (ret != GK_SUCCESS) {
+            gk_err_cipher("RSA is busy!\n");
+            return ret;
+        }
+
+        /* Config Mode */
+        hal_rsa_config_mode(key_width);
+
+        drv_rsa_rand_mask(rsa_data, key_len, (gk_u32 *)&random);
+
+        /* Write rsa_n, rsa_e, rsa_m */
+        hal_rsa_write_data(CIPHER_RSA_DATA_TYPE_MODULE,
+            rsa_data->rsa_n, rsa_data->rsa_n_len, key_len, (gk_u32 *)&random);
+
+        ret = drv_rsa_cipher_klad(rsa_data, key_len, (gk_u32 *)&random);
+        if (ret != GK_SUCCESS)
+            return ret;
+
+        hal_rsa_write_data(CIPHER_RSA_DATA_TYPE_CONTEXT,
+            rsa_data->input_data, rsa_data->rsa_n_len, key_len, (gk_u32 *)&random);
+
+        /* Sart */
+        hal_rsa_start();
+
+        ret = drv_rsa_wait_done();
+        if (ret != GK_SUCCESS) {
+            gk_err_cipher("RSA is busy and timeout,error!\n");
+            return ret;
+        }
+
+        /* Get result */
+        hal_rsa_read_data(rsa_data->output_data, rsa_data->rsa_n_len, key_len);
+
+        if (drv_cipher_clear_rsa_ram() != GK_SUCCESS)
+            return GK_FAILURE;
+
+        err_code = hal_rsa_get_error_code();
+
+        hal_rsa_disable();
+
+        if (err_code == 0)
+            return GK_SUCCESS;
+        else
+            continue;
+    }
+
+    gk_err_cipher("RSA is err: chipset error code: 0x%x!\n", err_code);
+    return GK_FAILURE;
+}
+#endif
+
+static gk_s32 drv_cipher_calc_rsa(cipher_rsa_data_s *rsa_data)
+{
+    gk_s32 ret;
+    gk_u32 key_len = 0;
+    cipher_rsa_data_s cipher_rsa_data;
+    cipher_rsa_key_width_e key_width = CIPHER_RSA_KEY_WIDTH_BUTT;
+
+    cipher_rsa_return_invalid_param(rsa_data == GK_NULL);
+    cipher_rsa_return_invalid_param(rsa_data->input_data == GK_NULL);
+    cipher_rsa_return_invalid_param(rsa_data->output_data == GK_NULL);
+    cipher_rsa_return_invalid_param(rsa_data->rsa_n == GK_NULL);
+    cipher_rsa_return_invalid_param(rsa_data->rsa_k == GK_NULL);
+    cipher_rsa_return_invalid_param(rsa_data->data_len != rsa_data->rsa_n_len);
+    cipher_rsa_return_invalid_param(rsa_data->rsa_k_len > rsa_data->rsa_n_len);
+
+    crypto_memset(g_rsa_n, sizeof(g_rsa_n), 0, sizeof(g_rsa_n));
+    crypto_memset(g_rsa_k, sizeof(g_rsa_k), 0, sizeof(g_rsa_k));
+    crypto_memset(g_rsa_m, sizeof(g_rsa_m), 0, sizeof(g_rsa_m));
+
+    ret = drv_rsa_key_info(rsa_data, &key_len, &key_width);
+    if (ret != GK_SUCCESS)
+        return ret;
+
+    crypto_memset(&cipher_rsa_data, sizeof(cipher_rsa_data), 0, sizeof(cipher_rsa_data_s));
+    cipher_rsa_data.rsa_n = g_rsa_n;
+    cipher_rsa_data.rsa_k = g_rsa_k;
+    cipher_rsa_data.rsa_n_len = key_len;
+    cipher_rsa_data.rsa_k_len = key_len;
+    cipher_rsa_data.input_data = g_rsa_m;
+    cipher_rsa_data.data_len = key_len;
+    cipher_rsa_data.output_data = g_rsa_m;
+    cipher_rsa_data.ca_type = rsa_data->ca_type;
+
+    ret = drv_cipher_calc_rsa_ex(&cipher_rsa_data, key_len, key_width);
+    if (ret != GK_SUCCESS)
+        return GK_FAILURE;
+
+    if (cipher_copy_to_user(rsa_data->output_data,
+        g_rsa_m + (key_len - rsa_data->rsa_n_len), rsa_data->rsa_n_len)) {
+        gk_err_cipher("copy data to user fail!\n");
+        return GK_FAILURE;
+    }
+
+    return ret;
+}
+
+gk_s32 gk_drv_cipher_calc_rsa(cipher_rsa_data_s *rsa_data)
+{
+    gk_s32 ret;
+
+    if (rsa_data == GK_NULL) {
+        gk_err_cipher("Invalid params!\n");
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    if (cipher_mutex_lock(&g_rsa_mutex_kernel)) {
+        gk_err_cipher("down_interruptible failed!\n");
+        return GK_FAILURE;
+    }
+
+    ret = drv_cipher_calc_rsa(rsa_data);
+
+    cipher_mutex_unlock(&g_rsa_mutex_kernel);
+
+    return ret;
+}
+
diff -uraN u-boot-2016.11/product/cipher/v2/drv/rsa/drv_rsa.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/rsa/drv_rsa.h
--- u-boot-2016.11/product/cipher/v2/drv/rsa/drv_rsa.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/rsa/drv_rsa.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,20 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __DRV_RSA_H__
+#define __DRV_RSA_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Macro Definition ******************************/
+
+gk_s32 drv_rsa_init(gk_void);
+gk_void drv_rsa_deinit(gk_void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* __DRV_CIPHER_H__ */
diff -uraN u-boot-2016.11/product/cipher/v2/drv/spacc/spacc_body.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/spacc/spacc_body.c
--- u-boot-2016.11/product/cipher/v2/drv/spacc/spacc_body.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/spacc/spacc_body.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,1122 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "cipher_adapt.h"
+#include "spacc_union_define.h"
+#include "spacc_body.h"
+#include "spacc_reg.h"
+
+#define spacc_point_return_if_null(p) \
+    do { \
+        if (!(p)) \
+            return SPACC_ERR_NULL_POINT; \
+    } while (0)
+
+#define spacc_value_return_if_max(val, max) \
+    do { \
+        if ((val) >= (max)) \
+            return SPACC_ERR_INVALID_PARAM; \
+    } while (0)
+
+#if 0
+#define SAPCC_SYMC_IN_ENTRY_TOTAL_SIZE \
+    (sizeof(struct spacc_symc_in_entry_t) * SPACC_MAX_DEPTH)
+#define SAPCC_SYMC_OUT_ENTRY_TOTAL_SIZE \
+    (sizeof(struct spacc_symc_out_entry_t) * SPACC_MAX_DEPTH)
+#define SAPCC_SYMC_ENTRY_TOTAL_SIZE \
+    (SAPCC_SYMC_IN_ENTRY_TOTAL_SIZE + SAPCC_SYMC_OUT_ENTRY_TOTAL_SIZE)
+#define SAPCC_DIGEST_IN_ENTRY_TOTAL_SIZE \
+    (sizeof(struct spacc_digest_in_entry_t) * SPACC_MAX_DEPTH)
+#else
+#define SAPCC_SYMC_IN_ENTRY_TOTAL_SIZE      (SPACC_PAGE_SIZE)
+#define SAPCC_SYMC_OUT_ENTRY_TOTAL_SIZE     (SPACC_PAGE_SIZE)
+#define SAPCC_DIGEST_IN_ENTRY_TOTAL_SIZE    (SPACC_PAGE_SIZE)
+#endif
+
+#define spacc_err(fmt, ...)     \
+    GK_PRINT("\033[0;31m%s-%03d"fmt"\033[0m;", __FUNCTION__, __LINE__, ##__VA_ARGS__)
+#define spacc_dbg(fmt...)       // GK_PRINT(fmt)
+
+/* spacc symc int entry struct which is defined by hardware, you can't change it */
+struct spacc_symc_in_entry_t {
+    unsigned int spacc_cmd: 2;
+    unsigned int rev1: 6;
+    unsigned int sym_ctrl: 7;
+    unsigned int rev2: 1;
+    unsigned int gcm_iv_len: 4;
+    unsigned int rev3: 12;
+    unsigned int sym_start_addr_high;
+    unsigned int sym_start_addr;
+    unsigned int sym_alg_length;
+    unsigned int symc_iv[4]; /* 4 iv len */
+};
+
+/* spacc digest in entry struct which is defined by hardware, you can't change it */
+struct spacc_digest_in_entry_t {
+    unsigned int spacc_cmd: 2;
+    unsigned int rev1: 6;
+    unsigned int hash_ctrl: 6;
+    unsigned int rev2: 18;
+    unsigned int hash_start_addr;
+    unsigned int hash_alg_length;
+    unsigned int hash_start_addr_high;
+};
+
+/* spacc symc out entry struct which is defined by hardware, you can't change it */
+struct spacc_symc_out_entry_t {
+    unsigned int rev1: 8;
+    unsigned int aes_ctrl: 4;
+    unsigned int rev2: 20;
+    unsigned int sym_start_addr;
+    unsigned int sym_alg_length;
+    unsigned int hash_rslt_start_addr;
+    unsigned int tag[4]; /* 4 tag len */
+};
+
+struct spacc_symc_context {
+    symc_alg_en  symc_alg;
+    symc_mode_en symc_mode;
+    unsigned int symc_iv[4]; /* 4 iv len */
+    unsigned int symc_ivlen;
+
+    unsigned int *pad_vir_addr;
+    unsigned int pad_phy_addr;
+
+    struct spacc_symc_in_entry_t*   entry_symc_in;
+    struct spacc_symc_out_entry_t*  entry_symc_out;
+    struct spacc_digest_in_entry_t* entry_digest_in;
+
+    unsigned int entry_symc_in_depth;
+    unsigned int entry_symc_out_depth;
+    unsigned int symc_cur_in_nodes;
+    unsigned int symc_cur_out_nodes;
+};
+
+struct spacc_digest_context {
+    digest_alg_en  digest_alg;
+    digest_mode_en digest_mode;
+    unsigned int digest_key[SPACC_MAX_HMAC_KEY_LEN / 4]; /* 4 */
+    unsigned int digest_klen;
+    unsigned int digest_len;
+    unsigned int digest_blen;
+
+    struct spacc_digest_in_entry_t* entry_digest_in;
+    unsigned int entry_digest_in_depth;
+    unsigned int digest_cur_in_nodes;
+
+    unsigned int hard_key;
+};
+
+void *g_spacc_reg_base = 0;
+static struct spacc_symc_context   g_symc_context[SPACC_LOGIC_MAX_CHN];
+static struct spacc_digest_context g_digest_context[SPACC_LOGIC_MAX_CHN];
+
+static gk_void spacc_secure_chn_enable(gk_void)
+{
+    u_sec_chn_cfg sec_chn_cfg;
+
+    sec_chn_cfg.u32 = spacc_read(SEC_CHN_CFG);
+    sec_chn_cfg.bits.cipher_sec_chn_cfg |= SPACC_CHN_MASK;
+    sec_chn_cfg.bits.hash_sec_chn_cfg |= SPACC_CHN_MASK;
+    spacc_write(SEC_CHN_CFG, sec_chn_cfg.u32);
+    spacc_dbg("SEC_CHN_CFG[%p]: 0x%x\n", SEC_CHN_CFG, sec_chn_cfg.u32);
+    hal_cipher_read_reg(SEC_CHN_CFG, &sec_chn_cfg.u32);
+}
+
+static gk_void spacc_smmu_enable(unsigned int mmu_table_addr)
+{
+#ifdef SMMU_ENABLE
+    u_cipher_in_smmu_en cipher_in_smmu_en;
+    u_out_smmu_en out_smmu_en;
+    u_hash_in_smmu_en hash_in_smmu_en;
+
+    cipher_in_smmu_en.u32 = spacc_read(CIPHER_IN_SMMU_EN);
+    out_smmu_en.u32 = spacc_read(OUT_SMMU_EN);
+    hash_in_smmu_en.u32 = spacc_read(HASH_IN_SMMU_EN);
+
+    cipher_in_smmu_en.bits.cipher_in_chan_rd_dat_smmu_en  |= SPACC_CHN_MASK >> 1;
+    cipher_in_smmu_en.bits.cipher_in_chan_rd_node_smmu_en |= SPACC_CHN_MASK >> 1;
+
+    out_smmu_en.bits.out_chan_wr_dat_smmu_en  |= SPACC_CHN_MASK >> 1;
+    out_smmu_en.bits.out_chan_rd_node_smmu_en |= SPACC_CHN_MASK >> 1;
+
+    hash_in_smmu_en.bits.hash_in_chan_rd_dat_smmu_en |= SPACC_CHN_MASK >> 1;
+    hash_in_smmu_en.bits.hash_in_chan_rd_node_smmu_en |= SPACC_CHN_MASK >> 1;
+
+    spacc_write(CIPHER_IN_SMMU_EN, cipher_in_smmu_en.u32);
+    spacc_write(OUT_SMMU_EN, out_smmu_en.u32);
+    spacc_write(HASH_IN_SMMU_EN, hash_in_smmu_en.u32);
+
+    spacc_dbg("CIPHER_IN_SMMU_EN[%p]: 0x%x\n", CIPHER_IN_SMMU_EN, cipher_in_smmu_en.u32);
+    spacc_dbg("OUT_SMMU_EN[%p]      : 0x%x\n", OUT_SMMU_EN, out_smmu_en.u32);
+    spacc_dbg("HASH_IN_SMMU_EN[%p]  : 0x%x\n", HASH_IN_SMMU_EN, hash_in_smmu_en.u32);
+#ifdef REE_NONSECURE_ENABLE
+    spacc_write(NORM_SMMU_START_ADDR, mmu_table_addr);
+#else
+    spacc_write(SEC_SMMU_START_ADDR, mmu_table_addr);
+#endif
+#endif // SMMU_ENABLE
+}
+
+static gk_void spacc_int_enable(gk_void)
+{
+#ifdef INT_ENABLE
+    u_cipher_int_en cipher_int_en;
+    u_hash_int_en hash_int_en;
+
+    cipher_int_en.u32 = spacc_read(CIPHER_INT_EN);
+    hash_int_en.u32 = spacc_read(HASH_INT_EN);
+
+    cipher_int_en.bits.cipher_chn_obuf_en |= SPACC_CHN_MASK;
+    hash_int_en.bits.hash_chn_oram_en |= SPACC_CHN_MASK;
+
+    cipher_int_en.bits.cipher_nsec_int_en = 1;
+    hash_int_en.bits.hash_int_en = 1;
+
+    spacc_write(CIPHER_INT_EN, cipher_int_en.u32);
+    spacc_write(HASH_INT_EN, hash_int_en.u32);
+    spacc_dbg("CIPHER_INT_EN: 0x%x\n", cipher_int_en.u32);
+    spacc_dbg("HASH_INT_EN: 0x%x\n", hash_int_en.u32);
+#endif
+}
+
+static gk_void spacc_config_start_addr(unsigned long entry_phy_addr, gk_void *entry_via_addr)
+{
+    unsigned int i;
+    gk_size_t page_phy;
+    gk_void *page_via = GK_NULL;
+
+    page_phy = entry_phy_addr;
+    page_via = entry_via_addr;
+
+    for (i = CIPHER_PKG_N_CHN_MIN; i <= CIPHER_PKG_N_CHN_MAX; i++) {
+        u_chann_cipher_in_node_cfg cipher_in_cfg;
+        u_chann_cipher_out_node_cfg cipher_out_cfg;
+        u_chann_hash_in_node_cfg hash_in_cfg;
+
+        /* set total num and start addr for cipher in node */
+        cipher_in_cfg.u32  = spacc_read(chn_n_cipher_in_node_cfg(i));
+        cipher_in_cfg.bits.cipher_in_node_total_num = SPACC_MAX_DEPTH;
+        spacc_write(chn_n_cipher_in_node_cfg(i), cipher_in_cfg.u32);
+        spacc_write(chn_n_cipher_in_node_start_addr(i), get_ulong_low(page_phy));
+        spacc_write(chn_n_cipher_in_node_start_addr_high(i), get_ulong_high(page_phy));
+        spacc_dbg("chn_n_cipher_in_node_cfg[%p]: \t0x%x, PHY: 0x%zx, VIA %p\n",
+            chn_n_cipher_in_node_cfg(i), cipher_in_cfg.u32, page_phy, page_via);
+        g_symc_context[i].entry_symc_in = (struct spacc_symc_in_entry_t*)page_via;
+        g_symc_context[i].symc_cur_in_nodes = cipher_in_cfg.bits.cipher_in_node_wptr;
+        g_symc_context[i].entry_symc_in_depth = 0;
+        page_via += SAPCC_SYMC_IN_ENTRY_TOTAL_SIZE;
+        page_phy += SAPCC_SYMC_IN_ENTRY_TOTAL_SIZE;
+
+        /* set total num and start addr for cipher out node */
+        cipher_out_cfg.u32 = spacc_read(chn_n_cipher_out_node_cfg(i));
+        cipher_out_cfg.bits.cipher_out_node_total_num = SPACC_MAX_DEPTH;
+        spacc_write(chn_n_cipher_out_node_cfg(i), cipher_out_cfg.u32);
+        spacc_write(chn_n_cipher_out_node_start_addr(i), get_ulong_low(page_phy));
+        spacc_write(chn_n_cipher_out_node_start_addr_high(i), get_ulong_high(page_phy));
+        spacc_dbg("chn_n_cipher_out_node_cfg[%p]: \t0x%x, PHY: 0x%zx, VIA %p\n",
+            chn_n_cipher_out_node_cfg(i), cipher_out_cfg.u32, page_phy, page_via);
+        g_symc_context[i].entry_symc_out = (struct spacc_symc_out_entry_t*)page_via;
+        g_symc_context[i].symc_cur_out_nodes = cipher_out_cfg.bits.cipher_out_node_wptr;
+        g_symc_context[i].entry_symc_out_depth = 0;
+        page_via += SAPCC_SYMC_OUT_ENTRY_TOTAL_SIZE;
+        page_phy += SAPCC_SYMC_OUT_ENTRY_TOTAL_SIZE;
+
+        /* set total num and start addr for hash in node */
+        hash_in_cfg.u32 = spacc_read(chn_n_hash_in_node_cfg(i));
+        hash_in_cfg.bits.hash_in_node_total_num = SPACC_MAX_DEPTH;
+        spacc_write(chn_n_hash_in_node_cfg(i), hash_in_cfg.u32);
+        spacc_write(chn_n_hash_in_node_start_addr(i), get_ulong_low(page_phy));
+        spacc_write(chn_n_hash_in_node_start_addr_high(i), get_ulong_high(page_phy));
+        spacc_dbg("chn_n_hash_in_node_cfg[%p]: \t0x%x, PHY: 0x%zx, VIA %p\n",
+            chn_n_hash_in_node_cfg(i), hash_in_cfg.u32, page_phy, page_via);
+        g_digest_context[i].entry_digest_in = (struct spacc_digest_in_entry_t*)page_via;
+        g_digest_context[i].digest_cur_in_nodes = hash_in_cfg.bits.hash_in_node_wptr;
+        g_digest_context[i].entry_digest_in_depth = 0;
+        page_via += SAPCC_DIGEST_IN_ENTRY_TOTAL_SIZE;
+        page_phy += SAPCC_DIGEST_IN_ENTRY_TOTAL_SIZE;
+    }
+}
+
+/**
+ * spacc_init - spacc hardware initialization.
+ * @reg_base: virtual address of spacc module which be accessed by CPU
+ * @mmu_table_addr: mmu base table physical addr, if disable mmu, set it to 0
+ * @entry_phy_addr: a consecutive physical memory, used for nodes
+ *                  list of symc-in, symc-out and hash-in, the size
+ *                   must large than spacc_get_node_list_size().
+ * @entry_via_addr: virtual address of entry_phy_addr.
+ *
+ * Description:
+ *   spacc hardware initialization as follows:
+ *   - reset global var.
+ *   - enable interrupt
+ *   - set nodes list addr
+ *   - set mmu table addr
+ *   - configureure hardware register
+ *
+ * Context:
+ *   this function must be called one time in the beginning.
+ */
+int spacc_init(gk_void *reg_base, unsigned int mmu_table_addr,
+               unsigned long entry_phy_addr, gk_void *entry_via_addr)
+{
+    spacc_point_return_if_null(reg_base);
+    spacc_point_return_if_null(entry_via_addr);
+
+    crypto_memset(&g_symc_context, sizeof(g_symc_context), 0, sizeof(g_symc_context));
+    crypto_memset(&g_digest_context, sizeof(g_digest_context), 0, sizeof(g_digest_context));
+    crypto_memset(entry_via_addr, spacc_get_node_list_size(), 0, spacc_get_node_list_size());
+
+    g_spacc_reg_base = reg_base;
+
+    spacc_secure_chn_enable();
+    spacc_smmu_enable(mmu_table_addr);
+    spacc_int_enable();
+
+    /* configure start addr for in-node and out-node */
+    spacc_config_start_addr(entry_phy_addr, entry_via_addr);
+
+    return SPACC_OK;
+}
+
+/**
+ * spacc_deinit - spacc hardware deinit.
+ */
+int spacc_deinit(void)
+{
+    return SPACC_OK;
+}
+
+/**
+ * spacc_get_node_list_size - return the total size of nodes lists memory required by the drive.
+ */
+unsigned int spacc_get_node_list_size(void)
+{
+    /*********************************************************************
+    symc in node page x1| symc out node page x0.5 | hash in node page x0.5
+    *********************************************************************/
+    return (SPACC_PAGE_SIZE * 3) * (CIPHER_PKG_N_CHN_MAX - CIPHER_PKG_N_CHN_MIN + 1); /* 3 */
+}
+
+int spacc_symc_getiv(unsigned int chn_num, unsigned int *iv, unsigned int ivsize)
+{
+    unsigned int i;
+
+    spacc_value_return_if_max(chn_num, SPACC_LOGIC_MAX_CHN);
+
+    for (i = 0; i < 4; i++) /* 4 iv len */
+        iv[i] = spacc_read(chn_n_cipher_iv_out(chn_num));
+
+    return SPACC_OK;
+}
+
+/*
+ * spacc_symc_gettag - get the tag for CCM/GCM.
+ */
+int spacc_symc_gettag(unsigned int chn_num, unsigned char *tag)
+{
+    struct spacc_symc_context *info = &g_symc_context[chn_num];
+    u_chann_cipher_out_node_cfg out_node_cfg;
+    unsigned int last;
+
+    spacc_value_return_if_max(chn_num, SPACC_LOGIC_MAX_CHN);
+
+    out_node_cfg.u32 = spacc_read(chn_n_cipher_out_node_cfg(chn_num));
+    last = out_node_cfg.bits.cipher_out_node_wptr;
+    last = (last == 0) ? (SPACC_MAX_DEPTH - 1) : (last - 1);
+
+    flush_cache(cipher_align_down((gk_size_t)(uintptr_t)info->entry_symc_out),
+        cipher_align_size((gk_size_t)(uintptr_t)info->entry_symc_out, SPACC_PAGE_SIZE));
+
+    crypto_memcpy(tag, 16, /* 16 tag size */
+        info->entry_symc_out[last].tag, sizeof(info->entry_symc_out[last].tag));
+
+    return SPACC_OK;
+}
+
+/**
+ * spacc_symc_setkey - set even key and odd key for symc.
+ * @chn_num: the logic channel number, must 1~7.
+ * @even_key: even key
+ * @odd_key:  odd key
+ * @klen:     length of key.
+ *
+ * Description:
+ *   the odd key only valid for aes ecb/cbc/ofb/cfb/ctr, and the data to encrypt/decprypt
+ *   must be aligned with 64.
+ *
+ */
+int spacc_symc_setkey(unsigned int chn_num, unsigned int *even_key, unsigned int *odd_key, unsigned int klen)
+{
+    struct spacc_symc_context *info = &g_symc_context[chn_num];
+    unsigned int i;
+
+    spacc_value_return_if_max(chn_num, SPACC_LOGIC_MAX_CHN);
+
+    spacc_point_return_if_null(even_key);
+    spacc_point_return_if_null(odd_key);
+    spacc_value_return_if_max(klen, 49); /* 49 klen max */
+    /* Set even key */
+    spacc_write(ODD_EVEN_KEY_SEL, 0x00);
+    for (i = 0; (i < klen / 4) && (i < 8); i++) { /* 4, 8 */
+        spacc_write(cipher_key(chn_num) + i * 4, even_key[i]); /* 4 */
+        spacc_dbg("EVEN key[%p]: 0x%x\n", cipher_key(chn_num) + i * 4, even_key[i]); /* 4 */
+    }
+
+    if (info->symc_alg == SYMC_ALG_SM1) {
+        for (i = 0; i < 4; i++) { /* 4  */
+            spacc_write(sm1_sk(chn_num) + i * 4, even_key[i + 8]); /* 4, 8 */
+            spacc_dbg("SK[%p]: 0x%x\n", sm1_sk(chn_num) + i * 4, even_key[i + 8]); /* 4, 8 */
+        }
+    }
+
+    return SPACC_OK;
+}
+
+/**
+ * spacc_symc_setiv - set iv for symc.
+ * @chn_num: the logic channel number, must 1~7.
+ * @iv: the initialization vector
+ * @ivlen:  length of iv.
+ *
+ * Description:
+ *   here store the iv to global structure of channel, don't set to logic,
+ *   because the IV must be set in the nodes list.
+ *
+ */
+int spacc_symc_setiv(unsigned int chn_num, unsigned char *iv, unsigned int ivlen)
+{
+    struct spacc_symc_context *info = &g_symc_context[chn_num];
+
+    spacc_value_return_if_max(chn_num, SPACC_LOGIC_MAX_CHN);
+    spacc_point_return_if_null(iv);
+    spacc_value_return_if_max(ivlen, 33); /* 33 iv max size */
+
+    crypto_memset(info->symc_iv, sizeof(info->symc_iv), 0, sizeof(info->symc_iv));
+    crypto_memcpy(info->symc_iv, sizeof(info->symc_iv), iv, ivlen);
+    info->symc_ivlen = ivlen;
+
+    return SPACC_OK;
+}
+
+/*
+ * spacc_symc_addbuf - filling the buf addr and length of
+ *   encrypt/decrypt data into nodes list.
+ */
+int spacc_symc_addbuf(unsigned int chn_num, unsigned long buf_phy,
+    unsigned int buf_size, spacc_buf_type_en type, unsigned int ctrl)
+{
+    struct spacc_symc_context *info = &g_symc_context[chn_num];
+    unsigned int id, size;
+    void *addr = GK_NULL;
+
+    spacc_value_return_if_max(chn_num, SPACC_LOGIC_MAX_CHN);
+    switch (type) {
+        case SPACC_BUF_TYPE_SYMC_IN:
+            id = info->symc_cur_in_nodes++;
+            addr = &info->entry_symc_in[id];
+            size = sizeof(struct spacc_symc_in_entry_t);
+            crypto_memset(addr, sizeof(info->entry_symc_in[id]), 0, size);
+            info->entry_symc_in[id].spacc_cmd = 0x00;
+            info->entry_symc_in[id].sym_start_addr = get_ulong_low(buf_phy);
+            info->entry_symc_in[id].sym_start_addr_high = get_ulong_high(buf_phy);
+            info->entry_symc_in[id].sym_alg_length = buf_size;
+            info->entry_symc_in[id].sym_ctrl = ctrl;
+            info->entry_symc_in_depth++;
+            info->symc_cur_in_nodes %= SPACC_MAX_DEPTH;
+            spacc_dbg("chn %d, add symc in buf: id %d, addr 0x%zx, len 0x%x, ctrl 0x%x\n",
+                chn_num, id, buf_phy, buf_size, ctrl);
+            break;
+        case SPACC_BUF_TYPE_SYMC_OUT:
+            id = info->symc_cur_out_nodes++;
+            addr = &info->entry_symc_out[id];
+            size = sizeof(struct spacc_symc_out_entry_t);
+            crypto_memset(addr, sizeof(info->entry_symc_out[id]), 0, size);
+            info->entry_symc_out[id].sym_start_addr = get_ulong_low(buf_phy);
+            info->entry_symc_out[id].tag[0] = get_ulong_high(buf_phy);
+            info->entry_symc_out[id].sym_alg_length = buf_size;
+            info->entry_symc_out[id].aes_ctrl = ctrl;
+            info->entry_symc_out_depth++;
+            info->symc_cur_out_nodes %= SPACC_MAX_DEPTH;
+            spacc_dbg("chn %d, add symc out buf: id %d, addr 0x%zx, len 0x%x\n", chn_num, id, buf_phy, buf_size);
+            break;
+        default:
+            return SPACC_ERR_INVALID_PARAM;
+    }
+
+    flush_cache(cipher_align_down(buf_phy), cipher_align_size(buf_phy, buf_size));
+
+    return SPACC_OK;
+}
+
+/*
+ * spacc_symc_addbuf - add a flags to the last valid nodes.
+ */
+int spacc_symc_addctrl(unsigned int chn_num, spacc_buf_type_en type, unsigned int ctrl)
+{
+    struct spacc_symc_context *info = &g_symc_context[chn_num];
+    unsigned int id;
+
+    spacc_value_return_if_max(chn_num, SPACC_LOGIC_MAX_CHN);
+
+    switch (type) {
+        case SPACC_BUF_TYPE_SYMC_IN:
+            id = (info->symc_cur_in_nodes == 0) ? SPACC_MAX_DEPTH - 1 : info->symc_cur_in_nodes - 1;
+            info->entry_symc_in[id].sym_ctrl |= ctrl;
+            break;
+        case SPACC_BUF_TYPE_SYMC_OUT:
+            id = (info->symc_cur_out_nodes == 0) ? SPACC_MAX_DEPTH - 1 : info->symc_cur_out_nodes - 1;
+            info->entry_symc_out[id].aes_ctrl |= ctrl;
+            break;
+        default:
+            return SPACC_ERR_INVALID_PARAM;
+    }
+
+    return SPACC_OK;
+}
+
+/*
+ * spacc_symc_configure - configure logic register, such as alg, mode, key len and so on.
+ */
+int spacc_symc_config(unsigned int chn_num, spacc_symc_config_s *symc_cfg,
+    unsigned char sm1_round_num, unsigned char hard_key)
+{
+    struct spacc_symc_context *info = &g_symc_context[chn_num];
+    u_chann_cipher_ctrl cipher_ctrl;
+    unsigned int symc_klen = 0;
+
+    spacc_value_return_if_max(chn_num, SPACC_LOGIC_MAX_CHN);
+    spacc_value_return_if_max(symc_cfg->symc_alg, SYMC_ALG_COUNT);
+    spacc_value_return_if_max(symc_cfg->symc_mode, SYMC_MODE_COUNT);
+    spacc_value_return_if_max(symc_cfg->symc_width, SYMC_DAT_WIDTH_COUNT);
+
+    if (symc_cfg->symc_alg == SYMC_ALG_AES)
+        symc_klen = symc_cfg->key_len / 8 - 2; /* 8, 2 */
+    else if (symc_cfg->symc_alg == SYMC_ALG_3DES)
+        symc_klen = (symc_cfg->key_len == 16 ? 3 : 2); /* 16, 3, 2 */
+
+    cipher_ctrl.u32 = spacc_read(chn_n_cipher_ctrl(chn_num));
+    cipher_ctrl.bits.sym_chn_sm1_round_num = sm1_round_num;
+    cipher_ctrl.bits.sym_chn_key_sel = hard_key;
+    cipher_ctrl.bits.sym_chn_key_length = symc_klen;
+    cipher_ctrl.bits.sym_chn_dat_width = symc_cfg->symc_width;
+    cipher_ctrl.bits.sym_chn_decrypt = 0x00;
+    cipher_ctrl.bits.sym_chn_alg_sel = symc_cfg->symc_alg;
+    cipher_ctrl.bits.sym_chn_alg_mode = symc_cfg->symc_mode;
+    spacc_write(chn_n_cipher_ctrl(chn_num), cipher_ctrl.u32);
+    spacc_dbg("chn_n_cipher_ctrl(%d): 0x%x\n", chn_num, cipher_ctrl.u32);
+
+    info->symc_alg = symc_cfg->symc_alg;
+    info->symc_mode = symc_cfg->symc_mode;
+    info->entry_symc_in_depth = 0;
+    info->entry_symc_out_depth = 0;
+
+    return SPACC_OK;
+}
+
+static int spacc_config_out_node(unsigned int chn_num, struct spacc_symc_context *info)
+{
+    u_chann_cipher_out_node_cfg out_node_cfg;
+    unsigned int ptr;
+
+    out_node_cfg.u32 = spacc_read(chn_n_cipher_out_node_cfg(chn_num));
+    if (out_node_cfg.bits.cipher_out_node_wptr != out_node_cfg.bits.cipher_out_node_rptr) {
+        spacc_err("Error, chn %d is busy.\n", chn_num);
+        return SPACC_ERR_BUSY;
+    }
+    ptr = out_node_cfg.bits.cipher_out_node_wptr + info->entry_symc_out_depth;
+    out_node_cfg.bits.cipher_out_node_wptr = ptr % SPACC_MAX_DEPTH;
+    out_node_cfg.bits.cipher_out_node_mpackage_int_level = info->entry_symc_out_depth;
+    spacc_write(chn_n_cipher_out_node_cfg(chn_num), out_node_cfg.u32);
+    spacc_dbg("chn_n_cipher_out_node_cfg: 0x%x\n", out_node_cfg.u32);
+
+    return SPACC_OK;
+}
+
+static void spacc_config_in_node(unsigned int chn_num, struct spacc_symc_context *info)
+{
+    u_chann_cipher_in_node_cfg in_node_cfg;
+    unsigned int ptr;
+
+    in_node_cfg.u32 = spacc_read(chn_n_cipher_in_node_cfg(chn_num));
+    ptr = in_node_cfg.bits.cipher_in_node_wptr + info->entry_symc_in_depth;
+    in_node_cfg.bits.cipher_in_node_wptr = ptr % SPACC_MAX_DEPTH;
+    in_node_cfg.bits.cipher_in_node_mpackage_int_level = info->entry_symc_in_depth;
+
+    spacc_dbg("chn_n_cipher_in_node_cfg: 0x%x\n", in_node_cfg.u32);
+    spacc_dbg("chn %d, start 0x%x from 0x%x to 0x%x\n", chn_num, info->entry_symc_in_depth,
+        in_node_cfg.bits.cipher_in_node_rptr, in_node_cfg.bits.cipher_in_node_wptr);
+
+    /* move forward the in-node ptr to action the symc working */
+    spacc_write(chn_n_cipher_in_node_cfg(chn_num), in_node_cfg.u32);
+}
+
+static void spacc_cipher_chn_crypt(unsigned int chn_num, unsigned int decrypt)
+{
+    u_chann_cipher_ctrl cipher_ctrl;
+
+    cipher_ctrl.u32 = spacc_read(chn_n_cipher_ctrl(chn_num));
+    cipher_ctrl.bits.sym_chn_decrypt = decrypt;
+    spacc_write(chn_n_cipher_ctrl(chn_num), cipher_ctrl.u32);
+}
+
+/*
+ * spacc_symc_start - action the symc start to processing the node list.
+ */
+int spacc_symc_start(unsigned int chn_num, unsigned int decrypt, unsigned int iv_set_flag)
+{
+    unsigned int cur, i, j, node;
+    u_chann_cipher_in_node_cfg in_node_cfg;
+    struct spacc_symc_context *info = &g_symc_context[chn_num];
+
+    spacc_value_return_if_max(chn_num, SPACC_LOGIC_MAX_CHN);
+
+    in_node_cfg.u32 = spacc_read(chn_n_cipher_in_node_cfg(chn_num));
+    cur = in_node_cfg.bits.cipher_in_node_rptr;
+    spacc_dbg("cur %d, depth %d, symc_iv Len %d\n", cur, info->entry_symc_in_depth, info->symc_ivlen);
+    for (j = 0; j < info->entry_symc_in_depth; j++) {
+        if (info->symc_ivlen > 0) {
+            /* Write iv to all nodes */
+            node = (cur + j) % SPACC_MAX_DEPTH;
+            for (i = 0; i < 4; i++) { /* 4 iv len */
+                info->entry_symc_in[node].symc_iv[i] = info->symc_iv[i];
+                spacc_dbg("symc_iv[%d]: 0x%x\n", i, info->symc_iv[i]);
+            }
+
+            /* Set iv len for GCM */
+            if (info->symc_mode == SYMC_MODE_GCM)
+                info->entry_symc_in[node].gcm_iv_len = info->symc_ivlen - 1;
+            else
+                info->entry_symc_in[node].gcm_iv_len = 0;
+
+            /* IV only be set for first node. */
+            if (iv_set_flag == GK_CIPHER_IV_CHG_ONE_PKG) {
+                info->entry_symc_in[node].sym_ctrl |= SPACC_CTRL_SYMC_IN_FIRST;
+                iv_set_flag = 0;
+            } else if ((iv_set_flag == GK_CIPHER_IV_CHG_ALL_PKG) &&
+                (info->symc_mode != SYMC_MODE_CCM) && (info->symc_mode != SYMC_MODE_GCM)) {
+                /* IV will be set for each node. */
+                info->entry_symc_in[node].sym_ctrl |= SPACC_CTRL_SYMC_IN_FIRST | SPACC_CTRL_SYMC_IN_LAST;
+            }
+        }
+    }
+
+    if (spacc_config_out_node(chn_num, info) != SPACC_OK)
+        return SPACC_ERR_BUSY;
+
+    /* encrypt or decrypt */
+    spacc_cipher_chn_crypt(chn_num, decrypt);
+
+    flush_cache(cipher_align_down((gk_size_t)(uintptr_t)info->entry_symc_in),
+        cipher_align_size((gk_size_t)(uintptr_t)info->entry_symc_in, SPACC_PAGE_SIZE));
+    flush_cache(cipher_align_down((gk_size_t)(uintptr_t)info->entry_symc_out),
+        cipher_align_size((gk_size_t)(uintptr_t)info->entry_symc_out, SPACC_PAGE_SIZE));
+
+    /* spacc_config_in_node must be placed after flush_cache, otherwwise it may be crypt timeout */
+    spacc_config_in_node(chn_num, info);
+
+    /* all the nodes are processing, reset the depth to 0 */
+    info->entry_symc_in_depth = 0;
+    info->entry_symc_out_depth = 0;
+
+    return SPACC_OK;
+}
+
+/*
+ * spacc_symc_restart - continue to action the symc to processing the node list.
+ */
+void spacc_symc_restart(unsigned int chn_num, unsigned int iv_set_flag)
+{
+    unsigned int cur, i, j, node;
+    u_chann_cipher_in_node_cfg in_node_cfg;
+    struct spacc_symc_context *info = &g_symc_context[chn_num];
+
+    if (info->entry_symc_in_depth == 0)
+        return;
+
+    in_node_cfg.u32 = spacc_read(chn_n_cipher_in_node_cfg(chn_num));
+    if ((iv_set_flag == GK_CIPHER_IV_CHG_ALL_PKG) &&
+        (info->symc_mode != SYMC_MODE_CCM) && (info->symc_mode != SYMC_MODE_GCM)) {
+        cur = in_node_cfg.bits.cipher_in_node_wptr;
+        for (j = 0; j < info->entry_symc_in_depth; j++) {
+            if (info->symc_ivlen == 0)
+                continue;
+
+            node = (cur + j) % SPACC_MAX_DEPTH;
+            for (i = 0; i < 4; i++) { /* 4 iv len */
+                info->entry_symc_in[node].symc_iv[i] = info->symc_iv[i];
+                spacc_dbg("symc_iv[%d]: 0x%x\n", i, info->symc_iv[i]);
+            }
+            info->entry_symc_in[node].sym_ctrl |= 0x01;
+        }
+    }
+
+    if (spacc_config_out_node(chn_num, info) != SPACC_OK)
+        return;
+    spacc_config_in_node(chn_num, info);
+
+    flush_cache(cipher_align_down((gk_size_t)(uintptr_t)info->entry_symc_in),
+        cipher_align_size((gk_size_t)(uintptr_t)info->entry_symc_in, SPACC_PAGE_SIZE));
+    flush_cache(cipher_align_down((gk_size_t)(uintptr_t)info->entry_symc_out),
+        cipher_align_size((gk_size_t)(uintptr_t)info->entry_symc_out, SPACC_PAGE_SIZE));
+
+    info->entry_symc_in_depth = 0;
+    info->entry_symc_out_depth = 0;
+}
+
+/*
+ * spacc_symc_get_free_nodes - get the num of free spacc nodes.
+ */
+unsigned int spacc_symc_get_free_nodes(unsigned int chn_num)
+{
+    unsigned int read, write, node;
+    u_chann_cipher_in_node_cfg in_node_cfg;
+    struct spacc_symc_context *info = &g_symc_context[chn_num];
+
+    in_node_cfg.u32 = spacc_read(chn_n_cipher_in_node_cfg(chn_num));
+    read  = in_node_cfg.bits.cipher_in_node_rptr;
+    write = in_node_cfg.bits.cipher_in_node_wptr;
+
+    node = (read + SPACC_MAX_DEPTH - write - 1) % SPACC_MAX_DEPTH;
+
+    return (node - info->entry_symc_in_depth);
+}
+
+/*
+ * spacc_symc_done_try - get the int status of symc.
+ */
+unsigned int spacc_symc_done_notify(void)
+{
+    u_cipher_int_raw int_raw;
+    unsigned int chn_mask;
+
+    int_raw.u32 = spacc_read(CIPHER_INT_RAW);
+    int_raw.bits.cipher_chn_obuf_raw &= SPACC_CHN_MASK;
+    chn_mask = int_raw.bits.cipher_chn_obuf_raw;
+    spacc_write(CIPHER_INT_RAW, int_raw.u32);
+
+    return chn_mask;
+}
+
+/*
+ * spacc_symc_done_try - test the int status of symc channel.
+ */
+unsigned int spacc_symc_done_try(unsigned int chn_num)
+{
+    u_cipher_int_raw int_raw;
+    unsigned int chn_mask;
+
+    int_raw.u32 = spacc_read(CIPHER_INT_RAW);
+    int_raw.bits.cipher_chn_obuf_raw &= 0x01 << chn_num;
+    chn_mask = int_raw.bits.cipher_chn_obuf_raw;
+
+    /* Clean raw int */
+    int_raw.u32 = 0x00;
+    int_raw.bits.cipher_chn_obuf_raw = chn_mask;
+    spacc_write(CIPHER_INT_RAW, int_raw.u32);
+
+    return chn_mask ? 1 : 0;
+}
+
+/*
+ * spacc_symc_get_err_code - get the error code of symc.
+ */
+unsigned int spacc_symc_get_err_code(unsigned int chn_num,
+                                     unsigned int *src_addr,
+                                     unsigned int *dst_addr)
+{
+    *src_addr = spacc_read(chn_n_cipher_in_buf_rptr(chn_num));
+    *dst_addr = spacc_read(chn_n_cipher_out_buf_rptr(chn_num));
+
+    return spacc_read(CALC_ERR);
+}
+
+/*
+ * spacc_digest_configure - configure the hash ctrl register.
+ */
+int spacc_digest_config(unsigned int chn_num,
+                        digest_alg_en digest_alg,
+                        digest_mode_en digest_mode,
+                        unsigned char hard_key)
+{
+    struct spacc_digest_context *info = &g_digest_context[chn_num];
+    u_chann_hash_ctrl hash_ctrl;
+
+    spacc_value_return_if_max(chn_num, SPACC_LOGIC_MAX_CHN);
+    spacc_value_return_if_max(digest_alg, DIGEST_ALG_COUNT);
+    spacc_value_return_if_max(digest_mode, DIGEST_MODE_COUNT);
+
+    info->digest_alg = digest_alg;
+    info->digest_mode = digest_mode;
+
+    switch (digest_alg) {
+        case DIGEST_ALG_SHA1:
+            info->digest_len = 20;   /* 20 sha1 digest len */
+            info->digest_blen = 64;  /* 64 sha1 digest blen */
+            break;
+        case DIGEST_ALG_SHA224:
+            info->digest_len = 28;   /* 28 sha1 digest len */
+            info->digest_blen = 64;  /* 64 sha1 digest blen */
+            break;
+        case DIGEST_ALG_SM3:
+        case DIGEST_ALG_SHA256:
+            info->digest_len = 32;   /* 32 sha1 digest len */
+            info->digest_blen = 64;  /* 64 sha1 digest blen */
+            break;
+        case DIGEST_ALG_SHA384:
+            info->digest_len = 48;   /* 48 sha1 digest len */
+            info->digest_blen = 128; /* 128 sha1 digest blen */
+            break;
+        case DIGEST_ALG_SHA512:
+            info->digest_len = 64;   /* 64 sha1 digest len */
+            info->digest_blen = 128; /* 128 sha1 digest blen */
+            break;
+        default:
+            return SPACC_ERR_INVALID_PARAM;
+    }
+
+    hash_ctrl.u32 = spacc_read(chn_n_hash_ctrl(chn_num));
+    hash_ctrl.bits.hash_chn_mode = digest_mode;
+    hash_ctrl.bits.hash_chn_agl_sel = digest_alg;
+    spacc_write(chn_n_hash_ctrl(chn_num), hash_ctrl.u32);
+    spacc_dbg("CTRL: 0x%X\n", hash_ctrl.u32);
+
+    info->entry_digest_in_depth = 0;
+    info->hard_key = hard_key;
+
+    return SPACC_OK;
+}
+
+/**
+ * spacc_digest_addbuf - filling the buf addr and length of
+ *   data into nodes list.
+ *
+ */
+int spacc_digest_addbuf(unsigned int chn_num,
+                        unsigned long buf_phy,
+                        unsigned int buf_size,
+                        unsigned int ctrl)
+{
+    struct spacc_digest_context *info = &g_digest_context[chn_num];
+    unsigned int id, size;
+    void *addr = GK_NULL;
+
+    spacc_value_return_if_max(chn_num, SPACC_LOGIC_MAX_CHN);
+
+    id = info->digest_cur_in_nodes++;
+    addr = &info->entry_digest_in[id];
+    size = sizeof(struct spacc_digest_in_entry_t);
+    crypto_memset(addr, sizeof(info->entry_digest_in[id]), 0, size);
+    info->entry_digest_in[id].spacc_cmd = 0x00;
+    info->entry_digest_in[id].hash_start_addr = get_ulong_low(buf_phy);
+    info->entry_digest_in[id].hash_alg_length = buf_size;
+    info->entry_digest_in[id].hash_ctrl = ctrl;
+    info->entry_digest_in[id].hash_start_addr_high = get_ulong_high(buf_phy);
+    info->entry_digest_in_depth++;
+    info->digest_cur_in_nodes %= SPACC_MAX_DEPTH;
+    spacc_dbg("add digest in buf: id %d, addr 0x%zx, len 0x%x, ctrl 0x%x\n", id, buf_phy, buf_size, ctrl);
+
+    flush_cache (cipher_align_down(buf_phy), cipher_align_size(buf_phy, buf_size));
+
+    return SPACC_OK;
+}
+
+/**
+ * spacc_digest_addctrl - add a flags to the last valid nodes.
+ *
+ */
+int spacc_digest_addctrl(unsigned int chn_num, unsigned int ctrl)
+{
+    struct spacc_digest_context *info = &g_digest_context[chn_num];
+    unsigned int id;
+
+    spacc_value_return_if_max(chn_num, SPACC_LOGIC_MAX_CHN);
+
+    id = (info->digest_cur_in_nodes == 0) ? SPACC_MAX_DEPTH - 1 : info->digest_cur_in_nodes - 1;
+    info->entry_digest_in[id].hash_ctrl |= ctrl;
+
+    return SPACC_OK;
+}
+
+/**
+ * spacc_digest_get - get hash result.
+ *
+ */
+int spacc_digest_get(unsigned int chn_num, unsigned int *digest)
+{
+    unsigned int i;
+
+    spacc_value_return_if_max(chn_num, SPACC_LOGIC_MAX_CHN);
+
+    for (i = 0; i < HASH_RESULT_MAX_SIZE_IN_WORD; i++) {
+        spacc_write(chn_n_hash_state_val_addr(chn_num), i);
+        digest[i] = spacc_read(chn_n_hash_state_val(chn_num));
+        spacc_dbg("digest[%d]: 0x%x\n", i, digest[i]);
+    }
+
+    return SPACC_OK;
+}
+
+/*
+ * spacc_digest_start - action the hash start to processing the node list.
+ */
+int spacc_digest_start(unsigned int chn_num, spacc_ctrl_en spacc_ctrl, unsigned int *state)
+{
+    unsigned int i;
+    u_chann_hash_in_node_cfg in_node_cfg;
+    struct spacc_digest_context *info = &g_digest_context[chn_num];
+    unsigned int ptr;
+
+    spacc_value_return_if_max(chn_num, SPACC_LOGIC_MAX_CHN);
+
+    spacc_dbg("chn %d, digest_mode %d, ctrl %d\n", chn_num, info->digest_mode, spacc_ctrl);
+
+    /* Write last state */
+    for (i = 0; i < HASH_RESULT_MAX_SIZE_IN_WORD; i++) {
+        spacc_write(chn_n_hash_state_val_addr(chn_num), i);
+        spacc_write(chn_n_hash_state_val(chn_num), state[i]);
+        spacc_dbg("state: 0x%x\n", state[i]);
+    }
+
+    if (info->entry_digest_in_depth == 0)
+        return SPACC_OK;
+
+    /* configure in-node */
+    in_node_cfg.u32 = spacc_read(chn_n_hash_in_node_cfg(chn_num));
+    if (in_node_cfg.bits.hash_in_node_wptr != in_node_cfg.bits.hash_in_node_rptr) {
+        spacc_err("Error, chn %d is busy.\n", chn_num);
+        return SPACC_ERR_BUSY;
+    }
+    ptr = in_node_cfg.bits.hash_in_node_wptr + info->entry_digest_in_depth;
+    in_node_cfg.bits.hash_in_node_wptr = ptr % SPACC_MAX_DEPTH;
+    in_node_cfg.bits.hash_in_node_mpackage_int_level = 1;
+
+    flush_cache(cipher_align_down((gk_size_t)(uintptr_t)info->entry_digest_in), \
+        cipher_align_size((gk_size_t)(uintptr_t)info->entry_digest_in, SPACC_PAGE_SIZE));
+
+    /* Start */
+    spacc_write(chn_n_hash_in_node_cfg(chn_num), in_node_cfg.u32);
+    spacc_dbg("chn_n_hash_in_node_cfg: 0x%x\n", in_node_cfg.u32);
+
+    return SPACC_OK;
+}
+
+/*
+ * spacc_digest_done_notify - get the int status of hash.
+ */
+unsigned int spacc_digest_done_notify(void)
+{
+    u_hash_int_raw int_raw;
+    unsigned int chn_mask;
+
+    int_raw.u32 = spacc_read(HASH_INT_RAW);
+    int_raw.bits.hash_chn_oram_raw &= SPACC_CHN_MASK;
+    chn_mask = int_raw.bits.hash_chn_oram_raw;
+
+    /* Clean raw int */
+    spacc_write(HASH_INT_RAW, int_raw.u32);
+
+    return chn_mask;
+}
+
+/*
+ * spacc_digest_done_try - test the int status of hash channel.
+ */
+unsigned int spacc_digest_done_try(unsigned int chn_num)
+{
+    u_hash_int_raw int_raw;
+    unsigned int chn_mask;
+
+    int_raw.u32 = spacc_read(HASH_INT_RAW);
+    int_raw.bits.hash_chn_oram_raw &= 0x01 << chn_num;
+    chn_mask = int_raw.bits.hash_chn_oram_raw;
+
+    /* Clean raw int */
+    spacc_write(HASH_INT_RAW, int_raw.u32);
+
+    return chn_mask;
+}
+
+/*
+ * spacc_digest_get_err_code - get the error code of hash.
+ */
+unsigned int spacc_digest_get_err_code(unsigned int chn_num, unsigned int *src_addr)
+{
+    *src_addr = spacc_read(chn_n_hash_in_buf_rptr(chn_num));
+
+    return spacc_read(CALC_ERR);
+}
+
+/******************* proc function begin *******************/
+#ifndef DISABLE_DEBUG_INFO
+static gk_void spacc_symc_proc_alg_sel(gk_u32 chn,
+                                       cipher_chn_status_s *cipher_status,
+                                       u_chann_cipher_ctrl cipher_ctrl)
+{
+    switch (cipher_ctrl.bits.sym_chn_alg_sel) {
+        case GK_CIPHER_ALG_AES:
+            cipher_status[chn].alg = "AES ";
+            break;
+        case GK_CIPHER_ALG_SM1:
+            cipher_status[chn].alg = "SM1 ";
+            break;
+        case GK_CIPHER_ALG_SM4:
+            cipher_status[chn].alg = "SM4 ";
+            break;
+        case GK_CIPHER_ALG_DMA:
+            cipher_status[chn].alg = "DMA ";
+            break;
+        default:
+            cipher_status[chn].alg = "BUTT";
+            break;
+    }
+}
+
+static gk_void spacc_symc_proc_alg_mode(gk_u32 chn,
+                                        cipher_chn_status_s *cipher_status,
+                                        u_chann_cipher_ctrl cipher_ctrl)
+{
+    switch (cipher_ctrl.bits.sym_chn_alg_mode) {
+        case GK_CIPHER_WORK_MODE_ECB:
+            cipher_status[chn].mode = "ECB ";
+            break;
+        case GK_CIPHER_WORK_MODE_CBC:
+            cipher_status[chn].mode = "CBC ";
+            break;
+        case GK_CIPHER_WORK_MODE_CFB:
+            cipher_status[chn].mode = "CFB ";
+            break;
+        case GK_CIPHER_WORK_MODE_OFB:
+            cipher_status[chn].mode = "OFB ";
+            break;
+        case GK_CIPHER_WORK_MODE_CTR:
+            cipher_status[chn].mode = "CTR ";
+            break;
+        case GK_CIPHER_WORK_MODE_CCM:
+            cipher_status[chn].mode = "CCM ";
+            break;
+        case GK_CIPHER_WORK_MODE_GCM:
+            cipher_status[chn].mode = "GCM ";
+            break;
+        default:
+            cipher_status[chn].mode = "BUTT";
+            break;
+    }
+}
+
+static gk_void spacc_symc_proc_key_len(gk_u32 chn,
+                                       cipher_chn_status_s *cipher_status,
+                                       u_chann_cipher_ctrl cipher_ctrl)
+{
+    if (cipher_ctrl.bits.sym_chn_alg_sel == GK_CIPHER_ALG_AES) {
+        switch (cipher_ctrl.bits.sym_chn_key_length) {
+            case GK_CIPHER_KEY_AES_128BIT:
+                cipher_status[chn].key_len = 128; /* 128 key len */
+                break;
+            case GK_CIPHER_KEY_AES_192BIT:
+                cipher_status[chn].key_len = 192; /* 192 key len */
+                break;
+            case GK_CIPHER_KEY_AES_256BIT:
+                cipher_status[chn].key_len = 256; /* 256 key len */
+                break;
+            default:
+                cipher_status[chn].key_len = 0;
+                break;
+        }
+    } else if(cipher_ctrl.bits.sym_chn_alg_sel == GK_CIPHER_ALG_SM1) {
+        cipher_status[chn].key_len = 384; /* 384 key len */
+    } else if(cipher_ctrl.bits.sym_chn_alg_sel == GK_CIPHER_ALG_SM4) {
+        cipher_status[chn].key_len = 128; /* 128 key len */
+    } else {
+        cipher_status[chn].key_len = 0;
+    }
+}
+
+static gk_void spacc_symc_proc_int_info(gk_u32 chn, cipher_chn_status_s *cipher_status)
+{
+    u_cipher_int_raw int_raw;
+    u_cipher_int_en int_en;
+    u_chann_cipher_in_node_cfg in_node;
+    gk_u32 *reg_addr = GK_NULL;
+
+    /* get INT RAW status */
+    int_raw.u32 = spacc_read(CIPHER_INT_RAW);
+    cipher_status[chn].in_int_raw = (int_raw.bits.cipher_chn_ibuf_raw >> chn) & 0x1;
+    cipher_status[chn].out_int_raw = (int_raw.bits.cipher_chn_obuf_raw >> chn) & 0x1;
+
+    /* get INT EN status */
+    int_en.u32 = spacc_read(CIPHER_INT_EN);
+    cipher_status[chn].in_int_en = int_en.bits.cipher_nsec_int_en;
+    cipher_status[chn].out_int_en = (int_en.bits.cipher_chn_ibuf_en >> chn) & 0x1;
+    cipher_status[chn].in_int_all_en = (int_en.bits.cipher_chn_obuf_en >> chn) & 0x1;
+
+    /* get INT_OINTCFG */
+    reg_addr = chn_n_cipher_in_node_cfg(chn);
+    in_node.u32 = spacc_read(reg_addr);
+    cipher_status[chn].out_int_count = in_node.bits.cipher_in_node_mpackage_int_level;
+}
+
+gk_s32 spacc_symc_proc_status(cipher_chn_status_s *cipher_status)
+{
+    gk_u32 *reg_addr = 0;
+    u_chann_cipher_ctrl cipher_ctrl;
+    gk_u32 value;
+    gk_u32 i, j;
+
+    if (cipher_status == NULL) {
+        gk_err_cipher("HAL_CIPHER_ProcGetStatus failed!\n");
+        return GK_FAILURE;
+    }
+
+    for (i = 0; i < 8; i++) { /* 8 max channel number */
+        if (i != 0)
+            reg_addr = chn_n_cipher_ctrl(i);
+        else
+            reg_addr = CHN_0_CIPHER_CTRL;
+
+        /* get cipher ctrl */
+        cipher_ctrl.u32 = spacc_read(reg_addr);
+        cipher_status[i].is_decrypt = cipher_ctrl.bits.sym_chn_decrypt;
+
+        spacc_symc_proc_alg_sel(i, cipher_status, cipher_ctrl); /* get alg sel */
+        spacc_symc_proc_alg_mode(i, cipher_status, cipher_ctrl); /* get alg mode */
+        spacc_symc_proc_key_len(i, cipher_status, cipher_ctrl); /* get key len */
+
+        /* get key sel */
+        if (cipher_ctrl.bits.sym_chn_key_sel)
+            cipher_status[i].key_from = "HW";
+        else
+            cipher_status[i].key_from = "SW";
+
+        /* get data in */
+        if (i != 0) {
+            reg_addr = chn_n_cipher_in_buf_rptr(i);
+            cipher_status[i].data_in_addr = spacc_read(reg_addr);
+        } else {
+            cipher_status[0].data_in_addr = CIPHER_CIPHER_REG_BASE_ADDR_PHY + 0x420;
+        }
+
+        /* get data out */
+        if (i != 0) {
+            reg_addr = chn_n_cipher_out_buf_rptr(i);
+            cipher_status[i].data_out_addr = spacc_read(reg_addr);
+        } else {
+            cipher_status[0].data_out_addr = CIPHER_CIPHER_REG_BASE_ADDR_PHY + 0x80;
+        }
+
+        for (j = 0; j < 4; j++) { /* 4 */
+            value = spacc_read(chn_n_cipher_iv_out(i) + j * 4); /* 4 */
+            hex2str(cipher_status[i].iv_string + j * 8, (gk_u8)(value & 0xFF)); /* 8 */
+            hex2str(cipher_status[i].iv_string + j * 8 + 2, (gk_u8)((value >> 8) & 0xFF)); /* 8, 2 */
+            hex2str(cipher_status[i].iv_string + j * 8 + 4, (gk_u8)((value >> 16) & 0xFF)); /* 8, 4, 16 */
+            hex2str(cipher_status[i].iv_string + j * 8 + 6, (gk_u8)((value >> 24) & 0xFF)); /* 8, 6, 24 */
+        }
+
+        spacc_symc_proc_int_info(i, cipher_status);
+    }
+
+    return GK_SUCCESS;
+}
+#endif
diff -uraN u-boot-2016.11/product/cipher/v2/drv/spacc/spacc_body.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/spacc/spacc_body.h
--- u-boot-2016.11/product/cipher/v2/drv/spacc/spacc_body.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/spacc/spacc_body.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,224 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef _SPACC_BODY_H_
+#define _SPACC_BODY_H_
+
+#define SPACC_LOGIC_MAX_CHN                    8
+#define CIPHER_PKG_1_CHN                       0
+#define SPACC_MAX_DEPTH                        127
+#define SPACC_MAX_HMAC_KEY_LEN                 512
+#define SPACC_PAGE_SIZE                        4096
+
+
+#define CIPHER_PKG_N_CHN_MIN                   1
+#define CIPHER_PKG_N_CHN_MAX                   7
+#define SPACC_CHN_MASK                         0xFE
+#define CIPHER_DMA_MINALIGN                    ARCH_DMA_MINALIGN
+
+typedef enum {
+    SYMC_ALG_DES = 0,
+    SYMC_ALG_3DES,
+    SYMC_ALG_AES,
+    SYMC_ALG_SM4,
+    SYMC_ALG_SM1,
+    SYMC_ALG_NULL_CIPHER,
+    SYMC_ALG_COUNT,
+} symc_alg_en;
+
+typedef enum {
+    SYMC_MODE_ECB = 0,
+    SYMC_MODE_CBC,
+    SYMC_MODE_CFB,
+    SYMC_MODE_OFB,
+    SYMC_MODE_CTR,
+    SYMC_MODE_CCM,
+    SYMC_MODE_GCM,
+    SYMC_MODE_COUNT,
+} symc_mode_en;
+
+typedef enum {
+    SYMC_DAT_WIDTH_128 = 0,
+    SYMC_DAT_WIDTH_64 = 0,
+    SYMC_DAT_WIDTH_8,
+    SYMC_DAT_WIDTH_1,
+    SYMC_DAT_WIDTH_COUNT,
+} symc_dat_width_en;
+
+typedef enum {
+    DIGEST_MODE_HASH,
+    DIGEST_MODE_HMAC,
+    DIGEST_MODE_COUNT,
+} digest_mode_en;
+
+typedef enum {
+    DIGEST_ALG_SHA1,
+    DIGEST_ALG_SHA224,
+    DIGEST_ALG_SHA256,
+    DIGEST_ALG_SHA384,
+    DIGEST_ALG_SHA512,
+    DIGEST_ALG_SM3,
+    DIGEST_ALG_COUNT,
+} digest_alg_en;
+
+typedef enum {
+    SPACC_ALLIED_SYMC = 0x00,
+    SPACC_ALLIED_DIGEST,
+    SPACC_ALLIED_SYMC_WITH_DIGEST,
+    SPACC_ALLIED_DIGEST_WITH_SYMC,
+    SPACC_ALLIED_COUNT,
+} spacc_allied_en;
+
+typedef enum {
+    SPACC_BUF_TYPE_SYMC_IN,
+    SPACC_BUF_TYPE_SYMC_OUT,
+    SPACC_BUF_TYPE_DIGEST_IN,
+    SPACC_BUF_TYPE_COUNT,
+} spacc_buf_type_en;
+
+typedef enum {
+    SPACC_CTRL_NONE             = 0x00,
+    SPACC_CTRL_SYMC_IN_GCM_A    = 0x00,
+    SPACC_CTRL_SYMC_IN_GCM_P    = 0x08,
+    SPACC_CTRL_SYMC_IN_GCM_LEN  = 0x10,
+    SPACC_CTRL_SYMC_IN_CCM_N    = 0x00,
+    SPACC_CTRL_SYMC_IN_CCM_A    = 0x08,
+    SPACC_CTRL_SYMC_IN_CCM_P    = 0x10,
+    SPACC_CTRL_SYMC_IN_CBC_OUTPUT_DISABLE = 0x04,
+    SPACC_CTRL_SYMC_IN_FIRST    = 0x01,
+    SPACC_CTRL_SYMC_IN_LAST     = 0x02,
+    SPACC_CTRL_HASH_IN_PAD      = 0x04,
+    SPACC_CTRL_HASH_IN_FIRST    = 0x01,
+    SPACC_CTRL_HASH_IN_LAST     = 0x02,
+    SPACC_CTRL_HASH_IN_AUTO_PADDING = 0x04,
+    SPACC_CTRL_HASH_IN_HMAC_END = 0x08,
+    SPACC_CTRL_SYMC_OUT_LAST    = 0x02,
+    SPACC_CTRL_SYMC_CCM_LAST    = 0x20,
+    SPACC_CTRL_SYMC_ODD_KEY     = 0x40,
+    SPACC_CTRL_SYMC_EVEN_KEY    = 0x00,
+    SPACC_CTRL_COUNT,
+} spacc_ctrl_en;
+
+typedef enum {
+    SPACC_DATA_SEAT_FIRST,
+    SPACC_DATA_SEAT_MIDDLE,
+    SPACC_DATA_SEAT_LAST,
+    SPACC_DATA_SEAT_COUNT,
+} spacc_data_seat_en;
+
+typedef struct {
+    symc_alg_en symc_alg;
+    symc_mode_en symc_mode;
+    symc_dat_width_en symc_width;
+    gk_u32 key_len;
+} spacc_symc_config_s;
+
+#define SPACC_OK                  0x000
+#define SPACC_DIGEST_DONE         0x001
+#define SPACC_DIGEST_LEN_ERR      0x002
+#define SPACC_SYMC_DONE           0x004
+#define SPACC_AEAD_DONE           0x008
+#define SPACC_SYMC_KEY_ERR        0x0100
+#define SPACC_SYMC_LEN_ERR        0x0200
+#define SPACC_SYMC_DFA_ATTACK     0x0400
+
+#define SPACC_ERR_NULL_POINT      0x400
+#define SPACC_ERR_INVALID_PARAM   0x401
+#define SPACC_ERR_BUSY            0x402
+#define SPACC_ERR_TIMEOUT         0x403
+
+#define SPACC_CHN_SECURE_ENABLE   0x80000000
+
+#define get_ulong_low(dw)                   (unsigned int)(dw)
+#define get_ulong_high(dw)                  0
+#define make_ulong(low, high)               (low)
+#define make_size(low)                      (((unsigned long)(low##High) << 32) | (low))
+
+#if (defined(CONFIG_TARGET_GK7205V200) || defined(CONFIG_TARGET_GK7205V300) || \
+     defined(CONFIG_TARGET_GK7202V300) || defined(CONFIG_TARGET_GK7605V100))
+#define HASH_RESULT_MAX_SIZE_IN_WORD        8
+#else
+#define HASH_RESULT_MAX_SIZE_IN_WORD        16
+#endif
+
+#define CACHE_LINE_VALUE                    CONFIG_SYS_CACHELINE_SIZE
+#define cipher_align_down(addr)             ((addr) & (~((CACHE_LINE_VALUE) - 1)))
+#define cipher_align_size(addr, size)       ALIGN((size) + ((addr) & (CACHE_LINE_VALUE - 1)), CIPHER_DMA_MINALIGN)
+
+int spacc_init(gk_void *reg_base, unsigned int mmu_table_addr,
+               unsigned long entry_phy_addr, gk_void *entry_via_addr);
+
+int spacc_deinit(void);
+
+unsigned int spacc_get_node_list_size(void);
+
+/**************************** SYMC API ********************************/
+int spacc_symc_getiv(unsigned int chn_num, unsigned int *iv, unsigned int ivsize);
+
+int spacc_symc_gettag(unsigned int chn_num, unsigned char *tag);
+
+int spacc_symc_setkey(unsigned int chn_num,
+                      unsigned int *even_key,
+                      unsigned int *odd_key,
+                      unsigned int klen);
+
+int spacc_symc_setiv(unsigned int chn_num,
+                     unsigned char *iv, unsigned int ivlen);
+
+int spacc_symc_addbuf(unsigned int chn_num,
+                      unsigned long buf_phy,
+                      unsigned int buf_size,
+                      spacc_buf_type_en type,
+                      unsigned int ctrl);
+
+int spacc_symc_addctrl(unsigned int chn_num, spacc_buf_type_en type, unsigned int ctrl);
+
+int spacc_symc_config(unsigned int chn_num, spacc_symc_config_s *symc_cfg,
+    unsigned char sm1_round_num, unsigned char hard_key);
+
+int spacc_symc_start(unsigned int chn_num, unsigned int decrypt, unsigned int iv_set_flag);
+void spacc_symc_restart(unsigned int chn_num, unsigned int iv_set_flag);
+
+unsigned int spacc_symc_get_free_nodes(unsigned int chn_num);
+
+unsigned int spacc_symc_is_free(unsigned int chn_num);
+
+unsigned int spacc_symc_done_notify(void);
+
+unsigned int spacc_symc_done_try(unsigned int chn_num);
+
+unsigned int spacc_symc_get_err_code(unsigned int chn_num, unsigned int *src_addr, unsigned int *dst_addr);
+
+/**************************** DIGEST API ********************************/
+int spacc_digest_config(unsigned int chn_num,
+                        digest_alg_en digest_alg,
+                        digest_mode_en digest_mode,
+                        unsigned char hard_key);
+
+void spacc_digest_get_init_val(digest_alg_en digest_alg, unsigned int state[16]); /* 16 */
+
+int spacc_digest_addbuf(unsigned int chn_num,
+                        unsigned long buf_phy,
+                        unsigned int buf_size,
+                        unsigned int ctrl);
+
+int spacc_digest_addctrl(unsigned int chn_num, unsigned int ctrl);
+
+int spacc_digest_start(unsigned int chn_num, spacc_ctrl_en enCtrl, unsigned int *state);
+
+unsigned int spacc_digest_done_notify(void);
+unsigned int spacc_digest_done_try(unsigned int chn_num);
+
+int spacc_digest_get(unsigned int chn_num, unsigned int *digest);
+
+unsigned int spacc_digest_get_err_code(unsigned int chn_num, unsigned int *src_addr);
+
+/* proc function begin */
+#ifndef DISABLE_DEBUG_INFO
+gk_s32 spacc_symc_proc_status(cipher_chn_status_s *cipher_statue);
+/* proc function end */
+#endif
+
+#endif
+
diff -uraN u-boot-2016.11/product/cipher/v2/drv/spacc/spacc_intf.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/spacc/spacc_intf.c
--- u-boot-2016.11/product/cipher/v2/drv/spacc/spacc_intf.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/spacc/spacc_intf.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,2169 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "cipher_adapt.h"
+#include "spacc_body.h"
+#include "spacc_union_define.h"
+#include "drv_klad.h"
+
+#define intf_func_fail_return(val, ret, func) \
+    do { \
+        if (val) { \
+            gk_err_cipher("%s[%d]: call %s failed\n", __FUNCTION__, __LINE__, #func); \
+            return ret; \
+        } \
+    } while (0)
+
+#define intf_param_invalid_return(val) \
+    do { \
+        if (val) { \
+            gk_err_cipher("%s[%d]: param is invalid\n", __FUNCTION__, __LINE__); \
+            return GK_ERR_CIPHER_INVALID_PARA; \
+        } \
+    } while (0)
+
+#define SPACC_MAX_CHN                   8
+#define AES_BLOCK_SIZE                  16
+#define SPACC_TIME_OUT                  100000
+#define SPACC_PAD_BUF_SIZE              128
+#define HASH_RESULT_MAX_LEN             64
+
+#define CHN_0_CIPHER_IV                 (g_cipher_reg_base + 0x0000)
+#define CHN_0_CIPHER_DOUT               (g_cipher_reg_base + 0x0080)
+#define CHN_0_CIPHER_KEY                (g_cipher_reg_base + 0x0100)
+#define CHN_0_SM1_SK                    (g_cipher_reg_base + 0x0200)
+#define ODD_EVEN_KEY_SEL                (g_cipher_reg_base + 0x0290)
+#define HDCP_MODE_CTRL                  (g_cipher_reg_base + 0x0300)
+#define SEC_CHN_CFG                     (g_cipher_reg_base + 0x0304)
+#define CALC_ST0                        (g_cipher_reg_base + 0x0318)
+#define CALC_ERR                        (g_cipher_reg_base + 0x0320)
+#define CHN_0_CCM_GCM_TAG               (g_cipher_reg_base + 0x0380)
+#define CHN_0_CIPHER_CTRL               (g_cipher_reg_base + 0x0400)
+#define CIPHER_INT_RAW                  (g_cipher_reg_base + 0x040c)
+#define CHN_0_CIPHER_DIN                (g_cipher_reg_base + 0x0420)
+
+#define SYMC_INT_LEVEL                  100 /* (SPACC_MAX_DEPTH / 2) */
+
+typedef gk_void (*func_cipher_callback)(gk_u32);
+
+typedef struct {
+    cipher_mmz_buf_t mmz_buf;
+} spacc_env_s;
+
+typedef struct {
+    gk_u8 *src_vir;
+    gk_u8 *dest_vir;
+    gk_u8 *aad_vir;
+
+    cipher_mmz_buf_t src_mmz_buf;
+    cipher_mmz_buf_t dest_mmz_buf;
+    cipher_mmz_buf_t aad_mmz_buf;
+} spacc_mmz_s;
+
+typedef struct {
+    gk_bool is_open;
+    gk_u32 hard_num;
+    gk_u32 block_size;
+
+    gk_bool symc_done;
+    CIPHER_QUEUE_HEAD queue;
+
+    gk_cipher_data *node_list;
+    gk_u32 node_num;
+    gk_u32 node_cur;
+    gk_u32 total_len;
+
+    gk_u8 *pad_vir_addr;
+    gk_size_t pad_phy_addr;
+
+    gk_u32 data_size;
+    gk_void* which_file;
+
+    cipher_config_ctrl_ex_s ctrl_ex;
+
+    func_cipher_callback callback;
+} spacc_symc_chn_s;
+
+typedef struct {
+    gk_bool is_open;
+    gk_u32 hard_num;
+    gk_u32 node_num;
+    gk_u32 node_cur;
+    gk_u32 block_size;
+
+    gk_bool digest_done;
+    CIPHER_QUEUE_HEAD queue;
+
+    func_cipher_callback callback;
+
+    gk_u32 data_size;
+    gk_void* which_file;
+} spacc_digest_chn_s;
+
+typedef struct {
+    gk_u32 src_phys_addr;
+    gk_u32 dst_phys_addr;
+    gk_u32 byte_length;
+    gk_bool is_use_odd_key;
+} cipher_data_compat_s;
+
+CIPHER_MUTEX                g_symc_mutex;
+CIPHER_MUTEX                g_digest_mutex;
+static spacc_env_s          g_spacc_env;
+static spacc_symc_chn_s     g_symc_chn[SPACC_MAX_CHN];
+static spacc_digest_chn_s   g_digest_chn[SPACC_MAX_CHN];
+static gk_void*             g_cipher_reg_base;
+
+static gk_s32 spacc_check_handle(gk_handle ci_handle)
+{
+    if ((handle_get_mod_id(ci_handle) != GK_ID_CIPHER) || \
+        (handle_get_pri_data(ci_handle) != 0)) {
+        gk_err_cipher("invalid cipher handle 0x%x\n", ci_handle);
+        cipher_mutex_unlock(&g_symc_mutex);
+        return GK_ERR_CIPHER_INVALID_HANDLE;
+    }
+    if (handle_get_chn_id(ci_handle) >= SPACC_MAX_CHN) {
+        gk_err_cipher("chan %d is too large, max: %d\n", \
+            handle_get_chn_id(ci_handle), SPACC_MAX_CHN);
+        cipher_mutex_unlock(&g_symc_mutex);
+        return GK_ERR_CIPHER_INVALID_HANDLE;
+    }
+    if (g_symc_chn[handle_get_chn_id(ci_handle)].is_open == GK_FALSE) {
+        gk_err_cipher("chan %d is not open\n", handle_get_chn_id(ci_handle));
+        cipher_mutex_unlock(&g_symc_mutex);
+        return GK_ERR_CIPHER_INVALID_HANDLE;
+    }
+    return GK_SUCCESS;
+}
+
+#ifdef INT_ENABLE
+CIPHER_IRQRETURN_T drv_cipher_isr(gk_s32 irq, gk_void *dev_id)
+{
+    gk_u32 chn_mask, i;
+
+    chn_mask = spacc_symc_done_notify();
+    gk_info_cipher("SPACC ISR IRQ: %d, chn_mask 0x%x\n", irq, chn_mask);
+
+    for (i = CIPHER_PKG_N_CHN_MIN; i <= CIPHER_PKG_N_CHN_MAX; i++) {
+        if ((chn_mask >> i) & 0x01) {
+            if (g_symc_chn[i].callback) {
+                g_symc_chn[i].callback(i);
+            } else {
+                g_symc_chn[i].symc_done = GK_TRUE;
+                gk_info_cipher("chn %d wake up\n", i);
+                cipher_queue_wait_up(&g_symc_chn[i].queue);
+            }
+        }
+    }
+
+    chn_mask = spacc_digest_done_notify();
+    for (i = CIPHER_PKG_N_CHN_MIN; i <= CIPHER_PKG_N_CHN_MAX; i++) {
+        if ((chn_mask >> i) & 0x01) {
+            if (g_digest_chn[i].callback) {
+                g_digest_chn[i].callback(i);
+            } else {
+                g_digest_chn[i].digest_done = GK_TRUE;
+                cipher_queue_wait_up(&g_digest_chn[i].queue);
+            }
+        }
+    }
+
+    return CIPHER_IRQ_HANDLED;
+}
+#endif
+
+static gk_s32 drv_cipher_reset(gk_void)
+{
+    gk_u32 *pvirt = GK_NULL;
+    gk_u32 spacc_stat = 0;
+
+    pvirt = cipher_ioremap_nocache(CIPHER_SPACC_CRG_ADDR_PHY, 16); /* 16 */
+    if (pvirt == GK_NULL) {
+        gk_err_cipher("ioremap_nocache phy addr err:%x.\n", CIPHER_SPACC_CRG_ADDR_PHY);
+        return GK_FAILURE;
+    }
+
+    /* open clock, reset */
+    hal_cipher_read_reg(CIPHER_SPACC_CRG_ADDR_PHY, &spacc_stat);
+    spacc_stat |= SPACC_CRG_CLOCK_BIT;
+    spacc_stat |= SPACC_CRG_RESET_BIT;
+    hal_cipher_write_reg(CIPHER_SPACC_CRG_ADDR_PHY, spacc_stat);
+    cipher_msleep(5); /* 5ms */
+
+    /* cancel reset */
+    spacc_stat &= ~SPACC_CRG_RESET_BIT;
+    hal_cipher_write_reg(CIPHER_SPACC_CRG_ADDR_PHY, spacc_stat);
+
+    cipher_iounmap(pvirt);
+    pvirt = GK_NULL;
+
+    return GK_SUCCESS;
+}
+
+gk_s32 drv_cipher_init(gk_void)
+{
+    gk_s32 ret;
+    gk_size_t size_addr = 0;
+    gk_u32 i;
+    u_sec_chn_cfg sec_cfg;
+
+    cipher_mutex_init(&g_symc_mutex);
+
+    g_cipher_reg_base = cipher_ioremap_nocache(CIPHER_CIPHER_REG_BASE_ADDR_PHY, 0x2000);
+    intf_func_fail_return(g_cipher_reg_base == GK_NULL, GK_FAILURE, cipher_ioremap_nocache);
+
+    ret = drv_cipher_reset();
+    intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_reset);
+
+    crypto_memset(&g_spacc_env, sizeof(g_spacc_env), 0, sizeof(spacc_env_s));
+    crypto_memset(&g_symc_chn, sizeof(g_symc_chn), 0, sizeof(g_symc_chn));
+    crypto_memset(&g_digest_chn, sizeof(g_digest_chn), 0, sizeof(g_digest_chn));
+
+    g_spacc_env.mmz_buf.mmz_size = spacc_get_node_list_size() + SPACC_PAGE_SIZE;
+    ret = cipher_mmz_alloc_remap("CIPHER_ChnBuf", &g_spacc_env.mmz_buf);
+    intf_func_fail_return(ret != GK_SUCCESS, ret, cipher_mmz_alloc_remap);
+
+    for (i = CIPHER_PKG_N_CHN_MIN; i <= CIPHER_PKG_N_CHN_MAX; i++) {
+        cipher_queue_init(&g_symc_chn[i].queue);
+        cipher_queue_init(&g_digest_chn[i].queue);
+        g_symc_chn[i].pad_phy_addr = g_spacc_env.mmz_buf.start_phy_addr + SPACC_PAD_BUF_SIZE * i;
+        g_symc_chn[i].pad_vir_addr = g_spacc_env.mmz_buf.start_vir_addr + SPACC_PAD_BUF_SIZE * i;
+        g_symc_chn[i].hard_num = i;
+        g_digest_chn[i].hard_num = i;
+    }
+
+    ret = spacc_init(g_cipher_reg_base, size_addr,
+                     g_spacc_env.mmz_buf.start_phy_addr + SPACC_PAGE_SIZE,
+                     g_spacc_env.mmz_buf.start_vir_addr + SPACC_PAGE_SIZE);
+    if (ret != GK_SUCCESS)
+        goto unmap_mmz;
+
+    hal_cipher_read_reg(SEC_CHN_CFG, &sec_cfg.u32);
+    sec_cfg.bits.cipher_sec_chn_cfg |= 0x01;
+    sec_cfg.bits.hash_sec_chn_cfg |= 0x01;
+    hal_cipher_write_reg(SEC_CHN_CFG, sec_cfg.u32);
+
+#ifdef INT_ENABLE
+    ret = cipher_request_irq(CIPHER_IRQ_NUMBER, drv_cipher_isr, "cipher");
+    if (ret != GK_SUCCESS) {
+        gk_err_cipher("Irq request failure, ret=%d, irq = %d", ret, CIPHER_IRQ_NUMBER);
+        goto unmap_mmz;
+    }
+#endif
+    return ret;
+
+unmap_mmz:
+    cipher_mmz_release_unmap(&g_spacc_env.mmz_buf);
+    return ret;
+}
+
+gk_void drv_cipher_deinit(gk_void)
+{
+    if (spacc_deinit() != GK_SUCCESS)
+        gk_err_cipher("spacc deinit failed.\n");
+
+#ifdef INT_ENABLE
+    cipher_free_irq(CIPHER_IRQ_NUMBER, "cipher");
+#endif
+
+    cipher_mmz_release_unmap(&g_spacc_env.mmz_buf);
+
+    cipher_iounmap(g_cipher_reg_base);
+
+    return;
+}
+
+gk_s32 gk_drv_cipher_create_handle(cipher_handle_s *ci_handle, gk_void* file)
+{
+    gk_u32 i;
+    gk_s32 ret = GK_SUCCESS;
+
+    if (ci_handle == GK_NULL) {
+        gk_err_cipher("Invalid params!\n");
+        return GK_FAILURE;
+    }
+
+    if (ci_handle->cipher_atts.cipher_type > GK_CIPHER_TYPE_COPY_AVOID) {
+        gk_err_cipher("Invalid cipher type!\n");
+        return GK_FAILURE;
+    }
+
+    if (cipher_mutex_lock(&g_symc_mutex)) {
+        gk_err_cipher("cipher_mutex_lock failed!\n");
+        return GK_FAILURE;
+    }
+
+    if (ci_handle->cipher_atts.cipher_type == GK_CIPHER_TYPE_COPY_AVOID) {
+        if (g_symc_chn[0].is_open == GK_FALSE)
+            i = 0;
+        else
+            i = SPACC_MAX_CHN;
+    } else {
+        for (i = CIPHER_PKG_N_CHN_MIN; i <= CIPHER_PKG_N_CHN_MAX; i++) {
+            if (g_symc_chn[i].is_open == GK_FALSE)
+                break;
+        }
+    }
+
+    if (i <= CIPHER_PKG_N_CHN_MAX) {
+        g_symc_chn[i].is_open = GK_TRUE;
+        g_symc_chn[i].which_file = file;
+        g_symc_chn[i].callback = GK_NULL;
+        g_symc_chn[i].node_list = GK_NULL;
+        g_symc_chn[i].node_num = 0;
+        ci_handle->ci_handle = gk_handle_make_handle(GK_ID_CIPHER, 0, i);
+    } else {
+        gk_err_cipher("No more cipher chan left.\n");
+        ret = GK_FAILURE;
+    }
+
+    cipher_mutex_unlock(&g_symc_mutex);
+
+    return ret;
+}
+
+static gk_s32 drv_cipher_param_check(symc_alg_en symc_alg,
+                                     symc_mode_en symc_mode,
+                                     symc_dat_width_en symc_width,
+                                     gk_cipher_sm1_round sm1_round)
+{
+   /* the mode depend on alg, which limit to hardware
+    * des/3des support ecb/cbc/cfb/ofb
+    * aes support ecb/cbc/cfb/ofb/ctr/ccm/gcm
+    * sm1 support ecb/cbc/cfb/ofb
+    * sm4 support ecb/cbc/ctr
+    */
+    if ((symc_alg == SYMC_ALG_DES) || (symc_alg == SYMC_ALG_3DES) || (symc_alg == SYMC_ALG_SM1)) {
+        if ((symc_mode != SYMC_MODE_ECB) && (symc_mode != SYMC_MODE_CBC) &&
+            (symc_mode != SYMC_MODE_CFB) && (symc_mode != SYMC_MODE_OFB)) {
+            gk_err_cipher("Invalid alg %d and mode: %d\n", symc_alg, symc_mode);
+            return GK_ERR_CIPHER_INVALID_PARA;
+         }
+    } else if (symc_alg == SYMC_ALG_SM4) {
+        if ((symc_mode != SYMC_MODE_ECB) && (symc_mode != SYMC_MODE_CBC) && (symc_mode != SYMC_MODE_CTR)) {
+            gk_err_cipher("Invalid alg %d and mode %d\n", symc_alg, symc_mode);
+            return GK_ERR_CIPHER_INVALID_PARA;
+         }
+    }
+
+   /* the bit width depend on alg and mode, which limit to hardware
+    * des/3des with cfb/ofb support bit1, bit8, bit 64.
+    * aes with cfb/ofb only support bit128.
+    * sm1 with ofb only support bit128, cfb support bit1, bit8, bit 64.
+    */
+    if ((symc_alg == SYMC_ALG_DES) || (symc_alg == SYMC_ALG_3DES)) {
+        if ((symc_mode == SYMC_MODE_CFB) || (symc_mode == SYMC_MODE_OFB)) {
+            if (symc_width != SYMC_DAT_WIDTH_64 &&
+                symc_width != SYMC_DAT_WIDTH_8 && symc_width != SYMC_DAT_WIDTH_1) {
+                gk_err_cipher("Invalid mode %d and bit width %d\n", symc_mode, symc_width);
+                return GK_ERR_CIPHER_INVALID_PARA;
+            }
+        }
+    }
+
+    if (symc_alg == SYMC_ALG_AES) {
+        if (((symc_mode == SYMC_MODE_CFB) && (symc_width >= SYMC_DAT_WIDTH_COUNT)) ||
+            ((symc_mode == SYMC_MODE_OFB) && (symc_width != SYMC_DAT_WIDTH_128))) {
+            gk_err_cipher("Invalid alg %d mode %d and width %d\n", symc_alg, symc_mode, symc_width);
+            return GK_ERR_CIPHER_INVALID_PARA;
+        }
+    }
+
+    if (symc_alg == SYMC_ALG_SM1) {
+        if (((symc_mode == SYMC_MODE_OFB) && (symc_width != SYMC_DAT_WIDTH_128)) ||
+            ((symc_mode == SYMC_MODE_CFB) && (symc_width >= SYMC_DAT_WIDTH_COUNT))) {
+            gk_err_cipher("Invalid alg %d mode %d and width %d\n", symc_alg, symc_mode, symc_width);
+            return GK_ERR_CIPHER_INVALID_PARA;
+        }
+
+        if (sm1_round >= GK_CIPHER_SM1_ROUND_BUTT) {
+            gk_err_cipher("Invalid alg %d and Sm1Round %d\n", symc_alg, sm1_round);
+            return GK_ERR_CIPHER_INVALID_PARA;
+        }
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 drv_cipher_match_alg(cipher_config_ctrl_ex_s *config, symc_alg_en *symc_alg, gk_u32 *block_size)
+{
+    /* set alg and block size */
+    switch (config->ci_alg) {
+        case GK_CIPHER_ALG_AES:
+            *symc_alg = SYMC_ALG_AES;
+            *block_size = 16; /* 16 block size */
+            break;
+        case GK_CIPHER_ALG_DMA:
+            *symc_alg = SYMC_ALG_NULL_CIPHER;
+            *block_size = 16; /* 16 block size */
+            break;
+        case GK_CIPHER_ALG_SM1:
+            *symc_alg = SYMC_ALG_SM1;
+            *block_size = 16; /* 16 block size */
+            break;
+        case GK_CIPHER_ALG_SM4:
+            *symc_alg = SYMC_ALG_SM4;
+            *block_size = 16; /* 16 block size */
+            break;
+        default:
+            gk_err_cipher("Invalid alg: 0x%x\n", config->ci_alg);
+            return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 drv_cipher_match_work_mode(cipher_config_ctrl_ex_s *config, symc_mode_en *symc_mode)
+{
+    switch (config->work_mode) {
+        case GK_CIPHER_WORK_MODE_ECB:
+            *symc_mode = SYMC_MODE_ECB;
+            break;
+        case GK_CIPHER_WORK_MODE_CBC:
+            *symc_mode = SYMC_MODE_CBC;
+            break;
+        case GK_CIPHER_WORK_MODE_CFB:
+            *symc_mode = SYMC_MODE_CFB;
+            break;
+        case GK_CIPHER_WORK_MODE_OFB:
+            *symc_mode = SYMC_MODE_OFB;
+            break;
+        case GK_CIPHER_WORK_MODE_CTR:
+            *symc_mode = SYMC_MODE_CTR;
+            break;
+        case GK_CIPHER_WORK_MODE_CCM:
+            *symc_mode = SYMC_MODE_CCM;
+            break;
+        case GK_CIPHER_WORK_MODE_GCM:
+            *symc_mode = SYMC_MODE_GCM;
+            break;
+        default:
+            gk_err_cipher("Invalid mode: 0x%x\n", config->work_mode);
+            return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 drv_cipher_match_bit_width(cipher_config_ctrl_ex_s *config, symc_dat_width_en *symc_width)
+{
+    /* set the bit width which depend on alg and mode */
+    if ((config->work_mode == GK_CIPHER_WORK_MODE_CFB) ||
+        (config->work_mode == GK_CIPHER_WORK_MODE_OFB)) {
+        switch (config->bit_width) {
+            case GK_CIPHER_BIT_WIDTH_64BIT:
+                *symc_width = SYMC_DAT_WIDTH_64;
+                break;
+            case GK_CIPHER_BIT_WIDTH_8BIT:
+                *symc_width = SYMC_DAT_WIDTH_8;
+                break;
+            case GK_CIPHER_BIT_WIDTH_1BIT:
+                *symc_width = SYMC_DAT_WIDTH_1;
+                break;
+            case GK_CIPHER_BIT_WIDTH_128BIT:
+                *symc_width = SYMC_DAT_WIDTH_128;
+                break;
+            default:
+                gk_err_cipher("Invalid width: 0x%x, mode 0x%x, alg 0x%x\n",
+                    config->bit_width, config->work_mode, config->ci_alg);
+                return GK_ERR_CIPHER_INVALID_PARA;
+        }
+    } else {
+        *symc_width = SYMC_DAT_WIDTH_128;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 drv_cipher_match_key_len(cipher_config_ctrl_ex_s *config, gk_u32 *key_len)
+{
+    if (config->ci_alg == GK_CIPHER_ALG_AES) {
+        switch (config->key_len) {
+            case GK_CIPHER_KEY_AES_128BIT:
+                *key_len = 16; /* 16 key len */
+                break;
+            case GK_CIPHER_KEY_AES_192BIT:
+                *key_len = 24; /* 24 key len */
+                break;
+            case GK_CIPHER_KEY_AES_256BIT:
+                *key_len = 32; /* 32 key len */
+                break;
+            default:
+                gk_err_cipher("Invalid key len: 0x%x\n", config->key_len);
+                return GK_ERR_CIPHER_INVALID_PARA;
+        }
+    } else if (config->ci_alg == GK_CIPHER_ALG_SM1) {
+        *key_len = 48; /* 48 key len */
+    } else if (config->ci_alg == GK_CIPHER_ALG_SM4) {
+        *key_len = 16; /* 16 key len */
+    } else {
+        gk_err_cipher("Invalid cipher alg: %d\n", config->ci_alg);
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+    return GK_SUCCESS;
+}
+
+/* change the unf params to drive params */
+static gk_s32 drv_cipher_param(cipher_config_ctrl_ex_s *config,
+    spacc_symc_config_s *symc_cfg, gk_u32 *block_size)
+{
+    gk_s32 ret;
+
+    /* set alg and block size */
+    ret = drv_cipher_match_alg(config, &symc_cfg->symc_alg, block_size);
+    intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_match_alg);
+
+    /* set the mode which depend on alg */
+    ret = drv_cipher_match_work_mode(config, &symc_cfg->symc_mode);
+    intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_match_work_mode);
+
+    /* set the bit width which depend on alg and mode */
+    ret = drv_cipher_match_bit_width(config, &symc_cfg->symc_width);
+    intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_match_bit_width);
+
+   /* set the key length depend on alg
+    * des/3des support 2key and 3key
+    * aes support 128, 192, and 256
+    * sm1 support ak/ek/sk
+    * sm4 support 128
+    */
+    ret = drv_cipher_match_key_len(config, &symc_cfg->key_len);
+    intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_match_key_len);
+
+    if (config->change_flags.bits_iv > GK_CIPHER_IV_CHG_ALL_PKG) {
+        gk_err_cipher("Invalid IV Change Flags: 0x%x\n", config->change_flags.bits_iv);
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    if ((config->change_flags.bits_iv == GK_CIPHER_IV_CHG_ALL_PKG) &&
+        ((config->work_mode == GK_CIPHER_WORK_MODE_CCM) ||
+        (config->work_mode == GK_CIPHER_WORK_MODE_GCM))) {
+        gk_err_cipher("Invalid IV Change Flags: 0x%x\n", config->change_flags.bits_iv);
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    if (config->key_by_ca && (config->ca_type >= GK_CIPHER_KEY_SRC_BUTT)) {
+        gk_err_cipher("Invalid CA Type: 0x%x\n", config->ca_type);
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    return drv_cipher_param_check(symc_cfg->symc_alg,
+        symc_cfg->symc_mode, symc_cfg->symc_width, config->sm1_round);
+}
+
+static gk_s32 drv_cipher_config_ccm(cipher_config_ctrl_ex_s *config,
+    gk_u32 *iv, gk_u32 ilen, gk_u32 *real_ilen)
+{
+    gk_u8 *buf = GK_NULL;
+
+    /* The octet lengths of N are denoted  n,
+     * The octet length of the binary represen tation of the
+     * octet length of the payload denoted q,
+     * n is an element of {7, 8, 9, 10, 11, 12, 13},
+     * equation: n + q = 15
+     * here the string of N  is config->iv, and n is config->iv_len.
+     */
+    if ((config->iv_len < 7) || (config->iv_len > 13)) { /* 7, 13 iv len range */
+        gk_err_cipher("Invalid IV LEN: 0x%x\n", config->iv_len);
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    /* the parameter t denotes the octet length of T(tag)
+     * t is an element of  { 4, 6, 8, 10, 12, 14, 16}
+     * here t is config->tag_len
+     */
+    if ((config->tag_len & 0x01) || (config->tag_len < 4) || (config->tag_len > 16)) { /* 4, 16 tag len value */
+        gk_err_cipher("Invalid TAG LEN: 0x%x\n", config->tag_len);
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+    /* Formatting of the Counter Blocks(IV for CTR)
+     *
+     * According to the CCM spec, the counter is equivalent to
+     * a formatting of the counter index i into a complete data block.
+     * The counter blocks Ctri are formatted as shown below:
+     * | Octet number:  0    1 ... 15-q    16-q ... 15
+     * | Contents:     Flags     N             [i]
+     * Within each block Ctri, the N is get from config->iv, n + q = 15,
+     * so the q equal to 15 - config->iv_len.
+     * the [i] is the block conut start with 0,
+     * In the Flags field, Bits 0, 1, and 2 contain the encoding of q - 1,
+     * others bits shall be set to 0.
+     * so the first byte of IV shall be q -1, that is 15 - config->iv_len - 1
+     */
+    buf = (gk_u8 *)iv;
+    crypto_memset(buf, ilen, 0, ilen);
+    buf[0] = 14 - config->iv_len; /* equation: IV[0] = q - 1 = 15 - n - 1, 14 */
+    crypto_memcpy(buf + 1, 16 - 1, config->iv, config->iv_len); /* 16 buf size */
+    *real_ilen = config->iv_len + 1;
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 drv_cipher_config_gcm(cipher_config_ctrl_ex_s *config,
+    gk_u32 *iv, gk_u32 ilen, gk_u32 *real_ilen)
+{
+    /* According to the GCM spec, the IVLen >= 1, typical equal to 12,
+     * but limit to hard logic devising, the IVLen can't large than 16.
+     */
+    if (config->iv_len > ilen) {
+        gk_err_cipher("Invalid IV LEN: 0x%x\n", config->iv_len);
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+    crypto_memcpy(iv, ilen, config->iv, config->iv_len);
+    *real_ilen = config->iv_len;
+    return GK_SUCCESS;
+}
+
+static gk_s32 drv_cipher_config_chn_0(spacc_symc_chn_s *channel,
+    cipher_config_ctrl_ex_s *config, spacc_symc_config_s *symc_cfg, gk_u32 *iv, gk_u32 iv_len)
+{
+    u_chan0_cipher_ctrl chn0_ctrl;
+    gk_u32 klen = 0;
+    gk_u32 i;
+    gk_s32 ret = GK_SUCCESS;
+
+    hal_cipher_write_reg(ODD_EVEN_KEY_SEL, 0x00);
+    if (config->key_by_ca == GK_FALSE) {
+        for (i = 0; i < 8; i++) /* 8 */
+            hal_cipher_write_reg(CHN_0_CIPHER_KEY + i * 4, config->key[i]); /* 4 */
+    } else {
+        ret = drv_cipher_klad_load_key(0, channel->ctrl_ex.ca_type,
+            GK_CIPHER_KLAD_TARGET_AES, (gk_u8 *)config->key, 16); /* 16 */
+        intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_klad_load_key);
+    }
+
+    if (symc_cfg->symc_alg == SYMC_ALG_SM1) {
+        for (i = 0; i < 4; i++) /* 4 */
+            hal_cipher_write_reg(CHN_0_SM1_SK + i * 4, config->key[i + 8]); /* 4, 8 */
+    }
+    for (i = 0; i < 4; i++) /* 4 */
+        hal_cipher_write_reg(CHN_0_CIPHER_IV + i * 4, iv[i]); /* 4 */
+
+    if (symc_cfg->symc_alg == SYMC_ALG_AES)
+        klen = symc_cfg->key_len / 8 - 2; /* 8, 2 */
+    else if (symc_cfg->symc_alg == SYMC_ALG_3DES)
+        klen = (symc_cfg->key_len == 16 ? 3 : 2); /* 16, 3, 2 */
+
+    chn0_ctrl.u32 = 0x00;
+    chn0_ctrl.bits.sym_ch0_sm1_round_num = config->sm1_round;
+    chn0_ctrl.bits.sym_ch0_ivin_sel = 0x01;
+    chn0_ctrl.bits.sym_ch0_key_sel = config->key_by_ca;
+    chn0_ctrl.bits.sym_ch0_key_length = klen;
+    chn0_ctrl.bits.sym_ch0_dat_width = symc_cfg->symc_width;
+    chn0_ctrl.bits.sym_ch0_alg_sel = symc_cfg->symc_alg;
+    chn0_ctrl.bits.sym_ch0_alg_mode = symc_cfg->symc_mode;
+    if (config->work_mode == GK_CIPHER_WORK_MODE_GCM)
+        chn0_ctrl.bits.sym_ch0_gcm_iv_len = config->iv_len - 1;
+    hal_cipher_write_reg(CHN_0_CIPHER_CTRL, chn0_ctrl.u32);
+
+    return ret;
+}
+
+static gk_s32 drv_cipher_config_chn_n(spacc_symc_chn_s *channel, cipher_config_ctrl_ex_s *config,
+    spacc_symc_config_s *symc_cfg, gk_u32 *iv, gk_u32 iv_len)
+{
+    gk_s32 ret;
+
+    ret = spacc_symc_config(channel->hard_num, symc_cfg, config->sm1_round, config->key_by_ca);
+    intf_func_fail_return(ret != SPACC_OK, GK_FAILURE, spacc_symc_config);
+
+    if (config->key_by_ca == GK_FALSE) { /* GK_CIPHER_KEY_SRC_USER, CPU config key */
+        ret = spacc_symc_setkey(channel->hard_num, config->key, config->odd_key, symc_cfg->key_len);
+        intf_func_fail_return(ret != SPACC_OK, GK_FAILURE, spacc_symc_setkey);
+#ifdef CIPHER_KLAD_SUPPORT
+    } else { /* GK_CIPHER_KEY_SRC_KLAD, KLAD load key */
+        ret = drv_cipher_klad_load_key(channel->hard_num, channel->ctrl_ex.ca_type,
+            GK_CIPHER_KLAD_TARGET_AES, (gk_u8 *)config->key, 16); /* 16 key len */
+        intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_klad_load_key);
+#endif
+    }
+
+    ret = spacc_symc_setiv(channel->hard_num, (gk_u8*)iv, iv_len);
+    intf_func_fail_return(ret != SPACC_OK, GK_FAILURE, spacc_symc_setiv);
+    return ret;
+}
+
+static gk_s32 drv_cipher_config_chn(gk_u32 soft_chn_id, cipher_config_ctrl_ex_s *config)
+{
+    gk_s32 ret;
+    gk_u32 iv[4]; /* 4 iv arr size */
+    gk_u32 real_ilen = 0;
+    gk_cipher_ctrl_chg_flag change_flags;
+    spacc_symc_config_s symc_cfg;
+    spacc_symc_chn_s *channel = &g_symc_chn[soft_chn_id];
+
+    crypto_memset(iv, sizeof(iv), 0, sizeof(iv));
+    crypto_memset(&symc_cfg, sizeof(symc_cfg), 0, sizeof(symc_cfg));
+    crypto_memset(&change_flags, sizeof(change_flags), 0, sizeof(change_flags));
+
+    change_flags.bits_iv = channel->ctrl_ex.change_flags.bits_iv;
+
+    crypto_memcpy(&channel->ctrl_ex, sizeof(channel->ctrl_ex), config, sizeof(cipher_config_ctrl_ex_s));
+    if (channel->ctrl_ex.key_by_ca == GK_TRUE)
+        channel->ctrl_ex.change_flags.bits_iv = change_flags.bits_iv;
+
+    ret = drv_cipher_param(config, &symc_cfg, &channel->block_size);
+    intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_param);
+
+    if (config->work_mode == GK_CIPHER_WORK_MODE_CCM) {
+        ret = drv_cipher_config_ccm(config, iv, sizeof(iv), &real_ilen);
+        intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_config_ccm);
+    } else if (config->work_mode == GK_CIPHER_WORK_MODE_GCM) {
+        ret = drv_cipher_config_gcm(config, iv, sizeof(iv), &real_ilen);
+        intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_config_gcm);
+    } else if (config->work_mode <= GK_CIPHER_WORK_MODE_CTR) {
+        /* IV length, 16 for aes, 8 for des/3des */
+        crypto_memcpy(iv, sizeof(iv), config->iv, sizeof(config->iv));
+        real_ilen = sizeof(config->iv);
+    } else {
+        gk_err_cipher("Invalid mode: 0x%x\n", config->work_mode);
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    /* chn 1~7, data transferred by DMA */
+    if (soft_chn_id != 0) {
+        ret = drv_cipher_config_chn_n(channel, config, &symc_cfg, iv, real_ilen);
+        intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_config_chn_n);
+    } else {     /* chn 0, data transferred by CPU, spacc_body do not drvie chn0 */
+        ret = drv_cipher_config_chn_0(channel, config, &symc_cfg, iv, sizeof(iv));
+        intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_config_chn_0);
+    }
+
+    return GK_SUCCESS;
+}
+
+gk_s32 gk_drv_cipher_config_chn_ex(gk_handle ci_handle, cipher_config_ctrl_ex_s *config)
+{
+    gk_s32 ret;
+    gk_u32 soft_chn_id;
+
+    if (config == GK_NULL) {
+        gk_err_cipher("Invalid params!\n");
+        return GK_FAILURE;
+    }
+
+    if (cipher_mutex_lock(&g_symc_mutex)) {
+        gk_err_cipher("cipher_mutex_lock failed!\n");
+        return GK_FAILURE;
+    }
+
+    ret = spacc_check_handle(ci_handle);
+    if (ret != GK_SUCCESS)
+        return ret;
+
+    soft_chn_id = handle_get_chn_id(ci_handle);
+    ret = drv_cipher_config_chn(soft_chn_id, config);
+
+    cipher_mutex_unlock(&g_symc_mutex);
+
+    return ret;
+}
+
+gk_s32 gk_drv_cipher_destory_handle(gk_handle cipher_chn)
+{
+    gk_u32 soft_chn_id;
+    gk_s32 ret;
+
+    if (cipher_mutex_lock(&g_symc_mutex)) {
+        gk_err_cipher("cipher_mutex_lock failed!\n");
+        return GK_FAILURE;
+    }
+
+    ret = spacc_check_handle(cipher_chn);
+    if (ret != GK_SUCCESS)
+        return ret;
+    soft_chn_id = handle_get_chn_id(cipher_chn);
+
+    g_symc_chn[soft_chn_id].is_open = GK_FALSE;
+
+    cipher_mutex_unlock(&g_symc_mutex);
+
+    return ret;
+}
+
+/* check error code
+ * bit0: klad_key_use_err
+ * bit1: alg_len_err
+ * bit2: smmu_page_unvlid
+ */
+static gk_s32 drv_cipher_check_error_code(gk_u32 hard_num, gk_u32 wait, gk_u32 src_addr)
+{
+    gk_s32 ret = GK_SUCCESS;
+
+    if (wait & 0x01) {
+        gk_err_cipher("hash error: klad_key_use_err, chn %d !!!\n", hard_num);
+        ret = GK_FAILURE;
+    }
+    if (wait & 0x02) {
+        gk_err_cipher("hash error: alg_len_err, chn %d !!!\n", hard_num);
+        ret = GK_FAILURE;
+    }
+    if (wait & 0x04) {
+        gk_err_cipher("hash error: smmu_page_unvlid, chn %d !!!\n", hard_num);
+        gk_err_cipher("SRC ADDR: 0x%x\n", src_addr);
+        ret = GK_FAILURE;
+    }
+    return ret;
+}
+
+static gk_s32 drv_cipher_symc_wait_done(spacc_symc_chn_s *channel, gk_u32 time_out)
+{
+    gk_s32 ret = GK_SUCCESS;
+    gk_u32 wait;
+    gk_u32 src_addr, dst_addr;
+
+#ifdef INT_ENABLE
+    if (cipher_queue_wait_timeout(&channel->queue,  &channel->symc_done, time_out) != GK_SUCCESS) {
+        gk_err_cipher("Encrypt time out! Chn %d, CIPHER_IRQ_NUMBER: %d\n", channel->hard_num, CIPHER_IRQ_NUMBER);
+        ret = GK_FAILURE;
+    }
+#else
+    time_out = 0;
+    while (time_out++ < SPACC_TIME_OUT) {
+        if (spacc_symc_done_try(channel->hard_num))
+            break;
+        cipher_msleep(1);
+    }
+    if (time_out >= SPACC_TIME_OUT) {
+        gk_err_cipher("symc time out!\n");
+        ret = GK_FAILURE;
+    }
+#endif
+
+    wait = spacc_symc_get_err_code(channel->hard_num, &src_addr, &dst_addr);
+    if (drv_cipher_check_error_code(channel->hard_num, wait, src_addr) != GK_SUCCESS)
+        ret = GK_FAILURE;
+
+    return ret;
+}
+
+static gk_s32 drv_cipher_digest_wait_done(spacc_digest_chn_s *channel)
+{
+    gk_s32 ret = GK_SUCCESS;
+    gk_u32 wait;
+    gk_u32 time_out = SPACC_TIME_OUT;
+    gk_u32 src_addr;
+
+#ifdef INT_ENABLE
+    if (channel->data_size > 100 * 1024) { /* 100, 1024 */
+        ret = cipher_queue_wait_timeout(&channel->queue, &channel->digest_done, time_out);
+        if (ret <= 0) {
+            gk_err_cipher("hash time out! CIPHER_IRQ_NUMBER: %d\n", CIPHER_IRQ_NUMBER);
+            ret = GK_FAILURE;
+        }
+    } else {
+        time_out = 0;
+        while (time_out++ < SPACC_TIME_OUT) {
+            if (channel->digest_done != GK_FALSE)
+                break;
+            cipher_msleep(1);
+        }
+        if (time_out >= SPACC_TIME_OUT) {
+            gk_err_cipher("hash time out!\n");
+            ret = GK_FAILURE;
+        }
+    }
+#else
+    time_out = 0;
+    while (time_out++ < SPACC_TIME_OUT) {
+        if (spacc_digest_done_try(channel->hard_num))
+            break;
+        cipher_msleep(1);
+    }
+    if (time_out >= SPACC_TIME_OUT) {
+        gk_err_cipher("hash time out!\n");
+        ret = GK_FAILURE;
+    }
+#endif
+
+   /* check error code
+    * bit0: klad_key_use_err
+    * bit1: alg_len_err
+    * bit2: smmu_page_unvlid
+    */
+    wait = spacc_digest_get_err_code(channel->hard_num, &src_addr);
+    if (drv_cipher_check_error_code(channel->hard_num, wait, src_addr) != GK_SUCCESS)
+        ret = GK_FAILURE;
+
+    return ret;
+}
+
+static gk_s32 drv_cipher_ccm_head_format(spacc_symc_chn_s *channel,
+    gk_u32 enc_len, gk_u8 *arr_b, gk_u32 blen, gk_u32 *b1_len)
+{
+    gk_u8 *pbuf = GK_NULL;
+    gk_u32 index;
+
+    /* Format B0 */
+    /* The leading octet of the first block of the formatting, B0,
+     * contains four flags for control information: two single bits,
+     * called  Reserved  and  Adata, and two strings of three bits,
+     * to encode the values t and q.  The encoding of t is [(t -2)/2],
+     * and the encoding of q is [ q-1].
+     * The ordering of the flags with in the octet is given:
+     *  _____________________________________________________
+     * |Bit number  7     |   6   | 5  4  3     |  2  1  0   |
+     * |Contents  Reserved  Adata   [( t -2)/2] |  [q-1]     |
+     *  -----------------------------------------------------
+     * The remaining 15 octets of the first block of  the formatting are
+     * devoted to the nonce and the binary representation of
+     * the message length in  q octets, as given:
+     *  _____________________________________________
+     * |Octet number  0   | 1 ... 15-q | 16-q ... 15 |
+     * |Contents    Flags |      N     |      Q      |
+     *  ---------------------------------------------
+    */
+    pbuf = arr_b;
+    index = 0;
+    crypto_memset(pbuf, AES_BLOCK_SIZE, 0, AES_BLOCK_SIZE);
+    pbuf[index]  = (channel->ctrl_ex.alen > 0 ? 1 : 0) << 6; /* Adata, 6 left shift */
+    pbuf[index] |= ((channel->ctrl_ex.tag_len - 2) / 2) << 3; /* formula: (t - 2) / 2, 3 left shift */
+    pbuf[index] |= ((15 - channel->ctrl_ex.iv_len) - 1); /* formula: q - 1, n + q = 15 */
+    index++;
+    crypto_memcpy(&pbuf[index], AES_BLOCK_SIZE - index, channel->ctrl_ex.iv, channel->ctrl_ex.iv_len);
+    index += channel->ctrl_ex.iv_len;
+    if (index <= 12) { /* 12 index */
+        index = 12; /* 12 index */
+        pbuf[index++] = (gk_u8)(enc_len >> 24); /* 24 right shift */
+        pbuf[index++] = (gk_u8)(enc_len >> 16); /* 16 right shift */
+        pbuf[index++] = (gk_u8)(enc_len >> 8);  /* 8  right shift */
+        pbuf[index++] = (gk_u8)(enc_len);
+    } else if ((index == 13) && (enc_len <= 0xFFFFFF)) { /* 13 index */
+        pbuf[index++] = (gk_u8)(enc_len >> 16); /* 16 right shift */
+        pbuf[index++] = (gk_u8)(enc_len >> 8);  /* 8  right shift */
+        pbuf[index++] = (gk_u8)(enc_len);
+    } else if ((index == 14) && (enc_len <= 0xFFFF)) { /* 14 index */
+        pbuf[index++] = (gk_u8)(enc_len >> 8); /* 8  right shift */
+        pbuf[index++] = (gk_u8)(enc_len);
+    } else {
+        gk_err_cipher("Invalid Mlen: 0x%x, q: 0x%x!\n", enc_len, 16 - index); /* 16 */
+        return GK_FAILURE;
+    }
+
+   /* Formatting of the Associated Data in B1, the length of A denotes as a */
+   /* The value a is encoded according to the following three cases:
+    * If 0 < a < 2^16 - 2^8, then a  is encoded as a[0..15], i.e., two octets.
+    * If 2^16 - 2^8 <= a < 2^32, then a  is encoded as 0xff || 0xfe || a[0..31], i.e., six octets.
+    * If 2^32 <= a < 2^64, then  a is encoded as 0xff || 0xff || a[0..63], i.e., ten octets.
+    * For example, if a=2^16, the encoding of a  is
+    * 11111111 11111110 00000000 00000001 00000000 00000000.
+    */
+    pbuf = arr_b + 16; /* 16 offset */
+    index = 0;
+    if (channel->ctrl_ex.alen > 0) {
+        if (channel->ctrl_ex.alen < (0x10000 - 0x100)) {
+            pbuf[index++] = (gk_u8)(channel->ctrl_ex.alen >> 8); /* 8 right shift */
+            pbuf[index++] = (gk_u8)(channel->ctrl_ex.alen);
+        } else {
+            pbuf[index++] = 0xFF;
+            pbuf[index++] = 0xFE;
+            pbuf[index++] = (gk_u8)(channel->ctrl_ex.alen >> 24); /* 24 right shift */
+            pbuf[index++] = (gk_u8)(channel->ctrl_ex.alen >> 16); /* 16 right shift */
+            pbuf[index++] = (gk_u8)(channel->ctrl_ex.alen >> 8); /* 8 right shift */
+            pbuf[index++] = (gk_u8)channel->ctrl_ex.alen;
+        }
+    }
+    *b1_len = index;
+
+    return GK_SUCCESS;
+}
+
+static gk_void drv_cipher_cpu_input(gk_u8 *input, gk_u8 *output, gk_u32 length,
+                                    gk_u32 block_size, gk_u32 ctrl, gk_bool set_last)
+{
+    gk_u32 offset = 0;
+    gk_u32 buf[4]; /* 4 buf arr size */
+    gk_u32 size;
+    u_chan0_cipher_ctrl chn0_ctrl;
+    u_cipher_int_raw int_raw;
+
+    chn0_ctrl.u32 = ctrl;
+
+    while (offset < length) {
+        gk_u32 i;
+        gk_u32 time = 0;
+
+        /* Compute one block, if less than one block, padding with 0 */
+        size = (offset + block_size) < length ? block_size : length - offset;
+        crypto_memset(buf, sizeof(buf), 0, sizeof(buf));
+        crypto_memcpy(buf, sizeof(buf), &input[offset], size);
+        for (i = 0; i < block_size / 4; i++) /* 4 */
+            hal_cipher_write_reg(CHN_0_CIPHER_DIN + i * 4, buf[i]); /* 4 */
+
+        /* may be needs set last flag when compute last block */
+        if (((offset + block_size) >= length) && set_last)
+            chn0_ctrl.bits.sym_ch0_ccm_gcm_pc_last = 0x01;
+        hal_cipher_write_reg(CHN_0_CIPHER_CTRL, chn0_ctrl.u32);
+
+        /* start working */
+        hal_cipher_write_reg(CHN_0_CIPHER_CTRL, chn0_ctrl.u32 | 0x01);
+
+        /* Waiting compute finished */
+        hal_cipher_read_reg(CIPHER_INT_RAW, &int_raw.u32);
+        while (!(int_raw.bits.cipher_chn_obuf_raw & 0x01) && (time++ < SPACC_TIME_OUT))
+            hal_cipher_read_reg(CIPHER_INT_RAW, &int_raw.u32);
+
+        if (time >= SPACC_TIME_OUT) {
+            gk_err_cipher("Chn 0 time out!\n");
+            return;
+        }
+
+        /* Clean raw interrupt */
+        int_raw.u32 = 0x00;
+        int_raw.bits.cipher_chn_obuf_raw = 0x01;
+        hal_cipher_write_reg(CIPHER_INT_RAW, int_raw.u32);
+
+        /* May be needs read output data */
+        if (output != GK_NULL) {
+            for (i = 0; i < block_size / 4; i++) /* 4 */
+                hal_cipher_read_reg(CHN_0_CIPHER_DOUT + i * 4, &buf[i]); /* 4 */
+            crypto_memcpy(&output[offset], length, (gk_u8*)buf, size);
+        }
+
+        /* prepare compute next block */
+        offset += block_size;
+        chn0_ctrl.u32 &= ~(0x01 << 15); /* 15 iv set */
+    }
+}
+
+static gk_s32 drv_cipher_cpu_mmz_map(spacc_symc_chn_s *channel,
+    cipher_data_s *ci_data, spacc_mmz_s *spacc_mmz)
+{
+    gk_s32 ret;
+
+    /* mapping phy address of SRC */
+    spacc_mmz->src_mmz_buf.mmz_size = ci_data->data_length;
+    spacc_mmz->src_mmz_buf.start_phy_addr =
+        make_ulong(ci_data->src_phy_addr, ci_data->src_phy_addr_high);
+    ret = cipher_mmz_map(&spacc_mmz->src_mmz_buf);
+    if (ret != GK_SUCCESS) {
+        gk_err_cipher("DRV SRC MMZ MAP ERROR!, addr = 0x%x!\n", ci_data->src_phy_addr);
+        return ret;
+    }
+    spacc_mmz->src_vir = spacc_mmz->src_mmz_buf.start_vir_addr;
+
+    /* mapping phy address of DST */
+    spacc_mmz->dest_mmz_buf.mmz_size = ci_data->data_length;
+    spacc_mmz->dest_mmz_buf.start_phy_addr =
+        make_ulong(ci_data->dest_phy_addr, ci_data->dest_phy_addr_high);
+    ret = cipher_mmz_map(&spacc_mmz->dest_mmz_buf);
+    if (ret !=  GK_SUCCESS) {
+        gk_err_cipher("DRV DEST MMZ MAP ERROR! addr = 0x%x!\n", ci_data->dest_phy_addr);
+        cipher_mmz_unmap(&spacc_mmz->src_mmz_buf);
+        return ret;
+    }
+    spacc_mmz->dest_vir = spacc_mmz->dest_mmz_buf.start_vir_addr;
+
+    /* mapping phy address of A for CCM/GCM */
+    if ((channel->ctrl_ex.work_mode == GK_CIPHER_WORK_MODE_CCM) ||
+        (channel->ctrl_ex.work_mode == GK_CIPHER_WORK_MODE_GCM)) {
+        spacc_mmz->aad_mmz_buf.mmz_size = channel->ctrl_ex.alen;
+        spacc_mmz->aad_mmz_buf.start_phy_addr =
+            make_ulong(channel->ctrl_ex.aphy_addr, channel->ctrl_ex.aphy_addr_high);
+        ret = cipher_mmz_map(&spacc_mmz->aad_mmz_buf);
+        if (ret != GK_SUCCESS) {
+            gk_err_cipher("DRV AD MMZ MAP ERROR!, addr = 0x%x!\n", channel->ctrl_ex.aphy_addr);
+            cipher_mmz_unmap(&spacc_mmz->src_mmz_buf);
+            cipher_mmz_unmap(&spacc_mmz->dest_mmz_buf);
+            return ret;
+        }
+        spacc_mmz->aad_vir = spacc_mmz->aad_mmz_buf.start_vir_addr;
+    }
+    return ret;
+}
+
+static gk_void drv_cipher_cpu_mmz_unmap(spacc_symc_chn_s *channel, spacc_mmz_s *spacc_mmz)
+{
+    cipher_mmz_unmap(&spacc_mmz->src_mmz_buf);
+    cipher_mmz_unmap(&spacc_mmz->dest_mmz_buf);
+
+    if ((channel->ctrl_ex.work_mode == GK_CIPHER_WORK_MODE_CCM) ||
+        (channel->ctrl_ex.work_mode == GK_CIPHER_WORK_MODE_GCM))
+        cipher_mmz_unmap(&spacc_mmz->aad_mmz_buf);
+}
+
+static gk_s32 drv_cipher_cpu_enc_ccm(spacc_symc_chn_s *channel,
+    cipher_data_s *ci_data, u_chan0_cipher_ctrl *chn0_ctrl, spacc_mmz_s *spacc_mmz)
+{
+    gk_u8 arr_b[32] = {0}; /* 32 arr size */
+    gk_s32 ret;
+    gk_u32 value;
+    gk_u32 offset = 0;
+    gk_bool set_last;
+
+    /* Format N and A */
+    ret = drv_cipher_ccm_head_format(channel, ci_data->data_length, arr_b, sizeof(arr_b), &offset);
+    intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_ccm_head_format);
+
+    /* Set last block size */
+    chn0_ctrl->bits.sym_ccm_gcm_last_block = (ci_data->data_length + 15) % 16; /* 15, 16 */
+
+    /* Set flag N */
+    chn0_ctrl->bits.sym_ch0_ccm_gcm_input_flag = 0x00; // N
+
+    /* Compute B0, contains N */
+    set_last = (channel->ctrl_ex.alen + ci_data->data_length == 0) ? GK_TRUE : GK_FALSE;
+    drv_cipher_cpu_input(arr_b, GK_NULL, 16, 16, chn0_ctrl->u32, set_last); /* 16 */
+
+    /* Don't update IV any more */
+    chn0_ctrl->bits.sym_ch0_ivin_sel = 0x00;
+
+    /* Compute A */
+    value = channel->ctrl_ex.alen + offset;
+    if (value > 16) { /* 16, a can't puts in one block */
+        /* Set flag A */
+        chn0_ctrl->bits.sym_ch0_ccm_gcm_input_flag = 0x01; // A
+
+        /* Fill head of A to B1 split joint 16 byets */
+        crypto_memcpy(arr_b + 16 + offset, sizeof(arr_b) - 16 - offset, /* 16 */
+            spacc_mmz->aad_vir, 16 - offset); /* 16 */
+
+        /* Compute B1, contains the coding of a and head of A */
+        drv_cipher_cpu_input(arr_b + 16, GK_NULL, 16, 16, chn0_ctrl->u32, GK_FALSE); /* 16 */
+
+        /* Compute the left data of A */
+        set_last = (ci_data->data_length == 0) ? GK_TRUE : GK_FALSE;
+        drv_cipher_cpu_input(spacc_mmz->aad_vir + 16 - offset, GK_NULL, /* 16 */
+            channel->ctrl_ex.alen - (16 - offset), 16, chn0_ctrl->u32, set_last); /* 16 */
+    } else if (value > 0) { /* A and a can puts in one block */
+        /* Set flag A */
+        chn0_ctrl->bits.sym_ch0_ccm_gcm_input_flag = 0x01; // A
+
+        /* Fill A to B1 split joint 16 byets */
+        crypto_memcpy(arr_b + 16 + offset, sizeof(arr_b) - 16 - offset, /* 16 */
+            spacc_mmz->aad_vir, channel->ctrl_ex.alen);
+
+        /* Compute B1, contains the coding of a and A */
+        set_last = (ci_data->data_length == 0) ? GK_TRUE : GK_FALSE;
+        drv_cipher_cpu_input(arr_b + 16, GK_NULL, 16, 16, chn0_ctrl->u32, set_last); /* 16 */
+    }
+
+    /* Next, compute the P */
+    chn0_ctrl->bits.sym_ch0_ccm_gcm_input_flag = 0x02; // P
+
+    return ret;
+}
+
+static gk_void drv_cipher_cpu_enc_gcm(spacc_symc_chn_s *channel, cipher_data_s *ci_data,
+    u_chan0_cipher_ctrl *chn0_ctrl, spacc_mmz_s *spacc_mmz, gk_u32 block_size)
+{
+    gk_bool set_last;
+
+    /* Set last block size */
+    chn0_ctrl->bits.sym_ccm_gcm_last_block = (ci_data->data_length + 15) % 16; /* 15, 16 */
+
+    /* Compute A */
+    if (channel->ctrl_ex.alen > 0) {
+        /* Set flag A */
+        chn0_ctrl->bits.sym_ch0_ccm_gcm_input_flag = 0x00; // A
+
+        /* Compute A */
+        set_last = (ci_data->data_length == 0) ? GK_TRUE : GK_FALSE;
+        drv_cipher_cpu_input(spacc_mmz->aad_vir, GK_NULL,
+            channel->ctrl_ex.alen, block_size, chn0_ctrl->u32, set_last);
+
+        chn0_ctrl->bits.sym_ch0_ivin_sel = 0x00;
+    }
+
+    /* Don't update IV any more */
+    chn0_ctrl->bits.sym_ch0_ccm_gcm_input_flag = 0x01; // P
+}
+
+static gk_s32 drv_cipher_cpu_enc_phy(cipher_data_s *ci_data, gk_u32 block_size, gk_bool is_decrypt)
+{
+    gk_u32 ret;
+    u_chan0_cipher_ctrl chn0_ctrl;
+    gk_u8 arr_b[32]; /* 32 arr size */
+    spacc_mmz_s spacc_mmz;
+
+    spacc_symc_chn_s *channel = &g_symc_chn[0];
+
+    ret = drv_cipher_cpu_mmz_map(channel, ci_data, &spacc_mmz);
+    intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_cpu_mmz_map);
+
+    /* Decrypt or encrypt */
+    hal_cipher_read_reg(CHN_0_CIPHER_CTRL, &chn0_ctrl.u32);
+    chn0_ctrl.bits.sym_ch0_decrypt = is_decrypt;
+    hal_cipher_write_reg(CHN_0_CIPHER_CTRL, chn0_ctrl.u32);
+
+    if (channel->ctrl_ex.work_mode == GK_CIPHER_WORK_MODE_CCM) {
+        ret = drv_cipher_cpu_enc_ccm(channel, ci_data, &chn0_ctrl, &spacc_mmz);
+        if (ret != GK_SUCCESS) {
+            drv_cipher_cpu_mmz_unmap(channel, &spacc_mmz);
+            return ret;
+        }
+    } else if (channel->ctrl_ex.work_mode == GK_CIPHER_WORK_MODE_GCM) {
+        drv_cipher_cpu_enc_gcm(channel, ci_data, &chn0_ctrl, &spacc_mmz, block_size);
+    }
+
+    /* Compute P */
+    if (ci_data->data_length > 0) {
+        drv_cipher_cpu_input(spacc_mmz.src_vir, spacc_mmz.dest_vir,
+            ci_data->data_length, block_size, chn0_ctrl.u32, GK_TRUE);
+
+        /* Don't update IV any more */
+        chn0_ctrl.bits.sym_ch0_ivin_sel = 0x00;
+    }
+
+    /* Compute LEN(C) for GCM */
+    if (channel->ctrl_ex.work_mode == GK_CIPHER_WORK_MODE_GCM) {
+        /* Set flag LEN(C) */
+        crypto_memset(arr_b, sizeof(arr_b), 0, sizeof(arr_b));
+        chn0_ctrl.bits.sym_ch0_ccm_gcm_input_flag = 0x02; // LEN
+
+        /* Format LEN(C) = LEN(A) || LEN(P), coding in bits */
+        arr_b[3] = (gk_u8)((channel->ctrl_ex.alen >> 29) & 0x07); /* 3 index, 29 shift bits */
+        arr_b[4] = (gk_u8)((channel->ctrl_ex.alen >> 21) & 0xff); /* 4 index, 21 shift bits */
+        arr_b[5] = (gk_u8)((channel->ctrl_ex.alen >> 13) & 0xff); /* 5 index, 13 shift bits */
+        arr_b[6] = (gk_u8)((channel->ctrl_ex.alen >> 5)  & 0xff); /* 6 index, 5  shift bits */
+        arr_b[7] = (gk_u8)((channel->ctrl_ex.alen << 3)  & 0xff); /* 7 index, 3  shift bits */
+
+        arr_b[11] = (gk_u8)((ci_data->data_length >> 29) & 0x07); /* 11 index, 29 shift bits */
+        arr_b[12] = (gk_u8)((ci_data->data_length >> 21) & 0xff); /* 12 index, 21 shift bits */
+        arr_b[13] = (gk_u8)((ci_data->data_length >> 13) & 0xff); /* 13 index, 13 shift bits */
+        arr_b[14] = (gk_u8)((ci_data->data_length >> 5)  & 0xff); /* 14 index, 5  shift bits */
+        arr_b[15] = (gk_u8)((ci_data->data_length << 3)  & 0xff); /* 15 index, 3  shift bits */
+
+        /* Compute LEN(C) */
+        drv_cipher_cpu_input(arr_b, GK_NULL, 16, 16, chn0_ctrl.u32, GK_FALSE);  /* 16 */
+    }
+
+    drv_cipher_cpu_mmz_unmap(channel, &spacc_mmz);
+
+    return ret;
+}
+
+static gk_s32 drv_cipher_ccm_na(spacc_symc_chn_s *channel, gk_u32 enc_len)
+{
+    gk_s32 ret;
+    gk_u8 *pbuf = GK_NULL;
+    gk_u32 index = 0;
+    gk_u32 alen = 0;
+    gk_u32 count, flag;
+
+    pbuf = channel->pad_vir_addr;
+    crypto_memset(pbuf, SPACC_PAD_BUF_SIZE, 0, 32);  /* 32 memset size */
+
+    /* Format B0 and head of B1 */
+    ret = drv_cipher_ccm_head_format(channel, enc_len, pbuf, 32, &alen);  /* 32 */
+    intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_ccm_head_format);
+
+    /* B0 contains the N, set flag N, for N, A, P, must set the first and last flag. */
+    flag = SPACC_CTRL_SYMC_IN_CCM_N | SPACC_CTRL_SYMC_IN_LAST | SPACC_CTRL_SYMC_IN_FIRST;
+    if ((channel->ctrl_ex.alen == 0) && (enc_len == 0))
+        flag |= SPACC_CTRL_SYMC_CCM_LAST;
+
+    ret = spacc_symc_addbuf(channel->hard_num, channel->pad_phy_addr, 16, SPACC_BUF_TYPE_SYMC_IN, flag); /* 16 */
+    intf_func_fail_return(ret != SPACC_OK, GK_FAILURE, spacc_symc_addbuf);
+    index += 16; /* 16 */
+
+    /* a > 0, add the phy of A into node list */
+    if (alen) {
+        /* 1st. add the phy of B1 into node list, which contains the coding of a */
+        ret = spacc_symc_addbuf(channel->hard_num, channel->pad_phy_addr + 16, /* 16 */
+            alen, SPACC_BUF_TYPE_SYMC_IN, SPACC_CTRL_SYMC_IN_CCM_A);
+        intf_func_fail_return(ret != SPACC_OK, GK_FAILURE, spacc_symc_addbuf);
+        index += alen;
+
+        /* 2nd. add the phy of A into node list */
+        ret = spacc_symc_addbuf(channel->hard_num, channel->ctrl_ex.aphy_addr,
+            channel->ctrl_ex.alen, SPACC_BUF_TYPE_SYMC_IN, SPACC_CTRL_SYMC_IN_CCM_A);
+        intf_func_fail_return(ret != SPACC_OK, GK_FAILURE, spacc_symc_addbuf);
+    }
+
+    /* if alen + Alen do not aligned with 16, padding 0 to the tail */
+    count = (channel->ctrl_ex.alen + alen) % AES_BLOCK_SIZE;
+    if (count != 0) {
+        /* Compute the padding length */
+        count = AES_BLOCK_SIZE - count;
+
+        /* Set zero */
+        crypto_memset(&pbuf[index], SPACC_PAD_BUF_SIZE - index, 0, 16); /* 16 clean numbers */
+
+        /* add the padding phy of A into node list */
+        ret = spacc_symc_addbuf(channel->hard_num, channel->pad_phy_addr + index,
+            count, SPACC_BUF_TYPE_SYMC_IN, SPACC_CTRL_SYMC_IN_CCM_A);
+        intf_func_fail_return(ret != SPACC_OK, GK_FAILURE, spacc_symc_addbuf);
+    }
+
+    flag = SPACC_CTRL_SYMC_IN_LAST;
+    if (enc_len == 0) /* if do not contains the P, set CCM last flag signal to hardware */
+        flag |= SPACC_CTRL_SYMC_CCM_LAST;
+    spacc_symc_addctrl(channel->hard_num, SPACC_BUF_TYPE_SYMC_IN, flag);
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 drv_cipher_gcm_a(spacc_symc_chn_s *channel)
+{
+    gk_s32 ret;
+    gk_u32 count;
+    gk_u32 index = 0;
+    gk_u8 *pbuf = GK_NULL;
+
+    if (channel->ctrl_ex.alen == 0)
+        return GK_SUCCESS;
+
+    pbuf = channel->pad_vir_addr;
+
+    /* Add phy of A into node list */
+    ret = spacc_symc_addbuf(channel->hard_num,
+        make_ulong(channel->ctrl_ex.aphy_addr, channel->ctrl_ex.aphy_addr_high),
+        channel->ctrl_ex.alen, SPACC_BUF_TYPE_SYMC_IN, SPACC_CTRL_SYMC_IN_GCM_A);
+    if (ret != GK_SUCCESS) {
+        gk_err_cipher("spacc add A buf failed, ret = 0x%x.\n", ret);
+        return GK_FAILURE;
+    }
+
+    /* if Alen do not aligned with 16, padding 0 to the tail */
+    count = channel->ctrl_ex.alen % AES_BLOCK_SIZE;
+    if (count != 0) {
+        /* Compute the padding length */
+        count = AES_BLOCK_SIZE - count;
+
+        /* Set zero */
+        crypto_memset(&pbuf[index], SPACC_PAD_BUF_SIZE - index, 0, 16); /* 16 clean size */
+
+        /* add the padding phy of A into node list */
+        ret = spacc_symc_addbuf(channel->hard_num,
+            channel->pad_phy_addr + index, count,
+            SPACC_BUF_TYPE_SYMC_IN, SPACC_CTRL_SYMC_IN_GCM_A);
+        if (ret != GK_SUCCESS) {
+            gk_err_cipher("spacc add A PAD buf failed, ret = 0x%x.\n", ret);
+            return GK_FAILURE;
+        }
+    }
+
+    /* Set A last flag */
+    spacc_symc_addctrl(channel->hard_num, SPACC_BUF_TYPE_SYMC_IN, SPACC_CTRL_SYMC_IN_LAST);
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 drv_cipher_gcm_len(spacc_symc_chn_s *channel, gk_u32 enc_len)
+{
+    gk_s32 ret;
+    gk_u8 *pbuf;
+    gk_u32 index = 32;
+
+    /* Format len(C), 16 byets, coding in bits.
+     * Byet0~7:  bits number of Add
+     * Byet8~15: bits number of P
+     */
+    pbuf = channel->pad_vir_addr;
+
+    pbuf[index + 0]  = 0x00; /* 0 arr index */
+    pbuf[index + 1]  = 0x00; /* 1 arr index */
+    pbuf[index + 2]  = 0x00; /* 2 arr index */
+    pbuf[index + 3]  = (gk_u8)((channel->ctrl_ex.alen >> 29) & 0x07); /* 3 arr index, 29 shift bits */
+    pbuf[index + 4]  = (gk_u8)((channel->ctrl_ex.alen >> 21) & 0xff); /* 4 arr index, 21 shift bits */
+    pbuf[index + 5]  = (gk_u8)((channel->ctrl_ex.alen >> 13) & 0xff); /* 5 arr index, 13 shift bits */
+    pbuf[index + 6]  = (gk_u8)((channel->ctrl_ex.alen >> 5)  & 0xff); /* 6 arr index, 5  shift bits */
+    pbuf[index + 7]  = (gk_u8)((channel->ctrl_ex.alen << 3)  & 0xff); /* 7 arr index, 3 shift bits */
+    pbuf[index + 8]  = 0x00; /* 8 arr index */
+    pbuf[index + 9]  = 0x00; /* 9 arr index */
+    pbuf[index + 10] = 0x00; /* 10 arr index */
+    pbuf[index + 11] = (gk_u8)((enc_len >> 29) & 0x07); /* 11 arr index, 29 shift bits */
+    pbuf[index + 12] = (gk_u8)((enc_len >> 21) & 0xff); /* 12 arr index, 21 shift bits */
+    pbuf[index + 13] = (gk_u8)((enc_len >> 13) & 0xff); /* 13 arr index, 13 shift bits */
+    pbuf[index + 14] = (gk_u8)((enc_len >> 5)  & 0xff); /* 14 arr index, 5 shift bits */
+    pbuf[index + 15] = (gk_u8)((enc_len << 3)  & 0xff); /* 15 arr index, 3 shift bits */
+
+    /* Add to nodes list */
+    ret = spacc_symc_addbuf(channel->hard_num, channel->pad_phy_addr + index,
+        16, SPACC_BUF_TYPE_SYMC_IN, SPACC_CTRL_SYMC_IN_GCM_LEN | SPACC_CTRL_SYMC_IN_LAST); /* 16 */
+    if (ret != GK_SUCCESS) {
+        gk_err_cipher("spacc add P buf failed, ret = 0x%x.\n", ret);
+        return GK_FAILURE;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 drv_cipher_enc_ccm(spacc_symc_chn_s *channel,
+    cipher_data_s *ci_data, gk_size_t src_phy_addr, gk_size_t dst_phys_addr)
+{
+    gk_s32 ret;
+
+    /* format N and A, add to node list */
+    ret = drv_cipher_ccm_na(channel, ci_data->data_length);
+    intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_ccm_na);
+
+    /* Add the phy of P into node list */
+    if (ci_data->data_length > 0) {
+        /* Add in buffer */
+        ret = spacc_symc_addbuf(channel->hard_num, src_phy_addr, ci_data->data_length,
+            SPACC_BUF_TYPE_SYMC_IN, SPACC_CTRL_SYMC_IN_CCM_P | SPACC_CTRL_SYMC_IN_LAST);
+        intf_func_fail_return(ret != SPACC_OK, GK_FAILURE, spacc_symc_addbuf);
+
+        /* Add out buffer */
+        ret = spacc_symc_addbuf(channel->hard_num, dst_phys_addr, ci_data->data_length,
+            SPACC_BUF_TYPE_SYMC_OUT, SPACC_CTRL_SYMC_OUT_LAST);
+        intf_func_fail_return(ret != SPACC_OK, GK_FAILURE, spacc_symc_addbuf);
+    } else {
+        /* If P is null, must add a empty node into node list, limit to hardware devising */
+        ret = spacc_symc_addbuf(channel->hard_num, 0x00, 0x00,
+            SPACC_BUF_TYPE_SYMC_OUT, SPACC_CTRL_SYMC_OUT_LAST);
+        intf_func_fail_return(ret != SPACC_OK, GK_FAILURE, spacc_symc_addbuf);
+    }
+
+    /* Set CCM last flag */
+    spacc_symc_addctrl(channel->hard_num, SPACC_BUF_TYPE_SYMC_IN, SPACC_CTRL_SYMC_CCM_LAST);
+
+    return ret;
+}
+
+static gk_s32 drv_cipher_enc_gcm(spacc_symc_chn_s *channel,
+    cipher_data_s *ci_data, gk_size_t src_phy_addr, gk_size_t dest_phy_addr)
+{
+    gk_s32 ret;
+
+    /* format N, add to node list */
+    ret = drv_cipher_gcm_a(channel);
+    intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_gcm_a);
+
+    /* Add the phy of P into node list */
+    if (ci_data->data_length > 0) {
+        /* Add in buffer */
+        ret = spacc_symc_addbuf(channel->hard_num, src_phy_addr, ci_data->data_length,
+            SPACC_BUF_TYPE_SYMC_IN, SPACC_CTRL_SYMC_IN_GCM_P | SPACC_CTRL_SYMC_IN_LAST);
+        intf_func_fail_return(ret != SPACC_OK, GK_FAILURE, spacc_symc_addbuf);
+
+        /* Add out buffer */
+        ret = spacc_symc_addbuf(channel->hard_num, dest_phy_addr, ci_data->data_length,
+            SPACC_BUF_TYPE_SYMC_OUT, SPACC_CTRL_NONE);
+        intf_func_fail_return(ret != SPACC_OK, GK_FAILURE, spacc_symc_addbuf);
+    }
+
+    /* At the and of GCM, must add a empty node to nodes list, limit to hardware devising */
+    ret = spacc_symc_addbuf(channel->hard_num, 0x00, 0x00,
+        SPACC_BUF_TYPE_SYMC_OUT, SPACC_CTRL_SYMC_OUT_LAST);
+    intf_func_fail_return(ret != SPACC_OK, GK_FAILURE, spacc_symc_addbuf);
+
+    /* Format the length fields of C and add to nodes list */
+    ret = drv_cipher_gcm_len(channel, ci_data->data_length);
+    intf_func_fail_return(ret != GK_SUCCESS, ret, spacc_symcdrv_cipher_gcm_len_addbuf);
+
+    return ret;
+}
+
+/* except ccm/gcm */
+static gk_s32 drv_cipher_enc_others(spacc_symc_chn_s *channel,
+    cipher_data_s *ci_data, gk_size_t src_phy_addr, gk_size_t dest_phy_addr)
+{
+    gk_s32 ret;
+
+    /* except ccm/gcm, the data length must not zero */
+    if (ci_data->data_length == 0) {
+        gk_err_cipher("Invalid data len 0x%x.\n", ci_data->data_length);
+        return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    /* The length of data depend on alg and mode, which limit to hardware
+     * for ecb/cbc/ofb/cfb, the data length must aligned with block size.
+     * for ctr/ccm/gcm, support any data length.
+     */
+    if (((channel->ctrl_ex.work_mode == GK_CIPHER_WORK_MODE_ECB) ||
+         (channel->ctrl_ex.work_mode == GK_CIPHER_WORK_MODE_CBC) ||
+         (channel->ctrl_ex.work_mode == GK_CIPHER_WORK_MODE_OFB) ||
+         (channel->ctrl_ex.work_mode == GK_CIPHER_WORK_MODE_CFB)) &&
+         (channel->ctrl_ex.ci_alg != GK_CIPHER_ALG_DMA)) {
+        if (ci_data->data_length % channel->block_size != 0) {
+            gk_err_cipher("Invalid data len 0x%x.\n", ci_data->data_length);
+            return GK_ERR_CIPHER_INVALID_PARA;
+        }
+    }
+
+    /* Add in buffer */
+    ret = spacc_symc_addbuf(channel->hard_num, src_phy_addr, ci_data->data_length,
+        SPACC_BUF_TYPE_SYMC_IN, SPACC_CTRL_SYMC_IN_LAST);
+    intf_func_fail_return(ret != SPACC_OK, GK_FAILURE, spacc_symc_addbuf);
+
+    /* Add out buffer */
+    ret = spacc_symc_addbuf(channel->hard_num, dest_phy_addr, ci_data->data_length,
+        SPACC_BUF_TYPE_SYMC_OUT, SPACC_CTRL_SYMC_OUT_LAST);
+    intf_func_fail_return(ret != SPACC_OK, GK_FAILURE, spacc_symc_addbuf);
+
+    return ret;
+}
+
+static gk_s32 drv_cipher_crypto(cipher_data_s *ci_data, gk_bool is_decrypt)
+{
+    gk_s32 ret;
+    spacc_symc_chn_s *channel;
+    gk_u32 soft_chn_id;
+    gk_size_t src_phy_addr, dest_phy_addr;
+
+    src_phy_addr = make_ulong(ci_data->src_phy_addr, ci_data->src_phy_addr_high);
+    dest_phy_addr = make_ulong(ci_data->dest_phy_addr, ci_data->dest_phy_addr_high);
+
+    soft_chn_id = handle_get_chn_id(ci_data->ci_handle);
+    channel = &g_symc_chn[soft_chn_id];
+
+    if (soft_chn_id != 0) {
+        if (channel->ctrl_ex.work_mode == GK_CIPHER_WORK_MODE_CCM) {
+            ret = drv_cipher_enc_ccm(channel, ci_data, src_phy_addr, dest_phy_addr);
+            intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_enc_ccm);
+        } else if (channel->ctrl_ex.work_mode == GK_CIPHER_WORK_MODE_GCM) {
+            ret = drv_cipher_enc_gcm(channel, ci_data, src_phy_addr, dest_phy_addr);
+            intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_enc_gcm);
+        } else { /* ECB/CBC/CBF/OFB/CTR */
+            ret = drv_cipher_enc_others(channel, ci_data, src_phy_addr, dest_phy_addr);
+            intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_enc_others);
+        }
+
+        channel->symc_done = GK_FALSE;
+
+        /* Start working */
+        spacc_symc_start(channel->hard_num, is_decrypt, channel->ctrl_ex.change_flags.bits_iv);
+
+        if (channel->ctrl_ex.change_flags.bits_iv == GK_CIPHER_IV_CHG_ONE_PKG)
+            channel->ctrl_ex.change_flags.bits_iv = 0; /* only update IV for first pkg */
+
+        /* Waiting hardware computing finished */
+        ret = drv_cipher_symc_wait_done(channel, SPACC_TIME_OUT);
+        intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_symc_wait_done);
+
+        flush_cache(cipher_align_down(dest_phy_addr), cipher_align_size(dest_phy_addr, ci_data->data_length));
+    } else {
+        /* Chn 0, CPU mode */
+        ret = drv_cipher_cpu_enc_phy(ci_data, channel->block_size, is_decrypt);
+        intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_cpu_enc_phy);
+    }
+
+    /* Save IV */
+    if (channel->ctrl_ex.change_flags.bits_iv == GK_CIPHER_IV_CHG_ONE_PKG)
+        spacc_symc_getiv(channel->hard_num, channel->ctrl_ex.iv, sizeof(channel->ctrl_ex.iv));
+
+    flush_cache(cipher_align_down(dest_phy_addr), cipher_align_size(dest_phy_addr, ci_data->data_length));
+
+    return ret;
+}
+
+gk_s32 gk_drv_cipher_get_tag(cipher_tag_s *tag)
+{
+    gk_u32 soft_chn_id;
+    spacc_symc_chn_s *channel = GK_NULL;
+    gk_u32 i;
+    gk_s32 ret;
+
+    if (tag ==  GK_NULL) {
+        gk_err_cipher("Invalid params!\n");
+        return GK_FAILURE;
+    }
+    if (cipher_mutex_lock(&g_symc_mutex)) {
+        gk_err_cipher("cipher_mutex_lock failed!\n");
+        return GK_FAILURE;
+    }
+
+    ret = spacc_check_handle(tag->ci_handle);
+    if (ret != GK_SUCCESS)
+        return ret;
+
+    soft_chn_id = handle_get_chn_id(tag->ci_handle);
+    channel = &g_symc_chn[soft_chn_id];
+
+    if ((channel->ctrl_ex.work_mode != GK_CIPHER_WORK_MODE_CCM) &&
+        (channel->ctrl_ex.work_mode != GK_CIPHER_WORK_MODE_GCM)) {
+        gk_err_cipher("Invalid mode %d!\n", channel->ctrl_ex.work_mode);
+        cipher_mutex_unlock(&g_symc_mutex);
+        return GK_FAILURE;
+    }
+    tag->tag_len = channel->ctrl_ex.tag_len;
+
+    /* Read tag for CCM/GCM */
+    if (soft_chn_id == 0) {
+        for (i = 0; i < 4; i++) /* 4 loop count */
+            hal_cipher_read_reg(CHN_0_CCM_GCM_TAG + i * 4, &tag->tag[i]); /* 4 */
+    } else {
+        spacc_symc_gettag(channel->hard_num, (gk_u8*)tag->tag);
+    }
+
+    cipher_mutex_unlock(&g_symc_mutex);
+
+    return GK_SUCCESS;
+}
+
+gk_s32 gk_drv_cipher_encrypt(cipher_data_s *ci_data)
+{
+    gk_s32 ret;
+
+    if (ci_data == GK_NULL) {
+        gk_err_cipher("Invalid point!\n");
+        return GK_ERR_CIPHER_INVALID_POINT;
+    }
+
+    if (cipher_mutex_lock(&g_symc_mutex)) {
+        gk_err_cipher("cipher_mutex_lock failed!\n");
+        return GK_FAILURE;
+    }
+
+    ret = spacc_check_handle(ci_data->ci_handle);
+    if (ret != GK_SUCCESS)
+        return ret;
+
+    ret = drv_cipher_crypto(ci_data, GK_FALSE);
+    cipher_mutex_unlock(&g_symc_mutex);
+
+    return ret;
+}
+
+gk_s32 gk_drv_cipher_decrypt(cipher_data_s *ci_data)
+{
+    gk_s32 ret;
+
+    if (ci_data ==  GK_NULL) {
+        gk_err_cipher("Invalid point!\n");
+        return GK_ERR_CIPHER_INVALID_POINT;
+    }
+
+    if (cipher_mutex_lock(&g_symc_mutex)) {
+        gk_err_cipher("cipher_mutex_lock failed!\n");
+        return GK_FAILURE;
+    }
+
+    ret = spacc_check_handle(ci_data->ci_handle);
+    if (ret != GK_SUCCESS)
+        return ret;
+
+    ret = drv_cipher_crypto(ci_data, GK_TRUE);
+    cipher_mutex_unlock(&g_symc_mutex);
+
+    return ret;
+}
+
+/* Get odd/even key flag and P flag */
+static gk_u32 drv_cipher_get_pay_load_ctrl(gk_bool odd_key, gk_cipher_work_mode mode)
+{
+    gk_u32 ctrl;
+
+    ctrl = odd_key ? SPACC_CTRL_SYMC_ODD_KEY : SPACC_CTRL_SYMC_EVEN_KEY;
+
+    if (mode == GK_CIPHER_WORK_MODE_CCM)
+        ctrl |= SPACC_CTRL_SYMC_IN_CCM_P;
+    else if (mode == GK_CIPHER_WORK_MODE_GCM)
+        ctrl |= SPACC_CTRL_SYMC_IN_GCM_P;
+
+    return ctrl;
+}
+
+static gk_s32 drv_cipher_block_align(spacc_symc_chn_s *channel, gk_u32 total, gk_u32 node_cur)
+{
+    gk_s32 ret = GK_SUCCESS;
+    gk_u32 ctrl;
+
+    /* Compute the tail length */
+    total %= channel->block_size;
+    if (total > 0)
+        total = channel->block_size - total;
+
+    /* if the total length don't aligned with block size, split joint the follow nodes */
+    while ((total > 0) && (channel->node_cur < channel->node_num)) {
+        /* The next node large than tail size, just split it to 2 nodes */
+        if (channel->node_list[node_cur].byte_len > total) {
+            /* Add P in */
+            ctrl = drv_cipher_get_pay_load_ctrl(channel->node_list[node_cur].odd_key, channel->ctrl_ex.work_mode);
+            ret = spacc_symc_addbuf(channel->hard_num, channel->node_list[node_cur].src_phys_addr,
+                total, SPACC_BUF_TYPE_SYMC_IN, ctrl);
+            intf_func_fail_return(ret != SPACC_OK, GK_FAILURE, spacc_symc_addbuf);
+
+            /* Add P out */
+            ret = spacc_symc_addbuf(channel->hard_num, channel->node_list[node_cur].dst_phys_addr,
+                total, SPACC_BUF_TYPE_SYMC_OUT, SPACC_CTRL_NONE);
+            intf_func_fail_return(ret != SPACC_OK, GK_FAILURE, spacc_symc_addbuf);
+
+            /* Let next node skip the tail size */
+            channel->node_list[node_cur].src_phys_addr  += total;
+            channel->node_list[node_cur].dst_phys_addr += total;
+            channel->node_list[node_cur].byte_len -= total;
+            total = 0;
+        } else {
+            /* The next node less than tail size, add it to nodes list */
+            /* Add P in */
+            ctrl = drv_cipher_get_pay_load_ctrl(channel->node_list[node_cur].odd_key, channel->ctrl_ex.work_mode);
+            ret = spacc_symc_addbuf(channel->hard_num, channel->node_list[node_cur].src_phys_addr,
+                channel->node_list[node_cur].byte_len, SPACC_BUF_TYPE_SYMC_IN, ctrl);
+            intf_func_fail_return(ret != SPACC_OK, GK_FAILURE, spacc_symc_addbuf);
+
+            /* Add P out */
+            ret = spacc_symc_addbuf(channel->hard_num, channel->node_list[node_cur].dst_phys_addr,
+                channel->node_list[node_cur].byte_len, SPACC_BUF_TYPE_SYMC_OUT, SPACC_CTRL_NONE);
+            intf_func_fail_return(ret != SPACC_OK, GK_FAILURE, spacc_symc_addbuf);
+
+            /* re-compute the tail size */
+            total -= channel->node_list[node_cur].byte_len;
+
+            /* Process next node */
+            node_cur++;
+            channel->node_cur++;
+        }
+    }
+
+    return ret;
+}
+
+static gk_s32 drv_cipher_add_nodes(spacc_symc_chn_s *channel, gk_u32 int_level)
+{
+    gk_u32 i;
+    gk_s32 ret = GK_SUCCESS;
+    gk_u32 nodes, node_cur, ctrl, total;
+
+    if (channel->node_cur < channel->node_num) {
+        nodes = cipher_min(int_level, channel->node_num - channel->node_cur);
+        node_cur = channel->node_cur;
+        total = 0;
+        for (i = 0; i < nodes; i++) {
+            /* Get odd/even key flag and P flag */
+            ctrl = drv_cipher_get_pay_load_ctrl(channel->node_list[node_cur].odd_key, channel->ctrl_ex.work_mode);
+
+            /* Add P in */
+            ret = spacc_symc_addbuf(channel->hard_num, channel->node_list[node_cur].src_phys_addr,
+                channel->node_list[node_cur].byte_len, SPACC_BUF_TYPE_SYMC_IN, ctrl);
+            intf_func_fail_return(ret != SPACC_OK, GK_FAILURE, spacc_symc_addbuf);
+
+            /* Add P out */
+            ret = spacc_symc_addbuf(channel->hard_num, channel->node_list[node_cur].dst_phys_addr,
+                channel->node_list[node_cur].byte_len, SPACC_BUF_TYPE_SYMC_OUT, SPACC_CTRL_NONE);
+            intf_func_fail_return(ret != SPACC_OK, GK_FAILURE, spacc_symc_addbuf);
+
+            total += channel->node_list[node_cur].byte_len;
+            channel->node_cur++;
+            node_cur++;
+        }
+
+       /* For each compute, the total length of valid nodes list
+        * must aligned with block size, otherwise can't recv interrupt,
+        * which limit to hardware devising.
+        */
+        ret = drv_cipher_block_align(channel, total, node_cur);
+        intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_block_align);
+    }
+
+    if (channel->node_cur == channel->node_num) { /* Set last flag */
+        if (channel->ctrl_ex.work_mode == GK_CIPHER_WORK_MODE_CCM) {
+            /* Set CCM last flag */
+            spacc_symc_addctrl(channel->hard_num, SPACC_BUF_TYPE_SYMC_IN, SPACC_CTRL_SYMC_CCM_LAST);
+        } else if (channel->ctrl_ex.work_mode == GK_CIPHER_WORK_MODE_GCM) {
+            /* Set GCM last flag */
+            spacc_symc_addctrl(channel->hard_num, SPACC_BUF_TYPE_SYMC_IN, SPACC_CTRL_SYMC_IN_LAST);
+
+            /* At the and of GCM, must add a empty P node to nodes list, limit to hardware devising */
+            ret = spacc_symc_addbuf(channel->hard_num, 0x00, 0x00,
+                SPACC_BUF_TYPE_SYMC_OUT, SPACC_CTRL_SYMC_OUT_LAST);
+            intf_func_fail_return(ret != SPACC_OK, GK_FAILURE, spacc_symc_addbuf);
+
+            /* After compute P, compute LEN(C) for GCM */
+            ret = drv_cipher_gcm_len(channel, channel->total_len);
+            intf_func_fail_return(ret != GK_SUCCESS, ret, spacc_symc_addbuf);
+        }
+
+        /* Set symc last flag */
+        spacc_symc_addctrl(channel->hard_num, SPACC_BUF_TYPE_SYMC_IN, SPACC_CTRL_SYMC_IN_LAST);
+        spacc_symc_addctrl(channel->hard_num, SPACC_BUF_TYPE_SYMC_OUT, SPACC_CTRL_SYMC_OUT_LAST);
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_void drv_cipher_callback(gk_u32 chn_id)
+{
+    gk_s32 ret;
+    spacc_symc_chn_s *channel = GK_NULL;
+
+    if (chn_id >= SPACC_MAX_CHN) {
+        gk_err_cipher("invalid chn_id %u\n", chn_id);
+        return;
+    }
+    channel = &g_symc_chn[chn_id];
+
+    /* Compute the follow nodes */
+    if (channel->node_cur < channel->node_num) {
+        ret = drv_cipher_add_nodes(channel, SYMC_INT_LEVEL);
+        if (ret == GK_SUCCESS)
+            spacc_symc_restart(channel->hard_num, channel->ctrl_ex.change_flags.bits_iv);
+    } else {
+        /* All the nodes compute finished, wake up user */
+        channel->symc_done = GK_TRUE;
+        gk_info_cipher("chn %d wake up\n", channel->hard_num);
+        cipher_queue_wait_up(&channel->queue);
+    }
+}
+
+static gk_s32 drv_cipher_enc_prepare(spacc_symc_chn_s *channel)
+{
+    gk_s32 ret = GK_SUCCESS;
+
+    /* Before compute P, compute N and A for CCM firstly */
+    if (channel->ctrl_ex.work_mode == GK_CIPHER_WORK_MODE_CCM) {
+        /* Format N and A, add to node list */
+        ret = drv_cipher_ccm_na(channel, channel->total_len);
+        intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_ccm_na);
+
+        if (channel->total_len == 0) {
+            /* If P is null, must add a empty node into node list, limit to hardware devising */
+            ret = spacc_symc_addbuf(channel->hard_num, 0x00, 0x00,
+                SPACC_BUF_TYPE_SYMC_OUT, SPACC_CTRL_SYMC_OUT_LAST);
+            intf_func_fail_return(ret != SPACC_OK, GK_FAILURE, drv_cipher_ccm_na);
+        }
+    } else if (channel->ctrl_ex.work_mode == GK_CIPHER_WORK_MODE_GCM) {
+        /* Before compute P, compute A for GCM firstly */
+        ret = drv_cipher_gcm_a(channel);
+        intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_gcm_a);
+    } else if ((channel->ctrl_ex.work_mode == GK_CIPHER_WORK_MODE_ECB) ||
+              (channel->ctrl_ex.work_mode == GK_CIPHER_WORK_MODE_CBC) ||
+              (channel->ctrl_ex.work_mode == GK_CIPHER_WORK_MODE_CFB) ||
+              (channel->ctrl_ex.work_mode == GK_CIPHER_WORK_MODE_OFB)) {
+       /* The length of data depend on alg and mode, which limit to hardware
+        * for ecb/cbc/ofb/cfb, the total data length must aligned with block size.
+        * for ctr/ccm/gcm, support any data length.
+        */
+        if (channel->total_len % channel->block_size != 0) {
+            gk_err_cipher("PKG len must align with 16.\n");
+            return GK_ERR_CIPHER_INVALID_PARA;
+        }
+    }
+
+    return ret;
+}
+
+static gk_s32 drv_cipher_encrypt_multi(cipher_pkg_s *pkg, gk_bool is_decrypt)
+{
+    gk_s32 ret;
+    gk_u32 i, soft_chn_id, remainder;
+    spacc_symc_chn_s *channel = GK_NULL;
+    cipher_data_compat_s *cipher_data = GK_NULL;
+
+    intf_param_invalid_return((pkg->pkg_num == 0) || (pkg->pkg_num > MAX_MULTI_PKG_NUM));
+
+    soft_chn_id = handle_get_chn_id(pkg->ci_handle);
+    channel = &g_symc_chn[soft_chn_id];
+
+    gk_info_cipher("pkg_num %d\n", pkg->pkg_num);
+    channel->node_list = cipher_malloc(pkg->pkg_num * sizeof(gk_cipher_data));
+    intf_func_fail_return(channel->node_list == GK_NULL, GK_ERR_CIPHER_INVALID_POINT, cipher_malloc);
+
+    cipher_data = (cipher_data_compat_s *)channel->node_list;
+
+    /* copy node list from user space to kernel */
+    ret = cipher_copy_from_user(channel->node_list,
+        pkg->cipher_data, pkg->pkg_num * sizeof(gk_cipher_data));
+    intf_func_fail_return(ret != 0, GK_FAILURE, cipher_copy_from_user);
+
+    /* Compute and check the nodes length */
+    channel->total_len = 0;
+
+    for (i = pkg->pkg_num; i > 0; i--) {
+        if (pkg->user_bit_width != MY_CPU_BIT_WIDTH) {
+            channel->node_list[i - 1].byte_len = cipher_data[i - 1].byte_length;
+            channel->node_list[i - 1].dst_phys_addr = cipher_data[i - 1].dst_phys_addr;
+            channel->node_list[i - 1].src_phys_addr = cipher_data[i - 1].src_phys_addr;
+        }
+
+        /* Can't used the odd key */
+        if (channel->node_list[i - 1].odd_key) {
+            gk_err_cipher("Odd key unsupport.\n");
+            return GK_FAILURE;
+        }
+
+        /* each node length can't be zero */
+        if (channel->node_list[i - 1].byte_len == 0) {
+            gk_err_cipher("PKG len must large than 0.\n");
+            return GK_ERR_CIPHER_INVALID_PARA;
+        }
+
+        channel->total_len += channel->node_list[i - 1].byte_len;
+    }
+
+    ret = drv_cipher_enc_prepare(channel);
+    intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_enc_prepare);
+
+    channel->node_num = pkg->pkg_num;
+    channel->node_cur = 0;
+
+    /* For one time compute, the max nodes is 127, but 126 for first time,
+     * here we compute 100 nodes firstly,
+     * Because under each compute, the total length of valid nodes list
+     * must aligned with block size, otherwise can't recv interrupt.
+     * if the total length don't aligned with block size, we must
+     * split joint the follow nodes with current nodes to multiple block size.
+     * so it follows that, the nodes num for this time compute may be larger than 100,
+     * The worst is that we need add 15 nodes(each node only carry 1 bye data)
+     * within this time, that is the SYMC_INT_LEVEL must less than 127 - 16 - 1= 110.
+     */
+    remainder = cipher_min(pkg->pkg_num, SYMC_INT_LEVEL);
+    ret = drv_cipher_add_nodes(channel, remainder);
+    intf_func_fail_return(ret != GK_SUCCESS, ret, drv_cipher_add_nodes);
+
+    channel->callback = drv_cipher_callback;
+    channel->symc_done = GK_FALSE;
+    spacc_symc_start(channel->hard_num, is_decrypt, channel->ctrl_ex.change_flags.bits_iv);
+    return ret;
+}
+
+gk_s32 gk_drv_cipher_encrypt_multi(cipher_pkg_s *pkg)
+{
+    gk_s32 ret;
+    gk_u32 soft_chn_id;
+    spacc_symc_chn_s *channel = GK_NULL;
+
+    if (pkg == GK_NULL) {
+        gk_err_cipher("Invalid pkg.\n");
+        return GK_ERR_CIPHER_INVALID_POINT;
+    }
+
+    if (cipher_mutex_lock(&g_symc_mutex)) {
+        gk_err_cipher("cipher_mutex_lock failed!\n");
+        return GK_FAILURE;
+    }
+
+    ret = spacc_check_handle(pkg->ci_handle);
+    if (ret != GK_SUCCESS)
+        return ret;
+    soft_chn_id = handle_get_chn_id(pkg->ci_handle);
+    channel = &g_symc_chn[soft_chn_id];
+
+    ret = drv_cipher_encrypt_multi(pkg, GK_FALSE);
+    if (ret != GK_SUCCESS) {
+        if (channel->node_list != GK_NULL) {
+            cipher_free(channel->node_list);
+            channel->node_list = GK_NULL;
+        }
+        cipher_mutex_unlock(&g_symc_mutex);
+        return ret;
+    }
+
+    ret = drv_cipher_symc_wait_done(channel, SPACC_TIME_OUT);
+    if (ret != GK_SUCCESS)
+        gk_err_cipher("spacc symc active failed, ret = 0x%x.\n", ret);
+
+    if (channel->node_list != GK_NULL) {
+        cipher_free(channel->node_list);
+        channel->node_list = GK_NULL;
+    }
+
+    if (channel->ctrl_ex.change_flags.bits_iv == GK_CIPHER_IV_CHG_ONE_PKG)
+        spacc_symc_getiv(channel->hard_num, channel->ctrl_ex.iv, sizeof(channel->ctrl_ex.iv));
+    cipher_mutex_unlock(&g_symc_mutex);
+
+    return ret;
+}
+
+gk_s32 gk_drv_cipher_decrypt_multi(cipher_pkg_s *pkg)
+{
+    gk_s32 ret;
+    gk_u32 soft_chn_id;
+    spacc_symc_chn_s *channel = GK_NULL;
+
+    if (pkg == GK_NULL) {
+        gk_err_cipher("Invalid pkg.\n");
+        return GK_ERR_CIPHER_INVALID_POINT;
+    }
+
+    if (cipher_mutex_lock(&g_symc_mutex)) {
+        gk_err_cipher("cipher_mutex_lock failed!\n");
+        return GK_FAILURE;
+    }
+
+    ret = spacc_check_handle(pkg->ci_handle);
+    if (ret != GK_SUCCESS)
+        return ret;
+    soft_chn_id = handle_get_chn_id(pkg->ci_handle);
+    channel = &g_symc_chn[soft_chn_id];
+
+    ret = drv_cipher_encrypt_multi(pkg, GK_TRUE);
+    if (ret != GK_SUCCESS) {
+        if (channel->node_list != GK_NULL) {
+            cipher_free(channel->node_list);
+            channel->node_list = GK_NULL;
+        }
+        cipher_mutex_unlock(&g_symc_mutex);
+        return ret;
+    }
+
+    ret = drv_cipher_symc_wait_done(channel, SPACC_TIME_OUT);
+    if (ret != GK_SUCCESS)
+        gk_err_cipher("spacc symc active failed, ret = 0x%x.\n", ret);
+
+    if (channel->node_list != GK_NULL) {
+        cipher_free(channel->node_list);
+        channel->node_list = GK_NULL;
+    }
+
+    if (channel->ctrl_ex.change_flags.bits_iv == GK_CIPHER_IV_CHG_ONE_PKG)
+        spacc_symc_getiv(channel->hard_num, channel->ctrl_ex.iv, sizeof(channel->ctrl_ex.iv));
+    cipher_mutex_unlock(&g_symc_mutex);
+
+    return ret;
+}
+
+static gk_s32 drv_digest_config(cipher_hash_data_s *cipher_hash_data, spacc_ctrl_en *spacc_ctrl)
+{
+    gk_s32 ret;
+    digest_alg_en digest_alg;
+    digest_mode_en digest_mode;
+
+    *spacc_ctrl = SPACC_CTRL_NONE;
+
+    switch (cipher_hash_data->sha_type) {
+        case GK_CIPHER_HASH_TYPE_SHA1:
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA1:
+            digest_alg = DIGEST_ALG_SHA1;
+            digest_mode = DIGEST_MODE_HASH;
+            break;
+        case GK_CIPHER_HASH_TYPE_SHA224:
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA224:
+            digest_alg = DIGEST_ALG_SHA224;
+            digest_mode = DIGEST_MODE_HASH;
+            break;
+        case GK_CIPHER_HASH_TYPE_SHA256:
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA256:
+            digest_alg = DIGEST_ALG_SHA256;
+            digest_mode = DIGEST_MODE_HASH;
+            break;
+        case GK_CIPHER_HASH_TYPE_SHA384:
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA384:
+            digest_alg = DIGEST_ALG_SHA384;
+            digest_mode = DIGEST_MODE_HASH;
+            break;
+        case GK_CIPHER_HASH_TYPE_SHA512:
+        case GK_CIPHER_HASH_TYPE_HMAC_SHA512:
+            digest_alg = DIGEST_ALG_SHA512;
+            digest_mode = DIGEST_MODE_HASH;
+            break;
+        case GK_CIPHER_HASH_TYPE_SM3:
+            digest_alg = DIGEST_ALG_SM3;
+            digest_mode = DIGEST_MODE_HASH;
+            break;
+        default:
+            gk_err_cipher("Invalid hash type: 0x%x\n", cipher_hash_data->sha_type);
+            return GK_ERR_CIPHER_INVALID_PARA;
+    }
+
+    ret = spacc_digest_config(cipher_hash_data->hard_chn, digest_alg, digest_mode, GK_FALSE);
+    if (ret != GK_SUCCESS) {
+        gk_err_cipher("spacc set digest mode failed, chn %d, alg %d, mode %d.\n",
+            cipher_hash_data->hard_chn, digest_alg, digest_mode);
+        return GK_FAILURE;
+    }
+
+    *spacc_ctrl = ((gk_u32)*spacc_ctrl) | SPACC_CTRL_HASH_IN_FIRST;
+    *spacc_ctrl = ((gk_u32)*spacc_ctrl) | SPACC_CTRL_HASH_IN_LAST;
+
+    return GK_SUCCESS;
+
+}
+
+gk_s32 gk_drv_cipher_calc_hash_init(cipher_hash_data_s *cipher_hash_data)
+{
+    return GK_SUCCESS;
+}
+
+gk_s32 gk_drv_cipher_calc_hash_update(cipher_hash_data_s *cipher_hash_data)
+{
+    gk_s32 ret;
+    spacc_ctrl_en spacc_ctrl;
+    spacc_digest_chn_s *channel = GK_NULL;
+
+    intf_param_invalid_return(cipher_hash_data->hard_chn >= SPACC_MAX_CHN);
+    channel = &g_digest_chn[cipher_hash_data->hard_chn];
+
+    /* configure hash register */
+    ret = drv_digest_config(cipher_hash_data, &spacc_ctrl);
+    if (ret != GK_SUCCESS) {
+        gk_err_cipher("cipher config failed, ret = 0x%x.\n", ret);
+        return GK_FAILURE;
+    }
+
+    /* Add the phy of data to nodes list */
+    ret = spacc_digest_addbuf(cipher_hash_data->hard_chn, make_ulong(cipher_hash_data->data_phy,
+        cipher_hash_data->data_phy_high), cipher_hash_data->data_len, spacc_ctrl);
+    if (ret != GK_SUCCESS) {
+        gk_err_cipher("spacc add in buf failed, ret = 0x%x.\n", ret);
+        return GK_FAILURE;
+    }
+
+    channel->data_size = cipher_hash_data->data_len;
+    channel->digest_done = GK_FALSE;
+
+    /* Start working */
+    ret = spacc_digest_start(cipher_hash_data->hard_chn, spacc_ctrl, cipher_hash_data->sha_val);
+    if (ret != GK_SUCCESS) {
+        gk_err_cipher("spacc add in buf failed, ret = 0x%x.\n", ret);
+        return GK_FAILURE;
+    }
+
+    /* Waiting hardware computing finished */
+    ret = drv_cipher_digest_wait_done(channel);
+    if (ret == GK_SUCCESS) /* Read hash result */
+        spacc_digest_get(cipher_hash_data->hard_chn, cipher_hash_data->sha_val);
+
+    return ret;
+}
+
+gk_s32 gk_drv_cipher_calc_hash_final(cipher_hash_data_s *cipher_hash_data)
+{
+    return gk_drv_cipher_calc_hash_update(cipher_hash_data);
+}
+
+gk_s32 gk_drv_cipher_get_handle_config_ex(cipher_config_ctrl_ex_s *config_ctrl)
+{
+    spacc_symc_chn_s *channel = GK_NULL;
+    gk_u32 soft_chn_id;
+    gk_s32 ret;
+
+    if (config_ctrl == GK_NULL) {
+        gk_err_cipher("Invalid params!\n");
+        return GK_ERR_CIPHER_INVALID_POINT;
+    }
+
+    if (cipher_mutex_lock(&g_symc_mutex)) {
+        gk_err_cipher("cipher_mutex_lock failed!\n");
+        return GK_FAILURE;
+    }
+
+    ret = spacc_check_handle(config_ctrl->ci_handle);
+    if (ret != GK_SUCCESS)
+        return ret;
+    soft_chn_id = handle_get_chn_id(config_ctrl->ci_handle);
+    channel = &g_symc_chn[soft_chn_id];
+
+    crypto_memcpy(config_ctrl, sizeof(cipher_config_ctrl_ex_s), &channel->ctrl_ex, sizeof(channel->ctrl_ex));
+    cipher_mutex_unlock(&g_symc_mutex);
+
+    return ret;
+}
+
+gk_s32 gk_drv_cipher_get_iv(gk_u32 chn_id, gk_u32 iv[4]) /* 4 iv arr size */
+{
+    return spacc_symc_getiv(chn_id, iv, 16); /* 16 iv size */
+}
+
+#ifdef CIPHER_KLAD_SUPPORT
+gk_s32 gk_drv_cipher_klad_encrypt_key(cipher_klad_key_s *klad_key)
+{
+    gk_s32 ret;
+
+    if (klad_key == GK_NULL) {
+        gk_err_cipher("Invalid params!\n");
+        return GK_FAILURE;
+    }
+
+    if (cipher_mutex_lock(&g_symc_mutex)) {
+        gk_err_cipher("down_interruptible failed!\n");
+        return GK_FAILURE;
+    }
+
+    ret = drv_cipher_klad_encrypt_key(klad_key->root_key,
+        klad_key->klad_target, klad_key->clean_key, klad_key->encrypt_key);
+    if (ret != GK_SUCCESS) {
+        gk_err_cipher("KladEncryptKey failed!\n");
+        cipher_mutex_unlock(&g_symc_mutex);
+        return ret;
+    }
+
+    cipher_mutex_unlock(&g_symc_mutex);
+
+    return ret;
+}
+#endif
diff -uraN u-boot-2016.11/product/cipher/v2/drv/spacc/spacc_intf.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/spacc/spacc_intf.h
--- u-boot-2016.11/product/cipher/v2/drv/spacc/spacc_intf.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/spacc/spacc_intf.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,15 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef _SPACC_INTF_H_
+#define _SPACC_INTF_H_
+
+gk_s32 drv_cipher_init(gk_void);
+gk_void drv_cipher_deinit(gk_void);
+
+gk_s32 drv_rsa_init(gk_void);
+gk_void drv_rsa_deinit(gk_void);
+
+#endif
+
diff -uraN u-boot-2016.11/product/cipher/v2/drv/spacc/spacc_reg.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/spacc/spacc_reg.h
--- u-boot-2016.11/product/cipher/v2/drv/spacc/spacc_reg.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/spacc/spacc_reg.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef _SPACC_REG_H_
+#define _SPACC_REG_H_
+
+#define CHN_0_CIPHER_IV                             (g_spacc_reg_base + 0x0000)
+#define chn_n_cipher_iv_out(id)                     (g_spacc_reg_base + 0x0000 + (id) * 0x10)
+#define CHN_0_CIPHER_DOUT                           (g_spacc_reg_base + 0x0080)
+#define cipher_key(id)                              (g_spacc_reg_base + 0x0100 + (id) * 0x20)
+#define sm1_sk(id)                                  (g_spacc_reg_base + 0x0200 + (id) * 0x10)
+#define ODD_EVEN_KEY_SEL                            (g_spacc_reg_base + 0x0290)
+#define HDCP_MODE_CTRL                              (g_spacc_reg_base + 0x0300)
+#define SEC_CHN_CFG                                 (g_spacc_reg_base + 0x0304)
+#define CALC_ERR                                    (g_spacc_reg_base + 0x0320)
+#define CHN_0_CIPHER_CTRL                           (g_spacc_reg_base + 0x0400)
+#define CIPHER_INT_STATUS                           (g_spacc_reg_base + 0x0404)
+#define CIPHER_INT_EN                               (g_spacc_reg_base + 0x0408)
+#define CIPHER_INT_RAW                              (g_spacc_reg_base + 0x040c)
+#define CIPHER_IN_SMMU_EN                           (g_spacc_reg_base + 0x0410)
+#define OUT_SMMU_EN                                 (g_spacc_reg_base + 0x0414)
+#define CHN_0_CIPHER_DIN                            (g_spacc_reg_base + 0x0420)
+#define NORM_SMMU_START_ADDR                        (g_spacc_reg_base + 0x0440)
+#define SEC_SMMU_START_ADDR                         (g_spacc_reg_base + 0x0444)
+#define chn_n_cipher_ctrl(id)                       (g_spacc_reg_base + 0x0400 + (id) * 0x80)
+#define chn_n_cipher_in_node_cfg(id)                (g_spacc_reg_base + 0x0404 + (id) * 0x80)
+#define chn_n_cipher_in_node_start_addr(id)         (g_spacc_reg_base + 0x0408 + (id) * 0x80)
+#define chn_n_cipher_in_buf_rptr(id)                (g_spacc_reg_base + 0x040C + (id) * 0x80)
+#define chn_n_cipher_out_node_cfg(id)               (g_spacc_reg_base + 0x0430 + (id) * 0x80)
+#define chn_n_cipher_out_node_start_addr(id)        (g_spacc_reg_base + 0x0434 + (id) * 0x80)
+#define chn_n_cipher_out_buf_rptr(id)               (g_spacc_reg_base + 0x0438 + (id) * 0x80)
+#define chn_n_cipher_in_node_start_addr_high(id)    (g_spacc_reg_base + 0x0460 + (id) * 0x80)
+#define chn_n_cipher_out_node_start_addr_high(id)   (g_spacc_reg_base + 0x0470 + (id) * 0x80)
+
+#define CHN_0_HASH_CTRL                             (g_spacc_reg_base + 0x0800)
+#define HASH_INT_STATUS                             (g_spacc_reg_base + 0x0804)
+#define HASH_INT_EN                                 (g_spacc_reg_base + 0x0808)
+#define HASH_INT_RAW                                (g_spacc_reg_base + 0x080C)
+#define HASH_IN_SMMU_EN                             (g_spacc_reg_base + 0x0810)
+#define CHN_0_HASH_DAT_IN                           (g_spacc_reg_base + 0x0818)
+#define CHN_0_HASH_TOTAL_DAT_LEN                    (g_spacc_reg_base + 0x081C)
+#define chn_n_hash_ctrl(id)                         (g_spacc_reg_base + 0x0800 + (id) * 0x80)
+#define chn_n_hash_in_node_cfg(id)                  (g_spacc_reg_base + 0x0804 + (id) * 0x80)
+#define chn_n_hash_in_node_start_addr(id)           (g_spacc_reg_base + 0x0808 + (id) * 0x80)
+#define chn_n_hash_in_buf_rptr(id)                  (g_spacc_reg_base + 0x080C + (id) * 0x80)
+#define chn_n_hash_state_val(id)                    (g_spacc_reg_base + 0x0340 + (id) * 0x08)
+#define chn_n_hash_state_val_addr(id)               (g_spacc_reg_base + 0x0344 + (id) * 0x08)
+#define chn_n_hash_in_node_start_addr_high(id)      (g_spacc_reg_base + 0x820  + (id) * 0x80)
+
+#define spacc_read(addr)        *(volatile unsigned int *)(addr)
+#define spacc_write(addr, val)  *(volatile unsigned int *)(addr) = (val)
+
+#endif
+
diff -uraN u-boot-2016.11/product/cipher/v2/drv/spacc/spacc_union_define.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/spacc/spacc_union_define.h
--- u-boot-2016.11/product/cipher/v2/drv/spacc/spacc_union_define.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/cipher/v2/drv/spacc/spacc_union_define.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,443 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __SPACC_UNION_DEFINE_H__
+#define __SPACC_UNION_DEFINE_H__
+
+/* Define the union u_hdcp_mode_ctrl */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int hdcp_mode_en          : 1   ; /* [0]  */
+        unsigned int hdcp_rootkey_sel      : 2   ; /* [2..1]  */
+        unsigned int reserved_0            : 1   ; /* [3]  */
+        unsigned int hdmi_tx_hdcp14_wr_en  : 1   ; /* [4]  */
+        unsigned int hdmi_rx_hdcp14_wr_en  : 1   ; /* [5]  */
+        unsigned int hdmi_rx_hdcp22_wr_en  : 1   ; /* [6]  */
+        unsigned int reserved_1            : 1   ; /* [7]  */
+        unsigned int hdcp_wr_sel           : 2   ; /* [9..8]  */
+        unsigned int reserved_2            : 22  ; /* [31..10]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_hdcp_mode_ctrl;
+
+/* Define the union u_sec_chn_cfg */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int cipher_sec_chn_cfg      : 8   ; /* [7..0]  */
+        unsigned int cipher_sec_chn_cfg_lock : 1   ; /* [8]  */
+        unsigned int reserved_0              : 7   ; /* [15..9]  */
+        unsigned int hash_sec_chn_cfg        : 8   ; /* [23..16]  */
+        unsigned int hash_sec_chn_cfg_lock   : 1   ; /* [24]  */
+        unsigned int reserved_1              : 7   ; /* [31..25]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_sec_chn_cfg;
+
+/* Define the union u_mem_ema_cfg */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int rfs_ema               : 3   ; /* [2..0]  */
+        unsigned int reserved_0            : 1   ; /* [3]  */
+        unsigned int rfs_emaw              : 2   ; /* [5..4]  */
+        unsigned int reserved_1            : 2   ; /* [7..6]  */
+        unsigned int rft_emaa              : 3   ; /* [10..8]  */
+        unsigned int rft_emab              : 3   ; /* [13..11]  */
+        unsigned int rft_emasa             : 1   ; /* [14]  */
+        unsigned int rft_colldisn          : 1   ; /* [15]  */
+        unsigned int reserved_2            : 16  ; /* [31..16]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_mem_ema_cfg;
+
+/* Define the union u_key_st */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int key_req_cur_st        : 2   ; /* [1..0]  */
+        unsigned int reserved_0            : 30  ; /* [31..2]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_key_st;
+
+/* Define the union u_calc_st0 */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int cipher_calc_cur_st    : 4   ; /* [3..0]  */
+        unsigned int reserved_0            : 4   ; /* [7..4]  */
+        unsigned int hash_calc_cur_st      : 4   ; /* [11..8]  */
+        unsigned int hdcp_key_ksv_crc4     : 4   ; /* [15..12]  */
+        unsigned int reserved_1            : 16  ; /* [31..16]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_calc_st0;
+
+/* Define the union u_calc_err */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int klad_key_use_err      : 1   ; /* [0]  */
+        unsigned int alg_len_err           : 1   ; /* [1]  */
+        unsigned int smmu_page_unvlid      : 1   ; /* [2]  */
+        unsigned int reserved_0            : 29  ; /* [31..3]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_calc_err;
+
+/* Define the union u_chann_hash_state_val_addr */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int hash_state_val_addr   : 4   ; /* [3..0]  */
+        unsigned int reserved_0            : 28  ; /* [31..4]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_chann_hash_state_val_addr;
+
+/* Define the union u_chan0_cipher_ctrl */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int sym_ch0_start              : 1   ; /* [0]  */
+        unsigned int sym_ch0_alg_mode           : 3   ; /* [3..1]  */
+        unsigned int sym_ch0_alg_sel            : 3   ; /* [6..4]  */
+        unsigned int sym_ch0_decrypt            : 1   ; /* [7]  */
+        unsigned int sym_ch0_dat_width          : 2   ; /* [9..8]  */
+        unsigned int sym_ch0_key_length         : 2   ; /* [11..10]  */
+        unsigned int sym_ch0_ccm_gcm_input_flag : 2   ; /* [13..12]  */
+        unsigned int sym_ch0_key_sel            : 1   ; /* [14]  */
+        unsigned int sym_ch0_ivin_sel           : 1   ; /* [15]  */
+        unsigned int reserved_0                 : 2   ; /* [17..16]  */
+        unsigned int sym_ch0_sm1_round_num      : 2   ; /* [19..18]  */
+        unsigned int sym_ch0_gcm_iv_len         : 4   ; /* [23..20]  */
+        unsigned int sym_ch0_ccm_gcm_pc_last    : 1   ; /* [24]  */
+        unsigned int sym_ccm_gcm_last_block     : 4   ; /* [28..25]  */
+        unsigned int reserved_1                 : 3   ; /* [31..28]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_chan0_cipher_ctrl;
+
+/* Define the union u_cipher_int_status */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int reserved_0            : 1   ; /* [0]  */
+        unsigned int cipher_chn_ibuf_int   : 7   ; /* [7..1]  */
+        unsigned int cipher_chn_obuf_int   : 8   ; /* [15..8]  */
+        unsigned int reserved_1            : 16  ; /* [31..16]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_cipher_int_status;
+
+/* Define the union u_cipher_int_en */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int reserved_0            : 1   ; /* [0]  */
+        unsigned int cipher_chn_ibuf_en    : 7   ; /* [7..1]  */
+        unsigned int cipher_chn_obuf_en    : 8   ; /* [15..8]  */
+        unsigned int reserved_1            : 14  ; /* [29..16]  */
+        unsigned int cipher_sec_int_en     : 1   ; /* [30]  */
+        unsigned int cipher_nsec_int_en    : 1   ; /* [31]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_cipher_int_en;
+
+/* Define the union u_cipher_int_raw */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int reserved_0            : 1   ; /* [0]  */
+        unsigned int cipher_chn_ibuf_raw   : 7   ; /* [7..1]  */
+        unsigned int cipher_chn_obuf_raw   : 8   ; /* [15..8]  */
+        unsigned int reserved_1            : 16  ; /* [31..16]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_cipher_int_raw;
+
+/* Define the union u_cipher_in_smmu_en */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int cipher_in_chan_rd_dat_smmu_en  : 7   ; /* [6..0]  */
+        unsigned int reserved_0                     : 9   ; /* [15..7]  */
+        unsigned int cipher_in_chan_rd_node_smmu_en : 7   ; /* [22..16]  */
+        unsigned int reserved_1                     : 9   ; /* [31..23]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_cipher_in_smmu_en;
+
+/* Define the union u_out_smmu_en */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int out_chan_wr_dat_smmu_en    : 7   ; /* [6..0]  */
+        unsigned int reserved_0                 : 9   ; /* [15..7]  */
+        unsigned int out_chan_rd_node_smmu_en   : 7   ; /* [22..16]  */
+        unsigned int reserved_1                 : 9   ; /* [31..23]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_out_smmu_en;
+
+/* Define the union u_in_st */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int hash_in_ctrl_cur_st   : 5   ; /* [4..0]  */
+        unsigned int sym_in_ctrl_cur_st    : 3   ; /* [7..5]  */
+        unsigned int sym_hash_req_cur_st   : 4   ; /* [11..8]  */
+        unsigned int reserved_0            : 20  ; /* [31..12]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_in_st;
+
+/* Define the union u_out_st */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int out_cur_st            : 5   ; /* [4..0]  */
+        unsigned int reserved_0            : 27  ; /* [31..5]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_out_st;
+
+/* Define the union u_chann_cipher_ctrl */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int reserved_0                 : 1   ; /* [0]  */
+        unsigned int sym_chn_alg_mode           : 3   ; /* [3..1]  */
+        unsigned int sym_chn_alg_sel            : 3   ; /* [6..4]  */
+        unsigned int sym_chn_decrypt            : 1   ; /* [7]  */
+        unsigned int sym_chn_dat_width          : 2   ; /* [9..8]  */
+        unsigned int sym_chn_key_length         : 2   ; /* [11..10]  */
+        unsigned int reserved_1                 : 2   ; /* [13..12]  */
+        unsigned int sym_chn_key_sel            : 1   ; /* [14]  */
+        unsigned int reserved_2                 : 1   ; /* [15]  */
+        unsigned int sym_chn_dout_byte_swap_en  : 1   ; /* [16]  */
+        unsigned int sym_chn_din_byte_swap_en   : 1   ; /* [17]  */
+        unsigned int sym_chn_sm1_round_num      : 2   ; /* [19..18]  */
+        unsigned int reserved_3                 : 2   ; /* [21..20]  */
+        unsigned int weight                     : 10  ; /* [31..22]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_chann_cipher_ctrl;
+
+/* Define the union u_chann_cipher_in_node_cfg */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int cipher_in_node_mpackage_int_level  : 7   ; /* [6..0]  */
+        unsigned int reserved_0                         : 1   ; /* [7]  */
+        unsigned int cipher_in_node_rptr                : 7   ; /* [14..8]  */
+        unsigned int reserved_1                         : 1   ; /* [15]  */
+        unsigned int cipher_in_node_wptr                : 7   ; /* [22..16]  */
+        unsigned int reserved_2                         : 1   ; /* [23]  */
+        unsigned int cipher_in_node_total_num           : 7   ; /* [30..24]  */
+        unsigned int reserved_3                         : 1   ; /* [31]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_chann_cipher_in_node_cfg;
+
+/* Define the union u_chann_cipher_in_left_byte */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int in_left_byte0         : 24  ; /* [23..0]  */
+        unsigned int in_byte_cnt           : 2   ; /* [25..24]  */
+        unsigned int in_word_cnt           : 2   ; /* [27..26]  */
+        unsigned int reserved_0            : 4   ; /* [31..28]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_chann_cipher_in_left_byte;
+
+/* Define the union u_chann_cipher_out_node_cfg */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int cipher_out_node_mpackage_int_level : 7   ; /* [6..0]  */
+        unsigned int reserved_0                         : 1   ; /* [7]  */
+        unsigned int cipher_out_node_rptr               : 7   ; /* [14..8]  */
+        unsigned int reserved_1                         : 1   ; /* [15]  */
+        unsigned int cipher_out_node_wptr               : 7   ; /* [22..16]  */
+        unsigned int reserved_2                         : 1   ; /* [23]  */
+        unsigned int cipher_out_node_total_num          : 7   ; /* [30..24]  */
+        unsigned int reserved_3                         : 1   ; /* [31]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_chann_cipher_out_node_cfg;
+
+/* Define the union u_chann_cipher_out_left_byte */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int out_left_byte0 : 24  ; /* [23..0]  */
+        unsigned int out_byte_cnt   : 2   ; /* [25..24]  */
+        unsigned int out_word_cnt   : 2   ; /* [27..26]  */
+        unsigned int reserved_0     : 4   ; /* [31..28]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_chann_cipher_out_left_byte;
+
+/* Define the union u_chan0_hash_ctrl */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int hash_ch0_start             : 1   ; /* [0]  */
+        unsigned int hash_ch0_agl_sel           : 3   ; /* [3..1]  */
+        unsigned int hash_ch0_hmac_calc_step    : 1   ; /* [4]  */
+        unsigned int hash_ch0_mode              : 1   ; /* [5]  */
+        unsigned int hash_ch0_key_sel           : 1   ; /* [6]  */
+        unsigned int reserved_0                 : 2   ; /* [8..7]  */
+        unsigned int hash_ch0_auto_padding_en   : 1   ; /* [9]  */
+        unsigned int hash_ch0_hmac_key_addr     : 3   ; /* [12..10]  */
+        unsigned int hash_ch0_used              : 1   ; /* [13]  */
+        unsigned int hash_ch0_sec_alarm         : 1   ; /* [13]  */
+        unsigned int reserved_1                 : 17  ; /* [31..15]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_chan0_hash_ctrl;
+
+/* Define the union u_hash_int_status */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int reserved_0         : 18  ; /* [17..0]  */
+        unsigned int hash_ch0_oram_int  : 1   ; /* [18]  */
+        unsigned int hash_ch1_oram_int  : 1   ; /* [19]  */
+        unsigned int hash_ch2_oram_int  : 1   ; /* [20]  */
+        unsigned int hash_ch3_oram_int  : 1   ; /* [21]  */
+        unsigned int hash_ch4_oram_int  : 1   ; /* [22]  */
+        unsigned int hash_ch5_oram_int  : 1   ; /* [23]  */
+        unsigned int hash_ch6_oram_int  : 1   ; /* [24]  */
+        unsigned int hash_ch7_oram_int  : 1   ; /* [25]  */
+        unsigned int reserved_1         : 6   ; /* [31..26]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_hash_int_status;
+
+/* Define the union u_hash_int_en */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int reserved_0         : 18  ; /* [17..0]  */
+        unsigned int hash_chn_oram_en   : 8   ; /* [25..18]  */
+        unsigned int reserved_1         : 4   ; /* [29..26]  */
+        unsigned int hash_sec_int_en    : 1   ; /* [30]  */
+        unsigned int hash_int_en        : 1   ; /* [31]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_hash_int_en;
+
+/* Define the union u_hash_int_raw */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int reserved_0         : 18  ; /* [17..0]  */
+        unsigned int hash_chn_oram_raw  : 8   ; /* [25..18]  */
+        unsigned int reserved_1         : 6   ; /* [31..26]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_hash_int_raw;
+
+/* Define the union u_hash_in_smmu_en */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int hash_in_chan_rd_dat_smmu_en    : 7   ; /* [6..0]  */
+        unsigned int reserved_0                     : 9   ; /* [15..7]  */
+        unsigned int hash_in_chan_rd_node_smmu_en   : 7   ; /* [22..16]  */
+        unsigned int reserved_1                     : 9   ; /* [31..23]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_hash_in_smmu_en;
+
+/* Define the union u_chann_hash_ctrl */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int reserved_0                     : 1   ; /* [0]  */
+        unsigned int hash_chn_agl_sel               : 3   ; /* [3..1]  */
+        unsigned int reserved_1                     : 1   ; /* [4]  */
+        unsigned int hash_chn_mode                  : 1   ; /* [5]  */
+        unsigned int hash_chn_key_sel               : 1   ; /* [6]  */
+        unsigned int hash_chn_dat_in_byte_swap_en   : 1   ; /* [7]  */
+        unsigned int hash_chn_dat_in_bit_swap_en    : 1   ; /* [8]  */
+        unsigned int hash_chn_auto_padding_en       : 1   ; /* [9]  */
+        unsigned int hash_chn_hmac_key_addr         : 3   ; /* [12..10]  */
+        unsigned int reserved_2                     : 19  ; /* [31..13]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_chann_hash_ctrl;
+
+/* Define the union u_chann_hash_in_node_cfg */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int hash_in_node_mpackage_int_level    : 8   ; /* [7..0]  */
+        unsigned int hash_in_node_rptr                  : 8   ; /* [15..8]  */
+        unsigned int hash_in_node_wptr                  : 8   ; /* [23..16]  */
+        unsigned int hash_in_node_total_num             : 8   ; /* [31..24]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_chann_hash_in_node_cfg;
+
+#endif /* __C_UNION_DEFINE_H__ */
diff -uraN u-boot-2016.11/product/i2c/i2c.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/i2c/i2c.c
--- u-boot-2016.11/product/i2c/i2c.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/i2c/i2c.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,731 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/io.h>
+#include <linux/errno.h>
+
+struct i2c_init_desc {
+	unsigned long ctrl_base;
+	unsigned char flag;
+};
+
+#define I2C_INIT_UNDO   0
+#define I2C_INIT_DONE   1
+#define i2c_desc(reg)   {.ctrl_base = (reg), \
+			.flag = I2C_INIT_UNDO}
+
+#define I2C_BUS_CLOCK   mhz(50)
+#define I2C_MAX_NUM 0
+struct i2c_init_desc gk_i2c_init_desc[] = NULL;
+
+/*
+ * I2C Registers offsets
+ */
+#define VENDOR_I2C_GLB       0x0
+#define VENDOR_I2C_SCL_H     0x4
+#define VENDOR_I2C_SCL_L     0x8
+#define VENDOR_I2C_DATA1     0x10
+#define VENDOR_I2C_TXF       0x20
+#define VENDOR_I2C_RXF       0x24
+#define VENDOR_I2C_CMD_BASE  0x30
+#define VENDOR_I2C_LOOP1     0xb0
+#define VENDOR_I2C_DST1      0xb4
+#define VENDOR_I2C_TX_WATER  0xc8
+#define VENDOR_I2C_RX_WATER  0xcc
+#define VENDOR_I2C_CTRL1     0xd0
+#define VENDOR_I2C_CTRL2     0xd4
+#define VENDOR_I2C_STAT      0xd8
+#define VENDOR_I2C_INTR_RAW  0xe0
+#define VENDOR_I2C_INTR_EN   0xe4
+#define VENDOR_I2C_INTR_STAT 0xe8
+
+/*
+ * Create a contiguous bitmask starting at bit position @l and ending at
+ * position @h.
+ */
+#define genmask(h, l) \
+	(((~0UL) << (l)) & (~0UL >> (BITS_PER_LONG - 1 - (h))))
+
+/*
+ * I2C Global Config Register -- VENDOR_I2C_GLB
+ */
+#define GLB_EN_MASK     BIT(0)
+#define GLB_SDA_HOLD_MASK   genmask(23, 8)
+#define GLB_SDA_HOLD_SHIFT  8
+
+/*
+ * I2C Timing CMD Register -- VENDOR_I2C_CMD_BASE + n * 4 (n = 0, 1, 2, ... 31)
+ */
+#define CMD_EXIT    0x0
+#define CMD_TX_S    0x1
+#define CMD_TX_D1_2 0x4
+#define CMD_TX_D1_1 0x5
+#define CMD_TX_FIFO 0x9
+#define CMD_RX_FIFO 0x12
+#define CMD_RX_ACK  0x13
+#define CMD_IGN_ACK 0x15
+#define CMD_TX_ACK  0x16
+#define CMD_TX_NACK 0x17
+#define CMD_JMP1    0x18
+#define CMD_UP_TXF  0x1d
+#define CMD_TX_RS   0x1e
+#define CMD_TX_P    0x1f
+
+/*
+ * I2C Control Register 1 -- VENDOR_I2C_CTRL1
+ */
+#define CTRL1_CMD_START_MASK    BIT(0)
+
+/*
+ * I2C Status Register -- VENDOR_I2C_STAT
+ */
+#define STAT_RXF_NOE_MASK   BIT(16) /* RX FIFO not empty flag */
+#define STAT_TXF_NOF_MASK   BIT(19) /* TX FIFO not full flag */
+
+
+/*
+ * I2C Interrupt status and mask Register --
+ * VENDOR_I2C_INTR_RAW, VENDOR_I2C_STAT, VENDOR_I2C_INTR_STAT
+ */
+#define INTR_ABORT_MASK     (BIT(0) | BIT(11))
+#define INTR_RX_MASK        BIT(2)
+#define INTR_TX_MASK        BIT(4)
+#define INTR_CMD_DONE_MASK  BIT(12)
+#define INTR_USE_MASK       (INTR_ABORT_MASK | \
+				INTR_RX_MASK | \
+				INTR_TX_MASK | \
+				INTR_CMD_DONE_MASK)
+#define INTR_ALL_MASK       genmask(31, 0)
+
+#define I2C_DEFAULT_FREQUENCY   100000
+#define I2C_TXF_DEPTH       64
+#define I2C_RXF_DEPTH       64
+#define I2C_TXF_WATER       32
+#define I2C_RXF_WATER       32
+#define I2C_WAIT_TIMEOUT    0x400
+#define I2C_IRQ_TIMEOUT     (msecs_to_jiffies(1000))
+#define khz(clk)    ((clk) * 1000)
+#define mhz(clk)    ((clk) * 1000000)
+#define MAX_SPEED   khz(400)
+unsigned int g_i2c_speed = I2C_DEFAULT_FREQUENCY;
+int g_i2c_num = -1;
+
+struct gk_i2c_msg {
+	__u16 chip;     /* slave address */
+	__u16 addr;     /* reg address */
+	__u16 alen;     /* reg width,1 or 2 */
+	__u16 flags;
+	__u16 len;      /* msg length,1 or 2 */
+	__u8 *buf;      /* pointer to msg data */
+#define I2C_M_RD        0x0001  /* read data, from slave to master */
+#define I2C_M_IGNORE_NAK    0x1000  /* if I2C_FUNC_PROTOCOL_MANGLING */
+#define I2C_M_TEN       0x0010  /* this is a ten bit chip address */
+#define I2C_M_STOP      0x8000  /* if I2C_FUNC_PROTOCOL_MANGLING */
+};
+
+struct gk_i2c_dev {
+	struct device       *dev;
+	void *base;
+	unsigned int        clk;
+	unsigned int        freq;
+	struct gk_i2c_msg        *msg;
+	unsigned int        msg_num;
+	unsigned int        msg_idx;
+	unsigned int        msg_buf_ptr;
+
+	int         status;
+};
+struct gk_i2c_dev i2c_dev;
+static inline void gk_i2c_disable(struct gk_i2c_dev *i2c);
+static inline void gk_i2c_cfg_irq(struct gk_i2c_dev *i2c, unsigned int flag);
+static inline unsigned int gk_i2c_clr_irq(struct gk_i2c_dev *i2c);
+static inline void gk_i2c_enable(struct gk_i2c_dev *i2c);
+#define CHECK_SDA_IN_SHIFT     16
+#define GPIO_MODE_SHIFT        8
+#define FORCE_SCL_OEN_SHIFT    4
+#define FORCE_SDA_OEN_SHIFT    0
+
+static void gk_i2c_rescue(struct gk_i2c_dev *i2c)
+{
+	unsigned int val;
+	unsigned int time_cnt;
+	int index;
+
+	gk_i2c_disable(i2c);
+	gk_i2c_cfg_irq(i2c, 0);
+	gk_i2c_clr_irq(i2c);
+
+	val = (0x1 << GPIO_MODE_SHIFT) | (0x1 << FORCE_SCL_OEN_SHIFT) |
+		  (0x1 << FORCE_SDA_OEN_SHIFT);
+	writel(val, i2c->base + VENDOR_I2C_CTRL2);
+
+	time_cnt = 0;
+	do {
+		for (index = 0; index < 9; index++) { /* 9: Cycle */
+			val = (0x1 << GPIO_MODE_SHIFT) | 0x1;
+			writel(val, i2c->base + VENDOR_I2C_CTRL2);
+
+			udelay(5); /* delay 5us */
+
+			val = (0x1 << GPIO_MODE_SHIFT) | (0x1 << FORCE_SCL_OEN_SHIFT) |
+				  (0x1 << FORCE_SDA_OEN_SHIFT);
+			writel(val, i2c->base + VENDOR_I2C_CTRL2);
+
+			udelay(5); /* delay 5us */
+		}
+
+		time_cnt++;
+		if (time_cnt > I2C_WAIT_TIMEOUT) {
+			printf("wait Timeout!\n");
+			goto disable_rescue;
+		}
+
+		val = readl(i2c->base + VENDOR_I2C_CTRL2);
+	} while (!(val & (0x1 << CHECK_SDA_IN_SHIFT)));
+
+	val = (0x1 << GPIO_MODE_SHIFT) | (0x1 << FORCE_SCL_OEN_SHIFT) |
+		  (0x1 << FORCE_SDA_OEN_SHIFT);
+	writel(val, i2c->base + VENDOR_I2C_CTRL2);
+
+	val = (0x1 << GPIO_MODE_SHIFT) | (0x1 << FORCE_SCL_OEN_SHIFT);
+	writel(val, i2c->base + VENDOR_I2C_CTRL2);
+
+	udelay(10); /* delay 10us */
+
+	val = (0x1 << GPIO_MODE_SHIFT) | (0x1 << FORCE_SCL_OEN_SHIFT) |
+		  (0x1 << FORCE_SDA_OEN_SHIFT);
+	writel(val, i2c->base + VENDOR_I2C_CTRL2);
+
+disable_rescue:
+	val = (0x1 << FORCE_SCL_OEN_SHIFT) | 0x1;
+	writel(val, i2c->base + VENDOR_I2C_CTRL2);
+}
+
+static void gk_i2c_disable(struct gk_i2c_dev *i2c)
+{
+	unsigned int val;
+
+	val = readl(i2c->base + VENDOR_I2C_GLB);
+	val &= ~GLB_EN_MASK;
+	writel(val, i2c->base + VENDOR_I2C_GLB);
+}
+
+static void gk_i2c_enable(struct gk_i2c_dev *i2c)
+{
+	unsigned int val;
+
+	val = readl(i2c->base + VENDOR_I2C_GLB);
+	val |= GLB_EN_MASK;
+	writel(val, i2c->base + VENDOR_I2C_GLB);
+}
+
+static inline void gk_i2c_cfg_irq(struct gk_i2c_dev *i2c,
+					unsigned int flag)
+{
+	writel(flag, i2c->base + VENDOR_I2C_INTR_EN);
+}
+
+static void gk_i2c_disable_irq(struct gk_i2c_dev *i2c,
+						unsigned int flag)
+{
+	unsigned int val;
+
+	val = readl(i2c->base + VENDOR_I2C_INTR_EN);
+	val &= ~flag;
+	writel(val, i2c->base + VENDOR_I2C_INTR_EN);
+}
+
+static unsigned int gk_i2c_clr_irq(struct gk_i2c_dev *i2c)
+{
+	unsigned int val;
+
+	val = readl(i2c->base + VENDOR_I2C_INTR_STAT);
+	writel(INTR_ALL_MASK, i2c->base + VENDOR_I2C_INTR_RAW);
+
+	return val;
+}
+
+static inline void gk_i2c_cmdreg_set(struct gk_i2c_dev *i2c,
+					unsigned int cmd, unsigned int *offset)
+{
+	/* the I2C_TIMING_CMD reg offset is (*offset * 4) */
+	writel(cmd, i2c->base + VENDOR_I2C_CMD_BASE + *offset * 4);
+	(*offset)++;
+}
+
+/*
+ * config i2c slave addr
+ */
+static void gk_i2c_set_addr(struct gk_i2c_dev *i2c)
+{
+	struct gk_i2c_msg *msg = i2c->msg;
+	u16 addr;
+
+	if (msg->flags & I2C_M_TEN) {
+		/* First byte is 11110XX0 where XX is upper 2 bits */
+		addr = ((msg->addr & 0x300) << 1) | 0xf000;
+		if (msg->flags & I2C_M_RD)
+			addr |= 1 << 8; /* Move Left 8bit */
+
+		/* Second byte is the remaining 8 bits */
+		addr |= msg->addr & 0xff;
+	} else {
+		addr = (msg->addr & 0x7f) << 1;
+		if (msg->flags & I2C_M_RD)
+			addr |= 1;
+	}
+
+	writel(addr, i2c->base + VENDOR_I2C_DATA1);
+}
+
+/*
+ * Start command sequence
+ */
+static void gk_i2c_init_descart_cmd(struct gk_i2c_dev *i2c)
+{
+	unsigned int val;
+
+	val = readl(i2c->base + VENDOR_I2C_CTRL1);
+	val |= CTRL1_CMD_START_MASK;
+	writel(val, i2c->base + VENDOR_I2C_CTRL1);
+}
+
+static int gk_i2c_wait_rx_noempty(struct gk_i2c_dev *i2c)
+{
+	unsigned int time_cnt = 0;
+	unsigned int val;
+
+	do {
+		val = readl(i2c->base + VENDOR_I2C_STAT);
+		if (val & STAT_RXF_NOE_MASK)
+			return 0;
+
+		udelay(50); /* delay 50us */
+	} while (time_cnt++ < I2C_WAIT_TIMEOUT);
+
+	gk_i2c_rescue(i2c);
+
+	printf("wait rx no empty timeout, RIS: 0x%x, SR: 0x%x\n",
+		   readl(i2c->base + VENDOR_I2C_INTR_RAW), val);
+	return -EIO;
+}
+
+static int gk_i2c_wait_tx_nofull(struct gk_i2c_dev *i2c)
+{
+	unsigned int time_cnt = 0;
+	unsigned int val;
+
+	do {
+		val = readl(i2c->base + VENDOR_I2C_STAT);
+		if (val & STAT_TXF_NOF_MASK)
+			return 0;
+
+		udelay(50); /* delay 50us */
+	} while (time_cnt++ < I2C_WAIT_TIMEOUT);
+
+	gk_i2c_rescue(i2c);
+
+	printf("wait tx no empty timeout, RIS: 0x%x, SR: 0x%x\n",
+		   readl(i2c->base + VENDOR_I2C_INTR_RAW), val);
+	return -EIO;
+}
+
+static int gk_i2c_wait_idle(struct gk_i2c_dev *i2c)
+{
+	unsigned int time_cnt = 0;
+	unsigned int val;
+
+	do {
+		val = readl(i2c->base + VENDOR_I2C_INTR_RAW);
+		if (val & (INTR_ABORT_MASK)) {
+			printf("wait idle abort!, RIS: 0x%x\n",
+				   val);
+			return -EIO;
+		}
+
+		if (val & INTR_CMD_DONE_MASK)
+			return 0;
+
+		udelay(50); /* delay 50us */
+	} while (time_cnt++ < I2C_WAIT_TIMEOUT);
+
+	gk_i2c_rescue(i2c);
+
+	printf("wait idle timeout, RIS: 0x%x, SR: 0x%x\n",
+		   val, readl(i2c->base + VENDOR_I2C_STAT));
+
+	return -EIO;
+}
+
+static void gk_i2c_set_freq(struct gk_i2c_dev *i2c)
+{
+	unsigned int max_freq, freq;
+	unsigned int clk_rate;
+	unsigned int val;
+
+	freq = i2c->freq;
+	clk_rate = i2c->clk;
+	max_freq = clk_rate >> 1;
+
+	if (freq > max_freq) {
+		i2c->freq = max_freq;
+		freq = i2c->freq;
+	}
+
+	if (!freq) {
+		printf("i2c_set_freq:freq can't be zero!");
+		return;
+	}
+
+	if (freq <= 100000) { /* 100000 : freq */
+		/* 1/2 of the SCL cycle in standard mode. */
+		val = clk_rate / (freq * 2);
+		writel(val, i2c->base + VENDOR_I2C_SCL_H);
+		writel(val, i2c->base + VENDOR_I2C_SCL_L);
+	} else {
+		/* 36/100 of the SCL cycle in fast mode. */
+		val = (clk_rate * 36) / (freq * 100);
+		writel(val, i2c->base + VENDOR_I2C_SCL_H);
+		/* 64/100  of the SCL cycle in fast mode. */
+		val = (clk_rate * 64) / (freq * 100);
+		writel(val, i2c->base + VENDOR_I2C_SCL_L);
+	}
+
+	val = readl(i2c->base + VENDOR_I2C_GLB);
+	val &= ~GLB_SDA_HOLD_MASK;
+	val |= ((0xa << GLB_SDA_HOLD_SHIFT) & GLB_SDA_HOLD_MASK);
+	writel(val, i2c->base + VENDOR_I2C_GLB);
+}
+
+/*
+ * set i2c controller TX and RX FIFO water
+ */
+static inline void gk_i2c_set_water(struct gk_i2c_dev *i2c)
+{
+	writel(I2C_TXF_WATER, i2c->base + VENDOR_I2C_TX_WATER);
+	writel(I2C_RXF_WATER, i2c->base + VENDOR_I2C_RX_WATER);
+}
+
+/*
+ * initialise the controller, set i2c bus interface freq
+ */
+static void gk_i2c_hw_init(struct gk_i2c_dev *i2c)
+{
+	gk_i2c_disable(i2c);
+	gk_i2c_disable_irq(i2c, INTR_ALL_MASK);
+	gk_i2c_set_freq(i2c);
+	gk_i2c_set_water(i2c);
+}
+
+/*
+ * gk_i2c_cfg_cmd - config i2c controller command sequence
+ *
+ * After all the timing command is configured,
+ * and then start the command, you can i2c communication,
+ * and then only need to read and write i2c fifo.
+ */
+static void gk_i2c_cfg_cmd(struct gk_i2c_dev *i2c)
+{
+	struct gk_i2c_msg *msg = i2c->msg;
+	unsigned int offset = 0;
+
+	if (i2c->msg_idx == 0)
+		gk_i2c_cmdreg_set(i2c, CMD_TX_S, &offset);
+	else
+		gk_i2c_cmdreg_set(i2c, CMD_TX_RS, &offset);
+
+	if (msg->flags & I2C_M_TEN) {
+		if (i2c->msg_idx == 0) {
+			gk_i2c_cmdreg_set(i2c, CMD_TX_D1_2, &offset);
+			gk_i2c_cmdreg_set(i2c, CMD_TX_D1_1, &offset);
+		} else {
+			gk_i2c_cmdreg_set(i2c, CMD_TX_D1_2, &offset);
+		}
+	} else {
+		gk_i2c_cmdreg_set(i2c, CMD_TX_D1_1, &offset);
+	}
+
+	if (msg->flags & I2C_M_IGNORE_NAK)
+		gk_i2c_cmdreg_set(i2c, CMD_IGN_ACK, &offset);
+	else
+		gk_i2c_cmdreg_set(i2c, CMD_RX_ACK, &offset);
+
+	if (msg->flags & I2C_M_RD) {
+		if (msg->len >= 2) { /* 2:len */
+			writel(offset, i2c->base + VENDOR_I2C_DST1);
+			writel(msg->len - 2, i2c->base + VENDOR_I2C_LOOP1); /* 2: len */
+			gk_i2c_cmdreg_set(i2c, CMD_RX_FIFO, &offset);
+			gk_i2c_cmdreg_set(i2c, CMD_TX_ACK, &offset);
+			gk_i2c_cmdreg_set(i2c, CMD_JMP1, &offset);
+		}
+		gk_i2c_cmdreg_set(i2c, CMD_RX_FIFO, &offset);
+		gk_i2c_cmdreg_set(i2c, CMD_TX_NACK, &offset);
+	} else {
+		writel(offset, i2c->base + VENDOR_I2C_DST1);
+		writel(msg->len - 1, i2c->base + VENDOR_I2C_LOOP1);
+		gk_i2c_cmdreg_set(i2c, CMD_UP_TXF, &offset);
+		gk_i2c_cmdreg_set(i2c, CMD_TX_FIFO, &offset);
+
+		if (msg->flags & I2C_M_IGNORE_NAK)
+			gk_i2c_cmdreg_set(i2c, CMD_IGN_ACK, &offset);
+		else
+			gk_i2c_cmdreg_set(i2c, CMD_RX_ACK, &offset);
+
+		gk_i2c_cmdreg_set(i2c, CMD_JMP1, &offset);
+	}
+
+	if ((i2c->msg_idx == (i2c->msg_num - 1)) || (msg->flags & I2C_M_STOP))
+		gk_i2c_cmdreg_set(i2c, CMD_TX_P, &offset);
+
+	gk_i2c_cmdreg_set(i2c, CMD_EXIT, &offset);
+}
+
+static int gk_i2c_polling_xfer_one_msg(struct gk_i2c_dev *i2c)
+{
+	int status;
+	unsigned int val;
+	struct gk_i2c_msg *msg = i2c->msg;
+
+	gk_i2c_enable(i2c);
+	gk_i2c_clr_irq(i2c);
+	gk_i2c_set_addr(i2c);
+	gk_i2c_cfg_cmd(i2c);
+	gk_i2c_init_descart_cmd(i2c);
+
+	i2c->msg_buf_ptr = 0;
+
+	if (msg->flags & I2C_M_RD) {
+		while (i2c->msg_buf_ptr < msg->len) {
+			status = gk_i2c_wait_rx_noempty(i2c);
+			if (status)
+				goto end;
+
+			val = readl(i2c->base + VENDOR_I2C_RXF);
+			msg->buf[i2c->msg_buf_ptr] = val;
+			i2c->msg_buf_ptr++;
+		}
+	} else {
+		while (i2c->msg_buf_ptr < msg->len) {
+			status = gk_i2c_wait_tx_nofull(i2c);
+			if (status)
+				goto end;
+
+			val = msg->buf[i2c->msg_buf_ptr];
+			writel(val, i2c->base + VENDOR_I2C_TXF);
+			i2c->msg_buf_ptr++;
+		}
+	}
+
+	status = gk_i2c_wait_idle(i2c);
+end:
+	gk_i2c_disable(i2c);
+
+	return status;
+}
+
+/*
+ * Master transfer function
+ */
+static int gk_i2c_xfer(struct gk_i2c_msg *msgs, int num)
+{
+	struct gk_i2c_dev *i2c = &i2c_dev;
+	int status = -EINVAL;
+
+	if (!msgs || (num <= 0)) {
+		printf("msgs == NULL || num <= 0, Invalid argument!\n");
+		return -EINVAL;
+	}
+
+	i2c->msg = msgs;
+	i2c->msg_num = num;
+	i2c->msg_idx = 0;
+
+	while (i2c->msg_idx < i2c->msg_num) {
+		status = gk_i2c_polling_xfer_one_msg(i2c);
+		if (status)
+			break;
+		i2c->msg++;
+		i2c->msg_idx++;
+	}
+
+	if (!status || i2c->msg_idx > 0)
+		status = i2c->msg_idx;
+
+	return status;
+}
+
+void i2c_init(int speed, int i2c_num)
+{
+	if (i2c_num < 0 || i2c_num >= I2C_MAX_NUM) {
+		printf("Cannot found I2C[%d]!\n", i2c_num);
+		return;
+	}
+
+	if (gk_i2c_init_desc[i2c_num].flag == I2C_INIT_UNDO) {
+		struct gk_i2c_dev *i2c = &i2c_dev;
+
+		i2c->base = (void *)(gk_i2c_init_desc[i2c_num].ctrl_base);
+		i2c->clk = I2C_BUS_CLOCK;
+		if (speed <= 0 || speed > MAX_SPEED) {
+			printf("Error speed out of range:[0, %d]!\n", MAX_SPEED);
+		} else {
+			i2c->freq = speed;
+			g_i2c_speed = i2c->freq;
+		}
+		gk_i2c_hw_init(i2c);
+		gk_i2c_init_desc[i2c_num].flag = I2C_INIT_DONE;
+		g_i2c_num = i2c_num;
+		printf("I2C[%d] init OK!\n", i2c_num);
+	} else {
+		printf("I2C[%d] had init!\n", i2c_num);
+		return;
+	}
+}
+
+int i2c_probe(unsigned char i2c_num)
+{
+	printf("init i2c [%d],speed:[%u]\n", i2c_num, g_i2c_speed);
+	i2c_init(g_i2c_speed, i2c_num);
+	return 0;
+}
+
+unsigned int i2c_set_bus_speed(unsigned int speed)
+{
+	if (g_i2c_num < 0) {
+		printf("please i2c probe [num] first!");
+		return 1;
+	}
+
+	if (g_i2c_speed != speed) {
+		g_i2c_speed = speed;
+		gk_i2c_init_desc[g_i2c_num].flag = I2C_INIT_UNDO;
+		printf("Set the i2c speed to %u\n", g_i2c_speed);
+		i2c_init(g_i2c_speed, g_i2c_num);
+	} else {
+		printf("The i2c speed has not changed!speed:%u\n", g_i2c_speed);
+	}
+	return 0;
+}
+
+unsigned int i2c_get_bus_speed(void)
+{
+	return g_i2c_speed;
+}
+
+unsigned int i2c_set_bus_num(int bus_no)
+{
+	struct gk_i2c_dev *i2c = &i2c_dev;
+
+	if (bus_no < 0 || bus_no >= I2C_MAX_NUM) {
+		printf("Error! out of range:[0, %d]!\n", I2C_MAX_NUM);
+		return 0;
+	}
+	if (gk_i2c_init_desc[bus_no].flag == I2C_INIT_UNDO) {
+		i2c_init(g_i2c_speed, bus_no);
+	} else {
+		g_i2c_num = bus_no;
+		i2c->base = (void *)(gk_i2c_init_desc[g_i2c_num].ctrl_base);
+	}
+	return 0;
+}
+
+unsigned int i2c_get_bus_num(void)
+{
+	if (g_i2c_num < 0)
+		printf("Please set the I2C device number!\n");
+
+	return g_i2c_num;
+}
+
+int i2c_read(unsigned char chip, uint addr, int alen, unsigned char *buffer,
+			 int len)
+{
+	struct gk_i2c_dev;
+	struct gk_i2c_msg msg[2]; /* 2 bit array */
+	int num = (__u32)2;
+	int len_idx = 1;
+	unsigned int cur_addr;
+	int ret;
+	unsigned char buf[4]; /* 4 bit array */
+
+	memset(buf, 0x0, 4); /* memset the ength is 4 array. */
+	msg[0].addr = (chip >> 1);
+	msg[0].len = alen;
+	msg[0].buf = buf;
+	msg[0].flags = 0;
+
+	msg[1].addr = (chip >> 1);
+	msg[1].len = len;
+	msg[1].buf = buf;
+	msg[1].flags = 0;
+	msg[1].flags |= I2C_M_RD;
+
+	for (cur_addr = addr; len_idx <= len; cur_addr += 1) {
+		if (alen == 2) { /* 2:len */
+			buf[0] = (cur_addr >> 8) & 0xff; /* Move Right 8bit */
+			buf[1] = cur_addr & 0xff;
+		} else {
+			buf[0] = cur_addr & 0xff;
+		}
+
+		ret = gk_i2c_xfer(msg, num);
+		if (ret != 2) { /* 2: Return Value */
+			printf("i2c read: failed %d\n", ret);
+			return 0;
+		}
+
+		if (len == 2) /* 2:len */
+			*buffer = buf[0] | (buf[1] << 8); /* Move Left 8bit */
+		else
+			*buffer = buf[0];
+
+		printf("0x%x:0x%x\n", cur_addr, buf[0]);
+		len_idx++;
+	}
+	return 0;
+}
+
+int i2c_write(unsigned char chip, uint addr, int alen,
+			const unsigned char *buffer, int len)
+{
+	struct gk_i2c_msg msg = {0};
+	unsigned char buf[4]; /* 4 bit array */
+	int index = 0;
+	int ret;
+
+	msg.addr = (chip >> 1);
+	msg.len = alen + len;
+	msg.buf = buf;
+	msg.flags = 0;
+
+	if (alen == 2) { /* 2:len */
+		buf[index] = (addr >> 8) & 0xff; /* Move Right 8bit */
+		index++;
+		buf[index] = addr & 0xff;
+		index++;
+	} else {
+		buf[index] = addr & 0xff;
+		index++;
+	}
+
+	if (len == 2) { /* 2:len */
+		buf[index] = *buffer & 0xff;
+		index++;
+		buf[index] = (*buffer >> 8) & 0xff; /* Move Right 8bit */
+		index++;
+	} else {
+		buf[index] = *buffer & 0xff;
+		index++;
+	}
+
+	ret = gk_i2c_xfer(&msg, 1);
+	if (ret != 1) {
+		printf("I2c write: failed %d\n", ret);
+		return 1;
+	}
+
+	return 0;
+}
diff -uraN u-boot-2016.11/product/i2c/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/i2c/Makefile
--- u-boot-2016.11/product/i2c/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/i2c/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,5 @@
+sinclude $(TOPDIR)/config.mk
+
+ifdef CONFIG_GK_I2C
+obj-y += i2c.o
+endif
diff -uraN u-boot-2016.11/product/osd/dec/jpegd.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/dec/jpegd.c
--- u-boot-2016.11/product/osd/dec/jpegd.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/dec/jpegd.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,649 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "jpegd_image.h"
+#include "jpegd_drv.h"
+#include "jpegd_entry.h"
+
+static const unsigned char g_zigzag_for_qtable[ZIGZAG_TABLE_SIZE] = {
+    0,  1,  8, 16,  9,  2,  3, 10, 17, 24, 32, 25, 18, 11,  4,  5,
+    12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13,  6,  7, 14, 21, 28,
+    35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51,
+    58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63,
+};
+
+motion_jpeg_obj g_jpegd_ctx;
+
+int jpegd_dec_baseline(motion_jpeg_obj *jpegd_hdl_ctx, unsigned char **str, unsigned int *flag,
+    unsigned int *idx, unsigned int len)
+{
+    unsigned char *stream = *str;
+    int result = GK_SUCCESS;
+    if (*flag == 1) {
+        int tmp_len = (stream[0] << 8) + stream[1]; /* shift left 8 bits */
+        tmp_len = MIN(tmp_len, len - *idx);
+        jpegd_hdl_ctx->stream_buffer = stream;
+        *idx += (tmp_len + 2); /* 2 number of bytes */
+        stream += (tmp_len);
+        result = decode_sof0(jpegd_hdl_ctx, jpegd_hdl_ctx->stream_buffer);
+        if (result == GK_JPEG_DEC_OK) {
+            *flag = 2; /* 2 decode sof0 success */
+        }
+    }
+    *str = stream;
+    return result;
+}
+
+int jpegd_dec_dht(motion_jpeg_obj *jpegd_hdl_ctx, unsigned char **str, unsigned int len, unsigned int *idx)
+{
+    unsigned char *stream = *str;
+    unsigned int tmp_len = (stream[0] << 8) + stream[1]; /* shift left 8 bits */
+    tmp_len = MIN(tmp_len, len - *idx);
+    jpegd_hdl_ctx->stream_buffer = stream;
+    *idx += (tmp_len + 2); /* 2 number of bytes */
+    stream += (tmp_len);
+
+    if (decode_dht(jpegd_hdl_ctx, jpegd_hdl_ctx->stream_buffer)) {
+        return GK_FAILURE;
+    }
+    *str = stream;
+    return GK_SUCCESS;
+}
+
+int jpegd_dec_sos(motion_jpeg_obj *jpegd_hdl_ctx, unsigned char **str, unsigned int *flag, unsigned int *idx,
+    unsigned int len)
+{
+    unsigned char *stream = *str;
+    int result = GK_SUCCESS;
+    if (*flag == 2) { /* 2 decode sof0 success */
+        int tmp_len = (stream[0] << 8) + stream[1]; /* shift left 8 bits */
+        tmp_len = MIN(tmp_len, len - *idx);
+        jpegd_hdl_ctx->stream_buffer = stream;
+        *idx += (tmp_len);
+        stream += (tmp_len);
+        jpegd_hdl_ctx->first_mcu = 0;
+        result = decode_sos(jpegd_hdl_ctx, jpegd_hdl_ctx->stream_buffer);
+        if (result == GK_JPEG_DEC_OK) {
+            *flag = 3;  /* 3 scan header decoding success */
+        } else {
+            return GK_FAILURE;
+        }
+    }
+    *str = stream;
+    return GK_SUCCESS;
+}
+
+int jpegd_dec_dqt(motion_jpeg_obj *jpegd_hdl_ctx, unsigned char **str, unsigned int *idx, unsigned int len)
+{
+    unsigned char *stream = *str;
+    int tmp_len = (stream[0] << 8) + stream[1]; /* shift left 8 bits */
+    tmp_len = MIN(tmp_len, len - *idx);
+    jpegd_hdl_ctx->stream_buffer = stream;
+    *idx += (tmp_len + 2); /* 2 DQT number of bytes */
+    stream += (tmp_len);
+
+    if (decode_dqt(jpegd_hdl_ctx, jpegd_hdl_ctx->stream_buffer)) {
+        return GK_FAILURE;
+    }
+    *str = stream;
+    return GK_SUCCESS;
+}
+
+int jpegd_dec_dri(motion_jpeg_obj *jpegd_hdl_ctx, unsigned char **str, unsigned int *flag, unsigned int *idx)
+{
+    unsigned char *stream = *str;
+    jpegd_hdl_ctx->stream_buffer = stream;
+    if (decode_dri(jpegd_hdl_ctx, jpegd_hdl_ctx->stream_buffer)) { /* 4 dri len */
+        *flag = 0;
+        return GK_FAILURE;
+    }
+    *idx += 6; /* 6 define restart interval */
+    stream += 4; /* 4 define restart interval */
+    *str = stream;
+    return GK_SUCCESS;
+}
+
+int jpegd_dec_err(unsigned char **str, unsigned int *idx, unsigned int type, unsigned int *flag)
+{
+    unsigned char *stream = *str;
+    int result = GK_SUCCESS;
+    if ((type & 0xE0) == 0xE0) { /* 0xE0:APP_0 value */
+        int tmp_len = (stream[0] << 8) + stream[1]; /* shift left 8 bits */
+        *idx += (tmp_len + 2); /* 2 number of bytes */
+        stream += (tmp_len);
+    } else if ((type & 0xF0) == 0xC0) { /* 0xF0:JPG_0 0xC0:baseline */
+        *flag = 0;
+        result = GK_FAILURE;
+    } else {
+        *idx += 2; /* 2 number of bytes */
+    }
+    *str = stream;
+    return result;
+}
+
+void jpegd_dec_sos_success(motion_jpeg_obj *jpegd_hdl_ctx, mjpeg_dec_frame *tmp_dec_frame,
+    bool quant_table_valid, bool huffman_table_valid, unsigned int idx)
+{
+    jpegd_hdl_ctx->stream_offest = idx + 2; /* 2 number of bytes */
+    tmp_dec_frame->width = jpegd_hdl_ctx->frame.y_width;
+    tmp_dec_frame->height = jpegd_hdl_ctx->frame.y_height;
+    tmp_dec_frame->y_stride = jpegd_hdl_ctx->y_stride;
+    tmp_dec_frame->c_stride = jpegd_hdl_ctx->c_stride;
+    tmp_dec_frame->pic_format = jpegd_hdl_ctx->pic_format;
+    tmp_dec_frame->pts = jpegd_hdl_ctx->stream.pts;
+    tmp_dec_frame->reserved = 0;
+    tmp_dec_frame->user_data = NULL;
+    jpegd_hdl_ctx->valid_frame ^= 0x1;  /*  0x1:change to another buffer */
+
+    if (quant_table_valid == GK_FALSE) {
+        init_default_quant_table(jpegd_hdl_ctx);
+    }
+    if (huffman_table_valid == GK_FALSE) {
+        init_default_huffman_table(jpegd_hdl_ctx);
+    }
+    return;
+}
+
+void jpegd_dec_sos_failed(mjpeg_dec_frame *tmp_dec_frame)
+{
+    tmp_dec_frame->y = NULL;
+    tmp_dec_frame->u = NULL;
+    tmp_dec_frame->v = NULL;
+    tmp_dec_frame->width = 0;
+    tmp_dec_frame->height = 0;
+    tmp_dec_frame->y_stride = 0;
+    tmp_dec_frame->c_stride = 0;
+    tmp_dec_frame->pic_format = PICTURE_FORMAT_BUTT;
+    tmp_dec_frame->pts = 0;
+    tmp_dec_frame->reserved = 0;
+    tmp_dec_frame->user_data = NULL;
+    return;
+}
+
+/* decode jpeg picture */
+int jpegd_dec_frame(jpegd_handle handle, unsigned int flags)
+{
+    motion_jpeg_obj *jpegd_hdl_ctx = (motion_jpeg_obj *)handle;
+    unsigned int i;
+    unsigned int jpeg_flag = 0;
+    int result = 0;
+    unsigned int type;
+    unsigned char *stream = NULL;
+    unsigned int len;
+    mjpeg_dec_frame *tmp_dec_frame = NULL;
+    mjpeg_dec_frame dec_frame;
+    gk_bool quant_table_valid = GK_FALSE;
+    gk_bool huffman_table_valid = GK_FALSE;
+
+    if (jpegd_hdl_ctx == NULL) {
+        gk_trace("jpegd handle is null!\n");
+        return GK_MJPEG_ERR_HANDLE;
+    }
+
+    stream = jpegd_hdl_ctx->stream.vir_addr;
+    len = jpegd_hdl_ctx->stream.len;
+    tmp_dec_frame = &dec_frame;
+
+    if (stream == NULL) {
+        gk_trace("jpegd stream vir_addr is null!\n");
+        return GK_MJPEG_ERR_HANDLE;
+    }
+    tmp_dec_frame->error_code = 0;
+    tmp_dec_frame->error = 0;
+    jpegd_hdl_ctx->frame.restart_interval = 0;
+
+    for (i = 0; i < len;) {
+        type = 0xFF; /* 0xFF:jpeg maker */
+        while ((i < len) && (*(stream++) != 0xff)) { /* 0xFF:jpeg maker */
+            i++;
+        }
+        type = *(stream++);
+        while ((i < len) && (type == 0xff)) { /* 0xFF:jpeg maker */
+            type = *(stream++);
+            i++;
+        }
+        switch (type) {
+            case BASELINE: {  /* sequential DCT */
+                result = jpegd_dec_baseline(jpegd_hdl_ctx, &stream, &jpeg_flag, &i, len);
+                if (result != GK_SUCCESS) {
+                    tmp_dec_frame->error_code = result;
+                    gk_trace("jpeg decode DCT error!\n");
+                    goto end;
+                }
+            }
+            break;
+
+            case DHT: {  /* DHT */
+                result = jpegd_dec_dht(jpegd_hdl_ctx, &stream, len, &i);
+                if (result != GK_SUCCESS) {
+                    tmp_dec_frame->error_code += GK_ERR_HUFFMAN_TABLE;
+                    gk_trace("jpeg decode huffman error!\n");
+                    goto end;
+                }
+                huffman_table_valid = GK_TRUE;
+            }
+            break;
+
+            case SOS: {  /* scan header */
+                result = jpegd_dec_sos(jpegd_hdl_ctx, &stream, &jpeg_flag, &i, len);
+                if (result != GK_SUCCESS) {
+                    gk_trace("jpeg decode SOS error!\n");
+                    goto end;  /* scan header decoding error */
+                }
+                goto end;
+            }
+            break;
+
+            case SOI: {  /* a new jpeg picture */
+                i += 2; /* 2 SOI number of bytes */
+                jpeg_flag = 1;
+            }
+            break;
+
+            case EOI: {  /* end of jpeg picture */
+                i += 2; /* 2 EOI number of bytes */
+                goto end;
+            }
+
+            case DQT: {
+                result = jpegd_dec_dqt(jpegd_hdl_ctx, &stream, &i, len);
+                if (result != GK_SUCCESS) {
+                    tmp_dec_frame->error_code += GK_ERR_HUFFMAN_TABLE;
+                    gk_trace("jpeg decode DQT error!\n");
+                    goto end;
+                }
+                quant_table_valid = GK_TRUE;
+            }
+            break;
+
+            case DNL: {
+                i += 6; /* 6 define number of lines */
+                stream += 4; /* 4 number of lines' size */
+                jpeg_flag = 0;
+            }
+            break;
+
+            case DRI: {
+                result = jpegd_dec_dri(jpegd_hdl_ctx, &stream, &jpeg_flag, &i);
+                if (result != GK_SUCCESS) {
+                    tmp_dec_frame->error_code = GK_ERR_RESTART_ERROR;
+                    gk_trace("jpeg decode DRI error!\n");
+                    goto end;
+                }
+            }
+            break;
+
+            default: {  /* do not support */
+                result = jpegd_dec_err(&stream, &i, type, &jpeg_flag);
+                if (result != GK_SUCCESS) {
+                    tmp_dec_frame->error_code = GK_ERR_NOT_BASELINE;
+                    gk_trace("jpeg decode error, unsupport type!\n");
+                    goto end;
+                }
+            }
+            break;
+        }
+    }
+
+end:
+    if (jpeg_flag == 3) { /* 3 scan header decoding success */
+        jpegd_dec_sos_success(jpegd_hdl_ctx, tmp_dec_frame, quant_table_valid, huffman_table_valid, i);
+        return GK_MJPEG_DEC_OK;
+    } else {
+        jpegd_dec_sos_failed(tmp_dec_frame);
+        return GK_MJPEG_NO_PICTURE;
+    }
+}
+
+/* create a JPEG decoder handle */
+jpegd_handle jpegd_get_handle(void)
+{
+    motion_jpeg_obj *mjpeg = &g_jpegd_ctx;
+    int pic_size;
+
+    mjpeg->max_width = JPEGD_MAX_WIDTH;
+    mjpeg->max_height = JPEGD_MAX_HEIGHT;
+
+    pic_size = mjpeg->max_width * mjpeg->max_height;
+    mjpeg->buf_size = pic_size + 0x10000; /* 0x10000:extra mem */
+    mjpeg->stream_buffer = NULL;
+    mjpeg->pic_buffer = NULL;
+    mjpeg->valid_frame = 0;
+    mjpeg->width_in_mcu = 1;
+    mjpeg->height_in_mcu = 0;
+    mjpeg->y_stride = 0;
+    mjpeg->c_stride = 0;
+    mjpeg->pic_format = PICTURE_FORMAT_BUTT;
+    mjpeg->first_mcu = 0;
+    mjpeg->bits.bit_len = 0;
+    mjpeg->bits.bit_offset = 0;
+    mjpeg->bits.buffer = NULL;
+    mjpeg->frame.nf = 0;
+    mjpeg->frame.y_height = 0;
+    mjpeg->frame.y_width = 0;
+    mjpeg->frame.restart_interval = 0;
+    mjpeg->frame.restart_interval_logic = 0;
+    mjpeg->frame.max_mcu_number = 0;
+
+    init_default_huffman_table(mjpeg);
+    init_default_quant_table(mjpeg);
+
+    mjpeg->state = STATE_IDLE;
+
+    return (jpegd_handle)mjpeg;
+}
+
+void jpegd_config_huffman_dc(motion_jpeg_obj *jpeg_hdl_ctx, unsigned int *huffman_table, unsigned int cs)
+{
+    huffman_tab *huf_tab = &jpeg_hdl_ctx->h_tab[cs];
+    unsigned int i, num, j, index;
+    for (index = 0, i = 0; i < JPEGD_CODE_LEN; i++) {
+        num = huf_tab->len[i];
+        for (j = 0; (j < num) && (index < 12); j++, index++) { /* 12 max index */
+            int pos = huf_tab->huffman_val[index];
+            if (cs == 1) {
+                huffman_table[pos] |= ((i + 1) << 20) + /* shift left 20 bits 0xFF000:overflow protection */
+                (((j + (unsigned int)huf_tab->min_code[i]) << 12) & 0xFF000); /* shift left 12 bits */
+            } else {
+                huffman_table[pos] |=
+                ((i + 1) << 8) + ((j + (unsigned int)huf_tab->min_code[i]) & 0xFF); /* shift left 8 bits */
+            }
+        }
+    }
+    return;
+}
+
+void jpegd_config_huffman_ac(motion_jpeg_obj *jpeg_hdl_ctx, unsigned char *ac_min_table,
+    unsigned char *ac_base_table, unsigned int idx)
+{
+    huffman_tab *huf_tab = &jpeg_hdl_ctx->h_tab[idx];
+    int i;
+
+    for (i = 0; i < JPEGD_CODE_LEN; i++) {
+        unsigned int base_code = 0;
+
+        if (huf_tab->len[i]) {
+            base_code = huf_tab->huffman_val_ptr[i] - huf_tab->min_code[i];
+        }
+
+        ac_min_table[i] = ((unsigned int)huf_tab->min_code[i]) & 0xFF; /* 0xFF:get low 8 bits */
+        ac_base_table[i] = base_code & 0xFF; /* 0xFF:get low 8 bits */
+    }
+    return;
+}
+
+void jpegd_config_huffman_table(motion_jpeg_obj *jpeg_hdl_ctx)
+{
+    unsigned int i;
+    unsigned int huffman_table[HDC_TABLE_SIZE] = {0};
+    unsigned char luma_ac_min_table[JPEGD_CODE_LEN]    = {0};
+    unsigned char luma_ac_base_table[JPEGD_CODE_LEN]   = {0};
+    unsigned char chroma_ac_min_table[JPEGD_CODE_LEN]  = {0};
+    unsigned char chroma_ac_base_table[JPEGD_CODE_LEN] = {0};
+
+    /* config huffman dc */
+    jpegd_config_huffman_dc(jpeg_hdl_ctx, huffman_table, 1);
+    jpegd_config_huffman_dc(jpeg_hdl_ctx, huffman_table, 0);
+
+    /* config huffman ac */
+    jpegd_config_huffman_ac(jpeg_hdl_ctx, luma_ac_min_table, luma_ac_base_table, 2); /* 2:table index */
+    jpegd_config_huffman_ac(jpeg_hdl_ctx, chroma_ac_min_table, chroma_ac_base_table, 3); /* 3:table index */
+
+    /* config huffman table */
+    for (i = 0; i < HDC_TABLE_SIZE; i++) {
+        jpeg_hdl_ctx->vpu_config.huffman_table[i] = huffman_table[i];
+    }
+
+    /* config huffman_min_table table */
+    for (i = 0; i < HAC_MIN_TABLE_SIZE; i++) {
+        jpeg_hdl_ctx->vpu_config.huffman_min_table[i] =
+            (chroma_ac_min_table[2 * i + 1] << 24) + /* 2 config chroma ac table shift left 24 bits */
+            (chroma_ac_min_table[2 * i] << 16) + /* 2 config chroma ac table shift left 16 bits */
+            (luma_ac_min_table[2 * i + 1] << 8) + /* 2 config luma ac table shift left 8 bits */
+            (luma_ac_min_table[2 * i]); /* 2 config luma ac min table */
+    }
+
+    /* config huffman_base_table table */
+    for (i = 0; i < HAC_BASE_TABLE_SIZE; i++) {
+        jpeg_hdl_ctx->vpu_config.huffman_base_table[i] =
+            (chroma_ac_base_table[2 * i + 1] << 24) + /* 2 config chroma ac base table shift left 24 bits */
+            (chroma_ac_base_table[2 * i] << 16) + /* 2 config chroma ac base table shift left 16 bits */
+            (luma_ac_base_table[2 * i + 1] << 8) + /* 2 config luma ac base table shift left 8 bits */
+            (luma_ac_base_table[2 * i]); /* 2 config luma ac base table */
+    }
+
+    /* config huffman_symbol_table table */
+    for (i = 0; i < HAC_SYMBOL_TABLE_SIZE; i++) {
+        jpeg_hdl_ctx->vpu_config.huffman_symbol_table[i] =
+            (jpeg_hdl_ctx->h_tab[3].huffman_val[i] << 8) + /* table 3 shift left 8 bits */
+            jpeg_hdl_ctx->h_tab[2].huffman_val[i]; /* plus table 2 */
+    }
+    return;
+}
+
+void jpegd_config_quant_table(motion_jpeg_obj *jpeg_hdl_ctx)
+{
+    unsigned int i;
+    unsigned int q_tab_y_index = jpeg_hdl_ctx->frame.tq[COM0] & 3; /* 3 overflow protection */
+    unsigned int q_tab_u_index = jpeg_hdl_ctx->frame.tq[COM1] & 3; /* 3 overflow protection */
+    unsigned int q_tab_v_index = jpeg_hdl_ctx->frame.tq[COM2] & 3; /* 3 overflow protection */
+
+    unsigned char *q_cr = (unsigned char *)&jpeg_hdl_ctx->q_tab[q_tab_v_index];
+    unsigned char *q_cb = (unsigned char *)&jpeg_hdl_ctx->q_tab[q_tab_u_index];
+    unsigned char *q_y = (unsigned char *)&jpeg_hdl_ctx->q_tab[q_tab_y_index];
+    int pos;
+
+    for (i = 0; i < QUANT_TABLE_SIZE; i++) {
+        pos = g_zigzag_for_qtable[i & 0x3f]; /* 0x3f:get low 6bits */
+        jpeg_hdl_ctx->vpu_config.quant_table[pos] =
+            q_y[i] + (q_cb[i] << 8) + (q_cr[i] << 16); /* shift left 8 bits shift left 16 bits */
+    }
+
+    return;
+}
+
+void jpegd_config_rgb_info(motion_jpeg_obj *jpeg_hdl_ctx)
+{
+    if (jpeg_hdl_ctx->vpu_config.pixel_format == PIXEL_FORMAT_YVU_SEMIPLANAR_420) {
+        jpeg_hdl_ctx->vpu_config.out_yuv = GK_TRUE;
+    } else {
+        jpeg_hdl_ctx->vpu_config.out_yuv = GK_FALSE;
+        if ((jpeg_hdl_ctx->vpu_config.pixel_format == PIXEL_FORMAT_ARGB_8888) ||
+            (jpeg_hdl_ctx->vpu_config.pixel_format == PIXEL_FORMAT_ABGR_8888)) {
+            jpeg_hdl_ctx->vpu_config.rgb_stride = align_up(jpeg_hdl_ctx->frame.y_width * 4, 16); /* 4,16 align up */
+        } else if ((jpeg_hdl_ctx->vpu_config.pixel_format == PIXEL_FORMAT_ARGB_1555) ||
+                   (jpeg_hdl_ctx->vpu_config.pixel_format == PIXEL_FORMAT_ABGR_1555)) {
+            jpeg_hdl_ctx->vpu_config.rgb_stride = align_up(jpeg_hdl_ctx->frame.y_width * 2, 16); /* 2,16 align up */
+        } else if ((jpeg_hdl_ctx->vpu_config.pixel_format == PIXEL_FORMAT_RGB_888) ||
+                   (jpeg_hdl_ctx->vpu_config.pixel_format == PIXEL_FORMAT_BGR_888)) {
+            jpeg_hdl_ctx->vpu_config.rgb_stride = align_up(jpeg_hdl_ctx->frame.y_width * 3, 16); /* 3,16 align up */
+        } else if ((jpeg_hdl_ctx->vpu_config.pixel_format == PIXEL_FORMAT_RGB_565) ||
+                   (jpeg_hdl_ctx->vpu_config.pixel_format == PIXEL_FORMAT_BGR_565)) {
+            jpeg_hdl_ctx->vpu_config.rgb_stride = align_up(jpeg_hdl_ctx->frame.y_width * 2, 16); /* 2,16 align up */
+        }
+    }
+    return;
+}
+
+unsigned int jpegd_prepare_pic_type(picture_format pic_format)
+{
+    unsigned int pic_type = 0;
+    switch (pic_format) {
+        case PICTURE_FORMAT_YUV420:
+            pic_type = 3; /* 3: value of hardware regulation */
+            break;
+        case PICTURE_FORMAT_YUV422:
+            pic_type = 4; /* 4: value of hardware regulation */
+            break;
+        case PICTURE_FORMAT_YUV444:
+            pic_type = 6; /* 6: value of hardware regulation */
+            break;
+        case PICTURE_FORMAT_YUV422V:
+            pic_type = 5; /* 5: value of hardware regulation */
+            break;
+        case PICTURE_FORMAT_YUV400:
+            pic_type = 0; /* 0: value of hardware regulation */
+            break;
+        default:
+            printf("Unkonwn picture format %d!", pic_format);
+    }
+    return pic_type;
+}
+
+/* Prepare the jpegd Hardware Info */
+int jpegd_prepare_hardware_info(motion_jpeg_obj *jpeg_hdl_ctx)
+{
+    unsigned int ysize;
+
+    ysize = align_up(jpeg_hdl_ctx->frame.y_width, 64) * /* 64 align up */
+        align_up(jpeg_hdl_ctx->frame.y_height, 16); /* 16 align up */
+    jpeg_hdl_ctx->vpu_config.width = jpeg_hdl_ctx->frame.y_width;
+    jpeg_hdl_ctx->vpu_config.height = jpeg_hdl_ctx->frame.y_height;
+    jpeg_hdl_ctx->vpu_config.width_in_mcu = jpeg_hdl_ctx->width_in_mcu;
+    jpeg_hdl_ctx->vpu_config.height_in_mcu = jpeg_hdl_ctx->height_in_mcu;
+    jpeg_hdl_ctx->vpu_config.c_phy_addr = jpeg_hdl_ctx->vpu_config.y_phy_addr + ysize;
+    jpeg_hdl_ctx->vpu_config.y_stride = align_up(jpeg_hdl_ctx->frame.y_width, 64); /* 64 align up */
+    jpeg_hdl_ctx->vpu_config.c_stride = align_up(jpeg_hdl_ctx->frame.y_width, 64); /* 64 align up */
+    jpeg_hdl_ctx->vpu_config.phy_str_start = jpeg_hdl_ctx->vpu_config.phy_str_start + jpeg_hdl_ctx->stream_offest;
+    jpeg_hdl_ctx->vpu_config.y_fac = jpeg_hdl_ctx->frame.h[0];
+    jpeg_hdl_ctx->vpu_config.u_fac = jpeg_hdl_ctx->frame.h[1];
+    jpeg_hdl_ctx->vpu_config.v_fac = jpeg_hdl_ctx->frame.h[2]; /* 2 array index */
+    jpeg_hdl_ctx->vpu_config.dri = jpeg_hdl_ctx->frame.restart_interval_logic;
+    jpeg_hdl_ctx->vpu_config.pic_format = jpeg_hdl_ctx->pic_format;
+    jpeg_hdl_ctx->vpu_config.pic_type = jpegd_prepare_pic_type(jpeg_hdl_ctx->vpu_config.pic_format);
+
+    /* config RGB info */
+    jpegd_config_rgb_info(jpeg_hdl_ctx);
+
+    /* config quant table */
+    jpegd_config_quant_table(jpeg_hdl_ctx);
+
+    /* config huffman table */
+    jpegd_config_huffman_table(jpeg_hdl_ctx);
+
+    return GK_SUCCESS;
+}
+
+int jpegd_start_one_frame(jpegd_handle handle, unsigned int flags)
+{
+    int ret;
+    motion_jpeg_obj *jpegd_hdl_ctx = (motion_jpeg_obj *)handle;
+
+    ret = jpegd_dec_frame(handle, flags);
+    if (ret != GK_SUCCESS) {
+        gk_trace("vdec_start_one_frame: decode stream fail for 0x%x\n", ret);
+        return ret;
+    }
+
+    ret = jpegd_prepare_hardware_info(jpegd_hdl_ctx);
+    if (ret != GK_SUCCESS) {
+        gk_trace("vdec_start_one_frame: decode stream fail for 0x%x\n", ret);
+        return ret;
+    }
+
+    return GK_SUCCESS;
+}
+
+/* write the jpegd register */
+void jpegd_write_regs(jpegd_handle handle, S_JPGD_REGS_TYPE *reg_base)
+{
+    motion_jpeg_obj *jpeg_hdl_ctx = (motion_jpeg_obj *)handle;
+
+    jpegd_drv_write_regs(reg_base, &jpeg_hdl_ctx->vpu_config);
+    return;
+}
+
+/* read the jpegd register */
+void jpegd_read_regs(jpegd_handle handle, S_JPGD_REGS_TYPE *reg_base)
+{
+    motion_jpeg_obj *jpeg_hdl_ctx = (motion_jpeg_obj *)handle;
+
+    jpegd_drv_read_regs(reg_base, &jpeg_hdl_ctx->vpu_status);
+    return;
+}
+
+int jpegd_start_decoding(jpegd_handle handle)
+{
+    motion_jpeg_obj *jpegd_hld_ctx = NULL;
+    int ret;
+
+    jpegd_hld_ctx = (motion_jpeg_obj *)handle;
+    jpegd_hld_ctx->vpu_config.y_phy_addr = get_video_data_base();
+    jpegd_hld_ctx->vpu_config.phy_str_buf_start = get_logo();
+    jpegd_hld_ctx->vpu_config.phy_str_buf_end = get_logo() + align_up(get_jpeg_size_val(), 128); /* 128 align up */
+    jpegd_hld_ctx->vpu_config.phy_str_start = get_logo();
+    jpegd_hld_ctx->vpu_config.phy_str_end = get_logo() + get_jpeg_size_val();
+    jpegd_hld_ctx->vpu_config.phy_emar_buffer0 = get_jpegd_emar_buf();
+    jpegd_hld_ctx->vpu_config.phy_emar_buffer1 = get_jpegd_emar_buf() + ONE_EMAR_BUF_SIZE;
+    jpegd_hld_ctx->stream.vir_addr = (unsigned char *)(uintptr_t)get_logo();
+    jpegd_hld_ctx->stream.len = get_jpeg_size_val();
+    jpegd_hld_ctx->stream.phy_addr = get_logo();
+    jpegd_hld_ctx->stream.pts = 0;
+    jpegd_hld_ctx->vpu_config.chn_id = 0;
+    jpegd_hld_ctx->vpu_config.alpha = 255; /* 255 transparency */
+
+    if (get_output_format() == 0) {
+        jpegd_hld_ctx->vpu_config.pixel_format = PIXEL_FORMAT_YVU_SEMIPLANAR_420;
+    } else if (get_output_format() == 1) {
+        jpegd_hld_ctx->vpu_config.pixel_format = PIXEL_FORMAT_ARGB_1555;
+    } else if (get_output_format() == 2) { /* 2 output format */
+        jpegd_hld_ctx->vpu_config.pixel_format = PIXEL_FORMAT_ARGB_8888;
+    } else {
+        jpegd_hld_ctx->vpu_config.pixel_format = PIXEL_FORMAT_YVU_SEMIPLANAR_420;
+    }
+
+    ret = jpegd_start_one_frame(handle, 0);
+    if (ret != GK_SUCCESS) {
+        gk_trace("jpegd_start_decoding: decode stream fail for 0x%x\n", ret);
+        return ret;
+    }
+
+    jpegd_set_clock_en(0, GK_TRUE);
+    jpegd_reset(0);
+    jpegd_set_time_out(0, 0xFFFFFFFF); /* 0xFFFFFFFF:time out value */
+
+    jpegd_write_regs(handle, (S_JPGD_REGS_TYPE *)JPEGD_REGS_ADDR);
+
+    jpegd_start_vpu(0);
+
+    return GK_SUCCESS;
+}
+
+void jpegd_finish_decoding(jpegd_handle handle)
+{
+    unsigned int int_statue;
+    unsigned int cnt = 0;
+    motion_jpeg_obj *jpegd_hld_ctx = (motion_jpeg_obj *)handle;
+
+    while (1) {
+        udelay(10); /* 10 delay time */
+        int_statue = jpegd_read_int(0);
+        if (int_statue & 0x1f) {
+            break;
+        }
+        if (cnt++ > 2000) { /* 2000:Maximum decoding time */
+            gk_trace("jpeg decode over time\n");
+            break;
+        }
+    }
+
+    jpegd_read_regs(handle, (S_JPGD_REGS_TYPE *)JPEGD_REGS_ADDR);
+    if (jpegd_hld_ctx->vpu_status.int_dec_finish == 0) {
+        printf("hardware decoding error!\n");
+    } else {
+        if (jpegd_hld_ctx->vpu_config.out_yuv != GK_TRUE) {
+            printf("hardware decoding success! %ux%u, stride %u.\n",
+                   jpegd_hld_ctx->frame.y_width, jpegd_hld_ctx->frame.y_height, jpegd_hld_ctx->vpu_config.rgb_stride);
+        } else {
+            printf("hardware decoding success! %ux%u, stride %u.\n",
+                   jpegd_hld_ctx->frame.y_width, jpegd_hld_ctx->frame.y_height, jpegd_hld_ctx->vpu_config.y_stride);
+        }
+    }
+
+    jpegd_clear_int(0);
+    jpegd_reset_select(0, GK_TRUE);
+
+    return;
+}
+
diff -uraN u-boot-2016.11/product/osd/dec/jpegd_drv.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/dec/jpegd_drv.c
--- u-boot-2016.11/product/osd/dec/jpegd_drv.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/dec/jpegd_drv.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,469 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#include "jpegd_drv.h"
+#include <common.h>
+
+#define osal_readl(x) (*((volatile int *)(x)))
+#define osal_writel(v, x) (*((volatile int *)(x)) = (v))
+
+__inline static unsigned int get_low_addr(unsigned long long phyaddr)
+{
+    return (unsigned int)phyaddr;
+}
+
+__inline static unsigned int get_high_addr(unsigned long long phyaddr)
+{
+    return (unsigned int)(phyaddr >> 32); /* shift right 32 bits */
+}
+
+void jpegd_set_clock_en(int vpu_id, gk_bool is_run)
+{
+    unsigned long t, mask;
+    const unsigned int offset = JPEGD_CKEN_OFFSET;
+    mask = 1 << offset;
+    t = osal_readl((const volatile void *)JPEGD_CRG_REG_ADDR);
+    t &= ~mask;
+    t |= ((unsigned int)is_run << offset) & mask;
+    osal_writel(t, (volatile void *)JPEGD_CRG_REG_ADDR);
+
+    return;
+}
+
+void jpegd_reset_select(int vpu_id, gk_bool is_run)
+{
+    int i;
+    volatile U_JPEG_DEC_START D32;
+    S_JPGD_REGS_TYPE *jpegd_reg = (S_JPGD_REGS_TYPE *)jpegd_get_reg_addr(vpu_id);
+
+    if (is_run == GK_FALSE) {
+        for (i = 0; i < 1000; i++) { /* 1000 cycle time */
+            D32.u32 = jpegd_reg->JPEG_DEC_START.u32;
+            if (D32.bits.rst_busy == 0) {
+                break;
+            }
+            udelay(10); /* 10 delay time */
+        }
+        if (i >= 1000) { /* 1000 cycle time */
+            printf("JPEGD reset error!\n");
+            return;
+        }
+    }
+
+    unsigned long t, mask;
+    const unsigned int offset = 0;
+    mask = 1 << offset;
+    t = osal_readl((const volatile void *)JPEGD_CRG_REG_ADDR);
+    t &= ~mask;
+    t |= ((unsigned int)is_run << offset) & mask;
+    osal_writel(t, (volatile void *)JPEGD_CRG_REG_ADDR);
+
+    return;
+}
+
+void jpegd_set_outstanding(int vpu_id, int outstanding)
+{
+    U_FREQ_SCALE D32;
+    S_JPGD_REGS_TYPE *jpegd_reg = (S_JPGD_REGS_TYPE *)jpegd_get_reg_addr(vpu_id);
+
+    D32.u32 = jpegd_reg->FREQ_SCALE.u32;
+    D32.bits.outstanding = outstanding;
+    jpegd_reg->FREQ_SCALE.u32 = D32.u32;
+    return;
+}
+
+void *jpegd_get_reg_addr(int vpu_id)
+{
+    S_JPGD_REGS_TYPE *jpegd_reg = GK_NULL;
+
+    jpegd_reg = (S_JPGD_REGS_TYPE *)JPEGD_REGS_ADDR;
+
+    return jpegd_reg;
+}
+
+unsigned int jpegd_read_int(int vpu_id)
+{
+    S_JPGD_REGS_TYPE *jpegd_reg = (S_JPGD_REGS_TYPE *)jpegd_get_reg_addr(vpu_id);
+
+    return jpegd_reg->JPEG_INT.u32;
+}
+
+void jpegd_clear_int(int vpu_id)
+{
+    S_JPGD_REGS_TYPE *jpegd_reg = (S_JPGD_REGS_TYPE *)jpegd_get_reg_addr(vpu_id);
+    /* check if it's frame end */
+    jpegd_reg->JPEG_INT.u32 = 0xFFFFFFFF; /* 0xFFFFFFFF:interrupt value */
+
+    return;
+}
+
+void jpegd_set_int_mask(int vpu_id)
+{
+    S_JPGD_REGS_TYPE *jpegd_reg = (S_JPGD_REGS_TYPE *)jpegd_get_reg_addr(vpu_id);
+
+    jpegd_reg->INT_MASK.u32 = 0x0; /* 0x0:interrupt mask value */
+
+    return;
+}
+
+void jpegd_reset(int vpu_id)
+{
+    jpegd_reset_select(vpu_id, GK_TRUE);
+    jpegd_reset_select(vpu_id, GK_FALSE);
+    jpegd_set_int_mask(vpu_id);
+    jpegd_set_outstanding(vpu_id, 0x3); /* 0x3:outstanding value */
+
+    return;
+}
+
+void jpegd_start_vpu(int vpu_id)
+{
+    U_JPEG_DEC_START D32;
+    S_JPGD_REGS_TYPE *jpegd_reg = (S_JPGD_REGS_TYPE *)jpegd_get_reg_addr(vpu_id);
+
+    D32.u32 = jpegd_reg->JPEG_DEC_START.u32;
+    D32.bits.jpeg_dec_start = 1;
+    jpegd_reg->JPEG_DEC_START.u32 = D32.u32;
+
+    return;
+}
+
+int jpegd_set_time_out(int vpu_id, int time_out)
+{
+    S_JPGD_REGS_TYPE *jpegd_reg = (S_JPGD_REGS_TYPE *)jpegd_get_reg_addr(vpu_id);
+
+    jpegd_reg->OVER_TIME_THD = (unsigned int)time_out;
+
+    return GK_SUCCESS;
+}
+
+void jpegd_resume_start(S_JPGD_REGS_TYPE *jpegd_reg)
+{
+    U_JPEG_RESUME_START D32;
+
+    D32.u32 = 0;
+
+    D32.bits.jpeg_resume_start = 0;
+    D32.bits.last_resume_in_pic = 1;
+
+    jpegd_reg->JPEG_RESUME_START.u32 = D32.u32;
+    return;
+}
+
+void jpegd_stride(S_JPGD_REGS_TYPE *jpegd_reg, jpegd_vpu_config *config)
+{
+    U_JPEG_STRIDE D32;
+
+    D32.u32 = 0;
+
+    D32.bits.y_stride = config->y_stride;
+    D32.bits.uv_stride = config->c_stride;
+
+    jpegd_reg->JPEG_STRIDE.u32 = D32.u32;
+    return;
+}
+
+void jpegd_picture_size(S_JPGD_REGS_TYPE *jpegd_reg, jpegd_vpu_config *config)
+{
+    U_PICTURE_SIZE D32;
+
+    D32.u32 = 0;
+
+    D32.bits.pic_width_in_mcu = config->width_in_mcu;
+    D32.bits.pic_height_in_mcu = config->height_in_mcu;
+
+    jpegd_reg->PICTURE_SIZE.u32 = D32.u32;
+    return;
+}
+
+void jpegd_picture_type(S_JPGD_REGS_TYPE *jpegd_reg, jpegd_vpu_config *config)
+{
+    U_PICTURE_TYPE D32;
+
+    D32.u32 = 0;
+
+    D32.bits.pic_type = config->pic_type;
+
+    jpegd_reg->PICTURE_TYPE.u32 = D32.u32;
+    return;
+}
+
+void jpegd_rgb_out_stride(S_JPGD_REGS_TYPE *jpegd_reg, jpegd_vpu_config *config)
+{
+    U_RGB_OUT_STRIDE D32;
+
+    D32.u32 = 0;
+
+    D32.bits.jcfg2jdo_out_stride = config->rgb_stride;
+
+    jpegd_reg->RGB_OUT_STRIDE.u32 = D32.u32;
+    return;
+}
+
+void jpegd_bit_buffer_addr(S_JPGD_REGS_TYPE *jpegd_reg, jpegd_vpu_config *config)
+{
+    jpegd_reg->BITBUFFER_STADDR_LSB = get_low_addr(config->phy_str_buf_start);
+    jpegd_reg->BITBUFFER_STADDR_MSB.u32 = get_high_addr(config->phy_str_buf_start);
+
+    jpegd_reg->BITBUFFER_ENDADDR_LSB = get_low_addr(config->phy_str_buf_end);
+    jpegd_reg->BITBUFFER_ENDADDR_MSB.u32 = get_high_addr(config->phy_str_buf_end);
+    return;
+}
+
+void jpegd_bit_stream_addr(S_JPGD_REGS_TYPE *jpegd_reg, jpegd_vpu_config *config)
+{
+    jpegd_reg->BITSTREAMS_STADDR_LSB = get_low_addr(config->phy_str_start);
+    jpegd_reg->BITSTREAMS_STADDR_MSB.u32 = get_high_addr(config->phy_str_start);
+
+    jpegd_reg->BITSTREAMS_ENDADDR_LSB = get_low_addr(config->phy_str_end);
+    jpegd_reg->BITSTREAMS_ENDADDR_MSB.u32 = get_high_addr(config->phy_str_end);
+    return;
+}
+
+void jpegd_pic_yuv_start_addr(S_JPGD_REGS_TYPE *jpegd_reg, jpegd_vpu_config *config)
+{
+    jpegd_reg->PICTURE_YSTADDR_LSB = get_low_addr(config->y_phy_addr);
+    jpegd_reg->PICTURE_YSTADDR_MSB.u32 = get_high_addr(config->y_phy_addr);
+
+    if (config->out_yuv == GK_TRUE) {
+        jpegd_reg->PICTURE_UVSTADDR_LSB = get_low_addr(config->c_phy_addr);
+        jpegd_reg->PICTURE_UVSTADDR_MSB.u32 = get_high_addr(config->c_phy_addr);
+    }
+    return;
+}
+
+void jpegd_freq_scale(S_JPGD_REGS_TYPE *jpegd_reg, jpegd_vpu_config *config)
+{
+    U_FREQ_SCALE D32;
+    D32.u32 = jpegd_reg->FREQ_SCALE.u32;
+
+    D32.bits.freq_scale = 0;
+    D32.bits.ck_gt_en = 0;
+    D32.bits.outstanding = 3; /* 3:Simulation recommendation */
+    D32.bits.axi_id = 0;
+    if (config->out_yuv == GK_TRUE) {
+        D32.bits.jidct_emar_en = 1;
+    } else {
+        D32.bits.jidct_emar_en = 0;
+    }
+    jpegd_reg->FREQ_SCALE.u32 = D32.u32;
+    return;
+}
+
+void jpegd_out_type(S_JPGD_REGS_TYPE *jpegd_reg, jpegd_vpu_config *config)
+{
+    U_OUT_TYPE D32;
+
+    D32.u32 = 0;
+
+    if (config->out_yuv == GK_TRUE) {
+        if (config->pic_format == PICTURE_FORMAT_YUV400) {
+            D32.bits.jidct_yuv420_en = 0;
+        } else {
+            D32.bits.jidct_yuv420_en = 1;
+        }
+    } else {
+        D32.bits.jidct_yuv420_en = 0;
+
+        D32.bits.hor_med_en = 0;
+        D32.bits.ver_med_en = 0;
+        D32.bits.dither_en = 0;
+        if (config->pixel_format == PIXEL_FORMAT_ARGB_8888) {
+            D32.bits.out_rgb_type = 0;
+        } else if (config->pixel_format == PIXEL_FORMAT_ABGR_8888) {
+            D32.bits.out_rgb_type = 1;
+        } else if (config->pixel_format == PIXEL_FORMAT_ARGB_1555) {
+            D32.bits.out_rgb_type = 2; /* 2 pixel format ARGB1555 */
+        } else if (config->pixel_format == PIXEL_FORMAT_ABGR_1555) {
+            D32.bits.out_rgb_type = 3; /* 3 pixel format ABGR1555 */
+        } else if (config->pixel_format == PIXEL_FORMAT_RGB_565) {
+            D32.bits.out_rgb_type = 4; /* 4 pixel format RGB565 */
+        } else if (config->pixel_format == PIXEL_FORMAT_BGR_565) {
+            D32.bits.out_rgb_type = 5; /* 5 pixel format BGR565 */
+        } else if (config->pixel_format == PIXEL_FORMAT_RGB_888) {
+            D32.bits.out_rgb_type = 6; /* 6 pixel format RGB888 */
+        } else if (config->pixel_format == PIXEL_FORMAT_BGR_888) {
+            D32.bits.out_rgb_type = 7; /* 7 pixel format BGR888 */
+        }
+    }
+
+    jpegd_reg->OUT_TYPE.u32 = D32.u32;
+    return;
+}
+
+void jpegd_alpha(S_JPGD_REGS_TYPE *jpegd_reg, jpegd_vpu_config *config)
+{
+    if (config->out_yuv == GK_FALSE) {
+        U_JPGD_ALPHA D32;
+
+        D32.u32 = 0;
+
+        D32.bits.jpgd_a = config->alpha;
+        jpegd_reg->JPGD_ALPHA.u32 = D32.u32;
+    }
+    return;
+}
+
+void jpegd_emar_buffer(S_JPGD_REGS_TYPE *jpegd_reg, jpegd_vpu_config *config)
+{
+    unsigned int i;
+
+    for (i = 0; i < JPEGD_IP_NUM; i++) {
+        jpegd_reg->MTN_ADDRESS0_LSB = get_low_addr(config->phy_emar_buffer0);
+        jpegd_reg->MTN_ADDRESS0_MSB.u32 = get_high_addr(config->phy_emar_buffer0);
+
+        jpegd_reg->MTN_ADDRESS1_LSB = get_low_addr(config->phy_emar_buffer1);
+        jpegd_reg->MTN_ADDRESS1_MSB.u32 = get_high_addr(config->phy_emar_buffer1);
+    }
+    return;
+}
+
+void jpegd_pic_cut_pos(S_JPGD_REGS_TYPE *jpegd_reg, jpegd_vpu_config *config)
+{
+    if (config->out_yuv == GK_FALSE) {
+        {
+            U_PICCUT_STARTPOS D32;
+
+            D32.u32 = 0;
+
+            D32.bits.jcfg2jytr_pic_startx = 0;
+            D32.bits.jcfg2jytr_pic_starty = 0;
+            jpegd_reg->PICCUT_STARTPOS.u32 = D32.u32;
+        }
+        {
+            U_PICCUT_ENDPOS D32;
+
+            D32.u32 = 0;
+
+            D32.bits.jcfg2jytr_pic_endx = config->width - 1;
+            D32.bits.jcfg2jytr_pic_endy = config->height - 1;
+            jpegd_reg->PICCUT_ENDPOS.u32 = D32.u32;
+        }
+    }
+    return;
+}
+
+void jpegd_sampling_factor(S_JPGD_REGS_TYPE *jpegd_reg, jpegd_vpu_config *config)
+{
+    U_SAMPLING_FACTOR D32;
+
+    D32.u32 = 0;
+
+    D32.bits.v_fac = config->v_fac;
+    D32.bits.u_fac = config->u_fac;
+    D32.bits.y_fac = config->y_fac;
+
+    jpegd_reg->SAMPLING_FACTOR.u32 = D32.u32;
+    return;
+}
+
+void jpegd_dri(S_JPGD_REGS_TYPE *jpegd_reg, jpegd_vpu_config *config)
+{
+    U_DRI D32;
+
+    D32.u32 = 0;
+
+    D32.bits.jcfg2jvld_ri = config->dri;
+
+    jpegd_reg->DRI.u32 = D32.u32;
+    return;
+}
+
+void jpegd_config_quant_table_regs(S_JPGD_REGS_TYPE *jpegd_reg, jpegd_vpu_config *config)
+{
+    unsigned int i;
+    for (i = 0; i < QUANT_TABLE_SIZE; i++) {
+        jpegd_reg->QUANT_TABLE[i].u32 = config->quant_table[i];
+    }
+    return;
+}
+
+void jpegd_config_huffman_table_regs(S_JPGD_REGS_TYPE *jpegd_reg, jpegd_vpu_config *config)
+{
+    unsigned int i;
+    for (i = 0; i < HDC_TABLE_SIZE; i++) {
+        jpegd_reg->HDC_TABLE[i].u32 = config->huffman_table[i];
+    }
+
+    for (i = 0; i < HAC_MIN_TABLE_SIZE; i++) {
+        jpegd_reg->HAC_MIN_TABLE[i].u32 = config->huffman_min_table[i];
+    }
+
+    for (i = 0; i < HAC_BASE_TABLE_SIZE; i++) {
+        jpegd_reg->HAC_BASE_TABLE[i].u32 = config->huffman_base_table[i];
+    }
+
+    for (i = 0; i < HAC_SYMBOL_TABLE_SIZE; i++) {
+        jpegd_reg->HAC_SYMBOL_TABLE[i] = config->huffman_symbol_table[i];
+    }
+    return;
+}
+
+void jpegd_drv_write_regs(S_JPGD_REGS_TYPE *reg_base, jpegd_vpu_config *config)
+{
+    S_JPGD_REGS_TYPE *jpegd_reg = reg_base;
+
+    /*  1. JPEG_RESUME_START */
+    jpegd_resume_start(jpegd_reg);
+
+    /*  2. JPEG_STRIDE */
+    jpegd_stride(jpegd_reg, config);
+
+    /*  3. PICTURE_SIZE */
+    jpegd_picture_size(jpegd_reg, config);
+
+    /*  4. PICTURE_TYPE */
+    jpegd_picture_type(jpegd_reg, config);
+
+    /*  . RGB_OUT_STRIDE */
+    jpegd_rgb_out_stride(jpegd_reg, config);
+
+    /*  5. BITBUFFER_STADDR */
+    /*  6. BITBUFFER_ENDADDR */
+    jpegd_bit_buffer_addr(jpegd_reg, config);
+
+    /*  7. BITSTREAMS_STADDR */
+    /*  8. BITSTREAMS_ENDADDR */
+    jpegd_bit_stream_addr(jpegd_reg, config);
+
+    /*  9. PICTURE_YSTADDR */
+    /*  10. PICTURE_UVSTADDR */
+    jpegd_pic_yuv_start_addr(jpegd_reg, config);
+
+    /*  11. FREQ_SCALE */
+    jpegd_freq_scale(jpegd_reg, config);
+
+    /*  12. OUT_TYPE */
+    jpegd_out_type(jpegd_reg, config);
+
+    /*  . JPGD_ALPHA */
+    jpegd_alpha(jpegd_reg, config);
+
+    jpegd_emar_buffer(jpegd_reg, config);
+
+    /*  PICCUT_STARTPOS     U_PICCUT_ENDPOS */
+    jpegd_pic_cut_pos(jpegd_reg, config);
+
+    jpegd_sampling_factor(jpegd_reg, config);
+
+    /*  13. DRI */
+    jpegd_dri(jpegd_reg, config);
+
+    jpegd_config_quant_table_regs(jpegd_reg, config);
+
+    jpegd_config_huffman_table_regs(jpegd_reg, config);
+
+    return;
+}
+
+void jpegd_drv_read_regs(S_JPGD_REGS_TYPE *reg_base, jpegd_vpu_status *jpegd_vpu_status)
+{
+    S_JPGD_REGS_TYPE *jpegd_reg = reg_base;
+
+    jpegd_vpu_status->int_dec_finish = jpegd_reg->JPEG_INT.bits.int_dec_fnsh;
+    jpegd_vpu_status->int_dec_err = jpegd_reg->JPEG_INT.bits.int_dec_err;
+    jpegd_vpu_status->int_over_time = jpegd_reg->JPEG_INT.bits.int_over_time;
+    jpegd_vpu_status->int_bs_res = jpegd_reg->JPEG_INT.bits.int_bs_res;
+    return;
+}
+
diff -uraN u-boot-2016.11/product/osd/dec/jpegd_drv.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/dec/jpegd_drv.h
--- u-boot-2016.11/product/osd/dec/jpegd_drv.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/dec/jpegd_drv.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,139 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#ifndef __JPEGD_DRV_H__
+#define __JPEGD_DRV_H__
+#include "jpegd_reg.h"
+#include "type.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* End of #ifdef __cplusplus */
+
+#define JPEGD_REGS_SIZE       0x6BF
+
+#define JPEGD_IP_NUM          1
+
+#define QUANT_TABLE_SIZE      64
+#define HDC_TABLE_SIZE        12
+#define HAC_MIN_TABLE_SIZE    8
+#define HAC_BASE_TABLE_SIZE   8
+#define HAC_SYMBOL_TABLE_SIZE 176
+#define ZIGZAG_TABLE_SIZE     64
+
+typedef struct {
+    gk_bool int_dec_finish;
+    gk_bool int_dec_err;
+    gk_bool int_over_time;
+    gk_bool int_bs_res;
+} jpegd_vpu_status;
+
+typedef enum {
+    PIXEL_FORMAT_RGB_444 = 0,
+    PIXEL_FORMAT_RGB_555,
+    PIXEL_FORMAT_RGB_565,
+    PIXEL_FORMAT_RGB_888,
+
+    PIXEL_FORMAT_BGR_444,
+    PIXEL_FORMAT_BGR_555,
+    PIXEL_FORMAT_BGR_565,
+    PIXEL_FORMAT_BGR_888,
+
+    PIXEL_FORMAT_ARGB_1555,
+    PIXEL_FORMAT_ARGB_4444,
+    PIXEL_FORMAT_ARGB_8565,
+    PIXEL_FORMAT_ARGB_8888,
+
+    PIXEL_FORMAT_ABGR_1555,
+    PIXEL_FORMAT_ABGR_4444,
+    PIXEL_FORMAT_ABGR_8565,
+    PIXEL_FORMAT_ABGR_8888,
+
+    PIXEL_FORMAT_RGB_BAYER_8BPP,
+    PIXEL_FORMAT_RGB_BAYER_10BPP,
+    PIXEL_FORMAT_RGB_BAYER_12BPP,
+    PIXEL_FORMAT_RGB_BAYER_14BPP,
+    PIXEL_FORMAT_RGB_BAYER_16BPP,
+
+    PIXEL_FORMAT_YUV_PLANAR_422,
+    PIXEL_FORMAT_YUV_PLANAR_420,
+    PIXEL_FORMAT_YUV_PLANAR_444,
+
+    PIXEL_FORMAT_YVU_SEMIPLANAR_422,
+    PIXEL_FORMAT_YVU_SEMIPLANAR_420,
+    PIXEL_FORMAT_YVU_SEMIPLANAR_444,
+
+    PIXEL_FORMAT_UYVY_PACKAGE_422,
+    PIXEL_FORMAT_YUYV_PACKAGE_422,
+    PIXEL_FORMAT_VYUY_PACKAGE_422,
+
+    PIXEL_FORMAT_YUV_400,
+
+    PIXEL_FORMAT_BUTT
+} gk_pixel_format;
+
+typedef enum {
+    PICTURE_FORMAT_YUV420 = 0,
+    PICTURE_FORMAT_YUV422 = 1, /* 422 2x1 */
+    PICTURE_FORMAT_YUV444 = 2,
+    PICTURE_FORMAT_YUV422V = 3, /* 422 1x2 */
+    PICTURE_FORMAT_YUV400 = 4,
+    PICTURE_FORMAT_BUTT
+} picture_format;
+
+typedef struct {
+    int chn_id;
+    picture_format pic_format;
+    gk_pixel_format pixel_format;
+    gk_bool out_yuv;
+    unsigned char v_fac;
+    unsigned char u_fac;
+    unsigned char y_fac;
+    unsigned int dri;
+    unsigned int width;
+    unsigned int height;
+    unsigned int width_in_mcu;
+    unsigned int height_in_mcu;
+    unsigned int y_stride;
+    unsigned int c_stride;
+    unsigned int pic_type;
+    unsigned int rgb_stride;
+    unsigned int alpha;
+
+    unsigned long long y_phy_addr;
+    unsigned long long c_phy_addr;
+    unsigned long long phy_str_buf_start;
+    unsigned long long phy_str_buf_end;
+    unsigned long long phy_str_start;
+    unsigned long long phy_str_end;
+    unsigned long long phy_emar_buffer0;
+    unsigned long long phy_emar_buffer1;
+
+    unsigned int quant_table[QUANT_TABLE_SIZE];
+    unsigned int huffman_table[HDC_TABLE_SIZE];
+    unsigned int huffman_min_table[HAC_MIN_TABLE_SIZE];
+    unsigned int huffman_base_table[HAC_BASE_TABLE_SIZE];
+    unsigned int huffman_symbol_table[HAC_SYMBOL_TABLE_SIZE];
+} jpegd_vpu_config;
+
+void jpegd_drv_write_regs(S_JPGD_REGS_TYPE *reg_base, jpegd_vpu_config *vpu_config);
+
+void jpegd_drv_read_regs(S_JPGD_REGS_TYPE *reg_base, jpegd_vpu_status *vpu_status);
+
+void jpegd_set_clock_en(int vpu_id, gk_bool is_run);
+void jpegd_reset_select(int vpu_id, gk_bool is_run);
+
+void jpegd_set_outstanding(int vpu_id, int outstanding);
+void *jpegd_get_reg_addr(int vpu_id);
+unsigned int jpegd_read_int(int vpu_id);
+void jpegd_clear_int(int vpu_id);
+void jpegd_set_int_mask(int vpu_id);
+void jpegd_reset(int vpu_id);
+void jpegd_start_vpu(int vpu_id);
+int jpegd_set_time_out(int vpu_id, int time_out);
+
+#ifdef __cplusplus
+}
+#endif /* End of #ifdef __cplusplus */
+
+#endif /* End of __JPEGD_DRV_H__ */
diff -uraN u-boot-2016.11/product/osd/dec/jpegd_entry.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/dec/jpegd_entry.c
--- u-boot-2016.11/product/osd/dec/jpegd_entry.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/dec/jpegd_entry.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,230 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#include "jpegd_entry.h"
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+#include <version.h>
+#include <net.h>
+#include <asm/io.h>
+#include <asm/arch/platform.h>
+#include <config.h>
+#include "jpegd.h"
+
+const char g_logo_magic_str[] = "VENDOR LOGO MAGIC";
+
+unsigned long g_logo = 0;
+unsigned long g_jpeg_size = 0;
+unsigned long g_video_data_base = 0;
+unsigned long g_jpegd_emar_buf = 0;
+unsigned int g_output_format = 0;
+
+unsigned long get_logo(void)
+{
+    return g_logo;
+}
+
+unsigned long get_jpeg_size_val(void)
+{
+    return g_jpeg_size;
+}
+
+unsigned long get_video_data_base(void)
+{
+    return g_video_data_base;
+}
+
+unsigned long get_jpegd_emar_buf(void)
+{
+    return g_jpegd_emar_buf;
+}
+
+unsigned int get_output_format(void)
+{
+    return g_output_format;
+}
+
+int jpeg_decode(unsigned int format)
+{
+    jpegd_handle handle = NULL;
+    int ret;
+
+    g_output_format = format;
+    if (dcache_status()) {
+        flush_dcache_range(g_logo, g_logo + g_jpeg_size);
+    }
+
+    handle = jpegd_get_handle();
+    if (handle == NULL) {
+        printf("handle is invalid!");
+        return -1;
+    }
+    ret = jpegd_start_decoding(handle);
+    if (ret != GK_SUCCESS) {
+        printf("decoding error!");
+        return -1;
+    }
+
+    jpegd_finish_decoding(handle);
+
+    return 0;
+}
+
+int get_vo_buf_addr(void)
+{
+    int i = 0;
+    char evn_buf[ENV_BUF_LEN] = {0};
+    char *str = getenv("vobuf");
+    if (str != NULL) {
+        while ((*str != '\0') && (i < sizeof(evn_buf) - 1)) {
+            evn_buf[i++] = *str++;
+        }
+        evn_buf[i] = '\0';
+        g_video_data_base = simple_strtol(evn_buf, NULL, 16); /* Base 16 */
+    } else {
+        printf("Invalid vobuf address!\n");
+        return 1;
+    }
+    if (g_video_data_base == 0) {
+        printf("Invalid VOU buffer address 0x%08lX\n", g_video_data_base);
+        return -1;
+    }
+    return 0;
+}
+
+int get_emar_buf_addr(void)
+{
+    int i = 0;
+    char evn_buf[ENV_BUF_LEN] = {0};
+    char *str = getenv("jpeg_emar_buf");
+    if (str != NULL) {
+        while ((*str != '\0') && (i < sizeof(evn_buf) - 1)) {
+            evn_buf[i++] = *str++;
+        }
+        evn_buf[i] = '\0';
+        g_jpegd_emar_buf = simple_strtol(evn_buf, NULL, 16); /* Base 16 */
+    } else {
+        printf("Invalid jpeg_emar_buf address!\n");
+        return 1;
+    }
+    if (g_jpegd_emar_buf == 0) {
+        printf("Invalid jpeg_emar_buf address 0x%08lX\n", g_jpegd_emar_buf);
+        return -1;
+    }
+    return 0;
+}
+
+int need_2_emar_buf(void)
+{
+    unsigned int len;
+    unsigned long interval;
+    len = ONE_EMAR_BUF_SIZE * 2; /* 2:need two emar buffer */
+    if (g_video_data_base > g_jpegd_emar_buf) {
+        interval = g_video_data_base - g_jpegd_emar_buf;
+    } else {
+        interval = g_jpegd_emar_buf - g_video_data_base;
+    }
+    if (interval < len) {
+        printf("vobuf and jpeg_emar_buf is overlapping! their interval len must larger than %u\n", len);
+        return -1;
+    }
+    return 0;
+}
+
+int get_jpeg_size(void)
+{
+    int i = 0;
+    char evn_buf[ENV_BUF_LEN] = {0};
+    char *str = getenv("jpeg_size");
+    if (str != NULL) {
+        while ((*str != '\0') && (i < sizeof(evn_buf) - 1)) {
+            evn_buf[i++] = *str++;
+        }
+        evn_buf[i] = '\0';
+        g_jpeg_size = simple_strtol(evn_buf, NULL, 16); /* Base 16 */
+    } else {
+        printf("you should set jpeg stream address!\n");
+        return -1;
+    }
+    if (g_jpeg_size == 0) {
+        printf("Invalid jpeg_size 0x%08lX\n", g_jpeg_size);
+        return -1;
+    }
+    return 0;
+}
+
+int get_jpeg_stream_addr(void)
+{
+    int i = 0;
+    char evn_buf[ENV_BUF_LEN] = {0};
+    char *str = getenv("jpeg_addr");
+    if (str != NULL) {
+        while ((*str != '\0') && (i < sizeof(evn_buf) - 1)) {
+            evn_buf[i++] = *str++;
+        }
+        evn_buf[i] = '\0';
+        g_logo = simple_strtol(evn_buf, NULL, 16);  /* Base 16 */
+    } else {
+        printf("you should set jpeg picture's address!\n");
+        return -1;
+    }
+    if (g_logo == 0) {
+        printf("Invalid jpeg_addr 0x%08lX\n", g_logo);
+        return -1;
+    }
+    return 0;
+}
+
+int load_jpeg(void)
+{
+    int ret;
+
+    printf("jpeg decoding ...\n");
+
+    /* get vo buffer address */
+    ret = get_vo_buf_addr();
+    if (ret != 0) {
+        return ret;
+    }
+
+    /* get emar buffer address for jpegd */
+    ret = get_emar_buf_addr();
+    if (ret != 0) {
+        return ret;
+    }
+
+    /* jpeg decoder need 2 emar buffer */
+    ret = need_2_emar_buf();
+    if (ret != 0) {
+        return ret;
+    }
+
+    /* get jpeg size */
+    ret = get_jpeg_size();
+    if (ret != 0) {
+        return ret;
+    }
+
+    /* get jpeg stream address */
+    ret = get_jpeg_stream_addr();
+    if (ret != 0) {
+        return ret;
+    }
+
+    printf("<<addr=%#lx, size=%#lx, jpeg_emar_buf=%#lx, vobuf=%#lx>>\n", g_logo, g_jpeg_size, g_jpegd_emar_buf,
+           g_video_data_base);
+    if ((g_logo & 0x7f) != 0) { /* 0x7f:get low 7 bits */
+        printf("jpeg_addr:%#lx should be align to 128bytes!\n", g_logo);
+        return -1;
+    }
+    /* 0xFF:jpeg maker 0xD8:SOI maker */
+    if ((*(unsigned char *)(uintptr_t)g_logo != 0xFF) || (*(unsigned char *)((uintptr_t)g_logo + 1) != 0xD8)) {
+        printf("addr:%#lx,size:%lu,logoaddr:0,:%2x,%2x\n", g_logo, g_jpeg_size,
+            *(unsigned char *)(uintptr_t)g_logo, *(unsigned char *)((uintptr_t)g_logo + 1));
+        return -1;
+    }
+
+    return 0;
+}
+
diff -uraN u-boot-2016.11/product/osd/dec/jpegd_entry.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/dec/jpegd_entry.h
--- u-boot-2016.11/product/osd/dec/jpegd_entry.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/dec/jpegd_entry.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __JPEGD_ENTRY_H__
+#define __JPEGD_ENTRY_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* End of #ifdef __cplusplus */
+#define ENV_BUF_LEN			32
+unsigned long get_logo(void);
+unsigned long get_jpeg_size_val(void);
+unsigned long get_video_data_base(void);
+unsigned long get_jpegd_emar_buf(void);
+unsigned int get_output_format(void);
+
+#ifdef __cplusplus
+}
+#endif /* End of #ifdef __cplusplus */
+
+#endif /* _JPEGD_ENTRY_H_ */
diff -uraN u-boot-2016.11/product/osd/dec/jpegd_error.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/dec/jpegd_error.h
--- u-boot-2016.11/product/osd/dec/jpegd_error.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/dec/jpegd_error.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __JPEGD_ERROR_H__
+#define __JPEGD_ERROR_H__
+
+#include <common.h>
+
+/* for SOF error */
+#define GK_ERR_NOT_BASELINE        0x00000001
+#define GK_UNSUPPORT_GRAY_PIC      0x00000002
+#define GK_UNSUPPORT_PIC_SIZE      0x00000004
+#define GK_UNSUPPORT_PIC_STRUCT    0x00000008
+#define GK_UNSUPPORT_YUV411        0x00000010
+
+#define GK_ERR_QUANT_TABLE         0x00000020
+#define GK_ERR_HUFFMAN_TABLE       0x00000040
+#define GK_ERR_FRAME_HEADER        0x00000080
+#define GK_ERR_SCAN_HEADER         0x00000100
+#define GK_ERR_RESTART_ERROR       0x00000200
+#define GK_ERR_UNSUPPORT_DNL       0x00000400
+
+#define gk_trace(fmt...)                             \
+    do {                                             \
+        printf("[%s]-%d: ", __FUNCTION__, __LINE__); \
+        printf(fmt);                                 \
+    } while (0)
+
+#endif /* End of __JPEGD_ERROR_H__ */
\ No newline at end of file
diff -uraN u-boot-2016.11/product/osd/dec/jpegd.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/dec/jpegd.h
--- u-boot-2016.11/product/osd/dec/jpegd.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/dec/jpegd.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,216 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __JPEGD_H__
+#define __JPEGD_H__
+#include "type.h"
+#include "jpegd_drv.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* End of #ifdef __cplusplus */
+
+#define align_up(x, a) (((x) + ((a) - 1)) & (~((a) - 1)))
+
+#define GK_JPEG_DEC_OK        0
+#define GK_JPEG_DEC_FRAME_ERR 1
+#define GK_JPEG_DEC_SCAN_ERR  2
+#define GK_JPEG_DEC_MCU_ERR   3
+#define GK_JPEG_DEC_DRI_ERR   4
+#define GK_JPEG_DEC_DHT_ERR   5
+#define GK_JPEG_DEC_DQT_ERR   6
+
+#define JPEGD_MAX_WIDTH       8192
+#define JPEGD_MAX_HEIGHT      8192
+#define JPEGD_MIN_WIDTH       8
+#define JPEGD_MIN_HEIGHT      8
+
+#define ONE_EMAR_BUF_SIZE     (128 * ((JPEGD_MAX_WIDTH + 7) >> 3))
+
+#define BASELINE              0xC0  /* baseline frame header */
+#define PROGRESSIVE           0xC2  /* progressive frame header */
+#define DHT                   0xC4
+#define RST0                  0xD0
+#define RST1                  0xD1
+#define RST2                  0xD2
+#define RST3                  0xD3
+#define RST4                  0xD4
+#define RST5                  0xD5
+#define RST6                  0xD6
+#define RST7                  0xD7
+#define SOI                   0xD8
+#define EOI                   0xD9
+#define SOS                   0xDA
+#define DQT                   0xDB
+#define DNL                   0xDC
+#define DRI                   0xDD
+
+#define MIN(a, b) (((a) < (b)) ? (a) : (b))
+
+#define GK_MJPEG_DEC_OK       0
+#define GK_MJPEG_NO_PICTURE   (-1)
+#define GK_MJPEG_ERR_HANDLE   (-2)
+
+#define JPEGD_MAX_HANDLE_NUM  3
+#define JPEGD_CODE_LEN        16
+#define JPEGD_HUFFMAN_LEN     256
+#define JPEGD_QUANT_LEN       64
+#define JPEGD_NF_LEN          4
+#define JPEGD_NS_LEN          4
+#define JPEGD_FRAME_COUNT     2
+#define JPEGD_HUFFMAN_TAB     4
+#define JPEGD_QUANT_TAB       4
+#define JPEGD_DC_PRED         4
+#define JPEGD_HUFFMAN_TAB_LEN 3
+#define JPEGD_HUFFMAN_LEN     256
+
+#define COM0  0
+#define COM1  1
+#define COM2  2
+
+#define JPEGD_ALLOC_BUFF_CACHED
+
+typedef void *jpegd_handle;
+
+typedef enum {
+    STATE_IDLE = 0,
+    STATE_BUSY = 1,
+    STATE_BUTT
+} jpegd_state;
+
+typedef struct {
+    int max_code[JPEGD_CODE_LEN];
+    int max_code16[JPEGD_CODE_LEN];
+    int min_code[JPEGD_CODE_LEN];
+    int len[JPEGD_CODE_LEN];
+    unsigned short huffman_val_ptr[JPEGD_CODE_LEN];
+    unsigned char huffman_val[JPEGD_HUFFMAN_LEN];
+
+    unsigned char fast_huffman_code[JPEGD_HUFFMAN_LEN];
+    unsigned char fast_huffman_len[JPEGD_HUFFMAN_LEN];
+    unsigned int u_code32;
+} huffman_tab;
+
+typedef struct {
+    unsigned char quant[JPEGD_QUANT_LEN];
+} quant_tab;
+
+typedef struct {
+    unsigned int nf;
+    unsigned int color_depth;
+    unsigned int y_width;
+    unsigned int y_height;
+    unsigned char ci[JPEGD_NF_LEN]; /* NF:Number of image components in frame */
+    unsigned char h[JPEGD_NF_LEN];
+    unsigned char v[JPEGD_NF_LEN];
+    unsigned char tq[JPEGD_NF_LEN];
+    unsigned int restart_interval;
+    unsigned int restart_interval_logic;
+    unsigned int max_mcu_number;
+} frame_header;
+
+typedef struct {
+    unsigned int ns;
+    unsigned char cs[JPEGD_NS_LEN]; /* NS:Number of image components in scan */
+    unsigned char td[JPEGD_NS_LEN];
+    unsigned char ta[JPEGD_NS_LEN];
+    unsigned char ss;
+    unsigned char se;
+    unsigned char ah;
+    unsigned char al;
+} scan_header;
+
+typedef struct {
+    unsigned char *buffer;
+    unsigned int bit_len;
+    unsigned int bit_offset;
+} bitstream;
+
+typedef struct {
+    unsigned char *vir_addr;
+    unsigned long long phy_addr;
+    unsigned int len;
+    unsigned int pts;
+} jpegd_stream;
+
+typedef struct {
+    unsigned char *stream_buffer;
+    unsigned char *pic_buffer;
+    unsigned int stream_offest;
+    jpegd_stream stream;
+    bitstream bits;
+    frame_header frame;
+    scan_header scan;
+    huffman_tab h_tab[JPEGD_HUFFMAN_TAB];
+    quant_tab q_tab[JPEGD_QUANT_TAB];
+
+    unsigned char *y[JPEGD_FRAME_COUNT];
+    unsigned char *u[JPEGD_FRAME_COUNT];
+    unsigned char *v[JPEGD_FRAME_COUNT];
+    unsigned int valid_frame;
+    unsigned int max_width;
+    unsigned int max_height;
+    unsigned int buf_size;
+    unsigned int first_mcu;
+    short jpeg_dc_pred[JPEGD_DC_PRED];  /* 0 for Y;  1 for U;   2 for V;  3 reserved total */
+
+    unsigned int height_in_mcu;
+    unsigned int width_in_mcu;
+    unsigned int y_stride;
+    unsigned int c_stride;
+    picture_format pic_format;
+
+    quant_tab *q_tab_components[JPEGD_HUFFMAN_TAB_LEN];
+    huffman_tab *h_tab_components_dc[JPEGD_HUFFMAN_TAB_LEN];
+    huffman_tab *h_tab_components_ac[JPEGD_HUFFMAN_TAB_LEN];
+    huffman_tab huffman_tmp;
+
+    unsigned int profile; /* 0: baseline; 1:progressive; other:unsupport; */
+    jpegd_state state;
+    jpegd_vpu_config vpu_config;
+    jpegd_vpu_status vpu_status;
+} motion_jpeg_obj;
+
+typedef struct gk_mjpeg_userdata {
+    unsigned int user_data_type;  /* type of userdata */
+    unsigned int user_data_size;  /* length of userdata in byte */
+    unsigned char *data;  /* buffer contains userdata stuff */
+    struct gk_mjpeg_userdata *next;  /* pointer to next userdata */
+} mjpeg_userdata;
+
+typedef struct {
+    unsigned char *y;
+    unsigned char *u;
+    unsigned char *v;
+    unsigned int width;
+    unsigned int height;
+    unsigned int y_stride;
+    unsigned int c_stride;
+    int pic_format;  /* 0: YUV420; */
+    /* 1: YUV422; */
+    /* 2: YUV444; */
+    /* 3: YUV422V; */
+    /* 4: YUV400; */
+    /* >=5: reserved */
+    int error;  /* 0: no error */
+    /* 1: MCU error */
+    unsigned long long pts;  /* time stamp */
+    unsigned int reserved;
+    int error_code;
+    mjpeg_userdata *user_data;  /* pointer to the first userdata */
+} mjpeg_dec_frame;
+
+jpegd_handle jpegd_get_handle(void);
+int jpegd_dec_frame(jpegd_handle handle, unsigned int flags);
+int jpegd_start_one_frame(jpegd_handle handle, unsigned int flags);
+void jpegd_write_regs(jpegd_handle handle, S_JPGD_REGS_TYPE *reg_base);
+void jpegd_read_regs(jpegd_handle handle, S_JPGD_REGS_TYPE *reg_base);
+int jpegd_start_decoding(jpegd_handle handle);
+void jpegd_finish_decoding(jpegd_handle handle);
+
+#ifdef __cplusplus
+}
+#endif /* End of #ifdef __cplusplus */
+
+#endif /* _JPEGD_H_ */
diff -uraN u-boot-2016.11/product/osd/dec/jpegd_image.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/dec/jpegd_image.c
--- u-boot-2016.11/product/osd/dec/jpegd_image.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/dec/jpegd_image.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,432 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "jpegd_image.h"
+
+static const unsigned char g_default_huffman_table[418] = { 0x01, 0xA2,    /* 418 :huffman_table size */
+    /* table K.3 - table for luminance DC coefficient differences */
+    0x00,
+    0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
+    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0x0A, 0x0B,
+
+    /* table K.4 - table for chrominance DC coefficient differences */
+    0x01,
+    0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
+    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0x0A, 0x0B,
+
+    /* table K.5 - table for luminance AC coefficients */
+    0x10,
+    0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7D,
+    0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,
+    0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xA1, 0x08, 0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1, 0xF0,
+    0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0A, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28,
+    0x29, 0x2A, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
+    0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
+    0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
+    0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7,
+    0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5,
+    0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE1, 0xE2,
+    0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8,
+    0xF9, 0xFA,
+
+    /* table K.6 - table for chrominance AC coefficients */
+    0x11,
+    0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77,
+    0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,
+    0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xA1, 0xB1, 0xC1, 0x09, 0x23, 0x33, 0x52, 0xF0,
+    0x15, 0x62, 0x72, 0xD1, 0x0A, 0x16, 0x24, 0x34, 0xE1, 0x25, 0xF1, 0x17, 0x18, 0x19, 0x1A, 0x26,
+    0x27, 0x28, 0x29, 0x2A, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
+    0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
+    0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
+    0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5,
+    0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3,
+    0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA,
+    0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8,
+    0xF9, 0xFA,
+};
+
+static const unsigned char g_default_quant_table[160] = { 0x00, 0x84,    /* 160 :quant_table size */
+    /* table K.1 - luminance quantization table */
+    0x00,
+    16,  11,  12,  14,  12,  10,  16,  14,  13,  14,  18,  17,  16,  19,  24,  40,
+    26,  24,  22,  22,  24,  49,  35,  37,  29,  40,  58,  51,  61,  60,  57,  51,
+    56,  55,  64,  72,  92,  78,  64,  68,  87,  69,  55,  56,  80, 109,  81,  87,
+    95,  98, 103, 104, 103,  62,  77, 113, 121, 112, 100, 120,  92, 101, 103,  99,
+
+    /* table K.2 - chrominance quantization table */
+    0x01,
+    17, 18, 18, 24, 21, 24, 47, 26, 26, 47, 99, 66, 56, 66, 99, 99,
+    99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
+    99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
+    99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
+};
+
+unsigned int jpegd_decode_dht_huffman_length(huffman_tab *huffman, const unsigned char **str,
+    unsigned char *ptr, unsigned int *error_flag)
+{
+    unsigned int i, tab_len;
+    int max_code = 0;
+    const unsigned char *stream = *str;
+    for (i = 0, tab_len = 0; i < JPEGD_CODE_LEN; i++) {
+        ptr[i] = *stream++;
+
+        if (ptr[i]) {
+            huffman->min_code[i] = (unsigned int)(max_code) << 1;
+            huffman->max_code[i] = huffman->min_code[i] + ptr[i] - 1;
+            huffman->max_code16[i] =
+                ((unsigned int)(huffman->max_code[i] + 1) << (15 - i)) - 1; /* 16bit maximum shift left number15 */
+            huffman->len[i] = ptr[i];
+            huffman->huffman_val_ptr[i] = tab_len;
+            max_code = huffman->max_code[i] + 1;
+            *error_flag |= (unsigned int)((huffman->max_code[i] + 1) > (1 << (i + 1)));
+        } else {
+            huffman->min_code[i] = (unsigned int)max_code << 1;
+            huffman->max_code[i] = -1;
+            huffman->max_code16[i] = -1;
+            huffman->len[i] = 0;
+            huffman->huffman_val_ptr[i] = tab_len;
+            max_code = (unsigned int)max_code << 1;
+        }
+        tab_len += ptr[i];
+    }
+    huffman->max_code16[JPEGD_CODE_LEN - 1] = 0x0000ffff; /* 0x0000ffff:default value */
+    huffman->max_code[JPEGD_CODE_LEN - 1] = huffman->min_code[JPEGD_CODE_LEN - 1] + ptr[JPEGD_CODE_LEN - 1] - 1;
+    *str += JPEGD_CODE_LEN;
+    return tab_len;
+}
+
+void jpegd_decode_dht_huffman_val(huffman_tab *huffman, const unsigned char **str, const unsigned char *ptr,
+    unsigned int tab_len)
+{
+    unsigned int i;
+    unsigned int ii = 0;
+    unsigned int jj;
+    const unsigned char *stream = *str;
+    for (i = 0; i < sizeof(huffman->huffman_val); i++) {
+        huffman->huffman_val[i] = 0;
+    }
+    for (i = 0; (i < tab_len) && (i < JPEGD_HUFFMAN_LEN); i++) {
+        huffman->huffman_val[i] = *stream++;
+    }
+
+    for (i = 0, jj = 0; i < 8; i++) { /* finds the first 8 codes when Lookup table */
+        for (ii = 0; ii < ptr[i]; ii++) {
+            int count = 1 << (7 - i); /* 7:finds the first 8 codes when Lookup table */
+            unsigned char huffmancode = huffman->huffman_val[huffman->huffman_val_ptr[i] + ii];
+            while ((count-- != 0) && (jj < JPEGD_HUFFMAN_LEN)) {
+                huffman->fast_huffman_len[jj] = i + 1;
+                huffman->fast_huffman_code[jj++] = huffmancode;
+            }
+        }
+    }
+    huffman->u_code32 = (jj - 1) << 24; /* Extended 32 bit, set 0 to low 24 bits */
+    *str += tab_len;
+    return;
+}
+
+int decode_dht(motion_jpeg_obj *mjpeg, const unsigned char *stream)
+{
+    huffman_tab *huffman = &mjpeg->huffman_tmp;
+    unsigned int error_flag = 0;
+    unsigned int tab_len;
+    unsigned char ptr[JPEGD_CODE_LEN];
+    unsigned int k = 2; /* 2:DHT maker takes 2 bytes */
+    unsigned int lh;
+    unsigned char code, tc, th;
+
+    lh = (stream[0] << 8) + stream[1]; /* 0,1:The first two bytes are dht length, shift left 8 bits */
+    stream += 2; /* Data length is 2 bytes */
+
+    while (k < lh) {
+        code = *stream++;
+        tc = (code >> 4) & 0x1; /* get top 4 bits 0x1:get 0 bit value */
+        th = code & 0x1; /* 0x1:get 0 bit value */
+        error_flag |= (unsigned int)(code & 0xEE); /* 0xEE:lh max value */
+        if (error_flag != 0) {
+            return GK_JPEG_DEC_DHT_ERR;
+        }
+        tab_len = jpegd_decode_dht_huffman_length(huffman, &stream, ptr, &error_flag);
+        k += 17 + tab_len; /* 17:tc and th take one byte, length take 16 bytes */
+        error_flag |= (unsigned int)(tab_len > 255); /* 255 max table length */
+        if ((k > lh) || error_flag) {
+            return GK_JPEG_DEC_DHT_ERR;
+        }
+
+        jpegd_decode_dht_huffman_val(huffman, &stream, ptr, tab_len);
+        mjpeg->h_tab[(tc << 1) + th] = *huffman;
+    }
+
+    return GK_JPEG_DEC_OK;
+}
+
+unsigned int check_sof_bit(frame_header *header, motion_jpeg_obj *mjpeg, int ls)
+{
+    if (header->color_depth != 8) { /* only support 8 sample precision */
+        return GK_ERR_NOT_BASELINE;
+    }
+
+    if (ls != (header->nf * 3 + 8)) { /* every components takes 3 bytes, previous info take 8 bytes */
+        return GK_ERR_FRAME_HEADER;
+    }
+
+    if ((header->y_height > mjpeg->max_height) || (header->y_height == 0)) {
+        return GK_UNSUPPORT_PIC_SIZE;
+    }
+
+    if ((header->y_width > mjpeg->max_width) || (header->y_width == 0)) {
+        return GK_UNSUPPORT_PIC_SIZE;
+    }
+    if ((header->nf != 3) && (header->nf != 1)) { /* number of components in frame can be 1 or 3 */
+        return GK_UNSUPPORT_PIC_STRUCT;
+    }
+    return GK_SUCCESS;
+}
+
+unsigned int check_sof_component_bit(frame_header *header, motion_jpeg_obj *mjpeg)
+{
+    if (header->nf == 1) {
+        if (header->h[COM0] != 0x11) { /* 0x11: only support H = V = 1 */
+            return GK_UNSUPPORT_PIC_STRUCT;
+        }
+        if (header->tq[COM0] & 0xfc) { /* 0xfc: tq range[0, 3] */
+            return GK_UNSUPPORT_PIC_STRUCT;
+        }
+    } else {
+         /* 0xfc: tq range[0, 3] */
+        if ((header->tq[COM0] & 0xfc) || (header->tq[COM1] & 0xfc) || (header->tq[COM2] & 0xfc)) {
+            return GK_ERR_NOT_BASELINE;
+        }
+         /* 0x41:not support H=4,V=1, 0x14:not support H=1, V=4 */
+        if ((header->h[COM0] == 0x41) || (header->h[COM0] == 0x14)) {
+            return GK_UNSUPPORT_YUV411;
+        }
+
+        if ((header->h[COM1] != 0x11) || (header->h[COM2] != 0x11)) { /* 0x11: chroma component H = V = 1 */
+            return GK_UNSUPPORT_PIC_STRUCT;
+        }
+    }
+    return GK_SUCCESS;
+}
+
+unsigned int get_sof_pic_format(frame_header *header, motion_jpeg_obj *mjpeg)
+{
+    if (header->nf == 1) {
+        mjpeg->width_in_mcu = (header->y_width + 7) >> 3; /* 7 3 each mcu is a DU */
+        mjpeg->height_in_mcu = (header->y_height + 7) >> 3; /* 7 3 each mcu is a DU */
+        mjpeg->y_stride = mjpeg->width_in_mcu << 3; /* 3: each mcu is a DU */
+        mjpeg->pic_format = PICTURE_FORMAT_YUV400;  /* YUV100 */
+    } else {
+        if (header->h[0] == 0x11) { /* 0x11: only support H = V = 1 */
+            mjpeg->width_in_mcu = (header->y_width + 7) >> 3; /* 7 3 each mcu is a DU */
+            mjpeg->height_in_mcu = (header->y_height + 7) >> 3; /* 7 3 each mcu is a DU */
+            mjpeg->y_stride = mjpeg->width_in_mcu << 3; /* 3: each mcu is a DU */
+            mjpeg->c_stride = mjpeg->width_in_mcu << 3; /* 3: each mcu is a DU */
+            mjpeg->pic_format = PICTURE_FORMAT_YUV444;  /* YUV111 */
+        } else if (header->h[0] == 0x22) { /* 0x22: only support H = V = 2 */
+            mjpeg->width_in_mcu = (header->y_width + 15) >> 4; /* 15 4 2 DU wide for each mcu */
+            mjpeg->height_in_mcu = (header->y_height + 15) >> 4; /* 15 4 2 DU height for each mcu */
+            mjpeg->y_stride = mjpeg->width_in_mcu << 4; /* 4: 2 DU wide for each mcu */
+            mjpeg->c_stride = mjpeg->width_in_mcu << 3; /* 3: each mcu is a DU */
+            mjpeg->pic_format = PICTURE_FORMAT_YUV420;  /* YUV420 */
+        } else if (header->h[0] == 0x21) { /* 0x21:support H=2,V=1 */
+            mjpeg->width_in_mcu = (header->y_width + 15) >> 4; /* 15 4 2 DU wide for each mcu */
+            mjpeg->height_in_mcu = (header->y_height + 7) >> 3; /* 7 3 each mcu is a DU */
+            mjpeg->y_stride = mjpeg->width_in_mcu << 4; /* 4: 2 DU wide for each mcu */
+            mjpeg->c_stride = mjpeg->width_in_mcu << 3; /* 3: each mcu is a DU */
+            mjpeg->pic_format = PICTURE_FORMAT_YUV422;  /* YUV422 */
+        } else if (header->h[0] == 0x12) { /* 0x12:support H=2,V=1 */
+            mjpeg->width_in_mcu = (header->y_width + 7) >> 3; /* 7 3 each mcu is a DU */
+            mjpeg->height_in_mcu = (header->y_height + 15) >> 4; /* 15 4 2 DU height for each mcu */
+            mjpeg->y_stride = mjpeg->width_in_mcu << 3; /* 3: each mcu is a DU */
+            mjpeg->c_stride = mjpeg->width_in_mcu << 3; /* 3: each mcu is a DU */
+            mjpeg->pic_format = PICTURE_FORMAT_YUV422V;
+        } else {
+            mjpeg->pic_format = PICTURE_FORMAT_BUTT;  /* do not support */
+            return GK_UNSUPPORT_PIC_STRUCT;
+        }
+    }
+    return GK_SUCCESS;
+}
+
+int decode_sof0(motion_jpeg_obj *mjpeg, const unsigned char *stream)  /* 0xFF C0 */
+{
+    unsigned int error_flag;
+    frame_header header = {0};
+    int ls;
+    int i = 0;
+
+    ls = (stream[0] << 8) + stream[1]; /* 0,1:The first two bytes are SOF length, shift left 8 bits */
+    header.color_depth = stream[2]; /* 2: Sample precision */
+    header.y_height = (stream[3] << 8) + stream[4]; /* 3,4,8:get height */
+    header.y_width = (stream[5] << 8) + stream[6]; /* 5,6,8:get width */
+    header.nf = stream[7]; /* 7:number of components in frame */
+    stream += 8; /* 8:bit number */
+    error_flag = check_sof_bit(&header, mjpeg, ls);
+    if (error_flag != GK_SUCCESS) {
+        gk_trace("CheckSOFBit error:0x%x!\n", error_flag);
+        return error_flag;
+    }
+
+    header.ci[0] = stream[i++];
+    header.h[0] = stream[i++];
+    header.tq[0] = stream[i++]; /* 2 array index */
+
+    if (header.nf == 3) { /* 3 number of components in frame */
+        header.ci[1] = stream[i++]; /* 3 array index */
+        header.h[1] = stream[i++]; /* 4 array index */
+        header.tq[1] = stream[i++]; /* 5 array index */
+        header.ci[2] = stream[i++]; /* 2 6 array index */
+        header.h[2] = stream[i++]; /* 2 7 array index */
+        header.tq[2] = stream[i++]; /* 2 8 array index */
+    }
+    error_flag = check_sof_component_bit(&header, mjpeg);
+    if (error_flag != GK_SUCCESS) {
+        gk_trace("check_sof_component_bit error:0x%x!\n", error_flag);
+        return error_flag;
+    }
+    error_flag = get_sof_pic_format(&header, mjpeg);
+    if (error_flag != GK_SUCCESS) {
+        gk_trace("decode_sof_pic_format error:0x%x!\n", error_flag);
+        return error_flag;
+    }
+    header.max_mcu_number = mjpeg->width_in_mcu * mjpeg->height_in_mcu;
+    header.restart_interval_logic = mjpeg->frame.restart_interval;
+    header.restart_interval = (mjpeg->frame.restart_interval != 0) ?
+        mjpeg->frame.restart_interval : header.max_mcu_number;
+    mjpeg->frame = header;
+    return GK_JPEG_DEC_OK;
+}
+
+int check_sos_bit(motion_jpeg_obj *mjpeg, scan_header *scan, unsigned int index)
+{
+    frame_header *fh = &mjpeg->frame;
+    if (scan->cs[index] != fh->ci[index]) {
+        return GK_ERR_SCAN_HEADER;
+    }
+    if (scan->td[index] > 1 || scan->ta[index] > 1) {
+        return GK_ERR_NOT_BASELINE;
+    }
+    return GK_SUCCESS;
+}
+
+int decode_sos(motion_jpeg_obj *mjpeg, unsigned char *stream)  /* 0xFF DA */
+{
+    unsigned int error_flag = 0;
+    scan_header scan;
+    unsigned char code;
+    unsigned int i;
+    frame_header *fh = &mjpeg->frame;
+    unsigned int ls = (stream[0] << 8) + stream[1]; /* 0,1:The first two bytes are SOF length, shift left 8 bits */
+    unsigned int ns = stream[2]; /* 2:number of components in frame */
+    stream += 3; /* 3 ls and ns 's number of bytes */
+
+    if (ns != fh->nf || ls != ns * 2 + 6 || ns > 4) { /* 2:cs takes 1 byte, td and ta each take 4 bits, else take 6 */
+        return GK_ERR_SCAN_HEADER;
+    }
+
+    for (i = 0; (i < ns) && (error_flag == 0); i++) {
+        scan.cs[i] = *stream++;
+        code = *stream++;
+        scan.td[i] = code >> 4; /* the top 4 bits are ah */
+        scan.ta[i] = code & 0xf; /* 0xf:get low 4 bits */
+        if (i < 3) { /* 3 number of components in frame */
+            mjpeg->q_tab_components[i] = &mjpeg->q_tab[(3 & fh->tq[i])]; /* 3 get low 2 bits */
+            mjpeg->h_tab_components_dc[i] = &mjpeg->h_tab[(1 & scan.td[i])];
+            mjpeg->h_tab_components_ac[i] =
+                &mjpeg->h_tab[2 + (1 & scan.ta[i])]; /* 2 each dc and ac take half of huffman table */
+        }
+
+        error_flag = check_sos_bit(mjpeg, &scan, i);
+        if (error_flag != GK_SUCCESS) {
+            gk_trace("check_sos_bit0 err:0x%x\n", error_flag);
+            return error_flag;
+        }
+    }
+    scan.ns = ns;
+    scan.ss = *stream++;
+    scan.se = *stream++;
+    code = *stream++;
+    scan.ah = code >> 4; /* the top 4 bits are ah */
+    scan.al = code & 0xf; /* 0xf:get low 4 bits */
+
+    if ((scan.ss != 0) || (scan.se != 63) || (scan.ah != 0) || (scan.al != 0)) { /* baseline se must be 63 */
+        return GK_ERR_NOT_BASELINE;
+    }
+
+    if (error_flag == 0) {
+        mjpeg->scan = scan;
+        return GK_JPEG_DEC_OK;
+    } else {
+        return GK_JPEG_DEC_SCAN_ERR;
+    }
+}
+
+int decode_dri(motion_jpeg_obj *mjpeg, const unsigned char *stream)
+{
+    int lr = (stream[0] << 8) + stream[1]; /* 8:shift left */
+    int ri = (stream[2] << 8) + stream[3]; /* 2,3:array index 8:shift left */
+
+    if (lr != 4) { /* DRI data length is 4 */
+        return 1;
+    }
+
+    mjpeg->frame.restart_interval = ri;
+    mjpeg->frame.restart_interval_logic = ri;
+
+    if (mjpeg->frame.max_mcu_number == 0) {
+        mjpeg->frame.restart_interval = ri;
+    } else {
+        mjpeg->frame.restart_interval = (ri == 0) ? mjpeg->frame.max_mcu_number : ri;
+    }
+
+    return 0;
+}
+
+int decode_dqt(motion_jpeg_obj *mjpeg, const unsigned char *stream)
+{
+    unsigned int error_flag = 0;
+    unsigned char *quant = NULL;
+    unsigned int i, code, pq, tq;
+    int k = 2;
+    int lq = (stream[0] << 8) + stream[1]; /* 0,1:The first two bytes are DQT length, shift left 8 bits */
+    stream += 2; /* 2: data length */
+
+    while ((k < lq) && (error_flag == 0)) {
+        k += 65; /* 65 jpegd quant length(64) + 1 */
+        code = *stream++;
+        pq = code >> 4; /* pq:top 4 bits */
+        tq = code & 0xf; /* 0xf:get low 4 bits */
+        error_flag |= (unsigned int)(pq != 0);  /* pq must be 0 in baseline */
+        error_flag |= (unsigned int)(tq > 3);  /* tq should be (0 ~ 3), inclusive */
+        error_flag |= (unsigned int)(k > lq);
+        if (error_flag) {
+            return GK_JPEG_DEC_FRAME_ERR;
+        }
+
+        quant = mjpeg->q_tab[tq & 3].quant; /* 3:Prevent decoding errors and array overflow */
+        for (i = 0; i < 64; i++) { /* 64 jpegd quant length */
+            quant[i] = *stream++;
+        }
+    }
+    return 0;
+}
+
+void init_default_huffman_table(motion_jpeg_obj *mjpeg)
+{
+    int ret;
+    ret = decode_dht(mjpeg, g_default_huffman_table);
+    if (ret != GK_JPEG_DEC_OK) {
+        gk_trace("jpeg decode DHT error!\n");
+    }
+}
+
+void init_default_quant_table(motion_jpeg_obj *mjpeg)
+{
+    int ret;
+    ret = decode_dqt(mjpeg, g_default_quant_table);
+    if (ret != 0) {
+        gk_trace("jpeg decode DQT error!\n");
+    }
+}
+
diff -uraN u-boot-2016.11/product/osd/dec/jpegd_image.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/dec/jpegd_image.h
--- u-boot-2016.11/product/osd/dec/jpegd_image.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/dec/jpegd_image.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __JPEGD_IMAGE_H__
+#define __JPEGD_IMAGE_H__
+#include "jpegd.h"
+#include "jpegd_error.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* End of #ifdef __cplusplus */
+
+int decode_sof0(motion_jpeg_obj *mjpeg, const unsigned char *stream);
+int decode_sos(motion_jpeg_obj *mjpeg, unsigned char *stream);
+int decode_dht(motion_jpeg_obj *mjpeg, const unsigned char *stream);
+int decode_dqt(motion_jpeg_obj *mjpeg, const unsigned char *stream);
+int decode_dri(motion_jpeg_obj *mjpeg, const unsigned char *stream);
+void init_default_huffman_table(motion_jpeg_obj *mjpeg);
+void init_default_quant_table(motion_jpeg_obj *mjpeg);
+
+#ifdef __cplusplus
+}
+#endif /* End of #ifdef __cplusplus */
+
+#endif
diff -uraN u-boot-2016.11/product/osd/dec/jpegd_reg.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/dec/jpegd_reg.h
--- u-boot-2016.11/product/osd/dec/jpegd_reg.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/dec/jpegd_reg.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,911 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __JPEGD_REG_H__
+#define __JPEGD_REG_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* End of #ifdef __cplusplus */
+
+/* Define the union U_JPEG_DEC_START */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int jpeg_dec_start : 1; /* [0]  */
+        unsigned int rst_busy : 1; /* [1]  */
+        unsigned int axi_sep_bypass : 1; /* [2]  */
+        unsigned int reserved_0 : 1; /* [3]  */
+        unsigned int axi_sep_typ : 1; /* [4]  */
+        unsigned int reserved_1 : 27; /* [31..5]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_JPEG_DEC_START;
+
+/* Define the union U_JPEG_RESUME_START */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int jpeg_resume_start : 1;  /* [0] */
+        unsigned int last_resume_in_pic : 1;  /* [1] */
+        unsigned int reserved : 30;  /* [31..2] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_JPEG_RESUME_START;
+
+/* Define the union U_JPEG_STRIDE */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int y_stride : 16;  /* [15..0] */
+        unsigned int uv_stride : 16;  /* [31..16] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_JPEG_STRIDE;
+
+/* Define the union U_PICTURE_SIZE */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int pic_width_in_mcu : 12;  /* [11..0] */
+        unsigned int reserved_0 : 4;  /* [15..12] */
+        unsigned int pic_height_in_mcu : 12;  /* [27..16] */
+        unsigned int reserved_1 : 4;  /* [31..28] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_PICTURE_SIZE;
+
+/* Define the union PICTURE_TYPE */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int pic_type : 3;  /* [2..0] */
+        unsigned int reserved : 29;  /* [31..3] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_PICTURE_TYPE;
+
+/* Define the union U_RGB_OUT_STRIDE */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int jcfg2jdo_out_stride : 16;  /* [15..0] */
+        unsigned int reserved : 16;  /* [31..16] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_RGB_OUT_STRIDE;
+
+/* Define the union U_PD_SUM_CFG_CBCR */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int jcfg2jvld_pd_cb : 16;  /* [15..0] */
+        unsigned int jcfg2jvld_pd_cr : 16;  /* [31..16] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_PD_SUM_CFG_CBCR;
+
+/* Define the union U_PD_SUM_CFG_Y */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int jcfg2jvld_pd_y : 16;  /* [15..0] */
+        unsigned int jcfg2jbs_flag_cur : 1;  /* [16] */
+        unsigned int reserved : 15;  /* [31..17] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_PD_SUM_CFG_Y;
+
+/* Define the union U_FREQ_SCALE */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int freq_scale : 2; /* [1..0]  */
+        unsigned int jidct_emar_en : 1; /* [2] */
+        unsigned int ck_gt_en : 1; /* [3]  */
+        unsigned int outstanding : 4; /* [7..4]  */
+        unsigned int axi_id : 4; /* [11..8] */
+        unsigned int reserved : 20; /* [31..12] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_FREQ_SCALE;
+
+/* Define the union U_OUT_TYPE */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int out_rgb_type_old : 2; /* [1..0]  */
+        unsigned int jidct_yuv420_en : 1; /* [2]  */
+        unsigned int hor_med_en : 1; /* [3]  */
+        unsigned int ver_med_en : 1; /* [4]  */
+        unsigned int dither_en : 1; /* [5]  */
+        unsigned int reserved_0 : 2; /* [7..6]  */
+        unsigned int out_rgb_type : 3; /* [10..8]  */
+        unsigned int reserved_1 : 21; /* [31..11]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_OUT_TYPE;
+
+/* Define the union U_JPGE_ALPHA; */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int jpgd_a : 8;  /* [7..0] */
+        unsigned int reserved : 24;  /* [31..8] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_JPGD_ALPHA;
+
+/* Define the union U_HOR_PHASE0_COEF01 */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int hor_phase0_coef0 : 10;  /* [9..0] */
+        unsigned int reserved_0 : 6;  /* [15..10] */
+        unsigned int hor_phase0_coef1 : 10;  /* [25..16] */
+        unsigned int reserved_1 : 6;  /* [31..26] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_HOR_PHASE0_COEF01;
+
+/* Define the union U_HOR_PHASE0_COEF23 */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int hor_phase0_coef2 : 10;  /* [9..0] */
+        unsigned int reserved_0 : 6;  /* [15..10] */
+        unsigned int hor_phase0_coef3 : 10;  /* [25..16] */
+        unsigned int reserved_1 : 6;  /* [31..26] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_HOR_PHASE0_COEF23;
+
+/* Define the union U_HOR_PHASE0_COEF45 */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int hor_phase0_coef4 : 10;  /* [9..0] */
+        unsigned int reserved_0 : 6;  /* [15..10] */
+        unsigned int hor_phase0_coef5 : 10;  /* [25..16] */
+        unsigned int reserved_1 : 6;  /* [31..26] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_HOR_PHASE0_COEF45;
+
+/* Define the union U_HOR_PHASE0_COEF67 */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int hor_phase0_coef6 : 10;  /* [9..0] */
+        unsigned int reserved_0 : 6;  /* [15..10] */
+        unsigned int hor_phase0_coef7 : 10;  /* [25..16] */
+        unsigned int reserved_1 : 6;  /* [31..26] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_HOR_PHASE0_COEF67;
+
+/* Define the union U_HOR_PHASE2_COEF01 */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int hor_phase2_coef0 : 10;  /* [9..0] */
+        unsigned int reserved_0 : 6;  /* [15..10] */
+        unsigned int hor_phase2_coef1 : 10;  /* [25..16] */
+        unsigned int reserved_1 : 6;  /* [31..26] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_HOR_PHASE2_COEF01;
+
+/* Define the union U_HOR_PHASE2_COEF23 */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int hor_phase2_coef2 : 10;  /* [9..0] */
+        unsigned int reserved_0 : 6;  /* [15..10] */
+        unsigned int hor_phase2_coef3 : 10;  /* [25..16] */
+        unsigned int reserved_1 : 6;  /* [31..26] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_HOR_PHASE2_COEF23;
+
+/* Define the union U_HOR_PHASE2_COEF45 */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int hor_phase2_coef4 : 10;  /* [9..0] */
+        unsigned int reserved_0 : 6;  /* [15..10] */
+        unsigned int hor_phase2_coef5 : 10;  /* [25..16] */
+        unsigned int reserved_1 : 6;  /* [31..26] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_HOR_PHASE2_COEF45;
+
+/* Define the union U_HOR_PHASE2_COEF67 */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int hor_phase2_coef6 : 10;  /* [9..0] */
+        unsigned int reserved_0 : 6;  /* [15..10] */
+        unsigned int hor_phase2_coef7 : 10;  /* [25..16] */
+        unsigned int reserved_1 : 6;  /* [31..26] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_HOR_PHASE2_COEF67;
+
+/* Define the union U_VER_PHASE0_COEF01 */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int ver_phase0_coef0 : 10;  /* [9..0] */
+        unsigned int reserved_0 : 6;  /* [15..10] */
+        unsigned int ver_phase0_coef1 : 10;  /* [25..16] */
+        unsigned int reserved_1 : 6;  /* [31..26] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_VER_PHASE0_COEF01;
+
+/* Define the union U_VER_PHASE0_COEF23 */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int ver_phase0_coef2 : 10;  /* [9..0] */
+        unsigned int reserved_0 : 6;  /* [15..10] */
+        unsigned int ver_phase0_coef3 : 10;  /* [25..16] */
+        unsigned int reserved_1 : 6;  /* [31..26] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_VER_PHASE0_COEF23;
+
+/* Define the union U_VER_PHASE2_COEF01 */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int ver_phase2_coef0 : 10;  /* [9..0] */
+        unsigned int reserved_0 : 6;  /* [15..10] */
+        unsigned int ver_phase2_coef1 : 10;  /* [25..16] */
+        unsigned int reserved_1 : 6;  /* [31..26] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_VER_PHASE2_COEF01;
+
+/* Define the union U_VER_PHASE2_COEF23 */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int ver_phase2_coef2 : 10;  /* [9..0] */
+        unsigned int reserved_0 : 6;  /* [15..10] */
+        unsigned int ver_phase2_coef3 : 10;  /* [25..16] */
+        unsigned int reserved_1 : 6;  /* [31..26] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_VER_PHASE2_COEF23;
+
+/* Define the union U_CSC_IN_DC_COEF */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int csc_in_dc_coef0 : 9;  /* [8..0] */
+        unsigned int reserved_0 : 1;  /* [9] */
+        unsigned int csc_in_dc_coef1 : 9;  /* [18..10] */
+        unsigned int reserved_1 : 1;  /* [19] */
+        unsigned int csc_in_dc_coef2 : 9;  /* [28..20] */
+        unsigned int reserved_2 : 3;  /* [31..29] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_CSC_IN_DC_COEF;
+
+/* Define the union U_CSC_OUT_DC_COEF */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int csc_out_dc_coef0 : 9;  /* [8..0] */
+        unsigned int reserved_0 : 1;  /* [9] */
+        unsigned int csc_out_dc_coef1 : 9;  /* [18..10] */
+        unsigned int reserved_1 : 1;  /* [19] */
+        unsigned int csc_out_dc_coef2 : 9;  /* [28..20] */
+        unsigned int reserved_2 : 3;  /* [31..29] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_CSC_OUT_DC_COEF;
+
+/* Define the union U_CSC_TRANS_COEF0 */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int csc_p_00 : 15;  /* [14..0] */
+        unsigned int reserved_0 : 1;  /* [15] */
+        unsigned int csc_p_01 : 15;  /* [30..16] */
+        unsigned int reserved_1 : 1;  /* [31] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_CSC_TRANS_COEF0;
+
+/* Define the union U_CSC_TRANS_COEF1 */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int csc_p_02 : 15;  /* [14..0] */
+        unsigned int reserved_0 : 1;  /* [15] */
+        unsigned int csc_p_10 : 15;  /* [30..16] */
+        unsigned int reserved_1 : 1;  /* [31] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_CSC_TRANS_COEF1;
+
+/* Define the union U_CSC_TRANS_COEF2 */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int csc_p_11 : 15;  /* [14..0] */
+        unsigned int reserved_0 : 1;  /* [15] */
+        unsigned int csc_p_12 : 15;  /* [30..16] */
+        unsigned int reserved_1 : 1;  /* [31] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_CSC_TRANS_COEF2;
+
+/* Define the union U_CSC_TRANS_COEF3 */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int csc_p_20 : 15;  /* [14..0] */
+        unsigned int reserved_0 : 1;  /* [15] */
+        unsigned int csc_p_21 : 15;  /* [30..16] */
+        unsigned int reserved_1 : 1;  /* [31] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_CSC_TRANS_COEF3;
+
+/* Define the union U_CSC_TRANS_COEF4 */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int csc_p_22 : 15;  /* [14..0] */
+        unsigned int reserved : 17;  /* [31..15] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_CSC_TRANS_COEF4;
+
+/* Define the union U_MCU_PRO_STARTPOS */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int jcfg2jvld_mcu_starty : 12;  /* [11..0] */
+        unsigned int reserved : 20;  /* [31..12] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_MCU_PRO_STARTPOS;
+
+/* Define the union U_PICCUT_STARTPOS */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int jcfg2jytr_pic_startx : 15; /* [14..0]  */
+        unsigned int reserved_0 : 1; /* [15]  */
+        unsigned int jcfg2jytr_pic_starty : 15; /* [30..16]  */
+        unsigned int reserved_1 : 1; /* [31]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_PICCUT_STARTPOS;
+
+/* Define the union U_PICCUT_ENDPOS */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int jcfg2jytr_pic_endx : 15; /* [14..0]  */
+        unsigned int reserved_0 : 1; /* [15]  */
+        unsigned int jcfg2jytr_pic_endy : 15; /* [30..16]  */
+        unsigned int reserved_1 : 1; /* [31]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_PICCUT_ENDPOS;
+
+/* Define the union U_MCU_PRO_CURPOS */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int jvld2jcfg_mcu_y : 12;  /* [11..0] */
+        unsigned int reserved : 20;  /* [31..12] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_MCU_PRO_CURPOS;
+
+/* Define the union U_BS_RES_BIT_CFG */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int jcfg2jbs_bs_remain : 7;  /* [6..0] */
+        unsigned int reserved : 25;  /* [31..7] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_BS_RES_BIT_CFG;
+
+/* Define the union U_JPEG_INT */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int int_dec_fnsh : 1;  /* [0] */
+        unsigned int int_dec_err : 1;  /* [1] */
+        unsigned int int_bs_res : 1;  /* [2] */
+        unsigned int debug_state : 1;  /* [3] */
+        unsigned int int_over_time : 1;  /* [4] */
+        unsigned int reserved : 27;  /* [31..5] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_JPEG_INT;
+
+/* Define the union U_INT_MASK */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int intm_dec_fnsh : 1;  /* [0] */
+        unsigned int intm_dec_err : 1;  /* [1] */
+        unsigned int intm_bs_res : 1;  /* [2] */
+        unsigned int reserved_0 : 1;  /* [3] */
+        unsigned int intm_over_time : 1;  /* [4] */
+        unsigned int reserved_1 : 27;  /* [31..5] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_INT_MASK;
+
+/* Define the union U_PD_SUM_Y */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int jvld2jcfg_pd_y : 16;  /* [15..0] */
+        unsigned int jbs2jcfg_flag_cur : 1;  /* [16] */
+        unsigned int reserved : 15;  /* [31..17] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_PD_SUM_Y;
+
+/* Define the union U_PD_SUM_CBCR */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int jvld2jcfg_pd_cb : 16;  /* [15..0] */
+        unsigned int jvld2jcfg_pd_cr : 16;  /* [31..16] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_PD_SUM_CBCR;
+
+/* Define the union U_LUMA_PIX_SUM1 */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int luma_pix_sum1 : 4;  /* [3..0] */
+        unsigned int reserved : 27;  /* [30..4] */
+        unsigned int jidct_luma_sum_en : 1;  /* [31] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_LUMA_PIX_SUM1;
+
+/* Define the union U_AXI_4K_CNT */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int wr_over_4k_cnt : 16;  /* [15..0] */
+        unsigned int rd_over_4k_cnt : 16;  /* [31..16] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_AXI_4K_CNT;
+
+/* Define the union U_AXI_16M_CNT */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int wr_over_16m_cnt : 16;  /* [15..0] */
+        unsigned int rd_over_16m_cnt : 16;  /* [31..16] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_AXI_16M_CNT;
+
+/* Define the union U_SAMPLING_FACTOR */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int v_fac : 8;  /* [7..0] */
+        unsigned int u_fac : 8;  /* [15..8] */
+        unsigned int y_fac : 8;  /* [23..16] */
+        unsigned int reserved : 8;  /* [31..24] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_SAMPLING_FACTOR;
+
+/* Define the union U_DRI */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int jcfg2jvld_ri : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16; /* [31..16]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_DRI;
+
+/* Define the union U_DRI_CNT_CFG */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int jcfg2jvld_dri_cnt : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16; /* [31..16]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_DRI_CNT_CFG;
+
+/* Define the union U_DRI_CNT */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int jvld2jcfg_dri_cnt : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16; /* [31..16]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_DRI_CNT;
+
+/* Define the union U_MEM_CTRL */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int mem_ctrl_rfs : 16; /* [15..0]  */
+        unsigned int mem_ctrl_rft : 16; /* [31..16]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_MEM_CTRL;
+
+/* Define the union U_BITBUFFER_STADDR_MSB */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int bb_staddr_msb : 2; /* [1..0]  */
+        unsigned int reserved_0 : 30; /* [31..2]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_BITBUFFER_STADDR_MSB;
+
+/* Define the union U_BITBUFFER_ENDADDR_MSB */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int bb_endaddr_msb : 2; /* [1..0]  */
+        unsigned int reserved_0 : 30; /* [31..2]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_BITBUFFER_ENDADDR_MSB;
+
+/* Define the union U_BITSTREAM_STADDR_MSB */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int bs_staddr_msb : 2; /* [1..0]  */
+        unsigned int reserved_0 : 30; /* [31..2]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_BITSTREAMS_STADDR_MSB;
+
+/* Define the union U_BITSTREAM_ENDADDR_MSB */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int bs_endaddr_msb : 2; /* [1..0]  */
+        unsigned int reserved_0 : 30; /* [31..2]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_BITSTREAMS_ENDADDR_MSB;
+
+/* Define the union U_PICTURE_YSTADDR_MSB */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int pic_ystaddr_msb : 2; /* [1..0]  */
+        unsigned int reserved_0 : 30; /* [31..2]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_PICTURE_YSTADDR_MSB;
+
+/* Define the union U_PICTURE_UVSTADDR_MSB */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int pic_uvstaddr_msb : 2; /* [1..0]  */
+        unsigned int reserved_0 : 30; /* [31..2]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_PICTURE_UVSTADDR_MSB;
+
+/* Define the union U_MTN_ADDRESS0_MSB */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int mtn_address0_msb : 2; /* [1..0]  */
+        unsigned int reserved_0 : 30; /* [31..2]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_MTN_ADDRESS0_MSB;
+
+/* Define the union U_MTN_ADDRESS1_MSB */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int mtn_address1_msb : 2; /* [1..0]  */
+        unsigned int reserved_0 : 30; /* [31..2]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_MTN_ADDRESS1_MSB;
+
+/* Define the union U_QUANT_TABLE */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int qtab_y : 8;  /* [7..0] */
+        unsigned int qtab_cb : 8;  /* [15..8] */
+        unsigned int qtab_cr : 8;  /* [23..16] */
+        unsigned int reserved : 8;  /* [31..24] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_QUANT_TABLE;
+
+/* Define the union U_HDC_TABLE */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int hdc_lu : 12;  /* [11..0] */
+        unsigned int hdc_ch : 12;  /* [23..12] */
+        unsigned int reserved : 8;  /* [31..24] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_HDC_TABLE;
+
+/* Define the union U_HAC_MIN_TABLE */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int hac_lu_mincode_even : 8;  /* [7..0] */
+        unsigned int hac_lu_mincode_odd : 8;  /* [15..8] */
+        unsigned int hac_ch_mincode_even : 8;  /* [23..16] */
+        unsigned int hac_ch_mincode_odd : 8;  /* [31..24] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_HAC_MIN_TABLE;
+
+/* Define the union U_HAC_BASE_TABLE */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int hac_lu_base_even : 8;  /* [7..0] */
+        unsigned int hac_lu_base_odd : 8;  /* [15..8] */
+        unsigned int hac_ch_base_even : 8;  /* [23..16] */
+        unsigned int hac_ch_base_odd : 8;  /* [31..24] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_HAC_BASE_TABLE;
+
+/* Define the union U_HAC_SYMBOL_TABLE */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int sel2_chn_wr : 8; /* [7..0]  */
+        unsigned int sel1_chn_wr : 8; /* [15..8]  */
+        unsigned int sel2_chn_rd : 8; /* [23..16]  */
+        unsigned int reserved_0 : 8; /* [31..24]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} U_HAC_SYMBOL_TABLE;
+
+/* Define the global struct */
+typedef struct {
+    volatile U_JPEG_DEC_START JPEG_DEC_START;  /* 0x00 */
+    volatile U_JPEG_RESUME_START JPEG_RESUME_START;  /* 0x04 */
+    volatile unsigned int PIC_VLD_NUM;  /* 0x08 */
+    volatile U_JPEG_STRIDE JPEG_STRIDE;  /* 0x0c */
+    volatile U_PICTURE_SIZE PICTURE_SIZE;  /* 0x10 */
+    volatile U_PICTURE_TYPE PICTURE_TYPE;  /* 0x14 */
+    volatile unsigned int PICDEC_TIME;  /* 0x18 */
+    volatile U_RGB_OUT_STRIDE RGB_OUT_STRIDE;  /* 0x1c */
+    volatile unsigned int BITBUFFER_STADDR_LSB;  /* 0x20 */
+    volatile unsigned int BITBUFFER_ENDADDR_LSB;  /* 0x24 */
+    volatile unsigned int BITSTREAMS_STADDR_LSB;  /* 0x28 */
+    volatile unsigned int BITSTREAMS_ENDADDR_LSB;  /* 0x2C */
+    volatile unsigned int PICTURE_YSTADDR_LSB;  /* 0x30 */
+    volatile unsigned int PICTURE_UVSTADDR_LSB;
+    volatile U_PD_SUM_CFG_CBCR PD_SUM_CFG_CBCR;
+    volatile U_PD_SUM_CFG_Y PD_SUM_CFG_Y;
+    volatile U_FREQ_SCALE FREQ_SCALE;  /* 0x40 */
+    volatile U_OUT_TYPE OUT_TYPE;
+    volatile U_JPGD_ALPHA JPGD_ALPHA;
+    volatile U_HOR_PHASE0_COEF01 HOR_PHASE0_COEF01;  /* 0x4c */
+    volatile U_HOR_PHASE0_COEF23 HOR_PHASE0_COEF23;  /* 0x50 */
+    volatile U_HOR_PHASE0_COEF45 HOR_PHASE0_COEF45;  /* 0x54 */
+    volatile U_HOR_PHASE0_COEF67 HOR_PHASE0_COEF67;  /* 0x58 */
+    volatile unsigned int RESERVED0[4];  /* 0x5c 0x60 0x64 0x68 */
+    volatile U_HOR_PHASE2_COEF01 HOR_PHASE2_COEF01;  /* 0x6c */
+    volatile U_HOR_PHASE2_COEF23 HOR_PHASE2_COEF23;  /* 0x70 */
+    volatile U_HOR_PHASE2_COEF45 HOR_PHASE2_COEF45;  /* 0x74 */
+    volatile U_HOR_PHASE2_COEF67 HOR_PHASE2_COEF67;  /* 0x78 */
+    volatile unsigned int RESERVED1[4];  /* 0x7c 0x80 0x84 0x88 */
+    volatile U_VER_PHASE0_COEF01 VER_PHASE0_COEF01;  /* 0x8C */
+    volatile U_VER_PHASE0_COEF23 VER_PHASE0_COEF23;  /* 0x90 */
+    volatile unsigned int RESERVED2[2];  /* 2:0x94 0x98 */
+    volatile U_VER_PHASE2_COEF01 VER_PHASE2_COEF01;  /* 0x9c */
+    volatile U_VER_PHASE2_COEF23 VER_PHASE2_COEF23;  /* 0xA0 */
+    volatile unsigned int RESERVED3[2];  /* 2:0xA4 0xA8 */
+    volatile U_CSC_IN_DC_COEF CSC_IN_DC_COEF;  /* 0xAC */
+    volatile U_CSC_OUT_DC_COEF CSC_OUT_DC_COEF;  /* 0xB0 */
+    volatile U_CSC_TRANS_COEF0 CSC_TRANS_COEF0;  /* 0xB4 */
+    volatile U_CSC_TRANS_COEF1 CSC_TRANS_COEF1;  /* 0xB8 */
+    volatile U_CSC_TRANS_COEF2 CSC_TRANS_COEF2;  /* 0xBC */
+    volatile U_CSC_TRANS_COEF3 CSC_TRANS_COEF3;  /* 0xC0 */
+    volatile U_CSC_TRANS_COEF4 CSC_TRANS_COEF4;  /* 0xC4 */
+    volatile unsigned int MTN_ADDRESS0_LSB;  /* 0xC8 */
+    volatile unsigned int MTN_ADDRESS1_LSB;  /* 0xCC */
+    volatile unsigned int RESERVED4;  /* 0xD0 */
+    volatile U_MCU_PRO_STARTPOS MCU_PRO_STARTPOS;  /* 0xD4 */
+    volatile U_PICCUT_STARTPOS PICCUT_STARTPOS;  /* 0xD8 */
+    volatile U_PICCUT_ENDPOS PICCUT_ENDPOS;  /* 0xDC */
+    volatile U_MCU_PRO_CURPOS MCU_PRO_CURPOS;  /* 0xE0 */
+    volatile unsigned int BS_CONSU;  /* 0xE4 */
+    volatile unsigned int BS_RESUME_DATA0;  /* 0xE8 */
+    volatile unsigned int BS_RESUME_DATA1;  /* 0xEC */
+    volatile unsigned int BS_RESUME_BIT;  /* 0xF0 */
+    volatile unsigned int BS_RES_DATA_CFG0;  /* 0xF4 */
+    volatile unsigned int BS_RES_DATA_CFG1;  /* 0xF8 */
+    volatile U_BS_RES_BIT_CFG BS_RES_BIT_CFG;  /* 0xFC */
+    volatile U_JPEG_INT JPEG_INT;  /* 0x100 */
+    volatile U_INT_MASK INT_MASK;  /* 0x104 */
+    volatile unsigned int OVER_TIME_THD;  /* 0x108 */
+    volatile U_PD_SUM_Y PD_SUM_Y;  /* 0x10C */
+    volatile U_PD_SUM_CBCR PD_SUM_CBCR;  /* 0x110 */
+    volatile unsigned int LUMA_PIX_SUM0;  /* 0x114 */
+    volatile U_LUMA_PIX_SUM1 LUMA_PIX_SUM1;  /* 0x118 */
+    volatile U_AXI_4K_CNT AXI_4K_CNT;  /* 0x11C */
+    volatile U_AXI_16M_CNT AXI_16M_CNT;  /* 0x120 */
+    volatile U_SAMPLING_FACTOR SAMPLING_FACTOR;  /* 0x124 */
+    volatile U_DRI DRI; /* 0x128 */
+    volatile U_DRI_CNT_CFG DRI_CNT_CFG; /* 0x12c */
+    volatile U_DRI_CNT DRI_CNT; /* 0x130 */
+    volatile unsigned int RESERVED5[3];  /* 0x134 0x138    0x13c */
+    volatile U_MEM_CTRL MEM_CTRL; /* 0x140 */
+    volatile unsigned int RESERVED6; /* 0x144 */
+    volatile U_BITBUFFER_STADDR_MSB BITBUFFER_STADDR_MSB; /* 0x148 */
+    volatile U_BITBUFFER_ENDADDR_MSB BITBUFFER_ENDADDR_MSB; /* 0x14c */
+    volatile U_BITSTREAMS_STADDR_MSB BITSTREAMS_STADDR_MSB; /* 0x150 */
+    volatile U_BITSTREAMS_ENDADDR_MSB BITSTREAMS_ENDADDR_MSB; /* 0x154 */
+    volatile U_PICTURE_YSTADDR_MSB PICTURE_YSTADDR_MSB; /* 0x158 */
+    volatile U_PICTURE_UVSTADDR_MSB PICTURE_UVSTADDR_MSB; /* 0x15c */
+    volatile U_MTN_ADDRESS0_MSB MTN_ADDRESS0_MSB; /* 0x160 */
+    volatile U_MTN_ADDRESS1_MSB MTN_ADDRESS1_MSB; /* 0x164 */
+    volatile unsigned int RESERVED7[38]; /* 38:0x168~0x1fc */
+    volatile U_QUANT_TABLE QUANT_TABLE[64]; /* 64:0x200~0x2fc */
+    volatile U_HDC_TABLE HDC_TABLE[12]; /* 12:0x300~0x32c */
+    volatile unsigned int RESERVED8[4]; /* 4:0x330~0x33c */
+    volatile U_HAC_MIN_TABLE HAC_MIN_TABLE[8]; /* 8:0x340~0x35c */
+    volatile U_HAC_BASE_TABLE HAC_BASE_TABLE[8]; /* 8:0x360~0x37c */
+    volatile unsigned int RESERVED9[32]; /* 32:0x380~0x3fc */
+    volatile unsigned int HAC_SYMBOL_TABLE[176]; /* 176:0x400~0x6c0 */
+} S_JPGD_REGS_TYPE;
+
+#ifdef __cplusplus
+}
+#endif /* End of #ifdef __cplusplus */
+
+#endif
diff -uraN u-boot-2016.11/product/osd/dec/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/dec/Makefile
--- u-boot-2016.11/product/osd/dec/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/dec/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,5 @@
+obj-y += jpegd_entry.o
+obj-y += jpegd.o
+obj-y += jpegd_drv.o
+obj-y += jpegd_image.o
+
diff -uraN u-boot-2016.11/product/osd/dec/type.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/dec/type.h
--- u-boot-2016.11/product/osd/dec/type.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/dec/type.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __GK_TYPE_H__
+#define __GK_TYPE_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/* ----------------------------------------------*
+ * const defination                             *
+ * ---------------------------------------------- */
+typedef enum {
+    GK_FALSE = 0,
+    GK_TRUE = 1,
+} gk_bool;
+
+#ifndef NULL
+#define NULL       0L
+#endif
+
+#define GK_NULL    0L
+#define GK_SUCCESS 0
+#define GK_FAILURE (-1)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __GK_TYPE_H__ */
diff -uraN u-boot-2016.11/product/osd/include/common.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/include/common.h
--- u-boot-2016.11/product/osd/include/common.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/include/common.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,327 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __GK_COMMON_H__
+#define __GK_COMMON_H__
+
+#include "type.h"
+#include "defines.h"
+#ifndef __KERNEL__
+#include "securec.h"
+#endif
+
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#ifndef VER_X
+#define VER_X                  1
+#endif
+
+#ifndef VER_Y
+#define VER_Y                  0
+#endif
+
+#ifndef VER_Z
+#define VER_Z                  0
+#endif
+
+#ifndef VER_P
+#define VER_P                  0
+#endif
+
+#ifndef VER_B
+#define VER_B                  0
+#endif
+
+#ifdef GK_DEBUG
+#define VER_D                  " Debug"
+#else
+#define VER_D                  " Release"
+#endif
+
+#define GK_COMPAT_POINTER(ptr, type) \
+    do { \
+        gk_ulong ulAddr = (gk_ulong)ptr; \
+        gk_u32 u32Addr = (gk_u32)ulAddr; \
+        ptr = (type)(gk_ulong)u32Addr; \
+    } while (0)
+
+#define __MK_VERSION(x, y, z, p, b) #x "." #y "." #z "." #p " B0" #b
+#define MK_VERSION(x, y, z, p, b) __MK_VERSION(x, y, z, p, b)
+#define GK_MPP_VERSION            GK_CHIP_NAME GK_MPP_VER_PRIX MK_VERSION(VER_X, VER_Y, VER_Z, VER_P, VER_B) VER_D
+
+
+#define GK_MAX_VERSION_NAME_LEN    64
+#define GK_INVALID_CHN         (-1)
+#define GK_INVALID_WAY         (-1)
+#define GK_INVALID_LAYER       (-1)
+#define GK_INVALID_DEV         (-1)
+#define GK_INVALID_HANDLE      (-1)
+#define GK_INVALID_VALUE       (-1)
+#define GK_INVALID_TYPE        (-1)
+
+#define GK_MPP_MOD_VI             "vi"
+#define GK_MPP_MOD_VO             "vo"
+#define GK_MPP_MOD_AVS            "avs"
+#define GK_MPP_MOD_HDMI           "hdmi"
+#define GK_MPP_MOD_VGS            "vgs"
+#define GK_MPP_MOD_GDC            "gdc"
+#define GK_MPP_MOD_DIS            "dis"
+#define GK_MPP_MOD_GYRODIS        "gyrodis"
+#define GK_MPP_MOD_CHNL           "chnl"
+#define GK_MPP_MOD_VENC           "venc"
+#define GK_MPP_MOD_VPSS           "vpss"
+#define GK_MPP_MOD_RGN            "rgn"
+#define GK_MPP_MOD_IVE            "ive"
+#define GK_MPP_MOD_FD             "fd"
+#define GK_MPP_MOD_MD             "md"
+#define GK_MPP_MOD_IVP            "ivp"
+#define GK_MPP_MOD_SVP            "svp"
+#define GK_MPP_MOD_SVP_NNIE       "nnie"
+#define GK_MPP_MOD_SVP_DSP        "dsp"
+#define GK_MPP_MOD_SVP_ALG        "svp_alg"
+#define GK_MPP_MOD_DPU_RECT       "rect"
+#define GK_MPP_MOD_DPU_MATCH      "match"
+#define GK_MPP_MOD_SVP_MAU        "mau"
+#define GK_MPP_MOD_H264E          "h264e"
+#define GK_MPP_MOD_H265E          "h265e"
+#define GK_MPP_MOD_JPEGE          "jpege"
+#define GK_MPP_MOD_MPEG4E         "mpeg4e"
+#define GK_MPP_MOD_VEDU           "vedu"
+#define GK_MPP_MOD_PRORES         "prores"
+#define GK_MPP_MOD_VDEC           "vdec"
+#define GK_MPP_MOD_H264D          "h264d"
+#define GK_MPP_MOD_JPEGD          "jpegd"
+#define GK_MPP_MOD_AI             "ai"
+#define GK_MPP_MOD_AO             "ao"
+#define GK_MPP_MOD_AENC           "aenc"
+#define GK_MPP_MOD_ADEC           "adec"
+#define GK_MPP_MOD_AIO            "aio"
+#define GK_MPP_MOD_ACODEC         "acodec"
+#define GK_MPP_MOD_VB             "vb"
+#define GK_MPP_MOD_SYS            "sys"
+#define GK_MPP_MOD_CMPI           "cmpi"
+#define GK_MPP_MOD_PCIV           "pciv"
+#define GK_MPP_MOD_PCIVFMW        "pcivfmw"
+#define GK_MPP_MOD_PROC           "proc"
+#define GK_MPP_MOD_LOG            "logmpp"
+#define GK_MPP_MOD_FB             "fb"
+#define GK_MPP_MOD_RC             "rc"
+#define GK_MPP_MOD_TDE            "tde"
+#define GK_MPP_MOD_ISP            "isp"
+#define GK_MPP_MOD_USR            "usr"
+#define GK_MPP_MOD_MCF            "mcf"
+#define GK_MPP_MOD_PM             "pm"
+#define GK_MPP_MOD_MFUSION        "motionfusion"
+#define GK_MPP_MOD_VDA            "vda"
+
+typedef struct {
+    gk_char version[GK_MAX_VERSION_NAME_LEN];
+} gk_mpp_version;
+
+typedef gk_s32 gk_ai_chn;
+typedef gk_s32 gk_ao_chn;
+typedef gk_s32 gk_aenc_chn;
+typedef gk_s32 gk_adec_chn;
+typedef gk_s32 gk_audio_dev;
+typedef gk_s32 gk_vi_dev;
+typedef gk_s32 gk_vi_pipe;
+typedef gk_s32 gk_vi_way;
+typedef gk_s32 gk_vi_chn;
+typedef gk_s32 gk_vo_dev;
+typedef gk_s32 gk_vo_layer;
+typedef gk_s32 gk_vo_chn;
+typedef gk_s32 gk_vo_wbc;
+typedef gk_s32 gk_gfx_layer;
+typedef gk_s32 gk_venc_chn;
+typedef gk_s32 gk_vdec_chn;
+typedef gk_s32 gk_ive_handle;
+typedef gk_s32 gk_fd_chn;
+typedef gk_s32 gk_md_chn;
+typedef gk_s32 gk_sensor_id;
+typedef gk_s32 gk_mipi_dev;
+typedef gk_s32 gk_slave_dev;
+typedef gk_s32 gk_svp_nnie_handle;
+typedef gk_s32 gk_svp_dsp_handle;
+typedef gk_s32 gk_svp_alg_chn;
+typedef gk_s32 gk_svp_mau_handle;
+typedef gk_s32 gk_vpss_grp;
+typedef gk_s32 gk_vpss_grp_pipe;
+typedef gk_s32 gk_vpss_chn;
+typedef gk_s32 gk_avs_grp;
+typedef gk_s32 gk_avs_pipe;
+typedef gk_s32 gk_avs_chn;
+typedef gk_s32 gk_mcf_grp;
+typedef gk_s32 gk_mcf_pipe;
+typedef gk_s32 gk_mcf_chn;
+typedef gk_s32 gk_vda_chn;
+typedef gk_s32 gk_pciv_chn;
+
+typedef enum {
+    GK_ID_CMPI    = 0,
+    GK_ID_VB      = 1,
+    GK_ID_SYS     = 2,
+    GK_ID_RGN      = 3,
+    GK_ID_CHNL    = 4,
+    GK_ID_VDEC    = 5,
+    GK_ID_AVS     = 6,
+    GK_ID_VPSS    = 7,
+    GK_ID_VENC    = 8,
+    GK_ID_SVP     = 9,
+    GK_ID_H264E   = 10,
+    GK_ID_JPEGE   = 11,
+    GK_ID_H265E   = 13,
+    GK_ID_JPEGD   = 14,
+    GK_ID_VO      = 15,
+    GK_ID_VI      = 16,
+    GK_ID_DIS     = 17,
+    GK_ID_VALG    = 18,
+    GK_ID_RC      = 19,
+    GK_ID_AIO     = 20,
+    GK_ID_AI      = 21,
+    GK_ID_AO      = 22,
+    GK_ID_AENC    = 23,
+    GK_ID_ADEC    = 24,
+    GK_ID_VPU    = 25,
+    GK_ID_PCIV    = 26,
+    GK_ID_PCIVFMW = 27,
+    GK_ID_ISP      = 28,
+    GK_ID_IVE      = 29,
+    GK_ID_USER    = 30,
+    GK_ID_PROC    = 33,
+    GK_ID_LOG     = 34,
+    GK_ID_VFMW    = 35,
+    GK_ID_GDC     = 37,
+    GK_ID_PHOTO   = 38,
+    GK_ID_FB      = 39,
+    GK_ID_HDMI    = 40,
+    GK_ID_VOIE    = 41,
+    GK_ID_TDE     = 42,
+    GK_ID_HDR      = 43,
+    GK_ID_PRORES  = 44,
+    GK_ID_VGS     = 45,
+    GK_ID_FD      = 47,
+    GK_ID_OD      = 48,
+    GK_ID_LPR      = 50,
+    GK_ID_SVP_NNIE     = 51,
+    GK_ID_SVP_DSP      = 52,
+    GK_ID_DPU_RECT     = 53,
+    GK_ID_DPU_MATCH    = 54,
+
+    GK_ID_MOTIONSENSOR = 55,
+    GK_ID_MOTIONFUSION = 56,
+
+    GK_ID_GYRODIS      = 57,
+    GK_ID_PM           = 58,
+    GK_ID_SVP_ALG      = 59,
+	GK_ID_IVP          = 60,
+	GK_ID_MCF          = 61,
+    GK_ID_SVP_MAU      = 62,
+    GK_ID_VDA     = 63,
+
+    GK_ID_BUTT,
+} gk_mod_id;
+
+typedef struct {
+    gk_mod_id    mod_id;
+    gk_s32      dev_id;
+    gk_s32      chn_id;
+} gk_mpp_chn;
+
+/* We just coyp this value of payload type from RTP/RTSP definition */
+typedef enum {
+        GK_PT_PCMU          = 0,
+        GK_PT_1016          = 1,
+        GK_PT_G721          = 2,
+        GK_PT_GSM           = 3,
+        GK_PT_G723          = 4,
+        GK_PT_DVI4_8K       = 5,
+        GK_PT_DVI4_16K      = 6,
+        GK_PT_LPC           = 7,
+        GK_PT_PCMA          = 8,
+        GK_PT_G722          = 9,
+        GK_PT_S16BE_STEREO  = 10,
+        GK_PT_S16BE_MONO    = 11,
+        GK_PT_QCELP         = 12,
+        GK_PT_CN            = 13,
+        GK_PT_MPEGAUDIO     = 14,
+        GK_PT_G728          = 15,
+        GK_PT_DVI4_3        = 16,
+        GK_PT_DVI4_4        = 17,
+        GK_PT_G729          = 18,
+        GK_PT_G711A         = 19,
+        GK_PT_G711U         = 20,
+        GK_PT_G726          = 21,
+        GK_PT_G729A         = 22,
+        GK_PT_LPCM          = 23,
+        GK_PT_CelB          = 25,
+        GK_PT_JPEG          = 26,
+        GK_PT_CUSM          = 27,
+        GK_PT_NV            = 28,
+        GK_PT_PICW          = 29,
+        GK_PT_CPV           = 30,
+        GK_PT_H261          = 31,
+        GK_PT_MPEGVIDEO     = 32,
+        GK_PT_MPEG2TS       = 33,
+        GK_PT_H263          = 34,
+        GK_PT_SPEG          = 35,
+        GK_PT_MPEG2VIDEO    = 36,
+        GK_PT_AAC           = 37,
+        GK_PT_WMA9STD       = 38,
+        GK_PT_HEAAC         = 39,
+        GK_PT_PCM_VOICE     = 40,
+        GK_PT_PCM_AUDIO     = 41,
+        GK_PT_MP3           = 43,
+        GK_PT_ADPCMA        = 49,
+        GK_PT_AEC           = 50,
+        GK_PT_X_LD          = 95,
+        GK_PT_H264          = 96,
+        GK_PT_D_GSM_HR      = 200,
+        GK_PT_D_GSM_EFR     = 201,
+        GK_PT_D_L8          = 202,
+        GK_PT_D_RED         = 203,
+        GK_PT_D_VDVI        = 204,
+        GK_PT_D_BT656       = 220,
+        GK_PT_D_H263_1998   = 221,
+        GK_PT_D_MP1S        = 222,
+        GK_PT_D_MP2P        = 223,
+        GK_PT_D_BMPEG       = 224,
+        GK_PT_MP4VIDEO      = 230,
+        GK_PT_MP4AUDIO      = 237,
+        GK_PT_VC1           = 238,
+        GK_PT_JVC_ASF       = 255,
+        GK_PT_D_AVI         = 256,
+        GK_PT_DIVX3         = 257,
+        GK_PT_AVS           = 258,
+        GK_PT_REAL8         = 259,
+        GK_PT_REAL9         = 260,
+        GK_PT_VP6           = 261,
+        GK_PT_VP6F          = 262,
+        GK_PT_VP6A          = 263,
+        GK_PT_SORENSON      = 264,
+        GK_PT_H265          = 265,
+        GK_PT_VP8           = 266,
+        GK_PT_MVC           = 267,
+        GK_PT_PNG           = 268,
+        /* add by vendor */
+        GK_PT_AMR           = 1001,
+        GK_PT_MJPEG         = 1002,
+        GK_PT_AMRWB         = 1003,
+        GK_PT_PRORES        = 1006,
+        GK_PT_OPUS          = 1007,
+        GK_PT_BUTT
+    } gk_payload_type;
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* __GK_COMMON_H__ */
+
diff -uraN u-boot-2016.11/product/osd/include/common_video.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/include/common_video.h
--- u-boot-2016.11/product/osd/include/common_video.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/include/common_video.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,284 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __GK_COMMON_VIDEO_H__
+#define __GK_COMMON_VIDEO_H__
+
+#include "type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+typedef enum  {
+    GK_OP_MODE_AUTO   = 0,
+    GK_OP_MODE_MANUAL = 1,
+    GK_OP_MODE_BUTT
+} gk_op_mode;
+
+typedef enum  {
+    GK_VB_SRC_COMMON  = 0,
+    GK_VB_SRC_MOD  = 1,
+    GK_VB_SRC_PRIVATE = 2,
+    GK_VB_SRC_USER    = 3,
+    GK_VB_SRC_BUTT
+} gk_vb_src;
+
+typedef enum  {
+    GK_ASPECT_RATIO_NONE   = 0,        /* full screen */
+    GK_ASPECT_RATIO_AUTO   = 1,        /* ratio no change, 1:1*/
+    GK_ASPECT_RATIO_MANUAL = 2,        /* ratio manual set */
+    GK_ASPECT_RATIO_BUTT
+} gk_aspect_ratio_type;
+
+
+typedef enum  {
+    GK_VIDEO_FIELD_TOP         = 1,    /* even field */
+    GK_VIDEO_FIELD_BOTTOM      = 2,    /* odd field */
+    GK_VIDEO_FIELD_INTERLACED  = 3,    /* two interlaced fields */
+    GK_VIDEO_FIELD_FRAME       = 4,    /* frame */
+
+    GK_VIDEO_FIELD_BUTT
+} gk_video_field;
+
+typedef enum  {
+    GK_VIDEO_FORMAT_LINEAR = 0,       /* nature video line */
+    GK_VIDEO_FORMAT_TILE_64x16,       /* tile cell: 64pixel x 16line */
+    GK_VIDEO_FORMAT_BUTT
+} gk_video_format;
+
+typedef enum  {
+    GK_COMPRESS_MODE_NONE = 0,      /* no compress */
+    GK_COMPRESS_MODE_SEG,           /* compress unit is 256x1 bytes as a segment.*/
+    GK_COMPRESS_MODE_SEG_COMPACT,   /* compact compress unit is 256x1 bytes as a segment.*/
+    GK_COMPRESS_MODE_TILE,          /* compress unit is a tile.*/
+    GK_COMPRESS_MODE_LINE,          /* compress unit is the whole line.*/
+    GK_COMPRESS_MODE_FRAME,         /* compress unit is the whole frame. YUV for VPSS(3DNR) */
+
+    GK_COMPRESS_MODE_BUTT
+} gk_compress_mode;
+
+typedef enum  {
+    GK_VIDEO_DISPLAY_MODE_PREVIEW  = 0,
+    GK_VIDEO_DISPLAY_MODE_PLAYBACK = 1,
+
+    GK_VIDEO_DISPLAY_MODE_BUTT
+} gk_video_display_mode;
+
+typedef enum  {
+    GK_FRAME_FLAG_SNAP_FLASH  = 0x1 << 0,
+    GK_FRAME_FLAG_SNAP_CUR    = 0x1 << 1,
+    GK_FRAME_FLAG_SNAP_REF    = 0x1 << 2,
+    GK_FRAME_FLAG_SNAP_END    = 0x1 << 3,
+    GK_FRAME_FLAG_MIRROR      = 0x1 << 4,
+    GK_FRAME_FLAG_FLIP        = 0x1 << 5,
+    GK_FRAME_FLAG_BUTT
+} gk_frame_flag;
+
+
+typedef enum  {
+    GK_COLOR_GAMUT_BT601 = 0,
+    GK_COLOR_GAMUT_BT709,
+    GK_COLOR_GAMUT_BT2020,
+    GK_COLOR_GAMUT_USER,
+    GK_COLOR_GAMUT_BUTT
+} gk_color_gamut;
+
+/* we ONLY define picture format used, all unused will be deleted! */
+typedef enum {
+    GK_PIXEL_FORMAT_RGB_444 = 0,
+    GK_PIXEL_FORMAT_RGB_555,
+    GK_PIXEL_FORMAT_RGB_565,
+    GK_PIXEL_FORMAT_RGB_888,
+
+    GK_PIXEL_FORMAT_BGR_444,
+    GK_PIXEL_FORMAT_BGR_555,
+    GK_PIXEL_FORMAT_BGR_565,
+    GK_PIXEL_FORMAT_BGR_888,
+
+    GK_PIXEL_FORMAT_ARGB_1555,
+    GK_PIXEL_FORMAT_ARGB_4444,
+    GK_PIXEL_FORMAT_ARGB_8565,
+    GK_PIXEL_FORMAT_ARGB_8888,
+    GK_PIXEL_FORMAT_ARGB_2BPP,
+    GK_PIXEL_FORMAT_ARGB_CLUT2,
+    GK_PIXEL_FORMAT_ARGB_CLUT4,
+
+    GK_PIXEL_FORMAT_ABGR_1555,
+    GK_PIXEL_FORMAT_ABGR_4444,
+    GK_PIXEL_FORMAT_ABGR_8565,
+    GK_PIXEL_FORMAT_ABGR_8888,
+
+    GK_PIXEL_FORMAT_RGB_BAYER_8BPP,
+    GK_PIXEL_FORMAT_RGB_BAYER_10BPP,
+    GK_PIXEL_FORMAT_RGB_BAYER_12BPP,
+    GK_PIXEL_FORMAT_RGB_BAYER_14BPP,
+    GK_PIXEL_FORMAT_RGB_BAYER_16BPP,
+
+    GK_PIXEL_FORMAT_YVU_PLANAR_422,
+    GK_PIXEL_FORMAT_YVU_PLANAR_420,
+    GK_PIXEL_FORMAT_YVU_PLANAR_444,
+
+    GK_PIXEL_FORMAT_YVU_SEMIPLANAR_422,
+    GK_PIXEL_FORMAT_YVU_SEMIPLANAR_420,
+    GK_PIXEL_FORMAT_YVU_SEMIPLANAR_444,
+
+    GK_PIXEL_FORMAT_YUV_SEMIPLANAR_422,
+    GK_PIXEL_FORMAT_YUV_SEMIPLANAR_420,
+    GK_PIXEL_FORMAT_YUV_SEMIPLANAR_444,
+
+    GK_PIXEL_FORMAT_YUYV_PACKAGE_422,
+    GK_PIXEL_FORMAT_YVYU_PACKAGE_422,
+    GK_PIXEL_FORMAT_UYVY_PACKAGE_422,
+    GK_PIXEL_FORMAT_VYUY_PACKAGE_422,
+    GK_PIXEL_FORMAT_YYUV_PACKAGE_422,
+    GK_PIXEL_FORMAT_YYVU_PACKAGE_422,
+    GK_PIXEL_FORMAT_UVYY_PACKAGE_422,
+    GK_PIXEL_FORMAT_VUYY_PACKAGE_422,
+    GK_PIXEL_FORMAT_VY1UY0_PACKAGE_422,
+
+    GK_PIXEL_FORMAT_YUV_400,
+    GK_PIXEL_FORMAT_UV_420,
+
+    /* SVP data format */
+    GK_PIXEL_FORMAT_BGR_888_PLANAR,
+    GK_PIXEL_FORMAT_HSV_888_PACKAGE,
+    GK_PIXEL_FORMAT_HSV_888_PLANAR,
+    GK_PIXEL_FORMAT_LAB_888_PACKAGE,
+    GK_PIXEL_FORMAT_LAB_888_PLANAR,
+    GK_PIXEL_FORMAT_S8C1,
+    GK_PIXEL_FORMAT_S8C2_PACKAGE,
+    GK_PIXEL_FORMAT_S8C2_PLANAR,
+    GK_PIXEL_FORMAT_S8C3_PLANAR,
+    GK_PIXEL_FORMAT_S16C1,
+    GK_PIXEL_FORMAT_U8C1,
+    GK_PIXEL_FORMAT_U16C1,
+    GK_PIXEL_FORMAT_S32C1,
+    GK_PIXEL_FORMAT_U32C1,
+    GK_PIXEL_FORMAT_U64C1,
+    GK_PIXEL_FORMAT_S64C1,
+
+    GK_PIXEL_FORMAT_BUTT
+} gk_pixel_format;
+
+
+typedef enum  {
+    GK_DYNAMIC_RANGE_SDR8 = 0,
+    GK_DYNAMIC_RANGE_SDR10,
+    GK_DYNAMIC_RANGE_HDR10,
+    GK_DYNAMIC_RANGE_HLG,
+    GK_DYNAMIC_RANGE_SLF,
+    GK_DYNAMIC_RANGE_XDR,
+    GK_DYNAMIC_RANGE_BUTT
+} gk_dynamic_range;
+
+
+typedef enum  {
+    GK_DATA_BIT_WIDTH_8 = 0,
+    GK_DATA_BIT_WIDTH_10,
+    GK_DATA_BIT_WIDTH_12,
+    GK_DATA_BIT_WIDTH_14,
+    GK_DATA_BIT_WIDTH_16,
+    GK_DATA_BIT_WIDTH_BUTT
+} gk_data_bit_width;
+
+
+typedef struct {
+    gk_u32 top_width;
+    gk_u32 bottom_width;
+    gk_u32 left_width;
+    gk_u32 right_width;
+    gk_u32 color;
+} gk_border;
+
+typedef struct {
+    gk_s32 x;
+    gk_s32 y;
+} gk_point;
+
+typedef struct {
+    gk_u32 width;
+    gk_u32 height;
+} gk_size;
+
+typedef struct {
+    gk_s32 x;
+    gk_s32 y;
+    gk_u32 width;
+    gk_u32 height;
+} gk_rect;
+
+typedef enum {
+    GK_COORD_ABS = 0,                          /* Absolute coordinate. */
+    GK_COORD_RATIO,                            /* Ratio coordinate. */
+    GK_COORD_BUTT
+} gk_coord;
+
+typedef enum {
+    GK_COVER_RECT = 0,                         /* Rectangle cover. */
+    GK_COVER_QUAD,                             /* Quadrangle cover. */
+    GK_COVER_BUTT
+} gk_cover_type;
+
+typedef struct {
+    gk_bool enable;
+    gk_rect  rect;
+} gk_crop_info;
+
+typedef struct {
+    gk_s32  src_frame_rate;        /* RW; source frame rate */
+    gk_s32  dst_frame_rate;        /* RW; dest frame rate */
+} gk_frame_rate_ctrl;
+
+typedef struct {
+    gk_aspect_ratio_type mode;          /* aspect ratio mode: none/auto/manual */
+    gk_u32         bg_color;      /* background color, RGB 888 */
+    gk_rect         video_rect;     /* valid in ASPECT_RATIO_MANUAL mode */
+} gk_aspect_ratio;
+
+typedef struct {
+    gk_u32 vb_size;
+
+    gk_u32 head_stride;
+    gk_u32 head_size;
+    gk_u32 head_y_size;
+
+    gk_u32 main_stride;
+    gk_u32 main_size;
+    gk_u32 main_y_size;
+
+    gk_u32 ex_stride;
+    gk_u32 ex_y_size;
+} gk_vb_calc_cfg;
+
+/* Angle of rotation */
+typedef enum  {
+    GK_ROTATION_0   = 0,
+    GK_ROTATION_90  = 1,
+    GK_ROTATION_180 = 2,
+    GK_ROTATION_270 = 3,
+    GK_ROTATION_BUTT
+} gk_rotation;
+
+typedef enum  {
+    GK_FRAME_INTERRUPT_START,
+    GK_FRAME_INTERRUPT_EARLY,
+    GK_FRAME_INTERRUPT_EARLY_END,
+    GK_FRAME_INTERRUPT_BUTT,
+} gk_frame_interrupt_type;
+
+typedef struct {
+    gk_frame_interrupt_type interrupt_type;
+    gk_u32 early_line;
+} gk_frame_interrupt_attr;
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __GK_COMMON_VIDEO_H__ */
diff -uraN u-boot-2016.11/product/osd/include/debug.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/include/debug.h
--- u-boot-2016.11/product/osd/include/debug.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/include/debug.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __GK_DEBUG_H__
+#define __GK_DEBUG_H__
+
+#include "type.h"
+#include "common.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+#define GK_DBG_EMERG      0   /* system is unusable                   */
+#define GK_DBG_ALERT      1   /* action must be taken immediately     */
+#define GK_DBG_CRIT       2   /* critical conditions                  */
+#define GK_DBG_ERR        3   /* error conditions                     */
+#define GK_DBG_WARN       4   /* warning conditions                   */
+#define GK_DBG_NOTICE     5   /* normal but significant condition     */
+#define GK_DBG_INFO       6   /* informational                        */
+#define GK_DBG_DEBUG      7   /* debug-level messages                 */
+
+#define GK_PRINT      printf
+
+#define GK_ASSERT(expr)
+#define GK_TRACE(level, enModId, fmt...)
+
+#define GK_ERR_TRACE(mod, fmt...) printf(fmt)
+#define GK_WARN_TRACE(mod, fmt...)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __GK_DEBUG_H__ */
diff -uraN u-boot-2016.11/product/osd/include/errno.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/include/errno.h
--- u-boot-2016.11/product/osd/include/errno.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/include/errno.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,79 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __GK_ERRNO_H__
+#define __GK_ERRNO_H__
+
+#include "debug.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#define GK_ERR_APP_ID (0x80000000L + 0x20000000L)
+
+#define GK_DEFINE_ERR(mod, level, err_id) \
+    ((gk_s32)((GK_ERR_APP_ID) | ((mod) << 16) | ((level) << 13) | (err_id)))
+
+typedef enum {
+    GK_ERR_LEVEL_DEBUG = 0,  /* debug-level                                  */
+    GK_ERR_LEVEL_INFO,       /* informational                                */
+    GK_ERR_LEVEL_NOTICE,     /* normal but significant condition             */
+    GK_ERR_LEVEL_WARNING,    /* warning conditions                           */
+    GK_ERR_LEVEL_ERROR,      /* error conditions                             */
+    GK_ERR_LEVEL_CRIT,       /* critical conditions                          */
+    GK_ERR_LEVEL_ALERT,      /* action must be taken immediately             */
+    GK_ERR_LEVEL_FATAL,      /* just for compatibility with previous version */
+    GK_ERR_LEVEL_BUTT
+} gk_err_level;
+
+typedef enum {
+    GK_ERR_INVALID_DEV_ID  =  0x1, /* invlalid device ID                          */
+    GK_ERR_INVALID_PIPE_ID =  0x2, /* invlalid pipe ID                           */
+    GK_ERR_INVALID_CHN_ID  =  0x3, /* invlalid channel ID                          */
+    GK_ERR_INVALID_LAYER_ID = 0x4, /* invlalid channel ID                          */
+
+    GK_ERR_ILLEGAL_PARAM   = 0x7, /* at lease one parameter is illagal
+                               * eg, an illegal enumeration value             */
+    GK_ERR_EXIST           = 0x8, /* resource exists                              */
+    GK_ERR_UNEXIST         = 0x9, /* resource unexists                            */
+    GK_ERR_NULL_PTR        = 0xa, /* using a NULL point                           */
+    GK_ERR_NOT_CFG         = 0xb, /* try to enable or initialize system, device
+                              ** or channel, before configing attribute       */
+    GK_ERR_NOT_SUPPORT     = 0xc, /* operation or type is not supported by NOW    */
+    GK_ERR_NOT_PERM        = 0xd, /* operation is not permitted
+                              ** eg, try to change static attribute           */
+    GK_ERR_NOT_ENABLE      = 0x10,
+    GK_ERR_NOT_DISABLE     = 0x11,
+    GK_ERR_NOT_START       = 0x12,
+    GK_ERR_NOT_STOP        = 0x13,
+    GK_ERR_NO_MEM          = 0x14, /* failure caused by malloc memory              */
+    GK_ERR_NO_BUF          = 0x15, /* failure caused by malloc buffer              */
+    GK_ERR_BUF_EMPTY       = 0x16, /* no data in buffer                            */
+    GK_ERR_BUF_FULL        = 0x17, /* no buffer for new data                       */
+    GK_ERR_NOT_READY       = 0x18, /* System is not ready, maybe not initialed or
+                              ** loaded. Returning the error code when opening
+                              ** a device file failed.                        */
+    GK_ERR_TIMEOUT         = 0x20,
+    GK_ERR_BAD_ADDR        = 0x21, /* bad address,
+                              ** eg. used for copy_from_user & copy_to_user   */
+    GK_ERR_BUSY            = 0x22, /* resource is busy,
+                              ** eg. destroy a venc chn without unregister it */
+    GK_ERR_SIZE_NOT_ENOUGH = 0x23, /* buffer size is smaller than the actual size required */
+
+    GK_ERR_NOT_BINDED      = 0x24,
+    GK_ERR_BINDED          = 0x25,
+    GK_ERR_BUTT            = 0x3f, /* maxium code, private error code of all modules
+                              ** must be greater than it                      */
+} gk_errno;
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __GK_ERRNO_H__ */
diff -uraN u-boot-2016.11/product/osd/include/math.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/include/math.h
--- u-boot-2016.11/product/osd/include/math.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/include/math.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,181 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __GK_MATH_H__
+#define __GK_MATH_H__
+
+#include "type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+#define MAX2(x, y)       ((x) > (y) ? (x) : (y))
+#define MIN2(x, y)       ((x) < (y) ? (x) : (y))
+#define MAX3(x, y, z)     ((x) > (y) ? MAX2(x, z) : MAX2(y, z))
+#define MIN3(x, y, z)     ((x) < (y) ? MIN2(x, z) : MIN2(y, z))
+#define MEDIAN(x, y, z)   (((x) + (y) + (z) - MAX3(x, y, z)) - MIN3(x, y, z))
+#define MEAN2(x, y)      (((x) + (y)) >> 1)
+
+#define CLIP_MIN(x, min)          (((x) >= (min)) ? (x) : (min))
+#define CLIP3(x, min, max)         ((x) < (min) ? (min) : ((x) > (max) ? (max) : (x)))
+#define CLIP_MAX(x, max)          ((x) > (max) ? (max) : (x))
+#define WRAP_MAX(x, max, min)      ((x) >= (max) ? (min) : (x))
+#define WRAP_MIN(x, min, max)      ((x) <= (min) ? (max) : (x))
+#define VALUE_BETWEEN(x, min, max) (((x) >= (min)) && ((x) <= (max)))
+
+#define MULTI_OF_2_POWER(x, a)    (!((x) & ((a) - 1)))
+#define GK_CEILING(x, a)           (((x) + (a)- 1) / (a))
+
+#define GK_ALIGN_UP(x, a)           ((((x) + ((a) - 1)) / (a)) * (a))
+#define GK_ALIGN_DOWN(x, a)         (((x) / (a)) * (a))
+
+#define GK_DIV_UP(x, a)             (((x) + ((a) - 1)) / (a))
+
+#define FRACTION32(de, nu)       (((de) << 16) | (nu))
+#define NUMERATOR32(x)          ((x) & 0xffff)
+#define DENOMINATOR32(x)        ((x) >> 16)
+
+#define RGB(r, g, b) ((((r) & 0xff) << 16) | (((g) & 0xff) << 8) | ((b) & 0xff))
+#define RGB_R(c)   (((c) & 0xff0000) >> 16)
+#define RGB_G(c)   (((c) & 0xff00) >> 8)
+#define RGB_B(c)   ((c) & 0xff)
+
+#define YUV(y, u, v) ((((y) & 0x03ff) << 20) | (((u) & 0x03ff) << 10) | ((v) & 0x03ff))
+#define YUV_Y(c)   (((c) & 0x3ff00000) >> 20)
+#define YUV_U(c)   (((c) & 0x000ffc00) >> 10)
+#define YUV_V(c)   ((c) & 0x000003ff)
+
+#define YUV_8BIT(y, u, v) ((((y) & 0xff) << 16) | (((u) & 0xff) << 8) | ((v) & 0xff))
+#define YUV_8BIT_Y(c)   (((c) & 0xff0000) >> 16)
+#define YUV_8BIT_U(c)   (((c) & 0xff00) >> 8)
+#define YUV_8BIT_V(c)   ((c) & 0xff)
+
+#define gk_usleep(usec) \
+    do {                \
+        usleep(usec);   \
+    } while (0)
+
+#define SPAN(type, begin, end) \
+({                             \
+    type b = (begin);          \
+    type e = (end);            \
+    (type)((b >= e) ? (b - e) : (b + ((~((type)0))-e))); \
+})
+
+#define  ENDIAN32(x)                     \
+    (((x) << 24) |                       \
+     (((x) & 0x0000ff00) << 8) |        \
+     (((x) & 0x00ff0000) >> 8) |        \
+     (((x) >> 24) & 0x000000ff))
+
+
+#define  ENDIAN16(x)    ((((x) << 8) & 0xff00) | (((x) >> 8) & 255))
+
+__inline static gk_void rgb_to_yc(gk_u16 r, gk_u16 g, gk_u16 b, gk_u16 *y, gk_u16 *cb, gk_u16 *cr)
+{
+    /* Y */
+    *y = (gk_u16)((((r * 66 + g * 129 + b * 25) >> 8) + 16) << 2); /* 66, 129, 25, 8, 16, 2 coef */
+
+    /* cb */
+    *cb = (gk_u16)(((((b * 112 - r * 38) - g * 74) >> 8) + 128) << 2); /* 112, 38, 74, 8, 128, 2 coef */
+
+    /* cr */
+    *cr = (gk_u16)(((((r * 112 - g * 94) - b * 18) >> 8) + 128) << 2); /* 112, 94, 18, 8, 128, 2 coef */
+}
+
+__inline static gk_u32 rgb_to_yuv(gk_u32 rgb)
+{
+    gk_u16 y, u, v;
+
+    rgb_to_yc(RGB_R(rgb), RGB_G(rgb), RGB_B(rgb), &y, &u, &v);
+
+    return YUV(y, u, v);
+}
+
+__inline static gk_void rgb_to_yc_full(gk_u16 r, gk_u16 g, gk_u16 b, gk_u16 *y, gk_u16 *cb, gk_u16 *cr)
+{
+    gk_u16 y_tmp, cb_tmp, cr_tmp;
+
+    y_tmp = (gk_u16)(((r * 76 + g * 150 + b * 29) >> 8) * 4); /* 76, 150, 29, 8, 4 coef */
+    cb_tmp = (gk_u16)(CLIP_MIN(((((b * 130 - r * 44) - g * 86) >> 8) + 128), 0) * 4); /* 130 44 86 8 128 4 coef */
+    cr_tmp = (gk_u16)(CLIP_MIN(((((r * 130 - g * 109) - b * 21) >> 8) + 128), 0) * 4); /* 130 109 21 8 128 4 coef */
+
+    *y = MAX2(MIN2(y_tmp, 1023), 0); /* 1023 coef */
+    *cb = MAX2(MIN2(cb_tmp, 1023), 0); /* 1023 coef */
+    *cr = MAX2(MIN2(cr_tmp, 1023), 0); /* 1023 coef */
+}
+
+__inline static gk_u32 rgb_to_yuv_full(gk_u32 rgb)
+{
+    gk_u16 y, u, v;
+
+    rgb_to_yc_full(RGB_R(rgb), RGB_G(rgb), RGB_B(rgb), &y, &u, &v);
+
+    return YUV(y, u, v);
+}
+
+__inline static gk_void rgb_to_yc_8bit(gk_u8 r, gk_u8 g, gk_u8 b, gk_u8 *y, gk_u8 *cb, gk_u8 *cr)
+{
+    /* Y */
+    *y = (gk_u8)(((r * 66 + g * 129 + b * 25) >> 8) + 16); /* 66 129 25 8 16 coef */
+
+    /* cb */
+    *cb = (gk_u8)((((b * 112 - r * 38) - g * 74) >> 8) + 128); /* 112 38 74 8 128 coef */
+
+    /* cr */
+    *cr = (gk_u8)((((r * 112 - g * 94) - b * 18) >> 8) + 128); /* 112 94 18 8 128 coef */
+}
+
+__inline static gk_u32 rgb_to_yuv_8bit(gk_u32 rgb)
+{
+    gk_u8 y, u, v;
+
+    rgb_to_yc_8bit(RGB_R(rgb), RGB_G(rgb), RGB_B(rgb), &y, &u, &v);
+
+    return YUV_8BIT(y, u, v);
+}
+
+__inline static gk_void rgb_to_yc_full_8bit(gk_u8 r, gk_u8 g, gk_u8 b, gk_u8 *y, gk_u8 *cb, gk_u8 *cr)
+{
+    gk_s16 y_tmp, cb_tmp, cr_tmp;
+
+    y_tmp = (r * 76 + g * 150 + b * 29) >> 8; /* 76 150 29 8 coef */
+    cb_tmp = (((b * 130 - r * 44) - g * 86) >> 8) + 128; /* 130 44 86 8 128 coef */
+    cr_tmp = (((r * 130 - g * 109) - b * 21) >> 8) + 128; /* 130 109 21 8 128 coef */
+
+    *y = MAX2(MIN2(y_tmp, 255), 0); /* 255 coef */
+    *cb = MAX2(MIN2(cb_tmp, 255), 0); /* 255 coef */
+    *cr = MAX2(MIN2(cr_tmp, 255), 0); /* 255 coef */
+}
+
+__inline static gk_u32 rgb2_yuv_full_8_bit(gk_u32 rgb)
+{
+    gk_u8 y, u, v;
+
+    rgb_to_yc_full_8bit(RGB_R(rgb), RGB_G(rgb), RGB_B(rgb), &y, &u, &v);
+
+    return YUV_8BIT(y, u, v);
+}
+
+__inline static gk_u32 get_low_addr(gk_phys_addr_t phys_addr)
+{
+    return (gk_u32)phys_addr;
+}
+
+__inline static gk_u32 get_high_addr(gk_phys_addr_t phys_addr)
+{
+    gk_u32 low_width = 32; /* 32bit low addr */
+    return (sizeof(phys_addr) > (low_width / 8)) ? (gk_u32)(phys_addr >> low_width) : 0; /* 8 bits per byte */
+}
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __GK_MATH_H__ */
diff -uraN u-boot-2016.11/product/osd/include/type.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/include/type.h
--- u-boot-2016.11/product/osd/include/type.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/include/type.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __GK_TYPE_H__
+#define __GK_TYPE_H__
+
+#ifdef __KERNEL__
+
+#include <linux/types.h>
+#else
+
+#include <stdint.h>
+#endif
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#ifndef NULL
+    #define NULL                0L
+#endif
+
+#define GK_NULL                 0L
+#define GK_SUCCESS              0
+#define GK_FAILURE              (-1)
+
+typedef unsigned char           gk_uchar;
+typedef unsigned char           gk_u8;
+typedef unsigned short          gk_u16;
+typedef unsigned int            gk_u32;
+typedef unsigned long           gk_ulong;
+
+typedef char                    gk_char;
+typedef signed char             gk_s8;
+typedef short                   gk_s16;
+typedef int                     gk_s32;
+typedef long                    gk_slong;
+
+typedef float                   gk_float;
+typedef double                  gk_double;
+
+typedef void                    gk_void;
+
+#ifndef _M_IX86
+    typedef unsigned long long  gk_u64;
+    typedef long long           gk_s64;
+#else
+    typedef unsigned __int64    gk_u64;
+    typedef __int64             gk_s64;
+#endif
+typedef unsigned long int       uintptr_t;
+
+typedef unsigned long           gk_size_t;
+typedef unsigned long           gk_length_t;
+typedef unsigned long int       gk_phys_addr_t;
+typedef gk_u32                  gk_handle;
+typedef uintptr_t               gk_uintptr_t;
+typedef unsigned int            gk_fr32;
+
+typedef enum {
+    GK_FALSE = 0,
+    GK_TRUE  = 1,
+} gk_bool;
+
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __GK_TYPE_H__ */
+
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/include/drv_vo_comm.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/include/drv_vo_comm.h
--- u-boot-2016.11/product/osd/vo/arch/comm/include/drv_vo_comm.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/include/drv_vo_comm.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __DRV_VO_COMM_H__
+#define __DRV_VO_COMM_H__
+
+#include "common_vo.h"
+#include "common_video.h"
+#include "mkp_vo.h"
+#include "drv_vo_coef_comm.h"
+#include "hal_vo_def.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#if VO_DESC("UBOOT_VO")
+
+typedef enum {
+    /* for video surface interface */
+    VOU_LAYER_PIXERL_FORMAT_SP_YCBCR_400 = 0x1,
+    VOU_LAYER_PIXERL_FORMAT_SP_YCBCR_420 = 0x2,
+    VOU_LAYER_PIXERL_FORMAT_SP_YCBCR_422 = 0x3,
+    VOU_LAYER_PIXERL_FORMAT_BUTT
+} vou_layer_pixerl_format;
+
+/* vou interrupt mask type */
+typedef enum {
+    VO_INTMSK_NONE = 0,
+    VO_INTMSK_DHD0_VTTHD1 = 0x1,
+    VO_INTMSK_DHD0_VTTHD2 = 0x2,
+    VO_INTMSK_DHD0_VTTHD3 = 0x4,
+    VO_INTMSK_DHD0_UFINT = 0x8,
+
+    VO_INTMSK_DHD1_VTTHD1 = 0x10,
+    VO_INTMSK_DHD1_VTTHD2 = 0x20,
+    VO_INTMSK_DHD1_VTTHD3 = 0x40,
+    VO_INTMSK_DHD1_UFINT = 0x80,
+
+    VO_INTMSK_DSD_VTTHD1 = 0x100,
+    VO_INTMSK_DSD_VTTHD2 = 0x200,
+    VO_INTMSK_DSD_VTTHD3 = 0x400,
+    VO_INTMSK_DSD_UFINT = 0x800,
+
+    VO_INTMSK_B0_ERR = 0x1000,
+    VO_INTMSK_B1_ERR = 0x2000,
+    VO_INTMSK_B2_ERR = 0x4000,
+
+    VO_INTMSK_WBC_DHDOVER = 0x8000,
+
+    VO_INTMSK_VGA_VDAC = 0x70000,   /*  INT VDAC0/VDAC1/VDAC2 */
+    VO_INTMSK_CVBS_VDAC = 0x80000,  /*  INT VDAC3 */
+
+    VO_INTREPORT_ALL = 0xffffffff
+} vo_int_mask;
+
+typedef enum {
+    VO_INT_MODE_FRAME = 0x0,
+    VO_INT_MODE_FIELD = 0x1,
+    VO_INT_MODE_BUTT
+} vo_int_mode;
+
+#if VO_DESC("wbc zme")
+typedef enum {
+    VO_ZME_TYP = 0,
+    VO_ZME_TYP1,
+    VO_ZME_RAND,
+    VO_ZME_MAX,
+    VO_ZME_MIN,
+    VO_ZME_ZERO,
+    VO_ZME_BUTT
+} vo_zme_mode;
+#endif
+
+#if VO_DESC("pub")
+hal_disp_syncinfo *vo_drv_comm_get_sync_timing(gk_vo_intf_sync sync);
+gk_s32 vou_drv_check_cvbs_sync(gk_vo_dev dev, gk_vo_intf_type intf_type, gk_vo_intf_sync intf_sync);
+hal_disp_pixel_format vou_drv_convert_data_format(vou_layer_pixerl_format data_fmt);
+gk_void vo_drv_board_init(gk_void);
+gk_void vo_drv_csc_trans_to_register(csc_coef *coef);
+#endif
+
+#endif /* end of #if VO_DESC("UBOOT_VO") */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* end of __DRV_VO_COMM_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/include/drv_vo_dev_comm.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/include/drv_vo_dev_comm.h
--- u-boot-2016.11/product/osd/vo/arch/comm/include/drv_vo_dev_comm.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/include/drv_vo_dev_comm.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,130 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __DRV_VO_COMM_DEV_H__
+#define __DRV_VO_COMM_DEV_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#if VO_DESC("UBOOT_VO")
+typedef enum {
+    VO_HD_HW_DEV = 0,  /* HD dev */
+    VO_SD_HW_DEV,  /* SD dev */
+    VO_UHD_HW_DEV,  /* UHD dev */
+    VO_CAS_DEV,  /* cascade dev */
+    VO_VIRT_DEV,  /* virtual dev */
+    VO_DEV_TYPE_BUTT,
+} vo_dev_type;
+
+/* 50000: 50ms */
+#define VO_DEV_REG_UP_TIMEOUT 50
+
+#define VO_MIN_DIV_MODE      1
+#define VO_MAX_DIV_MODE      4
+#define VO_INTF_HDMI_DIV_MODE      1
+#define VO_INTF_CVBS_DIV_MODE      4
+#define VO_INTF_BT656_DIV_MODE     2
+#define VO_INTF_RGB_DIV_MODE_1     1
+#define VO_INTF_RGB_DIV_MODE_3     3
+#define VO_INTF_RGB_DIV_MODE_4     4
+#define VO_MIN_PRE_DIV_MODE  1
+#define VO_MAX_PRE_DIV_MODE  32
+#define VO_INTF_NO_HDMI_PRE_DIV_MODE      1
+
+#define VO_MAX_USER_SYNC_INTFB 255
+#define VO_MAX_USER_SYNC_VACT  4096
+#define VO_MIN_USER_SYNC_VACT  100
+#define VO_MAX_USER_SYNC_VBB   256
+#define VO_MIN_USER_SYNC_VBB   1
+#define VO_MAX_USER_SYNC_VFB   256
+#define VO_MIN_USER_SYNC_VFB   1
+#define VO_MAX_USER_SYNC_HACT  4096
+#define VO_MIN_USER_SYNC_HACT  1
+#define VO_MAX_USER_SYNC_HBB   65535
+#define VO_MIN_USER_SYNC_HBB   1
+#define VO_MAX_USER_SYNC_HFB   65535
+#define VO_MIN_USER_SYNC_HFB   1
+#define VO_MAX_USER_SYNC_BVACT 4096
+#define VO_MAX_USER_SYNC_BVBB  256
+#define VO_MAX_USER_SYNC_BVFB  256
+#define VO_MAX_USER_SYNC_HPW   65535
+#define VO_MIN_USER_SYNC_HPW   1
+#define VO_MAX_USER_SYNC_VPW   256
+#define VO_MIN_USER_SYNC_VPW   1
+
+#if VO_DESC("dev drv api")
+gk_u32 vo_drv_get_dev_bg_color(gk_vo_dev dev);
+gk_vo_intf_type vo_drv_get_dev_intf_type(gk_vo_dev dev);
+gk_vo_intf_sync vo_drv_get_dev_intf_sync(gk_vo_dev dev);
+gk_u32 vo_drv_get_dev_vtth(gk_vo_dev dev);
+gk_u32 vo_drv_get_dev_vtth2(gk_vo_dev dev);
+gk_void vou_drv_set_disp_max_size(gk_vo_dev dev, gk_u32 max_width, gk_u32 max_height);
+#endif
+
+#if VO_DESC("dev")
+gk_void vo_drv_get_sync_info(gk_vo_dev dev, hal_disp_syncinfo *sync_info);
+gk_void vo_drv_set_sync_info(gk_vo_dev dev, hal_disp_syncinfo *sync_info);
+gk_bool vo_drv_is_progressive(gk_vo_dev dev);
+gk_void vo_drv_int_reg_up_mode(gk_vo_layer layer, vo_int_mode int_mode);
+gk_void vo_drv_set_dev_default_vtth(gk_vo_dev dev);
+gk_s32 vo_drv_set_dev_vtth(gk_vo_dev dev, gk_u32 vtth);
+gk_s32 vo_drv_set_dev_vtth2(gk_vo_dev dev, gk_u32 vtth);
+gk_bool vou_drv_get_dev_enable(gk_vo_dev dev);
+gk_s32 vo_drv_check_dev_clkvalue(gk_vo_dev dev, const gk_vo_user_sync_info *sync_info);
+gk_s32 vou_drv_check_dsd_intf(gk_vo_dev dev, gk_vo_intf_type intf_type);
+gk_s32 vou_drv_check_dev_sync(gk_vo_dev dev, gk_vo_intf_type intf_type, gk_vo_intf_sync intf_sync);
+gk_s32 vou_drv_check_dev_pub_attr(gk_vo_dev dev, const gk_vo_pub_attr *pub_attr);
+gk_void vo_drv_get_dev_reg_up(gk_vo_dev dev);
+#endif
+
+#if VO_DESC("dev layer prio")
+gk_void vou_drv_set_layer_priority(gk_vo_dev dev, gk_vo_layer layer, gk_u32 priority);
+#endif
+
+#if VO_DESC("dev intf")
+gk_void vou_drv_intf_csc_config(gk_vo_intf_type intf, const gk_vo_csc *csc);
+gk_void vo_drv_set_vga_param(gk_vo_dev dev, const gk_vo_vga_param *vga_param);
+gk_void vo_drv_set_hdmi_param(gk_vo_dev dev, const gk_vo_hdmi_param *hdmi_param);
+gk_void vo_drv_set_rgb_param(gk_vo_dev dev, const gk_vo_rgb_param *rgb_param);
+gk_void vo_drv_set_dev_mpp_chn(gk_vo_dev dev, gk_mpp_chn *mpp_chn);
+gk_bool vo_drv_is_hdmi_intf(gk_vo_intf_type intf_type);
+gk_bool vo_drv_is_rgb_intf(gk_vo_intf_type intf_type);
+gk_bool vo_drv_is_mipi_intf(gk_vo_intf_type intf_type);
+gk_bool vo_drv_is_bt1120_intf(gk_vo_intf_type intf_type);
+#endif
+
+#if VO_DESC("dev interrupt")
+gk_void vo_drv_int_set_mode(gk_vo_dev dev, vo_int_mode int_mode);
+#endif
+
+#if VO_DESC("check id")
+gk_s32 vo_drv_check_dev_id_pub(gk_vo_dev dev);
+gk_s32 vo_drv_check_layer_id_pub(gk_vo_layer layer);
+#endif
+
+gk_void vo_drv_set_pub_attr(gk_vo_dev dev, const gk_vo_pub_attr *vo_pub_attr);
+gk_void vo_drv_enable(gk_vo_dev dev);
+gk_void vo_drv_disable(gk_vo_dev dev);
+gk_u32 vou_drv_get_dev_layer_num(gk_vo_dev dev);
+gk_void vou_drv_get_dev_layer(gk_vo_dev dev, gk_vo_layer *layer, gk_u32 vo_layer_num);
+gk_vo_layer vo_drv_get_gfx_layer(gk_vo_dev dev);
+
+gk_bool vo_drv_is_phy_dev_uhd(gk_vo_dev dev);
+gk_bool vo_drv_is_phy_dev_hd(gk_vo_dev dev);
+gk_bool vo_drv_is_phy_dev_sd(gk_vo_dev dev);
+
+#endif /* #if VO_DESC("UBOOT_VO") */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* end of __DRV_VO_COMM_DEV_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/include/drv_vo_gfx_comm.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/include/drv_vo_gfx_comm.h
--- u-boot-2016.11/product/osd/vo/arch/comm/include/drv_vo_gfx_comm.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/include/drv_vo_gfx_comm.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __DRV_GFX_COMM_H__
+#define __DRV_GFX_COMM_H__
+
+#include "type.h"
+#include "common_vo.h"
+#include "mkp_vo.h"
+#include "inner_vo.h"
+#include "hal_vo_def.h"
+#include "drv_vo_coef_comm.h"
+
+#if VO_DESC("UBOOT_VO")
+#define GFX_CSC_SCALE    0xa
+#define GFX_CSC_CLIP_MIN 0x0
+#define GFX_CSC_CLIP_MAX 0x3ff
+gk_s32 vo_drv_set_gfx_layer_csc(gk_vo_layer gfx_layer, gk_vo_csc *csc, csc_coef_param *csc_param);
+typedef struct {
+    gk_bool opened;
+
+    gk_vo_csc gfx_csc;
+    csc_coef_param csc_param;
+} vo_gfxlayer_context;
+
+gk_s32 graphic_drv_set_csc_coef(hal_disp_layer gfx_layer, gk_vo_csc *gfx_csc, csc_coef_param *csc_param);
+gk_void gfx_drv_init_default_csc(gk_vo_layer layer, gk_vo_csc *csc);
+gk_void gfx_drv_init_default_csc_param(gk_vo_layer layer, csc_coef_param *csc_param);
+#endif /* #if VO_DESC("UBOOT_VO") */
+
+#endif
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/include/drv_vo_layer_comm.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/include/drv_vo_layer_comm.h
--- u-boot-2016.11/product/osd/vo/arch/comm/include/drv_vo_layer_comm.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/include/drv_vo_layer_comm.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __DRV_VO_LAYER_COMM_H__
+#define __DRV_VO_LAYER_COMM_H__
+
+#include "inner_vo.h"
+#include "drv_vo_coef_comm.h"
+#include "hal_vo_def.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#if VO_DESC("UBOOT_VO")
+
+#if VO_DESC("layer")
+#define VO_LAYER_CSC_SCALE2P_DEF_VAL 0xa
+#define VO_LAYER_CSC_CLIP_MIN 0x0
+#define VO_LAYER_CSC_CLIP_MAX 0xfff
+#endif
+
+#if VO_DESC("layer csc")
+gk_s32 vo_drv_get_csc_matrix(gk_vo_csc_matrix csc_matrix, const csc_coef **csc_tmp);
+gk_void vo_drv_calculate_yuv2rgb(hal_csc_value *csc_value, const csc_coef *csc_tmp, csc_coef *coef);
+gk_void vo_drv_calculate_rgb2yuv(hal_csc_value *csc_value, const csc_coef *csc_tmp, csc_coef *coef);
+gk_void vo_drv_clip_layer_csc_coef(csc_coef *coef);
+gk_void vou_drv_calc_csc_matrix(const gk_vo_csc *csc, gk_vo_csc_matrix csc_matrix, csc_coef *coef);
+gk_void vou_drv_layer_csc_config(gk_vo_layer layer, gk_vo_csc *csc, csc_coef_param *csc_param);
+gk_void vou_drv_get_layer_csc_param(gk_vo_layer layer, csc_coef_param *csc_param);
+#endif
+#endif /* #if VO_DESC("UBOOT_VO") */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* end of #ifdef __cplusplus */
+#endif
+
+#endif /* end of __DRV_VO_LAYER_COMM_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/include/drv_vo_video_comm.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/include/drv_vo_video_comm.h
--- u-boot-2016.11/product/osd/vo/arch/comm/include/drv_vo_video_comm.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/include/drv_vo_video_comm.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __DRV_VO_VIDEO_COMM_H__
+#define __DRV_VO_VIDEO_COMM_H__
+
+#include "drv_vo_comm.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#if VO_DESC("UBOOT_VO")
+
+#if VO_DESC("layer cfg")
+gk_void vou_drv_layer_enable(gk_vo_layer layer, gk_bool enable);
+gk_void vo_drv_disable_layer(gk_vo_layer layer);
+gk_void vou_drv_set_layer_reg_up(gk_vo_layer layer);
+gk_void vou_drv_set_layer_data_fmt(gk_vo_layer layer, vou_layer_pixerl_format data_fmt);
+#endif
+
+#if VO_DESC("layer")
+gk_void vou_drv_init_default_csc(gk_vo_layer layer);
+gk_void vou_drv_init_default_csc_param(gk_vo_layer layer);
+gk_void vou_drv_set_default_csc(gk_vo_layer layer, gk_vo_csc *csc);
+gk_s32 vou_drv_get_video_layer_bind_dev(gk_vo_layer layer);
+gk_void vo_drv_set_layer_attr(gk_vo_layer layer, const gk_vo_video_layer_attr *vo_layer_attr);
+gk_void vou_drv_get_default_csc(gk_vo_layer layer, gk_vo_csc *csc);
+
+#endif
+
+#endif /* #if VO_DESC("UBOOT_VO") */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* end of #ifdef __cplusplus */
+#endif
+
+#endif /* end of __DRV_VO_COMM_LAYER_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/src/drv_vo_coef_comm.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/drv_vo_coef_comm.h
--- u-boot-2016.11/product/osd/vo/arch/comm/src/drv_vo_coef_comm.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/drv_vo_coef_comm.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,133 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __DRV_VO_COMM_COEF_H__
+#define __DRV_VO_COMM_COEF_H__
+
+#include "type.h"
+#include "inner_vo.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#if VO_DESC("UBOOT_VO")
+
+typedef struct {
+    gk_s32 csc_coef00;
+    gk_s32 csc_coef01;
+    gk_s32 csc_coef02;
+
+    gk_s32 csc_coef10;
+    gk_s32 csc_coef11;
+    gk_s32 csc_coef12;
+
+    gk_s32 csc_coef20;
+    gk_s32 csc_coef21;
+    gk_s32 csc_coef22;
+} vdp_csc_coef;
+
+typedef struct {
+    gk_s32 csc_in_dc0;
+    gk_s32 csc_in_dc1;
+    gk_s32 csc_in_dc2;
+
+    gk_s32 csc_out_dc0;
+    gk_s32 csc_out_dc1;
+    gk_s32 csc_out_dc2;
+} vdp_csc_dc_coef;
+
+typedef struct {
+    /* for old version csc */
+    gk_s32 csc_coef00;
+    gk_s32 csc_coef01;
+    gk_s32 csc_coef02;
+
+    gk_s32 csc_coef10;
+    gk_s32 csc_coef11;
+    gk_s32 csc_coef12;
+
+    gk_s32 csc_coef20;
+    gk_s32 csc_coef21;
+    gk_s32 csc_coef22;
+
+    gk_s32 csc_in_dc0;
+    gk_s32 csc_in_dc1;
+    gk_s32 csc_in_dc2;
+
+    gk_s32 csc_out_dc0;
+    gk_s32 csc_out_dc1;
+    gk_s32 csc_out_dc2;
+
+    gk_s32 new_csc_scale2p;
+    gk_s32 new_csc_clip_min;
+    gk_s32 new_csc_clip_max;
+} csc_coef;
+
+typedef struct {
+    gk_s32 csc_scale2p;
+    gk_s32 csc_clip_min;
+    gk_s32 csc_clip_max;
+} csc_coef_param;
+
+typedef struct {
+    gk_s32 vga_hsp_tmp0;
+    gk_s32 vga_hsp_tmp1;
+    gk_s32 vga_hsp_tmp2;
+    gk_s32 vga_hsp_tmp3;
+    gk_u32 vga_hsp_coring;
+    gk_s32 vga_hsp_gainneg;
+    gk_s32 vga_hsp_gainpos;
+    gk_s32 vga_hsp_adpshooten;
+    gk_u32 vga_hsp_winsize;
+    gk_u32 vga_hsp_mixratio;
+    gk_u32 vga_hsp_underth;
+    gk_u32 vga_hsp_overth;
+} hsp_hf_coef;
+
+typedef struct {
+    gk_u32 vga_hsp_hf_shootdiv;
+    gk_u32 vga_hsp_lti_ratio;
+    gk_u32 vga_hsp_ldti_gain;
+    gk_u32 vga_hsp_cdti_gain;
+    gk_u32 vga_hsp_peak_ratio;
+    gk_u32 vga_hsp_glb_overth;
+    gk_u32 vga_hsp_glb_underth;
+} hsp_coef;
+
+/* CVFIR VCOEF */
+typedef struct {
+    gk_s32 vccoef00;
+    gk_s32 vccoef01;
+    gk_s32 vccoef02;
+    gk_s32 vccoef03;
+    gk_s32 vccoef10;
+    gk_s32 vccoef11;
+    gk_s32 vccoef12;
+    gk_s32 vccoef13;
+} cvfir_coef;
+
+/* HFIR VCOEF */
+typedef struct {
+    gk_s32 coef0;
+    gk_s32 coef1;
+    gk_s32 coef2;
+    gk_s32 coef3;
+    gk_s32 coef4;
+    gk_s32 coef5;
+    gk_s32 coef6;
+    gk_s32 coef7;
+} hfir_coef;
+#endif /* #if VO_DESC("UBOOT_VO") */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* end of #ifndef __DRV_VO_COMM_COEF_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/src/drv_vo_coef_org_comm.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/drv_vo_coef_org_comm.c
--- u-boot-2016.11/product/osd/vo/arch/comm/src/drv_vo_coef_org_comm.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/drv_vo_coef_org_comm.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,246 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "drv_vo_coef_org_comm.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#if VO_DESC("UBOOT_VO")
+const csc_coef g_csc_identity_limit = {
+    1024, 0, 0, 0, 1024, 0, 0, 0, 1024,
+    -16, -128, -128,
+    16, 128, 128
+};
+
+const csc_coef g_csc_identity_full = {
+    1024, 0, 0, 0, 1024, 0, 0, 0, 1024,
+    0, -128, -128,
+    0, 128, 128
+};
+
+const csc_coef g_csc_yuv601full_to_yuv601limit = {
+    880, 0, 0, 0, 899, 0, 0, 0, 899,
+    0, -128, -128,
+    16, 128, 128
+};
+
+const csc_coef g_csc_yuv709limit_to_yuv601limit = {
+    1024, 102, 196, 0, 1014, -113, 0, -74, 1007,
+    -16, -128, -128,
+    16, 128, 128
+};
+
+const csc_coef g_csc_yuv709full_to_yuv601limit = {
+    880, 90, 173, 0, 891, -99, 0, -65, 864,
+    0, -128, -128,
+    16, 128, 128
+};
+
+const csc_coef g_csc_yuv601limit_to_yuv709limit = {
+    1024, -118, -213, 0, 1043, 117, 0, 77, 1050,
+    -16, -128, -128,
+    16, 128, 128
+};
+
+const csc_coef g_csc_yuv601full_to_yuv709limit = {
+    880, -103, -187, 0, 916, 102, 0, 67, 922,
+    0, -128, -128,
+    16, 128, 128
+};
+
+const csc_coef g_csc_yuv709full_to_yuv709limit = {
+    880, 0, 0, 0, 899, 0, 0, 0, 899,
+    0, -128, -128,
+    16, 128, 128
+};
+
+const csc_coef g_csc_yuv601limit_to_yuv601full = {
+    1192, 0, 0, 0, 1165, 0, 0, 0, 1165,
+    -16, -128, -128,
+    0, 128, 128
+};
+
+const csc_coef g_csc_yuv709limit_to_yuv601full = {
+    1192, 117, 222, 0, 1154, -128, 0, -84, 1146,
+    -16, -128, -128,
+    0, 128, 128
+};
+
+const csc_coef g_csc_yuv709full_to_yuv601full = {
+    1024, 102, 196, 0, 1014, -113, 0, -74, 1007,
+    0, -128, -128,
+    0, 128, 128
+};
+
+const csc_coef g_csc_yuv601limit_to_yuv709full = {
+    1192, -137, -248, 0, 1188, 133, 0, 87, 1194,
+    -16, -128, -128,
+    0, 128, 128
+};
+
+const csc_coef g_csc_yuv601full_to_yuv709full = {
+    1024, -118, -213, 0, 1043, 117, 0, 77, 1050,
+    0, -128, -128,
+    0, 128, 128
+};
+
+const csc_coef g_csc_yuv709limit_to_yuv709full = {
+    1192, 0, 0, 0, 1165, 0, 0, 0, 1165,
+    -16, -128, -128,
+    0, 128, 128
+};
+
+const csc_coef g_csc_yuv601limit_to_rgbfull = {
+    1192, 0, 1634, 1192, -400, -833, 1192, 2066, 0,
+    -16, -128, -128,
+    0, 0, 0
+};
+
+const csc_coef g_csc_yuv601full_to_rgbfull = {
+    1024, 0, 1040, 1024, -344, -706, 1024, 1774, 0,
+    0, -128, -128,
+    0, 0, 0
+};
+
+const csc_coef g_csc_yuv709limit_to_rgbfull = {
+    1192, 0, 1836, 1192, -218, -547, 1192, 2166, 0,
+    -16, -128, -128,
+    0, 0, 0
+};
+
+const csc_coef g_csc_yuv709full_to_rgbfull = {
+    1024, 0, 1577, 1024, -187, -470, 1024, 1860, 0,
+    0, -128, -128,
+    0, 0, 0
+};
+
+const csc_coef g_csc_yuv601limit_to_rgblimit = {
+    1024, 0, 1404, 1024, -344, -716, 1024, 1775, 0,
+    -16, -128, -128,
+    16, 16, 16
+};
+
+const csc_coef g_csc_yuv601full_to_rgblimit = {
+    880, 0, 1233, 880, -302, -629, 880, 1599, 0,
+    0, -128, -128,
+    16, 16, 16
+};
+
+const csc_coef g_csc_yuv709limit_to_rgblimit = {
+    1024, 0, 1578, 1024, -187, -470, 1024, 1861, 0,
+    -16, -128, -128,
+    16, 16, 16
+};
+
+const csc_coef g_csc_yuv709full_to_rgblimit = {
+    880, 0, 1385, 880, -164, -413, 880, 1634, 0,
+    0, -128, -128,
+    16, 16, 16
+};
+
+const csc_coef g_csc_rgbfull_to_yuv601limit = {
+    264, 516, 100, -152, -298, 450, 450, -377, -73,
+    0, 0, 0,
+    16, 128, 128
+};
+
+const csc_coef g_csc_rgbfull_to_yuv601full = {
+    306, 601, 117, -176, -347, 523, 523, -438, -85,
+    0, 0, 0,
+    0, 128, 128
+};
+
+const csc_coef g_csc_rgbfull_to_yuv709limit = {
+    188, 629, 63, -103, -347, 450, 450, -409, -41,
+    0, 0, 0,
+    16, 128, 128
+};
+
+const csc_coef g_csc_rgbfull_to_yuv709full = {
+    218, 732, 74, -120, -403, 523, 523, -475, -48,
+    0, 0, 0,
+    0, 128, 128
+};
+
+const int g_sin_table[61] = { /* 61 theta */
+    -500, -485, -469, -454, -438, -422, -407, -391, -374, -358,
+    -342, -325, -309, -292, -276, -259, -242, -225, -208, -191,
+    -174, -156, -139, -122, -104, -87, -70, -52, -35, -17,
+    0, 17, 35, 52, 70, 87, 104, 122, 139, 156,
+    174, 191, 208, 225, 242, 259, 276, 292, 309, 325,
+    342, 358, 374, 391, 407, 422, 438, 454, 469, 485,
+    500
+};
+
+const int g_cos_table[61] = { /* 61 theta */
+    866, 875, 883, 891, 899, 906, 914, 921, 927, 934,
+    940, 946, 951, 956, 961, 966, 970, 974, 978, 982,
+    985, 988, 990, 993, 995, 996, 998, 999, 999, 1000,
+    1000, 1000, 999, 999, 998, 996, 995, 993, 990, 988,
+    985, 982, 978, 974, 970, 966, 961, 956, 951, 946,
+    940, 934, 927, 921, 914, 906, 899, 891, 883, 875,
+    866
+};
+
+const csc_coef *g_csc_coef[GK_VO_CSC_MATRIX_BUTT] = {
+    &g_csc_identity_limit,
+    &g_csc_yuv601full_to_yuv601limit,
+    &g_csc_yuv709limit_to_yuv601limit,
+    &g_csc_yuv709full_to_yuv601limit,
+    &g_csc_yuv601limit_to_yuv709limit,
+    &g_csc_yuv601full_to_yuv709limit,
+    &g_csc_identity_limit,
+    &g_csc_yuv709full_to_yuv709limit,
+    &g_csc_yuv601limit_to_yuv601full,
+    &g_csc_identity_full,
+    &g_csc_yuv709limit_to_yuv601full,
+    &g_csc_yuv709full_to_yuv601full,
+    &g_csc_yuv601limit_to_yuv709full,
+    &g_csc_yuv601full_to_yuv709full,
+    &g_csc_yuv709limit_to_yuv709full,
+    &g_csc_identity_full,
+    &g_csc_yuv601limit_to_rgbfull,
+    &g_csc_yuv601full_to_rgbfull,
+    &g_csc_yuv709limit_to_rgbfull,
+    &g_csc_yuv709full_to_rgbfull,
+    &g_csc_yuv601limit_to_rgblimit,
+    &g_csc_yuv601full_to_rgblimit,
+    &g_csc_yuv709limit_to_rgblimit,
+    &g_csc_yuv709full_to_rgblimit,
+    &g_csc_rgbfull_to_yuv601limit,
+    &g_csc_rgbfull_to_yuv601full,
+    &g_csc_rgbfull_to_yuv709limit,
+    &g_csc_rgbfull_to_yuv709full,
+};
+
+const csc_coef *vo_get_csc_coef(gk_vo_csc_matrix csc_matrix)
+{
+    if ((csc_matrix >= GK_VO_CSC_MATRIX_BT601LIMIT_TO_BT601LIMIT) &&
+        (csc_matrix < GK_VO_CSC_MATRIX_BUTT)) {
+        return g_csc_coef[csc_matrix];
+    }
+
+    return GK_NULL;
+}
+
+const int *vo_get_sin_table(gk_void)
+{
+    return g_sin_table;
+}
+
+const int *vo_get_cos_table(gk_void)
+{
+    return g_cos_table;
+}
+#endif /* #if VO_DESC("UBOOT_VO") */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/src/drv_vo_coef_org_comm.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/drv_vo_coef_org_comm.h
--- u-boot-2016.11/product/osd/vo/arch/comm/src/drv_vo_coef_org_comm.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/drv_vo_coef_org_comm.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,20 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __DRV_VO_COMM_COEF_ORG_H__
+#define __DRV_VO_COMM_COEF_ORG_H__
+
+#include "drv_vo_coef_comm.h"
+#include "hal_vo_def.h"
+#include "common_vo.h"
+#include "inner_vo.h"
+
+#if VO_DESC("UBOOT_VO")
+const csc_coef *vo_get_csc_coef(gk_vo_csc_matrix csc_matrix);
+const int *vo_get_sin_table(gk_void);
+const int *vo_get_cos_table(gk_void);
+#endif /* #if VO_DESC("UBOOT_VO") */
+
+#endif
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/src/drv_vo_comm.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/drv_vo_comm.c
--- u-boot-2016.11/product/osd/vo/arch/comm/src/drv_vo_comm.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/drv_vo_comm.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,139 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "drv_vo_comm.h"
+#include "drv_vo.h"
+#include "hal_vo.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#if VO_DESC("UBOOT")
+#if VO_DESC("pub")
+
+hal_disp_syncinfo g_sync_timing[GK_VO_OUT_BUTT] = {
+    /*
+     * |--INTFACE---||-----TOP-----||----HORIZON--------||----BOTTOM-----||-PULSE-||-INVERSE-|
+     * syncm, iop, itf,   vact, vbb,  vfb,  hact,  hbb,  hfb, hmid,bvact,bvbb, bvfb, hpw, vpw,idv, ihs, ivs
+     */
+    { 0, 0, 0, 288, 22, 2, 720, 132, 12, 1, 288, 23, 2, 126, 3, 0, 0, 0 }, /* 576I(PAL)  */
+    { 0, 0, 0, 240, 18, 4, 720, 119, 19, 1, 240, 19, 4, 124, 3, 0, 0, 0 }, /* 480I(NTSC) */
+    { 0, 0, 0, 288, 22, 2, 960, 176, 16, 1, 288, 23, 2, 168, 3, 0, 0, 0 }, /* 960H(PAL) */
+    { 0, 0, 0, 240, 18, 4, 960, 163, 21, 1, 240, 19, 4, 168, 3, 0, 0, 0 }, /* 960H(NTSC) */
+
+    { 1, 1, 2, 480,  35, 10, 640,  144, 16,  1, 1, 1, 1, 96,  2, 0, 1, 1 }, /* 640*480@60_hz CVT */
+    { 1, 1, 1, 480, 36, 9, 720, 122, 16, 1, 1, 1, 1, 62, 6, 0, 0, 0 }, /* 480P@60_hz */
+    { 1, 1, 1, 576, 44, 5, 720, 132, 12, 1, 1, 1, 1, 64, 5, 0, 0, 0 }, /* 576P@50_hz */
+    { 1, 1, 2, 600,  27, 1,  800,  216, 40,  1, 1, 1, 1, 128, 4, 0, 0, 0 }, /* 800*600@60_hz VGA@60_hz */
+    { 1, 1, 2, 768,  35, 3,  1024, 296, 24,  1, 1, 1, 1, 136, 6, 0, 1, 1 }, /* 1024x768@60_hz */
+    { 0, 1, 1, 720,  25, 5, 1280, 260, 440, 1, 1,   1,  1, 40, 5, 0, 0, 0 }, /* 720P@50_hz */
+    { 0, 1, 1, 720,  25, 5, 1280, 260, 110, 1, 1,   1,  1, 40, 5, 0, 0, 0 }, /* 720P@60_hz */
+    { 1, 1, 2, 800,  28, 3,  1280, 328, 72,  1, 1, 1, 1, 128, 6, 0, 1, 0 }, /* 1280*800@60_hz VGA@60_hz */
+    { 1, 1, 2, 1024, 41, 1,  1280, 360, 48,  1, 1, 1, 1, 112, 3, 0, 0, 0 }, /* 1280x1024@60_hz */
+    { 1, 1, 2, 768,  27, 3,  1366, 356, 70,  1, 1, 1, 1, 143, 3, 0, 0, 0 }, /* 1366x768@60_hz */
+    { 1, 1, 2, 1050, 36, 3,  1400, 376, 88,  1, 1, 1, 1, 144, 4, 0, 0, 0 }, /* 1400x1050@60_hz */
+    { 1, 1, 2, 900,  31, 3,  1440, 384, 80,  1, 1, 1, 1, 152, 6, 0, 1, 0 }, /* 1440x900@60_hz */
+    { 1, 1, 2, 1200, 49, 1,  1600, 496, 64,  1, 1, 1, 1, 192, 3, 0, 0, 0 }, /* 1600*1200@60_hz */
+    { 1, 1, 2, 1050, 36, 3,  1680, 456, 104, 1, 1, 1, 1, 176, 6, 0, 1, 0 }, /* 1680*1050@60_hz */
+
+    { 0, 1, 1, 1080, 41, 4, 1920, 192, 638, 1, 1, 1, 1, 44, 5, 0, 0, 0 }, /* 1080P@24_hz */
+    { 0, 1, 1, 1080, 41, 4, 1920, 192, 528, 1, 1, 1, 1, 44, 5, 0, 0, 0 }, /* 1080P@25_hz */
+    { 0, 1, 1, 1080, 41, 4, 1920, 192, 88,  1, 1, 1, 1, 44, 5, 0, 0, 0 }, /* 1080P@30_hz */
+    { 0, 0, 1, 540,  20, 2, 1920, 192, 528, 1128, 540, 21, 2, 44, 5, 0, 0, 0 }, /* 1080I@50_hz */
+    { 0, 0, 1, 540,  20, 2, 1920, 192, 88,  908,  540, 21, 2, 44, 5, 0, 0, 0 }, /* 1080I@60_hz */
+    { 0, 1, 1, 1080, 41, 4, 1920, 192, 528, 1,    1,   1,  1, 44, 5, 0, 0, 0 }, /* 1080P@50_hz */
+    { 0, 1, 1, 1080, 41, 4, 1920, 192, 88,  1,    1,   1,  1, 44, 5, 0, 0, 0 }, /* 1080P@60_hz */
+
+    { 1, 1, 2, 1200, 32, 3,  1920, 112, 48,  1, 1, 1, 1, 32,  6, 0, 0, 1 }, /* 1920*1200@60_hz CVT (reduced blanking) */
+    { 0, 1, 1, 2160, 72, 8, 1920, 192, 88,   1, 1, 1, 1, 44, 5,  0, 0, 0 }, /* 1920*2160@30_hz */
+    { 1, 1, 2, 1440, 39, 2, 2560, 112, 48,   1, 1, 1, 1, 32, 5,  0, 0, 0 }, /* 2560*1440@30_hz */
+    { 1, 1, 2, 1440, 39, 2, 2560, 112, 48,   1, 1, 1, 1, 32, 5,  0, 0, 0 }, /* 2560*1440@60_hz */
+    { 0, 1, 2, 1600, 43, 3, 2560, 112, 48,   1, 1, 1, 1, 32, 6,  0, 0, 1 }, /* 2560*1600@60_hz CVT (reduced blanking) */
+    { 0, 1, 1, 2160, 82, 8, 3840, 384, 1276, 1, 1, 1, 1, 88, 10, 0, 0, 0 }, /* 3840*2160@24_hz */
+    { 0, 1, 1, 2160, 82, 8, 3840, 384, 1056, 1, 1, 1, 1, 88, 10, 0, 0, 0 }, /* 3840*2160@25_hz */
+    { 0, 1, 1, 2160, 82, 8, 3840, 384, 176,  1, 1, 1, 1, 88, 10, 0, 0, 0 }, /* 3840*2160@30_hz */
+    { 0, 1, 1, 2160, 82, 8, 3840, 384, 1056, 1, 1, 1, 1, 88, 10, 0, 0, 0 }, /* 3840*2160@50_hz */
+    { 0, 1, 1, 2160, 82, 8, 3840, 384, 176,  1, 1, 1, 1, 88, 10, 0, 0, 0 }, /* 3840*2160@60_hz */
+
+    { 0,  1, 1, 2160, 82, 8,  4096, 384, 1020, 1, 1,   1,  1, 88, 10, 0, 0, 0 }, /* 4096x2160@24 */
+    { 0,  1, 1, 2160, 82, 8,  4096, 216, 968,  1, 1,   1,  1, 88, 10, 0, 0, 0 }, /* 4096x2160@25 */
+    { 0,  1, 1, 2160, 82, 8,  4096, 216, 88,   1, 1,   1,  1, 88, 10, 0, 0, 0 }, /* 4096x2160@30 */
+    { 0,  1, 1, 2160, 82, 8,  4096, 216, 968,  1, 1,   1,  1, 88, 10, 0, 0, 0 }, /* 4096x2160@50 */
+    { 0,  1, 1, 2160, 82, 8,  4096, 216, 88,   1, 1,   1,  1, 88, 10, 0, 0, 0 }, /* 4096x2160@60 */
+    { 0,  1, 1, 4320, 64,  16, 7680, 768, 552, 1, 1, 1, 1, 176, 20, 0, 0, 0 }, /* 7680x4320@30 */
+
+    { 0,  1, 1, 320,  10, 4,  240,  30,  10,   1, 1,   1,  1, 10, 2,  0, 0, 0 }, /* 240X320@50  6bit LCD */
+    { 0,  1, 1, 240,  2,  2,  320,  5,   10,   1, 1,   1,  1, 10, 1,  0, 0, 0 }, /* 320X240@50  6bit LCD */
+    { 0,  1, 1, 320,  4,  8,  240,  20,  10,   1, 1,   1,  1, 2,  2,  0, 0, 0 }, /* 240X320@60 16bit LCD */
+    { 0,  1, 1, 240,  15, 9,  320,  65,  7,    1, 240, 14, 9, 1,  1,  0, 0, 0 }, /* 320X240@60  8bit LCD */
+    { 0,  1, 1, 600,  23, 12, 800,  210, 46,   1, 1,   1,  1, 2,  1,  0, 0, 0 }, /* 800X600@60 24bit LCD */
+
+    { 0,  1, 1, 1280, 24,  8,  720,  123, 99,  1, 1, 1, 1, 24,  4,  0, 0, 0 }, /* for MIPI DSI tx 720 x1280 at 60 hz */
+    { 0,  1, 1, 1920, 36,  16, 1080, 28,  130, 1, 1, 1, 1, 8,   10, 0, 0, 0 }, /* for MIPI DSI tx 1080 x1920 at 60 hz */
+    {} /* user */
+};
+
+hal_disp_syncinfo *vo_drv_comm_get_sync_timing(gk_vo_intf_sync sync)
+{
+    return &g_sync_timing[sync];
+}
+
+gk_s32 vou_drv_check_cvbs_sync(gk_vo_dev dev, gk_vo_intf_type intf_type, gk_vo_intf_sync intf_sync)
+{
+    if (intf_type & GK_VO_INTF_CVBS) {
+        if ((intf_sync != GK_VO_OUT_PAL) && (intf_sync != GK_VO_OUT_NTSC)) {
+            vo_err_trace("for CVBS interface, vo%d's intfsync %d illegal!\n", dev, intf_sync);
+            return GK_ERR_VO_NOT_SUPPORT;
+        }
+    }
+
+    return GK_SUCCESS;
+}
+
+hal_disp_pixel_format vou_drv_convert_data_format(vou_layer_pixerl_format data_fmt)
+{
+    hal_disp_pixel_format pixel_format = HAL_DISP_PIXELFORMAT_BUTT;
+
+    if (data_fmt == VOU_LAYER_PIXERL_FORMAT_SP_YCBCR_420) {
+        pixel_format = HAL_INPUTFMT_YCBCR_SEMIPLANAR_420;
+    } else if (data_fmt == VOU_LAYER_PIXERL_FORMAT_SP_YCBCR_422) {
+        pixel_format = HAL_INPUTFMT_YCBCR_SEMIPLANAR_422;
+    } else if (data_fmt == VOU_LAYER_PIXERL_FORMAT_SP_YCBCR_400) {
+        pixel_format = HAL_INPUTFMT_YCBCR_SEMIPLANAR_400;
+    }
+
+    return pixel_format;
+}
+
+gk_void vo_drv_board_init(gk_void)
+{
+    hal_vou_init();
+    vo_drv_default_setting();
+}
+
+gk_void vo_drv_csc_trans_to_register(csc_coef *coef)
+{
+    const gk_s32 dc_precision = 4; /* 4 */
+
+    coef->csc_in_dc0 = dc_precision * coef->csc_in_dc0;
+    coef->csc_in_dc1 = dc_precision * coef->csc_in_dc1;
+    coef->csc_in_dc2 = dc_precision * coef->csc_in_dc2;
+
+    coef->csc_out_dc0 = dc_precision * coef->csc_out_dc0;
+    coef->csc_out_dc1 = dc_precision * coef->csc_out_dc1;
+    coef->csc_out_dc2 = dc_precision * coef->csc_out_dc2;
+}
+
+#endif
+
+#endif /* #if VO_DESC("UBOOT") */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/src/drv_vo_dev_comm.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/drv_vo_dev_comm.c
--- u-boot-2016.11/product/osd/vo/arch/comm/src/drv_vo_dev_comm.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/drv_vo_dev_comm.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,816 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "drv_vo_comm.h"
+#include "drv_vo.h"
+#include "hal_vo.h"
+#include "vo.h"
+#include "math.h"
+#include <common.h>
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#if VO_DESC("UBOOT_VO")
+#if VO_DESC("dev drv api")
+
+gk_u32 vo_drv_get_dev_bg_color(gk_vo_dev dev)
+{
+    vo_drv_dev *drv_dev_ctx = vo_drv_get_dev_ctx(dev);
+    return drv_dev_ctx->vou_attr.bg_color;
+}
+
+gk_vo_intf_type vo_drv_get_dev_intf_type(gk_vo_dev dev)
+{
+    vo_drv_dev *drv_dev_ctx = vo_drv_get_dev_ctx(dev);
+    return drv_dev_ctx->vou_attr.intf_type;
+}
+
+gk_vo_intf_sync vo_drv_get_dev_intf_sync(gk_vo_dev dev)
+{
+    vo_drv_dev *drv_dev_ctx = vo_drv_get_dev_ctx(dev);
+    return drv_dev_ctx->vou_attr.intf_sync;
+}
+
+gk_u32 vo_drv_get_dev_vtth(gk_vo_dev dev)
+{
+    vo_drv_dev *drv_dev_ctx = vo_drv_get_dev_ctx(dev);
+    return drv_dev_ctx->vtth;
+}
+
+gk_u32 vo_drv_get_dev_vtth2(gk_vo_dev dev)
+{
+    vo_drv_dev *drv_dev_ctx = vo_drv_get_dev_ctx(dev);
+    return drv_dev_ctx->vtth2;
+}
+
+gk_void vou_drv_set_disp_max_size(gk_vo_dev dev, gk_u32 max_width, gk_u32 max_height)
+{
+    vo_drv_dev *drv_dev_ctx = vo_drv_get_dev_ctx(dev);
+    drv_dev_ctx->max_width = max_width;
+    drv_dev_ctx->max_height = max_height;
+}
+
+#endif
+#if VO_DESC("dev")
+gk_void vo_drv_get_sync_info(gk_vo_dev dev, hal_disp_syncinfo *sync_info)
+{
+    hal_disp_syncinfo *hal_sync = GK_NULL;
+    gk_vo_sync_info *vo_sync_info = GK_NULL;
+    vo_drv_dev *drv_dev_ctx = vo_drv_get_dev_ctx(dev);
+
+    if (drv_dev_ctx->vou_attr.intf_sync == GK_VO_OUT_USER) {
+        vo_sync_info = &drv_dev_ctx->vou_attr.sync_info;
+        sync_info->syncm = vo_sync_info->syncm;
+        sync_info->iop = vo_sync_info->iop;
+        sync_info->intfb = vo_sync_info->intfb;
+        sync_info->vact = vo_sync_info->vact;
+        sync_info->vbb = vo_sync_info->vbb;
+        sync_info->vfb = vo_sync_info->vfb;
+        sync_info->hact = vo_sync_info->hact;
+        sync_info->hbb = vo_sync_info->hbb;
+        sync_info->hfb = vo_sync_info->hfb;
+        sync_info->hmid = vo_sync_info->hmid;
+        sync_info->bvact = vo_sync_info->bvact;
+        sync_info->bvbb = vo_sync_info->bvbb;
+        sync_info->bvfb = vo_sync_info->bvfb;
+        sync_info->hpw = vo_sync_info->hpw;
+        sync_info->vpw = vo_sync_info->vpw;
+        sync_info->idv = vo_sync_info->idv;
+        sync_info->ihs = vo_sync_info->ihs;
+        sync_info->ivs = vo_sync_info->ivs;
+        return;
+    }
+
+    hal_sync = vo_drv_comm_get_sync_timing(drv_dev_ctx->vou_attr.intf_sync);
+    memcpy(sync_info, hal_sync, sizeof(hal_disp_syncinfo));
+}
+
+gk_void vo_drv_set_sync_info(gk_vo_dev dev, hal_disp_syncinfo *sync_info)
+{
+    vo_hal_intf_set_sync_info(dev, sync_info);
+}
+
+gk_bool vo_drv_is_progressive(gk_vo_dev dev)
+{
+    hal_disp_syncinfo sync_info = {0};
+
+    vo_drv_get_sync_info(dev, &sync_info);
+    return sync_info.iop;
+}
+
+gk_void vo_drv_int_reg_up_mode(gk_vo_layer layer, vo_int_mode int_mode)
+{
+    hal_video_set_layer_up_mode(layer, int_mode);
+}
+
+static gk_u32 vo_drv_get_dev_default_vtth(gk_vo_dev dev)
+{
+    gk_u32 dev_vtth = 0;
+    gk_vo_intf_sync intf_sync;
+
+    if (vo_drv_is_phy_dev_hd(dev)) {
+        intf_sync = vo_drv_get_dev_intf_sync(dev);
+        switch (intf_sync) {
+            case GK_VO_OUT_7680x4320_30:
+                dev_vtth = 8 * VO_HD_VTTH_WATERLINE; /* 8 */
+                break;
+
+            case GK_VO_OUT_3840x2160_60:
+            case GK_VO_OUT_3840x2160_50:
+            case GK_VO_OUT_4096x2160_60:
+            case GK_VO_OUT_4096x2160_50:
+                dev_vtth = 4 * VO_HD_VTTH_WATERLINE; /* 4 */
+                break;
+
+            case GK_VO_OUT_2560x1600_60:
+            case GK_VO_OUT_3840x2160_24:
+            case GK_VO_OUT_3840x2160_25:
+            case GK_VO_OUT_3840x2160_30:
+            case GK_VO_OUT_4096x2160_24:
+            case GK_VO_OUT_4096x2160_25:
+            case GK_VO_OUT_4096x2160_30:
+                dev_vtth = 2 * VO_HD_VTTH_WATERLINE; /* 2 */
+                break;
+
+            default:
+                dev_vtth = VO_HD_VTTH_WATERLINE;
+                break;
+        }
+    } else {
+        dev_vtth = VO_SD_VTTH_WATERLINE;
+    }
+
+    return dev_vtth;
+}
+
+gk_void vo_drv_set_dev_default_vtth(gk_vo_dev dev)
+{
+    vo_drv_dev *drv_dev_ctx = vo_drv_get_dev_ctx(dev);
+
+    if (vo_drv_is_phy_dev_hd(dev) == GK_TRUE) {
+        drv_dev_ctx->vtth = VO_HD_VTTH_WATERLINE;
+    } else {
+        drv_dev_ctx->vtth = VO_SD_VTTH_WATERLINE;
+    }
+}
+
+gk_s32 vo_drv_set_dev_vtth(gk_vo_dev dev, gk_u32 vtth)
+{
+    gk_u32 dft_vtth;
+    gk_u32 vtth_max = VO_MAX_VTTH_WATERLINE;
+    vo_drv_dev *drv_dev_ctx = vo_drv_get_dev_ctx(dev);
+
+    dft_vtth = vo_drv_get_dev_default_vtth(dev);
+    if (vtth > vtth_max) {
+        vo_err_trace("dev:%d, vtth value(%d) should be in range: [%d,%d]\n",
+            dev, vtth, dft_vtth, vtth_max);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    drv_dev_ctx->vtth = MAX2(vtth, dft_vtth);
+    return GK_SUCCESS;
+}
+
+static gk_u32 vo_drv_get_dev_default_vtth2(gk_vo_dev dev)
+{
+    gk_u32 dft_vtth2;
+
+    dft_vtth2 = (vo_drv_is_phy_dev_hd(dev) == GK_TRUE) ? VO_HD_VTTH_WATERLINE2 : VO_SD_VTTH_WATERLINE2;
+    return dft_vtth2;
+}
+
+gk_void vo_drv_set_dev_default_vtth2(gk_vo_dev dev)
+{
+    vo_drv_dev *drv_dev_ctx = vo_drv_get_dev_ctx(dev);
+    drv_dev_ctx->vtth2 = vo_drv_get_dev_default_vtth2(dev);
+}
+
+gk_s32 vo_drv_set_dev_vtth2(gk_vo_dev dev, gk_u32 vtth)
+{
+    gk_u32 dft_vtth2;
+    gk_u32 drv_vtth2;
+    gk_u32 vtth1;
+    gk_u32 vtth_max = VO_MAX_VTTH_WATERLINE;
+    vo_drv_dev *drv_dev_ctx = vo_drv_get_dev_ctx(dev);
+
+    dft_vtth2 = vo_drv_get_dev_default_vtth2(dev);
+    if (vtth > vtth_max) {
+        vo_err_trace("dev:%d, vtth value(%d) should be in range: [%d,%d]\n",
+            dev, vtth, dft_vtth2, vtth_max);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+    drv_vtth2 = MAX2(vtth, dft_vtth2);
+    vtth1 = drv_dev_ctx->vtth;
+
+    drv_dev_ctx->vtth2 = MIN2(drv_vtth2, vtth1);
+    return GK_SUCCESS;
+}
+
+gk_bool vou_drv_get_dev_enable(gk_vo_dev dev)
+{
+    gk_bool intf_en = GK_FALSE;
+
+    hal_disp_get_intf_enable(dev, &intf_en);
+    return intf_en;
+}
+
+static gk_s32 vo_drv_check_dev_pll_param(gk_vo_dev dev, const gk_vo_pll *pll)
+{
+    if ((pll->fb_div > 0xfff) ||
+        (pll->frac > 0xffffff) ||
+        (pll->ref_div > 0x3f) ||
+        (pll->ref_div == 0) ||
+        (pll->post_div1 > 0x7) ||
+        (pll->post_div1 == 0) ||
+        (pll->post_div2 > 0x7) ||
+        (pll->post_div2 == 0)) {
+        vo_err_trace("dev(%d) pll param (fb_div,frac,ref_div,post_div1,post_div2)="
+            "(0x%x,0x%x,0x%x,0x%x,0x%x) illegal .\n", dev,
+            pll->fb_div, pll->frac, pll->ref_div,
+            pll->post_div1, pll->post_div2);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 vo_drv_check_dev_pll_postdiv(gk_vo_dev dev, const gk_vo_pll *pll)
+{
+    if (pll->post_div1 < pll->post_div2) {
+        vo_err_trace("dev(%d) pll postdiv (post_div1,post_div2)="
+            "(0x%x,0x%x) illegal, it should be div1 >= div2.\n", dev, pll->post_div1, pll->post_div2);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 vo_drv_check_dev_pll_foutvco(gk_vo_dev dev, const gk_vo_user_sync_info *sync_info)
+{
+    gk_u32 foutcvo;
+    gk_u32 src_clk;
+    gk_u32 pixel_clk;
+    gk_u32 max_clk;
+    const gk_vo_pll *pll = &(sync_info->user_sync_attr.vo_pll);
+
+    /* 0x01000000: 2^24 */
+    foutcvo = VO_PLL_FREF * pll->fb_div / pll->ref_div + VO_PLL_FREF * pll->frac / VO_PLL_FRAC_PREC / pll->ref_div;
+    if ((foutcvo < VO_PLL_FOUTCVO_MIN) || (foutcvo > VO_PLL_FOUTCVO_MAX)) {
+        vo_err_trace("dev(%d) pll foutcvo (fb_div,frac,ref_div)=(%u,%u,%u) illegal. foutcvo %u, not in [%u, %u]\n",
+            dev, pll->fb_div, pll->frac, pll->ref_div, foutcvo, VO_PLL_FOUTCVO_MIN, VO_PLL_FOUTCVO_MAX);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    src_clk = foutcvo * VO_CLK_MHZ_UNIT / (pll->post_div1 * pll->post_div2);
+    pixel_clk = src_clk / (sync_info->pre_div * sync_info->dev_div);
+    max_clk = vo_drv_dev_get_max_clk(dev);
+    if (pixel_clk > max_clk) {
+        vo_err_trace("dev(%d) pll (fb_div,frac,ref_div,post_div1,post_div2,pre_div,dev_div)=(%u,%u,%u,%u,%u,%u,%u)"
+            " is illegal. pixel clk %uHz is larger than %uHz.\n", dev, pll->fb_div, pll->frac, pll->ref_div,
+            pll->post_div1, pll->post_div2, sync_info->pre_div, sync_info->dev_div, pixel_clk, max_clk);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 vo_drv_check_dev_pll(gk_vo_dev dev, const gk_vo_user_sync_info *sync_info)
+{
+    gk_s32 ret;
+
+    ret = vo_drv_check_dev_pll_param(dev, &sync_info->user_sync_attr.vo_pll);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    ret = vo_drv_check_dev_pll_postdiv(dev, &sync_info->user_sync_attr.vo_pll);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    return vo_drv_check_dev_pll_foutvco(dev, sync_info);
+}
+
+static gk_s32 vo_drv_check_dev_lcdmclkdiv(gk_vo_dev dev, gk_u32 lcd_m_clk_div)
+{
+    if ((lcd_m_clk_div > VO_LCDMCLK_DIV_MAX) || (lcd_m_clk_div == 0)) {
+        vo_err_trace("dev(%d) lcd_mclk value %d illegal, it must be in (0,%d].\n",
+            dev, lcd_m_clk_div, VO_LCDMCLK_DIV_MAX);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    return GK_SUCCESS;
+}
+
+gk_s32 vo_drv_check_dev_clkvalue(gk_vo_dev dev, const gk_vo_user_sync_info *sync_info)
+{
+    gk_s32 ret;
+    gk_vo_clk_src clk_src = sync_info->user_sync_attr.clk_src;
+
+    if ((dev != VO_DEV_DHD0) && (dev != VO_DEV_DHD1)) {
+        return GK_SUCCESS;
+    }
+
+    ret = vo_drv_check_dev_clk_src(dev, sync_info->user_sync_attr.clk_src);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    if ((clk_src == GK_VO_CLK_SRC_PLL) || (clk_src == GK_VO_CLK_SRC_PLL_FOUT4)) {
+        return vo_drv_check_dev_pll(dev, sync_info);
+    } else if (clk_src == GK_VO_CLK_SRC_LCDMCLK) {
+        return vo_drv_check_dev_lcdmclkdiv(dev, sync_info->user_sync_attr.lcd_m_clk_div);
+    } else if (clk_src == GK_VO_CLK_SRC_FIXED) {
+        return vo_drv_check_dev_fixed_clk(dev, sync_info->user_sync_attr.fixed_clk);
+    }
+
+    return GK_ERR_VO_ILLEGAL_PARAM;
+}
+
+gk_s32 vou_drv_check_dsd_intf(gk_vo_dev dev, gk_vo_intf_type intf_type)
+{
+    if ((intf_type & ~(GK_VO_INTF_CVBS)) || (intf_type == 0)) {
+        vo_err_trace("vo device%d does not support intf(%d) !\n", dev, intf_type);
+        return GK_ERR_VO_NOT_SUPPORT;
+    }
+
+    return GK_SUCCESS;
+}
+
+gk_s32 vou_drv_check_dev_sync(gk_vo_dev dev, gk_vo_intf_type intf_type, gk_vo_intf_sync intf_sync)
+{
+    gk_s32 ret;
+
+    if ((intf_sync == GK_VO_OUT_960H_PAL) || (intf_sync == GK_VO_OUT_960H_NTSC)) {
+        vo_err_trace("vo%d's intfsync %d illegal, vo doesn't support interlaced sync %d!\n", dev,
+            intf_sync, intf_sync);
+        return GK_ERR_VO_NOT_SUPPORT;
+    }
+
+    ret = vou_drv_check_hdmi_sync(dev, intf_type, intf_sync);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    ret = vou_drv_check_bt_sync(dev, intf_type, intf_sync);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    ret = vou_drv_check_vga_sync(dev, intf_type, intf_sync);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    ret = vou_drv_check_cvbs_sync(dev, intf_type, intf_sync);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    ret = vou_drv_check_rgb_sync(dev, intf_type, intf_sync);
+    return ret;
+}
+
+static gk_s32 vo_drv_check_bool_value(gk_bool bool_val)
+{
+    if ((bool_val != GK_TRUE) && (bool_val != GK_FALSE)) {
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 vo_drv_check_dev_bool_sync_info(gk_vo_dev dev, const gk_vo_sync_info *sync_info)
+{
+    if ((vo_drv_check_bool_value(sync_info->syncm) != GK_SUCCESS) ||
+        (vo_drv_check_bool_value(sync_info->iop) != GK_SUCCESS) ||
+        (vo_drv_check_bool_value(sync_info->idv) != GK_SUCCESS) ||
+        (vo_drv_check_bool_value(sync_info->ihs) != GK_SUCCESS) ||
+        (vo_drv_check_bool_value(sync_info->ivs) != GK_SUCCESS)) {
+        vo_err_trace("vo%d: sync's syncm(%d),iop(%d),idv(%d),ihs(%d),ivs(%u) should be %u or %u!\n",
+            dev, sync_info->syncm, sync_info->iop, sync_info->idv, sync_info->ihs, sync_info->ivs, GK_TRUE, GK_FALSE);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 vo_drv_check_dev_vertical_sync_info(gk_vo_dev dev, const gk_vo_sync_info *sync_info)
+{
+    if (sync_info->intfb > VO_MAX_USER_SYNC_INTFB) {
+        vo_err_trace("vo%d: sync's intfb(%u) should be [0, %u]!", dev, sync_info->intfb, VO_MAX_USER_SYNC_INTFB);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    if ((sync_info->vact < VO_MIN_USER_SYNC_VACT) || (sync_info->vact > VO_MAX_USER_SYNC_VACT)) {
+        vo_err_trace("vo%d: sync's vact(%u) should be [%u, %u]!\n", dev, sync_info->vact,
+            VO_MIN_USER_SYNC_VACT, VO_MAX_USER_SYNC_VACT);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    if ((sync_info->vbb < VO_MIN_USER_SYNC_VBB) || (sync_info->vbb > VO_MAX_USER_SYNC_VBB)) {
+        vo_err_trace("vo%d: sync's vbb(%u) should be [%u, %u]!\n", dev, sync_info->vbb,
+            VO_MIN_USER_SYNC_VBB, VO_MAX_USER_SYNC_VBB);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    if ((sync_info->vfb < VO_MIN_USER_SYNC_VFB) || (sync_info->vfb > VO_MAX_USER_SYNC_VFB)) {
+        vo_err_trace("vo%d: sync's vfb(%u) should be [%u, %u]!\n", dev, sync_info->vfb,
+            VO_MIN_USER_SYNC_VFB, VO_MAX_USER_SYNC_VFB);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 vo_drv_check_dev_horizontal_sync_info(gk_vo_dev dev, const gk_vo_sync_info *sync_info)
+{
+    if ((sync_info->hact < VO_MIN_USER_SYNC_HACT) || (sync_info->hact > VO_MAX_USER_SYNC_HACT)) {
+        vo_err_trace("vo%d: sync's hact(%u) should be [%u, %u]!\n", dev, sync_info->hact,
+            VO_MIN_USER_SYNC_HACT, VO_MAX_USER_SYNC_HACT);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    if (sync_info->hbb < VO_MIN_USER_SYNC_HBB) {
+        vo_err_trace("vo%d: sync's hbb(%u) should be [%u, %u]!\n", dev, sync_info->hbb,
+            VO_MIN_USER_SYNC_HBB, VO_MAX_USER_SYNC_HBB);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    if (sync_info->hfb < VO_MIN_USER_SYNC_HFB) {
+        vo_err_trace("vo%d: sync's hfb(%u) should be [%u, %u]!\n", dev, sync_info->hfb,
+            VO_MIN_USER_SYNC_HFB, VO_MAX_USER_SYNC_HFB);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 vo_drv_check_dev_bottom_sync_info(gk_vo_dev dev, const gk_vo_sync_info *sync_info)
+{
+    if ((sync_info->iop == 0) && ((sync_info->bvact == 0) || (sync_info->bvbb == 0) || (sync_info->bvfb == 0))) {
+        vo_err_trace("vo%d: sync's bvact(%u) bvbb(%u) bvfb(%u) can't be 0 when interlaced timing!\n",
+            dev, sync_info->bvact, sync_info->bvbb, sync_info->bvfb);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    if (sync_info->bvact > VO_MAX_USER_SYNC_BVACT) {
+        vo_err_trace("vo%d: sync's bvact(%u) should be [0, %u]!", dev, sync_info->bvact, VO_MAX_USER_SYNC_BVACT);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    if (sync_info->bvbb > VO_MAX_USER_SYNC_BVBB) {
+        vo_err_trace("vo%d: sync's bvbb(%u) should be [0, %u]!", dev, sync_info->bvbb, VO_MAX_USER_SYNC_BVBB);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    if (sync_info->bvfb > VO_MAX_USER_SYNC_BVFB) {
+        vo_err_trace("vo%d: sync's bvfb(%u) should be [0, %u]!", dev, sync_info->bvfb, VO_MAX_USER_SYNC_BVFB);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 vo_drv_check_dev_pulse_sync_info(gk_vo_dev dev, const gk_vo_sync_info *sync_info)
+{
+    if (sync_info->hpw < VO_MIN_USER_SYNC_HPW) {
+        vo_err_trace("vo%d: sync's hpw(%u) should be [%u, %u]!\n", dev, sync_info->hpw,
+            VO_MIN_USER_SYNC_HPW, VO_MAX_USER_SYNC_HPW);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    if ((sync_info->vpw < VO_MIN_USER_SYNC_VPW) || (sync_info->vpw > VO_MAX_USER_SYNC_VPW)) {
+        vo_err_trace("vo%d: sync's vpw(%u) should be [%u, %u]!\n", dev, sync_info->vpw,
+            VO_MIN_USER_SYNC_VPW, VO_MAX_USER_SYNC_VPW);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 vo_drv_check_dev_sync_info(gk_vo_dev dev, const gk_vo_sync_info *sync_info)
+{
+    gk_s32 ret;
+
+    ret = vo_drv_check_dev_bool_sync_info(dev, sync_info);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    ret = vo_drv_check_dev_vertical_sync_info(dev, sync_info);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    ret = vo_drv_check_dev_horizontal_sync_info(dev, sync_info);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    ret = vo_drv_check_dev_bottom_sync_info(dev, sync_info);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    ret = vo_drv_check_dev_pulse_sync_info(dev, sync_info);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    return GK_SUCCESS;
+}
+
+gk_s32 vou_drv_check_dev_pub_attr(gk_vo_dev dev, const gk_vo_pub_attr *pub_attr)
+{
+    gk_s32 ret = GK_SUCCESS;
+
+    if (vo_drv_is_phy_dev_hd(dev) || vo_drv_is_phy_dev_sd(dev)) {
+        ret = vou_drv_check_dev_intf(dev, pub_attr->intf_type);
+        if (ret != GK_SUCCESS) {
+            vo_err_trace("vo%d check device's interface %d illegal!\n", dev, pub_attr->intf_type);
+            return ret;
+        }
+    }
+
+    if (pub_attr->intf_sync == GK_VO_OUT_USER) {
+        /*
+         * user defined sync will be welcome for all interface type
+         * WARNING: user must make sure to config right sync, otherwise, screen dosen't work!
+         */
+        return vo_drv_check_dev_sync_info(dev, &(pub_attr->sync_info));
+    }
+
+    ret = vou_drv_check_dev_sync(dev, pub_attr->intf_type, pub_attr->intf_sync);
+    return ret;
+}
+
+gk_void vo_drv_get_dev_reg_up(gk_vo_dev dev)
+{
+    gk_u64 start;
+    start = get_timer(0);
+
+    do {
+        if (get_timer(start) >= VO_DEV_REG_UP_TIMEOUT) { /* 50 ms */
+            break;
+        }
+    } while (hal_disp_get_reg_up(dev) != 0);
+}
+
+#endif
+
+#if VO_DESC("dev layer prio")
+
+gk_void vou_drv_set_layer_priority(gk_vo_dev dev, gk_vo_layer layer, gk_u32 priority)
+{
+    hal_cbm_set_cbm_mixer_prio(layer, priority, dev);
+
+    hal_disp_set_reg_up(dev);
+}
+#endif
+
+#if VO_DESC("dev intf")
+gk_void vou_drv_intf_csc_config(gk_vo_intf_type intf, const gk_vo_csc *csc)
+{
+    csc_coef coef;
+
+    memset(&coef, 0x0, sizeof(csc_coef));
+
+    vou_drv_calc_csc_matrix(csc, csc->csc_matrix, &coef);
+
+    vo_drv_csc_trans_to_register(&coef);
+
+    vo_hal_intf_set_csc_cfg(intf, &coef);
+}
+
+gk_void vo_drv_set_vga_param(gk_vo_dev dev, const gk_vo_vga_param *vga_param)
+{
+    vo_hal_intf_set_csc_enable(GK_VO_INTF_VGA, GK_TRUE);
+    vou_drv_intf_csc_config(GK_VO_INTF_VGA, &vga_param->csc);
+    vo_hal_intf_set_dac_gc(GK_VO_INTF_VGA, vga_param->gain);
+    vo_hal_intf_set_vga_hsp_cfg(GK_TRUE, (gk_u32)vga_param->sharpen_strength);
+    hal_disp_set_reg_up(dev);
+}
+
+gk_void vo_drv_set_hdmi_mode(gk_vo_dev dev, const gk_vo_hdmi_param *hdmi_param)
+{
+    if ((hdmi_param->csc.csc_matrix >= GK_VO_CSC_MATRIX_BT601LIMIT_TO_RGBFULL) &&
+        (hdmi_param->csc.csc_matrix <= GK_VO_CSC_MATRIX_BT709FULL_TO_RGBLIMIT)) {
+        hal_disp_set_hdmi_mode(dev, 1);  /* 1: RGB */
+    } else  {
+        hal_disp_set_hdmi_mode(dev, 0);  /* 0: RGB */
+    }
+}
+
+gk_void vo_drv_set_hdmi_param(gk_vo_dev dev, const gk_vo_hdmi_param *hdmi_param)
+{
+    vo_hal_intf_set_csc_enable(GK_VO_INTF_HDMI, GK_TRUE);
+    vou_drv_intf_csc_config(GK_VO_INTF_HDMI, &hdmi_param->csc);
+    vo_drv_set_hdmi_mode(dev, hdmi_param);
+    hal_disp_set_reg_up(dev);
+}
+
+gk_void vo_drv_set_rgb_param(gk_vo_dev dev, const gk_vo_rgb_param *rgb_param)
+{
+    vo_hal_intf_set_csc_enable(GK_VO_INTF_RGB_6BIT, GK_TRUE);
+    vou_drv_intf_csc_config(GK_VO_INTF_RGB_6BIT, &rgb_param->csc);
+    hal_disp_set_reg_up(dev);
+}
+
+gk_void vo_drv_set_dev_mpp_chn(gk_vo_dev dev, gk_mpp_chn *mpp_chn)
+{
+    mpp_chn->mod_id = GK_ID_VO;
+    mpp_chn->chn_id = 0;
+    mpp_chn->dev_id = dev;
+}
+
+gk_bool vo_drv_is_hdmi_intf(gk_vo_intf_type intf_type)
+{
+    if (intf_type & GK_VO_INTF_HDMI) {
+        return GK_TRUE;
+    }
+    return GK_FALSE;
+}
+
+gk_bool vo_drv_is_bt1120_intf(gk_vo_intf_type intf_type)
+{
+    if ((intf_type & GK_VO_INTF_BT1120)) {
+        return GK_TRUE;
+    }
+    return GK_FALSE;
+}
+
+gk_bool vo_drv_is_rgb_intf(gk_vo_intf_type intf_type)
+{
+    if ((intf_type & GK_VO_INTF_RGB_6BIT) ||
+        (intf_type & GK_VO_INTF_RGB_8BIT) ||
+        (intf_type & GK_VO_INTF_RGB_16BIT) ||
+        (intf_type & GK_VO_INTF_RGB_18BIT) ||
+        (intf_type & GK_VO_INTF_RGB_24BIT)) {
+        return GK_TRUE;
+    }
+    return GK_FALSE;
+}
+
+gk_bool vo_drv_is_mipi_intf(gk_vo_intf_type intf_type)
+{
+    if ((intf_type & GK_VO_INTF_MIPI) ||
+        (intf_type & GK_VO_INTF_MIPI_SLAVE)) {
+        return GK_TRUE;
+    }
+    return GK_FALSE;
+}
+#endif
+
+#if VO_DESC("dev interrupt")
+
+gk_void vo_drv_int_set_mode(gk_vo_dev dev, vo_int_mode int_mode)
+{
+    hal_disp_set_vtthd_mode(dev, int_mode);
+}
+#endif
+
+#if VO_DESC("check dev id")
+gk_s32 vo_drv_check_dev_id_pub(gk_vo_dev dev)
+{
+    if ((dev < 0) || (dev >= GK_VO_MAX_DEV_NUM)) {
+        return GK_ERR_VO_INVALID_DEV_ID;
+    }
+    return GK_SUCCESS;
+}
+
+#endif
+
+#if VO_DESC("check layer id")
+gk_s32 vo_drv_check_layer_id_pub(gk_vo_layer layer)
+{
+    if ((layer < 0) || (layer >= GK_VO_MAX_LAYER_NUM)) {
+        return GK_ERR_VO_INVALID_LAYER_ID;
+    }
+    return GK_SUCCESS;
+}
+
+#endif
+
+gk_void vo_drv_set_pub_attr(gk_vo_dev dev, const gk_vo_pub_attr *pub_attr)
+{
+    vo_drv_dev *drv_dev_ctx = GK_NULL;
+    drv_dev_ctx = vo_drv_get_dev_ctx(dev);
+
+    memcpy(&drv_dev_ctx->vou_attr, pub_attr, sizeof(gk_vo_pub_attr));
+    drv_dev_ctx->config = GK_TRUE;
+}
+
+gk_void vo_drv_enable(gk_vo_dev dev)
+{
+    vo_drv_dev *drv_dev_ctx = vo_drv_get_dev_ctx(dev);
+    drv_dev_ctx->vo_enable = GK_TRUE;
+}
+
+gk_void vo_drv_disable(gk_vo_dev dev)
+{
+    vo_drv_dev *drv_dev_ctx = vo_drv_get_dev_ctx(dev);
+
+    drv_dev_ctx->config = GK_FALSE;
+    drv_dev_ctx->vo_enable = GK_FALSE;
+    memset(&drv_dev_ctx->vou_attr, 0, sizeof(gk_vo_pub_attr));
+}
+
+gk_u32 vou_drv_get_dev_layer_num(gk_vo_dev dev)
+{
+    vo_drv_dev *dev_ctx = GK_NULL;
+    dev_ctx = vo_drv_get_dev_ctx(dev);
+    return dev_ctx->layer_num;
+}
+
+gk_void vou_drv_get_dev_layer(gk_vo_dev dev, gk_vo_layer *layer, gk_u32 vo_layer_num)
+{
+    gk_u32 layer_num;
+    gk_u32 i, j;
+    vo_drv_layer *layer_ctx = GK_NULL;
+
+    layer_num = vou_drv_get_dev_layer_num(dev);
+    if (layer_num > vo_layer_num) {
+        vo_err_trace("the layer num(%u) is larger than the input num(%u)", layer_num, vo_layer_num);
+        layer_num = vo_layer_num;
+    }
+
+    for (i = 0, j = 0; i < GK_VO_MAX_LAYER_NUM; i++) {
+        layer_ctx = vo_drv_get_layer_ctx(i);
+        if (dev == layer_ctx->bind_dev) {
+            *(layer + j) = i;
+            j++;
+        }
+
+        if (j == layer_num) {
+            return;
+        }
+    }
+
+    return;
+}
+
+#if VO_DESC("dev")
+gk_bool vo_drv_is_phy_dev_uhd(gk_vo_dev dev)
+{
+    if (dev == VO_DEV_DHD0) {
+        return GK_TRUE;
+    }
+
+    return GK_FALSE;
+}
+
+gk_bool vo_drv_is_phy_dev_hd(gk_vo_dev dev)
+{
+    if ((dev == VO_DEV_DHD0) ||
+        (dev == VO_DEV_DHD1)) {
+        return GK_TRUE;
+    }
+
+    return GK_FALSE;
+}
+
+gk_bool vo_drv_is_phy_dev_sd(gk_vo_dev dev)
+{
+    if ((dev == VO_DEV_DSD0)) {
+        return GK_TRUE;
+    }
+
+    return GK_FALSE;
+}
+#endif
+
+gk_vo_layer vo_drv_get_gfx_layer(gk_vo_dev dev)
+{
+    hal_disp_layer hal_layer;
+
+    switch (dev) {
+        case VO_DEV_DHD0:
+            hal_layer = HAL_DISP_LAYER_GFX0;
+            break;
+        case VO_DEV_DHD1:
+            hal_layer = HAL_DISP_LAYER_GFX1;
+            break;
+        case VO_DEV_DSD0:
+            hal_layer = HAL_DISP_LAYER_GFX3;
+            break;
+        default:
+            hal_layer = HAL_DISP_LAYER_BUTT;
+            break;
+    }
+
+    return hal_layer;
+}
+
+#endif /* #if VO_DESC("UBOOT_VO") */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/src/drv_vo_gfx_comm.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/drv_vo_gfx_comm.c
--- u-boot-2016.11/product/osd/vo/arch/comm/src/drv_vo_gfx_comm.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/drv_vo_gfx_comm.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,138 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "drv_vo_gfx_comm.h"
+#include "drv_vo_gfx.h"
+#include "mkp_vo_bmp.h"
+
+#include "drv_vo.h"
+#include "hal_vo.h"
+#include "drv_vo_coef_org_comm.h"
+#include "vo.h"
+#include <common.h>
+
+#if VO_DESC("UBOOT_VO")
+#if VO_DESC("vo gfx csc")
+
+gk_s32 vo_drv_set_gfx_layer_csc(gk_vo_layer gfx_layer, gk_vo_csc *csc, csc_coef_param *csc_param)
+{
+    gk_s32 ret;
+    hal_disp_layer hal_layer;
+    csc_coef coef;
+
+    ret = vo_drv_get_hal_gfx_layer(gfx_layer, &hal_layer);
+    if (ret != GK_SUCCESS) {
+        vo_err_trace("gfx layer %d is illegal!\n", gfx_layer);
+        return GK_ERR_VO_INVALID_LAYER_ID;
+    }
+
+    vou_drv_calc_csc_matrix(csc, csc->csc_matrix, &coef);
+
+    coef.new_csc_scale2p = GFX_CSC_SCALE;
+    coef.new_csc_clip_min = GFX_CSC_CLIP_MIN;
+    coef.new_csc_clip_max = GFX_CSC_CLIP_MAX;
+
+    vo_drv_csc_trans_to_register(&coef);
+
+    vo_drv_clip_layer_csc_coef(&coef);
+
+    hal_layer_set_csc_coef(hal_layer, &coef);
+
+    return GK_SUCCESS;
+}
+
+#endif
+
+#if VO_DESC("vo gfx open")
+static gk_s32 vo_drv_gfx_check_image_stride_and_xywh(gk_vo_gfx_attr *gfx_attr_out, osd_logo_t *scroll_image_logo)
+{
+    if ((gfx_attr_out->stride != scroll_image_logo->stride) ||
+        (gfx_attr_out->display_rect.width != scroll_image_logo->width) ||
+        (gfx_attr_out->display_rect.height != scroll_image_logo->height)) {
+        vo_err_trace("logo's stride=%d, w=%d, h=%d is not equal to gfx attr stride=%d, w=%d, h=%d\n",
+            scroll_image_logo->stride, scroll_image_logo->width, scroll_image_logo->height,
+            gfx_attr_out->stride, gfx_attr_out->display_rect.width, gfx_attr_out->display_rect.height);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+    return GK_SUCCESS;
+}
+
+gk_s32 vo_drv_gfx_convert_gfx_attr(const gk_vo_gfx_attr *gfx_attr_in, gk_vo_gfx_attr *gfx_attr_out)
+{
+    gk_phys_addr_t addr;
+    osd_logo_t scroll_image_logo = {0};
+
+    if (gfx_attr_in->type == GK_VO_GFX_TYPE_ARGB1555) {
+        *gfx_attr_out = *gfx_attr_in;
+    } else if (gfx_attr_in->type == GK_VO_GFX_TYPE_BMP1555) {
+        addr = gfx_attr_in->address;
+        if (load_bmp(addr, &scroll_image_logo) != 0) {
+            return GK_FAILURE;
+        }
+        gfx_attr_out->address = scroll_image_logo.rgb_buffer;
+        gfx_attr_out->stride = gfx_attr_in->stride;
+        gfx_attr_out->display_rect = gfx_attr_in->display_rect;
+        (gk_void)vo_drv_gfx_check_image_stride_and_xywh(gfx_attr_out, &scroll_image_logo);
+    } else {
+        vo_err_trace("gfx unknown input type %d\n", gfx_attr_in->type);
+        return GK_FAILURE;
+    }
+
+    vo_dcache_range(gfx_attr_out->address, gfx_attr_out->stride * gfx_attr_out->display_rect.height);
+
+    return GK_SUCCESS;
+}
+
+gk_void vo_drv_gfx_open(gk_vo_layer gfx_id, const gk_vo_gfx_attr *gfx_attr)
+{
+    gk_s32 ret;
+    hal_disp_layer vo_layer;
+    gk_phys_addr_t addr;
+    gk_u32 strd;
+    gk_rect gx_rect;
+
+    ret = vo_drv_get_hal_gfx_layer(gfx_id, &vo_layer);
+    if (ret != GK_SUCCESS) {
+        vo_err_trace("get gfx id failed.\n");
+        return;
+    }
+    addr = gfx_attr->address;
+    strd = gfx_attr->stride;
+    gx_rect = gfx_attr->display_rect;
+
+    hal_gfx_set_pixel_alpha_range(vo_layer, 0xff);
+    hal_layer_set_layer_global_alpha(vo_layer, 0xff);
+    hal_gfx_set_gfx_pre_mult(vo_layer, GK_FALSE);
+
+    hal_gfx_set_gfx_addr(vo_layer, addr);
+    hal_gfx_set_gfx_stride(vo_layer, strd >> 4); /* stride div 16(2 ^ 4) */
+    hal_gfx_set_layer_in_rect(vo_layer, &gx_rect);
+
+    hal_gfx_set_layer_disp_rect(vo_layer, &gx_rect);
+    hal_gfx_set_layer_video_rect(vo_layer, &gx_rect);
+
+    hal_gfx_set_src_resolution(vo_layer, &gx_rect);
+
+    hal_gfx_set_layer_data_fmt(vo_layer, HAL_INPUTFMT_ARGB_1555);
+
+    hal_gfx_enable_layer(vo_layer, GK_TRUE);
+    hal_gfx_set_reg_up(vo_layer);
+}
+
+gk_void vo_drv_gfx_close(gk_vo_layer layer_id)
+{
+    gk_s32 ret;
+    hal_disp_layer hal_gfx_layer;
+
+    ret = vo_drv_get_hal_gfx_layer(layer_id, &hal_gfx_layer);
+    if (ret != GK_SUCCESS) {
+        return;
+    }
+
+    hal_gfx_set_reg_up(hal_gfx_layer);
+    hal_gfx_enable_layer(hal_gfx_layer, GK_FALSE);
+    hal_gfx_set_reg_up(hal_gfx_layer);
+}
+#endif
+#endif /* #if VO_DESC("UBOOT_VO") */
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/src/drv_vo_layer_comm.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/drv_vo_layer_comm.c
--- u-boot-2016.11/product/osd/vo/arch/comm/src/drv_vo_layer_comm.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/drv_vo_layer_comm.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,218 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "drv_vo_layer_comm.h"
+#include "drv_vo.h"
+#include "hal_vo.h"
+#include "drv_vo_coef_org_comm.h"
+#include "vo.h"
+#include "math.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#if VO_DESC("UBOOT_VO")
+#if VO_DESC("layer csc")
+
+gk_s32 vo_drv_get_csc_matrix(gk_vo_csc_matrix csc_matrix, const csc_coef **csc_tmp)
+{
+    *csc_tmp = vo_get_csc_coef(csc_matrix);
+    if (*csc_tmp == GK_NULL) {
+        return GK_ERR_VO_NULL_PTR;
+    }
+    return GK_SUCCESS;
+}
+
+gk_void vo_drv_calculate_yuv2rgb(hal_csc_value *csc_value, const csc_coef *csc_tmp, csc_coef *coef)
+{
+    gk_s32 luma;
+    gk_s32 contrast;
+    gk_s32 hue;
+    gk_s32 satu;
+    const gk_s32 csc_value_times = 100;
+    const gk_s32 table_times = 1000;
+    gk_s32 square_cv_times = csc_value_times * csc_value_times;
+    const int *cos_table = vo_get_cos_table();
+    const int *sin_table = vo_get_sin_table();
+
+    luma = csc_value->luma;
+    contrast = csc_value->cont;
+    hue = csc_value->hue;
+    satu = csc_value->satu;
+
+    coef->csc_coef00 = (contrast * csc_tmp->csc_coef00) / csc_value_times;
+    coef->csc_coef01 = (contrast * satu * ((csc_tmp->csc_coef01 * cos_table[hue] - csc_tmp->csc_coef02 *
+                                            sin_table[hue]) / table_times)) / square_cv_times;
+    coef->csc_coef02 = (contrast * satu * ((csc_tmp->csc_coef01 * sin_table[hue] + csc_tmp->csc_coef02 *
+                                            cos_table[hue]) / table_times)) / square_cv_times;
+    coef->csc_coef10 = (contrast * csc_tmp->csc_coef10) / csc_value_times;
+    coef->csc_coef11 = (contrast * satu * ((csc_tmp->csc_coef11 * cos_table[hue] - csc_tmp->csc_coef12 *
+                                            sin_table[hue]) / table_times)) / square_cv_times;
+    coef->csc_coef12 = (contrast * satu * ((csc_tmp->csc_coef11 * sin_table[hue] + csc_tmp->csc_coef12 *
+                                            cos_table[hue]) / table_times)) / square_cv_times;
+    coef->csc_coef20 = (contrast * csc_tmp->csc_coef20) / csc_value_times;
+    coef->csc_coef21 = (contrast * satu * ((csc_tmp->csc_coef21 * cos_table[hue] - csc_tmp->csc_coef22 *
+                                            sin_table[hue]) / table_times)) / square_cv_times;
+    coef->csc_coef22 = (contrast * satu * ((csc_tmp->csc_coef21 * sin_table[hue] + csc_tmp->csc_coef22 *
+                                            cos_table[hue]) / table_times)) / square_cv_times;
+    coef->csc_in_dc0 += (contrast != 0) ? (luma * 100 / contrast) : luma * 100;  /* 100 */
+}
+
+gk_void vo_drv_calculate_rgb2yuv(hal_csc_value *csc_value, const csc_coef *csc_tmp, csc_coef *coef)
+{
+    gk_s32 luma;
+    gk_s32 contrast;
+    gk_s32 hue;
+    gk_s32 satu;
+    const gk_s32 csc_value_times = 100;
+    const gk_s32 table_times = 1000;
+    gk_s32 square_cv_times = csc_value_times * csc_value_times;
+    const int *cos_table = vo_get_cos_table();
+    const int *sin_table = vo_get_sin_table();
+
+    luma = csc_value->luma;
+    contrast = csc_value->cont;
+    hue = csc_value->hue;
+    satu = csc_value->satu;
+
+    coef->csc_coef00 = (contrast * csc_tmp->csc_coef00) / csc_value_times;
+    coef->csc_coef01 = (contrast * csc_tmp->csc_coef01) / csc_value_times;
+    coef->csc_coef02 = (contrast * csc_tmp->csc_coef02) / csc_value_times;
+    coef->csc_coef10 = (contrast * satu * ((csc_tmp->csc_coef10 * cos_table[hue] + csc_tmp->csc_coef20 *
+                                            sin_table[hue]) / table_times)) / square_cv_times;
+    coef->csc_coef11 = (contrast * satu * ((csc_tmp->csc_coef11 * cos_table[hue] + csc_tmp->csc_coef21 *
+                                            sin_table[hue]) / table_times)) / square_cv_times;
+    coef->csc_coef12 = (contrast * satu * ((csc_tmp->csc_coef12 * cos_table[hue] + csc_tmp->csc_coef22 *
+                                            sin_table[hue]) / table_times)) / square_cv_times;
+    coef->csc_coef20 = (contrast * satu * ((csc_tmp->csc_coef20 * cos_table[hue] - csc_tmp->csc_coef10 *
+                                            sin_table[hue]) / table_times)) / square_cv_times;
+    coef->csc_coef21 = (contrast * satu * ((csc_tmp->csc_coef21 * cos_table[hue] - csc_tmp->csc_coef11 *
+                                            sin_table[hue]) / table_times)) / square_cv_times;
+    coef->csc_coef22 = (contrast * satu * ((csc_tmp->csc_coef22 * cos_table[hue] - csc_tmp->csc_coef12 *
+                                            sin_table[hue]) / table_times)) / square_cv_times;
+    coef->csc_out_dc0 += luma;
+}
+
+gk_void vou_drv_calc_csc_matrix(const gk_vo_csc *csc, gk_vo_csc_matrix csc_matrix, csc_coef *coef)
+{
+    gk_s32 ret;
+    const csc_coef *csc_tmp = GK_NULL;
+    hal_csc_value csc_value;
+
+    if (csc->ex_csc_en == GK_FALSE) {
+        csc_value.luma = (gk_s32)csc->luma * 64 / 100 - 32; /* 64: -32~32 100  */
+    } else {
+        csc_value.luma = (gk_s32)csc->luma * 256 / 100 - 128; /* 256: -128~128 128 100  */
+    }
+
+    csc_value.cont = ((gk_s32)csc->contrast - 50) * 2 + 100; /* 50 2 100 */
+    csc_value.hue = (gk_s32)csc->hue * 60 / 100;             /* 60 100  */
+    csc_value.satu = ((gk_s32)csc->saturation - 50) * 2 + 100; /* 50 2 100  */
+
+    ret = vo_drv_get_csc_matrix(csc_matrix, &csc_tmp);
+    if (ret != GK_SUCCESS) {
+        return;
+    }
+
+    coef->csc_in_dc0 = csc_tmp->csc_in_dc0;
+    coef->csc_in_dc1 = csc_tmp->csc_in_dc1;
+    coef->csc_in_dc2 = csc_tmp->csc_in_dc2;
+    coef->csc_out_dc0 = csc_tmp->csc_out_dc0;
+    coef->csc_out_dc1 = csc_tmp->csc_out_dc1;
+    coef->csc_out_dc2 = csc_tmp->csc_out_dc2;
+
+    if ((csc_matrix >= GK_VO_CSC_MATRIX_BT601LIMIT_TO_RGBFULL) &&
+        (csc_matrix <= GK_VO_CSC_MATRIX_BT709FULL_TO_RGBLIMIT)) {
+        vo_drv_calculate_yuv2rgb(&csc_value, csc_tmp, coef);
+    } else {
+        vo_drv_calculate_rgb2yuv(&csc_value, csc_tmp, coef);
+    }
+}
+
+gk_void vo_drv_clip_layer_csc_coef(csc_coef *coef)
+{
+    gk_s32 min_coef = 0;
+    gk_s32 max_coef = 0;
+
+    vo_drv_get_layer_csc_coef_range(&min_coef, &max_coef);
+    coef->csc_coef00 = CLIP3(coef->csc_coef00, min_coef, max_coef);
+    coef->csc_coef01 = CLIP3(coef->csc_coef01, min_coef, max_coef);
+    coef->csc_coef02 = CLIP3(coef->csc_coef02, min_coef, max_coef);
+
+    coef->csc_coef10 = CLIP3(coef->csc_coef10, min_coef, max_coef);
+    coef->csc_coef11 = CLIP3(coef->csc_coef11, min_coef, max_coef);
+    coef->csc_coef12 = CLIP3(coef->csc_coef12, min_coef, max_coef);
+
+    coef->csc_coef20 = CLIP3(coef->csc_coef20, min_coef, max_coef);
+    coef->csc_coef21 = CLIP3(coef->csc_coef21, min_coef, max_coef);
+    coef->csc_coef22 = CLIP3(coef->csc_coef22, min_coef, max_coef);
+}
+
+gk_void vou_drv_layer_csc_config(gk_vo_layer layer, gk_vo_csc *csc, csc_coef_param *csc_param)
+{
+    csc_coef coef;
+    vo_drv_layer *drv_layer_ctx = GK_NULL;
+
+    vou_drv_calc_csc_matrix(csc, csc->csc_matrix, &coef);
+
+    drv_layer_ctx = vo_drv_get_layer_ctx(layer);
+    coef.new_csc_clip_max = drv_layer_ctx->csc_param.csc_clip_max;
+    coef.new_csc_clip_min = drv_layer_ctx->csc_param.csc_clip_min;
+    coef.new_csc_scale2p = drv_layer_ctx->csc_param.csc_scale2p;
+
+    vo_drv_csc_trans_to_register(&coef);
+
+    vo_drv_clip_layer_csc_coef(&coef);
+    hal_layer_set_csc_coef(layer, &coef);
+}
+
+gk_void vou_drv_get_layer_csc_param(gk_vo_layer layer, csc_coef_param *csc_param)
+{
+    vo_drv_layer *drv_layer_ctx  = vo_drv_get_layer_ctx(layer);
+    memcpy(csc_param, &drv_layer_ctx->csc_param, sizeof(csc_coef_param));
+}
+#endif
+
+#if VO_DESC("layer cfg")
+
+gk_vo_layer vo_drv_get_hw_layer(gk_vo_layer layer)
+{
+    return layer;
+}
+
+gk_void vou_drv_layer_enable(gk_vo_layer layer, gk_bool enable)
+{
+    gk_vo_layer hw_layer = vo_drv_get_hw_layer(layer);
+
+    hal_video_hfir_set_ck_gt_en(hw_layer, enable);
+    hal_layer_enable_layer(hw_layer, enable);
+}
+
+gk_void vou_drv_set_layer_reg_up(gk_vo_layer layer)
+{
+    gk_vo_layer hw_layer = vo_drv_get_hw_layer(layer);
+    hal_layer_set_reg_up(hw_layer);
+}
+
+gk_void vou_drv_set_layer_data_fmt(gk_vo_layer layer, vou_layer_pixerl_format data_fmt)
+{
+    gk_vo_layer hw_layer = vo_drv_get_hw_layer(layer);
+    hal_disp_layer hal_layer;
+    hal_disp_pixel_format disp_data_fmt;
+
+    hal_layer = vou_drv_convert_layer(hw_layer);
+    disp_data_fmt = vou_drv_convert_data_format(data_fmt);
+    hal_layer_set_layer_data_fmt(hal_layer, disp_data_fmt);
+}
+#endif
+#endif /* #if VO_DESC("UBOOT_VO") */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/src/drv_vo_video_comm.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/drv_vo_video_comm.c
--- u-boot-2016.11/product/osd/vo/arch/comm/src/drv_vo_video_comm.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/drv_vo_video_comm.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,148 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "drv_vo_video_comm.h"
+#include "drv_vo.h"
+#include "hal_vo.h"
+#include "drv_vo_coef_org_comm.h"
+#include "vo.h"
+#include <common.h>
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#if VO_DESC("UBOOT_VO")
+#if VO_DESC("video")
+gk_void vou_drv_init_default_csc(gk_vo_layer layer)
+{
+    gk_vo_csc *csc = GK_NULL;
+    vo_drv_layer *drv_layer_ctx = GK_NULL;
+
+    drv_layer_ctx = vo_drv_get_layer_ctx(layer);
+    csc = &drv_layer_ctx->csc;
+    csc->csc_matrix = GK_VO_CSC_MATRIX_BT601FULL_TO_BT601FULL;
+    csc->luma = VO_CSC_DEF_VAL;
+    csc->contrast = VO_CSC_DEF_VAL;
+    csc->hue = VO_CSC_DEF_VAL;
+    csc->saturation = VO_CSC_DEF_VAL;
+    csc->ex_csc_en = GK_FALSE;
+}
+
+gk_void vou_drv_init_default_csc_param(gk_vo_layer layer)
+{
+    csc_coef_param *csc_param = GK_NULL;
+    vo_drv_layer *drv_layer_ctx = GK_NULL;
+
+    drv_layer_ctx = vo_drv_get_layer_ctx(layer);
+
+    csc_param = &drv_layer_ctx->csc_param;
+    csc_param->csc_scale2p = VO_LAYER_CSC_SCALE2P_DEF_VAL;
+    csc_param->csc_clip_min = VO_LAYER_CSC_CLIP_MIN;
+    csc_param->csc_clip_max = VO_LAYER_CSC_CLIP_MAX;
+}
+
+gk_void vo_drv_set_layer_attr(gk_vo_layer layer, const gk_vo_video_layer_attr *vo_layer_attr)
+{
+    vo_drv_layer *drv_layer_ctx = GK_NULL;
+
+    drv_layer_ctx = vo_drv_get_layer_ctx(layer);
+    memcpy(&drv_layer_ctx->vo_video_attr, vo_layer_attr,
+        sizeof(gk_vo_video_layer_attr));
+    drv_layer_ctx->video_config = GK_TRUE;
+}
+
+gk_void vou_drv_get_default_csc(gk_vo_layer layer, gk_vo_csc *csc)
+{
+    vo_drv_layer *drv_layer_ctx = vo_drv_get_layer_ctx(layer);
+    csc->csc_matrix = drv_layer_ctx->csc.csc_matrix;
+    csc->luma = drv_layer_ctx->csc.luma;
+    csc->contrast = drv_layer_ctx->csc.contrast;
+    csc->hue = drv_layer_ctx->csc.hue;
+    csc->saturation = drv_layer_ctx->csc.saturation;
+    csc->ex_csc_en = drv_layer_ctx->csc.ex_csc_en;
+}
+
+gk_void vo_drv_disable_layer(gk_vo_layer layer)
+{
+    vo_drv_layer *drv_layer_ctx = vo_drv_get_layer_ctx(layer);
+
+    drv_layer_ctx->video_enable = GK_FALSE;
+}
+
+gk_s32 vou_drv_get_video_layer_bind_dev(gk_vo_layer layer)
+{
+    vo_drv_layer *layer_ctx = GK_NULL;
+    layer_ctx = vo_drv_get_layer_ctx(layer);
+    return layer_ctx->bind_dev;
+}
+
+#endif /* #if VO_DESC("UBOOT_VO") */
+
+#if VO_DESC("video open close")
+static gk_void video_layer_set_zme_cfg(unsigned int layer, gk_rect *disp_rect)
+{
+    vdp_vid_ip_cfg vid_cfg = {0};
+
+    vid_cfg.csc_en = 0;
+    vid_cfg.hfir_en = 1;
+    vid_cfg.vid_iw = disp_rect->width;
+    vid_cfg.vid_ih = disp_rect->height;
+
+    vid_cfg.vid_ow = disp_rect->width;
+    vid_cfg.vid_oh = disp_rect->height;
+    vid_cfg.zme_en = GK_FALSE;
+    vo_drv_video_set_zme_enable(layer, &vid_cfg);
+}
+
+gk_void vo_drv_layer_open(gk_vo_layer layer_id, const gk_vo_video_layer_attr *video_attr)
+{
+    hal_disp_layer layer;
+    gk_rect disp_rect = {0};
+    gk_ulong addr;
+    gk_u32 strd;
+
+    disp_rect = video_attr->display_rect;
+    addr = video_attr->address;
+    strd = video_attr->stride;
+
+    layer = vou_drv_convert_layer(layer_id);
+
+    hal_layer_set_layer_data_fmt(layer, HAL_INPUTFMT_YCBCR_SEMIPLANAR_420);
+    hal_video_set_layer_disp_rect(layer, &disp_rect);
+    hal_video_set_layer_video_rect(layer, &disp_rect);
+    hal_layer_set_layer_in_rect(layer, &disp_rect);
+    hal_layer_set_layer_global_alpha(layer, VO_ALPHA_OPACITY);
+    hal_layer_set_src_resolution(layer, &disp_rect);
+
+    video_layer_set_zme_cfg(layer, &disp_rect);
+
+    hal_layer_set_zme_info(layer, disp_rect.width, disp_rect.height, HAL_DISP_ZME_OUTFMT422);
+
+    hal_video_set_multi_area_lum_addr(layer, 0, addr, strd);
+    hal_video_set_multi_area_chm_addr(layer, 0, addr + strd * VOU_ALIGN(disp_rect.height, VO_STRIDE_ALIGN), strd);
+    hal_layer_enable_layer(layer, GK_TRUE);
+    hal_layer_set_reg_up(layer);
+    return;
+}
+
+gk_void vo_drv_layer_close(gk_vo_layer layer_id)
+{
+    hal_disp_layer layer;
+
+    layer = vou_drv_convert_layer(layer_id);
+
+    hal_layer_enable_layer(layer, GK_FALSE);
+    hal_layer_set_reg_up(layer);
+}
+#endif
+#endif /* #if VO_DESC("UBOOT_VO") */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/src/hal_vo_comm.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/hal_vo_comm.c
--- u-boot-2016.11/product/osd/vo/arch/comm/src/hal_vo_comm.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/hal_vo_comm.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#include "hal_vo_comm.h"
+#include "drv_vo.h"
+#include "hal_vo.h"
+#include "board.h"
+#include <common.h>
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#if VO_DESC("UBOOT_VO")
+#if VO_DESC("hal pub")
+
+gk_void hal_vou_init(gk_void)
+{
+    volatile reg_vdp_regs *reg = vo_hal_get_reg();
+    if (reg == GK_NULL) {
+        reg = (volatile reg_vdp_regs *)IO_ADDRESS(VOU_REGS_ADDR);
+        vo_hal_set_reg(reg);
+    }
+
+    if (reg == GK_NULL) {
+        GK_PRINT("ioremap failed\n");
+    }
+}
+
+gk_void hal_write_reg(gk_u32 *address, gk_u32 value)
+{
+    *(volatile gk_u32 *)address = value;
+}
+
+gk_u32 hal_read_reg(const gk_u32 *address)
+{
+    return *(volatile gk_u32 *)(address);
+}
+
+#endif
+#if VO_DESC("hal check")
+
+gk_bool vo_hal_is_phy_dev(gk_vo_dev dev)
+{
+    if ((dev >= DEV_PHY_START) && (dev <= DEV_PHY_END)) {
+        return GK_TRUE;
+    }
+
+    return GK_FALSE;
+}
+
+gk_bool vo_hal_is_video_layer(hal_disp_layer layer)
+{
+    if ((layer >= LAYER_VID_START) && (layer <= LAYER_VID_END)) {
+        return GK_TRUE;
+    }
+
+    return GK_FALSE;
+}
+
+gk_bool vo_hal_is_gfx_layer(hal_disp_layer layer)
+{
+    if ((layer >= LAYER_GFX_START) && (layer <= LAYER_GFX_END)) {
+        return GK_TRUE;
+    }
+
+    return GK_FALSE;
+}
+
+#endif
+
+#ifdef VO_HAL_CHECK_DEBUG
+
+gk_bool vo_hal_is_video_gfx_layer(hal_disp_layer layer)
+{
+    if (vo_hal_is_video_layer(layer) || vo_hal_is_gfx_layer(layer)) {
+        return GK_TRUE;
+    }
+
+    return GK_FALSE;
+}
+
+#endif
+
+#endif /* #if VO_DESC("UBOOT_VO") */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/src/hal_vo_comm.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/hal_vo_comm.h
--- u-boot-2016.11/product/osd/vo/arch/comm/src/hal_vo_comm.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/hal_vo_comm.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __HAL_VO_COMM_H__
+#define __HAL_VO_COMM_H__
+
+#include "hal_vo_def.h"
+#include "inner_vo.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#if VO_DESC("UBOOT_VO")
+
+#define IO_ADDRESS(x) (x)
+
+#ifdef GK_DEBUG
+#define VO_HAL_CHECK_DEBUG /* vo hal check debug, debug only */
+#endif
+/* 4bytes */
+#define REG_BYTES 4
+
+#if VO_DESC("hal pub")
+gk_void hal_vou_init(gk_void);
+gk_void hal_write_reg(gk_u32 *address, gk_u32 value);
+gk_u32 hal_read_reg(const gk_u32 *address);
+#endif
+
+#if VO_DESC("hal check")
+gk_bool vo_hal_is_phy_dev(gk_vo_dev dev);
+gk_bool vo_hal_is_video_layer(hal_disp_layer layer);
+gk_bool vo_hal_is_gfx_layer(hal_disp_layer layer);
+gk_bool vo_hal_is_video_gfx_layer(hal_disp_layer layer);
+#endif
+
+#ifdef VO_HAL_CHECK_DEBUG
+
+#define vo_hal_check_phy_dev_return(dev)         \
+    do {                                                    \
+        if (vo_hal_is_phy_dev(dev) != GK_TRUE) {   \
+            GK_PRINT("err dev in %s: L%d\n", __FUNCTION__, __LINE__); \
+            return;          \
+        }                     \
+    } while (0)
+
+#define vo_hal_check_video_layer_return(layer)         \
+    do {                                                    \
+        if (vo_hal_is_video_layer(layer) != GK_TRUE) {   \
+            GK_PRINT("err layer in %s: L%d\n", __FUNCTION__, __LINE__); \
+            return;          \
+        }                     \
+    } while (0)
+
+#define vo_hal_check_gfx_layer_return(layer)         \
+    do {                                                    \
+        if (vo_hal_is_gfx_layer(layer) != GK_TRUE) {   \
+            GK_PRINT("err layer in %s: L%d\n", __FUNCTION__, __LINE__); \
+            return;          \
+        }                     \
+    } while (0)
+
+#define vo_hal_check_video_gfx_layer_return(layer)         \
+    do {                                                    \
+        if (vo_hal_is_video_gfx_layer(layer) != GK_TRUE) {   \
+            GK_PRINT("err layer in %s: L%d\n", __FUNCTION__, __LINE__); \
+            return;          \
+        }                     \
+    } while (0)
+
+#else
+
+#define vo_hal_check_phy_dev_return(dev)
+#define vo_hal_check_video_layer_return(layer)
+#define vo_hal_check_gfx_layer_return(layer)
+#define vo_hal_check_video_gfx_layer_return(layer)
+
+#endif
+#endif /* #if VO_DESC("UBOOT_VO") */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* end of __HAL_VO_COMM_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/src/hal_vo_def_comm.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/hal_vo_def_comm.h
--- u-boot-2016.11/product/osd/vo/arch/comm/src/hal_vo_def_comm.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/hal_vo_def_comm.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,198 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __HAL_VO_COMM_DEF_H__
+#define __HAL_VO_COMM_DEF_H__
+
+#include "type.h"
+#include "defines.h"
+#include "inner_vo.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#if VO_DESC("UBOOT_VO")
+
+typedef enum {
+    HAL_INPUTFMT_YCBCR_SEMIPLANAR_400 = 0x1,
+    HAL_INPUTFMT_YCBCR_SEMIPLANAR_420 = 0x2,
+    HAL_INPUTFMT_YCBCR_SEMIPLANAR_422 = 0x3,
+    HAL_INPUTFMT_YCBCR_SEMIPLANAR_444 = 0x4,
+    HAL_INPUTFMT_YCBCR_SEMIPLANAR_411_4X1 = 0x6,
+    HAL_INPUTFMT_YCBCR_SEMIPLANAR_422_2X1 = 0x7,
+
+    HAL_INPUTFMT_CBYCRY_PACKAGE_422 = 0x9,
+    HAL_INPUTFMT_YCBYCR_PACKAGE_422 = 0xa,
+    HAL_INPUTFMT_YCRYCB_PACKAGE_422 = 0xb,
+    HAL_INPUTFMT_YCBCR_PACKAGE_444 = 0x1000,
+
+    HAL_INPUTFMT_CLUT_1BPP = 0x00,
+    HAL_INPUTFMT_CLUT_2BPP = 0x10,
+    HAL_INPUTFMT_CLUT_4BPP = 0x20,
+    HAL_INPUTFMT_CLUT_8BPP = 0x30,
+    HAL_INPUTFMT_ACLUT_44 = 0x38,
+
+    HAL_INPUTFMT_RGB_444 = 0x40,
+    HAL_INPUTFMT_RGB_555 = 0x41,
+    HAL_INPUTFMT_RGB_565 = 0x42,
+    HAL_INPUTFMT_CBYCRY_PACKAGE_422_GRC = 0x43,
+    HAL_INPUTFMT_YCBYCR_PACKAGE_422_GRC = 0x44,
+    HAL_INPUTFMT_YCRYCB_PACKAGE_422_GRC = 0x45,
+    HAL_INPUTFMT_ACLUT_88 = 0x46,
+    HAL_INPUTFMT_ARGB_4444 = 0x48,
+    HAL_INPUTFMT_ARGB_1555 = 0x49,
+
+    HAL_INPUTFMT_RGB_888 = 0x50,
+    HAL_INPUTFMT_YCBCR_888 = 0x51,
+    HAL_INPUTFMT_ARGB_8565 = 0x5a,
+    HAL_INPUTFMT_ARGB_6666 = 0x5b,
+
+    HAL_INPUTFMT_KRGB_888 = 0x60,
+    HAL_INPUTFMT_ARGB_8888 = 0x68,
+    HAL_INPUTFMT_AYCBCR_8888 = 0x69,
+
+    HAL_INPUTFMT_RGBA_4444 = 0xc8,
+    HAL_INPUTFMT_RGBA_5551 = 0xc9,
+
+    HAL_INPUTFMT_RGBA_6666 = 0xd8,
+    HAL_INPUTFMT_RGBA_5658 = 0xda,
+
+    HAL_INPUTFMT_RGBA_8888 = 0xe8,
+    HAL_INPUTFMT_YCBCRA_8888 = 0xe9,
+
+    HAL_DISP_PIXELFORMAT_BUTT
+} hal_disp_pixel_format;
+
+typedef enum {
+    HAL_DISP_ZME_OUTFMT420 = 0,
+    HAL_DISP_ZME_OUTFMT422,
+    HAL_DISP_ZME_OUTFMT444,
+    HAL_DISP_ZME_OUTFMT_BUTT
+} hal_disp_zme_outfmt;
+
+/* vou CBM MIXER */
+typedef enum {
+    HAL_CBMMIX1 = 0,
+    HAL_CBMMIX2 = 1,
+    HAL_CBMMIX3 = 2,
+
+    HAL_CBMMIX1_BUTT
+} hal_cbmmix;
+
+typedef enum {
+    HAL_HFIRMODE_MEDEN = 0,  /* median filtering enable */
+    HAL_HFIRMODE_COPY,  /* chroma HFIR copy */
+    HAL_HFIRMODE_DOUBLE,  /* bilinear interpolation */
+    HAL_HFIRMODE_6TAPFIR,  /* 6 order FIR */
+
+    HAL_HFIRMODE_BUTT
+} hal_hfirmode;
+
+typedef struct {
+    gk_u32 syncm;
+    gk_u32 iop;
+    gk_u8 intfb;
+
+    gk_u16 vact;
+    gk_u16 vbb;
+    gk_u16 vfb;
+
+    gk_u16 hact;
+    gk_u16 hbb;
+    gk_u16 hfb;
+    gk_u16 hmid;
+
+    gk_u16 bvact;
+    gk_u16 bvbb;
+    gk_u16 bvfb;
+
+    gk_u16 hpw;
+    gk_u16 vpw;
+
+    gk_u32 idv;
+    gk_u32 ihs;
+    gk_u32 ivs;
+} hal_disp_syncinfo;
+
+typedef struct {
+    gk_u32 f_inv;
+    gk_u32 vs_inv;
+    gk_u32 hs_inv;
+    gk_u32 dv_inv;
+} hal_disp_syncinv;
+
+typedef enum {
+    HAL_MULTICHN_EN_1P1C = 0x1,  /* 1 pixel / 1 cycle */
+    HAL_MULTICHN_EN_2P1C = 0x2,  /* 2 pixel / 1 cycle */
+} hal_multichn_en;
+
+typedef struct {
+    gk_u16 bkg_a;
+    gk_u16 bkg_y;
+    gk_u16 bkg_cb;
+    gk_u16 bkg_cr;
+} hal_disp_bkcolor;
+
+typedef struct {
+    gk_u16 clip_low_y;
+    gk_u16 clip_low_cb;
+    gk_u16 clip_low_cr;
+
+    gk_u16 clip_high_y;
+    gk_u16 clip_high_cb;
+    gk_u16 clip_high_cr;
+} hal_disp_clip;
+
+typedef enum {
+    VDP_LAYER_VID0 = 0,
+    VDP_LAYER_VID1 = 1,
+    VDP_LAYER_VID2 = 2,
+    VDP_LAYER_VID3 = 3,
+    VDP_LAYER_VID4 = 4,
+    VDP_LAYER_VID5 = 5,
+    VDP_LAYER_VID6 = 6,  /* for FI pixel */
+    VDP_LAYER_VID7 = 7,  /* for FI info */
+
+    VDP_LAYER_VID_BUTT
+} vdp_layer_vid;
+
+typedef enum {
+    VDP_RMODE_INTERFACE = 0,
+    VDP_RMODE_INTERLACE = 0,
+    VDP_RMODE_PROGRESSIVE = 1,
+    VDP_RMODE_TOP = 2,
+    VDP_RMODE_BOTTOM = 3,
+    VDP_RMODE_PRO_TOP = 4,
+    VDP_RMODE_PRO_BOTTOM = 5,
+    VDP_RMODE_BUTT
+} vdp_data_rmode;
+
+typedef enum {
+    VDP_PROC_FMT_SP_420 = 0x0,
+    VDP_PROC_FMT_SP_422 = 0x1,
+    VDP_PROC_FMT_SP_444 = 0x2,  /* plannar,in YUV color domain */
+    VDP_PROC_FMT_RGB_888 = 0x3,  /* package,in RGB color domain */
+    VDP_PROC_FMT_RGB_444 = 0x4,  /* plannar,in RGB color domain */
+
+    VDP_PROC_FMT_BUTT
+} vdp_proc_fmt;
+
+typedef struct {
+    gk_s32 luma;
+    gk_s32 cont;
+    gk_s32 hue;
+    gk_s32 satu;
+} hal_csc_value;
+#endif /* #if VO_DESC("UBOOT_VO") */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+#endif /* end of __HAL_VO_COMM_DEF_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/src/hal_vo_dev_comm.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/hal_vo_dev_comm.c
--- u-boot-2016.11/product/osd/vo/arch/comm/src/hal_vo_dev_comm.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/hal_vo_dev_comm.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,883 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#include "hal_vo_dev_comm.h"
+#include "drv_vo.h"
+#include "hal_vo.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+#if VO_DESC("UBOOT_VO")
+
+#if VO_DESC("dev&intf")
+
+gk_void hal_sys_set_rd_bus_id(gk_u32 mode)
+{
+    return;
+}
+
+gk_void hal_disp_set_intf_enable(gk_vo_dev dev, gk_bool intf)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_dhd0_ctrl dhd0_ctrl;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_phy_dev_return(dev);
+
+    addr_reg = vou_get_chn_abs_addr(dev, (gk_uintptr_t) & (vo_reg->dhd0_ctrl.u32));
+    dhd0_ctrl.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    dhd0_ctrl.bits.intf_en = intf;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, dhd0_ctrl.u32);
+}
+
+gk_void hal_disp_get_intf_enable(gk_vo_dev dev, gk_bool *intf_en)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_dhd0_ctrl dhd0_ctrl;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_phy_dev_return(dev);
+
+    addr_reg = vou_get_chn_abs_addr(dev, (gk_uintptr_t) & (vo_reg->dhd0_ctrl.u32));
+    dhd0_ctrl.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    *intf_en = dhd0_ctrl.bits.intf_en;
+}
+
+gk_void hal_disp_set_hdmi_mode(gk_vo_dev dev, gk_u32 color_space)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_dhd0_ctrl dhd0_ctrl;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_phy_dev_return(dev);
+
+    addr_reg = vou_get_chn_abs_addr(dev, (gk_uintptr_t) & (vo_reg->dhd0_ctrl.u32));
+    dhd0_ctrl.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    dhd0_ctrl.bits.hdmi_mode = color_space;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, dhd0_ctrl.u32);
+}
+
+gk_void hal_disp_set_dev_multi_chn_en(gk_vo_dev dev, hal_multichn_en multi_chn_en)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_dhd0_pwr dhd0_pwr;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_phy_dev_return(dev);
+
+    addr_reg = vou_get_chn_abs_addr(dev, (gk_uintptr_t) & (vo_reg->dhd0_pwr.u32));
+    dhd0_pwr.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    dhd0_pwr.bits.multichn_en = multi_chn_en;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, dhd0_pwr.u32);
+}
+
+gk_void hal_disp_set_vtthd_mode(gk_vo_dev dev, gk_u32 field_mode)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_dhd0_vtthd dhd0_vtthd;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_phy_dev_return(dev);
+
+    addr_reg = vou_get_chn_abs_addr(dev, (gk_uintptr_t) & (vo_reg->dhd0_vtthd.u32));
+    dhd0_vtthd.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    dhd0_vtthd.bits.thd1_mode = field_mode;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, dhd0_vtthd.u32);
+}
+
+gk_void hal_disp_set_vtthd(gk_vo_dev dev, gk_u32 vtthd, gk_u32 vtthd2)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_dhd0_vtthd dhd0_vtthd;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_phy_dev_return(dev);
+
+    /* for vtmgthd1 and vtmgthd2 */
+    addr_reg = vou_get_chn_abs_addr(dev, (gk_uintptr_t) & (vo_reg->dhd0_vtthd.u32));
+    dhd0_vtthd.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    dhd0_vtthd.bits.vtmgthd1 = vtthd;
+    dhd0_vtthd.bits.vtmgthd2 = vtthd2;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, dhd0_vtthd.u32);
+}
+
+gk_void hal_disp_clear_int_status(gk_u32 int_msk)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+
+    /* read interrupt status */
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) & (vo_reg->vomskintsta.u32), int_msk);
+}
+
+gk_void hal_intf_bt_set_dfir_en(gk_u32 dfir_en)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    reg_intf_bt_ctrl intf_bt_ctrl;
+
+    intf_bt_ctrl.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) & (vo_reg->intf_bt_ctrl.u32));
+    intf_bt_ctrl.bits.dfir_en = dfir_en;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) & (vo_reg->intf_bt_ctrl.u32), intf_bt_ctrl.u32);
+}
+
+gk_void hal_intf_bt_set_data_width(gk_u32 data_width)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    reg_intf_bt_ctrl intf_bt_ctrl;
+
+    intf_bt_ctrl.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) & (vo_reg->intf_bt_ctrl.u32));
+    intf_bt_ctrl.bits.data_width = data_width;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) & (vo_reg->intf_bt_ctrl.u32), intf_bt_ctrl.u32);
+}
+
+gk_void hal_disp_set_reg_up(gk_vo_dev dev)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_dhd0_ctrl dhd0_ctrl;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_phy_dev_return(dev);
+
+    addr_reg = vou_get_chn_abs_addr(dev, (gk_uintptr_t) & (vo_reg->dhd0_ctrl.u32));
+    dhd0_ctrl.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    dhd0_ctrl.bits.regup = 0x1;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, dhd0_ctrl.u32);
+}
+
+gk_u32 hal_disp_get_reg_up(gk_vo_dev dev)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    gk_u32 data;
+    volatile reg_dhd0_ctrl dhd0_ctrl;
+    volatile gk_ulong addr_reg;
+
+    if (vo_hal_is_phy_dev(dev) != GK_TRUE) {
+        return 0;
+    }
+
+    addr_reg = vou_get_chn_abs_addr(dev, (gk_uintptr_t) & (vo_reg->dhd0_ctrl.u32));
+    dhd0_ctrl.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    data = dhd0_ctrl.bits.regup;
+    return data & 0x1;
+}
+
+#endif
+
+#if VO_DESC("dev intf")
+
+static gk_bool vo_hal_is_valid_sd_dev(gk_vo_dev dev)
+{
+    if (dev == VO_DEV_DSD0) {
+        return GK_TRUE;
+    }
+
+    return GK_FALSE;
+}
+
+static gk_void vo_hal_intf_set_mux_sel_sd(gk_vo_dev dev, gk_vo_intf_type intf)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_vo_mux vo_mux;
+
+    vo_mux.u32 = vo_reg->vo_mux.u32;
+    if (intf == GK_VO_INTF_CVBS) {
+        vo_mux.bits.sddate_sel = 2;   /* 2: DSD SDATE */
+    }
+    vo_reg->vo_mux.u32 = vo_mux.u32;
+}
+
+gk_void vo_hal_intf_set_mux_sel(gk_vo_dev dev, gk_vo_intf_type intf)
+{
+    vo_hal_check_phy_dev_return(dev);
+
+    if (vo_hal_is_valid_sd_dev(dev)) {
+        vo_hal_intf_set_mux_sel_sd(dev, intf);
+        return;
+    }
+
+    vo_hal_intf_set_mux_sel_hd(dev, intf);
+}
+
+gk_void vo_hal_intf_set_bt_sync_inv(hal_disp_syncinv *inv)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_intf_bt_sync_inv intf_bt_sync_inv;
+
+    intf_bt_sync_inv.u32 = vo_reg->intf_bt_sync_inv.u32;
+    intf_bt_sync_inv.bits.dv_inv = inv->dv_inv;
+    intf_bt_sync_inv.bits.hs_inv = inv->hs_inv;
+    intf_bt_sync_inv.bits.vs_inv = inv->vs_inv;
+    intf_bt_sync_inv.bits.f_inv = inv->f_inv;
+    vo_reg->intf_bt_sync_inv.u32 = intf_bt_sync_inv.u32;
+}
+
+gk_void vo_hal_intf_set_cvbs_sync_inv(hal_disp_syncinv *inv)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_intf_date_sync_inv intf_date_sync_inv;
+
+    intf_date_sync_inv.u32 = vo_reg->intf_date_sync_inv.u32;
+    intf_date_sync_inv.bits.dv_inv = inv->dv_inv;
+    intf_date_sync_inv.bits.hs_inv = inv->hs_inv;
+    intf_date_sync_inv.bits.vs_inv = inv->vs_inv;
+    intf_date_sync_inv.bits.f_inv = inv->f_inv;
+    vo_reg->intf_date_sync_inv.u32 = intf_date_sync_inv.u32;
+}
+
+gk_void vo_hal_intf_set_vga_sync_inv(hal_disp_syncinv *inv)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_intf_vga_sync_inv intf_vga_sync_inv;
+
+    intf_vga_sync_inv.u32 = vo_reg->intf_vga_sync_inv.u32;
+    intf_vga_sync_inv.bits.dv_inv = inv->dv_inv;
+    intf_vga_sync_inv.bits.hs_inv = inv->hs_inv;
+    intf_vga_sync_inv.bits.vs_inv = inv->vs_inv;
+    intf_vga_sync_inv.bits.f_inv = inv->f_inv;
+    vo_reg->intf_vga_sync_inv.u32 = intf_vga_sync_inv.u32;
+}
+
+gk_void vo_hal_intf_set_hdmi_sync_inv(hal_disp_syncinv *inv)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_intf_hdmi_sync_inv intf_hdmi_sync_inv;
+
+    intf_hdmi_sync_inv.u32 = vo_reg->intf_hdmi_sync_inv.u32;
+    intf_hdmi_sync_inv.bits.dv_inv = inv->dv_inv;
+    intf_hdmi_sync_inv.bits.hs_inv = inv->hs_inv;
+    intf_hdmi_sync_inv.bits.vs_inv = inv->vs_inv;
+    intf_hdmi_sync_inv.bits.f_inv = inv->f_inv;
+    vo_reg->intf_hdmi_sync_inv.u32 = intf_hdmi_sync_inv.u32;
+}
+
+gk_void vo_hal_intf_set_hdmi_csc_dc_coef(vdp_csc_dc_coef *csc_dc_coef)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_hdmi_csc_idc hdmi_csc_idc;
+    volatile reg_hdmi_csc_odc hdmi_csc_odc;
+    volatile reg_hdmi_csc_iodc hdmi_csc_iodc;
+
+    hdmi_csc_idc.u32 = vo_reg->hdmi_csc_idc.u32;
+    hdmi_csc_odc.u32 = vo_reg->hdmi_csc_odc.u32;
+    hdmi_csc_iodc.u32 = vo_reg->hdmi_csc_iodc.u32;
+
+    hdmi_csc_idc.bits.cscidc0 = csc_dc_coef->csc_in_dc2;
+    hdmi_csc_idc.bits.cscidc1 = csc_dc_coef->csc_in_dc1;
+    hdmi_csc_iodc.bits.cscidc2 = csc_dc_coef->csc_in_dc0;
+
+    hdmi_csc_odc.bits.cscodc0 = csc_dc_coef->csc_out_dc2;
+
+    hdmi_csc_odc.bits.cscodc1 = csc_dc_coef->csc_out_dc1;
+    hdmi_csc_iodc.bits.cscodc2 = csc_dc_coef->csc_out_dc0;
+
+    vo_reg->hdmi_csc_idc.u32 = hdmi_csc_idc.u32;
+    vo_reg->hdmi_csc_odc.u32 = hdmi_csc_odc.u32;
+    vo_reg->hdmi_csc_iodc.u32 = hdmi_csc_iodc.u32;
+}
+
+gk_void vo_hal_intf_set_vga_csc_dc_coef(vdp_csc_dc_coef *csc_dc_coef)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_vga_csc_idc vga_csc_idc;
+    volatile reg_vga_csc_odc vga_csc_odc;
+    volatile reg_vga_csc_iodc vga_csc_iodc;
+
+    vga_csc_idc.u32 = vo_reg->vga_csc_idc.u32;
+    vga_csc_odc.u32 = vo_reg->vga_csc_odc.u32;
+    vga_csc_iodc.u32 = vo_reg->vga_csc_iodc.u32;
+
+    vga_csc_idc.bits.cscidc0 = csc_dc_coef->csc_in_dc2;
+    vga_csc_idc.bits.cscidc1 = csc_dc_coef->csc_in_dc1;
+    vga_csc_iodc.bits.cscidc2 = csc_dc_coef->csc_in_dc0;
+    vga_csc_odc.bits.cscodc0 = csc_dc_coef->csc_out_dc2;
+    vga_csc_odc.bits.cscodc1 = csc_dc_coef->csc_out_dc1;
+    vga_csc_iodc.bits.cscodc2 = csc_dc_coef->csc_out_dc0;
+
+    vo_reg->vga_csc_idc.u32 = vga_csc_idc.u32;
+    vo_reg->vga_csc_odc.u32 = vga_csc_odc.u32;
+    vo_reg->vga_csc_iodc.u32 = vga_csc_iodc.u32;
+}
+
+gk_void vo_hal_intf_set_hdmi_csc_coef(vdp_csc_coef *csc_coef)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_hdmi_csc_p0 hdmi_csc_p0;
+    volatile reg_hdmi_csc_p1 hdmi_csc_p1;
+    volatile reg_hdmi_csc_p2 hdmi_csc_p2;
+    volatile reg_hdmi_csc_p3 hdmi_csc_p3;
+    volatile reg_hdmi_csc_p4 hdmi_csc_p4;
+
+    hdmi_csc_p0.u32 = vo_reg->hdmi_csc_p0.u32;
+    hdmi_csc_p1.u32 = vo_reg->hdmi_csc_p1.u32;
+    hdmi_csc_p2.u32 = vo_reg->hdmi_csc_p2.u32;
+    hdmi_csc_p3.u32 = vo_reg->hdmi_csc_p3.u32;
+    hdmi_csc_p4.u32 = vo_reg->hdmi_csc_p4.u32;
+
+    hdmi_csc_p0.bits.cscp00 = csc_coef->csc_coef00;
+    hdmi_csc_p0.bits.cscp01 = csc_coef->csc_coef01;
+    hdmi_csc_p1.bits.cscp02 = csc_coef->csc_coef02;
+    hdmi_csc_p1.bits.cscp10 = csc_coef->csc_coef10;
+    hdmi_csc_p2.bits.cscp11 = csc_coef->csc_coef11;
+    hdmi_csc_p2.bits.cscp12 = csc_coef->csc_coef12;
+    hdmi_csc_p3.bits.cscp20 = csc_coef->csc_coef20;
+    hdmi_csc_p3.bits.cscp21 = csc_coef->csc_coef21;
+    hdmi_csc_p4.bits.cscp22 = csc_coef->csc_coef22;
+
+    vo_reg->hdmi_csc_p0.u32 = hdmi_csc_p0.u32;
+    vo_reg->hdmi_csc_p1.u32 = hdmi_csc_p1.u32;
+    vo_reg->hdmi_csc_p2.u32 = hdmi_csc_p2.u32;
+    vo_reg->hdmi_csc_p3.u32 = hdmi_csc_p3.u32;
+    vo_reg->hdmi_csc_p4.u32 = hdmi_csc_p4.u32;
+}
+
+gk_void vo_hal_intf_set_vga_csc_coef(vdp_csc_coef *csc_coef)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_vga_csc_p0 vga_csc_p0;
+    volatile reg_vga_csc_p1 vga_csc_p1;
+    volatile reg_vga_csc_p2 vga_csc_p2;
+    volatile reg_vga_csc_p3 vga_csc_p3;
+    volatile reg_vga_csc_p4 vga_csc_p4;
+
+    vga_csc_p0.u32 = vo_reg->vga_csc_p0.u32;
+    vga_csc_p1.u32 = vo_reg->vga_csc_p1.u32;
+    vga_csc_p2.u32 = vo_reg->vga_csc_p2.u32;
+    vga_csc_p3.u32 = vo_reg->vga_csc_p3.u32;
+    vga_csc_p4.u32 = vo_reg->vga_csc_p4.u32;
+
+    vga_csc_p0.bits.cscp00 = csc_coef->csc_coef00;
+    vga_csc_p0.bits.cscp01 = csc_coef->csc_coef01;
+    vga_csc_p1.bits.cscp02 = csc_coef->csc_coef02;
+    vga_csc_p1.bits.cscp10 = csc_coef->csc_coef10;
+    vga_csc_p2.bits.cscp11 = csc_coef->csc_coef11;
+    vga_csc_p2.bits.cscp12 = csc_coef->csc_coef12;
+    vga_csc_p3.bits.cscp20 = csc_coef->csc_coef20;
+    vga_csc_p3.bits.cscp21 = csc_coef->csc_coef21;
+    vga_csc_p4.bits.cscp22 = csc_coef->csc_coef22;
+
+    vo_reg->vga_csc_p0.u32 = vga_csc_p0.u32;
+    vo_reg->vga_csc_p1.u32 = vga_csc_p1.u32;
+    vo_reg->vga_csc_p2.u32 = vga_csc_p2.u32;
+    vo_reg->vga_csc_p3.u32 = vga_csc_p3.u32;
+    vo_reg->vga_csc_p4.u32 = vga_csc_p4.u32;
+}
+
+gk_void vo_hal_intf_set_csc_cfg(gk_vo_intf_type intf, csc_coef *coef)
+{
+    vo_hal_intf_set_csc_dc_coef(intf, (vdp_csc_dc_coef *)(&coef->csc_in_dc0));
+    vo_hal_intf_set_csc_coef(intf, (vdp_csc_coef *)(&coef->csc_coef00));
+}
+
+gk_void vo_hal_intf_set_dac_sel(gk_vo_intf_type intf_type)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_vomux_dac vomux_dac;
+
+    vomux_dac.u32 = vo_reg->vomux_dac.u32;
+    if (intf_type == GK_VO_INTF_VGA) {
+        vomux_dac.bits.dac2_sel = 9;   /* 9: DAC2 VGA B */
+        vomux_dac.bits.dac1_sel = 8;   /* 8: DAC2 VGA G */
+        vomux_dac.bits.dac0_sel = 7;   /* 7: DAC2 VGA R */
+    } else if (intf_type == GK_VO_INTF_CVBS) {
+        vomux_dac.bits.dac3_sel = 0;
+    }
+    vo_reg->vomux_dac.u32 = vomux_dac.u32;
+}
+
+gk_void vo_hal_intf_set_vga_and_cvbs_dac_enable(gk_bool enable)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_vo_dac_ctrl vo_dac_ctrl;
+
+    vo_dac_ctrl.u32 = vo_reg->vo_dac_ctrl.u32;
+    vo_dac_ctrl.bits.envbg = enable;
+    vo_reg->vo_dac_ctrl.u32 = vo_dac_ctrl.u32;
+}
+
+gk_void vo_hal_intf_set_cvbs_dac_cfg(gk_void)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_vo_dac_ctrl vo_dac_ctrl;
+    volatile reg_vo_dac_otp vo_dac_otp;
+
+    vo_dac_ctrl.u32 = vo_reg->vo_dac_ctrl.u32;
+    vo_dac_otp.u32 = vo_reg->vo_dac_otp.u32;
+    vo_dac_ctrl.bits.dac_reg_rev = 0xF;       /* 0xF: CVBS hardware test need it */
+    vo_dac_otp.bits.dac_otp_reg = 0x7900;   /* 0x7900: CVBS hardware test need it */
+    vo_reg->vo_dac_ctrl.u32 = vo_dac_ctrl.u32;
+    vo_reg->vo_dac_otp.u32 = vo_dac_otp.u32;
+}
+
+gk_void vo_hal_intf_set_dac_chn_enable(gk_vo_intf_type intf_type, gk_bool enable)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_vo_dac0_ctrl vo_dac0_ctrl;
+    volatile reg_vo_dac1_ctrl vo_dac1_ctrl;
+    volatile reg_vo_dac2_ctrl vo_dac2_ctrl;
+    volatile reg_vo_dac3_ctrl vo_dac3_ctrl;
+
+    if (intf_type == GK_VO_INTF_VGA) {
+        vo_dac0_ctrl.u32 = vo_reg->vo_dac0_ctrl.u32;
+        vo_dac1_ctrl.u32 = vo_reg->vo_dac1_ctrl.u32;
+        vo_dac2_ctrl.u32 = vo_reg->vo_dac2_ctrl.u32;
+        vo_dac0_ctrl.bits.dac_en = enable;
+        vo_dac1_ctrl.bits.dac_en = enable;
+        vo_dac2_ctrl.bits.dac_en = enable;
+        vo_reg->vo_dac0_ctrl.u32 = vo_dac0_ctrl.u32;
+        vo_reg->vo_dac1_ctrl.u32 = vo_dac1_ctrl.u32;
+        vo_reg->vo_dac2_ctrl.u32 = vo_dac2_ctrl.u32;
+    } else if (intf_type == GK_VO_INTF_CVBS) {
+        vo_dac3_ctrl.u32 = vo_reg->vo_dac3_ctrl.u32;
+        vo_dac3_ctrl.bits.dac_en = enable;
+        vo_reg->vo_dac3_ctrl.u32 = vo_dac3_ctrl.u32;
+    }
+}
+
+gk_void vo_hal_intf_set_dac_gc(gk_vo_intf_type intf_type, gk_u32 dac_gc)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_vo_dac0_ctrl vo_dac0_ctrl;
+    volatile reg_vo_dac1_ctrl vo_dac1_ctrl;
+    volatile reg_vo_dac2_ctrl vo_dac2_ctrl;
+    volatile reg_vo_dac3_ctrl vo_dac3_ctrl;
+
+    if (intf_type == GK_VO_INTF_VGA) {
+        vo_dac0_ctrl.u32 = vo_reg->vo_dac0_ctrl.u32;
+        vo_dac1_ctrl.u32 = vo_reg->vo_dac1_ctrl.u32;
+        vo_dac2_ctrl.u32 = vo_reg->vo_dac2_ctrl.u32;
+        vo_dac0_ctrl.bits.dacgc = dac_gc;
+        vo_dac1_ctrl.bits.dacgc = dac_gc;
+        vo_dac2_ctrl.bits.dacgc = dac_gc;
+        vo_reg->vo_dac0_ctrl.u32 = vo_dac0_ctrl.u32;
+        vo_reg->vo_dac1_ctrl.u32 = vo_dac1_ctrl.u32;
+        vo_reg->vo_dac2_ctrl.u32 = vo_dac2_ctrl.u32;
+    } else if (intf_type == GK_VO_INTF_CVBS) {
+        vo_dac3_ctrl.u32 = vo_reg->vo_dac3_ctrl.u32;
+        vo_dac3_ctrl.bits.dacgc = dac_gc;
+        vo_reg->vo_dac3_ctrl.u32 = vo_dac3_ctrl.u32;
+    }
+}
+
+gk_void vo_hal_intf_set_dac_cablectr(gk_vo_intf_type intf_type, gk_u32 cablectr)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_vo_dac0_ctrl vo_dac0_ctrl;
+    volatile reg_vo_dac1_ctrl vo_dac1_ctrl;
+    volatile reg_vo_dac2_ctrl vo_dac2_ctrl;
+    volatile reg_vo_dac3_ctrl vo_dac3_ctrl;
+
+    if (intf_type == GK_VO_INTF_VGA) {
+        vo_dac0_ctrl.u32 = vo_reg->vo_dac0_ctrl.u32;
+        vo_dac1_ctrl.u32 = vo_reg->vo_dac1_ctrl.u32;
+        vo_dac2_ctrl.u32 = vo_reg->vo_dac2_ctrl.u32;
+        vo_dac0_ctrl.bits.cablectr = cablectr;
+        vo_dac1_ctrl.bits.cablectr = cablectr;
+        vo_dac2_ctrl.bits.cablectr = cablectr;
+        vo_reg->vo_dac0_ctrl.u32 = vo_dac0_ctrl.u32;
+        vo_reg->vo_dac1_ctrl.u32 = vo_dac1_ctrl.u32;
+        vo_reg->vo_dac2_ctrl.u32 = vo_dac2_ctrl.u32;
+    } else if (intf_type == GK_VO_INTF_CVBS) {
+        vo_dac3_ctrl.u32 = vo_reg->vo_dac3_ctrl.u32;
+        vo_dac3_ctrl.bits.cablectr = cablectr;
+        vo_reg->vo_dac3_ctrl.u32 = vo_dac3_ctrl.u32;
+    }
+}
+
+static gk_void vo_hal_intf_set_vga_hsp_coef(hsp_coef *coef)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_vga_hspcfg14 vga_hspcfg14;
+    volatile reg_vga_hspcfg15 vga_hspcfg15;
+
+    vga_hspcfg14.u32 = vo_reg->vga_hspcfg14.u32;
+    vga_hspcfg15.u32 = vo_reg->vga_hspcfg15.u32;
+
+    vga_hspcfg14.bits.hsp_cdti_gain = coef->vga_hsp_cdti_gain;
+    vga_hspcfg14.bits.hsp_ldti_gain = coef->vga_hsp_ldti_gain;
+    vga_hspcfg14.bits.hsp_lti_ratio = coef->vga_hsp_lti_ratio;
+    vga_hspcfg14.bits.hsp_hf_shootdiv = coef->vga_hsp_hf_shootdiv;
+    vga_hspcfg15.bits.hsp_glb_underth = coef->vga_hsp_glb_underth;
+    vga_hspcfg15.bits.hsp_glb_overth = coef->vga_hsp_glb_overth;
+    vga_hspcfg15.bits.hsp_peak_ratio = coef->vga_hsp_peak_ratio;
+
+    vo_reg->vga_hspcfg14.u32 = vga_hspcfg14.u32;
+    vo_reg->vga_hspcfg15.u32 = vga_hspcfg15.u32;
+}
+
+static gk_void vo_hal_intf_set_vga_hsp_h0_coef(hsp_hf_coef *coef0)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_vga_hspcfg0 vga_hspcfg0;
+    volatile reg_vga_hspcfg1 vga_hspcfg1;
+    volatile reg_vga_hspcfg5 vga_hspcfg5;
+    volatile reg_vga_hspcfg6 vga_hspcfg6;
+
+    vga_hspcfg0.u32 = vo_reg->vga_hspcfg0.u32;
+    vga_hspcfg1.u32 = vo_reg->vga_hspcfg1.u32;
+    vga_hspcfg5.u32 = vo_reg->vga_hspcfg5.u32;
+    vga_hspcfg6.u32 = vo_reg->vga_hspcfg6.u32;
+
+    vga_hspcfg0.bits.hsp_hf0_tmp0 = coef0->vga_hsp_tmp0;
+    vga_hspcfg0.bits.hsp_hf0_tmp1 = coef0->vga_hsp_tmp1;
+    vga_hspcfg0.bits.hsp_hf0_tmp2 = coef0->vga_hsp_tmp2;
+    vga_hspcfg0.bits.hsp_hf0_tmp3 = coef0->vga_hsp_tmp3;
+    vga_hspcfg1.bits.hsp_hf0_coring = coef0->vga_hsp_coring;
+    vga_hspcfg5.bits.hsp_hf0_gainpos = coef0->vga_hsp_gainpos;
+    vga_hspcfg5.bits.hsp_hf0_gainneg = coef0->vga_hsp_gainneg;
+    vga_hspcfg6.bits.hsp_hf0_overth = coef0->vga_hsp_overth;
+    vga_hspcfg6.bits.hsp_hf0_underth = coef0->vga_hsp_underth;
+    vga_hspcfg6.bits.hsp_hf0_mixratio = coef0->vga_hsp_mixratio;
+    vga_hspcfg6.bits.hsp_hf0_winsize = coef0->vga_hsp_winsize;
+    vga_hspcfg6.bits.hsp_hf0_adpshoot_en = coef0->vga_hsp_adpshooten;
+
+    vo_reg->vga_hspcfg0.u32 = vga_hspcfg0.u32;
+    vo_reg->vga_hspcfg1.u32 = vga_hspcfg1.u32;
+    vo_reg->vga_hspcfg5.u32 = vga_hspcfg5.u32;
+    vo_reg->vga_hspcfg6.u32 = vga_hspcfg6.u32;
+}
+
+static gk_void vo_hal_intf_set_vga_hsp_h1_coef(hsp_hf_coef *coef1)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_vga_hspcfg7 vga_hspcfg7;
+    volatile reg_vga_hspcfg8 vga_hspcfg8;
+    volatile reg_vga_hspcfg12 vga_hspcfg12;
+    volatile reg_vga_hspcfg13 vga_hspcfg13;
+
+    vga_hspcfg7.u32 = vo_reg->vga_hspcfg7.u32;
+    vga_hspcfg8.u32 = vo_reg->vga_hspcfg8.u32;
+    vga_hspcfg12.u32 = vo_reg->vga_hspcfg12.u32;
+    vga_hspcfg13.u32 = vo_reg->vga_hspcfg13.u32;
+
+    vga_hspcfg7.bits.hsp_hf1_tmp0 = coef1->vga_hsp_tmp0;
+    vga_hspcfg7.bits.hsp_hf1_tmp1 = coef1->vga_hsp_tmp1;
+    vga_hspcfg7.bits.hsp_hf1_tmp2 = coef1->vga_hsp_tmp2;
+    vga_hspcfg7.bits.hsp_hf1_tmp3 = coef1->vga_hsp_tmp3;
+    vga_hspcfg8.bits.hsp_hf1_coring = coef1->vga_hsp_coring;
+    vga_hspcfg12.bits.hsp_hf1_gainpos = coef1->vga_hsp_gainpos;
+    vga_hspcfg12.bits.hsp_hf1_gainneg = coef1->vga_hsp_gainneg;
+    vga_hspcfg13.bits.hsp_hf1_overth = coef1->vga_hsp_overth;
+    vga_hspcfg13.bits.hsp_hf1_underth = coef1->vga_hsp_underth;
+    vga_hspcfg13.bits.hsp_hf1_mixratio = coef1->vga_hsp_mixratio;
+    vga_hspcfg13.bits.hsp_hf1_winsize = coef1->vga_hsp_winsize;
+    vga_hspcfg13.bits.hsp_hf1_adpshoot_en = coef1->vga_hsp_adpshooten;
+
+    vo_reg->vga_hspcfg7.u32 = vga_hspcfg7.u32;
+    vo_reg->vga_hspcfg8.u32 = vga_hspcfg8.u32;
+    vo_reg->vga_hspcfg12.u32 = vga_hspcfg12.u32;
+    vo_reg->vga_hspcfg13.u32 = vga_hspcfg13.u32;
+}
+
+static gk_void vo_hal_intf_set_vga_hsp_h_enable(gk_bool enable)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_vga_hspcfg14 vga_hspcfg14;
+
+    vga_hspcfg14.u32 = vo_reg->vga_hspcfg14.u32;
+    vga_hspcfg14.bits.hsp_h0_en = enable;
+    vga_hspcfg14.bits.hsp_h1_en = enable;
+    vga_hspcfg14.bits.hsp_ltih_en = enable;
+    vga_hspcfg14.bits.hsp_ctih_en = enable;
+    vo_reg->vga_hspcfg14.u32 = vga_hspcfg14.u32;
+}
+
+static gk_void vo_hal_intf_set_vga_hsp_enable(gk_bool enable)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_vga_hspcfg1 vga_hspcfg1;
+
+    vga_hspcfg1.u32 = vo_reg->vga_hspcfg1.u32;
+    vga_hspcfg1.bits.hsp_en = enable;
+    vo_reg->vga_hspcfg1.u32 = vga_hspcfg1.u32;
+}
+
+static gk_void vo_hal_intf_set_vga_hsp_cfg_coef(gk_u32 strength)
+{
+    const gk_u32 pre = 8;
+    hsp_coef coef = {0};
+
+    coef.vga_hsp_peak_ratio = 128; /* 128 */
+    coef.vga_hsp_glb_overth = 50;  /* 50 */
+    coef.vga_hsp_hf_shootdiv = 4;  /* 4 */
+    coef.vga_hsp_lti_ratio = 128;  /* 128 */
+    coef.vga_hsp_ldti_gain = (192 * strength) >> pre;  /* 192 */
+    coef.vga_hsp_cdti_gain = (192 * strength) >> pre;  /* 192 */
+    coef.vga_hsp_glb_underth = 255;  /* 255 */
+
+    vo_hal_intf_set_vga_hsp_coef(&coef);
+}
+
+static gk_void vo_hal_intf_set_vga_hsp_cfg_coef0(gk_u32 strength)
+{
+    const gk_u32 pre = 8;
+    hsp_hf_coef coef0 = {0};
+
+    coef0.vga_hsp_tmp0 = 0;
+    coef0.vga_hsp_tmp1 = -84; /* -84: coef 1 */
+    coef0.vga_hsp_tmp2 = 0;
+    coef0.vga_hsp_tmp3 = 20;   /* 20: coef 3 */
+    coef0.vga_hsp_coring = 2;  /* 2: coef */
+    coef0.vga_hsp_gainpos = (strength <= VO_VGA_SHARPEN_STRENGTH_DEF) ? ((154 * strength) >> pre) /* 154:coef */
+        : (2 * (strength - VO_VGA_SHARPEN_STRENGTH_DEF) + 77); /* 2:coef 77:coef  */
+    coef0.vga_hsp_gainneg = (strength <= VO_VGA_SHARPEN_STRENGTH_DEF) ? ((154 * strength) >> pre) /* 154:coef */
+        : (2 * (strength - VO_VGA_SHARPEN_STRENGTH_DEF) + 77); /* 2:coef 77:coef  */
+    coef0.vga_hsp_adpshooten = 1; /* 1: enable */
+    coef0.vga_hsp_winsize    = 2; /* 2: window size */
+    coef0.vga_hsp_mixratio   = 64; /* 64: 0.5 * 128 */
+    coef0.vga_hsp_underth    = (strength <= VO_VGA_SHARPEN_STRENGTH_DEF) ? ((36 * strength) >> pre) /* 36:coef */
+        : ((72 * ((strength - VO_VGA_SHARPEN_STRENGTH_DEF) >> pre)) +  18);  /* 72:coef 18:coef */
+    coef0.vga_hsp_overth     = (strength <= VO_VGA_SHARPEN_STRENGTH_DEF) ? ((24 * strength) >> pre) /* 24:coef */
+        : ((48 * ((strength - VO_VGA_SHARPEN_STRENGTH_DEF) >> pre)) +  12);  /* 48:coef 12:coef */
+
+    vo_hal_intf_set_vga_hsp_h0_coef(&coef0);
+}
+
+static gk_void vo_hal_intf_set_vga_hsp_cfg_coef1(gk_u32 strength)
+{
+    const gk_u32 pre = 8;
+    hsp_hf_coef coef1 = {0};
+
+    coef1.vga_hsp_tmp0 = 22;    /* 22: coef 0 */
+    coef1.vga_hsp_tmp1 = -62;   /* -62: coef 1 */
+    coef1.vga_hsp_tmp2 = -25;   /* -25: coef 2 */
+    coef1.vga_hsp_tmp3 = 1;     /* 1: coef 3 */
+    coef1.vga_hsp_coring = 2; /* 2: coef  */
+    coef1.vga_hsp_gainpos = (strength <= VO_VGA_SHARPEN_STRENGTH_DEF) ? ((214 * strength) >> pre) /* 214:coef  */
+        : ((712 * ((strength - VO_VGA_SHARPEN_STRENGTH_DEF) >> pre)) + 107); /* 712:coef 107:coef  */
+    coef1.vga_hsp_gainneg = (strength <= VO_VGA_SHARPEN_STRENGTH_DEF) ? ((214 * strength) >> pre) /* 214:coef */
+        : ((712 * ((strength - VO_VGA_SHARPEN_STRENGTH_DEF) >> pre)) + 107); /* 712:coef 107:coef  */
+    coef1.vga_hsp_adpshooten = 1;  /* 1: coef  */
+    coef1.vga_hsp_winsize    = 3;  /* 3: window size */
+    coef1.vga_hsp_mixratio   = 102; /* 102:: 0.8 * 128 */
+    coef1.vga_hsp_underth    = (strength <= VO_VGA_SHARPEN_STRENGTH_DEF) ? ((36 * strength) >> pre) /* 36:coef  */
+        : ((72 * ((strength - VO_VGA_SHARPEN_STRENGTH_DEF) >> pre)) +  18);  /* 72:coef 18:coef  */
+    coef1.vga_hsp_overth     = (strength <= VO_VGA_SHARPEN_STRENGTH_DEF) ? ((30 * strength) >> pre) /* 30:coef */
+        : ((60 * ((strength - VO_VGA_SHARPEN_STRENGTH_DEF) >> pre)) +  15);  /* 60:coef 15:coef */
+
+    vo_hal_intf_set_vga_hsp_h1_coef(&coef1);
+}
+
+gk_void vo_hal_intf_set_vga_hsp_cfg(gk_bool enable, gk_u32 strength)
+{
+    vo_hal_intf_set_vga_hsp_cfg_coef(strength);
+    vo_hal_intf_set_vga_hsp_cfg_coef0(strength);
+    vo_hal_intf_set_vga_hsp_cfg_coef1(strength);
+    vo_hal_intf_set_vga_hsp_h_enable(enable);
+    vo_hal_intf_set_vga_hsp_enable(enable);
+}
+
+static gk_void vo_hal_intf_set_date_coeff(gk_u32 data)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    vo_reg->date_coeff0.u32 = data;
+}
+
+static gk_void vo_hal_intf_set_date_cgain(gk_u32 data)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    vo_reg->date_coeff1.u32 = data;
+}
+
+static gk_void vo_hal_intf_set_date_out_ctrl(gk_u32 data)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_date_coeff21 date_coeff21;
+    volatile reg_date_coeff21 input_data;
+
+    date_coeff21.u32 = vo_reg->date_coeff21.u32;
+    input_data.u32 = data;
+
+    date_coeff21.bits.dac0_in_sel = input_data.bits.dac0_in_sel;
+    date_coeff21.bits.dac1_in_sel = input_data.bits.dac1_in_sel;
+    date_coeff21.bits.dac2_in_sel = input_data.bits.dac2_in_sel;
+    date_coeff21.bits.dac3_in_sel = input_data.bits.dac3_in_sel;
+    date_coeff21.bits.dac4_in_sel = input_data.bits.dac4_in_sel;
+    date_coeff21.bits.dac5_in_sel = input_data.bits.dac5_in_sel;
+
+    vo_reg->date_coeff21.u32 = date_coeff21.u32;
+}
+
+static gk_void vo_hal_intf_set_date_delta(gk_u32 data)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    vo_reg->date_coeff22.u32 = data;
+}
+
+gk_void vo_hal_intf_set_date_cvbs_color_burst(gk_void)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    vo_reg->date_coeff24 = 0x12099; /* 0x12099: color burst start position. */
+}
+
+gk_void vo_hal_intf_set_date_cvbs_burst_start(gk_void)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_date_coeff61 date_coeff61;
+
+    date_coeff61.u32 = vo_reg->date_coeff61.u32;
+    date_coeff61.bits.burst_start_ovrd = 0x1; /* 0x1: refresh */
+    vo_reg->date_coeff61.u32 = date_coeff61.u32;
+}
+
+static gk_u32 vo_hal_intf_get_date_user(gk_u32 vact)
+{
+    if (vact == 288) { /* 288 = 576 / 2 */
+        return VO_CVBS_DATE_PAL;
+    } else if (vact == 240) { /* 240 = 480 / 2 */
+        return VO_CVBS_DATE_NTSC;
+    } else {
+        vo_err_trace("GK_VO_OUT_USER wrong vact: %d\n", vact);
+        return VO_CVBS_DATE_NTSC;
+    }
+}
+
+gk_u32 vo_hal_intf_get_date(gk_vo_intf_sync intf_sync, gk_u32 vact)
+{
+    if (intf_sync == GK_VO_OUT_PAL) {
+        return VO_CVBS_DATE_PAL;
+    } else if (intf_sync == GK_VO_OUT_NTSC) {
+        return VO_CVBS_DATE_NTSC;
+    }
+    return vo_hal_intf_get_date_user(vact);
+}
+
+gk_void vo_hal_intf_set_date_cfg(gk_vo_intf_sync intf_sync, gk_u32 date)
+{
+    vo_hal_intf_set_date_coeff(date);
+    vo_hal_intf_set_date_cgain(0x20000000);   /* 0x20000000: data cgain */
+    vo_hal_intf_set_date_out_ctrl(0x111111);  /* 0x111111: data out ctrl */
+    vo_hal_intf_set_date_delta(0xa4);         /* 0xa4: data delta */
+    vo_hal_intf_set_date_cvbs_gain(0x80808383); /* 0x80808383: cvbs gain */
+
+    if (intf_sync == GK_VO_OUT_NTSC) {
+        vo_hal_intf_set_date_cvbs_color_burst();
+        vo_hal_intf_set_date_cvbs_burst_start();
+    }
+}
+
+gk_void vo_hal_intf_set_clip_cfg(gk_vo_intf_type intf_type, gk_bool clip, hal_disp_clip *clip_data)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_bt_clip0_l bt_clip0_l;
+    volatile reg_bt_clip0_h bt_clip0_h;
+    volatile reg_date_clip0_l date_clip0_l;
+    volatile reg_date_clip0_h date_clip0_h;
+
+    if ((intf_type == GK_VO_INTF_BT1120) || (intf_type == GK_VO_INTF_BT656)) {
+        bt_clip0_l.u32 = vo_reg->bt_clip0_l.u32;
+        bt_clip0_h.u32 = vo_reg->bt_clip0_h.u32;
+        bt_clip0_l.bits.clip_en = clip;
+        bt_clip0_l.bits.clip_cl2 = clip_data->clip_low_y;
+        bt_clip0_l.bits.clip_cl1 = clip_data->clip_low_cb;
+        bt_clip0_l.bits.clip_cl0 = clip_data->clip_low_cr;
+        bt_clip0_h.bits.clip_ch2 = clip_data->clip_high_y;
+        bt_clip0_h.bits.clip_ch1 = clip_data->clip_high_cb;
+        bt_clip0_h.bits.clip_ch0 = clip_data->clip_high_cr;
+        vo_reg->bt_clip0_l.u32 = bt_clip0_l.u32;
+        vo_reg->bt_clip0_h.u32 = bt_clip0_h.u32;
+    } else if (intf_type == GK_VO_INTF_CVBS) {
+        date_clip0_l.u32 = vo_reg->date_clip0_l.u32;
+        date_clip0_h.u32 = vo_reg->date_clip0_h.u32;
+        date_clip0_l.bits.clip_en = clip;
+        date_clip0_l.bits.clip_cl2 = clip_data->clip_low_y;
+        date_clip0_l.bits.clip_cl1 = clip_data->clip_low_cb;
+        date_clip0_l.bits.clip_cl0 = clip_data->clip_low_cr;
+        date_clip0_h.bits.clip_ch2 = clip_data->clip_high_y;
+        date_clip0_h.bits.clip_ch1 = clip_data->clip_high_cb;
+        date_clip0_h.bits.clip_ch0 = clip_data->clip_high_cr;
+        vo_reg->date_clip0_l.u32 = date_clip0_l.u32;
+        vo_reg->date_clip0_h.u32 = date_clip0_h.u32;
+    }
+}
+
+static gk_void vo_hal_intf_set_sync_info_hvsync(gk_vo_dev dev,
+    hal_disp_syncinfo *sync_info)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_dhd0_hsync1 dhd0_hsync1;
+    volatile reg_dhd0_hsync2 dhd0_hsync2;
+    volatile reg_dhd0_vsync1 dhd0_vsync1;
+    volatile reg_dhd0_vsync2 dhd0_vsync2;
+    volatile gk_ulong addr_reg;
+
+    addr_reg = vou_get_chn_abs_addr(dev, (gk_uintptr_t) & (vo_reg->dhd0_hsync1.u32));
+    dhd0_hsync1.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    dhd0_hsync1.bits.hact = sync_info->hact - 1;
+    dhd0_hsync1.bits.hbb = (sync_info->hbb) - 1;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, dhd0_hsync1.u32);
+
+    addr_reg = vou_get_chn_abs_addr(dev, (gk_uintptr_t) & (vo_reg->dhd0_hsync2.u32));
+    dhd0_hsync2.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    dhd0_hsync2.bits.hmid = (sync_info->hmid == 0) ? 0 : sync_info->hmid - 1;
+    dhd0_hsync2.bits.hfb = (sync_info->hfb) - 1;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, dhd0_hsync2.u32);
+
+    /* config VHD interface veritical timming */
+    addr_reg = vou_get_chn_abs_addr(dev, (gk_uintptr_t) & (vo_reg->dhd0_vsync1.u32));
+    dhd0_vsync1.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    dhd0_vsync1.bits.vact = sync_info->vact - 1;
+    dhd0_vsync1.bits.vbb = sync_info->vbb - 1;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, dhd0_vsync1.u32);
+
+    addr_reg = vou_get_chn_abs_addr(dev, (gk_uintptr_t) & (vo_reg->dhd0_vsync2.u32));
+    dhd0_vsync2.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    dhd0_vsync2.bits.vfb = sync_info->vfb - 1;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, dhd0_vsync2.u32);
+}
+
+static gk_void vo_hal_intf_set_sync_info_other(gk_vo_dev dev,
+    hal_disp_syncinfo *sync_info)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_dhd0_ctrl dhd0_ctrl;
+    volatile reg_dhd0_vplus1 dhd0_vplus1;
+    volatile reg_dhd0_vplus2 dhd0_vplus2;
+    volatile reg_dhd0_pwr dhd0_pwr;
+    volatile gk_ulong addr_reg;
+
+    addr_reg = vou_get_chn_abs_addr(dev, (gk_uintptr_t) & (vo_reg->dhd0_ctrl.u32));
+    dhd0_ctrl.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    dhd0_ctrl.bits.iop = sync_info->iop;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, dhd0_ctrl.u32);
+
+    /* config VHD interface veritical bottom timming,no use in progressive mode */
+    addr_reg = vou_get_chn_abs_addr(dev, (gk_ulong)(gk_uintptr_t) & (vo_reg->dhd0_vplus1.u32));
+    dhd0_vplus1.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    dhd0_vplus1.bits.bvact = sync_info->bvact - 1;
+    dhd0_vplus1.bits.bvbb = sync_info->bvbb - 1;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, dhd0_vplus1.u32);
+
+    addr_reg = vou_get_chn_abs_addr(dev, (gk_uintptr_t) & (vo_reg->dhd0_vplus2.u32));
+    dhd0_vplus2.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    dhd0_vplus2.bits.bvfb = sync_info->bvfb - 1;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, dhd0_vplus2.u32);
+
+    /* config VHD interface veritical bottom timming, */
+    addr_reg = vou_get_chn_abs_addr(dev, (gk_uintptr_t) & (vo_reg->dhd0_pwr.u32));
+    dhd0_pwr.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    dhd0_pwr.bits.hpw = sync_info->hpw - 1;
+    dhd0_pwr.bits.vpw = sync_info->vpw - 1;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, dhd0_pwr.u32);
+}
+
+gk_void vo_hal_intf_set_sync_info(gk_vo_dev dev, hal_disp_syncinfo *sync_info)
+{
+    vo_hal_check_phy_dev_return(dev);
+
+    vo_hal_intf_set_sync_info_hvsync(dev, sync_info);
+    vo_hal_intf_set_sync_info_other(dev, sync_info);
+}
+
+#endif
+
+#endif /* #if VO_DESC("UBOOT_VO") */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/src/hal_vo_dev_comm.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/hal_vo_dev_comm.h
--- u-boot-2016.11/product/osd/vo/arch/comm/src/hal_vo_dev_comm.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/hal_vo_dev_comm.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __HAL_VO_DEV_COMM_H__
+#define __HAL_VO_DEV_COMM_H__
+
+#include "hal_vo_def.h"
+#include "drv_vo_coef_comm.h"
+#include "inner_vo.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#if VO_DESC("UBOOT_VO")
+#if VO_DESC("intf")
+#define VO_CVBS_DATE_NTSC 0x108410dc
+gk_void hal_sys_set_rd_bus_id(gk_u32 mode);
+gk_void hal_disp_set_intf_enable(gk_vo_dev dev, gk_bool intf);
+gk_void hal_disp_get_intf_enable(gk_vo_dev dev, gk_bool *intf_en);
+gk_void hal_disp_set_hdmi_mode(gk_vo_dev dev, gk_u32 color_space);
+gk_void hal_disp_set_dev_multi_chn_en(gk_vo_dev dev, hal_multichn_en multi_chn_en);
+#endif
+
+#if VO_DESC("disp intf")
+gk_void hal_disp_set_vtthd_mode(gk_vo_dev dev, gk_u32 field_mode);
+gk_void hal_disp_set_vtthd(gk_vo_dev dev, gk_u32 vtthd, gk_u32 vtthd2);
+gk_void hal_disp_clear_int_status(gk_u32 int_msk);
+gk_void hal_intf_bt_set_dfir_en(gk_u32 dfir_en);
+gk_void hal_intf_bt_set_data_width(gk_u32 data_width);
+gk_void hal_disp_set_reg_up(gk_vo_dev dev);
+gk_u32 hal_disp_get_reg_up(gk_vo_dev dev);
+#endif
+
+#if VO_DESC("intf")
+gk_void vo_hal_intf_set_mux_sel(gk_vo_dev dev, gk_vo_intf_type intf);
+gk_void vo_hal_intf_set_bt_sync_inv(hal_disp_syncinv *inv);
+gk_void vo_hal_intf_set_cvbs_sync_inv(hal_disp_syncinv *inv);
+gk_void vo_hal_intf_set_vga_sync_inv(hal_disp_syncinv *inv);
+gk_void vo_hal_intf_set_hdmi_sync_inv(hal_disp_syncinv *inv);
+gk_void vo_hal_intf_set_hdmi_csc_dc_coef(vdp_csc_dc_coef *csc_dc_coef);
+gk_void vo_hal_intf_set_vga_csc_dc_coef(vdp_csc_dc_coef *csc_dc_coef);
+gk_void vo_hal_intf_set_hdmi_csc_coef(vdp_csc_coef *csc_coef);
+gk_void vo_hal_intf_set_vga_csc_coef(vdp_csc_coef *csc_coef);
+gk_void vo_hal_intf_set_csc_cfg(gk_vo_intf_type intf, csc_coef *coef);
+gk_void vo_hal_intf_set_dac_sel(gk_vo_intf_type intf_type);
+gk_void vo_hal_intf_set_vga_and_cvbs_dac_enable(gk_bool enable);
+gk_void vo_hal_intf_set_cvbs_dac_cfg(gk_void);
+gk_void vo_hal_intf_set_dac_chn_enable(gk_vo_intf_type intf_type, gk_bool enable);
+gk_void vo_hal_intf_set_dac_gc(gk_vo_intf_type intf_type, gk_u32 dac_gc);
+gk_void vo_hal_intf_set_dac_cablectr(gk_vo_intf_type intf_type, gk_u32 cablectr);
+gk_void vo_hal_intf_set_dac_det(gk_vo_dev dev, gk_vo_intf_type intf_type, gk_bool enable);
+gk_void vo_hal_intf_set_vga_hsp_cfg(gk_bool enable, gk_u32 strength);
+gk_void vo_hal_intf_set_date_cvbs_burst_start(gk_void);
+gk_void vo_hal_intf_set_date_cvbs_color_burst(gk_void);
+gk_u32 vo_hal_intf_get_date(gk_vo_intf_sync intf_sync, gk_u32 vact);
+gk_void vo_hal_intf_set_date_cfg(gk_vo_intf_sync intf_sync, gk_u32 date);
+gk_void vo_hal_intf_set_clip_cfg(gk_vo_intf_type intf_type, gk_bool clip, hal_disp_clip *clip_data);
+gk_void vo_hal_intf_set_sync_info(gk_vo_dev dev, hal_disp_syncinfo *sync_info);
+#endif
+#endif /* #if VO_DESC("UBOOT VO") */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* end of __HAL_VO_DEV_COMM_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/src/hal_vo_gfx_comm.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/hal_vo_gfx_comm.c
--- u-boot-2016.11/product/osd/vo/arch/comm/src/hal_vo_gfx_comm.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/hal_vo_gfx_comm.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,205 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#include "hal_vo_gfx_comm.h"
+#include "hal_vo.h"
+#include "math.h"
+#include "mkp_vo.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#if VO_DESC("UBOOT_VO")
+#if VO_DESC("gfx uboot only")
+gk_void hal_gfx_set_layer_disp_rect(hal_disp_layer layer, gk_rect *rect)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_g0_dfpos g0_dfpos;
+    volatile reg_g0_dlpos g0_dlpos;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_gfx_layer_return(layer);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_ulong)(gk_uintptr_t)&(vo_reg->g0_dfpos.u32));
+    g0_dfpos.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    g0_dfpos.bits.disp_xfpos = rect->x;
+    g0_dfpos.bits.disp_yfpos = rect->y;
+    hal_write_reg((gk_u32 *)(gk_uintptr_t)addr_reg, g0_dfpos.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_ulong)(gk_uintptr_t)&(vo_reg->g0_dlpos.u32));
+    g0_dlpos.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t)addr_reg);
+    g0_dlpos.bits.disp_xlpos = rect->x + rect->width - 1;
+    g0_dlpos.bits.disp_ylpos = rect->y + rect->height - 1;
+    hal_write_reg((gk_u32 *)(gk_uintptr_t)addr_reg, g0_dlpos.u32);
+}
+
+gk_void hal_gfx_set_layer_video_rect(hal_disp_layer layer, gk_rect *rect)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_g0_vfpos g0_vfpos;
+    volatile reg_g0_vlpos g0_vlpos;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_gfx_layer_return(layer);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_ulong)(gk_uintptr_t)&(vo_reg->g0_vfpos.u32));
+    g0_vfpos.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t)addr_reg);
+    g0_vfpos.bits.video_xfpos = rect->x;
+    g0_vfpos.bits.video_yfpos = rect->y;
+    hal_write_reg((gk_u32 *)(gk_uintptr_t)addr_reg, g0_vfpos.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_ulong)(gk_uintptr_t)&(vo_reg->g0_vlpos.u32));
+    g0_vlpos.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t)addr_reg);
+    g0_vlpos.bits.video_xlpos = rect->x + rect->width - 1;
+    g0_vlpos.bits.video_ylpos = rect->y + rect->height - 1;
+    hal_write_reg((gk_u32 *)(gk_uintptr_t)addr_reg, g0_vlpos.u32);
+}
+
+gk_void hal_gfx_enable_layer(hal_disp_layer layer, gk_u32 enable)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_g0_ctrl g0_ctrl;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_gfx_layer_return(layer);
+    addr_reg = vou_get_abs_addr(layer, (gk_ulong)(gk_uintptr_t)&(vo_reg->g0_ctrl.u32));
+    g0_ctrl.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t)addr_reg);
+    g0_ctrl.bits.surface_en = enable;
+    hal_write_reg((gk_u32 *)(gk_uintptr_t)addr_reg, g0_ctrl.u32);
+}
+
+gk_void hal_gfx_set_layer_data_fmt(hal_disp_layer layer, hal_disp_pixel_format data_fmt)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_gfx_src_info gfx_src_info;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_gfx_layer_return(layer);
+    addr_reg = vou_get_gfx_abs_addr(layer, (gk_ulong)(gk_uintptr_t)&(vo_reg->gfx_src_info.u32));
+    gfx_src_info.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t)addr_reg);
+    gfx_src_info.bits.ifmt = data_fmt;
+    hal_write_reg((gk_u32 *)(gk_uintptr_t)addr_reg, gfx_src_info.u32);
+}
+
+gk_void hal_gfx_set_layer_in_rect(hal_disp_layer layer, gk_rect *rect)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    reg_gfx_ireso gfx_ireso;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_gfx_layer_return(layer);
+    addr_reg = vou_get_gfx_abs_addr(layer, (gk_ulong)(gk_uintptr_t)&(vo_reg->gfx_ireso.u32));
+    gfx_ireso.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t)addr_reg);
+    gfx_ireso.bits.ireso_w = rect->width - 1;
+    gfx_ireso.bits.ireso_h = rect->height - 1;
+    hal_write_reg((gk_u32 *)(gk_uintptr_t)addr_reg, gfx_ireso.u32);
+}
+
+gk_bool hal_gfx_set_reg_up(hal_disp_layer layer)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    reg_g0_upd g0_upd;
+    volatile gk_ulong addr_reg;
+
+    switch (layer) {
+        case HAL_DISP_LAYER_GFX0:
+        case HAL_DISP_LAYER_GFX1:
+        case HAL_DISP_LAYER_GFX2:
+        case HAL_DISP_LAYER_GFX3:
+            addr_reg = vou_get_abs_addr(layer, (gk_ulong)(gk_uintptr_t)&(vo_reg->g0_upd.u32));
+            g0_upd.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t)addr_reg);
+            /* graphic layer register update */
+            g0_upd.bits.regup = 0x1;
+            hal_write_reg((gk_u32 *)(gk_uintptr_t)addr_reg, g0_upd.u32);
+            break;
+
+        default:
+            vo_err_trace("err layer id %d\n", layer);
+            return GK_FALSE;
+    }
+
+    return GK_TRUE;
+}
+
+gk_void hal_gfx_set_gfx_pre_mult(hal_disp_layer layer, gk_u32 enable)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_gfx_out_ctrl gfx_out_ctrl;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_gfx_layer_return(layer);
+    addr_reg = vou_get_gfx_abs_addr(layer, (gk_ulong)(gk_uintptr_t)&(vo_reg->gfx_out_ctrl.u32));
+    gfx_out_ctrl.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t)addr_reg);
+    gfx_out_ctrl.bits.premulti_en = enable;
+    hal_write_reg((gk_u32 *)(gk_uintptr_t)addr_reg, gfx_out_ctrl.u32);
+}
+
+gk_void hal_gfx_set_gfx_addr(hal_disp_layer layer, gk_phys_addr_t l_addr)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile gk_ulong ul_gfx_addr_h;
+    volatile gk_ulong ul_gfx_addr_l;
+
+    vo_hal_check_gfx_layer_return(layer);
+    // write low address to register.
+    ul_gfx_addr_l = vou_get_gfx_abs_addr(layer, (gk_ulong)(gk_uintptr_t)&(vo_reg->gfx_addr_l));
+    hal_write_reg((gk_u32 *)(gk_uintptr_t)ul_gfx_addr_l, get_low_addr(l_addr));
+    // write high address to register.
+    ul_gfx_addr_h = vou_get_gfx_abs_addr(layer, (gk_ulong)(gk_uintptr_t)&(vo_reg->gfx_addr_h));
+    hal_write_reg((gk_u32 *)(gk_uintptr_t)ul_gfx_addr_h, get_high_addr(l_addr));
+}
+
+gk_void hal_gfx_set_gfx_stride(hal_disp_layer layer, gk_u16 pitch)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_gfx_stride gfx_stride;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_gfx_layer_return(layer);
+    addr_reg = vou_get_gfx_abs_addr(layer, (gk_ulong)(gk_uintptr_t)&(vo_reg->gfx_stride.u32));
+    gfx_stride.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t)addr_reg);
+    gfx_stride.bits.surface_stride = pitch;
+    hal_write_reg((gk_u32 *)(gk_uintptr_t)addr_reg, gfx_stride.u32);
+}
+
+gk_void hal_gfx_set_src_resolution(hal_disp_layer layer, gk_rect *rect)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    reg_gfx_src_reso gfx_src_reso;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_gfx_layer_return(layer);
+    addr_reg = vou_get_gfx_abs_addr(layer, (gk_ulong)(gk_uintptr_t)&(vo_reg->gfx_src_reso.u32));
+    gfx_src_reso.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t)addr_reg);
+    gfx_src_reso.bits.src_w = rect->width - 1;
+    gfx_src_reso.bits.src_h = rect->height - 1;
+    hal_write_reg((gk_u32 *)(gk_uintptr_t)addr_reg, gfx_src_reso.u32);
+}
+#endif
+
+#if VO_DESC("gfx")
+gk_void hal_gfx_set_pixel_alpha_range(hal_disp_layer layer, gk_u32 arange)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    reg_gfx_out_ctrl gfx_out_ctrl;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_gfx_layer_return(layer);
+    addr_reg = vou_get_gfx_abs_addr(layer, (gk_ulong)(gk_uintptr_t)&(vo_reg->gfx_out_ctrl.u32));
+    gfx_out_ctrl.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t)addr_reg);
+    gfx_out_ctrl.bits.palpha_range = arange;
+    hal_write_reg((gk_u32 *)(gk_uintptr_t)addr_reg, gfx_out_ctrl.u32);
+}
+#endif
+#endif /* #if VO_DESC("UBOOT_VO") */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/src/hal_vo_gfx_comm.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/hal_vo_gfx_comm.h
--- u-boot-2016.11/product/osd/vo/arch/comm/src/hal_vo_gfx_comm.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/hal_vo_gfx_comm.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __HAL_VO_GFX_COMM_H__
+#define __HAL_VO_GFX_COMM_H__
+
+#include "hal_vo_def.h"
+#include "drv_vo_coef_comm.h"
+#include "inner_vo.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#if VO_DESC("UBOOT_VO")
+#if VO_DESC("gfx uboot only")
+gk_void hal_gfx_set_layer_disp_rect(hal_disp_layer layer, gk_rect *rect);
+gk_void hal_gfx_set_layer_video_rect(hal_disp_layer layer, gk_rect *rect);
+gk_void hal_gfx_enable_layer(hal_disp_layer layer, gk_u32 enable);
+gk_void hal_gfx_set_layer_data_fmt(hal_disp_layer layer, hal_disp_pixel_format data_fmt);
+gk_void hal_gfx_set_layer_in_rect(hal_disp_layer layer, gk_rect *rect);
+gk_bool hal_gfx_set_reg_up(hal_disp_layer layer);
+gk_void hal_gfx_set_gfx_pre_mult(hal_disp_layer layer, gk_u32 enable);
+gk_void hal_gfx_set_gfx_addr(hal_disp_layer layer, gk_phys_addr_t l_addr);
+gk_void hal_gfx_set_gfx_stride(hal_disp_layer layer, gk_u16 pitch);
+gk_void hal_gfx_set_src_resolution(hal_disp_layer layer, gk_rect *rect);
+#endif
+
+#if VO_DESC("gfx")
+gk_void hal_gfx_set_pixel_alpha_range(hal_disp_layer layer, gk_u32 arange);
+#endif
+#endif /* #if VO_DESC("UBOOT_VO") */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* end of __HAL_VO_GFX_COMM_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/src/hal_vo_layer_comm.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/hal_vo_layer_comm.c
--- u-boot-2016.11/product/osd/vo/arch/comm/src/hal_vo_layer_comm.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/hal_vo_layer_comm.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,379 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "hal_vo_layer_comm.h"
+#include "drv_vo.h"
+#include "hal_vo.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#if VO_DESC("UBOOT_VO")
+#if VO_DESC("layer")
+gk_void hal_video_set_layer_alpha(hal_disp_layer layer, gk_u32 arange)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_v0_alpha v0_alpha;
+    volatile reg_g0_alpha g0_alpha;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_video_gfx_layer_return(layer);
+
+    if (vo_hal_is_video_layer(layer)) {
+        addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_alpha.u32));
+        v0_alpha.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+        v0_alpha.bits.vbk_alpha = arange;
+        hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_alpha.u32);
+        return;
+    }
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->g0_alpha.u32));
+    g0_alpha.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    g0_alpha.bits.vbk_alpha = arange;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, g0_alpha.u32);
+}
+
+gk_void hal_layer_csc_set_enable_ck_gt_en(hal_disp_layer layer, gk_bool csc_en, gk_bool ck_gt_en)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    reg_v0_vopp_csc_ctrl v0_vopp_csc_ctrl;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_video_gfx_layer_return(layer);
+
+    if (vo_hal_is_video_layer(layer)) {
+        addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_vopp_csc_ctrl.u32));
+    } else {
+        addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->g0_vopp_csc_ctrl.u32));
+    }
+
+    v0_vopp_csc_ctrl.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_vopp_csc_ctrl.bits.vopp_csc_en = csc_en;
+    v0_vopp_csc_ctrl.bits.vopp_csc_ck_gt_en = ck_gt_en;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_vopp_csc_ctrl.u32);
+}
+
+static gk_void hal_layer_csc_set_video_coef(hal_disp_layer layer, vdp_csc_coef *coef)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    reg_v0_vopp_csc_coef00 v0_vopp_csc_coef00;
+    reg_v0_vopp_csc_coef01 v0_vopp_csc_coef01;
+    reg_v0_vopp_csc_coef02 v0_vopp_csc_coef02;
+    reg_v0_vopp_csc_coef10 v0_vopp_csc_coef10;
+    reg_v0_vopp_csc_coef11 v0_vopp_csc_coef11;
+    reg_v0_vopp_csc_coef12 v0_vopp_csc_coef12;
+    reg_v0_vopp_csc_coef20 v0_vopp_csc_coef20;
+    reg_v0_vopp_csc_coef21 v0_vopp_csc_coef21;
+    reg_v0_vopp_csc_coef22 v0_vopp_csc_coef22;
+    volatile gk_ulong addr_reg;
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_vopp_csc_coef00.u32));
+    v0_vopp_csc_coef00.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_vopp_csc_coef00.bits.vopp_csc_coef00 = coef->csc_coef00;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_vopp_csc_coef00.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_vopp_csc_coef01.u32));
+    v0_vopp_csc_coef01.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_vopp_csc_coef01.bits.vopp_csc_coef01 = coef->csc_coef01;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_vopp_csc_coef01.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_vopp_csc_coef02.u32));
+    v0_vopp_csc_coef02.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_vopp_csc_coef02.bits.vopp_csc_coef02 = coef->csc_coef02;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_vopp_csc_coef02.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_vopp_csc_coef10.u32));
+    v0_vopp_csc_coef10.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_vopp_csc_coef10.bits.vopp_csc_coef10 = coef->csc_coef10;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_vopp_csc_coef10.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_vopp_csc_coef11.u32));
+    v0_vopp_csc_coef11.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_vopp_csc_coef11.bits.vopp_csc_coef11 = coef->csc_coef11;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_vopp_csc_coef11.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_vopp_csc_coef12.u32));
+    v0_vopp_csc_coef12.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_vopp_csc_coef12.bits.vopp_csc_coef12 = coef->csc_coef12;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_vopp_csc_coef12.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_vopp_csc_coef20.u32));
+    v0_vopp_csc_coef20.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_vopp_csc_coef20.bits.vopp_csc_coef20 = coef->csc_coef20;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_vopp_csc_coef20.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_vopp_csc_coef21.u32));
+    v0_vopp_csc_coef21.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_vopp_csc_coef21.bits.vopp_csc_coef21 = coef->csc_coef21;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_vopp_csc_coef21.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_vopp_csc_coef22.u32));
+    v0_vopp_csc_coef22.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_vopp_csc_coef22.bits.vopp_csc_coef22 = coef->csc_coef22;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_vopp_csc_coef22.u32);
+}
+
+static gk_void hal_layer_csc_set_gfx_coef(hal_disp_layer layer, vdp_csc_coef *coef)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    reg_v0_vopp_csc_coef00 g0_vopp_csc_coef00;
+    reg_v0_vopp_csc_coef01 g0_vopp_csc_coef01;
+    reg_v0_vopp_csc_coef02 g0_vopp_csc_coef02;
+    reg_v0_vopp_csc_coef10 g0_vopp_csc_coef10;
+    reg_v0_vopp_csc_coef11 g0_vopp_csc_coef11;
+    reg_v0_vopp_csc_coef12 g0_vopp_csc_coef12;
+    reg_v0_vopp_csc_coef20 g0_vopp_csc_coef20;
+    reg_v0_vopp_csc_coef21 g0_vopp_csc_coef21;
+    reg_v0_vopp_csc_coef22 g0_vopp_csc_coef22;
+    volatile gk_ulong addr_reg;
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->g0_vopp_csc_coef00.u32));
+    g0_vopp_csc_coef00.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    g0_vopp_csc_coef00.bits.vopp_csc_coef00 = coef->csc_coef00;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, g0_vopp_csc_coef00.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->g0_vopp_csc_coef01.u32));
+    g0_vopp_csc_coef01.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    g0_vopp_csc_coef01.bits.vopp_csc_coef01 = coef->csc_coef01;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, g0_vopp_csc_coef01.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->g0_vopp_csc_coef02.u32));
+    g0_vopp_csc_coef02.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    g0_vopp_csc_coef02.bits.vopp_csc_coef02 = coef->csc_coef02;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, g0_vopp_csc_coef02.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->g0_vopp_csc_coef10.u32));
+    g0_vopp_csc_coef10.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    g0_vopp_csc_coef10.bits.vopp_csc_coef10 = coef->csc_coef10;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, g0_vopp_csc_coef10.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->g0_vopp_csc_coef11.u32));
+    g0_vopp_csc_coef11.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    g0_vopp_csc_coef11.bits.vopp_csc_coef11 = coef->csc_coef11;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, g0_vopp_csc_coef11.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->g0_vopp_csc_coef12.u32));
+    g0_vopp_csc_coef12.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    g0_vopp_csc_coef12.bits.vopp_csc_coef12 = coef->csc_coef12;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, g0_vopp_csc_coef12.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->g0_vopp_csc_coef20.u32));
+    g0_vopp_csc_coef20.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    g0_vopp_csc_coef20.bits.vopp_csc_coef20 = coef->csc_coef20;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, g0_vopp_csc_coef20.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->g0_vopp_csc_coef21.u32));
+    g0_vopp_csc_coef21.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    g0_vopp_csc_coef21.bits.vopp_csc_coef21 = coef->csc_coef21;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, g0_vopp_csc_coef21.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->g0_vopp_csc_coef22.u32));
+    g0_vopp_csc_coef22.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    g0_vopp_csc_coef22.bits.vopp_csc_coef22 = coef->csc_coef22;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, g0_vopp_csc_coef22.u32);
+}
+
+static gk_void hal_layer_csc_set_video_dc_coef(hal_disp_layer layer, vdp_csc_dc_coef *csc_dc_coef)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    reg_v0_vopp_csc_idc0 v0_vopp_csc_idc0;
+    reg_v0_vopp_csc_idc1 v0_vopp_csc_idc1;
+    reg_v0_vopp_csc_idc2 v0_vopp_csc_idc2;
+    reg_v0_vopp_csc_odc0 v0_vopp_csc_odc0;
+    reg_v0_vopp_csc_odc1 v0_vopp_csc_odc1;
+    reg_v0_vopp_csc_odc2 v0_vopp_csc_odc2;
+    volatile gk_ulong addr_reg;
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_vopp_csc_idc0.u32));
+    v0_vopp_csc_idc0.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_vopp_csc_idc0.bits.vopp_csc_idc0 = csc_dc_coef->csc_in_dc0;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_vopp_csc_idc0.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_vopp_csc_idc1.u32));
+    v0_vopp_csc_idc1.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_vopp_csc_idc1.bits.vopp_csc_idc1 = csc_dc_coef->csc_in_dc1;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_vopp_csc_idc1.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_vopp_csc_idc2.u32));
+    v0_vopp_csc_idc2.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_vopp_csc_idc2.bits.vopp_csc_idc2 = csc_dc_coef->csc_in_dc2;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_vopp_csc_idc2.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_vopp_csc_odc0.u32));
+    v0_vopp_csc_odc0.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_vopp_csc_odc0.bits.vopp_csc_odc0 = csc_dc_coef->csc_out_dc0;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_vopp_csc_odc0.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_vopp_csc_odc1.u32));
+    v0_vopp_csc_odc1.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_vopp_csc_odc1.bits.vopp_csc_odc1 = csc_dc_coef->csc_out_dc1;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_vopp_csc_odc1.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_vopp_csc_odc2.u32));
+    v0_vopp_csc_odc2.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_vopp_csc_odc2.bits.vopp_csc_odc2 = csc_dc_coef->csc_out_dc2;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_vopp_csc_odc2.u32);
+}
+
+static gk_void hal_layer_csc_set_gfx_dc_coef(hal_disp_layer layer, vdp_csc_dc_coef *csc_dc_coef)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    reg_v0_vopp_csc_idc0 g0_vopp_csc_idc0;
+    reg_v0_vopp_csc_idc1 g0_vopp_csc_idc1;
+    reg_v0_vopp_csc_idc2 g0_vopp_csc_idc2;
+    reg_v0_vopp_csc_odc0 g0_vopp_csc_odc0;
+    reg_v0_vopp_csc_odc1 g0_vopp_csc_odc1;
+    reg_v0_vopp_csc_odc2 g0_vopp_csc_odc2;
+    volatile gk_ulong addr_reg;
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->g0_vopp_csc_idc0.u32));
+    g0_vopp_csc_idc0.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    g0_vopp_csc_idc0.bits.vopp_csc_idc0 = csc_dc_coef->csc_in_dc0;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, g0_vopp_csc_idc0.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->g0_vopp_csc_idc1.u32));
+    g0_vopp_csc_idc1.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    g0_vopp_csc_idc1.bits.vopp_csc_idc1 = csc_dc_coef->csc_in_dc1;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, g0_vopp_csc_idc1.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->g0_vopp_csc_idc2.u32));
+    g0_vopp_csc_idc2.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    g0_vopp_csc_idc2.bits.vopp_csc_idc2 = csc_dc_coef->csc_in_dc2;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, g0_vopp_csc_idc2.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->g0_vopp_csc_odc0.u32));
+    g0_vopp_csc_odc0.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    g0_vopp_csc_odc0.bits.vopp_csc_odc0 = csc_dc_coef->csc_out_dc0;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, g0_vopp_csc_odc0.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->g0_vopp_csc_odc1.u32));
+    g0_vopp_csc_odc1.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    g0_vopp_csc_odc1.bits.vopp_csc_odc1 = csc_dc_coef->csc_out_dc1;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, g0_vopp_csc_odc1.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->g0_vopp_csc_odc2.u32));
+    g0_vopp_csc_odc2.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    g0_vopp_csc_odc2.bits.vopp_csc_odc2 = csc_dc_coef->csc_out_dc2;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, g0_vopp_csc_odc2.u32);
+}
+
+static gk_void hal_layer_csc_set_video_param(hal_disp_layer layer, csc_coef_param *csc_param)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    reg_v0_vopp_csc_scale v0_vopp_csc_scale;
+    reg_v0_vopp_csc_min_y v0_vopp_csc_min_y;
+    reg_v0_vopp_csc_min_c v0_vopp_csc_min_c;
+    reg_v0_vopp_csc_max_y v0_vopp_csc_max_y;
+    reg_v0_vopp_csc_max_c v0_vopp_csc_max_c;
+    volatile gk_ulong addr_reg;
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_vopp_csc_scale.u32));
+    v0_vopp_csc_scale.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_vopp_csc_scale.bits.vopp_csc_scale = csc_param->csc_scale2p;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_vopp_csc_scale.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_vopp_csc_min_y.u32));
+    v0_vopp_csc_min_y.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_vopp_csc_min_y.bits.vopp_csc_min_y = csc_param->csc_clip_min;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_vopp_csc_min_y.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_vopp_csc_min_c.u32));
+    v0_vopp_csc_min_c.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_vopp_csc_min_c.bits.vopp_csc_min_c = csc_param->csc_clip_min;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_vopp_csc_min_c.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_vopp_csc_max_y.u32));
+    v0_vopp_csc_max_y.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_vopp_csc_max_y.bits.vopp_csc_max_y = csc_param->csc_clip_max;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_vopp_csc_max_y.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_vopp_csc_max_c.u32));
+    v0_vopp_csc_max_c.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_vopp_csc_max_c.bits.vopp_csc_max_c = csc_param->csc_clip_max;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_vopp_csc_max_c.u32);
+}
+
+static gk_void hal_layer_csc_set_gfx_param(hal_disp_layer layer, csc_coef_param *csc_param)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    reg_v0_vopp_csc_scale g0_vopp_csc_scale;
+    reg_v0_vopp_csc_min_y g0_vopp_csc_min_y;
+    reg_v0_vopp_csc_min_c g0_vopp_csc_min_c;
+    reg_v0_vopp_csc_max_y g0_vopp_csc_max_y;
+    reg_v0_vopp_csc_max_c g0_vopp_csc_max_c;
+    volatile gk_ulong addr_reg;
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->g0_vopp_csc_scale.u32));
+    g0_vopp_csc_scale.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    g0_vopp_csc_scale.bits.vopp_csc_scale = csc_param->csc_scale2p;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, g0_vopp_csc_scale.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->g0_vopp_csc_min_y.u32));
+    g0_vopp_csc_min_y.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    g0_vopp_csc_min_y.bits.vopp_csc_min_y = csc_param->csc_clip_min;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, g0_vopp_csc_min_y.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->g0_vopp_csc_min_c.u32));
+    g0_vopp_csc_min_c.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    g0_vopp_csc_min_c.bits.vopp_csc_min_c = csc_param->csc_clip_min;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, g0_vopp_csc_min_c.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->g0_vopp_csc_max_y.u32));
+    g0_vopp_csc_max_y.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    g0_vopp_csc_max_y.bits.vopp_csc_max_y = csc_param->csc_clip_max;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, g0_vopp_csc_max_y.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->g0_vopp_csc_max_c.u32));
+    g0_vopp_csc_max_c.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    g0_vopp_csc_max_c.bits.vopp_csc_max_c = csc_param->csc_clip_max;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, g0_vopp_csc_max_c.u32);
+}
+
+gk_void hal_layer_set_csc_coef(hal_disp_layer layer, csc_coef *coef)
+{
+    if (vo_hal_is_video_layer(layer)) {
+        hal_layer_csc_set_video_dc_coef(layer, (vdp_csc_dc_coef *)(&coef->csc_in_dc0));
+        hal_layer_csc_set_video_coef(layer, (vdp_csc_coef *)(&coef->csc_coef00));
+        hal_layer_csc_set_video_param(layer, (csc_coef_param *)(&coef->new_csc_scale2p));
+        return;
+    }
+
+    hal_layer_csc_set_gfx_dc_coef(layer, (vdp_csc_dc_coef *)(&coef->csc_in_dc0));
+    hal_layer_csc_set_gfx_coef(layer, (vdp_csc_coef *)(&coef->csc_coef00));
+    hal_layer_csc_set_gfx_param(layer, (csc_coef_param *)(&coef->new_csc_scale2p));
+}
+
+gk_void hal_layer_set_layer_global_alpha(hal_disp_layer layer, gk_u8 alpha0)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_v0_ctrl v0_ctrl;
+    volatile reg_g0_ctrl g0_ctrl;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_video_gfx_layer_return(layer);
+
+    if (vo_hal_is_video_layer(layer)) {
+        addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_ctrl.u32));
+        v0_ctrl.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+        v0_ctrl.bits.galpha = alpha0;
+        hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_ctrl.u32);
+        return;
+    }
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->g0_ctrl.u32));
+    g0_ctrl.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    g0_ctrl.bits.galpha = alpha0;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, g0_ctrl.u32);
+}
+#endif
+#endif /* #if VO_DESC("UBOOT_VO") */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/src/hal_vo_layer_comm.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/hal_vo_layer_comm.h
--- u-boot-2016.11/product/osd/vo/arch/comm/src/hal_vo_layer_comm.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/hal_vo_layer_comm.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __HAL_VO_LAYER_COMM_H__
+#define __HAL_VO_LAYER_COMM_H__
+
+#include "hal_vo_def.h"
+#include "drv_vo_coef_comm.h"
+#include "inner_vo.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#if VO_DESC("UBOOT_VO")
+#if VO_DESC("layer")
+gk_void hal_video_set_layer_alpha(hal_disp_layer layer, gk_u32 arange);
+gk_void hal_layer_set_csc_coef(hal_disp_layer layer, csc_coef *coef);
+gk_void hal_layer_set_layer_global_alpha(hal_disp_layer layer, gk_u8 alpha0);
+gk_void hal_layer_csc_set_enable_ck_gt_en(hal_disp_layer layer, gk_bool csc_en, gk_bool ck_gt_en);
+#endif
+#endif /* #if VO_DESC("UBOOT_VO") */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* end of __HAL_VO_LAYER_COMM_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/src/hal_vo_reg_comm.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/hal_vo_reg_comm.h
--- u-boot-2016.11/product/osd/vo/arch/comm/src/hal_vo_reg_comm.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/hal_vo_reg_comm.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __HAL_VO_COMM_REG_H__
+#define __HAL_VO_COMM_REG_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* __VOU_REG_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/src/hal_vo_video_comm.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/hal_vo_video_comm.c
--- u-boot-2016.11/product/osd/vo/arch/comm/src/hal_vo_video_comm.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/hal_vo_video_comm.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,831 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#include "hal_vo_video_comm.h"
+#include "drv_vo.h"
+#include "hal_vo.h"
+#include "math.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+#if VO_DESC("UBOOT_VO")
+
+#if VO_DESC("video")
+
+gk_void hal_video_set_layer_up_mode(hal_disp_layer layer, gk_u32 up_mode)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    reg_v0_ctrl v0_ctrl;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_video_layer_return(layer);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_ctrl.u32));
+    v0_ctrl.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_ctrl.bits.rgup_mode = up_mode;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_ctrl.u32);
+}
+
+gk_void hal_video_set_layer_disp_rect(hal_disp_layer layer, gk_rect *rect)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_v0_dfpos v0_dfpos;
+    volatile reg_v0_dlpos v0_dlpos;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_video_layer_return(layer);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_dfpos.u32));
+    v0_dfpos.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_dfpos.bits.disp_xfpos = rect->x;
+    v0_dfpos.bits.disp_yfpos = rect->y;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_dfpos.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_dlpos.u32));
+    v0_dlpos.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_dlpos.bits.disp_xlpos = rect->x + rect->width - 1;
+    v0_dlpos.bits.disp_ylpos = rect->y + rect->height - 1;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_dlpos.u32);
+}
+
+gk_void hal_video_set_layer_video_rect(hal_disp_layer layer, gk_rect *rect)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_v0_vfpos v0_vfpos;
+    volatile reg_v0_vlpos v0_vlpos;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_video_layer_return(layer);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_vfpos.u32));
+    v0_vfpos.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_vfpos.bits.video_xfpos = rect->x;
+    v0_vfpos.bits.video_yfpos = rect->y;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_vfpos.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_vlpos.u32));
+    v0_vlpos.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_vlpos.bits.video_xlpos = rect->x + rect->width - 1;
+    v0_vlpos.bits.video_ylpos = rect->y + rect->height - 1;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_vlpos.u32);
+}
+
+gk_void hal_video_set_multi_area_lum_addr(hal_disp_layer layer, gk_u32 area_num, gk_ulong addr,
+    gk_u16 stride)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    gk_ulong reg_addr;
+    reg_vid_stride vid_stride;
+
+    vo_hal_check_video_layer_return(layer);
+
+    /* low 32 bits to vid_addr_l */
+    reg_addr = vou_get_vid_abs_addr(layer, (gk_uintptr_t) & (vo_reg->vid_addr_l));
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) reg_addr, get_low_addr(addr));
+
+    /* high 32 bits to vid_addr_h */
+    reg_addr = vou_get_vid_abs_addr(layer, (gk_uintptr_t) & (vo_reg->vid_addr_h));
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) reg_addr, get_high_addr(addr));
+
+    reg_addr = vou_get_vid_abs_addr(layer, (gk_uintptr_t) & (vo_reg->vid_stride.u32));
+    vid_stride.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) reg_addr);
+    vid_stride.bits.lm_stride = stride;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) reg_addr, vid_stride.u32);
+}
+
+gk_void hal_video_set_multi_area_chm_addr(hal_disp_layer layer, gk_u32 area_num, gk_ulong addr,
+    gk_u16 stride)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    gk_ulong reg_addr;
+    reg_vid_stride vid_stride;
+
+    vo_hal_check_video_layer_return(layer);
+
+    /* low 32 bits to vid_caddr_l */
+    reg_addr = vou_get_vid_abs_addr(layer, (gk_uintptr_t) & (vo_reg->vid_caddr_l));
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) reg_addr, get_low_addr(addr));
+
+    /* high 32 bits to vid_caddr_h */
+    reg_addr = vou_get_vid_abs_addr(layer, (gk_uintptr_t) & (vo_reg->vid_caddr_h));
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) reg_addr, get_high_addr(addr));
+
+    reg_addr = vou_get_vid_abs_addr(layer, (gk_uintptr_t) & (vo_reg->vid_stride.u32));
+    vid_stride.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) reg_addr);
+    vid_stride.bits.chm_stride = stride;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) reg_addr, vid_stride.u32);
+}
+
+static gk_void hal_layer_set_layer_zme_info(hal_disp_layer layer, gk_u32 width, gk_u32 height,
+    hal_disp_zme_outfmt zme_out_fmt)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_v0_zme_vinfo v0_zme_vinfo;
+    volatile reg_v0_zme_hinfo v0_zme_hinfo;
+    volatile reg_v1_cvfir_vinfo v1_cvfir_vinfo;
+    volatile reg_v2_cvfir_vinfo v2_cvfir_vinfo;
+    volatile gk_ulong addr_reg;
+
+    if (layer == HAL_DISP_LAYER_VHD0) {
+        addr_reg = (gk_ulong)(gk_uintptr_t) & (vo_reg->v0_zme_vinfo.u32);
+        v0_zme_vinfo.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+        v0_zme_vinfo.bits.vzme_ck_gt_en = 1;
+        v0_zme_vinfo.bits.out_height = height - 1;
+        v0_zme_vinfo.bits.out_fmt = zme_out_fmt;
+        hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_zme_vinfo.u32);
+
+        addr_reg = (gk_ulong)(gk_uintptr_t) & (vo_reg->v0_zme_hinfo.u32);
+        v0_zme_hinfo.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+        v0_zme_hinfo.bits.out_width = width - 1;
+        hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_zme_hinfo.u32);
+    } else if (layer == HAL_DISP_LAYER_VHD1) {
+        /* vertical info */
+        addr_reg = (gk_ulong)(gk_uintptr_t) & (vo_reg->v1_cvfir_vinfo.u32);
+        v1_cvfir_vinfo.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+        v1_cvfir_vinfo.bits.vzme_ck_gt_en = 1;
+        v1_cvfir_vinfo.bits.out_height = height - 1;
+        v1_cvfir_vinfo.bits.out_fmt = zme_out_fmt;
+        hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v1_cvfir_vinfo.u32);
+    } else if (layer == HAL_DISP_LAYER_VHD2) {
+        /* vertical info */
+        addr_reg = (gk_ulong)(gk_uintptr_t) & (vo_reg->v2_cvfir_vinfo.u32);
+        v2_cvfir_vinfo.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+        v2_cvfir_vinfo.bits.vzme_ck_gt_en = 1;
+        v2_cvfir_vinfo.bits.out_height = height - 1;
+        v2_cvfir_vinfo.bits.out_fmt = zme_out_fmt;
+        hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v2_cvfir_vinfo.u32);
+    }
+}
+
+gk_void hal_layer_set_zme_info(hal_disp_layer layer, gk_u32 width, gk_u32 height,
+                               hal_disp_zme_outfmt zme_out_fmt)
+{
+    if (vo_hal_is_video_layer(layer)) {
+        hal_layer_set_layer_zme_info(layer, width, height, zme_out_fmt);
+    }
+}
+
+gk_void hal_layer_enable_layer(hal_disp_layer layer, gk_u32 enable)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_v0_ctrl v0_ctrl;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_video_layer_return(layer);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_ctrl.u32));
+    v0_ctrl.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_ctrl.bits.surface_en = enable;
+    v0_ctrl.bits.nosec_flag = 1;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_ctrl.u32);
+}
+
+gk_void hal_layer_set_layer_data_fmt(hal_disp_layer layer, hal_disp_pixel_format data_fmt)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_vid_src_info vid_src_info;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_video_layer_return(layer);
+
+    addr_reg = vou_get_vid_abs_addr(layer, (gk_uintptr_t) & (vo_reg->vid_src_info.u32));
+    vid_src_info.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    vid_src_info.bits.data_type = data_fmt;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, vid_src_info.u32);
+}
+
+gk_void hal_layer_set_src_resolution(hal_disp_layer layer, const gk_rect *rect)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    reg_vid_src_reso vid_src_reso;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_video_layer_return(layer);
+
+    addr_reg = vou_get_vid_abs_addr(layer, (gk_uintptr_t) & (vo_reg->vid_src_reso.u32));
+    vid_src_reso.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    vid_src_reso.bits.src_w = rect->width - 1;
+    vid_src_reso.bits.src_h = rect->height - 1;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, vid_src_reso.u32);
+}
+
+#if VO_DESC("layer zme")
+static gk_void vo_hal_layer_set_zme_vinfo_basic_cfg(hal_disp_layer layer, gk_u32 vratio,
+    vo_v0_zme_cfg *cfg, vo_zme_comm_pq_cfg *pq_cfg)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_v0_zme_vinfo v0_zme_vinfo;
+    volatile reg_v0_zme_vsp v0_zme_vsp;
+    volatile reg_v0_zme_voffset v0_zme_voffset;
+    volatile reg_v0_zme_vboffset v0_zme_vboffset;
+
+    v0_zme_vinfo.u32 = vo_reg->v0_zme_vinfo.u32;
+    v0_zme_vsp.u32 = vo_reg->v0_zme_vsp.u32;
+    v0_zme_voffset.u32 = vo_reg->v0_zme_voffset.u32;
+    v0_zme_vboffset.u32 = vo_reg->v0_zme_vboffset.u32;
+
+    v0_zme_vinfo.bits.out_height = cfg->out_height - 1;
+    v0_zme_vinfo.bits.out_fmt = cfg->out_fmt;
+    v0_zme_vinfo.bits.out_pro = cfg->out_pro;
+    v0_zme_vinfo.bits.vzme_ck_gt_en = cfg->ck_gt_en;
+    v0_zme_vsp.bits.vratio = vratio;
+    v0_zme_vsp.bits.graphdet_en = cfg->graphdet_en;
+    v0_zme_vsp.bits.cvfir_mode = cfg->cvfir_mode;
+    v0_zme_vsp.bits.lvfir_mode = cfg->lvfir_mode;
+    v0_zme_vsp.bits.vfir_1tap_en = cfg->vfir_1tap_en;
+    v0_zme_vsp.bits.cvmid_en = cfg->cvmid_en;
+    v0_zme_vsp.bits.lvmid_en = cfg->lvmid_en;
+    v0_zme_vsp.bits.cvfir_en = cfg->cvfir_en;
+    v0_zme_vsp.bits.lvfir_en = cfg->lvfir_en;
+    v0_zme_voffset.bits.vchroma_offset = pq_cfg->vchroma_offset;
+    v0_zme_voffset.bits.vluma_offset = pq_cfg->vluma_offset;
+    v0_zme_vboffset.bits.vbchroma_offset = pq_cfg->vbchroma_offset;
+    v0_zme_vboffset.bits.vbluma_offset = pq_cfg->vbluma_offset;
+
+    vo_reg->v0_zme_vinfo.u32 = v0_zme_vinfo.u32 ;
+    vo_reg->v0_zme_vsp.u32 = v0_zme_vsp.u32;
+    vo_reg->v0_zme_voffset.u32 = v0_zme_voffset.u32;
+    vo_reg->v0_zme_vboffset.u32 = v0_zme_vboffset.u32;
+}
+
+static gk_void vo_hal_layer_set_zme_vinfo_ext_cfg(hal_disp_layer layer, vo_v0_zme_cfg *cfg,
+    vo_zme_comm_pq_cfg *pq_cfg)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_v0_zme_vl_shootctrl v0_zme_vl_shootctrl;
+    volatile reg_v0_zme_vc_shootctrl v0_zme_vc_shootctrl;
+
+    v0_zme_vl_shootctrl.u32 = vo_reg->v0_zme_vl_shootctrl.u32;
+    v0_zme_vc_shootctrl.u32 = vo_reg->v0_zme_vc_shootctrl.u32;
+
+    v0_zme_vl_shootctrl.bits.vl_coring = pq_cfg->vl_coring;
+    v0_zme_vl_shootctrl.bits.vl_gain = pq_cfg->vl_gain;
+    v0_zme_vl_shootctrl.bits.vl_coringadj_en = pq_cfg->vl_coringadj_en;
+    v0_zme_vl_shootctrl.bits.vl_flatdect_mode = pq_cfg->vl_flatdect_mode;
+    v0_zme_vl_shootctrl.bits.vl_shootctrl_mode = cfg->vl_shootctrl_mode;
+    v0_zme_vl_shootctrl.bits.vl_shootctrl_en = cfg->vl_shootctrl_en;
+    v0_zme_vc_shootctrl.bits.vc_coring = pq_cfg->vc_coring;
+    v0_zme_vc_shootctrl.bits.vc_gain = pq_cfg->vc_gain;
+    v0_zme_vc_shootctrl.bits.vc_coringadj_en = pq_cfg->vc_coringadj_en;
+    v0_zme_vc_shootctrl.bits.vc_flatdect_mode = pq_cfg->vc_flatdect_mode;
+    v0_zme_vc_shootctrl.bits.vc_shootctrl_mode = cfg->vc_shootctrl_mode;
+    v0_zme_vc_shootctrl.bits.vc_shootctrl_en = cfg->vc_shootctrl_en;
+
+    vo_reg->v0_zme_vl_shootctrl.u32 = v0_zme_vl_shootctrl.u32;
+    vo_reg->v0_zme_vc_shootctrl.u32 = v0_zme_vc_shootctrl.u32;
+}
+
+static gk_void vo_hal_layer_set_zme_hinfo_basic_cfg(hal_disp_layer layer, gk_u32 hratio,
+    vo_v0_zme_cfg *cfg, vo_zme_comm_pq_cfg *pq_cfg)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_v0_zme_hinfo v0_zme_hinfo;
+    volatile reg_v0_zme_hsp v0_zme_hsp;
+    volatile reg_v0_zme_hloffset v0_zme_hloffset;
+    volatile reg_v0_zme_hcoffset v0_zme_hcoffset;
+
+    v0_zme_hinfo.u32 = vo_reg->v0_zme_hinfo.u32;
+    v0_zme_hsp.u32 = vo_reg->v0_zme_hsp.u32;
+    v0_zme_hloffset.u32 = vo_reg->v0_zme_hloffset.u32;
+    v0_zme_hcoffset.u32 = vo_reg->v0_zme_hcoffset.u32;
+
+    v0_zme_hinfo.bits.out_width = cfg->out_width - 1;
+    v0_zme_hinfo.bits.hzme_ck_gt_en = cfg->ck_gt_en;
+    v0_zme_hsp.bits.hratio = hratio;
+    v0_zme_hsp.bits.hfir_order = cfg->hfir_order;
+    v0_zme_hsp.bits.chfir_mode = cfg->chfir_mode;
+    v0_zme_hsp.bits.lhfir_mode = cfg->lhfir_mode;
+    v0_zme_hsp.bits.non_lnr_en = cfg->non_lnr_en;
+    v0_zme_hsp.bits.chmid_en = cfg->chmid_en;
+    v0_zme_hsp.bits.lhmid_en = cfg->lhmid_en;
+    v0_zme_hsp.bits.chfir_en = cfg->chfir_en;
+    v0_zme_hsp.bits.lhfir_en = cfg->lhfir_en;
+    v0_zme_hloffset.bits.lhfir_offset = pq_cfg->lhfir_offset;
+    v0_zme_hcoffset.bits.chfir_offset = pq_cfg->chfir_offset;
+
+    vo_reg->v0_zme_hinfo.u32 = v0_zme_hinfo.u32;
+    vo_reg->v0_zme_hsp.u32 = v0_zme_hsp.u32;
+    vo_reg->v0_zme_hloffset.u32 = v0_zme_hloffset.u32;
+    vo_reg->v0_zme_hcoffset.u32 = v0_zme_hcoffset.u32;
+}
+
+static gk_void vo_hal_layer_set_zme_hinfo_ext_cfg(hal_disp_layer layer, vo_v0_zme_cfg *cfg,
+    vo_zme_comm_pq_cfg *pq_cfg)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_v0_zme_hzone0delta v0_zme_hzone0delta;
+    volatile reg_v0_zme_hzone2delta v0_zme_hzone2delta;
+    volatile reg_v0_zme_hzoneend v0_zme_hzoneend;
+    volatile reg_v0_zme_hl_shootctrl v0_zme_hl_shootctrl;
+    volatile reg_v0_zme_hc_shootctrl v0_zme_hc_shootctrl;
+
+    v0_zme_hzone0delta.u32 = vo_reg->v0_zme_hzone0delta.u32;
+    v0_zme_hzone2delta.u32 = vo_reg->v0_zme_hzone2delta.u32;
+    v0_zme_hzoneend.u32 = vo_reg->v0_zme_hzoneend.u32;
+    v0_zme_hl_shootctrl.u32 = vo_reg->v0_zme_hl_shootctrl.u32;
+    v0_zme_hc_shootctrl.u32 = vo_reg->v0_zme_hc_shootctrl.u32;
+
+    v0_zme_hzone0delta.bits.zone0_delta = 0;
+    v0_zme_hzone2delta.bits.zone2_delta = 0;
+    v0_zme_hzoneend.bits.zone0_end = 0;
+    v0_zme_hzoneend.bits.zone1_end = 0;
+    v0_zme_hl_shootctrl.bits.hl_coring = pq_cfg->hl_coring;
+    v0_zme_hl_shootctrl.bits.hl_gain = pq_cfg->hl_gain;
+    v0_zme_hl_shootctrl.bits.hl_coringadj_en = pq_cfg->hl_coringadj_en;
+    v0_zme_hl_shootctrl.bits.hl_flatdect_mode = pq_cfg->hl_flatdect_mode;
+    v0_zme_hl_shootctrl.bits.hl_shootctrl_mode = cfg->hl_shootctrl_mode;
+    v0_zme_hl_shootctrl.bits.hl_shootctrl_en = cfg->hl_shootctrl_en;
+    v0_zme_hc_shootctrl.bits.hc_coring = pq_cfg->hc_coring;
+    v0_zme_hc_shootctrl.bits.hc_gain = pq_cfg->hc_gain;
+    v0_zme_hc_shootctrl.bits.hc_coringadj_en = pq_cfg->hc_coringadj_en;
+    v0_zme_hc_shootctrl.bits.hc_flatdect_mode = pq_cfg->hc_flatdect_mode;
+    v0_zme_hc_shootctrl.bits.hc_shootctrl_mode = cfg->hc_shootctrl_mode;
+    v0_zme_hc_shootctrl.bits.hc_shootctrl_en = cfg->hc_shootctrl_en;
+
+    vo_reg->v0_zme_hzone0delta.u32 = v0_zme_hzone0delta.u32;
+    vo_reg->v0_zme_hzone2delta.u32 = v0_zme_hzone2delta.u32;
+    vo_reg->v0_zme_hzoneend.u32 = v0_zme_hzoneend.u32;
+    vo_reg->v0_zme_hl_shootctrl.u32 = v0_zme_hl_shootctrl.u32;
+    vo_reg->v0_zme_hc_shootctrl.u32 = v0_zme_hc_shootctrl.u32;
+}
+
+gk_void vo_hal_layer_set_zme_cfg(hal_disp_layer layer, gk_u32 vratio, gk_u32 hratio,
+    vo_v0_zme_cfg *cfg, vo_zme_comm_pq_cfg *pq_cfg)
+{
+    vo_hal_layer_set_zme_vinfo_basic_cfg(layer, vratio, cfg, pq_cfg);
+    vo_hal_layer_set_zme_vinfo_ext_cfg(layer, cfg, pq_cfg);
+    vo_hal_layer_set_zme_hinfo_basic_cfg(layer, hratio, cfg, pq_cfg);
+    vo_hal_layer_set_zme_hinfo_ext_cfg(layer, cfg, pq_cfg);
+}
+
+#endif
+
+#if VO_DESC("layer cvfir")
+gk_void vo_hal_layer_set_v1_cvfir_cfg(gk_u32 vratio, vdp_v1_cvfir_cfg *cfg,
+    vo_zme_comm_pq_cfg *pq_cfg)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_v1_cvfir_vinfo v1_cvfir_vinfo;
+    volatile reg_v1_cvfir_vsp v1_cvfir_vsp;
+    volatile reg_v1_cvfir_voffset v1_cvfir_voffset;
+    volatile reg_v1_cvfir_vboffset v1_cvfir_vboffset;
+    volatile gk_ulong addr_reg;
+
+    addr_reg = (gk_ulong)(gk_uintptr_t) & (vo_reg->v1_cvfir_vinfo.u32);
+    v1_cvfir_vinfo.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v1_cvfir_vinfo.bits.out_height = cfg->out_height - 1;
+    v1_cvfir_vinfo.bits.out_fmt = cfg->out_fmt;
+    v1_cvfir_vinfo.bits.out_pro = cfg->out_pro;
+    v1_cvfir_vinfo.bits.vzme_ck_gt_en = cfg->ck_gt_en;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v1_cvfir_vinfo.u32);
+
+    addr_reg = (gk_ulong)(gk_uintptr_t) & (vo_reg->v1_cvfir_vsp.u32);
+    v1_cvfir_vsp.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v1_cvfir_vsp.bits.vratio = vratio;
+    v1_cvfir_vsp.bits.cvfir_mode = cfg->cvfir_mode;
+    v1_cvfir_vsp.bits.cvmid_en = cfg->cvmid_en;
+    v1_cvfir_vsp.bits.cvfir_en = cfg->cvfir_en;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v1_cvfir_vsp.u32);
+
+    addr_reg = (gk_ulong)(gk_uintptr_t) & (vo_reg->v1_cvfir_voffset.u32);
+    v1_cvfir_voffset.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v1_cvfir_voffset.bits.vchroma_offset = pq_cfg->vchroma_offset;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v1_cvfir_voffset.u32);
+
+    addr_reg = (gk_ulong)(gk_uintptr_t) & (vo_reg->v1_cvfir_vboffset.u32);
+    v1_cvfir_vboffset.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v1_cvfir_vboffset.bits.vbchroma_offset = pq_cfg->vbchroma_offset;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v1_cvfir_vboffset.u32);
+}
+
+gk_void vo_hal_layer_set_v2_cvfir_cfg(gk_u32 vratio, vdp_v1_cvfir_cfg *cfg,
+    vo_zme_comm_pq_cfg *pq_cfg)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_v2_cvfir_vinfo v2_cvfir_vinfo;
+    volatile reg_v2_cvfir_vsp v2_cvfir_vsp;
+    volatile reg_v2_cvfir_voffset v2_cvfir_voffset;
+    volatile reg_v2_cvfir_vboffset v2_cvfir_vboffset;
+    volatile gk_ulong addr_reg;
+
+    addr_reg = (gk_ulong)(gk_uintptr_t) & (vo_reg->v2_cvfir_vinfo.u32);
+    v2_cvfir_vinfo.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v2_cvfir_vinfo.bits.out_height = cfg->out_height - 1;
+    v2_cvfir_vinfo.bits.out_fmt = cfg->out_fmt;
+    v2_cvfir_vinfo.bits.out_pro = cfg->out_pro;
+    v2_cvfir_vinfo.bits.vzme_ck_gt_en = cfg->ck_gt_en;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v2_cvfir_vinfo.u32);
+
+    addr_reg = (gk_ulong)(gk_uintptr_t) & (vo_reg->v2_cvfir_vsp.u32);
+    v2_cvfir_vsp.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v2_cvfir_vsp.bits.vratio = vratio;
+    v2_cvfir_vsp.bits.cvfir_mode = cfg->cvfir_mode;
+    v2_cvfir_vsp.bits.cvmid_en = cfg->cvmid_en;
+    v2_cvfir_vsp.bits.cvfir_en = cfg->cvfir_en;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v2_cvfir_vsp.u32);
+
+    addr_reg = (gk_ulong)(gk_uintptr_t) & (vo_reg->v2_cvfir_voffset.u32);
+    v2_cvfir_voffset.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v2_cvfir_voffset.bits.vchroma_offset = pq_cfg->vchroma_offset;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v2_cvfir_voffset.u32);
+
+    addr_reg = (gk_ulong)(gk_uintptr_t) & (vo_reg->v2_cvfir_vboffset.u32);
+    v2_cvfir_vboffset.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v2_cvfir_vboffset.bits.vbchroma_offset = pq_cfg->vbchroma_offset;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v2_cvfir_vboffset.u32);
+}
+
+static gk_void vo_hal_layer_set_v1_cvfir_coef(cvfir_coef *coef)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_v1_cvfir_vcoef0 v1_cvfir_vcoef0;
+    volatile reg_v1_cvfir_vcoef1 v1_cvfir_vcoef1;
+    volatile reg_v1_cvfir_vcoef2 v1_cvfir_vcoef2;
+    volatile gk_ulong addr_reg;
+
+    addr_reg = (gk_ulong)(gk_uintptr_t) & (vo_reg->v1_cvfir_vcoef0.u32);
+    v1_cvfir_vcoef0.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v1_cvfir_vcoef0.bits.vccoef00 = coef->vccoef00;
+    v1_cvfir_vcoef0.bits.vccoef01 = coef->vccoef01;
+    v1_cvfir_vcoef0.bits.vccoef02 = coef->vccoef02;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v1_cvfir_vcoef0.u32);
+
+    addr_reg = (gk_ulong)(gk_uintptr_t) & (vo_reg->v1_cvfir_vcoef1.u32);
+    v1_cvfir_vcoef1.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v1_cvfir_vcoef1.bits.vccoef03 = coef->vccoef03;
+    v1_cvfir_vcoef1.bits.vccoef10 = coef->vccoef10;
+    v1_cvfir_vcoef1.bits.vccoef11 = coef->vccoef11;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v1_cvfir_vcoef1.u32);
+
+    addr_reg = (gk_ulong)(gk_uintptr_t) & (vo_reg->v1_cvfir_vcoef2.u32);
+    v1_cvfir_vcoef2.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v1_cvfir_vcoef2.bits.vccoef12 = coef->vccoef12;
+    v1_cvfir_vcoef2.bits.vccoef13 = coef->vccoef13;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v1_cvfir_vcoef2.u32);
+}
+
+static gk_void vo_hal_layer_set_v2_cvfir_coef(cvfir_coef *coef)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_v2_cvfir_vcoef0 v2_cvfir_vcoef0;
+    volatile reg_v2_cvfir_vcoef1 v2_cvfir_vcoef1;
+    volatile reg_v2_cvfir_vcoef2 v2_cvfir_vcoef2;
+    volatile gk_ulong addr_reg;
+
+    addr_reg = (gk_ulong)(gk_uintptr_t) & (vo_reg->v2_cvfir_vcoef0.u32);
+    v2_cvfir_vcoef0.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v2_cvfir_vcoef0.bits.vccoef00 = coef->vccoef00;
+    v2_cvfir_vcoef0.bits.vccoef01 = coef->vccoef01;
+    v2_cvfir_vcoef0.bits.vccoef02 = coef->vccoef02;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v2_cvfir_vcoef0.u32);
+
+    addr_reg = (gk_ulong)(gk_uintptr_t) & (vo_reg->v2_cvfir_vcoef1.u32);
+    v2_cvfir_vcoef1.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v2_cvfir_vcoef1.bits.vccoef03 = coef->vccoef03;
+    v2_cvfir_vcoef1.bits.vccoef10 = coef->vccoef10;
+    v2_cvfir_vcoef1.bits.vccoef11 = coef->vccoef11;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v2_cvfir_vcoef1.u32);
+
+    addr_reg = (gk_ulong)(gk_uintptr_t) & (vo_reg->v2_cvfir_vcoef2.u32);
+    v2_cvfir_vcoef2.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v2_cvfir_vcoef2.bits.vccoef12 = coef->vccoef12;
+    v2_cvfir_vcoef2.bits.vccoef13 = coef->vccoef13;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v2_cvfir_vcoef2.u32);
+}
+
+gk_void vo_hal_layer_set_cvfir_coef(hal_disp_layer layer, cvfir_coef *coef)
+{
+    if (layer == HAL_DISP_LAYER_VHD1) {
+        vo_hal_layer_set_v1_cvfir_coef(coef);
+    } else if (layer == HAL_DISP_LAYER_VHD2) {
+        vo_hal_layer_set_v2_cvfir_coef(coef);
+    }
+}
+#endif
+
+#if VO_DESC("layer chroma copy")
+
+gk_void vo_hal_layer_set_chroma_copy(gk_u32 layer, gk_bool chroma_copy_flag)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_vid_read_ctrl vid_read_ctrl;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_video_layer_return(layer);
+
+    addr_reg = (gk_ulong)(gk_uintptr_t) (&(vo_reg->vid_read_ctrl.u32) + layer * FDR_VID_OFFSET);
+    vid_read_ctrl.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    vid_read_ctrl.bits.chm_copy_en = chroma_copy_flag;
+    hal_write_reg((gk_u32 *)(gk_uintptr_t)addr_reg, vid_read_ctrl.u32);
+}
+
+#endif
+
+gk_void hal_video_hfir_set_ck_gt_en(hal_disp_layer layer, gk_u32 ck_gt_en)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_v0_hfir_ctrl v0_hfir_ctrl;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_video_layer_return(layer);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_hfir_ctrl.u32));
+    v0_hfir_ctrl.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_hfir_ctrl.bits.ck_gt_en = ck_gt_en;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_hfir_ctrl.u32);
+}
+
+gk_void hal_video_hfir_set_mid_en(hal_disp_layer layer, gk_u32 mid_en)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_v0_hfir_ctrl v0_hfir_ctrl;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_video_layer_return(layer);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_hfir_ctrl.u32));
+    v0_hfir_ctrl.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_hfir_ctrl.bits.mid_en = mid_en;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_hfir_ctrl.u32);
+}
+
+gk_void hal_video_hfir_set_hfir_mode(hal_disp_layer layer, gk_u32 hfir_mode)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_v0_hfir_ctrl v0_hfir_ctrl;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_video_layer_return(layer);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_hfir_ctrl.u32));
+    v0_hfir_ctrl.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_hfir_ctrl.bits.hfir_mode = hfir_mode;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_hfir_ctrl.u32);
+}
+
+gk_void hal_video_hfir_set_coef(hal_disp_layer layer, hfir_coef *coef)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_v0_hfircoef01 v0_hfir_coef01;
+    volatile reg_v0_hfircoef23 v0_hfir_coef23;
+    volatile reg_v0_hfircoef45 v0_hfir_coef45;
+    volatile reg_v0_hfircoef67 v0_hfir_coef67;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_video_layer_return(layer);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_hfircoef01.u32));
+    v0_hfir_coef01.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_hfir_coef01.bits.coef0 = coef->coef0;
+    v0_hfir_coef01.bits.coef1 = coef->coef1;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_hfir_coef01.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_hfircoef23.u32));
+    v0_hfir_coef23.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_hfir_coef23.bits.coef2 = coef->coef2;
+    v0_hfir_coef23.bits.coef3 = coef->coef3;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_hfir_coef23.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_hfircoef45.u32));
+    v0_hfir_coef45.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_hfir_coef45.bits.coef4 = coef->coef4;
+    v0_hfir_coef45.bits.coef5 = coef->coef5;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_hfir_coef45.u32);
+
+    addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_hfircoef67.u32));
+    v0_hfir_coef67.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    v0_hfir_coef67.bits.coef6 = coef->coef6;
+    v0_hfir_coef67.bits.coef7 = coef->coef7;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_hfir_coef67.u32);
+}
+
+gk_void hal_layer_set_layer_in_rect(hal_disp_layer layer, gk_rect *rect)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_vid_in_reso vid_in_reso;
+    volatile gk_ulong addr_reg;
+
+    vo_hal_check_video_layer_return(layer);
+
+    addr_reg = vou_get_vid_abs_addr(layer, (gk_uintptr_t) & (vo_reg->vid_in_reso.u32));
+    vid_in_reso.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+    vid_in_reso.bits.ireso_w = rect->width - 1;
+    vid_in_reso.bits.ireso_h = rect->height - 1;
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, vid_in_reso.u32);
+}
+
+gk_void hal_layer_set_reg_up(hal_disp_layer layer)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_v0_upd v0_upd;
+    volatile reg_g0_upd g0_upd;
+    volatile gk_ulong addr_reg;
+
+    if (vo_hal_is_video_layer(layer)) {
+        addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->v0_upd.u32));
+        v0_upd.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+        /* video layer register update */
+        v0_upd.bits.regup = 0x1;
+        hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, v0_upd.u32);
+    } else if (vo_hal_is_gfx_layer(layer)) {
+        addr_reg = vou_get_abs_addr(layer, (gk_uintptr_t) & (vo_reg->g0_upd.u32));
+        g0_upd.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) addr_reg);
+        /* graphic layer register update */
+        g0_upd.bits.regup = 0x1;
+        hal_write_reg ((gk_u32 *)(gk_uintptr_t) addr_reg, g0_upd.u32);
+    }
+}
+
+gk_void hal_cbm_set_cbm_attr(hal_disp_layer layer, gk_vo_dev dev)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_link_ctrl link_ctrl;
+
+    if (layer == HAL_DISP_LAYER_VHD2) {
+        link_ctrl.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) & (vo_reg->link_ctrl.u32));
+        link_ctrl.bits.v2_link = dev;
+        hal_write_reg ((gk_u32 *)(gk_uintptr_t) & (vo_reg->link_ctrl.u32), link_ctrl.u32);
+    } else if (layer == HAL_DISP_LAYER_GFX2) {
+        link_ctrl.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) & (vo_reg->link_ctrl.u32));
+        link_ctrl.bits.g2_link = dev;
+        hal_write_reg ((gk_u32 *)(gk_uintptr_t) & (vo_reg->link_ctrl.u32), link_ctrl.u32);
+    } else if (layer == HAL_DISP_LAYER_GFX3) {
+        link_ctrl.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) & (vo_reg->link_ctrl.u32));
+        link_ctrl.bits.g3_link = dev;
+        hal_write_reg ((gk_u32 *)(gk_uintptr_t) & (vo_reg->link_ctrl.u32), link_ctrl.u32);
+    }
+}
+
+gk_void hal_cbm_set_cbm_bkg(hal_cbmmix mixer, hal_disp_bkcolor *bkg)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_cbm_bkg1 cbm_bkg1;
+    volatile reg_cbm_bkg2 cbm_bkg2;
+    volatile reg_cbm_bkg3 cbm_bkg3;
+
+    if (mixer == HAL_CBMMIX1) {
+        cbm_bkg1.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) & (vo_reg->cbm_bkg1.u32));
+        cbm_bkg1.bits.cbm_bkgy1 = (bkg->bkg_y);
+        cbm_bkg1.bits.cbm_bkgcb1 = (bkg->bkg_cb);
+        cbm_bkg1.bits.cbm_bkgcr1 = (bkg->bkg_cr);
+        hal_write_reg ((gk_u32 *)(gk_uintptr_t) & (vo_reg->cbm_bkg1.u32), cbm_bkg1.u32);
+    } else if (mixer == HAL_CBMMIX2) {
+        cbm_bkg2.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) & (vo_reg->cbm_bkg2.u32));
+        cbm_bkg2.bits.cbm_bkgy2 = (bkg->bkg_y);
+        cbm_bkg2.bits.cbm_bkgcb2 = (bkg->bkg_cb);
+        cbm_bkg2.bits.cbm_bkgcr2 = (bkg->bkg_cr);
+        hal_write_reg ((gk_u32 *)(gk_uintptr_t) & (vo_reg->cbm_bkg2.u32), cbm_bkg2.u32);
+    } else if (mixer == HAL_CBMMIX3) {
+        cbm_bkg3.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) & (vo_reg->cbm_bkg3.u32));
+        cbm_bkg3.bits.cbm_bkgy3 = (bkg->bkg_y);
+        cbm_bkg3.bits.cbm_bkgcb3 = (bkg->bkg_cb);
+        cbm_bkg3.bits.cbm_bkgcr3 = (bkg->bkg_cr);
+        hal_write_reg ((gk_u32 *)(gk_uintptr_t) & (vo_reg->cbm_bkg3.u32), cbm_bkg3.u32);
+    }
+}
+
+static gk_void hal_cbm_set_cbm1_mixer_prio(gk_vo_layer layer, gk_u8 prio)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    volatile reg_cbm_mix1 cbm_mix1;
+    gk_u8 layer_id = 0;
+
+    /* check layer availability */
+    if (hal_cbm_get_cbm1_mixer_layer_id(layer, &layer_id) != GK_TRUE) {
+        return;
+    }
+
+     /* set mixer prio */
+    cbm_mix1.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) & (vo_reg->cbm_mix1.u32));
+
+    switch (prio) {
+        case 0:  /* 0: prio 0 */
+            cbm_mix1.bits.mixer_prio0 = layer_id;
+            break;
+
+        case 1:  /* 1: prio 1 */
+            cbm_mix1.bits.mixer_prio1 = layer_id;
+            break;
+
+        case 2:  /* 2: prio 2 */
+            cbm_mix1.bits.mixer_prio2 = layer_id;
+            break;
+
+        case 3:  /* 3: prio 3 */
+            cbm_mix1.bits.mixer_prio3 = layer_id;
+            break;
+
+        case 4:  /* 4: prio 4 */
+            cbm_mix1.bits.mixer_prio4 = layer_id;
+            break;
+
+        default:
+            vo_err_trace("error priority id %d found\n", prio);
+            return;
+    }
+
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) & (vo_reg->cbm_mix1.u32), cbm_mix1.u32);
+}
+
+static gk_void hal_cbm_set_cbm2_mixer_prio(gk_vo_layer layer, gk_u8 prio)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    reg_cbm_mix2 cbm_mix2;
+    gk_u8 layer_id = 0;
+
+    /* check layer availability */
+    if (hal_cbm_get_cbm2_mixer_layer_id(layer, &layer_id) != GK_TRUE) {
+        return;
+    }
+
+    /* set mixer prio */
+    cbm_mix2.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) & (vo_reg->cbm_mix2.u32));
+
+    switch (prio) {
+        case 0:  /* 0: prio 0 */
+            cbm_mix2.bits.mixer_prio0 = layer_id;
+            break;
+
+        case 1:  /* 1: prio 1 */
+            cbm_mix2.bits.mixer_prio1 = layer_id;
+            break;
+
+        case 2:  /* 2: prio 2 */
+            cbm_mix2.bits.mixer_prio2 = layer_id;
+            break;
+
+        case 3:  /* 3: prio 3 */
+            cbm_mix2.bits.mixer_prio3 = layer_id;
+            break;
+
+        case 4:  /* 4: prio 4 */
+            cbm_mix2.bits.mixer_prio4 = layer_id;
+            break;
+
+        default:
+            vo_err_trace("error priority id %d found\n", prio);
+            return;
+    }
+
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) & (vo_reg->cbm_mix2.u32), cbm_mix2.u32);
+}
+
+static gk_void hal_cbm_set_cbm3_mixer_prio(gk_vo_layer layer, gk_u8 prio)
+{
+    volatile reg_vdp_regs *vo_reg = vo_hal_get_reg();
+    reg_cbm_mix3 cbm_mix3;
+    gk_u8 layer_id = 0;
+
+    /* check layer availability */
+    if (hal_cbm_get_cbm3_mixer_layer_id(layer, &layer_id) != GK_TRUE) {
+        return;
+    }
+
+    /* set mixer prio */
+    cbm_mix3.u32 = hal_read_reg((gk_u32 *)(gk_uintptr_t) & (vo_reg->cbm_mix3.u32));
+
+    switch (prio) {
+        case 0:  /* 0: prio 0 */
+            cbm_mix3.bits.mixer_prio0 = layer_id;
+            break;
+
+        case 1:  /* 1: prio 1 */
+            cbm_mix3.bits.mixer_prio1 = layer_id;
+            break;
+
+        case 2:  /* 2: prio 2 */
+            cbm_mix3.bits.mixer_prio2 = layer_id;
+            break;
+
+        default:
+            vo_err_trace("error priority id %d found\n", prio);
+            return;
+    }
+
+    hal_write_reg ((gk_u32 *)(gk_uintptr_t) & (vo_reg->cbm_mix3.u32), cbm_mix3.u32);
+}
+
+gk_void hal_cbm_set_cbm_mixer_prio(gk_vo_layer layer, gk_u8 prio, gk_u8 mixer_id)
+{
+    if (mixer_id == HAL_CBMMIX1) {
+        hal_cbm_set_cbm1_mixer_prio(layer, prio);
+    } else if (mixer_id == HAL_CBMMIX2) {
+        hal_cbm_set_cbm2_mixer_prio(layer, prio);
+    } else if (mixer_id == HAL_CBMMIX3) {
+        hal_cbm_set_cbm3_mixer_prio(layer, prio);
+    }
+}
+
+#endif
+#endif /* #if VO_DESC("UBOOT_VO") */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
diff -uraN u-boot-2016.11/product/osd/vo/arch/comm/src/hal_vo_video_comm.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/hal_vo_video_comm.h
--- u-boot-2016.11/product/osd/vo/arch/comm/src/hal_vo_video_comm.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/comm/src/hal_vo_video_comm.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __HAL_VO_VIDEO_COMM_H__
+#define __HAL_VO_VIDEO_COMM_H__
+
+#include "hal_vo_def.h"
+#include "drv_vo_coef_comm.h"
+#include "inner_vo.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#if VO_DESC("UBOOT_VO")
+
+#if VO_DESC("layer")
+gk_void hal_video_set_layer_up_mode(hal_disp_layer layer, gk_u32 up_mode);
+gk_void hal_video_set_layer_disp_rect(hal_disp_layer layer, gk_rect *rect);
+gk_void hal_video_set_layer_video_rect(hal_disp_layer layer, gk_rect *rect);
+gk_void hal_video_set_multi_area_lum_addr(hal_disp_layer layer, gk_u32 area_num, gk_ulong addr,
+    gk_u16 stride);
+gk_void hal_video_set_multi_area_chm_addr(hal_disp_layer layer, gk_u32 area_num, gk_ulong addr,
+    gk_u16 stride);
+#endif
+
+#if VO_DESC("layer zme")
+gk_void vo_hal_layer_set_zme_cfg(hal_disp_layer layer, gk_u32 vratio, gk_u32 hratio,
+    vo_v0_zme_cfg *cfg, vo_zme_comm_pq_cfg *pq_cfg);
+#endif
+
+#if VO_DESC("cvfir")
+gk_void vo_hal_layer_set_v1_cvfir_cfg(gk_u32 vratio, vdp_v1_cvfir_cfg *cfg,
+    vo_zme_comm_pq_cfg *pq_cfg);
+gk_void vo_hal_layer_set_v2_cvfir_cfg(gk_u32 vratio, vdp_v1_cvfir_cfg *cfg,
+    vo_zme_comm_pq_cfg *pq_cfg);
+
+gk_void vo_hal_layer_set_chroma_copy(gk_u32 layer, gk_bool chroma_copy_flag);
+#endif
+
+#if VO_DESC("layer")
+/* video layer HFIR relative hal functions */
+gk_void hal_video_hfir_set_ck_gt_en(hal_disp_layer layer, gk_u32 ck_gt_en);
+gk_void hal_video_hfir_set_mid_en(hal_disp_layer layer, gk_u32 mid_en);
+gk_void hal_video_hfir_set_hfir_mode(hal_disp_layer layer, gk_u32 hfir_mode);
+gk_void hal_video_hfir_set_coef(hal_disp_layer layer, hfir_coef *coef);
+
+gk_void hal_layer_enable_layer(hal_disp_layer layer, gk_u32 enable);
+gk_void hal_layer_set_layer_data_fmt(hal_disp_layer layer, hal_disp_pixel_format data_fmt);
+gk_void hal_layer_set_src_resolution(hal_disp_layer layer, const gk_rect *rect);
+gk_void hal_layer_set_layer_in_rect(hal_disp_layer layer, gk_rect *rect);
+gk_void hal_layer_set_zme_info(hal_disp_layer layer, gk_u32 width, gk_u32 height,
+                               hal_disp_zme_outfmt data_fmt);
+gk_void hal_layer_set_reg_up(hal_disp_layer layer);
+gk_void hal_cbm_set_cbm_attr(hal_disp_layer layer, gk_vo_dev dev);
+gk_void hal_cbm_set_cbm_bkg(hal_cbmmix mixer, hal_disp_bkcolor *bkg);
+gk_void hal_cbm_set_cbm_mixer_prio(gk_vo_layer layer, gk_u8 prio, gk_u8 mixer_id);
+#endif
+#endif /* #if VO_DESC("UBOOT_VO") */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* end of __HAL_VO_VIDEO_COMM_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/arch/include/drv_vo_dev.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/include/drv_vo_dev.h
--- u-boot-2016.11/product/osd/vo/arch/include/drv_vo_dev.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/include/drv_vo_dev.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,109 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __DRV_VO_DEV_H__
+#define __DRV_VO_DEV_H__
+
+#include "common.h"
+#include "sys_ext.h"
+#include "common_vo.h"
+#include "inner_vo.h"
+#include "drv_vo_comm.h"
+#include "drv_vo_dev_comm.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#if VO_DESC("UBOOT_VO")
+
+typedef enum {
+    VO_CLK_DIV1 = 0,
+    VO_CLK_DIV2 = 1,
+    VO_CLK_DIV_BUTT
+} vo_clk_div;
+
+typedef enum {
+    SSC_VDP_DIV_25_TO_50 = 15, /* 25MHz~50MHz, 16div */
+    SSC_VDP_DIV_50_TO_100 = 7, /* 50MHz~100MHz, 8div */
+    SSC_VDP_DIV_100_TO_200 = 3, /* 100MHz~200MHz, 4div */
+    SSC_VDP_DIV_200_TO_340 = 1, /* 200MHz~340MHz, 2div */
+    SSC_VDP_DIV_340_TO_600 = 0, /* 340MHz~600MHz, 1div */
+
+    SSC_VDP_DIV_BUTT
+}gk_vo_hdmi_ssc_vdp_div_mode;
+
+typedef struct {
+    gk_vo_intf_sync index;
+    gk_vo_pll pll;
+    gk_vo_hdmi_ssc_vdp_div_mode div;
+}vo_pll_param;
+
+typedef enum {
+    VO_CLK_PLL_SRC_FOUTPOSTDIV = 0, /* FOUTVCO / (postdiv1 * postdiv2) */
+    VO_CLK_PLL_SRC_FOUT4 = 1, /* FOUTVCO / (postdiv1 * postdiv2 * 8) */
+
+    VO_CLK_PLL_SRC_BUTT
+}vo_clk_pll_src;
+
+#if VO_DESC("dev")
+gk_void vo_drv_set_dev_user_intf_sync_attr(gk_vo_dev dev, const gk_vo_user_sync_info *sync_info);
+gk_void vo_drv_set_dev_div(gk_vo_dev dev, gk_u32 dev_div);
+gk_void vo_drv_set_hdmi_div(gk_vo_dev dev, gk_u32 pre_div);
+gk_s32 vo_drv_check_dev_clk_src(gk_vo_dev dev, gk_vo_clk_src clk_src);
+gk_s32 vo_drv_check_intf_user_dev_div(gk_vo_dev dev, gk_u32 dev_div);
+gk_s32 vo_drv_check_dev_fixed_clk(gk_vo_dev dev, gk_vo_fixed_clk fixed_clk);
+#endif
+
+#if VO_DESC("dev intf")
+gk_s32 vou_drv_check_hdmi_sync(gk_vo_dev dev, gk_vo_intf_type intf_type, gk_vo_intf_sync intf_sync);
+gk_s32 vou_drv_check_bt_sync(gk_vo_dev dev, gk_vo_intf_type intf_type, gk_vo_intf_sync intf_sync);
+gk_s32 vou_drv_check_vga_sync(gk_vo_dev dev, gk_vo_intf_type intf_type, gk_vo_intf_sync intf_sync);
+gk_s32 vou_drv_check_rgb_sync(gk_vo_dev dev, gk_vo_intf_type intf_type, gk_vo_intf_sync intf_sync);
+gk_s32 vou_drv_check_dev_intf(gk_vo_dev dev, gk_vo_intf_type intf_type);
+gk_u32 vo_drv_get_vga_gain_def(gk_void);
+#endif
+
+#if VO_DESC("dev")
+
+gk_void vo_drv_open(gk_vo_dev dev);
+gk_void vo_drv_close(gk_vo_dev dev);
+
+gk_void vo_drv_dev_info_init(gk_void);
+gk_vo_layer vo_drv_get_layer(gk_vo_dev dev);
+gk_void vo_drv_default_setting(gk_void);
+gk_s32 vo_drv_check_dev_id(gk_vo_dev dev);
+gk_s32 vo_drv_check_layer_id(gk_vo_layer layer);
+gk_void vou_drv_set_dev_clk(gk_vo_dev dev);
+gk_void vo_drv_set_out_clk_div(gk_u32 dev, gk_u32 vo_out_clk_div);
+gk_void vo_drv_set_dev_clk_en_sel(gk_vo_dev dev);
+gk_void vo_drv_dev_get_clk_pll_src(gk_vo_dev dev, gk_u32 *pll_src);
+gk_void vo_drv_set_intf_dither(gk_vo_intf_type intf_type, gk_u32 in_bit_width);
+gk_u32 vo_drv_dev_get_max_clk(gk_vo_dev dev);
+#endif
+
+gk_void vo_drv_dev_get_pll_cfg(gk_vo_dev dev, gk_vo_pll *pll);
+gk_void vo_drv_get_pll_cfg_no_div(gk_vo_intf_sync intf_sync, gk_vo_pll *pll);
+gk_void vo_drv_get_hdmi_ssc_vdp_div(gk_vo_intf_sync intf_sync, gk_u32 *hdmi_ssc_vdp_div);
+gk_void vo_drv_dev_set_pll_cfg(gk_vo_dev dev, gk_vo_pll *pll);
+
+#if VO_DESC("dev")
+gk_void vo_drv_set_all_crg_clk(gk_bool clk_en);
+gk_void vo_lpw_bus_reset(gk_bool reset);
+#endif
+
+gk_bool vo_drv_is_dev_support_rgb(gk_vo_dev dev);
+
+#endif /* #if VO_DESC("UBOOT_VO") */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* end of __DRV_VO_DEV_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/arch/include/drv_vo_gfx.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/include/drv_vo_gfx.h
--- u-boot-2016.11/product/osd/vo/arch/include/drv_vo_gfx.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/include/drv_vo_gfx.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __DRV_GFX_H__
+#define __DRV_GFX_H__
+
+#include "type.h"
+#include "common_vo.h"
+#include "mkp_vo.h"
+#include "drv_vo_gfx_comm.h"
+
+gk_s32 vo_drv_check_gfx_id(gk_vo_layer gfx_layer);
+gk_s32 vo_drv_get_hal_gfx_layer(gk_vo_layer gfx_layer, hal_disp_layer *hal_layer);
+gk_s32 vou_drv_get_gfx_bind_dev(gk_vo_layer layer);
+
+gk_s32 graphic_drv_init(gk_void);
+gk_s32 vo_drv_check_gfx_layer_id(gk_vo_layer layer);
+gk_s32 vo_drv_check_gfx_attr_display_rect(gk_vo_layer layer, const gk_rect *rect);
+
+gk_s32 vo_drv_gfx_convert_gfx_attr(const gk_vo_gfx_attr *gfx_attr_in, gk_vo_gfx_attr *gfx_attr_out);
+gk_void vo_drv_gfx_open(gk_vo_layer gfx_id, const gk_vo_gfx_attr *gfx_attr);
+gk_void vo_drv_gfx_close(gk_vo_layer layer_id);
+#endif
diff -uraN u-boot-2016.11/product/osd/vo/arch/include/drv_vo.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/include/drv_vo.h
--- u-boot-2016.11/product/osd/vo/arch/include/drv_vo.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/include/drv_vo.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,131 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __DRV_VO_H__
+#define __DRV_VO_H__
+
+#include "drv_vo_comm.h"
+#include "drv_vo_dev.h"
+#include "drv_vo_layer.h"
+#include "drv_vo_video.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+#if VO_DESC("UBOOT_VO")
+
+#define VO_ADDR_ALIGN        16 /* bytes */
+#define VO_STRIDE_ALIGN      16
+
+#define VO_SD_VTTH_WATERLINE 100
+#define VO_HD_VTTH_WATERLINE 240
+#define VO_SD_VTTH_WATERLINE2  2
+#define VO_HD_VTTH_WATERLINE2  2
+
+/* PLL FREF 24MHz */
+#define VO_PLL_FREF 24
+
+/* PLL frac precision */
+#define VO_PLL_FRAC_PREC (1 << 24)
+#define VO_PLL_FOUTCVO_MIN 800
+#define VO_PLL_FOUTCVO_MAX 3200
+#define VO_PLL_MAX_CLK_594000 594000
+#define VO_PLL_MAX_CLK_297000 297000
+#define VO_PLL_MAX_CLK_148500 148500
+
+/* LCDMCLKDIV max ((75 / 1188) * 2^27 )(max 75Mhz) */
+#define VO_LCDMCLK_DIV_MAX 8473341
+
+#define VO_SD_SRC_CLK 54000
+#define VO_CLK_MHZ_UNIT 1000
+
+/* vou mixer prio id */
+typedef enum {
+    VOU_MIX_PRIO0 = 0,
+    VOU_MIX_PRIO1,
+    VOU_MIX_PRIO2,
+    VOU_MIX_PRIO3,
+    VOU_MIX_PRIO4,
+    VOU_MIX_BUTT
+} vou_mix_prio;
+
+typedef enum {
+    VO_CSC_DEF_VAL = 50,
+    VO_CSC_LUMA_MAX = 100,
+    VO_CSC_LUMA_MIN = 0,
+
+    VO_CSC_CONT_MAX = 100,
+    VO_CSC_CONT_MIN = 0,
+
+    VO_CSC_HUE_MAX = 100,
+    VO_CSC_HUE_MIN = 0,
+
+    VO_CSC_SAT_MAX = 100,
+    VO_CSC_SAT_MIN = 0,
+} vo_csc_range;
+
+#define VO_VGA_SHARPEN_STRENGTH_MIN  0
+#define VO_VGA_SHARPEN_STRENGTH_MAX  0xFF
+#define VO_VGA_SHARPEN_STRENGTH_DEF   128
+#define VO_VGA_GAIN_MAX                 0x3F
+#define VO_CVBS_DAC_GC_DEF              0x3C
+
+#define VO_DAC_CABLE_CTR_DEF            3
+
+typedef struct {
+    vo_dev_type dev_type; /* dev type */
+    gk_bool support_wbc; /* WBC support or not */
+} vo_dev_capability;
+
+#define VO_RESO_MIN_WDT      32 /* minimal width of display resolution */
+#define VO_RESO_MIN_HGT      32 /* minimal height of display resolution */
+
+/* desc : device context, which contains device public attribute. */
+typedef struct {
+    gk_bool vo_enable;
+    gk_bool config;
+    gk_vo_pub_attr vou_attr;
+
+    gk_u32 layer_num;
+
+    gk_u32 max_width;
+    gk_u32 max_height;
+    gk_u32 vtth;
+    gk_u32 vtth2;
+} vo_drv_dev;
+
+typedef struct {
+    gk_bool video_enable;
+    gk_bool video_config;
+
+    gk_s32 bind_dev;
+    gk_vo_video_layer_attr vo_video_attr;
+    gk_vo_csc csc;
+    csc_coef_param csc_param;
+} vo_drv_layer;
+
+#if VO_DESC("ctx")
+vo_drv_dev *vo_drv_get_dev_ctx(gk_vo_dev vo_dev);
+vo_drv_layer *vo_drv_get_layer_ctx(gk_vo_layer layer);
+#endif
+
+#if VO_DESC("pub")
+gk_void vo_drv_set_clk_reverse(gk_vo_dev dev, gk_bool reverse);
+
+gk_void vou_drv_def_layer_bind_dev(gk_void);
+gk_void vo_drv_default_setting(gk_void);
+#endif
+
+#endif /* #if VO_DESC("UBOOT_VO") */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* end of __DRV_VO_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/arch/include/drv_vo_layer.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/include/drv_vo_layer.h
--- u-boot-2016.11/product/osd/vo/arch/include/drv_vo_layer.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/include/drv_vo_layer.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,11 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __DRV_VO_LAYER_H__
+#define __DRV_VO_LAYER_H__
+
+#include "drv_vo_layer_comm.h"
+
+#endif /* end of __DRV_VO_LAYER_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/arch/include/drv_vo_video.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/include/drv_vo_video.h
--- u-boot-2016.11/product/osd/vo/arch/include/drv_vo_video.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/include/drv_vo_video.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __DRV_VO_VIDEO_H__
+#define __DRV_VO_VIDEO_H__
+
+#include "drv_vo_video_comm.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#if VO_DESC("UBOOT_VO")
+
+#if VO_DESC("layer")
+
+typedef struct {
+    gk_u32 vid_iw;
+    gk_u32 vid_ih;
+    gk_u32 vid_ow;
+    gk_u32 vid_oh;
+
+    gk_u32 zme_en;
+    gk_u32 hfir_en;
+    gk_u32 csc_en;
+    gk_u32 hdr_en;
+} vdp_vid_ip_cfg;
+
+typedef struct {
+    gk_u32 zme_vprec;
+    gk_u32 zme_hprec;
+} vo_zme_ds_info;
+
+#endif
+
+#if VO_DESC("layer zme")
+hal_disp_layer vou_drv_convert_layer(gk_vo_layer layer);
+#endif
+
+#if VO_DESC("layer")
+gk_void vo_drv_get_zme_comm_pq_cfg(vo_zme_ds_info *ds_info,
+                                   vo_zme_mode zme_mode,
+                                   vo_zme_comm_pq_cfg *comm_pq_cfg);
+
+gk_void vo_drv_get_cvfir_pq_cfg(vo_zme_ds_info *ds_info,
+                                vo_zme_mode zme_mode,
+                                vo_zme_comm_pq_cfg *comm_pq_cfg);
+gk_void vo_drv_layer_info_init(gk_void);
+gk_void vo_drv_video_set_zme_enable(gk_u32 layer, vdp_vid_ip_cfg *vid_cfg);
+#endif
+
+gk_void vou_drv_layer_csc_enable(gk_vo_layer layer, gk_bool csc_en);
+gk_void vo_drv_get_layer_csc_coef_range(gk_s32 *min_coef, gk_s32 *max_coef);
+#if VO_DESC("layer")
+gk_s32 vo_drv_check_video_layer_id(gk_vo_layer layer);
+gk_s32 vo_drv_check_layer_attr_display_rect(gk_vo_layer layer, const gk_rect *rect);
+#endif
+
+#if VO_DESC("layer open")
+gk_void vo_drv_layer_open(gk_vo_layer layer_id, const gk_vo_video_layer_attr *video_attr);
+gk_void vo_drv_layer_close(gk_vo_layer layer_id);
+#endif
+
+#endif /* #if VO_DESC("UBOOT_VO") */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* end of __DRV_VO_VIDEO_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/arch/include/sys_drv.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/include/sys_drv.h
--- u-boot-2016.11/product/osd/vo/arch/include/sys_drv.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/arch/include/sys_drv.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __SYS_DRV_H__
+#define __SYS_DRV_H__
+
+#include "common.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+gk_s32 sys_drv_drv_ioctrl(gk_mpp_chn *mpp_chn, gk_u32 func_id, gk_void *io_args);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* end of #ifndef __SYS_DRV_H__ */
\ No newline at end of file
diff -uraN u-boot-2016.11/product/osd/vo/ext_inc/sys_ext.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/ext_inc/sys_ext.h
--- u-boot-2016.11/product/osd/vo/ext_inc/sys_ext.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/ext_inc/sys_ext.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __SYS_EXT_H__
+#define __SYS_EXT_H__
+
+#include "type.h"
+#include "common_video.h"
+#include "sys_drv.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+typedef enum {
+    SYS_VO_PLL_POSTDIV2_SET,
+    SYS_VO_PLL_POSTDIV1_SET,
+    SYS_VO_PLL_FRAC_SET,
+    SYS_VO_PLL_REFDIV_SET,
+    SYS_VO_PLL_FBDIV_SET,
+    SYS_VO_PLL_POWER_CTRL,
+    SYS_VO_BUS_RESET_SEL,
+    SYS_VO_CFG_CLK_EN,
+    SYS_VO_APB_CLK_EN,
+    SYS_VO_BUS_CLK_EN,
+    SYS_VO_HD_CLKOUT_PHASIC_REVERSE_EN,
+    SYS_VO_OUT_DLY_TUNE,
+    SYS_VO_OUT_HD_DIV,
+    SYS_VO_HD0_DIV_MOD,
+    SYS_VO_HD_CLK_SEL,
+    SYS_VO_CORE_CLK_EN,
+    SYS_VO_DEV_CLK_EN,
+    SYS_VO_HD1_DIV_MOD,
+    SYS_VO_SD_CLK_DIV,
+    SYS_VO_SD_CLK_SEL,
+    SYS_VO_BT1120_CLK_EN,
+    SYS_VO_BT1120_CLK_SEL,
+    SYS_VO_DAC_CLK_PHASIC_REVERSE_EN,
+    SYS_VO_HD_DAC_SEL,
+    SYS_VO_DEV_DAC_EN,
+    SYS_VO_HDMI_SSC_VDP_DIV,
+    SYS_VO_HDMI_CLK_EN,
+    SYS_VO_HDMI_CLK_SEL,
+
+    SYS_BUTT,
+} sys_func;
+
+#define call_sys_drv_ioctrl(mpp_chn, func_id, io_args) \
+    sys_drv_drv_ioctrl(mpp_chn, func_id, io_args);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* __SYS_EXT_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/gk7205v200/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/Makefile
--- u-boot-2016.11/product/osd/vo/gk7205v200/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,4 @@
+obj-y += vou.o
+obj-y += vou_drv.o
+obj-y += vou_hal.o
+obj-y += vou_coef_org.o
diff -uraN u-boot-2016.11/product/osd/vo/gk7205v200/type.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/type.h
--- u-boot-2016.11/product/osd/vo/gk7205v200/type.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/type.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __GK_TYPE_H__
+#define __GK_TYPE_H__
+
+#include <common.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+typedef unsigned char GK_U8;
+typedef unsigned short GK_U16;
+typedef unsigned int GK_U32;
+
+typedef signed char GK_S8;
+typedef short GK_S16;
+typedef int GK_S32;
+
+typedef unsigned long GK_UL;
+typedef signed long GK_SL;
+
+typedef float GK_FLOAT;
+typedef double GK_DOUBLE;
+
+#ifndef _M_IX86
+typedef unsigned long long GK_U64;
+typedef long long GK_S64;
+#else
+typedef unsigned __int64 GK_U64;
+typedef __int64 GK_S64;
+#endif
+
+typedef char GK_CHAR;
+#define GK_VOID void
+
+typedef GK_U32 GK_HANDLE;
+
+typedef enum {
+    GK_FALSE = 0,
+    GK_TRUE = 1,
+} GK_BOOL;
+
+#ifndef NULL
+#define NULL 0L
+#endif
+
+#define GK_NULL    0L
+#define GK_SUCCESS 0
+#define GK_FAILURE (-1)
+
+typedef unsigned char           gk_uchar;
+typedef unsigned char           gk_u8;
+typedef unsigned short          gk_u16;
+typedef unsigned int            gk_u32;
+typedef unsigned long long      gk_u64;
+typedef unsigned long           gk_ulong;
+
+typedef char                    gk_char;
+typedef signed char             gk_s8;
+typedef short                   gk_s16;
+typedef int                     gk_s32;
+typedef long long               gk_s64;
+typedef long                    gk_slong;
+
+typedef float                   gk_float;
+typedef double                  gk_double;
+
+typedef void                    gk_void;
+
+typedef unsigned long           gk_size_t;
+typedef unsigned long           gk_length_t;
+typedef unsigned long int       gk_phys_addr_t;
+
+typedef gk_u32                  gk_handle;
+
+typedef GK_BOOL                 gk_bool;
+typedef uintptr_t               gk_uintptr_t;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __GK_TYPE_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/gk7205v200/vou.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/vou.c
--- u-boot-2016.11/product/osd/vo/gk7205v200/vou.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/vou.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,429 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "vou.h"
+#include "vou_drv.h"
+#include "vou_hal.h"
+
+/* for debug,bootlogo.dat is a bin file(image) #include "bootlogo.dat" */
+static gk_u32 g_bg_color = 0xFF; /* 0xFF default blue */
+static gk_bool g_inited = GK_FALSE;
+static gk_rect g_max_rect = {0};
+
+#define align_back(x, a) ((a) * (((x) / (a))))
+
+static gk_void vo_dcache_range(gk_phys_addr_t start_addr, gk_u64 size)
+{
+    if (dcache_status()) {
+        flush_dcache_range(start_addr, start_addr + size);
+    }
+}
+
+static unsigned int gfx_convert_layer(unsigned int layer)
+{
+    unsigned int gfx_layer;
+
+    /* hard cursor is not supported. */
+    switch (layer) {
+        case 0: /* 0 layer */
+            gfx_layer = VO_LAYER_G0;
+            break;
+
+        default:
+            gfx_layer = VO_LAYER_G0;
+            break;
+    }
+
+    return gfx_layer;
+}
+
+static hal_disp_layer gfx_convert_to_hal_layer(unsigned int layer)
+{
+    hal_disp_layer hal_gfx_layer;
+
+    /* hard cursor is not supported. */
+    switch (layer) {
+        case 0: /* 0 layer */
+            hal_gfx_layer = HAL_DISP_LAYER_GFX0;
+            break;
+
+        default:
+            hal_gfx_layer = HAL_DISP_LAYER_GFX0;
+            break;
+    }
+
+    return hal_gfx_layer;
+}
+
+static hal_disp_layer video_layer_convert_to_hal(unsigned int layer)
+{
+    hal_disp_layer hal_video_layer;
+
+    /* hard cursor is not supported. */
+    switch (layer) {
+        case 0: /* 0 layer */
+            hal_video_layer = HAL_DISP_LAYER_VHD0;
+            break;
+
+        default:
+            hal_video_layer = HAL_DISP_LAYER_VHD0;
+            break;
+    }
+
+    return hal_video_layer;
+}
+
+int set_vobg(unsigned int dev, unsigned int rgb)
+{
+    if (dev < 1) {
+        g_bg_color = rgb;
+    }
+
+    return 0;
+}
+
+gk_void vo_set_disp_max_size(vo_hal_dev vo_dev, vo_intf_sync vo_out_mode)
+{
+    /* default is 720x576 */
+    gk_u32 max_width = 720;
+    gk_u32 max_height = 576;
+
+    /* to get the width and height of the sync, not magic num */
+    switch (vo_out_mode) {
+        case VO_OUTPUT_PAL:
+        case VO_OUTPUT_576P50:
+            max_width = 720;
+            max_height = 576;
+            break;
+
+        case VO_OUTPUT_NTSC:
+        case VO_OUTPUT_480P60:
+            max_width = 720;
+            max_height = 480;
+            break;
+
+        case VO_OUTPUT_720P60:
+        case VO_OUTPUT_720P50:
+            max_width = 1280;
+            max_height = 720;
+            break;
+
+        case VO_OUTPUT_1080I50:
+        case VO_OUTPUT_1080I60:
+        case VO_OUTPUT_1080P24:
+        case VO_OUTPUT_1080P25:
+        case VO_OUTPUT_1080P30:
+        case VO_OUTPUT_1080P50:
+        case VO_OUTPUT_1080P60:
+            max_width = 1920;
+            max_height = 1080;
+            break;
+
+        case VO_OUTPUT_800x600_60:
+        case VO_OUTPUT_800x600_50:
+            max_width = 800;
+            max_height = 600;
+            break;
+
+        case VO_OUTPUT_1024x768_60:
+            max_width = 1024;
+            max_height = 768;
+            break;
+
+        case VO_OUTPUT_1280x1024_60:
+            max_width = 1280;
+            max_height = 1024;
+            break;
+
+        case VO_OUTPUT_1366x768_60:
+            max_width = 1366;
+            max_height = 768;
+            break;
+
+        case VO_OUTPUT_1440x900_60:
+            max_width = 1440;
+            max_height = 900;
+            break;
+
+        case VO_OUTPUT_1280x800_60:
+            max_width = 1280;
+            max_height = 800;
+            break;
+
+        case VO_OUTPUT_1600x1200_60:
+            max_width = 1600;
+            max_height = 1200;
+            break;
+
+        case VO_OUTPUT_1680x1050_60:
+            max_width = 1680;
+            max_height = 1050;
+            break;
+
+        case VO_OUTPUT_1920x1200_60:
+            max_width = 1920;
+            max_height = 1200;
+            break;
+
+        case VO_OUTPUT_640x480_60:
+            max_width = 640;
+            max_height = 480;
+            break;
+
+        case VO_OUTPUT_1920x2160_30:
+            max_width = 1920;
+            max_height = 2160;
+            break;
+
+        case VO_OUTPUT_2560x1440_30:
+        case VO_OUTPUT_2560x1440_60:
+            max_width = 2560;
+            max_height = 1440;
+            break;
+
+        case VO_OUTPUT_2560x1600_60:
+            max_width = 2560;
+            max_height = 1600;
+            break;
+
+        case VO_OUTPUT_3840x2160_24:
+        case VO_OUTPUT_3840x2160_25:
+        case VO_OUTPUT_3840x2160_30:
+        case VO_OUTPUT_3840x2160_50:
+        case VO_OUTPUT_3840x2160_60:
+            max_width = 3840;
+            max_height = 2160;
+            break;
+
+        case VO_OUTPUT_4096x2160_24:
+        case VO_OUTPUT_4096x2160_25:
+        case VO_OUTPUT_4096x2160_30:
+        case VO_OUTPUT_4096x2160_50:
+        case VO_OUTPUT_4096x2160_60:
+            max_width = 4096;
+            max_height = 2160;
+            break;
+
+        case VO_OUTPUT_320x240_50:
+        case VO_OUTPUT_320x240_60:
+            max_width = 320;
+            max_height = 240;
+            break;
+
+        case VO_OUTPUT_240x320_50:
+        case VO_OUTPUT_240x320_60:
+            max_width = 240;
+            max_height = 320;
+            break;
+
+        case VO_OUTPUT_720x1280_60:
+            max_width = 720;
+            max_height = 1280;
+            break;
+
+        case VO_OUTPUT_1080x1920_60:
+            max_width = 1080;
+            max_height = 1920;
+            break;
+
+        case VO_OUTPUT_7680x4320_30:
+            max_width = 7680;
+            max_height = 4320;
+            break;
+
+        default:
+            max_width = 4096;
+            max_height = 2160;
+    }
+
+    g_max_rect.width = max_width;
+    g_max_rect.height = max_height;
+}
+
+int start_vo(unsigned int dev, unsigned int type, unsigned int sync)
+{
+    if (g_inited == GK_FALSE) {
+        sys_hal_vo_bus_reset_sel(GK_FALSE);
+        /* open clk */
+        vo_drv_set_all_crg_clk(GK_TRUE);
+        vo_drv_board_init();
+        hal_sys_control();
+
+        g_inited = GK_TRUE;
+    }
+
+    sys_hal_vo_dev_clk_en(dev, GK_TRUE);
+    sys_hal_vo_core_clk_en(dev, GK_TRUE);
+
+    vo_drv_def_layer_bind_dev();
+    vo_set_disp_max_size(dev, sync);
+    vo_drv_set_dev_intf_type(dev, type);
+    vo_drv_set_dev_out_sync(dev, sync);
+
+    vo_drv_set_dev_bk_grd(dev, g_bg_color);
+
+    vo_drv_set_dev_clk(dev);
+    vo_drv_open(dev);
+    return 0;
+}
+
+int stop_vo(unsigned int dev)
+{
+    vo_drv_close(dev);
+    sys_hal_vo_dev_clk_en(dev, GK_FALSE);
+    return 0;
+}
+
+static void vo_get_videolayer_csc_matric(vo_intf_type intf_type, vo_csc_matrix *csc_matrix)
+{
+    if (intf_type == VO_INTF_BT1120) {
+        *csc_matrix = VO_CSC_MATRIX_IDENTITY;
+    } else if ((intf_type == VO_INTF_LCD_6BIT) ||
+               (intf_type == VO_INTF_LCD_8BIT) ||
+               (intf_type == VO_INTF_LCD_16BIT)) {
+        *csc_matrix = VO_CSC_MATRIX_BT709_TO_RGB_PC;
+    }
+}
+
+int start_videolayer(unsigned int layer, unsigned long addr, unsigned int strd, gk_vo_rect layer_rect)
+{
+    int i;
+    gk_rect disp_rect = { layer_rect.x, layer_rect.y, layer_rect.w, layer_rect.h };
+    hal_disp_layer vo_layer;
+    const hfir_coef coef = { 42, -10, -20, 28, -40, 61, -107, 330 }; /* hfir coef */
+
+    vo_intf_type intf_type;
+
+    vdp_vid_ip_cfg vid_cfg = {0};
+    vo_csc_matrix csc_matrix = VO_CSC_MATRIX_IDENTITY;
+
+    vo_dcache_range(addr, strd * layer_rect.h * 3 / 2); /* 3 / 2 times */
+
+    vo_layer = video_layer_convert_to_hal(layer);
+    hal_layer_set_layer_data_fmt(vo_layer, VO_LAYER_PIXERL_FORMAT_SP_Y_CB_CR_420);
+    vdp_fdr_vid_set_chm_copy_en(vo_layer, GK_TRUE);
+    intf_type = vo_drv_get_dev_intf_type(vo_layer);
+    vo_get_videolayer_csc_matric(intf_type, &csc_matrix);
+
+    vo_drv_video_set_csc_coef(vo_layer, csc_matrix);
+    hal_layer_set_csc_en(vo_layer, GK_TRUE);
+
+    for (i = 0; i < HAL_DISP_LAYER_VHD1; i++) {
+        hal_video_set_layer_alpha(i, 255); /* 255 max alpha */
+        hal_video_set_hfir_mode(i, HAL_HFIRMODE_COPY);
+        hal_video_hfir_set_coef(i, &coef);
+        hal_video_hfir_set_mid_en(i, GK_TRUE);
+    }
+
+    hal_video_hfir_set_ck_gt_en(vo_layer, GK_TRUE);
+    hal_video_set_layer_disp_rect(vo_layer, &disp_rect);
+    hal_video_set_layer_video_rect(vo_layer, &disp_rect);
+    hal_layer_set_layer_in_rect(vo_layer, &disp_rect);
+    hal_layer_set_layer_galpha(vo_layer, 255); /* 255 max alpha */
+    hal_layer_set_src_resolution(vo_layer, &disp_rect);
+    hal_layer_set_zme_enable(vo_layer, HAL_DISP_ZMEMODE_ALL, GK_FALSE);
+
+    vid_cfg.csc_en = 0;
+    vid_cfg.hfir_en = 1;
+    vid_cfg.vid_iw = disp_rect.width;
+    vid_cfg.vid_ih = disp_rect.height;
+    vid_cfg.vid_ow = disp_rect.width;
+    vid_cfg.vid_oh = disp_rect.height;
+    vid_cfg.zme_en = GK_FALSE;
+    vo_vid_set_zme_enable(vo_layer, &vid_cfg);
+    hal_layer_set_zme_info(vo_layer, disp_rect.width, disp_rect.height, HAL_DISP_ZME_OUTFMT420);
+
+    /* area 0 */
+    hal_video_set_multi_area_l_addr(vo_layer, 0, addr, strd);
+    hal_video_set_multi_area_c_addr(vo_layer, 0, addr + layer_rect.h * align_back(layer_rect.w, 8), strd); /* align 8 */
+
+    hal_layer_enable_layer(vo_layer, GK_TRUE);
+    hal_layer_set_reg_up(vo_layer);
+
+    return 0;
+}
+
+int stop_videolayer(unsigned int layer)
+{
+    hal_disp_layer hal_video_layer;
+
+    hal_video_layer = video_layer_convert_to_hal(layer);
+
+    hal_layer_enable_layer(hal_video_layer, GK_FALSE);
+    hal_layer_set_reg_up(hal_video_layer);
+
+    return 0;
+}
+
+int start_gx(unsigned int layer, unsigned long addr, unsigned int strd, gk_vo_rect gx_rect)
+{
+    osd_logo_t scroll_image_logo = {0};
+    gk_vo_layer vo_layer;
+    vo_intf_type intf_type;
+    vo_csc gfx_csc;
+    csc_coef_param csc_coef;
+
+    vo_layer = gfx_convert_layer(layer);
+    intf_type = vo_drv_get_dev_intf_type(layer);
+    load_bmp(addr, &scroll_image_logo);
+    gk_rect disp_rect = { gx_rect.x, gx_rect.y, scroll_image_logo.width, scroll_image_logo.height };
+
+    vo_dcache_range(scroll_image_logo.rgb_buffer, strd * gx_rect.h);
+
+    hal_graphic_set_gfx_ext(vo_layer, HAL_GFX_BITEXTEND_3RD);
+    hal_graphic_set_gfx_palpha(vo_layer, GK_TRUE, GK_TRUE, 0xff, 0xff);
+    hal_layer_set_layer_galpha(vo_layer, 0xff);
+    hal_graphic_set_gfx_pre_mult(vo_layer, GK_FALSE);
+
+    /* for mipi_tx, do not do this two line. */
+    if ((VO_INTF_BT1120 & intf_type) || (VO_INTF_BT656 & intf_type)) {
+        gfx_csc.csc_matrix = VO_CSC_MATRIX_RGB_TO_BT709_PC;
+        gfx_csc.luma = 50; /* 50 default value */
+        gfx_csc.contrast = 50; /* 50 default value */
+        gfx_csc.hue = 50; /* 50 default value */
+        gfx_csc.satuature = 50; /* 50 default value */
+
+        csc_coef.csc_scale2p = GFX_CSC_SCALE;
+        csc_coef.csc_clip_min = GFX_CSC_CLIP_MIN;
+        csc_coef.csc_clip_max = GFX_CSC_CLIP_MAX;
+
+        /* do rgb to yuv. */
+        graphic_drv_set_csc_coef(vo_layer, &gfx_csc, &csc_coef);
+        hal_layer_set_csc_en(vo_layer, GK_TRUE);
+    } else if ((intf_type == VO_INTF_LCD_6BIT) ||
+               (intf_type == VO_INTF_LCD_8BIT) ||
+               (intf_type == VO_INTF_LCD_16BIT)) {
+        /* do yuv to rgb or do nothing. */
+        hal_layer_set_csc_en(vo_layer, GK_FALSE);
+    }
+
+    hal_graphic_set_gfx_addr (vo_layer, (gk_u64)(gk_u32)scroll_image_logo.rgb_buffer);
+    hal_graphic_set_gfx_stride(vo_layer, (scroll_image_logo.stride) >> 4); /* 4 to set register */
+
+    hal_layer_set_layer_in_rect(vo_layer, &disp_rect);
+    hal_video_set_layer_disp_rect(vo_layer, &disp_rect);
+    hal_video_set_layer_video_rect(vo_layer, &disp_rect);
+    hal_gfx_set_src_resolution(vo_layer, &disp_rect);
+    hal_layer_set_layer_data_fmt(vo_layer, HAL_INPUTFMT_ARGB_1555);
+    hal_layer_enable_layer(vo_layer, GK_TRUE);
+    hal_layer_set_reg_up(vo_layer);
+
+    return 0;
+}
+
+int stop_gx(unsigned int layer)
+{
+    gk_vo_layer vo_layer;
+    hal_disp_layer hal_gfx_layer;
+
+    vo_layer = gfx_convert_layer(layer);
+    hal_gfx_layer = gfx_convert_to_hal_layer(layer);
+
+    hal_layer_set_reg_up(vo_layer);
+    hal_layer_enable_layer(vo_layer, GK_FALSE);
+    hal_layer_set_reg_up(hal_gfx_layer);
+
+    return 0;
+}
+
diff -uraN u-boot-2016.11/product/osd/vo/gk7205v200/vou_coef.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/vou_coef.h
--- u-boot-2016.11/product/osd/vo/gk7205v200/vou_coef.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/vou_coef.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,167 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __VOU_COEF_H__
+#define __VOU_COEF_H__
+
+#include "type.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* end of #ifdef __cplusplus */
+
+#define VOU_GAMM_COEF_ROW 32
+#define VOU_GAMM_COEF_COL 16
+
+#define VOU_ZOOM_COEF_ITEM   18
+#define VOU_ZOOM_COEF_MAXTAP 8
+
+#define VOU_ACC_COEF_NUM 256
+
+typedef enum {
+    VOU_ZOOM_COEF_1 = 0,
+    VOU_ZOOM_COEF_EQU_1,
+    VOU_ZOOM_COEF_075,
+    VOU_ZOOM_COEF_05,
+    VOU_ZOOM_COEF_033,
+    VOU_ZOOM_COEF_025,
+    VOU_ZOOM_COEF_0,
+    VOU_ZOOM_COEF_BUTT
+} vou_zoom_coef;
+
+typedef enum {
+    VOU_ZOOM_TAP_8LH = 0,
+    VOU_ZOOM_TAP_4CH,
+    VOU_ZOOM_TAP_6LV,
+    VOU_ZOOM_TAP_4LV,
+    VOU_ZOOM_TAP_4CV,
+    VOU_ZOOM_TAP_BUTT
+} vou_zoom_tap;
+
+typedef struct {
+    gk_s32 bits_0 : 10;
+    gk_s32 bits_1 : 10;
+    gk_s32 bits_2 : 10;
+    gk_s32 bits_32 : 2;
+    gk_s32 bits_38 : 8;
+    gk_s32 bits_4 : 10;
+    gk_s32 bits_5 : 10;
+    gk_s32 bits_64 : 4;
+    gk_s32 bits_66 : 6;
+    gk_s32 bits_7 : 10;
+    gk_s32 bits_8 : 10;
+    gk_s32 bits_96 : 6;
+    gk_s32 bits_94 : 4;
+    gk_s32 bits_10 : 10;
+    gk_s32 bits_11 : 10;
+    gk_s32 bits_12 : 8;
+} vo_zoom_bit;
+
+typedef struct {
+    gk_u32 size;
+    vo_zoom_bit bit[12]; /* 12 bit array */
+} vo_zoom_bitarray;
+
+typedef struct {
+    gk_s32 csc_coef00;
+    gk_s32 csc_coef01;
+    gk_s32 csc_coef02;
+
+    gk_s32 csc_coef10;
+    gk_s32 csc_coef11;
+    gk_s32 csc_coef12;
+
+    gk_s32 csc_coef20;
+    gk_s32 csc_coef21;
+    gk_s32 csc_coef22;
+} vdp_csc_coef;
+
+typedef struct {
+    gk_s32 csc_in_dc0;
+    gk_s32 csc_in_dc1;
+    gk_s32 csc_in_dc2;
+
+    gk_s32 csc_out_dc0;
+    gk_s32 csc_out_dc1;
+    gk_s32 csc_out_dc2;
+} vdp_csc_dc_coef;
+
+typedef struct {
+    gk_s32 csc_scale2p;
+    gk_s32 csc_clip_min;
+    gk_s32 csc_clip_max;
+} csc_coef_param;
+
+/* HFIR VCOEF */
+typedef struct {
+    gk_s32 coef0;
+    gk_s32 coef1;
+    gk_s32 coef2;
+    gk_s32 coef3;
+    gk_s32 coef4;
+    gk_s32 coef5;
+    gk_s32 coef6;
+    gk_s32 coef7;
+} hfir_coef;
+
+typedef struct {
+    /* for old version csc */
+    gk_s32 csc_coef00;
+    gk_s32 csc_coef01;
+    gk_s32 csc_coef02;
+
+    gk_s32 csc_coef10;
+    gk_s32 csc_coef11;
+    gk_s32 csc_coef12;
+
+    gk_s32 csc_coef20;
+    gk_s32 csc_coef21;
+    gk_s32 csc_coef22;
+
+    gk_s32 csc_in_dc0;
+    gk_s32 csc_in_dc1;
+    gk_s32 csc_in_dc2;
+
+    gk_s32 csc_out_dc0;
+    gk_s32 csc_out_dc1;
+    gk_s32 csc_out_dc2;
+
+    gk_s32 new_csc_scale2p;
+    gk_s32 new_csc_clip_min;
+    gk_s32 new_csc_clip_max;
+} vo_csc_coef;
+
+/* vga sharpen HF coefficient */
+typedef struct {
+    gk_s32 vga_hsp_tmp0;
+    gk_s32 vga_hsp_tmp1;
+    gk_s32 vga_hsp_tmp2;
+    gk_s32 vga_hsp_tmp3;
+    gk_u32 vga_hsp_coring;
+    gk_s32 vga_hsp_gainneg;
+    gk_s32 vga_hsp_gainpos;
+    gk_s32 vga_hsp_adpshooten;
+    gk_u32 vga_hsp_winsize;
+    gk_u32 vga_hsp_mixratio;
+    gk_u32 vga_hsp_underth;
+    gk_u32 vga_hsp_overth;
+} hsp_hf_coef;
+
+typedef struct {
+    gk_u32 vga_hsp_hf_shootdiv;
+    gk_u32 vga_hsp_lti_ratio;
+    gk_u32 vga_hsp_ldti_gain;
+    gk_u32 vga_hsp_cdti_gain;
+    gk_u32 vga_hsp_peak_ratio;
+    gk_u32 vga_hsp_glb_overth;
+    gk_u32 vga_hsp_glb_unferth;
+} hsp_coef;
+
+#define VO_CSC_DC_MAGIC 0x07c30180
+
+#ifdef __cplusplus
+}
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* end of #ifndef __VOU_COEF_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/gk7205v200/vou_coef_org.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/vou_coef_org.c
--- u-boot-2016.11/product/osd/vo/gk7205v200/vou_coef_org.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/vou_coef_org.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,136 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "vou_coef_org.h"
+
+/* RGB->YUV601 */
+const vo_csc_coef g_csc_rgb_to_yuv601_tv = {
+    /* csc */
+    258, 504, 98, -148, -291, 439, 439, -368, -71,
+    /* csc(IDC) */
+    0, 0, 0,
+    /* csc(ODC) */
+    16, 128, 128
+};
+
+/* RGB->YUV601 */
+const vo_csc_coef g_csc_rgb_to_yuv601_pc = {
+    /* csc */
+    299, 587, 114, -172, -339, 511, 511, -428, -83,
+    /* csc(IDC) */
+    0, 0, 0,
+    /* csc(ODC) */
+    0, 128, 128
+};
+
+/* RGB->YUV709 */
+const vo_csc_coef g_csc_rgb_to_yuv709_tv = {
+    /* csc */
+    5966, 20071, 2026, -3289, -11063, 14352, 14352, -13021, -1316,
+    /* csc(IDC) */
+    0, 0, 0,
+    /* csc(ODC) */
+    256, 2048, 2048
+};
+
+/* RGB->YUV709 output full[0,255] */
+const vo_csc_coef g_csc_rgb_to_yuv709_pc = {
+    /* csc */
+    213, 715, 72, -117, -394, 511, 511, -464, -47,
+    /* csc(IDC) */
+    0, 0, 0,
+    /* csc(ODC) */
+    0, 128, 128
+};
+
+/* RGB -> YUV BT.2020 coefficient matrix */
+const vo_csc_coef g_csc_rgb_to_yuv2020_pc = {
+    /* csc multiplier coefficient */
+    263, 678, 59, -143, -368, 511, 511, -470, -41,
+    /* csc input DC component (IDC) */
+    0, 0, 0,
+    /* csc output DC component (ODC) */
+    0, 128, 128
+};
+
+/* YUV601->RGB  */
+const vo_csc_coef g_csc_yuv601_to_rgb_pc = {
+    /* csc */
+    1000, 0, 1371, 1000, -336, -689, 1000, 1732, 0,
+    /* csc(IDC) */
+    0, -128, -128,
+    /* csc(ODC) */
+    0, 0, 0
+};
+
+/* YUV709->RGB  */
+const vo_csc_coef g_csc_yuv709_to_rgb_pc = {
+    /* csc */
+    1000, 0, 1540, 1000, -183, -459, 1000, 1816, 0,
+    /* csc(IDC) */
+    0, -128, -128,
+    /* csc(ODC) */
+    0, 0, 0
+};
+
+/* BT.2020 YUV -> RGB coefficient matrix */
+const vo_csc_coef g_csc_yuv2020_to_rgb_pc = {
+    /* csc multiplier coefficient */
+    1000, 0, 1442, 1000, -160, -560, 1000, 1841, 0,
+    /* csc input DC component (IDC) */
+    0, -128, -128,
+    /* csc output DC component (ODC) */
+    0, 0, 0
+};
+
+/* YUV601->YUV709 output full[0,255] */
+const vo_csc_coef g_csc_yuv_to_yuv_601_709 = {
+    /* csc */
+    1000, -116, 208, 0, 1017, 114, 0, 75, 1025,
+    /* csc(IDC) */
+    -16, -128, -128,
+    /* csc(ODC) */
+    16, 128, 128
+};
+
+/* YUV709->YUV601 full[0,255] */
+const vo_csc_coef g_csc_yuv_to_yuv_709_601 = {
+    /* csc */
+    1000, 99, 192, 0, 990, -111, 0, -72, 983,
+    /* csc(IDC) */
+    -16, -128, -128,
+    /* csc(ODC) */
+    16, 128, 128
+};
+
+/* YUV601->YUV709  */
+const vo_csc_coef g_csc_init = {
+    /* csc */
+    1000, 0, 0, 0, 1000, 0, 0, 0, 1000,
+    /* csc(IDC) */
+    -16, -128, -128,
+    /* csc(ODC) */
+    16, 128, 128
+};
+
+const int g_sin_table[61] = { /* 61 sin table length */
+    -500, -485, -469, -454, -438, -422, -407, -391, -374, -358,
+    -342, -325, -309, -292, -276, -259, -242, -225, -208, -191,
+    -174, -156, -139, -122, -104, -87, -70, -52, -35, -17,
+    0, 17, 35, 52, 70, 87, 104, 122, 139, 156,
+    174, 191, 208, 225, 242, 259, 276, 292, 309, 325,
+    342, 358, 374, 391, 407, 422, 438, 454, 469, 485,
+    500
+};
+
+const int g_cos_table[61] = { /* 61 cos table length */
+    866, 875, 883, 891, 899, 906, 914, 921, 927, 934,
+    940, 946, 951, 956, 961, 966, 970, 974, 978, 982,
+    985, 988, 990, 993, 995, 996, 998, 999, 999, 1000,
+    1000, 1000, 999, 999, 998, 996, 995, 993, 990, 988,
+    985, 982, 978, 974, 970, 966, 961, 956, 951, 946,
+    940, 934, 927, 921, 914, 906, 899, 891, 883, 875,
+    866
+};
+
diff -uraN u-boot-2016.11/product/osd/vo/gk7205v200/vou_coef_org.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/vou_coef_org.h
--- u-boot-2016.11/product/osd/vo/gk7205v200/vou_coef_org.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/vou_coef_org.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __VOU_COEF_ORG_H__
+#define __VOU_COEF_ORG_H__
+
+#include "vou_coef.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* end of #ifdef __cplusplus */
+
+/* RGB->YUV601 */
+extern const vo_csc_coef g_csc_rgb_to_yuv601_tv;
+/* RGB->YUV601 */
+extern const vo_csc_coef g_csc_rgb_to_yuv601_pc;
+/* RGB->YUV709 */
+extern const vo_csc_coef g_csc_rgb_to_yuv709_tv;
+/* RGB->YUV709 */
+extern const vo_csc_coef g_csc_rgb_to_yuv709_pc;
+extern const vo_csc_coef g_csc_rgb_to_yuv2020_pc;
+/* YUV601->RGB */
+extern const vo_csc_coef g_csc_yuv601_to_rgb_pc;
+/* YUV709->RGB */
+extern const vo_csc_coef g_csc_yuv709_to_rgb_pc;
+extern const vo_csc_coef g_csc_yuv2020_to_rgb_pc;
+/* YUV601->YUV709 */
+extern const vo_csc_coef g_csc_yuv_to_yuv_601_709;
+/* YUV709->YUV601 */
+extern const vo_csc_coef g_csc_yuv_to_yuv_709_601;
+/* YUV601->YUV709 */
+extern const vo_csc_coef g_csc_init;
+
+extern const int g_sin_table[61]; /* 61 sin table array */
+extern const int g_cos_table[61]; /* 61 cos table array */
+
+#ifdef __cplusplus
+}
+#endif /* end of #ifdef __cplusplus */
+
+#endif
diff -uraN u-boot-2016.11/product/osd/vo/gk7205v200/vou_def.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/vou_def.h
--- u-boot-2016.11/product/osd/vo/gk7205v200/vou_def.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/vou_def.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,508 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __VOU_DEF_H__
+#define __VOU_DEF_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* end of #ifdef __cplusplus */
+
+#define VO_BASE_ADDR      0x11280000
+#define VO_VHD_BASE_ADDR  0x800
+#define VO_GFX_BASE_ADDR  0x6000
+#define VO_HC_BASE_ADDR   0x9800
+#define VO_WBC0_BASE_ADDR 0xac00
+#define VO_WBC1_BASE_ADDR 0xa400
+#define VO_DHD_BASE_ADDR  0xc000
+#define VO_DSD_BASE_ADDR  0xc800
+#define VHD_REG_LEN       0x1000
+#define VSD_REG_LEN       0x1000
+#define GFX_REG_LEN       0x800
+#define HC_REG_LEN        0x800
+#define WBC_REG_LEN       0x400
+#define DHD_REG_LEN       0x400
+#define DSD_REG_LEN       0x400
+#define INTF_REG_LEN      0x100
+#define INTF_REGS_LEN     0x100
+#define VHD_REGS_LEN      0x1000 /* len of V0's regs */
+#define VSD_REGS_LEN      0x1000
+#define GFX_REGS_LEN      0x800
+#define WBC_REGS_LEN      0x400
+#define DHD_REGS_LEN      0x1000
+#define DSD_REGS_LEN      0x400
+#define INTF_REGS_LEN     0x100
+#define VID_REGS_LEN      0x200 /* len of VID regs */
+#define GRF_REGS_LEN      0x200 /* len of GFX regs */
+
+#define rgb_r(c) (((c) & 0xff0000) >> 16)
+#define rgb_g(c) (((c) & 0xff00) >> 8)
+#define rgb_b(c) ((c) & 0xff)
+
+#define ZME_HPREC (1 << 20)
+#define ZME_VPREC (1 << 12)
+
+#define MAX_OFFSET 3
+#define MIN_OFFSET (-1)
+
+#define CHANNEL_DHD_START 0
+#define CHANNEL_DHD_END   1
+#define CHANNEL_DSD_START 2
+#define CHANNEL_DSD_END   2
+
+#define MULTI_AREA_CFG_LEN (4 * 8)
+#define MULTI_AREA_1RGN    1
+#define MULTI_AREA_4RGN    4
+#define MULTI_AREA_32RGN   32
+#define MULTI_AREA_64RGN   64
+
+typedef enum {
+    HAL_DISP_CHANNEL_DHD0 = 0,
+    HAL_DISP_CHANNEL_DHD1 = 1,
+    HAL_DISP_CHANNEL_WBC = 2,
+    HAL_DISP_CHANNEL_DSD0 = 3,
+    HAL_DISP_CHANNEL_BUTT
+} hal_disp_outputchannel;
+
+typedef enum {
+    HAL_DISP_LAYER_VHD0 = 0,
+    HAL_DISP_LAYER_VHD1 = 1,
+    HAL_DISP_LAYER_VHD2 = 2,
+    HAL_DISP_LAYER_VSD0 = 3,
+    HAL_DISP_LAYER_GFX0 = 4, /* fb0 */
+    HAL_DISP_LAYER_GFX1 = 5, /* fb2 */
+    HAL_DISP_LAYER_HC0 = 6,  /* G2 is HC0 fb3 */
+    HAL_DISP_LAYER_HC1 = 7,  /* G3 is HC1 fb4 */
+    HAL_DISP_LAYER_GFX4 = 8, /* fb1 */
+    HAL_DISP_LAYER_WBC_G0 = 9,
+    HAL_DISP_LAYER_WBC_G4 = 10,
+    HAL_DISP_LAYER_WBC_D = 11,
+    HAL_DISP_LAYER_TT = 12,
+    HAL_DISP_LAYER_WBC = 13,
+
+    HAL_DISP_LAYER_BUTT,
+    HAL_DISP_INVALID_LAYER = -1
+} hal_disp_layer;
+
+#define HAL_DISP_LAYER_GFX2 HAL_DISP_LAYER_HC0
+#define HAL_DISP_LAYER_GFX3 HAL_DISP_LAYER_HC1
+
+#define LAYER_VHD_START HAL_DISP_LAYER_VHD0
+#define LAYER_VHD_END   HAL_DISP_LAYER_VHD0
+#define LAYER_VSD_START HAL_DISP_LAYER_VSD0
+#define LAYER_VSD_END   HAL_DISP_LAYER_VSD0
+#define LAYER_GFX_START HAL_DISP_LAYER_GFX0
+#define LAYER_GFX_END   HAL_DISP_LAYER_GFX0
+#define LAYER_WBC_START HAL_DISP_LAYER_WBC_D
+#define LAYER_WBC_END   HAL_DISP_LAYER_WBC_D
+
+typedef enum {
+    HAL_DISP_INTERLACE = 0,
+    HAL_DISP_PROGRESSIVE = 1,
+    HAL_DISP_TOP,
+    HAL_DISP_BOTTOM,
+
+    HAL_DISP_DATARMODE_BUTT
+} hal_disp_datarmode;
+
+typedef enum {
+    HAL_INPUTFMT_Y_CB_CR_SEMIPLANAR_400 = 0x1,
+    HAL_INPUTFMT_Y_CB_CR_SEMIPLANAR_411_1X4 = 0x2,
+    HAL_INPUTFMT_Y_CB_CR_SEMIPLANAR_420 = 0x3,
+    HAL_INPUTFMT_Y_CB_CR_SEMIPLANAR_422 = 0x4,
+    HAL_INPUTFMT_Y_CB_CR_SEMIPLANAR_422_1X2 = 0x4,
+    HAL_INPUTFMT_Y_CB_CR_SEMIPLANAR_444 = 0x5,
+    HAL_INPUTFMT_Y_CB_CR_SEMIPLANAR_411_4X1 = 0x6,
+    HAL_INPUTFMT_Y_CB_CR_SEMIPLANAR_422_2X1 = 0x7,
+
+    HAL_INPUTFMT_CB_Y_CR_Y_PACKAGE_422 = 0x9,
+    HAL_INPUTFMT_Y_CB_Y_CR_PACKAGE_422 = 0xa,
+    HAL_INPUTFMT_Y_CR_Y_CB_PACKAGE_422 = 0xb,
+    HAL_INPUTFMT_Y_CB_CR_PACKAGE_444 = 0x1000,
+
+    HAL_INPUTFMT_CLUT_1BPP = 0x00,
+    HAL_INPUTFMT_CLUT_2BPP = 0x10,
+    HAL_INPUTFMT_CLUT_4BPP = 0x20,
+    HAL_INPUTFMT_CLUT_8BPP = 0x30,
+    HAL_INPUTFMT_ACLUT_44 = 0x38,
+
+    HAL_INPUTFMT_RGB_444 = 0x40,
+    HAL_INPUTFMT_RGB_555 = 0x41,
+    HAL_INPUTFMT_RGB_565 = 0x42,
+    HAL_INPUTFMT_CB_Y_CR_Y_PACKAGE_422_GRC = 0x43,
+    HAL_INPUTFMT_Y_CB_Y_CR_PACKAGE_422_GRC = 0x44,
+    HAL_INPUTFMT_Y_CR_Y_CB_PACKAGE_422_GRC = 0x45,
+    HAL_INPUTFMT_ACLUT_88 = 0x46,
+    HAL_INPUTFMT_ARGB_4444 = 0x48,
+    HAL_INPUTFMT_ARGB_1555 = 0x49,
+
+    HAL_INPUTFMT_RGB_888 = 0x50,
+    HAL_INPUTFMT_Y_CB_CR_888 = 0x51,
+    HAL_INPUTFMT_ARGB_8565 = 0x5a,
+    HAL_INPUTFMT_ARGB_6666 = 0x5b,
+
+    HAL_INPUTFMT_KRGB_888 = 0x60,
+    HAL_INPUTFMT_ARGB_8888 = 0x68,
+    HAL_INPUTFMT_A_Y_Cb_CR_8888 = 0x69,
+
+    HAL_INPUTFMT_RGBA_4444 = 0xc8,
+    HAL_INPUTFMT_RGBA_5551 = 0xc9,
+
+    HAL_INPUTFMT_RGBA_6666 = 0xd8,
+    HAL_INPUTFMT_RGBA_5658 = 0xda,
+
+    HAL_INPUTFMT_RGBA_8888 = 0xe8,
+    HAL_INPUTFMT_Y_CB_CR_A_8888 = 0xe9,
+
+    HAL_DISP_PIXELFORMAT_BUTT
+} hal_disp_pixel_format;
+
+typedef enum {
+    HAL_DISP_INTFDATAFMT_SPCBYCRY_422 = 0x0,
+    HAL_DISP_INTFDATAFMT_SPYCBYCR_422 = 0x1,
+    HAL_DISP_INTFDATAFMT_SPYCRYCB_422 = 0x2,
+
+    HAL_DISP_INTFDATAFMT_ARGB8888 = 0x3,
+    HAL_DISP_INTFDATAFMT_YCBCR420 = 0x4,
+    HAL_DISP_INTFDATAFMT_YCBCR422 = 0x5,
+
+    HAL_DISP_INTFDATAFMT_BUTT
+} hal_disp_intfdatafmt;
+
+typedef enum {
+    VDP_PROC_FMT_SP_420 = 0x0,
+    VDP_PROC_FMT_SP_422 = 0x1,
+    VDP_PROC_FMT_SP_444 = 0x2,
+    VDP_PROC_FMT_RGB_888 = 0x3,
+    VDP_PROC_FMT_RGB_444 = 0x4,
+
+    VDP_PROC_FMT_BUTT
+} vdp_proc_fmt;
+
+typedef enum {
+    HAL_CS_UNKNOWN = 0,
+    HAL_CS_BT601,
+    HAL_CS_BT709,
+    HAL_CS_RGB,
+    HAL_CS_BUTT
+} hal_cs;
+
+typedef enum {
+    HAL_CSC_MODE_NONE = 0,
+
+    HAL_CSC_MODE_BT601_TO_BT601,
+    HAL_CSC_MODE_BT709_TO_BT709,
+    HAL_CSC_MODE_RGB_TO_RGB,
+
+    HAL_CSC_MODE_BT601_TO_BT709,
+    HAL_CSC_MODE_BT709_TO_BT601,
+
+    HAL_CSC_MODE_BT601_TO_RGB_PC,
+    HAL_CSC_MODE_BT709_TO_RGB_PC,
+    HAL_CSC_MODE_BT2020_TO_RGB_PC,
+    HAL_CSC_MODE_RGB_TO_BT601_PC,
+    HAL_CSC_MODE_RGB_TO_BT709_PC,
+    HAL_CSC_MODE_RGB_TO_BT2020_PC,
+
+    HAL_CSC_MODE_BT601_TO_RGB_TV,
+    HAL_CSC_MODE_BT709_TO_RGB_TV,
+    HAL_CSC_MODE_RGB_TO_BT601_TV,
+    HAL_CSC_MODE_RGB_TO_BT709_TV,
+
+    HAL_CSC_MODE_BUTT
+} hal_csc_mode;
+
+typedef enum {
+    HAL_DISP_BIT_WIDTH_1 = 0x0,
+    HAL_DISP_BIT_WIDTH_2 = 0x1,
+    HAL_DISP_BIT_WIDTH_3 = 0x2,
+    HAL_DISP_BIT_WIDTH_BUTT
+} hal_disp_bit_width;
+
+typedef enum {
+    HAL_CCD_IMGID_INVALID,
+    HAL_CCD_IMGID_1080P60,
+    HAL_CCD_IMGID_1080P30_ODD,
+    HAL_CCD_IMGID_1080P30_EVEN,
+} hal_ccd_imgid;
+
+typedef enum {
+    HAL_T_FIRST = 0,
+    HAL_B_FIRST = 1,
+
+    HAL_VHD_FOD_BUTT
+} hal_vhd_fod;
+
+/* vou coef load mode */
+typedef enum {
+    HAL_DISP_COEFMODE_HORL = 0,
+    HAL_DISP_COEFMODE_HORC,
+    HAL_DISP_COEFMODE_VERL,
+    HAL_DISP_COEFMODE_VERC,
+    HAL_DISP_COEFMODE_LUT,
+    HAL_DISP_COEFMODE_GAM,
+    HAL_DISP_COEFMODE_ACC,
+    HAL_DISP_COEFMODE_ALL
+} hal_disp_coefmode;
+
+/* vou zoom mode */
+typedef enum {
+    HAL_DISP_ZMEMODE_HORL = 0,
+    HAL_DISP_ZMEMODE_HORC,
+    HAL_DISP_ZMEMODE_VERL,
+    HAL_DISP_ZMEMODE_VERC,
+
+    HAL_DISP_ZMEMODE_HOR,
+    HAL_DISP_ZMEMODE_VER,
+    HAL_DISP_ZMEMODE_ALPHA,
+    HAL_DISP_ZMEMODE_ALPHAV,
+    HAL_DISP_ZMEMODE_VERT,
+    HAL_DISP_ZMEMODE_VERB,
+
+    HAL_DISP_ZMEMODE_ALL,
+    HAL_DISP_ZMEMODE_NONL,
+    HAL_DISP_ZMEMODE_BUTT
+} hal_disp_zmemode;
+
+typedef enum {
+    HAL_DISP_ZME_OUTFMT420 = 0,
+    HAL_DISP_ZME_OUTFMT422,
+    HAL_DISP_ZME_OUTFMT444,
+    HAL_DISP_ZME_OUTFMT_BUTT
+} hal_disp_zme_outfmt;
+
+/* vou CBM MIXER */
+typedef enum {
+    HAL_CBMMIX1 = 0,
+    HAL_CBMMIX2,
+    HAL_CBMMIX3,
+
+    HAL_CBMMIX1_BUTT
+} hal_cbmmix;
+
+/* vou graphic layer data extend mode */
+typedef enum {
+    HAL_GFX_BITEXTEND_1ST = 0,
+    HAL_GFX_BITEXTEND_2ND = 0x2,
+    HAL_GFX_BITEXTEND_3RD = 0x3,
+
+    HAL_GFX_BITEXTEND_BUTT
+} hal_gfx_bitextend;
+
+/* vou acm block id information */
+typedef enum {
+    HAL_ACMBLK_ID0,
+    HAL_ACMBLK_ID1,
+    HAL_ACMBLK_ID2,
+    HAL_ACMBLK_ID3,
+
+    HAL_ACMBLK_ALL,
+
+    HAL_ACMBLK_BUTT
+} hal_acmblk_id;
+
+typedef enum {
+    HAL_DAC_SEL_HDDATE = 0x0,
+    HAL_DAC_SEL_VGA = 0x01,
+} hal_dac_sel;
+
+typedef enum {
+    HAL_DISP_SYNC_MODE_TIMING = 0x0,
+    HAL_DISP_SYNC_MODE_SIGNAL = 0x1,
+    HAL_DISP_SYNC_MODE_BUTT
+} hal_disp_sync_mode;
+
+typedef enum {
+    HAL_GFX_LINE_TYPE_HYBRID,
+    HAL_GFX_LINE_TYPE_VLC,
+    HAL_GFX_LINE_TYPE_FLC,
+
+    HAL_GFX_LINE_TYPE_BUTT,
+} hal_gfx_linetype;
+
+typedef enum {
+    HAL_GFX_LINE_LEN_128,
+    HAL_GFX_LINE_LEN_256,
+    HAL_GFX_LINE_LEN_512,
+    HAL_GFX_LINE_LEN_ALLLINE,
+
+    HAL_GFX_LINE_LEN_BUTT,
+} hal_gfx_linelen;
+
+/* RM frame or filed infomation */
+typedef enum {
+    HAL_IFIRMODE_DISEN = 0,
+    HAL_IFIRMODE_COPY,
+    HAL_IFIRMODE_DOUBLE,
+    HAL_IFIRMODE_6TAPFIR,
+
+    HAL_IFIRMODE_BUTT
+} hal_ifirmode;
+
+typedef enum {
+    HAL_HFIRMODE_MEDEN = 0,
+    HAL_HFIRMODE_COPY,
+    HAL_HFIRMODE_DOUBLE,
+    HAL_HFIRMODE_6TAPFIR,
+
+    HAL_HFIRMODE_BUTT
+} hal_hfirmode;
+
+/* vou mixer prio id */
+typedef enum {
+    HAL_DISP_MIX_PRIO0 = 0,
+    HAL_DISP_MIX_PRIO1,
+    HAL_DISP_MIX_PRIO2,
+    HAL_DISP_MIX_PRIO3,
+    HAL_DISP_MIX_BUTT
+} hal_disp_mix_prio;
+
+/* LTI/CTI mode */
+typedef enum {
+    HAL_DISP_TIMODE_LUM = 0,
+    HAL_DISP_TIMODE_CHM,
+
+    HAL_DISP_TIMODE_ALL,
+    HAL_DISP_TIMODE_NON,
+    HAL_DISP_TIMODE_BUTT,
+} hal_disp_timode;
+
+typedef struct {
+    gk_u32 synm;
+    gk_u32 iop;
+    gk_u8 intfb;
+
+    gk_u16 vact;
+    gk_u16 vbb;
+    gk_u16 vfb;
+
+    gk_u16 hact;
+    gk_u16 hbb;
+    gk_u16 hfb;
+    gk_u16 hmid;
+
+    gk_u16 bvact;
+    gk_u16 bvbb;
+    gk_u16 bvfb;
+
+    gk_u16 hpw;
+    gk_u16 vpw;
+
+    gk_u32 idv;
+    gk_u32 ihs;
+    gk_u32 ivs;
+} hal_disp_syncinfo;
+
+typedef struct {
+    gk_u32 dither_sed_y0;
+    gk_u32 dither_sed_u0;
+    gk_u32 dither_sed_v0;
+    gk_u32 dither_sed_w0;
+
+    gk_u32 dither_sed_y1;
+    gk_u32 dither_sed_u1;
+    gk_u32 dither_sed_v1;
+    gk_u32 dither_sed_w1;
+
+    gk_u32 dither_sed_y2;
+    gk_u32 dither_sed_u2;
+    gk_u32 dither_sed_v2;
+    gk_u32 dither_sed_w2;
+
+    gk_u32 dither_sed_y3;
+    gk_u32 dither_sed_u3;
+    gk_u32 dither_sed_v3;
+    gk_u32 dither_sed_w3;
+} hal_disp_dihter_sed;
+
+typedef enum {
+    /* the numbers are to define the enum, not magic numbers */
+    HAL_DISP_INTF_CVBS = (0x01L << 0),
+    HAL_DISP_INTF_HDDATE = (0x01L << 1),
+    HAL_DISP_INTF_VGA = (0x01L << 2),
+    HAL_DISP_INTF_BT656 = (0x01L << 3),
+    HAL_DISP_INTF_BT1120 = (0x01L << 4),
+    HAL_DISP_INTF_HDMI = (0x01L << 5),
+    HAL_DISP_INTF_LCD = (0x01L << 6),
+    HAL_DISP_INTF_DATE = (0x01L << 7),
+    HAL_DISP_INTF_LCD_6BIT = (0x01L << 9),
+    HAL_DISP_INTF_LCD_8BIT = (0x01L << 10),
+    HAL_DISP_INTF_LCD_16BIT = (0x01L << 11),
+    HAL_DISP_INTF_LCD_18BIT = (0x01L << 12),
+    HAL_DISP_INTF_LCD_24BIT = (0x01L << 13),
+    HAL_DISP_INTF_MIPI = (0x01L << 14),
+    HAL_DISP_INTF_BUTT = (0x01L << 15),
+} hal_disp_intf;
+
+typedef struct {
+    gk_u32 f_inv;
+    gk_u32 vs_inv;
+    gk_u32 hs_inv;
+    gk_u32 dv_inv;
+} hal_disp_syncinv;
+
+typedef enum {
+    HAL_MULTICHN_EN_1P1C = 0x1,
+    HAL_MULTICHN_EN_2P1C = 0x2,
+} hal_multi_chn;
+
+/* vou background color */
+typedef struct {
+    gk_u16 bkg_a;
+    gk_u16 bkg_y;
+    gk_u16 bkg_cb;
+    gk_u16 bkg_cr;
+} hal_disp_bkcolor;
+
+typedef struct {
+    gk_u16 clip_low_y;
+    gk_u16 clip_low_cb;
+    gk_u16 clip_low_cr;
+
+    gk_u16 clip_high_y;
+    gk_u16 clip_high_cb;
+    gk_u16 clip_high_cr;
+} hal_disp_clip;
+
+typedef struct {
+    gk_s32 x;
+    gk_s32 y;
+    gk_u32 width;
+    gk_u32 height;
+} gk_rect;
+
+typedef struct {
+    gk_u32 fbdiv;
+    gk_u32 frac;
+    gk_u32 refdiv;
+    gk_u32 postdiv1;
+    gk_u32 postdiv2;
+} vo_user_intfsync_pll;
+
+typedef enum {
+    VO_CLK_SOURCE_PLL = 0,
+    VO_CLK_SOURCE_LCDMCLK,
+    VO_CLK_SOURCE_BUTT
+} vo_clk_source;
+
+typedef struct {
+    vo_clk_source clk_source;
+    union {
+        vo_user_intfsync_pll user_sync_pll;
+        gk_u32 lcd_m_clk_div;
+    };
+} vo_user_intfsync_attr;
+
+typedef struct {
+    vo_user_intfsync_attr user_intf_sync_attr;
+    gk_u32 pre_div;
+    gk_u32 dev_div;
+    gk_bool clk_reverse;
+} vo_user_intfsync_info;
+
+#ifdef __cplusplus
+}
+#endif /* end of #ifdef __cplusplus */
+#endif /* end of __VOU_DEF_H__ */
+
diff -uraN u-boot-2016.11/product/osd/vo/gk7205v200/vou_drv.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/vou_drv.c
--- u-boot-2016.11/product/osd/vo/gk7205v200/vou_drv.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/vou_drv.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,1334 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#include "vou_drv.h"
+#include "type.h"
+#include "vou_reg.h"
+#include "vou_def.h"
+#include "vou_hal.h"
+#include "vou_coef_org.h"
+
+#define VO_DEV_MAX_NUM   1
+#define VO_LAYER_MAX_NUM 1
+
+#define VO_SD_VTTH_WATERLINE 100
+#define VO_HD_VTTH_WATERLINE 240
+
+#define VO_BACKGROUD_BLACK   0x8080
+#define VO_BACKGROUD_GREEN   0x804D3A42
+#define VO_BACKGROUD_WHITE   0x3fffffff
+#define VO_BACKGROUD_DEFAULT VO_BACKGROUD_WHITE
+
+#define max2(x, y)       ((x) > (y) ? (x) : (y))
+#define min2(x, y)       ((x) < (y) ? (x) : (y))
+#define clip_min(x, min) (((x) >= (min)) ? (x) : (min))
+
+static gk_u32 rgb_to_yuv_full(gk_u32 rgb)
+{
+    gk_u16 y, u, v;
+    gk_u16 r, g, b;
+    gk_u16 py_temp, pcb_temp, pcr_temp;
+
+    r = rgb_r(rgb);
+    g = rgb_g(rgb);
+    b = rgb_b(rgb);
+
+    /* to calculate rgb to yc, the numbers is from algorithm, not magic numbers */
+    py_temp = (gk_u16)(((r * 76 + g * 150 + b * 29) >> 8) * 4);
+    pcb_temp = (gk_u16)(clip_min(((((b * 130 - r * 44) - g * 86) >> 8) + 128), 0) * 4);
+    pcr_temp = (gk_u16)(clip_min(((((r * 130 - g * 109) - b * 21) >> 8) + 128), 0) * 4);
+
+    /* value 0 - 1023 */
+    y = max2(min2(py_temp, 1023), 0);
+    u = max2(min2(pcb_temp, 1023), 0);
+    v = max2(min2(pcr_temp, 1023), 0);
+
+    return yuv(y, u, v);
+}
+
+/* vou interrupt mask type */
+typedef enum {
+    VO_INTMSK_NONE = 0,
+    VO_INTMSK_DHD0_VTTHD1 = 0x1,
+    VO_INTMSK_DHD0_VTTHD2 = 0x2,
+    VO_INTMSK_DHD0_VTTHD3 = 0x4,
+    VO_INTMSK_DHD0_UFINT = 0x8,
+
+    VO_INTMSK_DHD1_VTTHD1 = 0x10,
+    VO_INTMSK_DHD1_VTTHD2 = 0x20,
+    VO_INTMSK_DHD1_VTTHD3 = 0x40,
+    VO_INTMSK_DHD1_UFINT = 0x80,
+
+    VO_INTMSK_DSD_VTTHD1 = 0x100,
+    VO_INTMSK_DSD_VTTHD2 = 0x200,
+    VO_INTMSK_DSD_VTTHD3 = 0x400,
+    VO_INTMSK_DSD_UFINT = 0x800,
+
+    VO_INTMSK_B0_ERR = 0x1000,
+    VO_INTMSK_B1_ERR = 0x2000,
+    VO_INTMSK_B2_ERR = 0x4000,
+
+    VO_INTMSK_WBC_DHDOVER = 0x8000,
+
+    VO_INTREPORT_ALL = 0xffffffff
+} vo_int_mask;
+
+typedef struct {
+    gk_bool enable;
+    gk_u32 bk_grd;
+    vo_intf_type intf_type;
+    vo_intf_sync out_sync;
+    hal_disp_pixel_format pixel_fmt;
+} hal_dev_config;
+
+typedef struct {
+    gk_u32 bk_grd;
+} hal_layer_config;
+
+typedef struct {
+    gk_s32 luma;
+    gk_s32 cont;
+    gk_s32 hue;
+    gk_s32 satu;
+} hal_csc_value;
+
+typedef struct {
+    gk_u32 base_phys;
+    gk_void *base_virt;
+    gk_u32 hor;
+    gk_u32 ver422;
+    gk_u32 ver420;
+    gk_u32 lut;
+    gk_u32 gam;
+    gk_u32 acc;
+} hal_coef_addr;
+
+vo_user_intfsync_info g_user_intfsync_info = {
+    .dev_div = 1,
+    .clk_reverse = GK_TRUE,
+    .user_intf_sync_attr = {
+        .clk_source = VO_CLK_SOURCE_LCDMCLK,
+        .lcd_m_clk_div = 0xC5E41,
+    }
+};
+
+/* user time default value */
+hal_disp_syncinfo g_user_sync_timing = {
+    .synm = 0,
+    .iop = 1,
+    .intfb = 1,
+    .vact = 480,
+    .vbb = 4,
+    .vfb = 8,
+    .hact = 320,
+    .hbb = 8,
+    .hfb = 38,
+    .hmid = 1,
+    .bvact = 240,
+    .bvbb = 14,
+    .bvfb = 9,
+    .hpw = 4,
+    .vpw = 4,
+    .idv = 0,
+    .ihs = 1,
+    .ivs = 1,
+};
+
+hal_disp_syncinfo g_sync_timing[VO_OUTPUT_BUTT] = {
+    /* synm, iop, itf,   vact, vbb,  vfb,  hact,  hbb,  hfb, hmid,bvact,bvbb, bvfb, hpw, vpw,idv, ihs, ivs */
+    { 0, 0, 0, 288,  22, 2,  720,  132, 12,   1,    288, 23, 2, 126, 3,  0, 0, 0 }, /* 576I(PAL)  */
+    { 0, 0, 0, 240,  18, 4,  720,  119, 19,   1,    240, 19, 4, 124, 3,  0, 0, 0 }, /* 480I(NTSC) */
+    { 0, 1, 1, 1080, 41, 4,  1920, 192, 638,  1,    1,   1,  1, 44,  5,  0, 0, 0 }, /* 1080P@24Hz */
+    { 0, 1, 1, 1080, 41, 4,  1920, 192, 528,  1,    1,   1,  1, 44,  5,  0, 0, 0 }, /* 1080P@25Hz */
+    { 0, 1, 1, 1080, 41, 4,  1920, 192, 88,   1,    1,   1,  1, 44,  5,  0, 0, 0 }, /* 1080P@30Hz */
+    { 0, 1, 1, 720,  25, 5,  1280, 260, 440,  1,    1,   1,  1, 40,  5,  0, 0, 0 }, /* 720P@50Hz */
+    { 0, 1, 1, 720,  25, 5,  1280, 260, 110,  1,    1,   1,  1, 40,  5,  0, 0, 0 }, /* 720P@60Hz */
+    { 0, 0, 1, 540,  20, 2,  1920, 192, 528,  1128, 540, 21, 2, 44,  5,  0, 0, 0 }, /* 1080I@50Hz */
+    { 0, 0, 1, 540,  20, 2,  1920, 192, 88,   908,  540, 21, 2, 44,  5,  0, 0, 0 }, /* 1080I@60Hz */
+    { 0, 1, 1, 1080, 41, 4,  1920, 192, 528,  1,    1,   1,  1, 44,  5,  0, 0, 0 }, /* 1080P@50Hz */
+    { 0, 1, 1, 1080, 41, 4,  1920, 192, 88,   1,    1,   1,  1, 44,  5,  0, 0, 0 }, /* 1080P@60Hz */
+    { 1, 1, 1, 576,  44, 5,  720,  132, 12,   1,    1,   1,  1, 64,  5,  0, 0, 0 }, /* 576P@50Hz */
+    { 1, 1, 1, 480,  36, 9,  720,  122, 16,   1,    1,   1,  1, 62,  6,  0, 0, 0 }, /* 480P@60Hz */
+    { 1, 1, 2, 600,  27, 1,  800,  216, 40,   1,    1,   1,  1, 128, 4,  0, 0, 0 }, /* 800*600@60Hz VGA@60Hz */
+    { 1, 1, 2, 768,  35, 3,  1024, 296, 24,   1,    1,   1,  1, 136, 6,  0, 1, 1 }, /* 1024x768@60Hz */
+    { 1, 1, 2, 1024, 41, 1,  1280, 360, 48,   1,    1,   1,  1, 112, 3,  0, 0, 0 }, /* 1280x1024@60Hz */
+    { 1, 1, 2, 768,  27, 3,  1366, 356, 70,   1,    1,   1,  1, 143, 3,  0, 0, 0 }, /* 1366x768@60Hz */
+    { 1, 1, 2, 900,  31, 3,  1440, 384, 80,   1,    1,   1,  1, 152, 6,  0, 1, 0 }, /* 1440x900@60Hz */
+    { 1, 1, 2, 800,  28, 3,  1280, 328, 72,   1,    1,   1,  1, 128, 6,  0, 1, 0 }, /* 1280*800@60Hz VGA@60Hz */
+    { 1, 1, 2, 1200, 49, 1,  1600, 496, 64,   1,    1,   1,  1, 192, 3,  0, 0, 0 }, /* 1600*1200@60Hz */
+    { 1, 1, 2, 1050, 36, 3,  1680, 456, 104,  1,    1,   1,  1, 176, 6,  0, 1, 0 }, /* 1680*1050@60Hz */
+    /* 1920*1200@60Hz CVT (reduced blanking) */
+    { 1, 1, 2, 1200, 32, 3,  1920, 112, 48,   1,    1,   1,  1, 32,  6,  0, 0, 1 },
+    { 1, 1, 2, 480,  35, 10, 640,  144, 16,   1,    1,   1,  1, 96,  2,  0, 1, 1 }, /* 640*480@60Hz CVT */
+    { 0, 0, 0, 288,  22, 2,  960,  176, 16,   1,    288, 23, 2, 168, 3,  0, 0, 0 }, /* 960H(PAL) */
+    { 0, 0, 0, 240,  18, 4,  960,  163, 21,   1,    240, 19, 4, 168, 3,  0, 0, 0 }, /* 960H(NTSC) */
+    { 0, 1, 1, 2160, 72, 8,  1920, 192, 88,   1,    1,   1,  1, 44,  5,  0, 0, 0 }, /* 1920*2160@30Hz */
+    { 1, 1, 2, 1440, 39, 2,  2560, 112, 48,   1,    1,   1,  1, 32,  5,  0, 0, 0 }, /* 2560*1440@30Hz */
+    { 1, 1, 2, 1440, 39, 2,  2560, 112, 48,   1,    1,   1,  1, 32,  5,  0, 0, 0 }, /* 2560*1440@60Hz */
+    /* 2560*1600@60Hz CVT (reduced blanking) */
+    { 0, 1, 2, 1600, 43, 3,  2560, 112, 48,   1,    1,   1,  1, 32,  6,  0, 0, 1 },
+    { 0, 1, 1, 2160, 82, 8,  3840, 384, 1276, 1,    1,   1,  1, 88,  10, 0, 0, 0 }, /* 3840*2160@24Hz */
+    { 0, 1, 1, 2160, 82, 8,  3840, 384, 1056, 1,    1,   1,  1, 88,  10, 0, 0, 0 }, /* 3840*2160@25Hz */
+    { 0, 1, 1, 2160, 82, 8,  3840, 384, 176,  1,    1,   1,  1, 88,  10, 0, 0, 0 }, /* 3840*2160@30Hz */
+    { 0, 1, 1, 2160, 82, 8,  3840, 384, 1056, 1,    1,   1,  1, 88,  10, 0, 0, 0 }, /* 3840*2160@50Hz */
+    { 0, 1, 1, 2160, 82, 8,  3840, 384, 176,  1,    1,   1,  1, 88,  10, 0, 0, 0 }, /* 3840*2160@60Hz */
+    { 0, 1, 1, 2160, 82, 8,  4096, 384, 1020, 1,    1,   1,  1, 88,  10, 0, 0, 0 }, /* 4096x2160@24 */
+    { 0, 1, 1, 2160, 82, 8,  4096, 216, 968,  1,    1,   1,  1, 88,  10, 0, 0, 0 }, /* 4096x2160@25 */
+    { 0, 1, 1, 2160, 82, 8,  4096, 216, 88,   1,    1,   1,  1, 88,  10, 0, 0, 0 }, /* 4096x2160@30 */
+    { 0, 1, 1, 2160, 82, 8,  4096, 216, 968,  1,    1,   1,  1, 88,  10, 0, 0, 0 }, /* 4096x2160@50 */
+    { 0, 1, 1, 2160, 82, 8,  4096, 216, 88,   1,    1,   1,  1, 88,  10, 0, 0, 0 }, /* 4096x2160@60 */
+    { 0, 1, 1, 240,  15, 9,  320,  65,  7,    1,    240, 14, 9, 1,   1,  0, 0, 0 }, /* 320X240@60  8bit LCD */
+    { 0, 1, 1, 240,  2,  2,  320,  5,   10,   1,    1,   1,  1, 10,  1,  0, 0, 0 }, /* 320X240@50  6bit LCD */
+    { 0, 1, 1, 320,  10, 4,  240,  30,  10,   1,    1,   1,  1, 10,  2,  0, 0, 0 }, /* 240X320@50  6bit LCD */
+    { 0, 1, 1, 320,  2,  2,  240,  20,  10,   1,    1,   1,  1, 2,   1,  0, 0, 0 }, /* 240X320@60 16bit LCD */
+    { 0, 1, 1, 600,  23, 12, 800,  210, 46,   1,    1,   1,  1, 2,   1,  0, 0, 0 }, /* 800X600@60 24bit LCD */
+    { 0, 1, 1, 1280, 24, 8,  720,  123, 99,   1,    1,   1,  1, 24,  4,  0, 0, 0 }, /* 720 x1280 at 60 hz */
+    { 0, 1, 1, 1920, 36, 16, 1080, 28,  130,  1,    1,   1,  1, 8,   10, 0, 0, 0 }, /* 1080 x1920 at 60 hz */
+    { 0, 1, 1, 4320, 64, 16, 7680, 768, 552,  1,    1,   1,  1, 176, 20, 0, 0, 0 }, /* 7680x4320@30 */
+    {}                                                                              /* user */
+};
+
+static hal_dev_config g_hal_dev_cfg[VO_DEV_MAX_NUM] = {
+    {
+        .enable = GK_FALSE,
+        .bk_grd = VO_BACKGROUD_DEFAULT,
+        .intf_type = VO_INTF_BT1120 | VO_INTF_LCD,
+        .out_sync = VO_OUTPUT_1080P30,
+        .pixel_fmt = HAL_INPUTFMT_Y_CB_CR_SEMIPLANAR_422,
+    }
+};
+
+gk_void vo_drv_board_init(gk_void)
+{
+    hal_vo_init();
+    vo_drv_default_setting();
+}
+
+gk_void vo_drv_int_reg_up_mode(vo_hal_layer vo_layer, vo_int_mode int_mode)
+{
+    hal_video_set_layer_up_mode(vo_layer, int_mode);
+    return;
+}
+
+gk_void vo_drv_set_dev_intf_type(gk_s32 vo_dev, vo_intf_type intf_type)
+{
+    g_hal_dev_cfg[vo_dev].intf_type = intf_type;
+    return;
+}
+
+gk_void vo_drv_set_dev_bk_grd(gk_s32 vo_dev, gk_u32 bg_color)
+{
+    g_hal_dev_cfg[vo_dev].bk_grd = bg_color;
+    return;
+}
+
+gk_void vo_drv_set_dev_out_sync(gk_s32 vo_dev, vo_intf_sync vo_out_mode)
+{
+    g_hal_dev_cfg[vo_dev].out_sync = vo_out_mode;
+    return;
+}
+
+/* interrupt relative */
+gk_void vo_drv_dev_int_enable(vo_hal_dev vo_dev, gk_bool enable)
+{
+    vo_int_mask int_type;
+
+    switch (vo_dev) {
+        case VO_DEV_DHD0:
+            int_type = VO_INTMSK_DHD0_VTTHD1;
+            break;
+
+        default:
+            return;
+    }
+
+    if (enable == GK_TRUE) {
+        hal_disp_set_int_mask(int_type);
+    } else {
+        hal_disp_clr_int_mask(int_type);
+    }
+
+    return;
+}
+
+gk_void vo_drv_int_set_mode(gk_s32 vo_dev, vo_int_mode int_mode)
+{
+    hal_disp_set_vt_thd_mode(vo_dev, int_mode);
+    return;
+}
+
+gk_void vo_drv_layer_enable(vo_hal_layer vo_layer, gk_bool enable)
+{
+    hal_layer_enable_layer(vo_layer, enable);
+    return;
+}
+
+gk_void vo_drv_def_layer_bind_dev(gk_void)
+{
+    hal_cbm_set_cbm_mixer_prio(HAL_DISP_LAYER_VHD0, VO_MIX_PRIO0, HAL_CBMMIX1);
+    hal_cbm_set_cbm_mixer_prio(HAL_DISP_LAYER_GFX0, VO_MIX_PRIO1, HAL_CBMMIX1);
+    return;
+}
+
+gk_void vo_drv_set_dev_clk(vo_hal_dev vo_dev)
+{
+    /* the numbers below is the default value of the register. */
+    gk_bool clk_en = GK_FALSE;
+    gk_u32 vdp_out_clk_sel = 0x0;
+    gk_u32 vdp_hd_clk_sel = 0x0;
+    gk_u32 lcd_mclk_div = 0x00FFFFF;
+    switch (g_hal_dev_cfg[vo_dev].out_sync) {
+        /* the number is pll register config, calculate from out sync */
+        case VO_OUTPUT_PAL:
+        case VO_OUTPUT_NTSC:
+        case VO_OUTPUT_576P50:
+        case VO_OUTPUT_480P60: {
+            /* 27MHz */
+            vdp_out_clk_sel = 0xa;
+            break;
+        }
+
+        case VO_OUTPUT_1080P24:
+        case VO_OUTPUT_1080P25:
+        case VO_OUTPUT_1080P30:
+        case VO_OUTPUT_720P50:
+        case VO_OUTPUT_720P60:
+        case VO_OUTPUT_1080I50:
+        case VO_OUTPUT_1080I60:
+        case VO_OUTPUT_720x1280_60: {
+            /* 74.25MHz */
+            vdp_out_clk_sel = 0x8;
+            break;
+        }
+
+        case VO_OUTPUT_1080P50:
+        case VO_OUTPUT_1080P60:
+        case VO_OUTPUT_1920x2160_30:
+        case VO_OUTPUT_1080x1920_60: {
+            /* 148.5MHz */
+            vdp_out_clk_sel = 0x0;
+            break;
+        }
+
+        case VO_OUTPUT_640x480_60: {
+            /* 25.175MHz */
+            vdp_out_clk_sel = 0x5;
+            vdp_hd_clk_sel = 0x0;
+            lcd_mclk_div = 0x1cac08;
+            clk_en = GK_TRUE;
+            break;
+        }
+
+        case VO_OUTPUT_800x600_60: {
+            /* 40MHz */
+            vdp_out_clk_sel = 0x5;
+            vdp_hd_clk_sel = 0x0;
+            lcd_mclk_div = 0x2d45b3;
+            clk_en = GK_TRUE;
+            break;
+        }
+
+        case VO_OUTPUT_1024x768_60: {
+            /* 65MHz */
+            vdp_out_clk_sel = 0x5;
+            vdp_hd_clk_sel = 0x0;
+            lcd_mclk_div = 0x49f369;
+            clk_en = GK_TRUE;
+            break;
+        }
+
+        case VO_OUTPUT_1280x1024_60: {
+            /* 108MHz */
+            vdp_out_clk_sel = 0x5;
+            vdp_hd_clk_sel = 0x0;
+            lcd_mclk_div = 0x7ad6ef;
+            clk_en = GK_TRUE;
+            break;
+        }
+
+        case VO_OUTPUT_1366x768_60: {
+            /* 85.5MHz */
+            vdp_out_clk_sel = 0x5;
+            vdp_hd_clk_sel = 0x0;
+            lcd_mclk_div = 0x619f57;
+            clk_en = GK_TRUE;
+            break;
+        }
+
+        case VO_OUTPUT_1280x800_60: {
+            /* 83.5MHz */
+            vdp_out_clk_sel = 0x5;
+            vdp_hd_clk_sel = 0x0;
+            lcd_mclk_div = 0x5f4e44;
+            clk_en = GK_TRUE;
+            break;
+        }
+
+        case VO_OUTPUT_320x240_60: {
+            /* lcd clk config */
+            vdp_out_clk_sel = 0x5;
+            vdp_hd_clk_sel = 0x3;
+            lcd_mclk_div = 0x1c4255;
+            clk_en = GK_TRUE;
+            break;
+        }
+
+        case VO_OUTPUT_320x240_50: {
+            /* lcd clk config */
+            vdp_out_clk_sel = 0x5;
+            vdp_hd_clk_sel = 0x2;
+            lcd_mclk_div = 0xdf346;
+            clk_en = GK_TRUE;
+            break;
+        }
+
+        case VO_OUTPUT_240x320_50: {
+            /* lcd clk config */
+            vdp_out_clk_sel = 0x5;
+            vdp_hd_clk_sel = 0x2;
+            lcd_mclk_div = 0xff5f3;
+            clk_en = GK_TRUE;
+            break;
+        }
+
+        case VO_OUTPUT_240x320_60: {
+            /* lcd clk config */
+            vdp_out_clk_sel = 0x5;
+            vdp_hd_clk_sel = 0x0;
+            lcd_mclk_div = 0x5f8d2;
+            clk_en = GK_TRUE;
+            break;
+        }
+
+        case VO_OUTPUT_USER: {
+            if (vo_dev == 0) {
+                if (g_user_intfsync_info.user_intf_sync_attr.clk_source == VO_CLK_SOURCE_LCDMCLK) {
+                    /* LCD_MCLK_DIV */
+                    vdp_out_clk_sel = 0x5; /* 0x5 register value for lcd */
+                    sys_hal_vo_out_clk_sel(vdp_out_clk_sel);
+                    /* configuring the clock */
+                    sys_hal_lcd_mclk_div(g_user_intfsync_info.user_intf_sync_attr.lcd_m_clk_div);
+                    sys_hal_vo_lcd_clk_en(GK_TRUE);
+                } else if (g_user_intfsync_info.user_intf_sync_attr.clk_source == VO_CLK_SOURCE_PLL) {
+                    printf("vo_dev(%d) clk source %d illegal.\n", vo_dev,
+                           g_user_intfsync_info.user_intf_sync_attr.clk_source);
+                }
+            } else {
+                printf("VO dev %d is illegal\n", vo_dev);
+            }
+
+            sys_hal_vo_hd_out_pctrl(g_user_intfsync_info.clk_reverse);
+            sys_hal_vo_hd0_div_mode(g_user_intfsync_info.dev_div - 1);
+
+            if ((VO_INTF_LCD_6BIT & g_hal_dev_cfg[vo_dev].intf_type) ||
+                (VO_INTF_LCD_8BIT & g_hal_dev_cfg[vo_dev].intf_type)) {
+                if (g_user_intfsync_info.dev_div == 3) { /* div 3 */
+                    hal_disp_set_lcd_serial_perd(0);
+                } else {
+                    hal_disp_set_lcd_serial_perd(1);
+                }
+            }
+            return;
+            break;
+        }
+
+        default: {
+            return;
+        }
+    }
+
+    sys_hal_vo_lcd_clk_en(clk_en);
+    sys_hal_lcd_mclk_div(lcd_mclk_div);
+    sys_hal_vo_hd0_div_mode(vdp_hd_clk_sel);
+    sys_hal_vo_out_clk_sel(vdp_out_clk_sel);
+
+    return;
+}
+
+static gk_bool vo_drv_get_dither_io_mode(gk_u32 dither_io_mode,
+    gk_u32 *dither_mode,
+    gk_u32 *i_data_width_dither,
+    gk_u32 *o_data_width_dither)
+{
+    if (dither_io_mode == DITHER_IO_MODE_12_10) {
+        *dither_mode           = DITHER_MODE_10BIT;
+        *i_data_width_dither   = DITHER_IWIDTH_MODE_12BIT;
+        *o_data_width_dither   = DITHER_OWIDTH_MODE_10BIT;
+    } else if (dither_io_mode == DITHER_IO_MODE_12_8) {
+        *dither_mode           = DITHER_MODE_8BIT;
+        *i_data_width_dither   = DITHER_IWIDTH_MODE_12BIT;
+        *o_data_width_dither   = DITHER_OWIDTH_MODE_8BIT;
+    } else if (dither_io_mode == DITHER_IO_MODE_10_8) {
+        *dither_mode           = DITHER_MODE_8BIT;
+        *i_data_width_dither   = DITHER_IWIDTH_MODE_10BIT;
+        *o_data_width_dither   = DITHER_OWIDTH_MODE_8BIT;
+    } else if (dither_io_mode == DITHER_IO_MODE_10_6) {
+        *dither_mode           = DITHER_MODE_8BIT;
+        *i_data_width_dither   = DITHER_IWIDTH_MODE_10BIT;
+        *o_data_width_dither   = DITHER_OWIDTH_MODE_6BIT;
+    } else if (dither_io_mode == DITHER_IO_MODE_9_6) {
+        *dither_mode           = DITHER_MODE_8BIT;
+        *i_data_width_dither   = DITHER_IWIDTH_MODE_9BIT;
+        *o_data_width_dither   = DITHER_OWIDTH_MODE_6BIT;
+    } else if (dither_io_mode == DITHER_IO_MODE_8_6) {
+        *dither_mode           = DITHER_MODE_8BIT;
+        *i_data_width_dither   = DITHER_IWIDTH_MODE_8BIT;
+        *o_data_width_dither   = DITHER_OWIDTH_MODE_6BIT;
+    } else if (dither_io_mode == 0) {
+        *dither_mode           = DITHER_MODE_8BIT;
+        *i_data_width_dither   = DITHER_IWIDTH_MODE_8BIT;
+        *o_data_width_dither   = DITHER_OWIDTH_MODE_6BIT;
+    } else {
+        return GK_FALSE;
+    }
+
+    return GK_TRUE;
+}
+
+static gk_void vo_drv_get_dither_sed(hal_disp_dihter_sed *tmp_sed)
+{
+    /* number is from algorithm, not magic number */
+    tmp_sed->dither_sed_y0 = 2147483647;
+    tmp_sed->dither_sed_u0 = 2147482647;
+    tmp_sed->dither_sed_v0 = 2147481647;
+    tmp_sed->dither_sed_w0 = 2147480647;
+    tmp_sed->dither_sed_y1 = tmp_sed->dither_sed_y0;
+    tmp_sed->dither_sed_u1 = tmp_sed->dither_sed_u0;
+    tmp_sed->dither_sed_v1 = tmp_sed->dither_sed_v0;
+    tmp_sed->dither_sed_w1 = tmp_sed->dither_sed_w0;
+    tmp_sed->dither_sed_y2 = tmp_sed->dither_sed_y0;
+    tmp_sed->dither_sed_u2 = tmp_sed->dither_sed_u0;
+    tmp_sed->dither_sed_v2 = tmp_sed->dither_sed_v0;
+    tmp_sed->dither_sed_w2 = tmp_sed->dither_sed_w0;
+    tmp_sed->dither_sed_y3 = tmp_sed->dither_sed_y0;
+    tmp_sed->dither_sed_u3 = tmp_sed->dither_sed_u0;
+    tmp_sed->dither_sed_v3 = tmp_sed->dither_sed_v0;
+    tmp_sed->dither_sed_w3 = tmp_sed->dither_sed_w0;
+
+    return;
+}
+
+gk_void vo_drv_set_dev_dither_mode(vo_hal_dev vo_dev, vdp_dither_mode drv_dither_mode, vdp_dither_cfg *cfg)
+{
+    hal_disp_outputchannel vo_channel;
+    hal_disp_dihter_sed dither_sed;
+    gk_u32 dither_round_unlim;
+    gk_u32 i_data_width_dither = 0;
+    gk_u32 o_data_width_dither = 0;
+    gk_u32 dither_en;
+    gk_u32 dither_io_mode;
+    gk_u32 dither_mode = 0;
+    gk_u32 dither_round;
+    gk_u32 dither_domain_mode;
+    gk_u32 dither_tap_mode;
+    gk_u32 dither_thr_max = 0;
+    gk_u32 dither_thr_min = 0;
+    gk_bool ret = GK_FALSE;
+
+    dither_en = cfg->dither_en;
+    dither_round = cfg->dither_round;
+    dither_round_unlim = cfg->dither_round_unlim;
+    dither_domain_mode = cfg->dither_domain_mode;
+    dither_tap_mode = cfg->dither_tap_mode;
+    dither_io_mode = cfg->dither_io_mode;
+
+    ret = vo_drv_get_dither_io_mode(dither_io_mode, &dither_mode, &i_data_width_dither, &o_data_width_dither);
+    if (ret == GK_FALSE) {
+        return;
+    }
+
+    if (drv_dither_mode == VDP_DITHER_MODE_TYP) {
+        vo_drv_get_dither_sed(&dither_sed);
+        dither_thr_max = 60000; /* 60000 max */
+        dither_thr_min = 120; /* 120 min */
+    } else {
+        return;
+    }
+
+    vo_channel = HAL_DISP_CHANNEL_DHD0;
+    hal_disp_set_dither_round_unlim(vo_channel, dither_round_unlim);
+    hal_disp_set_dither_data_in_out(vo_channel, i_data_width_dither, o_data_width_dither);
+    hal_disp_set_dither_en(vo_channel, dither_en);
+    hal_disp_set_dither_mode(vo_channel, dither_mode);
+    hal_disp_set_dither_round(vo_channel, dither_round);
+    hal_disp_set_dither_domain_mode(vo_channel, dither_domain_mode);
+    hal_disp_set_dither_tap_mode(vo_channel, dither_tap_mode);
+    hal_disp_set_dither_sed(vo_channel, &dither_sed);
+    hal_disp_set_dither_thr_min_max(vo_channel, dither_thr_min, dither_thr_max);
+}
+
+gk_void vo_drv_set_dev_dither_cfg(vo_hal_dev vo_dev, gk_u32 in_bit_widht, gk_u32 out_bit_widht)
+{
+    vdp_dither_cfg dither_cfg;
+
+    if ((in_bit_widht == 10) && (out_bit_widht == 8)) { /* 10bit 8bit */
+        /* the numbers below are register config, not magic number. */
+        dither_cfg.dither_en = 1;
+        dither_cfg.dither_round = 1;
+        dither_cfg.dither_round_unlim = 1;
+        dither_cfg.dither_domain_mode = 1;
+        dither_cfg.dither_tap_mode = 1;
+        dither_cfg.dither_io_mode = DITHER_IO_MODE_12_8;
+
+        vo_drv_set_dev_dither_mode(vo_dev, VDP_DITHER_MODE_TYP, &dither_cfg);
+        hal_disp_set_dither_en(vo_dev, GK_TRUE);
+        hal_disp_set_dither_data_in_out(vo_dev, 0x4, 0x5);  /* 4:12bit 5:10bit;3:8bit */
+    } else if ((in_bit_widht == 10) && (out_bit_widht == 6)) { /* 10bit 6bit */
+        /* the numbers below are register config, not magic number. */
+        dither_cfg.dither_en = 1;
+        dither_cfg.dither_round = 0;
+        dither_cfg.dither_round_unlim = 1;
+        dither_cfg.dither_domain_mode = 1;
+        dither_cfg.dither_tap_mode = 1;
+        dither_cfg.dither_io_mode = DITHER_IO_MODE_10_6;
+        vo_drv_set_dev_dither_mode(vo_dev, VDP_DITHER_MODE_TYP, &dither_cfg);
+        hal_disp_set_dither_en(vo_dev, GK_TRUE);
+        hal_disp_set_dither_data_in_out(vo_dev, 0x2, 0x1); /* 4:12bit 5:10bit;3:8bit */
+    } else if (((in_bit_widht == 10) && (out_bit_widht == 10)) || /* 10bit */
+               ((in_bit_widht == 8) && (out_bit_widht == 8))) { /* 8bit */
+        hal_disp_set_dither_en(vo_dev, GK_FALSE);
+    }
+}
+
+gk_u32 vo_drv_get_dev_vtth(vo_hal_dev vo_dev)
+{
+    gk_u32 dev_vtth;
+
+    switch (g_hal_dev_cfg[vo_dev].out_sync) {
+        case VO_OUTPUT_3840x2160_60:
+        case VO_OUTPUT_3840x2160_50:
+        case VO_OUTPUT_4096x2160_60:
+        case VO_OUTPUT_4096x2160_50:
+            dev_vtth = 4 * VO_HD_VTTH_WATERLINE; /* 4 times of default */
+            break;
+
+        case VO_OUTPUT_2560x1600_60:
+        case VO_OUTPUT_3840x2160_24:
+        case VO_OUTPUT_3840x2160_25:
+        case VO_OUTPUT_3840x2160_30:
+        case VO_OUTPUT_4096x2160_24:
+        case VO_OUTPUT_4096x2160_25:
+        case VO_OUTPUT_4096x2160_30:
+            dev_vtth = 2 * VO_HD_VTTH_WATERLINE; /* 2 times of default */
+            break;
+
+        default:
+            dev_vtth = VO_HD_VTTH_WATERLINE;
+    }
+
+    return dev_vtth;
+}
+
+/* turn on clk */
+gk_void vo_drv_set_all_crg_clk(gk_bool clk_en)
+{
+    gk_bool vo_clk_en = clk_en;
+
+    sys_hal_vo_dev_clk_en(0, vo_clk_en); /* dev 0 */
+    sys_hal_vo_core_clk_en(0, vo_clk_en); /* dev 0 */
+    sys_hal_vo_cfg_clk_en(vo_clk_en);
+    sys_hal_vo_apb_clk_en(vo_clk_en);
+    sys_hal_vo_bus_clk_en(vo_clk_en);
+    return;
+}
+
+gk_u32 vo_drv_get_dev_intf_type(vo_hal_dev vo_dev)
+{
+    return g_hal_dev_cfg[vo_dev].intf_type;
+}
+
+void vo_drv_set_cbm_bkg(gk_s32 vo_dev)
+{
+    hal_disp_bkcolor bkg;
+    vo_intf_type intf_type;
+    gk_u32 yuv_bk_grd = 0;
+    hal_dev_config *hal_dev_cfg = &g_hal_dev_cfg[vo_dev];
+
+    intf_type = hal_dev_cfg->intf_type;
+
+    if ((VO_INTF_LCD_6BIT & intf_type) ||
+        (VO_INTF_LCD_8BIT & intf_type) ||
+        (VO_INTF_LCD_16BIT & intf_type)) {
+        bkg.bkg_y = rgb_r(hal_dev_cfg->bk_grd);
+        bkg.bkg_cb = rgb_g(hal_dev_cfg->bk_grd);
+        bkg.bkg_cr = rgb_b(hal_dev_cfg->bk_grd);
+        /* for 30bit register. */
+        bkg.bkg_y = bkg.bkg_y << 2; /* 2 to turn 8 to 10 value */
+        bkg.bkg_cb = bkg.bkg_cb << 2; /* 2 to turn 8 to 10 value */
+        bkg.bkg_cr = bkg.bkg_cr << 2; /* 2 to turn 8 to 10 value */
+    } else {
+        yuv_bk_grd = rgb_to_yuv_full(hal_dev_cfg->bk_grd);
+        bkg.bkg_y = yuv_y(yuv_bk_grd);
+        bkg.bkg_cb = yuv_u(yuv_bk_grd);
+        bkg.bkg_cr = yuv_v(yuv_bk_grd);
+    }
+
+    hal_cbm_set_cbm_bkg(HAL_CBMMIX1, &bkg);
+}
+
+void vo_drv_get_intf_property(gk_s32 vo_dev, hal_disp_syncinfo *sync_info, hal_disp_syncinv *inv)
+{
+    hal_dev_config *hal_dev_cfg = &g_hal_dev_cfg[vo_dev];
+
+    if (hal_dev_cfg->out_sync != VO_OUTPUT_USER) {
+        memcpy(sync_info, &g_sync_timing[hal_dev_cfg->out_sync], sizeof(hal_disp_syncinfo));
+    } else {
+        memcpy(sync_info, &g_user_sync_timing, sizeof(hal_disp_syncinfo));
+    }
+
+    /* the numbers below are register config, not magic number. */
+    inv->hs_inv = sync_info->ihs ? 1 : 0;
+    inv->vs_inv = sync_info->ivs ? 1 : 0;
+    inv->dv_inv = sync_info->idv ? 1 : 0;
+}
+
+void vo_drv_set_intf_bt1120_cfg(gk_s32 vo_dev, hal_disp_syncinfo *sync_info, hal_disp_syncinv *inv)
+{
+    sys_hal_vo_bt_clk_en(GK_TRUE);
+
+    hal_disp_set_intf_mux_sel(vo_dev, VO_INTF_BT1120);
+    hal_intf_bt_set_dfir_en(0x1);  /* 0x1 enable */
+}
+
+void vo_drv_set_intf_bt656_cfg(gk_s32 vo_dev, hal_disp_syncinfo *sync_info, hal_disp_syncinv *inv, gk_u32 *div_mod)
+{
+    sys_hal_vo_bt_clk_en(GK_TRUE);
+
+    /* the numbers below are register config, not magic number. */
+    hal_disp_set_intf_mux_sel(vo_dev, VO_INTF_BT656);
+    hal_intf_bt_set_dfir_en(0x1);
+    *div_mod = 1;
+}
+
+void vo_drv_set_intf_lcd_cfg(gk_s32 vo_dev, hal_disp_syncinfo *sync_info, hal_disp_syncinv *inv, gk_u32 *div_mod)
+{
+    hal_dev_config *hal_dev_cfg = &g_hal_dev_cfg[vo_dev];
+    U_INTF_LCD_CTRL LCD_CTRL;
+    vo_intf_type intf_type;
+    gk_u32 data_mode = 0x0;
+    vo_intf_sync out_sync;
+
+    intf_type = hal_dev_cfg->intf_type;
+    out_sync = hal_dev_cfg->out_sync;
+
+    sys_hal_vo_bt_clk_en(GK_TRUE);
+    sys_hal_vo_lcd_clk_en(GK_TRUE);
+    hal_disp_set_intf_mux_sel(vo_dev, intf_type);
+
+    if (VO_INTF_LCD_8BIT & intf_type) {
+        /* the numbers below are register config, not magic number. */
+        *div_mod = 3; /* 3 register config */
+        data_mode = 1;
+        LCD_CTRL.bits.hdmi_mode = 1;
+        LCD_CTRL.bits.lcd_serial_mode = 1;
+        LCD_CTRL.bits.lcd_serial_perd = 1;
+        LCD_CTRL.bits.lcd_parallel_order = 0;
+        LCD_CTRL.bits.lcd_data_inv = 0;
+        LCD_CTRL.bits.lcd_parallel_mode = 1;  /* 0:RGB565, 1:RGB888 */
+    } else if (VO_INTF_LCD_6BIT & intf_type) {
+        /* the numbers below are register config, not magic number. */
+        *div_mod = 2; /* 2 register config */
+        data_mode = 0;
+
+        LCD_CTRL.bits.lcd_serial_mode = 1;
+        LCD_CTRL.bits.lcd_serial_perd = 0;
+        LCD_CTRL.bits.lcd_parallel_order = 0;
+        LCD_CTRL.bits.lcd_data_inv = 0;
+        LCD_CTRL.bits.lcd_parallel_mode = 0;
+    } else if (VO_INTF_LCD_16BIT & intf_type) {
+        /* the numbers below are register config, not magic number. */
+        *div_mod = 0;
+        data_mode = 2; /* 2 register config */
+
+        LCD_CTRL.bits.lcd_serial_mode = 0;
+        LCD_CTRL.bits.lcd_serial_perd = 0;
+        LCD_CTRL.bits.lcd_parallel_order = 0;
+        LCD_CTRL.bits.lcd_data_inv = 0;
+        LCD_CTRL.bits.lcd_parallel_mode = 1;
+    }
+
+    sys_hal_lcd_data_mode(data_mode);
+    hal_disp_set_intf_ctrl(intf_type, &(LCD_CTRL.u32));
+
+    if (out_sync != VO_OUTPUT_USER) {
+        hal_disp_set_lcd_serial_perd(LCD_CTRL.bits.lcd_serial_perd);
+    }
+}
+
+void vo_drv_set_intf_cfg(gk_s32 vo_dev, hal_disp_syncinfo *sync_info, hal_disp_syncinv *inv, gk_u32 *div_mod)
+{
+    hal_dev_config *hal_dev_cfg = &g_hal_dev_cfg[vo_dev];
+    vo_intf_type intf_type;
+
+    intf_type = hal_dev_cfg->intf_type;
+
+    if (VO_INTF_BT1120 & hal_dev_cfg->intf_type) {
+        vo_drv_set_intf_bt1120_cfg(vo_dev, sync_info, inv);
+    }
+
+    if (VO_INTF_BT656 & intf_type) {
+        vo_drv_set_intf_bt656_cfg(vo_dev, sync_info, inv, div_mod);
+    }
+
+    if ((VO_INTF_LCD_6BIT & intf_type) ||
+        (VO_INTF_LCD_8BIT & intf_type) ||
+        (VO_INTF_LCD_16BIT & intf_type)) {
+        vo_drv_set_intf_lcd_cfg(vo_dev, sync_info, inv, div_mod);
+    }
+}
+
+void vo_drv_set_dev_multichn(gk_s32 vo_dev)
+{
+    hal_multi_chn multi_chn_en = HAL_MULTICHN_EN_1P1C;
+    hal_disp_set_dev_multi_chn_en(vo_dev, multi_chn_en);
+}
+
+void vo_drv_set_dev_clip_by_intf(gk_s32 vo_dev)
+{
+    hal_dev_config *hal_dev_cfg = &g_hal_dev_cfg[vo_dev];
+    vo_intf_type intf_type;
+
+    intf_type = hal_dev_cfg->intf_type;
+
+    if (VO_INTF_BT1120 & intf_type) {
+        const hal_disp_clip clip_data = { 0x40, 0x40, 0x40, 0x3ac, 0x3c0, 0x3c0 }; /* clip register config */
+        hal_disp_set_intf_clip(VO_INTF_BT1120, GK_TRUE, &clip_data);
+    }
+
+    if (VO_INTF_BT656 & intf_type) {
+        const hal_disp_clip clip_data = { 0x40, 0x40, 0x40, 0x3ac, 0x3c0, 0x3c0 }; /* clip register config */
+        hal_disp_set_intf_clip(VO_INTF_BT656, GK_TRUE, &clip_data);
+    }
+}
+void vo_drv_set_dev_int_mode(gk_s32 vo_dev, hal_disp_syncinfo *sync_info)
+{
+    vo_int_mode int_mode;
+
+    if (sync_info->iop == 0) {
+        int_mode = VO_INT_MODE_FIELD;
+    } else {
+        int_mode = VO_INT_MODE_FRAME;
+    }
+
+    vo_drv_int_set_mode(vo_dev, int_mode);
+    vo_drv_int_reg_up_mode(vo_dev, int_mode);
+}
+
+void vo_drv_set_dev_out_pctrl(gk_s32 vo_dev)
+{
+    hal_dev_config *hal_dev_cfg = &g_hal_dev_cfg[vo_dev];
+    vo_intf_sync out_sync;
+    gk_bool clk_reverse = GK_TRUE;
+
+    out_sync = hal_dev_cfg->out_sync;
+
+    if (out_sync != VO_OUTPUT_USER) {
+        sys_hal_vo_hd_out_pctrl(clk_reverse);
+    }
+}
+
+void vo_drv_set_dev_div_mod(gk_s32 vo_dev, gk_u32 div_mod)
+{
+    hal_dev_config *hal_dev_cfg = &g_hal_dev_cfg[vo_dev];
+    vo_intf_sync out_sync;
+
+    out_sync = hal_dev_cfg->out_sync;
+
+    if (out_sync != VO_OUTPUT_USER) {
+        if (vo_dev == 0) {
+            sys_hal_vo_hd0_div_mode(div_mod);
+        }
+    }
+}
+
+void vo_drv_set_dev_dither(gk_s32 vo_dev)
+{
+    hal_dev_config *hal_dev_cfg = &g_hal_dev_cfg[vo_dev];
+    vo_intf_type intf_type;
+
+    intf_type = hal_dev_cfg->intf_type;
+    if ((VO_INTF_LCD_6BIT & intf_type) ||
+        (VO_INTF_LCD_16BIT & intf_type)) {
+        vo_drv_set_dev_dither_cfg(vo_dev, 10, 6); /* 10 to 6 */
+    } else {
+        vo_drv_set_dev_dither_cfg(vo_dev, 10, 8); /* 10 to 8 */
+    }
+}
+
+gk_void vo_drv_open(gk_s32 vo_dev)
+{
+    hal_disp_syncinfo sync_info;
+    gk_u16 vtth_line;
+    hal_disp_syncinv inv = {0};
+    gk_u32 div_mode = 0;
+
+    vo_drv_set_all_crg_clk(GK_TRUE);
+    hal_disp_set_intf_enable(vo_dev, GK_FALSE);
+
+    sys_hal_vo_dev_clk_en(0, GK_TRUE);
+    sys_hal_vo_out_clk_en(0, GK_TRUE);
+
+    vo_drv_set_cbm_bkg(vo_dev);
+
+    /* set interface property */
+    vo_drv_get_intf_property(vo_dev, &sync_info, &inv);
+
+    vo_drv_set_intf_cfg(vo_dev, &sync_info, &inv, &div_mode);
+
+    vo_drv_set_dev_out_pctrl(vo_dev);
+    vo_drv_set_dev_div_mod(vo_dev, div_mode);
+
+    hal_disp_set_intf_sync(vo_dev, &sync_info, &inv);
+    vo_drv_set_dev_multichn(vo_dev);
+
+    /* set clip */
+    vo_drv_set_dev_clip_by_intf(vo_dev);
+
+    vo_drv_set_dev_int_mode(vo_dev, &sync_info);
+
+    vtth_line = sync_info.vact + sync_info.vfb + sync_info.vbb - 1 - vo_drv_get_dev_vtth(vo_dev);
+    hal_disp_set_vt_thd(vo_dev, vtth_line);
+
+    /* dither config */
+    vo_drv_set_dev_dither(vo_dev);
+
+    hal_disp_set_intf_enable(vo_dev, GK_TRUE);
+    vo_drv_dev_int_enable(vo_dev, GK_TRUE);
+    hal_disp_set_reg_up(vo_dev);
+    g_hal_dev_cfg[vo_dev].enable = GK_TRUE;
+
+    return;
+}
+
+gk_void vo_drv_close(gk_s32 vo_dev)
+{
+    gk_u32 i;
+
+    hal_disp_set_intf_enable(vo_dev, GK_FALSE);
+    hal_disp_set_reg_up(vo_dev);
+
+    hal_disp_set_intf_mux_sel(vo_dev, HAL_DISP_INTF_BUTT);
+
+    g_hal_dev_cfg[vo_dev].enable = GK_FALSE;
+
+    for (i = 0; i < VO_DEV_MAX_NUM; i++) {
+        if (g_hal_dev_cfg[vo_dev].enable) {
+            break;
+        }
+    }
+
+    if (i == VO_DEV_MAX_NUM) {
+        vo_drv_set_all_crg_clk(GK_FALSE);
+    }
+
+    return;
+}
+
+gk_void vo_drv_default_setting(gk_void)
+{
+    hal_layer_set_layer_galpha(HAL_DISP_LAYER_VHD0, 255);  /* 255 max alpha */
+    vo_drv_layer_enable(HAL_DISP_LAYER_VHD0, GK_FALSE);
+
+    return;
+}
+
+gk_void vo_drv_func_get_cvfir_pq_cfg(vo_zme_ds_info *ds_info, vo_zme_mode zme_mode,
+                                     vo_zme_comm_pq_cfg *comm_pq_cfg)
+{
+    gk_u32 zme_vprec;
+    /* the zme num is from algorithm, not magic num */
+    if (zme_mode == VO_ZME_TYP) {
+        zme_vprec = ds_info->zme_vprec;
+        comm_pq_cfg->vluma_offset = 0;
+        comm_pq_cfg->vchroma_offset = 0;
+        comm_pq_cfg->vbluma_offset = MIN_OFFSET * (gk_s32)zme_vprec / 2;
+        comm_pq_cfg->vbchroma_offset = MIN_OFFSET * (gk_s32)zme_vprec / 2;
+        comm_pq_cfg->vl_flatdect_mode = 1;
+        comm_pq_cfg->vl_coringadj_en = 1;
+        comm_pq_cfg->vl_gain = 32;
+        comm_pq_cfg->vl_coring = 16;
+        comm_pq_cfg->vc_flatdect_mode = 1;
+        comm_pq_cfg->vc_coringadj_en = 1;
+        comm_pq_cfg->vc_gain = 32;
+        comm_pq_cfg->vc_coring = 16;
+        comm_pq_cfg->lhfir_offset = 0;
+        comm_pq_cfg->chfir_offset = 0;
+        comm_pq_cfg->hl_flatdect_mode = 1;
+        comm_pq_cfg->hl_coringadj_en = 1;
+        comm_pq_cfg->hl_gain = 32;
+        comm_pq_cfg->hl_coring = 16;
+        comm_pq_cfg->hc_flatdect_mode = 1;
+        comm_pq_cfg->hc_coringadj_en = 1;
+        comm_pq_cfg->hc_gain = 32;
+        comm_pq_cfg->hc_coring = 16;
+    }
+}
+
+static gk_void vo_drv_set_layer_cvfir_mode(gk_u32 layer, vo_zme_mode zme_mode, const vdp_v1_cvfir_cfg *cfg)
+{
+    gk_u32 vzme_ck_gt_en;
+    gk_u32 out_pro;
+    gk_u32 out_fmt;
+    gk_u32 out_height;
+    gk_u32 cvfir_en;
+    gk_u32 cvmid_en;
+    gk_u32 cvfir_mode;
+    gk_u32 vratio;
+    gk_u32 vchroma_offset;
+    gk_u32 vbchroma_offset;
+    vo_zme_ds_info ds_info = {0};
+    vo_zme_comm_pq_cfg comm_pq_cfg = {0};
+
+    ds_info.zme_vprec = ZME_VPREC;
+    ds_info.zme_hprec = ZME_HPREC;
+
+    vzme_ck_gt_en = cfg->ck_gt_en;
+    cvfir_en = cfg->cvfir_en;
+    cvfir_mode = cfg->cvfir_mode;
+    cvmid_en = cfg->cvmid_en;
+
+    out_pro = cfg->out_pro;
+    out_fmt = cfg->out_fmt;
+    out_height = cfg->in_height;
+    vratio = ds_info.zme_vprec;
+
+    vo_drv_func_get_cvfir_pq_cfg(&ds_info, zme_mode, &comm_pq_cfg);
+
+    vchroma_offset = comm_pq_cfg.vchroma_offset;
+    vbchroma_offset = comm_pq_cfg.vbchroma_offset;
+
+    hal_video_cvfir_set_out_height(layer, out_height);
+    hal_video_cvfir_set_out_fmt(layer, out_fmt);
+    hal_video_cvfir_set_out_pro(layer, out_pro);
+    hal_video_cvfir_set_vzme_ck_gt_en(layer, vzme_ck_gt_en);
+
+    hal_video_cvfir_set_cvfir_en(layer, cvfir_en);
+    hal_video_cvfir_set_cvmid_en(layer, cvmid_en);
+    hal_video_cvfir_set_cvfir_mode(layer, cvfir_mode);
+    hal_video_cvfir_set_vratio(layer, vratio);
+
+    hal_video_cvfir_set_v_chroma_offset(layer, vchroma_offset);
+    hal_video_cvfir_set_vb_chroma_offset(layer, vbchroma_offset);
+}
+
+gk_void vo_vid_set_zme_enable(gk_u32 layer, const vdp_vid_ip_cfg *vid_cfg)
+{
+    /* the numbers below are register config from algorithm, not magic number. */
+    vdp_v1_cvfir_cfg cvfir_cfg;
+    cvfir_cfg.hfir_order = 0;
+    cvfir_cfg.lhfir_en = 0;
+    cvfir_cfg.chfir_en = 0;
+    cvfir_cfg.lhmid_en = 0;
+    cvfir_cfg.chmid_en = 0;
+    cvfir_cfg.lhfir_mode = 0;
+    cvfir_cfg.chfir_mode = 0;
+    cvfir_cfg.hl_shootctrl_en = 0;
+    cvfir_cfg.hl_shootctrl_mode = 0;
+    cvfir_cfg.hc_shootctrl_en = 0;
+    cvfir_cfg.hc_shootctrl_mode = 0;
+    cvfir_cfg.lvfir_en = 0;
+    cvfir_cfg.lvmid_en = 0;
+    cvfir_cfg.lvfir_mode = 0;
+    cvfir_cfg.vl_shootctrl_en = 0;
+    cvfir_cfg.vl_shootctrl_mode = 0;
+    cvfir_cfg.vc_shootctrl_en = 0;
+    cvfir_cfg.vc_shootctrl_mode = 0;
+
+    /* CVFIR */
+    cvfir_cfg.ck_gt_en = 0;
+    cvfir_cfg.cvfir_en = 1;
+    cvfir_cfg.cvmid_en = 0;
+    cvfir_cfg.cvfir_mode = 0;
+    cvfir_cfg.out_pro = VDP_RMODE_PROGRESSIVE;
+    cvfir_cfg.out_fmt = VDP_PROC_FMT_SP_422;
+    cvfir_cfg.in_width = vid_cfg->vid_iw;
+    cvfir_cfg.in_height = vid_cfg->vid_ih;
+    cvfir_cfg.out_width = vid_cfg->vid_ow;
+    cvfir_cfg.out_height = vid_cfg->vid_oh;
+    vo_drv_set_layer_cvfir_mode(layer, VO_ZME_TYP, &cvfir_cfg);
+}
+
+gk_s32 vo_drv_get_csc_matrix(hal_csc_mode csc_mode, const vo_csc_coef **csc_tmp)
+{
+    switch (csc_mode) {
+        case HAL_CSC_MODE_BT601_TO_BT601:
+        case HAL_CSC_MODE_BT709_TO_BT709:
+        case HAL_CSC_MODE_RGB_TO_RGB:
+            *csc_tmp = &g_csc_init;
+            break;
+
+        case HAL_CSC_MODE_BT709_TO_BT601:
+            *csc_tmp = &g_csc_yuv_to_yuv_709_601;
+            break;
+
+        case HAL_CSC_MODE_BT601_TO_BT709:
+            *csc_tmp = &g_csc_yuv_to_yuv_601_709;
+            break;
+
+        case HAL_CSC_MODE_BT601_TO_RGB_PC:
+            *csc_tmp = &g_csc_yuv601_to_rgb_pc;
+            break;
+
+        case HAL_CSC_MODE_BT709_TO_RGB_PC:
+            *csc_tmp = &g_csc_yuv709_to_rgb_pc;
+            break;
+
+        case HAL_CSC_MODE_RGB_TO_BT601_PC:
+            *csc_tmp = &g_csc_rgb_to_yuv601_pc;
+            break;
+
+        case HAL_CSC_MODE_RGB_TO_BT709_PC:
+            *csc_tmp = &g_csc_rgb_to_yuv709_pc;
+            break;
+
+        case HAL_CSC_MODE_RGB_TO_BT601_TV:
+            *csc_tmp = &g_csc_rgb_to_yuv601_tv;
+            break;
+
+        case HAL_CSC_MODE_RGB_TO_BT709_TV:
+            *csc_tmp = &g_csc_rgb_to_yuv709_tv;
+            break;
+
+        default:
+            return GK_FAILURE;
+    }
+
+    return GK_SUCCESS;
+}
+
+gk_void vo_drv_get_hal_cscvalue(const vo_csc *csc, hal_csc_value *csc_value)
+{
+    csc_value->luma = (gk_s32)csc->luma * 64 / 100 - 32; /* x64/100 -32 to adjust the value */
+    csc_value->cont = ((gk_s32)csc->contrast - 50) * 2 + 100; /* -50) * 2 + 100 to adjust the value */
+    csc_value->hue = (gk_s32)csc->hue * 60 / 100; /* x60/100 to adjust the value */
+    csc_value->satu = ((gk_s32)csc->satuature - 50) * 2 + 100; /* -50) * 2 + 100 to adjust the value */
+}
+
+gk_void vo_drv_set_csc_coef_y2r(const hal_csc_value *csc_value, const vo_csc_coef *csc_tmp, vo_csc_coef *csc_coef)
+{
+    gk_s32 luma;
+    gk_s32 contrast;
+    gk_s32 hue;
+    gk_s32 satu;
+
+    luma = csc_value->luma;
+    contrast = csc_value->cont;
+    hue = csc_value->hue;
+    satu = csc_value->satu;
+    /* 100 and 1000 is to adjust the coef */
+    csc_coef->csc_coef00 = (contrast * csc_tmp->csc_coef00) / 100;
+    csc_coef->csc_coef01 = (contrast * satu * ((csc_tmp->csc_coef01 * g_cos_table[hue] -
+                           csc_tmp->csc_coef02 * g_sin_table[hue]) / 1000)) / 10000;
+    csc_coef->csc_coef02 = (contrast * satu * ((csc_tmp->csc_coef01 * g_sin_table[hue] +
+                           csc_tmp->csc_coef02 * g_cos_table[hue]) / 1000)) / 10000;
+    csc_coef->csc_coef10 = (contrast * csc_tmp->csc_coef10) / 100;
+    csc_coef->csc_coef11 = (contrast * satu * ((csc_tmp->csc_coef11 * g_cos_table[hue] -
+                           csc_tmp->csc_coef12 * g_sin_table[hue]) / 1000)) / 10000;
+    csc_coef->csc_coef12 = (contrast * satu * ((csc_tmp->csc_coef11 * g_sin_table[hue] +
+                           csc_tmp->csc_coef12 * g_cos_table[hue]) / 1000)) / 10000;
+    csc_coef->csc_coef20 = (contrast * csc_tmp->csc_coef20) / 100;
+    csc_coef->csc_coef21 = (contrast * satu * ((csc_tmp->csc_coef21 * g_cos_table[hue] -
+                           csc_tmp->csc_coef22 * g_sin_table[hue]) / 1000)) / 10000;
+    csc_coef->csc_coef22 = (contrast * satu * ((csc_tmp->csc_coef21 * g_sin_table[hue] +
+                           csc_tmp->csc_coef22 * g_cos_table[hue]) / 1000)) / 10000;
+    csc_coef->csc_in_dc0 += (contrast != 0) ? (luma * 100 / contrast) : luma * 100;
+}
+
+gk_void vo_drv_set_csc_coef_r2y(hal_csc_value *csc_value, const vo_csc_coef *csc_tmp, vo_csc_coef *csc_coef)
+{
+    gk_s32 luma;
+    gk_s32 contrast;
+    gk_s32 hue;
+    gk_s32 satu;
+
+    luma = csc_value->luma;
+    contrast = csc_value->cont;
+    hue = csc_value->hue;
+    satu = csc_value->satu;
+
+    /* 100 and 1000 is to adjust the coef */
+    csc_coef->csc_coef00 = (contrast * csc_tmp->csc_coef00) / 100;
+    csc_coef->csc_coef01 = (contrast * csc_tmp->csc_coef01) / 100;
+    csc_coef->csc_coef02 = (contrast * csc_tmp->csc_coef02) / 100;
+    csc_coef->csc_coef10 = (contrast * satu * ((csc_tmp->csc_coef10 * g_cos_table[hue] +
+                           csc_tmp->csc_coef20 * g_sin_table[hue]) / 1000)) / 10000;
+    csc_coef->csc_coef11 = (contrast * satu * ((csc_tmp->csc_coef11 * g_cos_table[hue] +
+                           csc_tmp->csc_coef21 * g_sin_table[hue]) / 1000)) / 10000;
+    csc_coef->csc_coef12 = (contrast * satu * ((csc_tmp->csc_coef12 * g_cos_table[hue] +
+                           csc_tmp->csc_coef22 * g_sin_table[hue]) / 1000)) / 10000;
+    csc_coef->csc_coef20 = (contrast * satu * ((csc_tmp->csc_coef20 * g_cos_table[hue] -
+                           csc_tmp->csc_coef10 * g_sin_table[hue]) / 1000)) / 10000;
+    csc_coef->csc_coef21 = (contrast * satu * ((csc_tmp->csc_coef21 * g_cos_table[hue] -
+                           csc_tmp->csc_coef11 * g_sin_table[hue]) / 1000)) / 10000;
+    csc_coef->csc_coef22 = (contrast * satu * ((csc_tmp->csc_coef22 * g_cos_table[hue] -
+                           csc_tmp->csc_coef12 * g_sin_table[hue]) / 1000)) / 10000;
+    csc_coef->csc_out_dc0 += luma;
+}
+
+gk_void vo_drv_calc_csc_matrix(const vo_csc *csc, hal_csc_mode csc_mode, vo_csc_coef *cst_coef)
+{
+    const vo_csc_coef *csc_tmp = GK_NULL;
+    gk_s32 ret;
+    hal_csc_value csc_value = {0};
+
+    vo_drv_get_hal_cscvalue(csc, &csc_value);
+
+    ret = vo_drv_get_csc_matrix(csc_mode, &csc_tmp);
+    if (ret != GK_SUCCESS) {
+        return;
+    }
+
+    cst_coef->csc_in_dc0 = csc_tmp->csc_in_dc0;
+    cst_coef->csc_in_dc1 = csc_tmp->csc_in_dc1;
+    cst_coef->csc_in_dc2 = csc_tmp->csc_in_dc2;
+    cst_coef->csc_out_dc0 = csc_tmp->csc_out_dc0;
+    cst_coef->csc_out_dc1 = csc_tmp->csc_out_dc1;
+    cst_coef->csc_out_dc2 = csc_tmp->csc_out_dc2;
+
+    if ((csc_mode == HAL_CSC_MODE_BT601_TO_RGB_PC) || (csc_mode == HAL_CSC_MODE_BT709_TO_RGB_PC) ||
+        (csc_mode == HAL_CSC_MODE_BT601_TO_RGB_TV) || (csc_mode == HAL_CSC_MODE_BT709_TO_RGB_TV)) {
+        vo_drv_set_csc_coef_y2r(&csc_value, csc_tmp, cst_coef);
+    } else {
+        vo_drv_set_csc_coef_r2y(&csc_value, csc_tmp, cst_coef);
+    }
+
+    return;
+}
+
+gk_s32 graphic_drv_set_csc_coef(hal_disp_layer gfx_layer, const vo_csc *gfx_csc, const csc_coef_param *coef_param)
+{
+    vo_csc_coef coef;
+    hal_csc_mode csc_mode;
+
+    if (gfx_csc->csc_matrix == VO_CSC_MATRIX_IDENTITY) {
+        csc_mode = HAL_CSC_MODE_NONE;
+    } else if (gfx_csc->csc_matrix == VO_CSC_MATRIX_RGB_TO_BT601_PC) {
+        csc_mode = HAL_CSC_MODE_RGB_TO_BT601_PC;
+    } else if (gfx_csc->csc_matrix == VO_CSC_MATRIX_RGB_TO_BT709_PC) {
+        csc_mode = HAL_CSC_MODE_RGB_TO_BT709_PC;
+    } else {
+        printf("csc_matrix %d err, should only be RGB to yuv matrix\n", gfx_csc->csc_matrix);
+        return GK_FAILURE;
+    }
+
+    coef.new_csc_clip_max = GFX_CSC_CLIP_MAX;
+    coef.new_csc_clip_min = GFX_CSC_CLIP_MIN;
+    coef.new_csc_scale2p = GFX_CSC_SCALE;
+
+    hal_layer_set_csc_coef(gfx_layer, &coef);
+    hal_layer_csc_set_csc_mode(gfx_layer, csc_mode);
+
+    return GK_SUCCESS;
+}
+
+gk_void vo_drv_get_hal_cscmode(vo_csc_matrix csc_matrix, hal_csc_mode *csc_mode)
+{
+    switch (csc_matrix) {
+        case VO_CSC_MATRIX_IDENTITY:
+            *csc_mode = HAL_CSC_MODE_BT601_TO_BT601;
+            break;
+        case VO_CSC_MATRIX_BT601_TO_BT709:
+            *csc_mode = HAL_CSC_MODE_BT601_TO_BT709;
+            break;
+        case VO_CSC_MATRIX_BT709_TO_BT601:
+            *csc_mode = HAL_CSC_MODE_BT709_TO_BT601;
+            break;
+        case VO_CSC_MATRIX_BT601_TO_RGB_PC:
+            *csc_mode = HAL_CSC_MODE_BT601_TO_RGB_PC;
+            break;
+        case VO_CSC_MATRIX_BT709_TO_RGB_PC:
+            *csc_mode = HAL_CSC_MODE_BT709_TO_RGB_PC;
+            break;
+        case VO_CSC_MATRIX_RGB_TO_BT601_PC:
+            *csc_mode = HAL_CSC_MODE_RGB_TO_BT601_PC;
+            break;
+        case VO_CSC_MATRIX_RGB_TO_BT709_PC:
+            *csc_mode = HAL_CSC_MODE_RGB_TO_BT709_PC;
+            break;
+        default:
+            *csc_mode = HAL_CSC_MODE_BT601_TO_BT601;
+            break;
+    }
+}
+
+gk_s32 vo_drv_video_set_csc_coef(vo_hal_layer vo_layer, vo_csc_matrix csc_matrix)
+{
+    vo_csc_coef csc_coef;
+    hal_csc_mode csc_mode;
+    const gk_u32 dc_pre = 4;
+    vo_csc csc = {0};
+
+    /* 50 default value */
+    csc.contrast = 50;
+    csc.hue = 50;
+    csc.luma = 50;
+    csc.satuature = 50;
+
+    if ((vo_layer < LAYER_VHD_START) || (vo_layer > LAYER_VHD_END)) {
+        printf("[%s][%d] vo_layer:%d not supported\n", __FUNCTION__, __LINE__, vo_layer);
+        return GK_FAILURE;
+    }
+
+    vo_drv_get_hal_cscmode(csc_matrix, &csc_mode);
+
+    vo_drv_calc_csc_matrix(&csc, csc_mode, &csc_coef);
+
+    /* 0xfff 0x0 0x8 default value from algorithm */
+    csc_coef.new_csc_clip_max = 0xfff;
+    csc_coef.new_csc_clip_min = 0x0;
+    csc_coef.new_csc_scale2p = 0x8;
+
+    /* x1024/1000 is to adjust coef value */
+    csc_coef.csc_coef00 = csc_coef.csc_coef00 * 1024 / 1000;
+    csc_coef.csc_coef01 = csc_coef.csc_coef01 * 1024 / 1000;
+    csc_coef.csc_coef02 = csc_coef.csc_coef02 * 1024 / 1000;
+    csc_coef.csc_coef10 = csc_coef.csc_coef10 * 1024 / 1000;
+    csc_coef.csc_coef11 = csc_coef.csc_coef11 * 1024 / 1000;
+    csc_coef.csc_coef12 = csc_coef.csc_coef12 * 1024 / 1000;
+    csc_coef.csc_coef20 = csc_coef.csc_coef20 * 1024 / 1000;
+    csc_coef.csc_coef21 = csc_coef.csc_coef21 * 1024 / 1000;
+    csc_coef.csc_coef22 = csc_coef.csc_coef22 * 1024 / 1000;
+
+    /* 0x7ff is the max value */
+    csc_coef.csc_coef00 = (csc_coef.csc_coef00 > 0x7ff) ? 0x7ff : csc_coef.csc_coef00;
+    csc_coef.csc_coef01 = (csc_coef.csc_coef01 > 0x7ff) ? 0x7ff : csc_coef.csc_coef01;
+    csc_coef.csc_coef02 = (csc_coef.csc_coef02 > 0x7ff) ? 0x7ff : csc_coef.csc_coef02;
+    csc_coef.csc_coef10 = (csc_coef.csc_coef10 > 0x7ff) ? 0x7ff : csc_coef.csc_coef10;
+    csc_coef.csc_coef11 = (csc_coef.csc_coef11 > 0x7ff) ? 0x7ff : csc_coef.csc_coef11;
+    csc_coef.csc_coef12 = (csc_coef.csc_coef12 > 0x7ff) ? 0x7ff : csc_coef.csc_coef12;
+    csc_coef.csc_coef20 = (csc_coef.csc_coef20 > 0x7ff) ? 0x7ff : csc_coef.csc_coef20;
+    csc_coef.csc_coef21 = (csc_coef.csc_coef21 > 0x7ff) ? 0x7ff : csc_coef.csc_coef21;
+    csc_coef.csc_coef22 = (csc_coef.csc_coef22 > 0x7ff) ? 0x7ff : csc_coef.csc_coef22;
+
+    csc_coef.csc_in_dc0 = (gk_s32)csc_coef.csc_in_dc0;
+    csc_coef.csc_in_dc1 = (gk_s32)csc_coef.csc_in_dc1;
+    csc_coef.csc_in_dc2 = (gk_s32)csc_coef.csc_in_dc2;
+    csc_coef.csc_out_dc0 = (gk_s32)dc_pre * csc_coef.csc_out_dc0;
+    csc_coef.csc_out_dc1 = (gk_s32)dc_pre * csc_coef.csc_out_dc1;
+    csc_coef.csc_out_dc2 = (gk_s32)dc_pre * csc_coef.csc_out_dc2;
+
+    hal_layer_set_csc_coef(vo_layer, &csc_coef);
+
+    return GK_SUCCESS;
+}
+
+gk_s32 load_bmp(gk_phys_addr_t bmp_addr, osd_logo_t *video_logo)
+{
+    gk_u16 bpp;
+    osd_bitmap_file_header bmp_file_header;
+    osd_bitmap_info bmp_info;
+
+    memcpy(&bmp_file_header, (char *)(uintptr_t)(bmp_addr + sizeof(gk_u16)), sizeof(osd_bitmap_file_header));
+    memcpy(&bmp_info, (char *)(uintptr_t)(bmp_addr + sizeof(gk_u16) + sizeof(osd_bitmap_file_header)), sizeof(osd_bitmap_info));
+    video_logo->width = bmp_info.bmi_header.bi_width;
+    video_logo->height = bmp_info.bmi_header.bi_height;
+    video_logo->stride = bmp_info.bmi_header.bi_width * (OSD_BI_BIT_COUNT_16BPP / 8); /* 8 bits per bytes */
+    video_logo->rgb_buffer = bmp_addr + bmp_file_header.bf_off_bits;
+
+    bpp = bmp_info.bmi_header.bi_bit_count;
+    if (bpp != OSD_BI_BIT_COUNT_16BPP) { /* 16 bits, 2bytes per pixel bitmap format */
+        printf("bitmap format bpp=%d not supported! only supoort format bpp=%d\n", bpp, OSD_BI_BIT_COUNT_16BPP);
+        return -1;
+    }
+    return 0;
+}
diff -uraN u-boot-2016.11/product/osd/vo/gk7205v200/vou_drv.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/vou_drv.h
--- u-boot-2016.11/product/osd/vo/gk7205v200/vou_drv.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/vou_drv.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,676 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __VOU_DRV_H__
+#define __VOU_DRV_H__
+
+#include "type.h"
+#include "gk7205v200_vo.h"
+#include "vou_def.h"
+#include "vou_coef.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* end of #ifdef __cplusplus */
+
+/*
+ * yuv(y,u,v)    assemble the y,u,v to 24bit color
+ * yuv_y(c)      get Y from 24bit color
+ * yuv_u(c)      get U from 24bit color
+ * yuv_v(c)      get V from 24bit color
+ */
+#define yuv(y, u, v) ((((y) & 0x03ff) << 20) | (((u) & 0x03ff) << 10) | ((v) & 0x03ff))
+#define yuv_y(c)     (((c) & 0x3ff00000) >> 20)
+#define yuv_u(c)     (((c) & 0x000ffc00) >> 10)
+#define yuv_v(c)     ((c) & 0x000003ff)
+
+#define GFX_CSC_SCALE    0x8
+#define GFX_CSC_CLIP_MIN 0x0
+#define GFX_CSC_CLIP_MAX 0x3ff
+
+typedef gk_s32 vo_hal_dev;
+typedef gk_s32 vo_hal_layer;
+typedef gk_s32 vo_hal_chn;
+typedef gk_s32 vo_hal_wbc;
+typedef gk_s32 graphic_hal_layer;
+typedef gk_u32 vo_intf_type;
+
+typedef enum {
+    VO_INT_MODE_FRAME = 0x0,
+    VO_INT_MODE_FIELD = 0x1,
+    VO_INT_MODE_BUTT
+} vo_int_mode;
+
+/* vou mixer prio id */
+typedef enum {
+    VO_MIX_PRIO0 = 0,
+    VO_MIX_PRIO1,
+    VO_MIX_PRIO2,
+    VO_MIX_PRIO3,
+    VO_MIX_PRIO4,
+    VO_MIX_PRIO5,
+    VO_MIX_PRIO_CLR,
+    VO_MIX_BUTT
+} vo_mix_prio;
+
+typedef enum {
+    /* for video surface interface */
+    VO_LAYER_PIXERL_FORMAT_SP_Y_CB_CR_400 = 0x1,
+    VO_LAYER_PIXERL_FORMAT_SP_Y_CB_CR_420 = 0x2,
+    VO_LAYER_PIXERL_FORMAT_SP_Y_CB_CR_422 = 0x3,
+    VO_LAYER_PIXERL_FORMAT_BUTT
+} vo_layer_pixerl_format;
+
+typedef enum {
+    /* for device interface */
+    VO_INTF_PIXERL_FORMAT_YCBCR422 = 0x0,
+    VO_INTF_PIXERL_FORMAT_YCBCR444 = 0xC,
+    VO_INTF_PIXERL_FORMAT_RGB888 = 0xC,
+    VO_INTF_PIXERL_FORMAT_BUTT
+} vo_intf_pixerl_format;
+
+typedef enum {
+    VO_CSC_DEF_VAL = 50,
+    VO_CSC_LUMA_MAX = 100,
+    VO_CSC_LUMA_MIN = 0,
+
+    VO_CSC_CONT_MAX = 100,
+    VO_CSC_CONT_MIN = 0,
+
+    VO_CSC_HUE_MAX = 100,
+    VO_CSC_HUE_MIN = 0,
+
+    VO_CSC_SAT_MAX = 100,
+    VO_CSC_SAT_MIN = 0,
+} vo_csc_range;
+
+typedef struct {
+    gk_u32 acm_blk_en;
+
+    gk_u8 u_index;
+    gk_u8 v_index;
+
+    gk_s8 u_offset_a;
+    gk_s8 u_offset_b;
+    gk_s8 u_offset_c;
+    gk_s8 u_offset_d;
+
+    gk_s8 v_offset_a;
+    gk_s8 v_offset_b;
+    gk_s8 v_offset_c;
+    gk_s8 v_offset_d;
+} vou_acm_blkinfo;
+
+/* vou zoom mode */
+typedef enum {
+    VO_DISP_ZMEMODE_HORL = 0,
+    VO_DISP_ZMEMODE_HORC,
+    VO_DISP_ZMEMODE_VERL,
+    VO_DISP_ZMEMODE_VERC,
+
+    VO_DISP_ZMEMODE_HOR,
+    VO_DISP_ZMEMODE_VER,
+    VO_DISP_ZMEMODE_ALPHA,
+    VO_DISP_ZMEMODE_ALPHAV,
+    VO_DISP_ZMEMODE_VERT,
+    VO_DISP_ZMEMODE_VERB,
+
+    VO_DISP_ZMEMODE_ALL,
+    VO_DISP_ZMEMODE_NONL,
+    VO_DISP_ZMEMODE_BUTT
+} vo_disp_zmemode;
+
+typedef struct {
+    vou_acm_blkinfo acm_blk[4]; /* 4 acm blk num */
+} vou_acm;
+
+typedef enum {
+    VOU_HD_HW_DEV = 0,
+    VOU_SD_HW_DEV,
+    VOU_CAS_DEV,
+    VOU_VIRT_DEV,
+    VOU_DEV_TYPE_BUTT,
+} vou_dev_type;
+
+typedef struct {
+    vou_dev_type vo_dev_type;
+    gk_bool hd_vpss_rciv;
+    gk_bool sd_tde_disp;
+    gk_bool support_wbc;
+    gk_bool spt_get_screen_frm;
+} vou_dev_capability;
+
+typedef enum {
+    VOU_SW_LAYER_VHD0 = 0,
+    VOU_SW_LAYER_VHD1 = 1,
+    VOU_SW_LAYER_VP = 2,
+    VOU_SW_LAYER_VSD0 = 3,
+    VOU_SW_LAYER_VIRT0 = 4,
+    VOU_SW_LAYER_VIRT1 = 5,
+    VOU_SW_LAYER_VIRT2 = 6,
+    VOU_SW_LAYER_VIRT3 = 7,
+    VOU_SW_LAYER_BUTT
+} vou_sw_layer;
+
+typedef struct {
+    gk_bool synm; /* sync mode(0:timing,as BT.656; 1:signal,as LCD) */
+    gk_bool iop;  /* interlaced or progressive display(0:i; 1:p) */
+    gk_u8 intfb; /* interlace bit width while output */
+
+    gk_u16 vact; /* vertical active area */
+    gk_u16 vbb;  /* vertical back blank porch */
+    gk_u16 vfb;  /* vertical front blank porch */
+
+    gk_u16 hact; /* herizontal active area */
+    gk_u16 hbb;  /* herizontal back blank porch */
+    gk_u16 hfb;  /* herizontal front blank porch */
+    gk_u16 hmid; /* bottom herizontal active area */
+
+    gk_u16 bvact; /* bottom vertical active area */
+    gk_u16 bvbb;  /* bottom vertical back blank porch */
+    gk_u16 bvfb;  /* bottom vertical front blank porch */
+
+    gk_u16 hpw; /* horizontal pulse width */
+    gk_u16 vpw; /* vertical pulse width */
+
+    gk_bool idv; /* inverse data valid of output */
+    gk_bool ihs; /* inverse horizontal synch signal */
+    gk_bool ivs; /* inverse vertical synch signal */
+} vo_sync_info;
+
+typedef enum {
+    VOU_LAYER_DDR0 = 0,
+    VOU_LAYER_DDR1 = 1,
+    VOU_LAYER_DDR_BUTT
+} vou_layer_ddr;
+
+typedef struct {
+    vo_csc_matrix csc_matrix;
+    gk_u32 luma;      /* luminance:   0 ~ 100 default: 50 */
+    gk_u32 contrast;  /* contrast :   0 ~ 100 default: 50 */
+    gk_u32 hue;       /* hue      :   0 ~ 100 default: 50 */
+    gk_u32 satuature; /* satuature:   0 ~ 100 default: 50 */
+} vo_csc;
+
+typedef struct {
+    vo_csc csc;
+    gk_u32 gain; /* current gain of VGA signals. [0, 64). default:0x30 */
+} vo_vga_param;
+
+typedef struct {
+    gk_u32 width;
+    gk_u32 height;
+} size;
+
+typedef struct {
+    gk_u32 bg_color;        /* background color of a device, in RGB format. */
+    vo_intf_type intf_type; /* type of a VO interface */
+    vo_intf_sync intf_sync; /* type of a VO interface timing */
+    vo_sync_info sync_info; /* information about VO interface timings */
+} vo_pub_attr;
+
+typedef struct {
+    gk_u32 vhdr_en;
+    gk_u32 vhdr_ck_gt_en;
+    gk_u32 vhdr_degmm_en;
+    gk_u32 vhdr_gamut_en;
+    gk_u32 vhdr_tmap_en;
+    gk_u32 vhdr_gmm_en;
+    gk_u32 vhdr_dither_en;
+    gk_u32 vhdr_r2y_en;
+    gk_u32 vhdr_cadj_en;
+    gk_u32 vhdr_gamut_bind;
+
+    gk_u32 vhdr_dither_round_unlim;
+    gk_u32 vhdr_dither_round;
+    gk_u32 vhdr_dither_domain_mode;
+    gk_u32 vhdr_dither_tap_mode;
+} vo_hdr_v_cfg;
+
+typedef struct {
+    gk_u32 hdr_y2r_en;
+    gk_u32 hdr_y2r_ck_gt_en;
+
+    gk_u32 hdr_v0_y2r_en;
+    gk_u32 hdr_v1_y2r_en;
+    gk_u32 hdr_v0_vhdr_en;
+    gk_u32 hdr_v1_vhdr_en;
+    gk_u32 hdr_v0_cl_en;
+    gk_u32 hdr_v1_cl_en;
+
+    gk_u32 hdr_v_demo_en;
+    gk_u32 hdr_v_demo_mode;
+    gk_u32 hdr_v_demo_pos;
+} vo_csc_v0_cfg;
+
+typedef struct {
+    gk_u32 ck_gt_en;
+    gk_u32 hfir_order;
+    gk_u32 lhfir_en;
+    gk_u32 chfir_en;
+    gk_u32 lhmid_en;
+    gk_u32 chmid_en;
+    gk_u32 non_lnr_en;
+    gk_u32 lhfir_mode;
+    gk_u32 chfir_mode;
+    gk_u32 hl_shootctrl_en;
+    gk_u32 hl_shootctrl_mode;
+    gk_u32 hc_shootctrl_en;
+    gk_u32 hc_shootctrl_mode;
+
+    gk_u32 in_pro;
+    gk_u32 out_pro;
+    gk_u32 out_fmt;
+    gk_u64 in_height;
+    gk_u64 out_height;
+    gk_u64 in_width;
+    gk_u64 out_width;
+    gk_u32 graphdet_en;
+
+    gk_u32 lvfir_en;
+    gk_u32 cvfir_en;
+    gk_u32 lvmid_en;
+    gk_u32 cvmid_en;
+    gk_u32 vfir_1tap_en;
+    gk_u32 lvfir_mode;
+    gk_u32 cvfir_mode;
+    gk_u32 vl_shootctrl_en;
+    gk_u32 vl_shootctrl_mode;
+    gk_u32 vc_shootctrl_en;
+    gk_u32 vc_shootctrl_mode;
+} vo_v0_zme_cfg;
+
+typedef struct {
+    gk_u32 vluma_offset;
+    gk_u32 vchroma_offset;
+    gk_u32 vbluma_offset;
+    gk_u32 vbchroma_offset;
+    gk_u32 lhfir_offset;
+    gk_u32 chfir_offset;
+    gk_u32 vl_flatdect_mode;
+    gk_u32 vl_coringadj_en;
+    gk_u32 vl_gain;
+    gk_u32 vl_coring;
+    gk_u32 vc_flatdect_mode;
+    gk_u32 vc_coringadj_en;
+    gk_u32 vc_gain;
+    gk_u32 vc_coring;
+    gk_u32 hl_flatdect_mode;
+    gk_u32 hl_coringadj_en;
+    gk_u32 hl_gain;
+    gk_u32 hl_coring;
+    gk_u32 hc_flatdect_mode;
+    gk_u32 hc_coringadj_en;
+    gk_u32 hc_gain;
+    gk_u32 hc_coring;
+} vo_zme_comm_pq_cfg;
+
+typedef struct {
+    gk_u32 zme_vprec;
+    gk_u32 zme_hprec;
+} vo_zme_ds_info;
+
+typedef enum {
+    VO_ZME_TYP = 0,
+    VO_ZME_TYP1,
+    VO_ZME_RAND,
+    VO_ZME_MAX,
+    VO_ZME_MIN,
+    VO_ZME_ZERO,
+    VO_ZME_BUTT
+} vo_zme_mode;
+
+typedef enum {
+    VDP_V0_HFIR_TYP = 0,
+    VDP_V0_HFIR_TYP1,
+    VDP_V0_HFIR_RAND,
+    VDP_V0_HFIR_MAX,
+    VDP_V0_HFIR_MIN,
+    VDP_V0_HFIR_ZERO,
+    VDP_V0_HFIR_BUTT
+} vo_v0_hfir_mode;
+
+typedef enum {
+    XDP_V0_HFIR_BYPASS = 0,
+    XDP_V0_HFIR_COPY,
+    XDP_V0_HFIR_BILT,
+    XDP_V0_HFIR_FILT,
+    XDP_V0_HFIR_BUTT
+} xdp_v0_hfir_mode;
+
+typedef struct {
+    gk_u32 ck_gt_en;
+    gk_u32 mid_en;
+    xdp_v0_hfir_mode hfir_mode;
+} vo_v0_hfir_cfg;
+
+typedef struct {
+    gk_u32 vid_iw;
+    gk_u32 vid_ih;
+    gk_u32 vid_ow;
+    gk_u32 vid_oh;
+
+    gk_u32 zme_en;
+    gk_u32 hfir_en;
+    gk_u32 csc_en;
+    gk_u32 hdr_en;
+
+    vo_v0_zme_cfg zme_cfg;
+    vo_v0_hfir_cfg hfir_cfg;
+    vo_csc_v0_cfg yuv2_rgb_cfg;
+    vo_hdr_v_cfg v_hdr_cfg;
+} vdp_vid_ip_cfg;
+
+typedef struct {
+    gk_u32 ck_gt_en;
+    gk_u32 out_pro;
+    gk_u32 out_fmt;
+    gk_u64 in_height;
+    gk_u64 out_height;
+    gk_u64 in_width;
+    gk_u64 out_width;
+    gk_u32 cvfir_en;
+    gk_u32 cvmid_en;
+    gk_u32 cvfir_mode;
+
+    gk_u32 hfir_order;
+    gk_u32 lhfir_en;
+    gk_u32 chfir_en;
+    gk_u32 lhmid_en;
+    gk_u32 chmid_en;
+    gk_u32 non_lnr_en;
+    gk_u32 lhfir_mode;
+    gk_u32 chfir_mode;
+    gk_u32 hl_shootctrl_en;
+    gk_u32 hl_shootctrl_mode;
+    gk_u32 hc_shootctrl_en;
+    gk_u32 hc_shootctrl_mode;
+
+    gk_u32 in_pro;
+    gk_u32 graphdet_en;
+
+    gk_u32 lvfir_en;
+    gk_u32 lvmid_en;
+    gk_u32 vfir_1tap_en;
+    gk_u32 lvfir_mode;
+    gk_u32 vl_shootctrl_en;
+    gk_u32 vl_shootctrl_mode;
+    gk_u32 vc_shootctrl_en;
+    gk_u32 vc_shootctrl_mode;
+} vdp_v1_cvfir_cfg;
+
+typedef enum {
+    VDP_V1_HFIR_TYP = 0,
+    VDP_V1_HFIR_TYP1,
+    VDP_V1_HFIR_RAND,
+    VDP_V1_HFIR_MAX,
+    VDP_V1_HFIR_MIN,
+    VDP_V1_HFIR_ZERO,
+    VDP_V1_HFIR_BUTT
+} vdp_v1_hfir_mode;
+
+typedef enum {
+    XDP_HFIR_BYPASS = 0,
+    XDP_HFIR_COPY,
+    XDP_HFIR_BILT,
+    XDP_HFIR_FILT,
+    XDP_HFIR_BUTT
+} xdp_hfir_mode;
+
+typedef struct {
+    gk_u32 ck_gt_en;
+    gk_u32 mid_en;
+    xdp_hfir_mode hfir_mode;
+} vdp_v1_hfir_cfg;
+
+typedef struct {
+    gk_u32 csc_en;
+    gk_u32 csc_ck_gt_en;
+} vdp_csc_v1_cfg;
+
+typedef enum {
+    VDP_RMODE_INTERFACE = 0,
+    VDP_RMODE_INTERLACE = 0,
+    VDP_RMODE_PROGRESSIVE = 1,
+    VDP_RMODE_TOP = 2,
+    VDP_RMODE_BOTTOM = 3,
+    VDP_RMODE_PRO_TOP = 4,
+    VDP_RMODE_PRO_BOTTOM = 5,
+    VDP_RMODE_BUTT
+} vdp_data_rmode;
+
+typedef enum {
+    VDP_G0_ZME_TYP = 0,
+    VDP_G0_ZME_TYP1,
+    VDP_G0_ZME_RAND,
+    VDP_G0_ZME_MAX,
+    VDP_G0_ZME_MIN,
+    VDP_G0_ZME_ZERO,
+    VDP_G0_ZME_BUTT
+} gf_g0_zme_mode;
+
+typedef enum {
+    VDP_G0_ZME_FIR_COPY = 0,
+    VDP_G0_ZME_FIR_FILT = 1
+} gf_g0_zme_fir_mode;
+
+typedef struct {
+    gk_u32 ck_gt_en;
+    gk_u32 in_width;
+    gk_u32 out_width;
+    gk_u32 out_pro;
+
+    gk_u32 hfir_en;
+    gk_u32 lhmid_en;
+    gk_u32 ahmid_en;
+    gk_u32 lhfir_mode;
+    gk_u32 ahfir_mode;
+
+    gk_u32 in_height;
+    gk_u32 out_height;
+
+    gk_u32 vfir_en;
+    gk_u32 lvmid_en;
+    gk_u32 avmid_en;
+    gk_u32 lvfir_mode;
+    gk_u32 avfir_mode;
+} gf_g0_zme_cfg;
+
+typedef enum {
+    GF_RM_COEF_MODE_TYP = 0x0,
+    GF_RM_COEF_MODE_RAN = 0x1,
+    GF_RM_COEF_MODE_MIN = 0x2,
+    GF_RM_COEF_MODE_MAX = 0x3,
+    GF_RM_COEF_MODE_ZRO = 0x4,
+    GF_RM_COEF_MODE_CUS = 0x5,
+    GF_RM_COEF_MODE_UP = 0x6,
+    GF_RM_COEF_MODE_BUTT
+} gf_rm_coef_mode;
+
+typedef enum {
+    GFX_DCMP_SRC_MODE_ARGB8888 = 0,
+    GFX_DCMP_SRC_MODE_ARGB6888,
+    GFX_DCMP_SRC_MODE_ARGB1555,
+    GFX_DCMP_SRC_MODE_ARGB4444,
+
+    GFX_DCMP_SRC_MODE_BUTT
+} gfx_dcmp_src_mode;
+
+typedef enum {
+    VDP_DITHER_MODE_TYP = 0,
+    VDP_DITHER_MODE_TYP1,
+    VDP_DITHER_MODE_RAND,
+    VDP_DITHER_MODE_MAX,
+    VDP_DITHER_MODE_MIN,
+    VDP_DITHER_MODE_ZERO,
+    VDP_DITHER_MODE_BUTT
+} vdp_dither_mode;
+
+typedef enum {
+    DITHER_MODE_10BIT = 0,
+    DITHER_MODE_8BIT = 1,
+    DITHER_MODE_BUTT
+} dither_mode;
+
+typedef enum {
+    DITHER_OWIDTH_MODE_5BIT = 0,
+    DITHER_OWIDTH_MODE_6BIT = 1,
+    DITHER_OWIDTH_MODE_7BIT = 2,
+    DITHER_OWIDTH_MODE_8BIT = 3,
+    DITHER_OWIDTH_MODE_9BIT = 4,
+    DITHER_OWIDTH_MODE_10BIT = 5,
+    DITHER_OWIDTH_MODE_BUTT
+} dither_owidth_mode;
+
+typedef enum {
+    DITHER_IWIDTH_MODE_8BIT = 0,
+    DITHER_IWIDTH_MODE_9BIT = 1,
+    DITHER_IWIDTH_MODE_10BIT = 2,
+    DITHER_IWIDTH_MODE_11BIT = 3,
+    DITHER_IWIDTH_MODE_12BIT = 4,
+    DITHER_IWIDTH_MODE_BUTT
+} dither_iwidth_mode;
+
+typedef enum {
+    DITHER_DOMAIN_MODE_SPACE = 0,
+    DITHER_DOMAIN_MODE_TIME = 1,
+    DITHER_DOMAIN_MODE_BUTT
+} dither_domain_mode;
+
+typedef enum {
+    DITHER_TAP_MODE_7 = 0,
+    DITHER_TAP_MODE_15 = 1,
+    DITHER_TAP_MODE_23 = 2,
+    DITHER_TAP_MODE_31 = 3,
+    DITHER_TAP_MODE_BUTT
+} dither_tap_mode;
+
+typedef struct {
+    gk_u32 dither_in_bit_width;
+    gk_u32 dither_out_bit_width;
+} vo_dither_info;
+
+typedef enum {
+    DITHER_IO_MODE_12_10 = 1,
+    DITHER_IO_MODE_12_8 = 2,
+    DITHER_IO_MODE_10_8 = 3,
+    DITHER_IO_MODE_10_6 = 4,
+    DITHER_IO_MODE_9_6 = 5,
+    DITHER_IO_MODE_8_6 = 6,
+    DITHER_IO_MODE_10_9_6 = 5,
+    DITHER_IO_MODE_10_8_6 = 6,
+    DITHER_IO_MODE_BUTT
+} vo_dither_io_mode;
+
+typedef struct {
+    gk_u32 dither_en;
+    gk_u32 dither_mode;
+    gk_u32 dither_round;
+    gk_u32 dither_round_unlim;
+    gk_u32 i_data_width_dither;
+    gk_u32 o_data_width_dither;
+    gk_u32 dither_domain_mode;
+    gk_u32 dither_tap_mode;
+    gk_u32 dither_sed_y0;
+    gk_u32 dither_sed_u0;
+    gk_u32 dither_sed_v0;
+    gk_u32 dither_sed_w0;
+    gk_u32 dither_sed_y1;
+    gk_u32 dither_sed_u1;
+    gk_u32 dither_sed_v1;
+    gk_u32 dither_sed_w1;
+    gk_u32 dither_sed_y2;
+    gk_u32 dither_sed_u2;
+    gk_u32 dither_sed_v2;
+    gk_u32 dither_sed_w2;
+    gk_u32 dither_sed_y3;
+    gk_u32 dither_sed_u3;
+    gk_u32 dither_sed_v3;
+    gk_u32 dither_sed_w3;
+    gk_u32 dither_thr_max;
+    gk_u32 dither_thr_min;
+    vo_dither_io_mode dither_io_mode;
+} vdp_dither_cfg;
+
+typedef struct {
+    gk_u16 bi_size;
+    gk_u32 bi_width;
+    gk_s32 bi_height;
+    gk_u16 bi_planes;
+    gk_u16 bi_bit_count;
+    gk_u32 bi_compression;
+    gk_u32 bi_size_image;
+    gk_u32 bi_x_pels_per_meter;
+    gk_u32 bi_y_pels_per_meter;
+    gk_u32 bi_clr_used;
+    gk_u32 bi_clr_important;
+} osd_bitmap_info_header;
+
+typedef struct {
+    gk_u8 rgb_blue;
+    gk_u8 rgb_green;
+    gk_u8 rgb_red;
+    gk_u8 rgb_reserved;
+} osd_rgb_quad;
+
+typedef struct {
+    gk_u32 bf_size;
+    gk_u16 bf_reserved1;
+    gk_u16 bf_reserved2;
+    gk_u32 bf_off_bits;
+} osd_bitmap_file_header;
+
+typedef struct {
+    osd_bitmap_info_header bmi_header;
+    osd_rgb_quad bmi_colors[1];
+} osd_bitmap_info;
+
+typedef struct {
+    gk_u32 width;       /* out */
+    gk_u32 height;      /* out */
+    gk_u32 stride;      /* in */
+    gk_phys_addr_t rgb_buffer; /* in */
+} osd_logo_t;
+
+typedef enum {
+    OSD_BI_BIT_COUNT_1BPP = 1,
+    OSD_BI_BIT_COUNT_4BPP = 4,
+    OSD_BI_BIT_COUNT_8BPP = 8,
+    OSD_BI_BIT_COUNT_16BPP = 16,
+    OSD_BI_BIT_COUNT_24BPP = 24,
+    OSD_BI_BIT_COUNT_32BPP = 32,
+} osd_bi_bit_count;
+
+gk_void vo_drv_board_init(gk_void);
+gk_void vo_drv_int_reg_up_mode(vo_hal_layer vo_layer, vo_int_mode int_mode);
+gk_void vo_drv_set_dev_intf_type(vo_hal_dev vo_dev, vo_intf_type intf_type);
+gk_void vo_drv_set_dev_bk_grd(vo_hal_dev vo_dev, gk_u32 bg_color);
+gk_void vo_drv_set_dev_out_sync(vo_hal_dev vo_dev, vo_intf_sync vo_out_mode);
+
+gk_void vo_drv_dev_int_enable(vo_hal_dev vo_dev, gk_bool enable);
+gk_void vo_drv_int_set_mode(vo_hal_dev vo_dev, vo_int_mode int_mode);
+
+gk_void vo_drv_layer_enable(vo_hal_layer vo_layer, gk_bool enable);
+
+gk_void vo_drv_set_all_crg_clk(gk_bool clk_en);
+gk_u32 vo_drv_get_dev_intf_type(vo_hal_dev vo_dev);
+gk_void vo_drv_open(vo_hal_dev vo_dev);
+gk_void vo_drv_close(vo_hal_dev vo_dev);
+gk_void vo_drv_default_setting(gk_void);
+
+gk_void vo_drv_set_dev_clk(vo_hal_dev vo_dev);
+gk_void vo_vid_set_zme_enable(gk_u32 layer, const vdp_vid_ip_cfg *vid_cfg);
+
+gk_s32 graphic_drv_set_csc_coef(hal_disp_layer gfx_layer, const vo_csc *gfx_csc, const csc_coef_param *coef_param);
+gk_s32 vo_drv_video_set_csc_coef(vo_hal_layer vo_layer, vo_csc_matrix csc_matrix);
+gk_s32 load_bmp(gk_phys_addr_t bmp_addr, osd_logo_t *video_logo);
+
+gk_void vo_drv_def_layer_bind_dev(gk_void);
+
+#ifdef __cplusplus
+}
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* end of __VOU_DRV_H__ */
+
diff -uraN u-boot-2016.11/product/osd/vo/gk7205v200/vou.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/vou.h
--- u-boot-2016.11/product/osd/vo/gk7205v200/vou.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/vou.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __VOU_H__
+#define __VOU_H__
+
+#include "gk7205v200_vo.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* end of #ifdef __cplusplus */
+
+int set_vobg(unsigned int dev, unsigned int rgb);
+int start_vo(unsigned int dev, unsigned int type, unsigned int sync);
+int stop_vo(unsigned int dev);
+int start_videolayer(unsigned int layer, unsigned long addr, unsigned int strd, gk_vo_rect layer_rect);
+int stop_videolayer(unsigned int layer);
+int start_gx(unsigned int layer, unsigned long addr, unsigned int strd, gk_vo_rect gx_rect);
+int stop_gx(unsigned int layer);
+
+#ifdef __cplusplus
+}
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* end of #ifdef __VOU_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/gk7205v200/vou_hal.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/vou_hal.c
--- u-boot-2016.11/product/osd/vo/gk7205v200/vou_hal.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/vou_hal.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,2139 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "vou_hal.h"
+#include <asm/io.h>
+#include "gk7205v200_vo.h"
+
+#define IO_ADDRESS(x) (x)
+
+#define GK_INVALID_LAYER (-1)
+
+#define CRG_REGS_ADDR 0x12010000
+#define CRG_REGS_SIZE 0X10000
+
+#define CRG_PERCTL2_ADDR (0x0008 + CRG_REGS_ADDR)
+#define CRG_PERCTL3_ADDR (0x000C + CRG_REGS_ADDR)
+#define CRG_PERCTL4_ADDR (0x0010 + CRG_REGS_ADDR)
+#define CRG_PERCTL5_ADDR (0x0014 + CRG_REGS_ADDR)
+#define CRG_PERCTL6_ADDR (0x0018 + CRG_REGS_ADDR)
+#define CRG_PERCTL7_ADDR (0x001c + CRG_REGS_ADDR)
+
+#define CRG_PERCTL10_ADDR (0x0028 + CRG_REGS_ADDR)
+#define CRG_PERCTL11_ADDR (0x002c + CRG_REGS_ADDR)
+#define CRG_PERCTL18_ADDR (0x0048 + CRG_REGS_ADDR)
+
+#define CRG_PERCTL19_ADDR (0x004c + CRG_REGS_ADDR)
+#define CRG_PERCTL59_ADDR (0x00ec + CRG_REGS_ADDR)
+
+#define CRG_PERCTL65_ADDR (0x0104 + CRG_REGS_ADDR) /* LCD CRG */
+#define CRG_PERCTL66_ADDR (0x0108 + CRG_REGS_ADDR) /* VDP low power CRG */
+#define CRG_PERCTL72_ADDR (0x0120 + CRG_REGS_ADDR)
+#define CRG_PERCTL73_ADDR (0x0124 + CRG_REGS_ADDR) /* VDP CRG */
+#define CRG_PERCTL15_ADDR (0x003C + CRG_REGS_ADDR)
+
+#define LCD_CRG_PERCTL_ADDR CRG_PERCTL65_ADDR
+#define VOU_CRG_PERCTL_ADDR CRG_PERCTL66_ADDR
+
+#define MISC_REGS_ADDR 0x12028000
+#define MISC_REGS_SIZE 0x8000
+#define FDR_VID_OFFSET (0x200 / 4)
+
+#define MISC_CTL18_ADDR (0x18 + MISC_REGS_ADDR)
+
+volatile S_VDP_REGS_TYPE *g_vo_reg = GK_NULL;
+
+gk_void hal_vo_init(gk_void)
+{
+    g_vo_reg = (volatile S_VDP_REGS_TYPE *)IO_ADDRESS(VO_BASE_ADDR);
+}
+
+gk_void hal_vo_exit(gk_void)
+{
+}
+
+static inline void gk_reg_set_bit(unsigned long value, unsigned long offset,
+                                  unsigned long addr)
+{
+    unsigned long t, mask;
+
+    mask = 1 << offset;
+    t = readl(addr);
+    t &= ~mask;
+    t |= (value << offset) & mask;
+    writel(t, addr);
+}
+
+static inline void gk_reg_write32(unsigned long value, unsigned long mask,
+                                  unsigned long addr)
+{
+    unsigned long t;
+
+    t = readl(addr);
+    t &= ~mask;
+    t |= value & mask;
+    writel(t, addr);
+}
+
+gk_void hal_write_reg(gk_u32 *address, gk_u32 value)
+{
+    *(volatile gk_u32 *)address = value;
+    return;
+}
+
+gk_u32 hal_read_reg(const gk_u32 *address)
+{
+    return *(volatile gk_u32 *)(address);
+}
+
+gk_bool hal_intf_bt_set_dfir_en(gk_u32 dfir_en)
+{
+    U_INTF_BT_CTRL INTF_BT_CTRL;
+
+    INTF_BT_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)&(g_vo_reg->INTF_BT_CTRL.u32));
+    INTF_BT_CTRL.bits.dfir_en = dfir_en;
+    hal_write_reg ((gk_u32*)(gk_uintptr_t)&(g_vo_reg->INTF_BT_CTRL.u32), INTF_BT_CTRL.u32);
+
+    return GK_TRUE;
+}
+
+gk_ulong vo_get_abs_addr(hal_disp_layer layer, gk_ulong reg)
+{
+    gk_ulong reg_abs_addr;
+
+    switch (layer) {
+        case HAL_DISP_LAYER_VHD0:
+        case HAL_DISP_LAYER_VHD1: {
+            reg_abs_addr = (reg) + (layer - HAL_DISP_LAYER_VHD0) * VHD_REGS_LEN;
+            break;
+        }
+
+        case HAL_DISP_LAYER_GFX0:
+        case HAL_DISP_LAYER_GFX1: {
+            reg_abs_addr = (reg) + (layer - HAL_DISP_LAYER_GFX0) * GFX_REGS_LEN;
+            break;
+        }
+
+        default: {
+            return 0;
+        }
+    }
+
+    return reg_abs_addr;
+}
+
+gk_ulong vo_get_chn_abs_addr(hal_disp_outputchannel chan, gk_ulong reg)
+{
+    volatile gk_ulong reg_abs_addr;
+
+    switch (chan) {
+        case HAL_DISP_CHANNEL_DHD0: {
+            reg_abs_addr = reg + (chan - HAL_DISP_CHANNEL_DHD0) * DHD_REGS_LEN;
+            break;
+        }
+
+        default: {
+            printf("error channel id found in %s: L%d\n", __FUNCTION__, __LINE__);
+            return 0;
+        }
+    }
+
+    return reg_abs_addr;
+}
+
+gk_s32 sys_hal_vo_bus_reset_sel(gk_bool reset)
+{
+    gk_u32 tmp = (reset == GK_TRUE) ? 1 : 0;
+    gk_reg_set_bit(tmp, 0, IO_ADDRESS(VOU_CRG_PERCTL_ADDR));
+
+    return 0;
+}
+
+gk_s32 sys_hal_vo_apb_clk_en(gk_bool clk_en)
+{
+    gk_u32 tmp = (clk_en == GK_TRUE) ? 1 : 0;
+    gk_reg_set_bit(tmp, 1, IO_ADDRESS(VOU_CRG_PERCTL_ADDR));
+
+    return 0;
+}
+
+gk_s32 sys_hal_vo_bus_clk_en(gk_bool clk_en)
+{
+    gk_u32 tmp = (clk_en == GK_TRUE) ? 1 : 0;
+    gk_reg_set_bit(tmp, 2, IO_ADDRESS(VOU_CRG_PERCTL_ADDR)); /* 2bit */
+
+    return 0;
+}
+
+gk_s32 sys_hal_vo_cfg_clk_en(gk_bool clk_en)
+{
+    gk_u32 tmp = (clk_en == GK_TRUE) ? 1 : 0;
+    gk_reg_set_bit(tmp, 3, IO_ADDRESS(VOU_CRG_PERCTL_ADDR)); /* 3bit */
+
+    return 0;
+}
+
+/* VO HD PPC clock gating enable */
+gk_s32 sys_hal_vo_core_clk_en(gk_s32 dev, gk_bool clk_en)
+{
+    gk_u32 tmp = (clk_en == GK_TRUE) ? 1 : 0;
+
+    gk_reg_set_bit(tmp, 5, IO_ADDRESS(VOU_CRG_PERCTL_ADDR)); /* 5bit */
+
+    return 0;
+}
+
+gk_s32 sys_hal_vo_dev_clk_en(gk_s32 vo_dev, gk_bool clk_en)
+{
+    gk_u32 tmp = (clk_en == GK_TRUE) ? 1 : 0;
+
+    if (vo_dev == 0) {
+        gk_reg_set_bit(tmp, 5, IO_ADDRESS(VOU_CRG_PERCTL_ADDR)); /* 5bit */
+        gk_reg_set_bit(tmp, 6, IO_ADDRESS(VOU_CRG_PERCTL_ADDR)); /* 6bit */
+    } else {
+        return -1;
+    }
+
+    return 0;
+}
+
+gk_s32 sys_hal_vo_bt_clk_en(gk_bool bt_clk_en)
+{
+    gk_u32 tmp = (bt_clk_en == GK_TRUE) ? 1 : 0;
+
+    gk_reg_set_bit(tmp, 8, IO_ADDRESS(VOU_CRG_PERCTL_ADDR)); /* 8bit */
+    gk_reg_set_bit(tmp, 9, IO_ADDRESS(VOU_CRG_PERCTL_ADDR)); /* 9bit */
+
+    return 0;
+}
+
+gk_s32 sys_hal_vo_hd0_div_mode(gk_u32 hd0_div_mod)
+{
+    gk_reg_write32(hd0_div_mod << 12, 0x3 << 12, IO_ADDRESS(VOU_CRG_PERCTL_ADDR)); /* 12bit to set 0x3 */
+
+    return 0;
+}
+
+gk_s32 sys_hal_vo_hd_out_pctrl(gk_bool clk_reverse)
+{
+    gk_u32 tmp = (clk_reverse == GK_TRUE) ? 1 : 0;
+
+    gk_reg_set_bit(tmp, 20, IO_ADDRESS(VOU_CRG_PERCTL_ADDR)); /* 20bit */
+
+    return 0;
+}
+
+gk_s32 sys_hal_vo_out_clk_sel(gk_u32 clk_sel)
+{
+    gk_reg_write32(clk_sel << 21, 0xf << 21, IO_ADDRESS(VOU_CRG_PERCTL_ADDR)); /* 21bit */
+
+    return 0;
+}
+
+gk_s32 sys_hal_vo_lcd_clk_en(gk_bool clk_en)
+{
+    gk_u32 tmp = (clk_en == GK_TRUE) ? 1 : 0;
+
+    gk_reg_set_bit(tmp, 27, IO_ADDRESS(LCD_CRG_PERCTL_ADDR)); /* 27bit */
+
+    return 0;
+}
+
+gk_s32 sys_hal_lcd_mclk_div(gk_u32 mclk_div)
+{
+    gk_reg_write32(mclk_div, 0x7ffffff, IO_ADDRESS(LCD_CRG_PERCTL_ADDR));
+
+    return 0;
+}
+
+gk_s32 sys_hal_vo_out_clk_en(gk_s32 dev, gk_bool clk_en)
+{
+    gk_u32 tmp = (clk_en == GK_TRUE) ? 1 : 0;
+
+    gk_reg_set_bit(tmp, 8, IO_ADDRESS(VOU_CRG_PERCTL_ADDR)); /* 8bit */
+
+    return 0;
+}
+
+gk_s32 sys_hal_lcd_data_mode(gk_u32 data_mode)
+{
+    gk_reg_write32(data_mode << 8, 0x7 << 8, IO_ADDRESS(MISC_CTL18_ADDR)); /* 8bit to set 0x7 */
+
+    return 0;
+}
+
+gk_void hal_sys_control(gk_void)
+{
+    volatile U_VOCTRL VOCTRL;
+
+    /* outstand */
+    VOCTRL.u32 = g_vo_reg->VOCTRL.u32;
+    VOCTRL.u32 = 0x80000000; /* 0x80000000 vo contrl */
+    g_vo_reg->VOCTRL.u32 = VOCTRL.u32;
+}
+
+gk_ulong vo_get_intf_abs_addr(hal_disp_intf intf, gk_ulong reg)
+{
+    volatile gk_ulong reg_abs_addr;
+
+    switch (intf) {
+        case HAL_DISP_INTF_BT656:
+        case HAL_DISP_INTF_BT1120: {
+            reg_abs_addr = reg + 1 * INTF_REGS_LEN;
+            break;
+        }
+
+        case HAL_DISP_INTF_LCD:
+        case HAL_DISP_INTF_LCD_6BIT:
+        case HAL_DISP_INTF_LCD_8BIT:
+        case HAL_DISP_INTF_LCD_16BIT:
+        case HAL_DISP_INTF_LCD_24BIT: {
+            reg_abs_addr = reg + 2 * INTF_REGS_LEN; /* 2 to get addr */
+            break;
+        }
+
+        default: {
+            printf("error intf id found in %s: L%d\n", __FUNCTION__, __LINE__);
+            return 0;
+        }
+    }
+
+    return reg_abs_addr;
+}
+
+gk_ulong vo_get_vid_abs_addr(hal_disp_layer layer, gk_ulong reg)
+{
+    volatile gk_ulong reg_abs_addr;
+
+    switch (layer) {
+        case HAL_DISP_LAYER_VHD0: {
+            reg_abs_addr = reg + (layer - HAL_DISP_LAYER_VHD0) * VID_REGS_LEN;
+            break;
+        }
+
+        default: {
+            return 0;
+        }
+    }
+
+    return reg_abs_addr;
+}
+
+gk_ulong vo_get_gfx_abs_addr(hal_disp_layer layer, gk_ulong reg)
+{
+    volatile gk_ulong reg_abs_addr;
+
+    switch (layer) {
+        case HAL_DISP_LAYER_GFX0: {
+            reg_abs_addr = reg + (layer - HAL_DISP_LAYER_GFX0) * GRF_REGS_LEN;
+            break;
+        }
+
+        default: {
+            return 0;
+        }
+    }
+
+    return reg_abs_addr;
+}
+
+gk_bool hal_disp_set_intf_enable(hal_disp_outputchannel chan, gk_bool intf)
+{
+    volatile U_DHD0_CTRL DHD0_CTRL;
+    volatile gk_ulong addr_reg;
+
+    switch (chan) {
+        case HAL_DISP_CHANNEL_DHD0: {
+            addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->DHD0_CTRL.u32));
+            DHD0_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            DHD0_CTRL.bits.intf_en = intf;
+            hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, DHD0_CTRL.u32);
+            break;
+        }
+
+        default: {
+            return GK_FALSE;
+        }
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_disp_set_lcd_serial_perd(gk_u32 serial_perd)
+{
+    U_INTF_LCD_CTRL INTF_LCD_CTRL;
+    volatile gk_ulong addr_reg;
+
+    addr_reg = vo_get_intf_abs_addr(HAL_DISP_INTF_LCD_8BIT, (gk_uintptr_t)&(g_vo_reg->INTF_HDMI_CTRL.u32));
+    INTF_LCD_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+
+    INTF_LCD_CTRL.bits.lcd_serial_perd = serial_perd;
+
+    hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, INTF_LCD_CTRL.u32);
+    return GK_TRUE;
+}
+
+gk_bool hal_disp_set_intf_ctrl(hal_disp_intf intf, const gk_u32 *ctrl_info)
+{
+    U_INTF_BT_CTRL INTF_BT_CTRL;
+    U_INTF_LCD_CTRL INTF_LCD_CTRL;
+    volatile gk_ulong addr_reg;
+    U_INTF_BT_CTRL *bt_ctrl = GK_NULL;
+    U_INTF_LCD_CTRL *lcd_ctrl = GK_NULL;
+
+    if ((intf == VO_INTF_BT1120) || (intf == VO_INTF_BT656)) {
+        bt_ctrl = (U_INTF_BT_CTRL *)ctrl_info;
+        addr_reg = vo_get_intf_abs_addr(intf, (gk_uintptr_t)&(g_vo_reg->INTF_HDMI_CTRL.u32));
+        INTF_BT_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        INTF_BT_CTRL.bits.hdmi_mode = bt_ctrl->bits.hdmi_mode;
+        INTF_BT_CTRL.bits.lcd_serial_mode = bt_ctrl->bits.lcd_serial_mode;
+        INTF_BT_CTRL.bits.lcd_parallel_order = bt_ctrl->bits.lcd_parallel_order;
+        INTF_BT_CTRL.bits.lcd_data_inv = bt_ctrl->bits.lcd_data_inv;
+        INTF_BT_CTRL.bits.lcd_parallel_mode = bt_ctrl->bits.lcd_parallel_mode;
+        hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, INTF_BT_CTRL.u32);
+    } else if ((intf == VO_INTF_LCD) || (intf == VO_INTF_LCD_6BIT) ||
+               (intf == VO_INTF_LCD_8BIT) || (intf == VO_INTF_LCD_16BIT)) {
+        lcd_ctrl = (U_INTF_LCD_CTRL *)ctrl_info;
+        addr_reg = vo_get_intf_abs_addr(intf, (gk_uintptr_t)&(g_vo_reg->INTF_HDMI_CTRL.u32));
+        INTF_LCD_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        INTF_LCD_CTRL.bits.hdmi_mode = lcd_ctrl->bits.hdmi_mode;
+        INTF_LCD_CTRL.bits.lcd_serial_mode = lcd_ctrl->bits.lcd_serial_mode;
+        INTF_LCD_CTRL.bits.lcd_parallel_order = lcd_ctrl->bits.lcd_parallel_order;
+        INTF_LCD_CTRL.bits.lcd_data_inv = lcd_ctrl->bits.lcd_data_inv;
+        INTF_LCD_CTRL.bits.lcd_parallel_mode = lcd_ctrl->bits.lcd_parallel_mode;
+        hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, INTF_LCD_CTRL.u32);
+    } else {
+        return GK_FALSE;
+    }
+
+    return GK_TRUE;
+}
+
+static gk_void hal_disp_set_intf_vertical_sync(hal_disp_outputchannel chan,
+                                               const hal_disp_syncinfo *sync_info)
+{
+    volatile U_DHD0_VSYNC1 DHD0_VSYNC1;
+    volatile U_DHD0_VSYNC2 DHD0_VSYNC2;
+    volatile U_DHD0_VPLUS1 DHD0_VPLUS1;
+    volatile U_DHD0_VPLUS2 DHD0_VPLUS2;
+
+    volatile gk_ulong addr_reg;
+
+    /* register is the value -1 */
+    addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->DHD0_VSYNC1.u32));
+    DHD0_VSYNC1.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    DHD0_VSYNC1.bits.vact = sync_info->vact - 1;
+    DHD0_VSYNC1.bits.vbb = sync_info->vbb - 1;
+    hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, DHD0_VSYNC1.u32);
+
+    addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->DHD0_VSYNC2.u32));
+    DHD0_VSYNC2.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    DHD0_VSYNC2.bits.vfb = sync_info->vfb - 1;
+    hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, DHD0_VSYNC2.u32);
+
+    addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->DHD0_VPLUS1.u32));
+    DHD0_VPLUS1.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    DHD0_VPLUS1.bits.bvact = sync_info->bvact - 1;
+    DHD0_VPLUS1.bits.bvbb = sync_info->bvbb - 1;
+    hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, DHD0_VPLUS1.u32);
+
+    addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->DHD0_VPLUS2.u32));
+    DHD0_VPLUS2.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    DHD0_VPLUS2.bits.bvfb = sync_info->bvfb - 1;
+    hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, DHD0_VPLUS2.u32);
+
+    return;
+}
+
+gk_bool hal_disp_set_intf_sync(hal_disp_outputchannel chan,
+                               const hal_disp_syncinfo *sync_info, const hal_disp_syncinv *inv)
+{
+    volatile U_DHD0_CTRL DHD0_CTRL;
+    volatile U_DHD0_HSYNC1 DHD0_HSYNC1;
+    volatile U_DHD0_HSYNC2 DHD0_HSYNC2;
+    volatile U_DHD0_PWR DHD0_PWR;
+
+    volatile gk_ulong addr_reg;
+
+    switch (chan) {
+        case HAL_DISP_CHANNEL_DHD0: {
+            addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->DHD0_CTRL.u32));
+            DHD0_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            DHD0_CTRL.bits.iop = sync_info->iop;
+            DHD0_CTRL.bits.intf_ihs = inv->hs_inv;
+            DHD0_CTRL.bits.intf_ivs = inv->vs_inv;
+            DHD0_CTRL.bits.intf_idv = inv->dv_inv;
+            hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, DHD0_CTRL.u32);
+
+            addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->DHD0_HSYNC1.u32));
+            DHD0_HSYNC1.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            DHD0_HSYNC1.bits.hact = sync_info->hact - 1;
+            DHD0_HSYNC1.bits.hbb = (sync_info->hbb) - 1;
+            hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, DHD0_HSYNC1.u32);
+
+            addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->DHD0_HSYNC2.u32));
+            DHD0_HSYNC2.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            DHD0_HSYNC2.bits.hmid = (sync_info->hmid == 0) ? 0 : sync_info->hmid - 1;
+            DHD0_HSYNC2.bits.hfb = (sync_info->hfb) - 1;
+            hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, DHD0_HSYNC2.u32);
+
+            hal_disp_set_intf_vertical_sync(chan, sync_info);
+
+            addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->DHD0_PWR.u32));
+            DHD0_PWR.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            DHD0_PWR.bits.hpw = sync_info->hpw - 1;
+            DHD0_PWR.bits.vpw = sync_info->vpw - 1;
+            hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, DHD0_PWR.u32);
+
+            break;
+        }
+
+        default: {
+            return GK_FALSE;
+        }
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_disp_set_dev_multi_chn_en(hal_disp_outputchannel chn, hal_multi_chn multi_chn_en)
+{
+    volatile U_DHD0_PWR DHD0_PWR;
+    volatile gk_ulong addr_reg;
+    addr_reg = vo_get_chn_abs_addr(chn, (gk_uintptr_t)&(g_vo_reg->DHD0_PWR.u32));
+    DHD0_PWR.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    DHD0_PWR.bits.multichn_en = multi_chn_en;
+    hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, DHD0_PWR.u32);
+
+    return GK_TRUE;
+}
+
+gk_bool hal_disp_set_intf_mux_sel(hal_disp_outputchannel chan, hal_disp_intf intf)
+{
+    volatile U_VO_MUX VO_MUX;
+    volatile gk_ulong addr_reg;
+
+    addr_reg = (gk_uintptr_t)&(g_vo_reg->VO_MUX.u32);
+    VO_MUX.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    /* the numbers below are register config, not magic number. */
+    switch (intf) {
+        case HAL_DISP_INTF_BT1120: {
+            VO_MUX.bits.digital_sel = 0;
+            VO_MUX.bits.bt_sel = 0;
+            break;
+        }
+
+        case HAL_DISP_INTF_BT656: {
+            VO_MUX.bits.digital_sel = 1;
+            VO_MUX.bits.bt_sel = 0;
+            break;
+        }
+
+        case HAL_DISP_INTF_LCD:
+        case HAL_DISP_INTF_LCD_6BIT:
+        case HAL_DISP_INTF_LCD_8BIT:
+        case HAL_DISP_INTF_LCD_16BIT: {
+            VO_MUX.bits.digital_sel = 2; /* 2 register config */
+            VO_MUX.bits.lcd_sel = 0;
+            break;
+        }
+
+        default: {
+            VO_MUX.bits.digital_sel = 15; /* 15 register config */
+        }
+    }
+
+    hal_write_reg((gk_u32*)(gk_uintptr_t)&(g_vo_reg->VO_MUX.u32), VO_MUX.u32);
+
+    return GK_TRUE;
+}
+
+gk_bool hal_disp_set_intf_clip(hal_disp_intf intf,
+                               gk_bool clip,
+                               const hal_disp_clip *clip_data)
+{
+    volatile U_BT_CLIP0_L BT_CLIP0_L;
+    volatile U_BT_CLIP0_H BT_CLIP0_H;
+    volatile gk_ulong addr_reg;
+
+    addr_reg = (gk_uintptr_t)&(g_vo_reg->BT_CLIP0_L.u32);
+    BT_CLIP0_L.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    BT_CLIP0_L.bits.clip_en = clip;
+    BT_CLIP0_L.bits.clip_cl2 = clip_data->clip_low_y;
+    BT_CLIP0_L.bits.clip_cl1 = clip_data->clip_low_cb;
+    BT_CLIP0_L.bits.clip_cl0 = clip_data->clip_low_cr;
+    hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, BT_CLIP0_L.u32);
+
+    addr_reg = (gk_uintptr_t)&(g_vo_reg->BT_CLIP0_H.u32);
+    BT_CLIP0_H.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    BT_CLIP0_H.bits.clip_ch2 = clip_data->clip_high_y;
+    BT_CLIP0_H.bits.clip_ch1 = clip_data->clip_high_cb;
+    BT_CLIP0_H.bits.clip_ch0 = clip_data->clip_high_cr;
+    hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, BT_CLIP0_H.u32);
+
+    return GK_TRUE;
+}
+
+gk_bool hal_disp_set_vt_thd_mode(hal_disp_outputchannel chan, gk_u32 field_mode)
+{
+    volatile U_DHD0_VTTHD DHD0_VTTHD;
+    volatile gk_ulong addr_reg;
+
+    switch (chan) {
+        case HAL_DISP_CHANNEL_DHD0: {
+            addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->DHD0_VTTHD.u32));
+            DHD0_VTTHD.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            DHD0_VTTHD.bits.thd1_mode = field_mode;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, DHD0_VTTHD.u32);
+            break;
+        }
+
+        default: {
+            return GK_FALSE;
+        }
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_disp_set_vt_thd(hal_disp_outputchannel chan, gk_u32 vtthd)
+{
+    volatile U_DHD0_VTTHD DHD0_VTTHD;
+    volatile gk_ulong addr_reg;
+
+    switch (chan) {
+        case HAL_DISP_CHANNEL_DHD0: {
+            addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->DHD0_VTTHD.u32));
+            DHD0_VTTHD.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            DHD0_VTTHD.bits.vtmgthd1 = vtthd;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, DHD0_VTTHD.u32);
+            break;
+        }
+
+        default: {
+            return GK_FALSE;
+        }
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_disp_set_int_mask(gk_u32 mask_en)
+{
+    volatile U_VOINTMSK VOINTMSK;
+    /* dispaly interrupt mask enable */
+    VOINTMSK.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)&(g_vo_reg->VOINTMSK.u32));
+    VOINTMSK.u32 = VOINTMSK.u32 | mask_en;
+    hal_write_reg((gk_u32*)(gk_uintptr_t)&(g_vo_reg->VOINTMSK.u32), VOINTMSK.u32);
+
+    return GK_TRUE;
+}
+
+gk_bool hal_disp_clr_int_mask(gk_u32 mask_en)
+{
+    volatile U_VOINTMSK VOINTMSK;
+
+    /* dispaly interrupt mask enable */
+    VOINTMSK.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)&(g_vo_reg->VOINTMSK.u32));
+    VOINTMSK.u32 = VOINTMSK.u32 & (~mask_en);
+    hal_write_reg((gk_u32*)(gk_uintptr_t)&(g_vo_reg->VOINTMSK.u32), VOINTMSK.u32);
+
+    return GK_TRUE;
+}
+
+gk_void hal_disp_set_reg_up(hal_disp_outputchannel chan)
+{
+    volatile U_DHD0_CTRL DHD0_CTRL;
+    volatile gk_ulong addr_reg;
+
+    if (chan >= HAL_DISP_CHANNEL_DHD1) {
+        printf("error,hal_disp_set_reg_up select wrong CHANNEL ID\n");
+        return;
+    }
+
+    addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->DHD0_CTRL.u32));
+    DHD0_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    DHD0_CTRL.bits.regup = 0x1; /* 0x1 reg up */
+    hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, DHD0_CTRL.u32);
+    return;
+}
+
+gk_bool hal_video_set_layer_up_mode(hal_disp_layer layer, gk_u32 up_mode)
+{
+    U_V0_CTRL V0_CTRL;
+    volatile gk_ulong addr_reg;
+
+    switch (layer) {
+        case HAL_DISP_LAYER_VHD0: {
+            addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_CTRL.u32));
+            V0_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            V0_CTRL.bits.rgup_mode = up_mode;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_CTRL.u32);
+            break;
+        }
+
+        default: {
+            return GK_FALSE;
+        }
+    }
+
+    return GK_TRUE;
+}
+
+gk_void hal_video_hfir_set_ck_gt_en(hal_disp_layer layer, gk_u32 ck_gt_en)
+{
+    U_V0_HFIR_CTRL V0_HFIR_CTRL;
+    volatile gk_u32 addr_reg;
+
+    if ((layer >= LAYER_VHD_START) && (layer <= LAYER_VHD_END)) {
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_HFIR_CTRL.u32));
+        V0_HFIR_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_HFIR_CTRL.bits.ck_gt_en = ck_gt_en;
+        hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_HFIR_CTRL.u32);
+    }
+
+    return;
+}
+
+gk_void hal_video_cvfir_set_out_height(hal_disp_layer layer, gk_u32 out_height)
+{
+    U_V0_CVFIR_VINFO V0_CVFIR_VINFO;
+    volatile gk_u32 addr_reg;
+
+    if ((layer >= LAYER_VHD_START) && (layer <= LAYER_VHD_END)) {
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_CVFIR_VINFO.u32));
+        V0_CVFIR_VINFO.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_CVFIR_VINFO.bits.out_height = out_height - 1;
+        hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_CVFIR_VINFO.u32);
+    }
+
+    return;
+}
+
+gk_void hal_video_cvfir_set_out_fmt(hal_disp_layer layer, gk_u32 out_fmt)
+{
+    U_V0_CVFIR_VINFO V0_CVFIR_VINFO;
+    volatile gk_u32 addr_reg;
+
+    if ((layer >= LAYER_VHD_START) && (layer <= LAYER_VHD_END)) {
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_CVFIR_VINFO.u32));
+        V0_CVFIR_VINFO.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_CVFIR_VINFO.bits.out_fmt = out_fmt;
+        hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_CVFIR_VINFO.u32);
+    }
+
+    return;
+}
+
+gk_void hal_video_cvfir_set_out_pro(hal_disp_layer layer, gk_u32 out_pro)
+{
+    U_V0_CVFIR_VINFO V0_CVFIR_VINFO;
+    volatile gk_u32 addr_reg;
+
+    if ((layer >= LAYER_VHD_START) && (layer <= LAYER_VHD_END)) {
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_CVFIR_VINFO.u32));
+        V0_CVFIR_VINFO.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_CVFIR_VINFO.bits.out_pro = out_pro;
+        hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_CVFIR_VINFO.u32);
+    }
+
+    return;
+}
+
+gk_void hal_video_cvfir_set_vzme_ck_gt_en(hal_disp_layer layer, gk_bool vzme_ck_gt_en)
+{
+    U_V0_CVFIR_VINFO V0_CVFIR_VINFO;
+    volatile gk_u32 addr_reg;
+
+    if ((layer >= LAYER_VHD_START) && (layer <= LAYER_VHD_END)) {
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_CVFIR_VINFO.u32));
+        V0_CVFIR_VINFO.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_CVFIR_VINFO.bits.vzme_ck_gt_en = vzme_ck_gt_en;
+        hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_CVFIR_VINFO.u32);
+    }
+
+    return;
+}
+
+gk_void hal_video_cvfir_set_cvfir_en(hal_disp_layer layer, gk_u32 cvfir_en)
+{
+    U_V0_CVFIR_VSP V0_CVFIR_VSP;
+    volatile gk_u32 addr_reg;
+
+    if ((layer >= LAYER_VHD_START) && (layer <= LAYER_VHD_END)) {
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_CVFIR_VSP.u32));
+        V0_CVFIR_VSP.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_CVFIR_VSP.bits.cvfir_en = cvfir_en;
+        hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_CVFIR_VSP.u32);
+    }
+
+    return;
+}
+
+gk_void hal_video_cvfir_set_cvmid_en(hal_disp_layer layer, gk_u32 cvmid_en)
+{
+    U_V0_CVFIR_VSP V0_CVFIR_VSP;
+    volatile gk_u32 addr_reg;
+
+    if ((layer >= LAYER_VHD_START) && (layer <= LAYER_VHD_END)) {
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_CVFIR_VSP.u32));
+        V0_CVFIR_VSP.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_CVFIR_VSP.bits.cvmid_en = cvmid_en;
+        hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_CVFIR_VSP.u32);
+    }
+
+    return;
+}
+
+gk_void hal_video_cvfir_set_cvfir_mode(hal_disp_layer layer, gk_u32 cvfir_mode)
+{
+    U_V0_CVFIR_VSP V0_CVFIR_VSP;
+    volatile gk_u32 addr_reg;
+
+    if ((layer >= LAYER_VHD_START) && (layer <= LAYER_VHD_END)) {
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_CVFIR_VSP.u32));
+        V0_CVFIR_VSP.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_CVFIR_VSP.bits.cvfir_mode = cvfir_mode;
+        hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_CVFIR_VSP.u32);
+    }
+
+    return;
+}
+
+gk_void hal_video_cvfir_set_vratio(hal_disp_layer layer, gk_u32 vratio)
+{
+    U_V0_CVFIR_VSP V0_CVFIR_VSP;
+    volatile gk_u32 addr_reg;
+
+    if ((layer >= LAYER_VHD_START) && (layer <= LAYER_VHD_END)) {
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_CVFIR_VSP.u32));
+        V0_CVFIR_VSP.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_CVFIR_VSP.bits.vratio = vratio;
+        hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_CVFIR_VSP.u32);
+    }
+
+    return;
+}
+
+gk_void hal_video_cvfir_set_v_chroma_offset(hal_disp_layer layer, gk_u32 vchroma_offset)
+{
+    U_V0_CVFIR_VOFFSET V0_CVFIR_VOFFSET;
+    volatile gk_u32 addr_reg;
+
+    if ((layer >= LAYER_VHD_START) && (layer <= LAYER_VHD_END)) {
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_CVFIR_VOFFSET.u32));
+        V0_CVFIR_VOFFSET.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_CVFIR_VOFFSET.bits.vchroma_offset = vchroma_offset;
+        hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_CVFIR_VOFFSET.u32);
+    }
+
+    return;
+}
+
+gk_void hal_video_cvfir_set_vb_chroma_offset(hal_disp_layer layer, gk_u32 vbchroma_offset)
+{
+    U_V1_CVFIR_VBOFFSET V0_CVFIR_VBOFFSET;
+    volatile gk_u32 addr_reg;
+
+    if ((layer >= LAYER_VHD_START) && (layer <= LAYER_VHD_END)) {
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_CVFIR_VBOFFSET.u32));
+        V0_CVFIR_VBOFFSET.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_CVFIR_VBOFFSET.bits.vbchroma_offset = vbchroma_offset;
+        hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_CVFIR_VBOFFSET.u32);
+    }
+
+    return;
+}
+
+gk_void hal_video_hfir_set_mid_en(hal_disp_layer layer, gk_u32 mid_en)
+{
+    U_V0_HFIR_CTRL V0_HFIR_CTRL;
+    volatile gk_ulong addr_reg;
+
+    if ((layer >= LAYER_VHD_START) && (layer <= LAYER_VHD_END)) {
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_HFIR_CTRL.u32));
+        V0_HFIR_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_HFIR_CTRL.bits.mid_en = mid_en;
+        hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_HFIR_CTRL.u32);
+    }
+
+    return;
+}
+
+gk_void vdp_fdr_vid_set_chm_copy_en(gk_u32 layer, gk_u32 chm_copy_en)
+{
+    U_VID_READ_CTRL VID_READ_CTRL;
+
+    VID_READ_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)(&(g_vo_reg->VID_READ_CTRL.u32) + layer * FDR_VID_OFFSET));
+    VID_READ_CTRL.bits.chm_copy_en = chm_copy_en;
+    hal_write_reg ((gk_u32*)(gk_uintptr_t)(&(g_vo_reg->VID_READ_CTRL.u32) + layer * FDR_VID_OFFSET),
+                   VID_READ_CTRL.u32);
+    return;
+}
+
+gk_bool hal_video_set_hfir_mode(hal_disp_layer layer, hal_hfirmode mode)
+{
+    volatile U_V0_HFIR_CTRL V0_HFIR_CTRL;
+    volatile gk_ulong addr_reg;
+
+    switch (layer) {
+        case HAL_DISP_LAYER_VHD0: {
+            addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_HFIR_CTRL.u32));
+            V0_HFIR_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            V0_HFIR_CTRL.bits.hfir_mode = mode;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_HFIR_CTRL.u32);
+            break;
+        }
+
+        default: {
+            return GK_FALSE;
+        }
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_video_hfir_set_coef(hal_disp_layer layer, const hfir_coef *coef)
+{
+    volatile U_V0_HFIRCOEF01 V0_HFIRCOEF01;
+    volatile U_V0_HFIRCOEF23 V0_HFIRCOEF23;
+    volatile U_V0_HFIRCOEF45 V0_HFIRCOEF45;
+    volatile U_V0_HFIRCOEF67 V0_HFIRCOEF67;
+    volatile gk_ulong addr_reg;
+
+    if ((layer >= LAYER_VHD_START) && (layer <= LAYER_VHD_END)) {
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_HFIRCOEF01.u32));
+        V0_HFIRCOEF01.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_HFIRCOEF01.bits.coef0 = coef->coef0;
+        V0_HFIRCOEF01.bits.coef1 = coef->coef1;
+        hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_HFIRCOEF01.u32);
+
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_HFIRCOEF23.u32));
+        V0_HFIRCOEF23.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_HFIRCOEF23.bits.coef2 = coef->coef2;
+        V0_HFIRCOEF23.bits.coef3 = coef->coef3;
+        hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_HFIRCOEF23.u32);
+
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_HFIRCOEF45.u32));
+        V0_HFIRCOEF45.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_HFIRCOEF45.bits.coef4 = coef->coef4;
+        V0_HFIRCOEF45.bits.coef5 = coef->coef5;
+        hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_HFIRCOEF45.u32);
+
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_HFIRCOEF67.u32));
+        V0_HFIRCOEF67.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_HFIRCOEF67.bits.coef6 = coef->coef6;
+        V0_HFIRCOEF67.bits.coef7 = coef->coef7;
+        hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_HFIRCOEF67.u32);
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_video_set_layer_disp_rect(hal_disp_layer layer, const gk_rect *rect)
+{
+    volatile U_V0_DFPOS V0_DFPOS;
+    volatile U_V0_DLPOS V0_DLPOS;
+    volatile U_G0_DFPOS G0_DFPOS;
+    volatile U_G0_DLPOS G0_DLPOS;
+    volatile gk_ulong addr_reg;
+
+    switch (layer) {
+        case HAL_DISP_LAYER_VHD0: {
+            addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_DFPOS.u32));
+            V0_DFPOS.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            V0_DFPOS.bits.disp_xfpos = rect->x;
+            V0_DFPOS.bits.disp_yfpos = rect->y;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_DFPOS.u32);
+
+            addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_DLPOS.u32));
+            V0_DLPOS.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            V0_DLPOS.bits.disp_xlpos = rect->x + rect->width - 1;
+            V0_DLPOS.bits.disp_ylpos = rect->y + rect->height - 1;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_DLPOS.u32);
+            break;
+        }
+
+        case HAL_DISP_LAYER_GFX0: {
+            addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->G0_DFPOS));
+            G0_DFPOS.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            G0_DFPOS.bits.disp_xfpos = rect->x;
+            G0_DFPOS.bits.disp_yfpos = rect->y;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, G0_DFPOS.u32);
+
+            addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->G0_DLPOS));
+            G0_DLPOS.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            G0_DLPOS.bits.disp_xlpos = rect->x + rect->width - 1;
+            G0_DLPOS.bits.disp_ylpos = rect->y + rect->height - 1;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, G0_DLPOS.u32);
+            break;
+        }
+
+        default: {
+            printf("error layer id found in %s: L%d\n", __FUNCTION__, __LINE__);
+            return GK_FALSE;
+        }
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_video_set_layer_video_rect(hal_disp_layer layer, const gk_rect *rect)
+{
+    volatile U_V0_VFPOS V0_VFPOS;
+    volatile U_V0_VLPOS V0_VLPOS;
+    volatile U_G0_VFPOS G0_VFPOS;
+    volatile U_G0_VLPOS G0_VLPOS;
+    volatile gk_ulong addr_reg;
+
+    switch (layer) {
+        case HAL_DISP_LAYER_VHD0: {
+            addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_VFPOS.u32));
+            V0_VFPOS.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            V0_VFPOS.bits.video_xfpos = rect->x;
+            V0_VFPOS.bits.video_yfpos = rect->y;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_VFPOS.u32);
+
+            addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_VLPOS.u32));
+            V0_VLPOS.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            V0_VLPOS.bits.video_xlpos = rect->x + rect->width - 1;
+            V0_VLPOS.bits.video_ylpos = rect->y + rect->height - 1;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_VLPOS.u32);
+
+            break;
+        }
+
+        case HAL_DISP_LAYER_GFX0: {
+            addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->G0_VFPOS));
+            G0_VFPOS.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            G0_VFPOS.bits.video_xfpos = rect->x;
+            G0_VFPOS.bits.video_yfpos = rect->y;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, G0_VFPOS.u32);
+
+            addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->G0_VLPOS));
+            G0_VLPOS.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            G0_VLPOS.bits.video_xlpos = rect->x + rect->width - 1;
+            G0_VLPOS.bits.video_ylpos = rect->y + rect->height - 1;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, G0_VLPOS.u32);
+            break;
+        }
+
+        default: {
+            printf("error layer id %d# found in %s,%s: L%d\n", layer, __FILE__, __FUNCTION__, __LINE__);
+            return GK_FALSE;
+        }
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_video_set_multi_area_l_addr(hal_disp_layer layer, gk_u32 area_num, gk_ulong l_addr, gk_u16 stride)
+{
+    gk_ulong pxaddr_addr;
+    gk_ulong pxstride_addr;
+    U_VID_STRIDE VID_STRIDE;
+
+    if (layer == HAL_DISP_LAYER_VHD0) {
+        pxaddr_addr = vo_get_vid_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->VID_ADDR_L));
+        hal_write_reg((gk_u32*)(gk_uintptr_t)pxaddr_addr, get_low_addr(l_addr));
+
+        pxaddr_addr = vo_get_vid_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->VID_ADDR_H));
+        hal_write_reg((gk_u32*)(gk_uintptr_t)pxaddr_addr, get_high_addr(l_addr));
+
+        pxstride_addr = vo_get_vid_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->VID_STRIDE.u32));
+        VID_STRIDE.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)pxstride_addr);
+        VID_STRIDE.bits.lm_stride = stride;
+        hal_write_reg((gk_u32*)(gk_uintptr_t)pxstride_addr, VID_STRIDE.u32);
+    } else {
+        return GK_FALSE;
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_video_set_multi_area_c_addr(hal_disp_layer layer, gk_u32 area_num, gk_ulong c_addr, gk_u16 stride)
+{
+    gk_ulong pxaddr_addr;
+    gk_ulong pxstride_addr;
+    U_VID_STRIDE VID_STRIDE;
+
+    if (layer == HAL_DISP_LAYER_VHD0) {
+        pxaddr_addr = vo_get_vid_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->VID_CADDR_L));
+        hal_write_reg((gk_u32*)(gk_uintptr_t)pxaddr_addr, get_low_addr(c_addr));
+
+        pxaddr_addr = vo_get_vid_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->VID_CADDR_H));
+        hal_write_reg((gk_u32*)(gk_uintptr_t)pxaddr_addr, get_high_addr(c_addr));
+
+        pxstride_addr = vo_get_vid_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->VID_STRIDE.u32));
+        VID_STRIDE.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)pxstride_addr);
+        VID_STRIDE.bits.chm_stride = stride;
+        hal_write_reg((gk_u32*)(gk_uintptr_t)pxstride_addr, VID_STRIDE.u32);
+    } else {
+        return GK_FALSE;
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_layer_enable_layer(hal_disp_layer layer, gk_u32 enable)
+{
+    volatile U_V0_CTRL V0_CTRL;
+    volatile U_G0_CTRL G0_CTRL;
+    volatile gk_ulong addr_reg;
+
+    switch (layer) {
+        case HAL_DISP_LAYER_VHD0: {
+            addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_CTRL.u32));
+            V0_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            V0_CTRL.bits.surface_en = enable;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_CTRL.u32);
+            break;
+        }
+
+        case HAL_DISP_LAYER_GFX0: {
+            addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->G0_CTRL));
+            G0_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            G0_CTRL.bits.surface_en = enable;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, G0_CTRL.u32);
+            break;
+        }
+
+        default: {
+            printf("error layer:%d id found in %s: L%d\n", layer, __FUNCTION__, __LINE__);
+            return GK_FALSE;
+        }
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_layer_set_layer_data_fmt(hal_disp_layer layer,
+                                     hal_disp_pixel_format data_fmt)
+{
+    volatile U_VID_SRC_INFO VID_SRC_INFO;
+    volatile U_GFX_SRC_INFO GFX_SRC_INFO;
+    volatile gk_ulong addr_reg;
+
+    if (layer == HAL_DISP_LAYER_VHD0) {
+        addr_reg = vo_get_vid_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->VID_SRC_INFO.u32));
+        VID_SRC_INFO.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        VID_SRC_INFO.bits.data_type = data_fmt;
+        hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, VID_SRC_INFO.u32);
+    } else if (layer == HAL_DISP_LAYER_GFX0) {
+        addr_reg = vo_get_gfx_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->GFX_SRC_INFO.u32));
+        GFX_SRC_INFO.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        GFX_SRC_INFO.bits.ifmt = data_fmt;
+        hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, GFX_SRC_INFO.u32);
+    } else {
+        printf("error layer id%d found in %s: L%d\n", layer, __FUNCTION__, __LINE__);
+        return GK_FALSE;
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_layer_set_layer_in_rect(hal_disp_layer layer, const gk_rect *rect)
+{
+    U_VID_IN_RESO VID_IN_RESO;
+    U_GFX_IRESO GFX_IRESO;
+    volatile gk_ulong addr_reg;
+
+    if (layer == HAL_DISP_LAYER_VHD0) {
+        addr_reg = vo_get_vid_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->VID_IN_RESO.u32));
+        VID_IN_RESO.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        VID_IN_RESO.bits.ireso_w = rect->width - 1;
+        VID_IN_RESO.bits.ireso_h = rect->height - 1;
+        hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, VID_IN_RESO.u32);
+    } else if (layer == HAL_DISP_LAYER_GFX0) {
+        addr_reg = vo_get_gfx_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->GFX_IRESO.u32));
+        GFX_IRESO.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        GFX_IRESO.bits.ireso_w = rect->width - 1;
+        GFX_IRESO.bits.ireso_h = rect->height - 1;
+        hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, GFX_IRESO.u32);
+    } else {
+        return GK_FALSE;
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_layer_set_layer_galpha(hal_disp_layer layer,
+                                   gk_u8 alpha0)
+{
+    volatile U_V0_CTRL V0_CTRL;
+    volatile gk_ulong addr_reg;
+
+    switch (layer) {
+        case HAL_DISP_LAYER_VHD0: {
+            addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_CTRL.u32));
+            V0_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            V0_CTRL.bits.galpha = alpha0;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_CTRL.u32);
+            break;
+        }
+
+        default: {
+            return GK_FALSE;
+        }
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_layer_set_zme_info(hal_disp_layer layer, gk_u32 width, gk_u32 height,
+                               hal_disp_zme_outfmt zme_out_fmt)
+{
+    volatile U_V0_ZME_HINFO V0_ZME_HINFO;
+    volatile U_V0_ZME_VINFO V0_ZME_VINFO;
+    volatile gk_ulong addr_reg;
+
+    if (layer == HAL_DISP_LAYER_VHD0) {
+        addr_reg = (gk_uintptr_t)&(g_vo_reg->V0_ZME_HINFO.u32);
+        V0_ZME_HINFO.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_ZME_HINFO.bits.out_width = width - 1;
+        hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_ZME_HINFO.u32);
+
+        addr_reg = (gk_uintptr_t)&(g_vo_reg->V0_ZME_VINFO.u32);
+        V0_ZME_VINFO.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_ZME_VINFO.bits.out_pro = 1;
+        V0_ZME_VINFO.bits.out_height = height - 1;
+        V0_ZME_VINFO.bits.out_fmt = zme_out_fmt;
+        hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_ZME_VINFO.u32);
+    } else {
+        return GK_FALSE;
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_layer_set_src_resolution(hal_disp_layer layer,
+                                     const gk_rect *rect)
+{
+    U_VID_SRC_RESO VID_SRC_RESO;
+    volatile gk_ulong addr_reg;
+
+    if (layer == HAL_DISP_LAYER_VHD0) {
+        addr_reg = vo_get_vid_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->VID_SRC_RESO.u32));
+        VID_SRC_RESO.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        VID_SRC_RESO.bits.src_w = rect->width - 1;
+        VID_SRC_RESO.bits.src_h = rect->height - 1;
+        hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, VID_SRC_RESO.u32);
+    }
+
+    return GK_TRUE;
+}
+
+/* vou zoom enable */
+gk_bool hal_layer_set_zme_enable(hal_disp_layer layer,
+                                 hal_disp_zmemode mode,
+                                 gk_u32 enable)
+{
+    volatile U_V0_ZME_HSP V0_ZME_HSP;
+    volatile U_V0_ZME_VSP V0_ZME_VSP;
+
+    volatile U_V1_CVFIR_VSP V1_CVFIR_VSP;
+
+    volatile gk_ulong addr_reg;
+
+    if (layer == HAL_DISP_LAYER_VHD0) {
+        if ((mode == HAL_DISP_ZMEMODE_HORL) || (mode == HAL_DISP_ZMEMODE_HOR) || (mode == HAL_DISP_ZMEMODE_ALL)) {
+            addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_ZME_HSP.u32));
+            V0_ZME_HSP.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            V0_ZME_HSP.bits.lhfir_en = enable;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_ZME_HSP.u32);
+        }
+
+        if ((mode == HAL_DISP_ZMEMODE_HORC) || (mode == HAL_DISP_ZMEMODE_HOR) || (mode == HAL_DISP_ZMEMODE_ALL)) {
+            addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_ZME_HSP.u32));
+            V0_ZME_HSP.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            V0_ZME_HSP.bits.chfir_en = enable;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_ZME_HSP.u32);
+        }
+
+        if ((mode == HAL_DISP_ZMEMODE_VERL) || (mode == HAL_DISP_ZMEMODE_VER) || (mode == HAL_DISP_ZMEMODE_ALL)) {
+            addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_ZME_VSP.u32));
+            V0_ZME_VSP.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            V0_ZME_VSP.bits.lvfir_en = enable;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_ZME_VSP.u32);
+        }
+
+        if ((mode == HAL_DISP_ZMEMODE_VERC) || (mode == HAL_DISP_ZMEMODE_VER) || (mode == HAL_DISP_ZMEMODE_ALL)) {
+            addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_ZME_VSP.u32));
+            V0_ZME_VSP.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            V0_ZME_VSP.bits.cvfir_en = enable;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_ZME_VSP.u32);
+        }
+    } else if (layer == HAL_DISP_LAYER_VHD1) {
+        if ((mode == HAL_DISP_ZMEMODE_VERL) || (mode == HAL_DISP_ZMEMODE_VER) || (mode == HAL_DISP_ZMEMODE_ALL)) {
+            addr_reg = (gk_uintptr_t)&(g_vo_reg->V1_CVFIR_VSP.u32);
+            V1_CVFIR_VSP.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            V1_CVFIR_VSP.bits.cvfir_en = enable;
+            V1_CVFIR_VSP.bits.cvmid_en = enable;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V1_CVFIR_VSP.u32);
+        }
+    } else {
+        return GK_FALSE;
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_disp_set_dither_round_unlim(hal_disp_outputchannel chan, gk_u32 dither_round_unlim)
+{
+    volatile U_INTF0_DITHER_CTRL INTF0_DITHER_CTRL;
+    volatile gk_ulong addr_reg;
+
+    switch (chan) {
+        case HAL_DISP_CHANNEL_DHD0: {
+            addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->INTF0_DITHER_CTRL.u32));
+            INTF0_DITHER_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            INTF0_DITHER_CTRL.bits.dither_round_unlim = dither_round_unlim;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, INTF0_DITHER_CTRL.u32);
+            break;
+        }
+
+        default: {
+            return GK_FALSE;
+        }
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_disp_set_dither_data_in_out(hal_disp_outputchannel chan, gk_u32 i_data_width_dither,
+                                        gk_u32 o_data_width_dither)
+{
+    volatile U_INTF0_DITHER_CTRL INTF0_DITHER_CTRL;
+    volatile gk_ulong addr_reg;
+
+    switch (chan) {
+        case HAL_DISP_CHANNEL_DHD0: {
+            addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->INTF0_DITHER_CTRL.u32));
+            INTF0_DITHER_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            INTF0_DITHER_CTRL.bits.i_data_width_dither = i_data_width_dither;
+            INTF0_DITHER_CTRL.bits.o_data_width_dither = o_data_width_dither;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, INTF0_DITHER_CTRL.u32);
+            break;
+        }
+
+        default: {
+            return GK_FALSE;
+        }
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_disp_set_dither_en(hal_disp_outputchannel chan, gk_u32 dither_en)
+{
+    volatile U_INTF0_DITHER_CTRL INTF0_DITHER_CTRL;
+    volatile gk_ulong addr_reg;
+
+    switch (chan) {
+        case HAL_DISP_CHANNEL_DHD0: {
+            addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->INTF0_DITHER_CTRL.u32));
+            INTF0_DITHER_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            INTF0_DITHER_CTRL.bits.dither_en = dither_en;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, INTF0_DITHER_CTRL.u32);
+            break;
+        }
+
+        default: {
+            return GK_FALSE;
+        }
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_disp_set_dither_mode(hal_disp_outputchannel chan, gk_u32 dither_mode)
+{
+    volatile U_INTF0_DITHER_CTRL INTF0_DITHER_CTRL;
+    volatile gk_ulong addr_reg;
+
+    switch (chan) {
+        case HAL_DISP_CHANNEL_DHD0: {
+            addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->INTF0_DITHER_CTRL.u32));
+            INTF0_DITHER_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            INTF0_DITHER_CTRL.bits.dither_mode = dither_mode;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, INTF0_DITHER_CTRL.u32);
+            break;
+        }
+
+        default: {
+            return GK_FALSE;
+        }
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_disp_set_dither_round(hal_disp_outputchannel chan, gk_u32 dither_round)
+{
+    volatile U_INTF0_DITHER_CTRL INTF0_DITHER_CTRL;
+    volatile gk_ulong addr_reg;
+
+    switch (chan) {
+        case HAL_DISP_CHANNEL_DHD0: {
+            addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->INTF0_DITHER_CTRL.u32));
+            INTF0_DITHER_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            INTF0_DITHER_CTRL.bits.dither_round = dither_round;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, INTF0_DITHER_CTRL.u32);
+            break;
+        }
+
+        default: {
+            return GK_FALSE;
+        }
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_disp_set_dither_domain_mode(hal_disp_outputchannel chan, gk_u32 dither_domain_mode)
+{
+    volatile U_INTF0_DITHER_CTRL INTF0_DITHER_CTRL;
+    volatile gk_ulong addr_reg;
+
+    switch (chan) {
+        case HAL_DISP_CHANNEL_DHD0: {
+            addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->INTF0_DITHER_CTRL.u32));
+            INTF0_DITHER_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            INTF0_DITHER_CTRL.bits.dither_domain_mode = dither_domain_mode;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, INTF0_DITHER_CTRL.u32);
+            break;
+        }
+
+        default: {
+            return GK_FALSE;
+        }
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_disp_set_dither_tap_mode(hal_disp_outputchannel chan, gk_u32 dither_tap_mode)
+{
+    volatile U_INTF0_DITHER_CTRL INTF0_DITHER_CTRL;
+    volatile gk_ulong addr_reg;
+
+    switch (chan) {
+        case HAL_DISP_CHANNEL_DHD0: {
+            addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->INTF0_DITHER_CTRL.u32));
+            INTF0_DITHER_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            INTF0_DITHER_CTRL.bits.dither_tap_mode = dither_tap_mode;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, INTF0_DITHER_CTRL.u32);
+            break;
+        }
+
+        default: {
+            return GK_FALSE;
+        }
+    }
+
+    return GK_TRUE;
+}
+
+static gk_void hal_disp_set_dither_sed0(hal_disp_outputchannel chan, const hal_disp_dihter_sed *dither_sed)
+{
+    volatile U_INTF0_DITHER_SED_Y0 INTF0_DITHER_SED_Y0;
+    volatile U_INTF0_DITHER_SED_U0 INTF0_DITHER_SED_U0;
+    volatile U_INTF0_DITHER_SED_V0 INTF0_DITHER_SED_V0;
+    volatile U_INTF0_DITHER_SED_W0 INTF0_DITHER_SED_W0;
+
+    volatile gk_ulong addr_reg;
+
+    addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->INTF0_DITHER_SED_Y0.u32));
+    INTF0_DITHER_SED_Y0.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    INTF0_DITHER_SED_Y0.bits.dither_sed_y0 = dither_sed->dither_sed_y0;
+    hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, INTF0_DITHER_SED_Y0.u32);
+
+    addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->INTF0_DITHER_SED_U0.u32));
+    INTF0_DITHER_SED_U0.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    INTF0_DITHER_SED_U0.bits.dither_sed_u0 = dither_sed->dither_sed_u0;
+    hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, INTF0_DITHER_SED_U0.u32);
+
+    addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->INTF0_DITHER_SED_V0.u32));
+    INTF0_DITHER_SED_V0.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    INTF0_DITHER_SED_V0.bits.dither_sed_v0 = dither_sed->dither_sed_v0;
+    hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, INTF0_DITHER_SED_V0.u32);
+
+    addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->INTF0_DITHER_SED_W0.u32));
+    INTF0_DITHER_SED_W0.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    INTF0_DITHER_SED_W0.bits.dither_sed_w0 = dither_sed->dither_sed_w0;
+    hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, INTF0_DITHER_SED_W0.u32);
+
+    return;
+}
+
+static gk_void hal_disp_set_dither_sed1(hal_disp_outputchannel chan, const hal_disp_dihter_sed *dither_sed)
+{
+    volatile U_INTF0_DITHER_SED_Y1 INTF0_DITHER_SED_Y1;
+    volatile U_INTF0_DITHER_SED_U1 INTF0_DITHER_SED_U1;
+    volatile U_INTF0_DITHER_SED_V1 INTF0_DITHER_SED_V1;
+    volatile U_INTF0_DITHER_SED_W1 INTF0_DITHER_SED_W1;
+
+    volatile gk_ulong addr_reg;
+
+    addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->INTF0_DITHER_SED_Y1.u32));
+    INTF0_DITHER_SED_Y1.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    INTF0_DITHER_SED_Y1.bits.dither_sed_y1 = dither_sed->dither_sed_y1;
+    hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, INTF0_DITHER_SED_Y1.u32);
+
+    addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->INTF0_DITHER_SED_U1.u32));
+    INTF0_DITHER_SED_U1.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    INTF0_DITHER_SED_U1.bits.dither_sed_u1 = dither_sed->dither_sed_u1;
+    hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, INTF0_DITHER_SED_U1.u32);
+
+    addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->INTF0_DITHER_SED_V1.u32));
+    INTF0_DITHER_SED_V1.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    INTF0_DITHER_SED_V1.bits.dither_sed_v1 = dither_sed->dither_sed_v1;
+    hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, INTF0_DITHER_SED_V1.u32);
+
+    addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->INTF0_DITHER_SED_W1.u32));
+    INTF0_DITHER_SED_W1.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    INTF0_DITHER_SED_W1.bits.dither_sed_w1 = dither_sed->dither_sed_w1;
+    hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, INTF0_DITHER_SED_W1.u32);
+
+    return ;
+}
+
+static gk_void hal_disp_set_dither_sed2(hal_disp_outputchannel chan, const hal_disp_dihter_sed *dither_sed)
+{
+    volatile U_INTF0_DITHER_SED_Y2 INTF0_DITHER_SED_Y2;
+    volatile U_INTF0_DITHER_SED_U2 INTF0_DITHER_SED_U2;
+    volatile U_INTF0_DITHER_SED_V2 INTF0_DITHER_SED_V2;
+    volatile U_INTF0_DITHER_SED_W2 INTF0_DITHER_SED_W2;
+
+    volatile gk_ulong addr_reg;
+
+    addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->INTF0_DITHER_SED_Y2.u32));
+    INTF0_DITHER_SED_Y2.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    INTF0_DITHER_SED_Y2.bits.dither_sed_y2 = dither_sed->dither_sed_y2;
+    hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, INTF0_DITHER_SED_Y2.u32);
+
+    addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->INTF0_DITHER_SED_U2.u32));
+    INTF0_DITHER_SED_U2.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    INTF0_DITHER_SED_U2.bits.dither_sed_u2 = dither_sed->dither_sed_u2;
+    hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, INTF0_DITHER_SED_U2.u32);
+
+    addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->INTF0_DITHER_SED_V2.u32));
+    INTF0_DITHER_SED_V2.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    INTF0_DITHER_SED_V2.bits.dither_sed_v2 = dither_sed->dither_sed_v2;
+    hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, INTF0_DITHER_SED_V2.u32);
+
+    addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->INTF0_DITHER_SED_W2.u32));
+    INTF0_DITHER_SED_W2.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    INTF0_DITHER_SED_W2.bits.dither_sed_w2 = dither_sed->dither_sed_w2;
+    hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, INTF0_DITHER_SED_W2.u32);
+
+    return;
+}
+
+static gk_void hal_disp_set_dither_sed3(hal_disp_outputchannel chan, const hal_disp_dihter_sed *dither_sed)
+{
+    volatile U_INTF0_DITHER_SED_Y3 INTF0_DITHER_SED_Y3;
+    volatile U_INTF0_DITHER_SED_U3 INTF0_DITHER_SED_U3;
+    volatile U_INTF0_DITHER_SED_V3 INTF0_DITHER_SED_V3;
+    volatile U_INTF0_DITHER_SED_W3 INTF0_DITHER_SED_W3;
+    volatile gk_ulong addr_reg;
+
+    addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->INTF0_DITHER_SED_Y3.u32));
+    INTF0_DITHER_SED_Y3.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    INTF0_DITHER_SED_Y3.bits.dither_sed_y3 = dither_sed->dither_sed_y3;
+    hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, INTF0_DITHER_SED_Y3.u32);
+
+    addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->INTF0_DITHER_SED_U3.u32));
+    INTF0_DITHER_SED_U3.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    INTF0_DITHER_SED_U3.bits.dither_sed_u3 = dither_sed->dither_sed_u3;
+    hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, INTF0_DITHER_SED_U3.u32);
+
+    addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->INTF0_DITHER_SED_V3.u32));
+    INTF0_DITHER_SED_V3.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    INTF0_DITHER_SED_V3.bits.dither_sed_v3 = dither_sed->dither_sed_v3;
+    hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, INTF0_DITHER_SED_V3.u32);
+
+    addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->INTF0_DITHER_SED_W3.u32));
+    INTF0_DITHER_SED_W3.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    INTF0_DITHER_SED_W3.bits.dither_sed_w3 = dither_sed->dither_sed_w3;
+    hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, INTF0_DITHER_SED_W3.u32);
+
+    return;
+}
+
+gk_bool hal_disp_set_dither_sed(hal_disp_outputchannel chan, const hal_disp_dihter_sed *dither_sed)
+{
+    switch (chan) {
+        case HAL_DISP_CHANNEL_DHD0: {
+            /* set sed_y0,sed_u0,sed_v0,sed_w0 */
+            hal_disp_set_dither_sed0(chan, dither_sed);
+
+            /* set sed_y1,sed_u1,sed_v1,sed_w1 */
+            hal_disp_set_dither_sed1(chan, dither_sed);
+
+            /* set sed_y2,sed_u2,sed_v2,sed_w2 */
+            hal_disp_set_dither_sed2(chan, dither_sed);
+
+            /* set sed_y3,sed_u3,sed_v3,sed_w3 */
+            hal_disp_set_dither_sed3(chan, dither_sed);
+
+            break;
+        }
+
+        default: {
+            return GK_FALSE;
+        }
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_disp_set_dither_thr_min_max(hal_disp_outputchannel chan, gk_u32 thr_min, gk_u32 thr_max)
+{
+    volatile U_INTF0_DITHER_THR INTF0_DITHER_THR;
+    volatile gk_ulong addr_reg;
+
+    switch (chan) {
+        case HAL_DISP_CHANNEL_DHD0: {
+            addr_reg = vo_get_chn_abs_addr(chan, (gk_uintptr_t)&(g_vo_reg->INTF0_DITHER_THR.u32));
+            INTF0_DITHER_THR.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            INTF0_DITHER_THR.bits.dither_thr_min = thr_min;
+            INTF0_DITHER_THR.bits.dither_thr_max = thr_max;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, INTF0_DITHER_THR.u32);
+            break;
+        }
+
+        default: {
+            return GK_FALSE;
+        }
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_layer_set_reg_up(hal_disp_layer layer)
+{
+    U_V0_UPD V0_UPD;
+    U_G0_UPD G0_UPD;
+    volatile gk_ulong addr_reg;
+
+    switch (layer) {
+        case HAL_DISP_LAYER_VHD0: {
+            addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_UPD.u32));
+            V0_UPD.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            /* video layer register update */
+            V0_UPD.bits.regup = 0x1;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, V0_UPD.u32);
+            break;
+        }
+
+        case HAL_DISP_LAYER_GFX0: {
+            addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->G0_UPD));
+            G0_UPD.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            /* graphic layer register update */
+            G0_UPD.bits.regup = 0x1;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, G0_UPD.u32);
+            break;
+        }
+
+        default: {
+            printf("error layer id found in %s: L%d\n", __FUNCTION__, __LINE__);
+            return GK_FALSE;
+        }
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_video_set_layer_alpha(hal_disp_layer layer, gk_u32 arange)
+{
+    volatile U_V0_ALPHA V0_ALPHA;
+    volatile gk_ulong addr_reg;
+
+    switch (layer) {
+        case HAL_DISP_LAYER_VHD0: {
+            addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_ALPHA.u32));
+            V0_ALPHA.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            V0_ALPHA.bits.vbk_alpha = arange;
+            hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_ALPHA.u32);
+            break;
+        }
+
+        default: {
+            return GK_FALSE;
+        }
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_cbm_set_cbm_bkg(gk_u32 mixer_id, const hal_disp_bkcolor *bkg)
+{
+    U_CBM_BKG1 CBM_BKG1;
+
+    if (mixer_id == HAL_CBMMIX1) {
+        CBM_BKG1.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)&(g_vo_reg->CBM_BKG1.u32));
+        CBM_BKG1.bits.cbm_bkgy1 = (bkg->bkg_y);
+        CBM_BKG1.bits.cbm_bkgcb1 = (bkg->bkg_cb);
+        CBM_BKG1.bits.cbm_bkgcr1 = (bkg->bkg_cr);
+        hal_write_reg((gk_u32*)(gk_uintptr_t)&(g_vo_reg->CBM_BKG1.u32), CBM_BKG1.u32);
+    } else {
+        return GK_FALSE;
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_cbm_set_cbm_mixer_prio(hal_disp_layer layer, gk_u8 prio, gk_u8 mixer_id)
+{
+    U_CBM_MIX1 CBM_MIX1;
+    gk_u8 layer_id = 0;
+
+    if (mixer_id == HAL_CBMMIX1) {
+        switch (layer) {
+            case HAL_DISP_LAYER_VHD0: {
+                layer_id = 0x1; /* 0x1 register config */
+                break;
+            }
+
+            case HAL_DISP_LAYER_GFX0: {
+                layer_id = 0x2; /* 0x2 register config */
+                break;
+            }
+
+            default: {
+                return GK_FALSE;
+            }
+        }
+
+        CBM_MIX1.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)&(g_vo_reg->CBM_MIX1.u32));
+
+        switch (prio) {
+            case 0: { /* prio 0 */
+                CBM_MIX1.bits.mixer_prio0 = layer_id;
+                break;
+            }
+
+            case 1: { /* prio 1 */
+                CBM_MIX1.bits.mixer_prio1 = layer_id;
+                break;
+            }
+
+            case 2: { /* prio 2 */
+                CBM_MIX1.bits.mixer_prio2 = layer_id;
+                break;
+            }
+
+            default: {
+                return GK_FALSE;
+            }
+        }
+
+        hal_write_reg((gk_u32*)(gk_uintptr_t)&(g_vo_reg->CBM_MIX1.u32), CBM_MIX1.u32);
+    } else {
+        return GK_FALSE;
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_graphic_set_gfx_ext(hal_disp_layer layer,
+                                hal_gfx_bitextend mode)
+{
+    U_GFX_OUT_CTRL GFX_OUT_CTRL;
+
+    volatile gk_ulong addr_reg;
+
+    if (layer == HAL_DISP_LAYER_GFX0) {
+        addr_reg = vo_get_gfx_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->GFX_OUT_CTRL.u32));
+        GFX_OUT_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        GFX_OUT_CTRL.bits.bitext = mode;
+        hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, GFX_OUT_CTRL.u32);
+    } else {
+        printf("error layer id found in %s: L%d\n", __FUNCTION__, __LINE__);
+        return GK_FALSE;
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_graphic_set_gfx_palpha(hal_disp_layer layer,
+                                   gk_u32 alpha_en, gk_u32 arange,
+                                   gk_u8 alpha0, gk_u8 alpha1)
+{
+    U_GFX_OUT_CTRL GFX_OUT_CTRL;
+
+    U_GFX_1555_ALPHA GFX_1555_ALPHA;
+
+    volatile gk_ulong addr_reg;
+
+    if (layer == HAL_DISP_LAYER_GFX0) {
+        addr_reg = vo_get_gfx_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->GFX_OUT_CTRL.u32));
+        GFX_OUT_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        GFX_OUT_CTRL.bits.palpha_en = alpha_en;
+        hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, GFX_OUT_CTRL.u32);
+
+        if (alpha_en == GK_TRUE) {
+            addr_reg = vo_get_gfx_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->GFX_1555_ALPHA.u32));
+            GFX_1555_ALPHA.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            GFX_1555_ALPHA.bits.alpha_1 = alpha1;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, GFX_1555_ALPHA.u32);
+
+            addr_reg = vo_get_gfx_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->GFX_1555_ALPHA.u32));
+            GFX_1555_ALPHA.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            GFX_1555_ALPHA.bits.alpha_0 = alpha0;
+            hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, GFX_1555_ALPHA.u32);
+        } else {
+            addr_reg = vo_get_gfx_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->GFX_1555_ALPHA.u32));
+            GFX_1555_ALPHA.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            GFX_1555_ALPHA.bits.alpha_1 = 0xff; /* 0xff max alpha */
+            hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, GFX_1555_ALPHA.u32);
+
+            addr_reg = vo_get_gfx_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->GFX_1555_ALPHA.u32));
+            GFX_1555_ALPHA.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+            GFX_1555_ALPHA.bits.alpha_0 = 0xff; /* 0xff max alpha */
+            hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, GFX_1555_ALPHA.u32);
+        }
+    } else {
+        printf("error layer id found in %s: L%d\n", __FUNCTION__, __LINE__);
+        return GK_FALSE;
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_graphic_set_gfx_pre_mult(hal_disp_layer layer, gk_u32 enable)
+{
+    U_GFX_OUT_CTRL GFX_OUT_CTRL;
+
+    volatile gk_ulong addr_reg;
+
+    if (layer == HAL_DISP_LAYER_GFX0) {
+        addr_reg = vo_get_gfx_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->GFX_OUT_CTRL.u32));
+        GFX_OUT_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        GFX_OUT_CTRL.bits.premulti_en = enable;
+        hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, GFX_OUT_CTRL.u32);
+    } else {
+        printf("error layer id found in %s: L%d\n", __FUNCTION__, __LINE__);
+        return GK_FALSE;
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_graphic_set_gfx_addr(hal_disp_layer layer, gk_u64 l_addr)
+{
+    volatile gk_ulong gfx_addr_h;
+    volatile gk_ulong gfx_addr_l;
+
+    if (layer == HAL_DISP_LAYER_GFX0) {
+        gfx_addr_l = vo_get_gfx_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->GFX_ADDR_L));
+        hal_write_reg((gk_u32*)(gk_uintptr_t)gfx_addr_l, get_low_addr(l_addr));
+        gfx_addr_h = vo_get_gfx_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->GFX_ADDR_H));
+        hal_write_reg((gk_u32*)(gk_uintptr_t)gfx_addr_h, get_high_addr(l_addr));
+    } else {
+        printf("error layer id found in %s: L%d\n", __FUNCTION__, __LINE__);
+        return GK_FALSE;
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_graphic_set_gfx_stride(hal_disp_layer layer, gk_u16 pitch)
+{
+    volatile U_GFX_STRIDE GFX_STRIDE;
+    volatile gk_ulong addr_reg;
+
+    if (layer == HAL_DISP_LAYER_GFX0) {
+        addr_reg = vo_get_gfx_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->GFX_STRIDE.u32));
+        GFX_STRIDE.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        GFX_STRIDE.bits.surface_stride = pitch;
+        hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, GFX_STRIDE.u32);
+    } else {
+        printf("error layer id found in %s: L%d\n", __FUNCTION__, __LINE__);
+        return GK_FALSE;
+    }
+
+    return GK_TRUE;
+}
+
+gk_bool hal_gfx_set_src_resolution(hal_disp_layer layer, const gk_rect *rect)
+{
+    U_GFX_SRC_RESO GFX_SRC_RESO;
+    volatile gk_ulong addr_reg;
+
+    if (layer == HAL_DISP_LAYER_GFX0) {
+        addr_reg = vo_get_gfx_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->GFX_SRC_RESO.u32));
+        GFX_SRC_RESO.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        GFX_SRC_RESO.bits.src_w = rect->width - 1;
+        GFX_SRC_RESO.bits.src_h = rect->height - 1;
+        hal_write_reg((gk_u32*)(gk_uintptr_t)addr_reg, GFX_SRC_RESO.u32);
+    } else {
+        printf("error:layer id not found in %s: L%d\n", __FUNCTION__, __LINE__);
+        return GK_FALSE;
+    }
+
+    return GK_TRUE;
+}
+
+gk_void hal_layer_csc_set_dc_coef(hal_disp_layer layer, const vdp_csc_dc_coef *csc_dc_coef)
+{
+    U_V0_VOPP_CSC_IDC0 V0_VOPP_CSC_IDC0;
+    U_V0_VOPP_CSC_IDC1 V0_VOPP_CSC_IDC1;
+    U_V0_VOPP_CSC_IDC2 V0_VOPP_CSC_IDC2;
+    U_V0_VOPP_CSC_ODC0 V0_VOPP_CSC_ODC0;
+    U_V0_VOPP_CSC_ODC1 V0_VOPP_CSC_ODC1;
+    U_V0_VOPP_CSC_ODC2 V0_VOPP_CSC_ODC2;
+
+    volatile gk_u32 addr_reg;
+
+    if ((layer >= LAYER_VHD_START) && (layer <= LAYER_VHD_END)) {
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_VOPP_CSC_IDC0.u32));
+        V0_VOPP_CSC_IDC0.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_VOPP_CSC_IDC0.bits.vopp_csc_idc0 = csc_dc_coef->csc_in_dc0;
+        hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_IDC0.u32);
+
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_VOPP_CSC_IDC1.u32));
+        V0_VOPP_CSC_IDC1.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_VOPP_CSC_IDC1.bits.vopp_csc_idc1 = csc_dc_coef->csc_in_dc1;
+        hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_IDC1.u32);
+
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_VOPP_CSC_IDC2.u32));
+        V0_VOPP_CSC_IDC2.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_VOPP_CSC_IDC2.bits.vopp_csc_idc2 = csc_dc_coef->csc_in_dc2;
+        hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_IDC2.u32);
+
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_VOPP_CSC_ODC0.u32));
+        V0_VOPP_CSC_ODC0.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_VOPP_CSC_ODC0.bits.vopp_csc_odc0 = csc_dc_coef->csc_out_dc0;
+        hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_ODC0.u32);
+
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_VOPP_CSC_ODC1.u32));
+        V0_VOPP_CSC_ODC1.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_VOPP_CSC_ODC1.bits.vopp_csc_odc1 = csc_dc_coef->csc_out_dc1;
+        hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_ODC1.u32);
+
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_VOPP_CSC_ODC2.u32));
+        V0_VOPP_CSC_ODC2.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_VOPP_CSC_ODC2.bits.vopp_csc_odc2 = csc_dc_coef->csc_out_dc2;
+        hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_ODC2.u32);
+    }
+}
+
+gk_void hal_layer_csc_set_csc_mode(hal_disp_layer layer, gk_s32 csc_mode)
+{
+    U_V0_VOPP_CSC_CTRL V0_VOPP_CSC_CTRL;
+    volatile gk_ulong addr_reg;
+    if (layer == HAL_DISP_LAYER_GFX0) {
+        switch (csc_mode) {
+            case HAL_CSC_MODE_RGB_TO_BT601_PC: {
+                addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->G0_VOPP_CSC_CTRL.u32));
+                V0_VOPP_CSC_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+                V0_VOPP_CSC_CTRL.bits.vopp_csc_mode = 0x0;
+                hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_CTRL.u32);
+                break;
+            }
+            case HAL_CSC_MODE_RGB_TO_BT709_PC: {
+                addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->G0_VOPP_CSC_CTRL.u32));
+                V0_VOPP_CSC_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+                V0_VOPP_CSC_CTRL.bits.vopp_csc_mode = 0x1;
+                hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_CTRL.u32);
+                break;
+            }
+            default: {
+                break;
+            }
+        }
+    }
+
+    return;
+}
+
+gk_void hal_layer_csc_set_param(hal_disp_layer layer, const csc_coef_param *coef_param)
+{
+    U_V0_VOPP_CSC_SCALE V0_VOPP_CSC_SCALE;
+    U_V0_VOPP_CSC_MIN_Y V0_VOPP_CSC_MIN_Y;
+    U_V0_VOPP_CSC_MIN_C V0_VOPP_CSC_MIN_C;
+    U_V0_VOPP_CSC_MAX_Y V0_VOPP_CSC_MAX_Y;
+    U_V0_VOPP_CSC_MAX_C V0_VOPP_CSC_MAX_C;
+
+    volatile gk_u32 addr_reg;
+
+    if ((layer >= LAYER_VHD_START) && (layer <= LAYER_VHD_END)) {
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_VOPP_CSC_SCALE.u32));
+        V0_VOPP_CSC_SCALE.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_VOPP_CSC_SCALE.bits.vopp_csc_scale = coef_param->csc_scale2p;
+        hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_SCALE.u32);
+
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_VOPP_CSC_MIN_Y.u32));
+        V0_VOPP_CSC_MIN_Y.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_VOPP_CSC_MIN_Y.bits.vopp_csc_min_y = coef_param->csc_clip_min;
+        hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_MIN_Y.u32);
+
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_VOPP_CSC_MIN_C.u32));
+        V0_VOPP_CSC_MIN_C.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_VOPP_CSC_MIN_C.bits.vopp_csc_min_c = coef_param->csc_clip_min;
+        hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_MIN_C.u32);
+
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_VOPP_CSC_MAX_Y.u32));
+        V0_VOPP_CSC_MAX_Y.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_VOPP_CSC_MAX_Y.bits.vopp_csc_max_y = coef_param->csc_clip_max;
+        hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_MAX_Y.u32);
+
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_VOPP_CSC_MAX_C.u32));
+        V0_VOPP_CSC_MAX_C.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_VOPP_CSC_MAX_C.bits.vopp_csc_max_c = coef_param->csc_clip_max;
+        hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_MAX_C.u32);
+    }
+}
+
+static gk_void hal_layer_csc_set_video_coef0x(hal_disp_layer layer, const vdp_csc_coef *csc_coef)
+{
+    U_V0_VOPP_CSC_COEF00 V0_VOPP_CSC_COEF00;
+    U_V0_VOPP_CSC_COEF01 V0_VOPP_CSC_COEF01;
+    U_V0_VOPP_CSC_COEF02 V0_VOPP_CSC_COEF02;
+
+    volatile gk_u32 addr_reg;
+
+    addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_VOPP_CSC_COEF00.u32));
+    V0_VOPP_CSC_COEF00.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    V0_VOPP_CSC_COEF00.bits.vopp_csc_coef00 = csc_coef->csc_coef00;
+    hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_COEF00.u32);
+
+    addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_VOPP_CSC_COEF01.u32));
+    V0_VOPP_CSC_COEF01.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    V0_VOPP_CSC_COEF01.bits.vopp_csc_coef01 = csc_coef->csc_coef01;
+    hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_COEF01.u32);
+
+    addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_VOPP_CSC_COEF02.u32));
+    V0_VOPP_CSC_COEF02.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    V0_VOPP_CSC_COEF02.bits.vopp_csc_coef02 = csc_coef->csc_coef02;
+    hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_COEF02.u32);
+
+    return;
+}
+
+static gk_void hal_layer_csc_set_video_coef1x(hal_disp_layer layer, const vdp_csc_coef *csc_coef)
+{
+    U_V0_VOPP_CSC_COEF10 V0_VOPP_CSC_COEF10;
+    U_V0_VOPP_CSC_COEF11 V0_VOPP_CSC_COEF11;
+    U_V0_VOPP_CSC_COEF12 V0_VOPP_CSC_COEF12;
+
+    volatile gk_u32 addr_reg;
+
+    addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_VOPP_CSC_COEF10.u32));
+    V0_VOPP_CSC_COEF10.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    V0_VOPP_CSC_COEF10.bits.vopp_csc_coef10 = csc_coef->csc_coef10;
+    hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_COEF10.u32);
+
+    addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_VOPP_CSC_COEF11.u32));
+    V0_VOPP_CSC_COEF11.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    V0_VOPP_CSC_COEF11.bits.vopp_csc_coef11 = csc_coef->csc_coef11;
+    hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_COEF11.u32);
+
+    addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_VOPP_CSC_COEF12.u32));
+    V0_VOPP_CSC_COEF12.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    V0_VOPP_CSC_COEF12.bits.vopp_csc_coef12 = csc_coef->csc_coef12;
+    hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_COEF12.u32);
+
+    return;
+}
+
+static gk_void hal_layer_csc_set_video_coef2x(hal_disp_layer layer, const vdp_csc_coef *csc_coef)
+{
+    U_V0_VOPP_CSC_COEF20 V0_VOPP_CSC_COEF20;
+    U_V0_VOPP_CSC_COEF21 V0_VOPP_CSC_COEF21;
+    U_V0_VOPP_CSC_COEF22 V0_VOPP_CSC_COEF22;
+
+    volatile gk_u32 addr_reg;
+
+    addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_VOPP_CSC_COEF20.u32));
+    V0_VOPP_CSC_COEF20.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    V0_VOPP_CSC_COEF20.bits.vopp_csc_coef20 = csc_coef->csc_coef20;
+    hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_COEF20.u32);
+
+    addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_VOPP_CSC_COEF21.u32));
+    V0_VOPP_CSC_COEF21.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    V0_VOPP_CSC_COEF21.bits.vopp_csc_coef21 = csc_coef->csc_coef21;
+    hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_COEF21.u32);
+
+    addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_VOPP_CSC_COEF22.u32));
+    V0_VOPP_CSC_COEF22.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+    V0_VOPP_CSC_COEF22.bits.vopp_csc_coef22 = csc_coef->csc_coef22;
+    hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_COEF22.u32);
+
+    return;
+}
+
+gk_void hal_layer_csc_set_coef(hal_disp_layer layer, const vdp_csc_coef *csc_coef)
+{
+    if ((layer >= LAYER_VHD_START) && (layer <= LAYER_VHD_END)) {
+        hal_layer_csc_set_video_coef0x(layer, csc_coef);
+        hal_layer_csc_set_video_coef1x(layer, csc_coef);
+        hal_layer_csc_set_video_coef2x(layer, csc_coef);
+    }
+
+    return;
+}
+
+gk_bool hal_layer_set_csc_coef(hal_disp_layer layer, const vo_csc_coef *csc_coef)
+{
+    hal_layer_csc_set_dc_coef(layer, (vdp_csc_dc_coef *)(&csc_coef->csc_in_dc0));
+    hal_layer_csc_set_coef(layer, (vdp_csc_coef *)(&csc_coef->csc_coef00));
+    hal_layer_csc_set_param(layer, (csc_coef_param *)(&csc_coef->new_csc_scale2p));
+
+    return GK_TRUE;
+}
+
+gk_void hal_layer_csc_set_ck_gt_en(hal_disp_layer layer, gk_bool ck_gt_en)
+{
+    U_V0_VOPP_CSC_CTRL V0_VOPP_CSC_CTRL;
+
+    volatile gk_u32 addr_reg;
+
+    if ((layer >= LAYER_VHD_START) && (layer <= LAYER_VHD_END)) {
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_VOPP_CSC_CTRL.u32));
+        V0_VOPP_CSC_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_VOPP_CSC_CTRL.bits.vopp_csc_ck_gt_en = ck_gt_en;
+        hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_CTRL.u32);
+    } else if ((layer >= LAYER_GFX_START) && (layer <= LAYER_GFX_END)) {
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->G0_VOPP_CSC_CTRL.u32));
+        V0_VOPP_CSC_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_VOPP_CSC_CTRL.bits.vopp_csc_ck_gt_en = ck_gt_en;
+        hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_CTRL.u32);
+    }
+}
+
+gk_void hal_layer_csc_set_enable(hal_disp_layer layer, gk_bool csc_en)
+{
+    U_V0_VOPP_CSC_CTRL V0_VOPP_CSC_CTRL;
+
+    volatile gk_u32 addr_reg;
+
+    if ((layer >= LAYER_VHD_START) && (layer <= LAYER_VHD_END)) {
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->V0_VOPP_CSC_CTRL.u32));
+        V0_VOPP_CSC_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_VOPP_CSC_CTRL.bits.vopp_csc_en = csc_en;
+        hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_CTRL.u32);
+    } else if ((layer >= LAYER_GFX_START) && (layer <= LAYER_GFX_END)) {
+        addr_reg = vo_get_abs_addr(layer, (gk_uintptr_t)&(g_vo_reg->G0_VOPP_CSC_CTRL.u32));
+        V0_VOPP_CSC_CTRL.u32 = hal_read_reg((gk_u32*)(gk_uintptr_t)addr_reg);
+        V0_VOPP_CSC_CTRL.bits.vopp_csc_en = csc_en;
+        hal_write_reg ((gk_u32*)(gk_uintptr_t)addr_reg, V0_VOPP_CSC_CTRL.u32);
+    }
+}
+
+gk_bool hal_layer_set_csc_en(hal_disp_layer layer, gk_bool csc_en)
+{
+    if ((layer != HAL_DISP_LAYER_VHD0) && (layer != HAL_DISP_LAYER_GFX0)) {
+        printf("error, wrong layer ID!%d\n", __LINE__);
+        return GK_FALSE;
+    }
+
+    hal_layer_csc_set_ck_gt_en(layer, csc_en);
+    hal_layer_csc_set_enable(layer, csc_en);
+
+    return GK_TRUE;
+}
+
diff -uraN u-boot-2016.11/product/osd/vo/gk7205v200/vou_hal.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/vou_hal.h
--- u-boot-2016.11/product/osd/vo/gk7205v200/vou_hal.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/vou_hal.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,167 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __VOU_HAL_H__
+#define __VOU_HAL_H__
+
+#include "vou_reg.h"
+#include "vou_def.h"
+#include "vou_coef.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* end of #ifdef __cplusplus */
+
+gk_void hal_vo_init(gk_void);
+gk_void hal_vo_exit(gk_void);
+
+gk_void hal_write_reg(gk_u32 *address, gk_u32 value);
+gk_u32 hal_read_reg(const gk_u32 *address);
+
+gk_void hal_video_hfir_set_ck_gt_en(hal_disp_layer layer, gk_u32 ck_gt_en);
+gk_bool hal_layer_set_src_resolution(hal_disp_layer layer,
+                                     const gk_rect *rect);
+
+gk_bool hal_intf_bt_set_dfir_en(gk_u32 dfir_en);
+
+gk_s32 sys_hal_vo_bus_reset_sel(gk_bool reset);
+gk_s32 sys_hal_vo_hd_out_pctrl(gk_bool clk_reverse);
+gk_s32 sys_hal_vo_cfg_clk_en(gk_bool clk_en);
+gk_s32 sys_hal_vo_core_clk_en(gk_s32 dev, gk_bool clk_en);
+gk_s32 sys_hal_vou_ppc_clk_en(gk_s32 dev, gk_bool clk_en);
+gk_s32 sys_hal_vo_out_clk_en(gk_s32 dev, gk_bool clk_en);
+gk_s32 sys_hal_vo_apb_clk_en(gk_bool clk_en);
+gk_s32 sys_hal_vo_bus_clk_en(gk_bool clk_en);
+gk_s32 sys_hal_vo_dev_clk_en(gk_s32 vo_dev, gk_bool clk_en);
+gk_s32 sys_hal_vo_hd0_ppc_sel(gk_u32 clk_sel);
+gk_s32 sys_hal_vo_hd0_div_mode(gk_u32 hd0_div_mod);
+
+gk_s32 sys_hal_vo_hd1_ppc_sel(gk_u32 bt_clk_ch_sel);
+gk_s32 sys_hal_vo_hd1_div_mode(gk_u32 hd1_div_mod);
+gk_s32 sys_hal_vo_out_clk_sel(gk_u32 clk_sel);
+gk_s32 sys_hal_vo_hd_hdmi_clk_div(gk_u32 hdmi_clk_div);
+
+gk_s32 sys_hal_vo_lcd_clk_en(gk_bool clk_en);
+gk_s32 sys_hal_lcd_mclk_div(gk_u32 mclk_div);
+gk_s32 sys_hal_lcd_data_mode(gk_u32 data_mode);
+gk_s32 sys_hal_vo_bt_clk_en(gk_bool bt_clk_en);
+gk_s32 sys_hal_vo_bt_clk_sel(gk_u32 bt_clk_ch_sel);
+gk_s32 sys_hal_vo_mipi_chn_sel(gk_u32 mipi_ch_sel);
+gk_s32 sys_hal_set_vo_low_power_ctrl(gk_bool low_power_clk_en);
+
+gk_s32 sys_hal_set_vo_pll_frac(gk_u32 bits_set);
+gk_s32 sys_hal_set_vo_pll_postdiv1(gk_u32 bits_set);
+gk_s32 sys_hal_set_vo_pll_postdiv2(gk_u32 bits_set);
+gk_s32 sys_hal_set_vo_pll_refdiv(gk_u32 bits_set);
+gk_s32 sys_hal_set_vo_pll_fbdiv(gk_u32 bits_set);
+
+gk_void hal_sys_control(gk_void);
+
+gk_void hal_sys_set_arb_mode(gk_u32 mode);
+gk_void hal_sys_vdp_reset_clk(gk_u32 sel);
+
+gk_bool hal_disp_set_intf_enable(hal_disp_outputchannel chan, gk_bool intf);
+gk_bool hal_disp_set_intf_ctrl(hal_disp_intf intf, const gk_u32 *ctrl_info);
+gk_bool hal_disp_set_intf_sync(hal_disp_outputchannel chan,
+                               const hal_disp_syncinfo *sync_info, const hal_disp_syncinv *inv);
+
+gk_bool hal_disp_set_dev_multi_chn_en(hal_disp_outputchannel chn, hal_multi_chn multi_chn_en);
+gk_bool hal_disp_set_intf_mux_sel(hal_disp_outputchannel chan, hal_disp_intf intf);
+gk_bool hal_disp_set_bt1120_sel(hal_disp_outputchannel chan);
+
+gk_bool hal_disp_set_intf_clip(hal_disp_intf intf, gk_bool clip, const hal_disp_clip *clip_data);
+gk_bool hal_disp_set_vt_thd_mode(hal_disp_outputchannel chan, gk_u32 field_mode);
+gk_bool hal_disp_set_vt_thd(hal_disp_outputchannel chan, gk_u32 vtthd);
+
+gk_bool hal_disp_set_int_mask(gk_u32 mask_en);
+gk_bool hal_disp_clr_int_mask(gk_u32 mask_en);
+
+gk_bool hal_disp_set_lcd_serial_perd(gk_u32 serial_perd);
+
+gk_void hal_disp_set_reg_up(hal_disp_outputchannel chan);
+
+gk_bool hal_video_set_layer_up_mode(hal_disp_layer layer, gk_u32 up_mode);
+gk_bool hal_video_set_hfir_mode(hal_disp_layer layer, hal_hfirmode mode);
+gk_bool hal_video_hfir_set_coef(hal_disp_layer layer, const hfir_coef *coef);
+gk_bool hal_video_set_layer_disp_rect(hal_disp_layer layer, const gk_rect *rect);
+gk_bool hal_video_set_layer_video_rect(hal_disp_layer layer, const gk_rect *rect);
+gk_bool hal_video_set_multi_area_l_addr(hal_disp_layer layer, gk_u32 area_num, gk_ulong l_addr, gk_u16 stride);
+gk_bool hal_video_set_multi_area_c_addr(hal_disp_layer layer, gk_u32 area_num, gk_ulong c_addr, gk_u16 stride);
+gk_bool hal_video_set_layer_alpha(hal_disp_layer layer, gk_u32 arange);
+gk_void hal_video_cvfir_set_out_height(hal_disp_layer layer, gk_u32 out_height);
+gk_void hal_video_cvfir_set_out_fmt(hal_disp_layer layer, gk_u32 out_fmt);
+gk_void hal_video_cvfir_set_out_pro(hal_disp_layer layer, gk_u32 out_pro);
+gk_void hal_video_cvfir_set_vzme_ck_gt_en(hal_disp_layer layer, gk_bool vzme_ck_gt_en);
+gk_void hal_video_hfir_set_mid_en(hal_disp_layer layer, gk_u32 mid_en);
+gk_void vdp_fdr_vid_set_chm_copy_en(gk_u32 layer, gk_u32 chm_copy_en);
+
+gk_void hal_video_cvfir_set_cvfir_en(hal_disp_layer layer, gk_u32 cvfir_en);
+gk_void hal_video_cvfir_set_cvmid_en(hal_disp_layer layer, gk_u32 cvmid_en);
+gk_void hal_video_cvfir_set_cvfir_mode(hal_disp_layer layer, gk_u32 cvfir_mode);
+gk_void hal_video_cvfir_set_vratio(hal_disp_layer layer, gk_u32 vratio);
+
+gk_void hal_video_cvfir_set_v_chroma_offset(hal_disp_layer layer, gk_u32 vchroma_offset);
+gk_void hal_video_cvfir_set_vb_chroma_offset(hal_disp_layer layer, gk_u32 vbchroma_offset);
+
+gk_bool hal_layer_enable_layer(hal_disp_layer layer, gk_u32 enable);
+gk_bool hal_layer_set_layer_data_fmt(hal_disp_layer layer,
+                                     hal_disp_pixel_format data_fmt);
+gk_bool hal_layer_set_layer_in_rect(hal_disp_layer layer, const gk_rect *rect);
+gk_bool hal_layer_set_layer_galpha(hal_disp_layer layer,
+                                   gk_u8 alpha0);
+gk_bool hal_layer_set_zme_info(hal_disp_layer layer, gk_u32 width, gk_u32 height,
+                               hal_disp_zme_outfmt zme_out_fmt);
+gk_bool hal_layer_set_zme_enable(hal_disp_layer layer,
+                                 hal_disp_zmemode mode,
+                                 gk_u32 enable);
+gk_bool hal_layer_set_reg_up(hal_disp_layer layer);
+
+gk_bool hal_cbm_set_cbm_bkg(gk_u32 mixer_id, const hal_disp_bkcolor *bkg);
+gk_bool hal_cbm_set_cbm_mixer_prio(hal_disp_layer layer, gk_u8 prio, gk_u8 mixer_id);
+gk_bool hal_disp_set_vga_csc_en(hal_disp_layer layer, gk_bool csc_en);
+gk_void hal_hdr_g_set_hdr_r2y_scale2p(gk_u32 hdr_r2y_scale2p);
+gk_void hal_hdr_g_set_hdr_r2y_clip_min(gk_u32 hdr_r2y_clip_min);
+gk_void hal_hdr_g_set_hdr_r2y_clip_max(gk_u32 hdr_r2y_clip_max);
+
+gk_bool hal_graphic_set_gfx_ext(hal_disp_layer layer,
+                                hal_gfx_bitextend mode);
+
+gk_bool hal_graphic_set_gfx_pre_mult(hal_disp_layer layer, gk_u32 enable);
+gk_bool hal_graphic_set_gfx_palpha(hal_disp_layer layer,
+                                   gk_u32 alpha_en, gk_u32 arange,
+                                   gk_u8 alpha0, gk_u8 alpha1);
+
+gk_bool hal_graphic_set_gfx_addr(hal_disp_layer layer, gk_u64 l_addr);
+gk_bool hal_graphic_set_gfx_stride(hal_disp_layer layer, gk_u16 pitch);
+gk_bool hal_layer_set_csc_coef(hal_disp_layer layer, const vo_csc_coef *csc_coef);
+gk_bool hal_layer_set_csc_en(hal_disp_layer layer, gk_bool csc_en);
+gk_bool hal_gfx_set_src_resolution(hal_disp_layer layer, const gk_rect *rect);
+gk_void hal_layer_csc_set_csc_mode(hal_disp_layer layer, gk_s32 csc_mode);
+
+gk_bool hal_disp_set_dither_round_unlim(hal_disp_outputchannel chan, gk_u32 dither_mode);
+gk_bool hal_disp_set_dither_data_in_out(hal_disp_outputchannel chan, gk_u32 i_data_width_dither,
+                                        gk_u32 o_data_width_dither);
+gk_bool hal_disp_set_dither_en(hal_disp_outputchannel chan, gk_u32 dither_en);
+gk_bool hal_disp_set_dither_mode(hal_disp_outputchannel chan, gk_u32 dither_mode);
+gk_bool hal_disp_set_dither_round(hal_disp_outputchannel chan, gk_u32 dither_round);
+gk_bool hal_disp_set_dither_domain_mode(hal_disp_outputchannel chan, gk_u32 dither_domain_mode);
+gk_bool hal_disp_set_dither_tap_mode(hal_disp_outputchannel chan, gk_u32 dither_tap_mode);
+gk_bool hal_disp_set_dither_sed(hal_disp_outputchannel chan, const hal_disp_dihter_sed *dither_sed);
+gk_bool hal_disp_set_dither_thr_min_max(hal_disp_outputchannel chan, gk_u32 thr_min, gk_u32 thr_max);
+
+__inline static gk_u32 get_low_addr(gk_u64 phyaddr)
+{
+    return (gk_u32)phyaddr;
+}
+
+__inline static gk_u32 get_high_addr(gk_u64 phyaddr)
+{
+    return (gk_u32)(phyaddr >> 32); /* 32 to get high address */
+}
+
+#ifdef __cplusplus
+}
+#endif /* end of #ifdef __cplusplus */
+#endif /* end of __VOU_HAL_H__ */
+
diff -uraN u-boot-2016.11/product/osd/vo/gk7205v200/vou_reg.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/vou_reg.h
--- u-boot-2016.11/product/osd/vo/gk7205v200/vou_reg.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/gk7205v200/vou_reg.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,9738 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __VOU_REG_H__
+#define __VOU_REG_H__
+
+#include "type.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* end of #ifdef __cplusplus */
+
+/* define the union U_VOCTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 25;      /* [24..0]  */
+        unsigned int wbc_dhd_ck_gt_en : 1; /* [25]  */
+        unsigned int g1_ck_gt_en : 1;      /* [26]  */
+        unsigned int g0_ck_gt_en : 1;      /* [27]  */
+        unsigned int v1_ck_gt_en : 1;      /* [28]  */
+        unsigned int v0_ck_gt_en : 1;      /* [29]  */
+        unsigned int chk_sum_en : 1;       /* [30]  */
+        unsigned int vo_ck_gt_en : 1;      /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VOCTRL;
+
+/* define the union U_VOINTSTA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dhd0vtthd1_int : 1;   /* [0]  */
+        unsigned int dhd0vtthd2_int : 1;   /* [1]  */
+        unsigned int dhd0vtthd3_int : 1;   /* [2]  */
+        unsigned int dhd0uf_int : 1;       /* [3]  */
+        unsigned int dhd1vtthd1_int : 1;   /* [4]  */
+        unsigned int dhd1vtthd2_int : 1;   /* [5]  */
+        unsigned int dhd1vtthd3_int : 1;   /* [6]  */
+        unsigned int dhd1uf_int : 1;       /* [7]  */
+        unsigned int dsdvtthd1_int : 1;    /* [8]  */
+        unsigned int dsdvtthd2_int : 1;    /* [9]  */
+        unsigned int dsdvtthd3_int : 1;    /* [10]  */
+        unsigned int dsduf_int : 1;        /* [11]  */
+        unsigned int b0_err_int : 1;       /* [12]  */
+        unsigned int b1_err_int : 1;       /* [13]  */
+        unsigned int b2_err_int : 1;       /* [14]  */
+        unsigned int wbc_dhd_over_int : 1; /* [15]  */
+        unsigned int vdac0_int : 1;        /* [16]  */
+        unsigned int vdac1_int : 1;        /* [17]  */
+        unsigned int vdac2_int : 1;        /* [18]  */
+        unsigned int vdac3_int : 1;        /* [19]  */
+        unsigned int reserved_0 : 12;      /* [31..20]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VOINTSTA;
+
+/* define the union U_VOMSKINTSTA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dhd0vtthd1_clr : 1;   /* [0]  */
+        unsigned int dhd0vtthd2_clr : 1;   /* [1]  */
+        unsigned int dhd0vtthd3_clr : 1;   /* [2]  */
+        unsigned int dhd0uf_clr : 1;       /* [3]  */
+        unsigned int dhd1vtthd1_clr : 1;   /* [4]  */
+        unsigned int dhd1vtthd2_clr : 1;   /* [5]  */
+        unsigned int dhd1vtthd3_clr : 1;   /* [6]  */
+        unsigned int dhd1uf_clr : 1;       /* [7]  */
+        unsigned int dsdvtthd1_clr : 1;    /* [8]  */
+        unsigned int dsdvtthd2_clr : 1;    /* [9]  */
+        unsigned int dsdvtthd3_clr : 1;    /* [10]  */
+        unsigned int dsduf_clr : 1;        /* [11]  */
+        unsigned int b0_err_clr : 1;       /* [12]  */
+        unsigned int b1_err_clr : 1;       /* [13]  */
+        unsigned int b2_err_clr : 1;       /* [14]  */
+        unsigned int wbc_dhd_over_clr : 1; /* [15]  */
+        unsigned int vdac0_clr : 1;        /* [16]  */
+        unsigned int vdac1_clr : 1;        /* [17]  */
+        unsigned int vdac2_clr : 1;        /* [18]  */
+        unsigned int vdac3_clr : 1;        /* [19]  */
+        unsigned int reserved_0 : 12;      /* [31..20]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VOMSKINTSTA;
+
+/* define the union U_VOINTMSK */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dhd0vtthd1_intmask : 1;   /* [0]  */
+        unsigned int dhd0vtthd2_intmask : 1;   /* [1]  */
+        unsigned int dhd0vtthd3_intmask : 1;   /* [2]  */
+        unsigned int dhd0uf_intmask : 1;       /* [3]  */
+        unsigned int dhd1vtthd1_intmask : 1;   /* [4]  */
+        unsigned int dhd1vtthd2_intmask : 1;   /* [5]  */
+        unsigned int dhd1vtthd3_intmask : 1;   /* [6]  */
+        unsigned int dhd1uf_intmask : 1;       /* [7]  */
+        unsigned int dsdvtthd1_intmask : 1;    /* [8]  */
+        unsigned int dsdvtthd2_intmask : 1;    /* [9]  */
+        unsigned int dsdvtthd3_intmask : 1;    /* [10]  */
+        unsigned int dsduf_intmask : 1;        /* [11]  */
+        unsigned int b0_err_intmask : 1;       /* [12]  */
+        unsigned int b1_err_intmask : 1;       /* [13]  */
+        unsigned int b2_err_intmask : 1;       /* [14]  */
+        unsigned int wbc_dhd_over_intmask : 1; /* [15]  */
+        unsigned int vdac0_intmask : 1;        /* [16]  */
+        unsigned int vdac1_intmask : 1;        /* [17]  */
+        unsigned int vdac2_intmask : 1;        /* [18]  */
+        unsigned int vdac3_intmask : 1;        /* [19]  */
+        unsigned int reserved_0 : 12;          /* [31..20]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VOINTMSK;
+
+/* define the union U_VODEBUG */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int rm_chn : 4;     /* [3..0]  */
+        unsigned int dhd0_ff_info : 2;  /* [5..4]  */
+        unsigned int dhd1_ff_info : 2;  /* [7..6]  */
+        unsigned int dsd0_ff_info : 2;  /* [9..8]  */
+        unsigned int bfm_vga_en : 1;    /* [10]  */
+        unsigned int bfm_cvbs_en : 1;   /* [11]  */
+        unsigned int bfm_lcd_en : 1;    /* [12]  */
+        unsigned int bfm_bt1120_en : 1; /* [13]  */
+        unsigned int wbc2_ff_info : 2;  /* [15..14]  */
+        unsigned int wbc_mode : 4;      /* [19..16]  */
+        unsigned int node_num : 4;      /* [23..20]  */
+        unsigned int wbc_cmp_mode : 2;  /* [25..24]  */
+        unsigned int bfm_mode : 3;      /* [28..26]  */
+        unsigned int bfm_clk_sel : 3;   /* [31..29]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VODEBUG;
+
+/* define the union U_VOINTSTA1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dhd0vtthd1_int : 1;   /* [0]  */
+        unsigned int dhd0vtthd2_int : 1;   /* [1]  */
+        unsigned int dhd0vtthd3_int : 1;   /* [2]  */
+        unsigned int dhd0uf_int : 1;       /* [3]  */
+        unsigned int dhd1vtthd1_int : 1;   /* [4]  */
+        unsigned int dhd1vtthd2_int : 1;   /* [5]  */
+        unsigned int dhd1vtthd3_int : 1;   /* [6]  */
+        unsigned int dhd1uf_int : 1;       /* [7]  */
+        unsigned int dsdvtthd1_int : 1;    /* [8]  */
+        unsigned int dsdvtthd2_int : 1;    /* [9]  */
+        unsigned int dsdvtthd3_int : 1;    /* [10]  */
+        unsigned int dsduf_int : 1;        /* [11]  */
+        unsigned int b0_err_int : 1;       /* [12]  */
+        unsigned int b1_err_int : 1;       /* [13]  */
+        unsigned int b2_err_int : 1;       /* [14]  */
+        unsigned int wbc_dhd_over_int : 1; /* [15]  */
+        unsigned int vdac0_int : 1;        /* [16]  */
+        unsigned int vdac1_int : 1;        /* [17]  */
+        unsigned int vdac2_int : 1;        /* [18]  */
+        unsigned int vdac3_int : 1;        /* [19]  */
+        unsigned int reserved_0 : 12;      /* [31..20]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VOINTSTA1;
+
+/* define the union U_VOMSKINTSTA1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dhd0vtthd1_clr : 1;   /* [0]  */
+        unsigned int dhd0vtthd2_clr : 1;   /* [1]  */
+        unsigned int dhd0vtthd3_clr : 1;   /* [2]  */
+        unsigned int dhd0uf_clr : 1;       /* [3]  */
+        unsigned int dhd1vtthd1_clr : 1;   /* [4]  */
+        unsigned int dhd1vtthd2_clr : 1;   /* [5]  */
+        unsigned int dhd1vtthd3_clr : 1;   /* [6]  */
+        unsigned int dhd1uf_clr : 1;       /* [7]  */
+        unsigned int dsdvtthd1_clr : 1;    /* [8]  */
+        unsigned int dsdvtthd2_clr : 1;    /* [9]  */
+        unsigned int dsdvtthd3_clr : 1;    /* [10]  */
+        unsigned int dsduf_clr : 1;        /* [11]  */
+        unsigned int b0_err_clr : 1;       /* [12]  */
+        unsigned int b1_err_clr : 1;       /* [13]  */
+        unsigned int b2_err_clr : 1;       /* [14]  */
+        unsigned int wbc_dhd_over_clr : 1; /* [15]  */
+        unsigned int vdac0_clr : 1;        /* [16]  */
+        unsigned int vdac1_clr : 1;        /* [17]  */
+        unsigned int vdac2_clr : 1;        /* [18]  */
+        unsigned int vdac3_clr : 1;        /* [19]  */
+        unsigned int reserved_0 : 12;      /* [31..20]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VOMSKINTSTA1;
+
+/* define the union U_VOINTMSK1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dhd0vtthd1_intmask : 1;   /* [0]  */
+        unsigned int dhd0vtthd2_intmask : 1;   /* [1]  */
+        unsigned int dhd0vtthd3_intmask : 1;   /* [2]  */
+        unsigned int dhd0uf_intmask : 1;       /* [3]  */
+        unsigned int dhd1vtthd1_intmask : 1;   /* [4]  */
+        unsigned int dhd1vtthd2_intmask : 1;   /* [5]  */
+        unsigned int dhd1vtthd3_intmask : 1;   /* [6]  */
+        unsigned int dhd1uf_intmask : 1;       /* [7]  */
+        unsigned int dsdvtthd1_intmask : 1;    /* [8]  */
+        unsigned int dsdvtthd2_intmask : 1;    /* [9]  */
+        unsigned int dsdvtthd3_intmask : 1;    /* [10]  */
+        unsigned int dsduf_intmask : 1;        /* [11]  */
+        unsigned int b0_err_intmask : 1;       /* [12]  */
+        unsigned int b1_err_intmask : 1;       /* [13]  */
+        unsigned int b2_err_intmask : 1;       /* [14]  */
+        unsigned int wbc_dhd_over_intmask : 1; /* [15]  */
+        unsigned int vdac0_intmask : 1;        /* [16]  */
+        unsigned int vdac1_intmask : 1;        /* [17]  */
+        unsigned int vdac2_intmask : 1;        /* [18]  */
+        unsigned int vdac3_intmask : 1;        /* [19]  */
+        unsigned int reserved_0 : 12;          /* [31..20]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VOINTMSK1;
+
+/* define the union U_VOLOWPOWER_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int rfs_ema : 3;      /* [2..0]  */
+        unsigned int rfs_emaw : 2;     /* [4..3]  */
+        unsigned int ret1n : 1;        /* [5]  */
+        unsigned int rft_emaa : 3;     /* [8..6]  */
+        unsigned int rft_emab : 3;     /* [11..9]  */
+        unsigned int rfs_colldisn : 1; /* [12]  */
+        unsigned int rft_emasa : 1;    /* [13]  */
+        unsigned int rfsuhd_wtsel : 2; /* [15..14]  */
+        unsigned int rfsuhd_rtsel : 2; /* [17..16]  */
+        unsigned int rfs_wtsel : 2;    /* [19..18]  */
+        unsigned int rfs_rtsel : 2;    /* [21..20]  */
+        unsigned int rfts_wct : 2;     /* [23..22]  */
+        unsigned int rfts_rct : 2;     /* [25..24]  */
+        unsigned int rfts_kp : 3;      /* [28..26]  */
+        unsigned int rftf_wct : 2;     /* [30..29]  */
+        unsigned int reserved_0 : 1;   /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VOLOWPOWER_CTRL;
+
+/* define the union U_VOUFSTA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int v0_uf_sta : 1;   /* [0]  */
+        unsigned int v1_uf_sta : 1;   /* [1]  */
+        unsigned int reserved_0 : 1;  /* [2]  */
+        unsigned int v3_uf_sta : 1;   /* [3]  */
+        unsigned int reserved_1 : 4;  /* [7..4]  */
+        unsigned int g0_uf_sta : 1;   /* [8]  */
+        unsigned int g1_uf_sta : 1;   /* [9]  */
+        unsigned int g2_uf_sta : 1;   /* [10]  */
+        unsigned int g3_uf_sta : 1;   /* [11]  */
+        unsigned int g4_uf_sta : 1;   /* [12]  */
+        unsigned int reserved_2 : 19; /* [31..13]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VOUFSTA;
+
+/* define the union U_VOUFCLR */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int v0_uf_clr : 1;   /* [0]  */
+        unsigned int v1_uf_clr : 1;   /* [1]  */
+        unsigned int reserved_0 : 1;  /* [2]  */
+        unsigned int v3_uf_clr : 1;   /* [3]  */
+        unsigned int reserved_1 : 4;  /* [7..4]  */
+        unsigned int g0_uf_clr : 1;   /* [8]  */
+        unsigned int g1_uf_clr : 1;   /* [9]  */
+        unsigned int g2_uf_clr : 1;   /* [10]  */
+        unsigned int g3_uf_clr : 1;   /* [11]  */
+        unsigned int g4_uf_clr : 1;   /* [12]  */
+        unsigned int reserved_2 : 19; /* [31..13]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VOUFCLR;
+
+/* define the union U_VOINTPROC_TIM */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vointproc_time : 24; /* [23..0]  */
+        unsigned int reserved_0 : 8;      /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VOINTPROC_TIM;
+
+/* define the union U_VOLOWPOWER_CTRL1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int rftf_rct : 2;      /* [1..0]  */
+        unsigned int rftf_kp : 3;       /* [4..2]  */
+        unsigned int rft_wtsel : 2;     /* [6..5]  */
+        unsigned int rft_rtsel : 2;     /* [8..7]  */
+        unsigned int rft_mtsel : 2;     /* [10..9]  */
+        unsigned int rasshds_wtsel : 2; /* [12..11]  */
+        unsigned int rasshds_rtsel : 2; /* [14..13]  */
+        unsigned int rasshdm_wtsel : 2; /* [16..15]  */
+        unsigned int rasshdm_rtsel : 2; /* [18..17]  */
+        unsigned int rashds_wtsel : 2;  /* [20..19]  */
+        unsigned int rashds_rtsel : 2;  /* [22..21]  */
+        unsigned int rashdm_wtsel : 2;  /* [24..23]  */
+        unsigned int rashdm_rtsel : 2;  /* [26..25]  */
+        unsigned int ras_wtsel : 2;     /* [28..27]  */
+        unsigned int ras_rtsel : 2;     /* [30..29]  */
+        unsigned int reserved_0 : 1;    /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VOLOWPOWER_CTRL1;
+
+/* define the union U_VOFPGADEF */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hdr_v_def : 1;  /* [0]  */
+        unsigned int hdr_g_def : 1;  /* [1]  */
+        unsigned int hdr_wd_def : 1; /* [2]  */
+        unsigned int reserved_0 : 29;  /* [31..3]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VOFPGADEF;
+
+/* define the union U_CBM_BKG1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int cbm_bkgcr1 : 10; /* [9..0]  */
+        unsigned int cbm_bkgcb1 : 10; /* [19..10]  */
+        unsigned int cbm_bkgy1 : 10;  /* [29..20]  */
+        unsigned int reserved_0 : 2;  /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_CBM_BKG1;
+
+/* define the union U_CBM_MIX1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mixer_prio0 : 4; /* [3..0]  */
+        unsigned int mixer_prio1 : 4; /* [7..4]  */
+        unsigned int mixer_prio2 : 4; /* [11..8]  */
+        unsigned int mixer_prio3 : 4; /* [15..12]  */
+        unsigned int reserved_0 : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_CBM_MIX1;
+
+/* define the union U_WBC_BMP_THD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int wbc_bmp_thd : 8; /* [7..0]  */
+        unsigned int reserved_0 : 24; /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_BMP_THD;
+
+/* define the union U_CBM_BKG2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int cbm_bkgcr2 : 10; /* [9..0]  */
+        unsigned int cbm_bkgcb2 : 10; /* [19..10]  */
+        unsigned int cbm_bkgy2 : 10;  /* [29..20]  */
+        unsigned int reserved_0 : 2;  /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_CBM_BKG2;
+
+/* define the union U_CBM_MIX2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mixer_prio0 : 4; /* [3..0]  */
+        unsigned int mixer_prio1 : 4; /* [7..4]  */
+        unsigned int mixer_prio2 : 4; /* [11..8]  */
+        unsigned int mixer_prio3 : 4; /* [15..12]  */
+        unsigned int reserved_0 : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_CBM_MIX2;
+
+/* define the union U_HC_BMP_THD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hc_bmp_thd : 8;  /* [7..0]  */
+        unsigned int reserved_0 : 24; /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_HC_BMP_THD;
+
+/* define the union U_CBM_BKG3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int cbm_bkgcr3 : 10; /* [9..0]  */
+        unsigned int cbm_bkgcb3 : 10; /* [19..10]  */
+        unsigned int cbm_bkgy3 : 10;  /* [29..20]  */
+        unsigned int reserved_0 : 2;  /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_CBM_BKG3;
+
+/* define the union U_CBM_MIX3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mixer_prio0 : 4; /* [3..0]  */
+        unsigned int mixer_prio1 : 4; /* [7..4]  */
+        unsigned int mixer_prio2 : 4; /* [11..8]  */
+        unsigned int reserved_0 : 20; /* [31..12]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_CBM_MIX3;
+
+/* define the union U_MIXV0_BKG */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mixer_bkgcr : 10; /* [9..0]  */
+        unsigned int mixer_bkgcb : 10; /* [19..10]  */
+        unsigned int mixer_bkgy : 10;  /* [29..20]  */
+        unsigned int reserved_0 : 2;   /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_MIXV0_BKG;
+
+/* define the union U_MIXV0_MIX */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mixer_prio0 : 4; /* [3..0]  */
+        unsigned int mixer_prio1 : 4; /* [7..4]  */
+        unsigned int reserved_0 : 24; /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_MIXV0_MIX;
+
+/* define the union U_MIXG0_BKG */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mixer_bkgcr : 10; /* [9..0]  */
+        unsigned int mixer_bkgcb : 10; /* [19..10]  */
+        unsigned int mixer_bkgy : 10;  /* [29..20]  */
+        unsigned int reserved_0 : 2;   /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_MIXG0_BKG;
+
+/* define the union U_MIXG0_BKALPHA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mixer_alpha : 8; /* [7..0]  */
+        unsigned int reserved_0 : 24; /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_MIXG0_BKALPHA;
+
+/* define the union U_MIXG0_MIX */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mixer_prio0 : 4; /* [3..0]  */
+        unsigned int mixer_prio1 : 4; /* [7..4]  */
+        unsigned int mixer_prio2 : 4; /* [11..8]  */
+        unsigned int mixer_prio3 : 4; /* [15..12]  */
+        unsigned int reserved_0 : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_MIXG0_MIX;
+
+/* define the union U_LINK_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int gchn3_link : 1;  /* [0]  */
+        unsigned int vchn2_link : 1;  /* [1]  */
+        unsigned int vchn1_link : 1;  /* [2]  */
+        unsigned int reserved_0 : 29; /* [31..3]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_LINK_CTRL;
+
+/* define the union U_VPSS_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vpss_en : 1;         /* [0]  */
+        unsigned int chk_sum_en : 1;      /* [1]  */
+        unsigned int dei_en : 1;          /* [2]  */
+        unsigned int mcdi_en : 1;         /* [3]  */
+        unsigned int nx2_vc1_en : 1;      /* [4]  */
+        unsigned int rgme_en : 1;         /* [5]  */
+        unsigned int meds_en : 1;         /* [6]  */
+        unsigned int hsp_en : 1;          /* [7]  */
+        unsigned int snr_en : 1;          /* [8]  */
+        unsigned int tnr_en : 1;          /* [9]  */
+        unsigned int rfr_en : 1;          /* [10]  */
+        unsigned int ifmd_en : 1;         /* [11]  */
+        unsigned int igbm_en : 1;         /* [12]  */
+        unsigned int cue_en : 1;          /* [13]  */
+        unsigned int scd_en : 1;          /* [14]  */
+        unsigned int blk_det_en : 1;      /* [15]  */
+        unsigned int reserved_0 : 7;      /* [22..16]  */
+        unsigned int vpss_node_init : 1;  /* [23]  */
+        unsigned int ram_bank : 4;        /* [27..24]  */
+        unsigned int dei_debug_en : 1;    /* [28]  */
+        unsigned int dei_repeat_mode : 1; /* [29]  */
+        unsigned int reserved_1 : 2;      /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VPSS_CTRL;
+
+/* define the union U_VPSS_MISCELLANEOUS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 4;    /* [3..0]  */
+        unsigned int reserved_1 : 4;    /* [7..4]  */
+        unsigned int reserved_2 : 16;   /* [23..8]  */
+        unsigned int ck_gt_en : 1;      /* [24]  */
+        unsigned int ck_gt_calc : 1; /* [25]  */
+        unsigned int reserved_3 : 2;    /* [27..26]  */
+        unsigned int reserved_4 : 4;    /* [31..28]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VPSS_MISCELLANEOUS;
+
+/* define the union U_VPSS_FTCONFIG */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int node_rst_en : 1; /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VPSS_FTCONFIG;
+
+/* define the union U_PARA_UP_VHD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int para_up_vhd_chn00 : 1; /* [0]  */
+        unsigned int para_up_vhd_chn01 : 1; /* [1]  */
+        unsigned int para_up_vhd_chn02 : 1; /* [2]  */
+        unsigned int para_up_vhd_chn03 : 1; /* [3]  */
+        unsigned int para_up_vhd_chn04 : 1; /* [4]  */
+        unsigned int para_up_vhd_chn05 : 1; /* [5]  */
+        unsigned int para_up_vhd_chn06 : 1; /* [6]  */
+        unsigned int para_up_vhd_chn07 : 1; /* [7]  */
+        unsigned int para_up_vhd_chn08 : 1; /* [8]  */
+        unsigned int para_up_vhd_chn09 : 1; /* [9]  */
+        unsigned int para_up_vhd_chn10 : 1; /* [10]  */
+        unsigned int para_up_vhd_chn11 : 1; /* [11]  */
+        unsigned int para_up_vhd_chn12 : 1; /* [12]  */
+        unsigned int para_up_vhd_chn13 : 1; /* [13]  */
+        unsigned int para_up_vhd_chn14 : 1; /* [14]  */
+        unsigned int para_up_vhd_chn15 : 1; /* [15]  */
+        unsigned int para_up_vhd_chn16 : 1; /* [16]  */
+        unsigned int para_up_vhd_chn17 : 1; /* [17]  */
+        unsigned int para_up_vhd_chn18 : 1; /* [18]  */
+        unsigned int para_up_vhd_chn19 : 1; /* [19]  */
+        unsigned int para_up_vhd_chn20 : 1; /* [20]  */
+        unsigned int para_up_vhd_chn21 : 1; /* [21]  */
+        unsigned int para_up_vhd_chn22 : 1; /* [22]  */
+        unsigned int para_up_vhd_chn23 : 1; /* [23]  */
+        unsigned int para_up_vhd_chn24 : 1; /* [24]  */
+        unsigned int para_up_vhd_chn25 : 1; /* [25]  */
+        unsigned int para_up_vhd_chn26 : 1; /* [26]  */
+        unsigned int para_up_vhd_chn27 : 1; /* [27]  */
+        unsigned int para_up_vhd_chn28 : 1; /* [28]  */
+        unsigned int para_up_vhd_chn29 : 1; /* [29]  */
+        unsigned int para_up_vhd_chn30 : 1; /* [30]  */
+        unsigned int para_up_vhd_chn31 : 1; /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_PARA_UP_VHD;
+
+/* define the union U_PARA_UP_VSD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int para_up_vsd_chn00 : 1; /* [0]  */
+        unsigned int para_up_vsd_chn01 : 1; /* [1]  */
+        unsigned int para_up_vsd_chn02 : 1; /* [2]  */
+        unsigned int para_up_vsd_chn03 : 1; /* [3]  */
+        unsigned int para_up_vsd_chn04 : 1; /* [4]  */
+        unsigned int para_up_vsd_chn05 : 1; /* [5]  */
+        unsigned int para_up_vsd_chn06 : 1; /* [6]  */
+        unsigned int para_up_vsd_chn07 : 1; /* [7]  */
+        unsigned int reserved_0 : 24;       /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_PARA_UP_VSD;
+
+/* define the union U_PARA_CONFLICT_CLR */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int para_conflict_clr_hd : 1; /* [0]  */
+        unsigned int para_conflict_clr_sd : 1; /* [1]  */
+        unsigned int reserved_0 : 30;          /* [31..2]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_PARA_CONFLICT_CLR;
+
+/* define the union U_PARA_CONFLICT_STA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int para_conflict_hd : 1; /* [0]  */
+        unsigned int para_conflict_sd : 1; /* [1]  */
+        unsigned int reserved_0 : 30;      /* [31..2]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_PARA_CONFLICT_STA;
+
+/* define the union U_V0_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int galpha : 8;      /* [7..0]  */
+        unsigned int reserved_0 : 20; /* [27..8]  */
+        unsigned int rupd_field : 1;  /* [28]  */
+        unsigned int rgup_mode : 1;   /* [29]  */
+        unsigned int nosec_flag : 1;  /* [30]  */
+        unsigned int surface_en : 1;  /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_CTRL;
+
+/* define the union U_G0_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int galpha : 8;       /* [7..0]  */
+        unsigned int reserved_0 : 19;  /* [26..8]  */
+        unsigned int g0_depremult : 1; /* [27]  */
+        unsigned int rupd_field : 1;   /* [28]  */
+        unsigned int rgup_mode : 1;    /* [29]  */
+        unsigned int nosec_flag : 1;   /* [30]  */
+        unsigned int surface_en : 1;   /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_G0_CTRL;
+
+/* define the union U_V0_UPD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int regup : 1;       /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_UPD;
+
+/* define the union U_G0_UPD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int regup : 1;       /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_G0_UPD;
+
+/* define the union U_V0_0RESO_READ */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int ow : 16; /* [15..0]  */
+        unsigned int oh : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_0RESO_READ;
+
+/* define the union U_V0_DFPOS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int disp_xfpos : 16; /* [15..0]  */
+        unsigned int disp_yfpos : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_DFPOS;
+
+/* define the union U_V0_DLPOS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int disp_xlpos : 16; /* [15..0]  */
+        unsigned int disp_ylpos : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_DLPOS;
+
+/* define the union U_G0_DFPOS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int disp_xfpos : 16; /* [15..0]  */
+        unsigned int disp_yfpos : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_G0_DFPOS;
+
+/* define the union U_G0_DLPOS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int disp_xlpos : 16; /* [15..0]  */
+        unsigned int disp_ylpos : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_G0_DLPOS;
+/* define the union U_V0_VFPOS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int video_xfpos : 16; /* [15..0]  */
+        unsigned int video_yfpos : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VFPOS;
+
+/* define the union U_V0_VLPOS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int video_xlpos : 16; /* [15..0]  */
+        unsigned int video_ylpos : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VLPOS;
+
+/* define the union U_V0_BK */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vbk_cr : 10;    /* [9..0]  */
+        unsigned int vbk_cb : 10;    /* [19..10]  */
+        unsigned int vbk_y : 10;     /* [29..20]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_BK;
+
+/* define the union U_G0_VFPOS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int video_xfpos : 16; /* [15..0]  */
+        unsigned int video_yfpos : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_G0_VFPOS;
+
+/* define the union U_G0_VLPOS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int video_xlpos : 16; /* [15..0]  */
+        unsigned int video_ylpos : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_G0_VLPOS;
+
+/* define the union U_V0_ALPHA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vbk_alpha : 8;   /* [7..0]  */
+        unsigned int reserved_0 : 24; /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_ALPHA;
+
+/* define the union U_V0_MUTE_BK */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mute_cr : 10;   /* [9..0]  */
+        unsigned int mute_cb : 10;   /* [19..10]  */
+        unsigned int mute_y : 10;    /* [29..20]  */
+        unsigned int reserved_0 : 1; /* [30]  */
+        unsigned int mute_en : 1;    /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_MUTE_BK;
+
+/* define the union U_V0_RIMWIDTH */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int v0_rim_width : 5; /* [4..0]  */
+        unsigned int reserved_0 : 27;  /* [31..5]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_RIMWIDTH;
+
+/* define the union U_V0_RIMCOL0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int v0_rim_v0 : 10; /* [9..0]  */
+        unsigned int v0_rim_u0 : 10; /* [19..10]  */
+        unsigned int v0_rim_y0 : 10; /* [29..20]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_RIMCOL0;
+
+/* define the union U_V0_RIMCOL1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int v0_rim_v1 : 10; /* [9..0]  */
+        unsigned int v0_rim_u1 : 10; /* [19..10]  */
+        unsigned int v0_rim_y1 : 10; /* [29..20]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_RIMCOL1;
+
+/* define the union U_V0_VOPP_CSC_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc_en : 1;       /* [0]  */
+        unsigned int vopp_csc_mode : 1;     /* [1]  */
+        unsigned int vopp_csc_ck_gt_en : 1; /* [2]  */
+        unsigned int reserved_0 : 29;       /* [31..3]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_CTRL;
+
+/* define the union U_V0_VOPP_CSC_COEF00 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc_coef00 : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;      /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_COEF00;
+
+/* define the union U_V0_VOPP_CSC_COEF01 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc_coef01 : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;      /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_COEF01;
+
+/* define the union U_V0_VOPP_CSC_COEF02 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc_coef02 : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;      /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_COEF02;
+
+/* define the union U_V0_VOPP_CSC_COEF10 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc_coef10 : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;      /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_COEF10;
+
+/* define the union U_V0_VOPP_CSC_COEF11 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc_coef11 : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;      /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_COEF11;
+
+/* define the union U_V0_VOPP_CSC_COEF12 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc_coef12 : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;      /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_COEF12;
+
+/* define the union U_V0_VOPP_CSC_COEF20 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc_coef20 : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;      /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_COEF20;
+
+/* define the union U_V0_VOPP_CSC_COEF21 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc_coef21 : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;      /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_COEF21;
+
+/* define the union U_V0_VOPP_CSC_COEF22 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc_coef22 : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;      /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_COEF22;
+
+/* define the union U_V0_VOPP_CSC_SCALE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc_scale : 4; /* [3..0]  */
+        unsigned int reserved_0 : 28;    /* [31..4]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_SCALE;
+
+/* define the union U_V0_VOPP_CSC_IDC0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc_idc0 : 9; /* [8..0]  */
+        unsigned int reserved_0 : 23;   /* [31..9]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_IDC0;
+
+/* define the union U_V0_VOPP_CSC_IDC1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc_idc1 : 9; /* [8..0]  */
+        unsigned int reserved_0 : 23;   /* [31..9]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_IDC1;
+
+/* define the union U_V0_VOPP_CSC_IDC2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc_idc2 : 9; /* [8..0]  */
+        unsigned int reserved_0 : 23;   /* [31..9]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_IDC2;
+
+/* define the union U_V0_VOPP_CSC_ODC0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc_odc0 : 11; /* [10..0]  */
+        unsigned int reserved_0 : 21;    /* [31..11]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_ODC0;
+
+/* define the union U_V0_VOPP_CSC_ODC1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc_odc1 : 11; /* [10..0]  */
+        unsigned int reserved_0 : 21;    /* [31..11]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_ODC1;
+
+/* define the union U_V0_VOPP_CSC_ODC2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc_odc2 : 11; /* [10..0]  */
+        unsigned int reserved_0 : 21;    /* [31..11]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_ODC2;
+
+/* define the union U_V0_VOPP_CSC_MIN_Y */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc_min_y : 10; /* [9..0]  */
+        unsigned int reserved_0 : 22;     /* [31..10]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_MIN_Y;
+
+/* define the union U_V0_VOPP_CSC_MIN_C */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc_min_c : 10; /* [9..0]  */
+        unsigned int reserved_0 : 22;     /* [31..10]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_MIN_C;
+
+/* define the union U_V0_VOPP_CSC_MAX_Y */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc_max_y : 10; /* [9..0]  */
+        unsigned int reserved_0 : 22;     /* [31..10]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_MAX_Y;
+
+/* define the union U_V0_VOPP_CSC_MAX_C */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc_max_c : 10; /* [9..0]  */
+        unsigned int reserved_0 : 22;     /* [31..10]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_MAX_C;
+
+/* define the union U_V0_VOPP_CSC2_COEF00 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc2_coef00 : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;       /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC2_COEF00;
+
+/* define the union U_V0_VOPP_CSC2_COEF01 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc2_coef01 : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;       /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC2_COEF01;
+
+/* define the union U_V0_VOPP_CSC2_COEF02 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc2_coef02 : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;       /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC2_COEF02;
+
+/* define the union U_V0_VOPP_CSC2_COEF10 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc2_coef10 : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;       /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC2_COEF10;
+
+/* define the union U_V0_VOPP_CSC2_COEF11 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc2_coef11 : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;       /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC2_COEF11;
+
+/* define the union U_V0_VOPP_CSC2_COEF12 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc2_coef12 : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;       /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC2_COEF12;
+
+/* define the union U_V0_VOPP_CSC2_COEF20 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc2_coef20 : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;       /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC2_COEF20;
+
+/* define the union U_V0_VOPP_CSC2_COEF21 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc2_coef21 : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;       /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC2_COEF21;
+
+/* define the union U_V0_VOPP_CSC2_COEF22 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc2_coef22 : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;       /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC2_COEF22;
+
+/* define the union U_V0_VOPP_CSC2_SCALE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc2_scale : 4; /* [3..0]  */
+        unsigned int reserved_0 : 28;     /* [31..4]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC2_SCALE;
+
+/* define the union U_V0_VOPP_CSC2_IDC0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc2_idc0 : 11; /* [10..0]  */
+        unsigned int reserved_0 : 21;     /* [31..11]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC2_IDC0;
+
+/* define the union U_V0_VOPP_CSC2_IDC1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc2_idc1 : 11; /* [10..0]  */
+        unsigned int reserved_0 : 21;     /* [31..11]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC2_IDC1;
+
+/* define the union U_V0_VOPP_CSC2_IDC2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc2_idc2 : 11; /* [10..0]  */
+        unsigned int reserved_0 : 21;     /* [31..11]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC2_IDC2;
+
+/* define the union U_V0_VOPP_CSC2_ODC0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc2_odc0 : 11; /* [10..0]  */
+        unsigned int reserved_0 : 21;     /* [31..11]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC2_ODC0;
+
+/* define the union U_V0_VOPP_CSC2_ODC1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc2_odc1 : 11; /* [10..0]  */
+        unsigned int reserved_0 : 21;     /* [31..11]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC2_ODC1;
+
+/* define the union U_V0_VOPP_CSC2_ODC2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc2_odc2 : 11; /* [10..0]  */
+        unsigned int reserved_0 : 21;     /* [31..11]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC2_ODC2;
+
+/* define the union U_V0_VOPP_CSC2_MIN_Y */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc2_min_y : 10; /* [9..0]  */
+        unsigned int reserved_0 : 22;      /* [31..10]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC2_MIN_Y;
+
+/* define the union U_V0_VOPP_CSC2_MIN_C */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc2_min_c : 10; /* [9..0]  */
+        unsigned int reserved_0 : 22;      /* [31..10]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC2_MIN_C;
+
+/* define the union U_V0_VOPP_CSC2_MAX_Y */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc2_max_y : 10; /* [9..0]  */
+        unsigned int reserved_0 : 22;      /* [31..10]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC2_MAX_Y;
+
+/* define the union U_V0_VOPP_CSC2_MAX_C */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vopp_csc2_max_c : 10; /* [9..0]  */
+        unsigned int reserved_0 : 22;      /* [31..10]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC2_MAX_C;
+
+/* define the union U_V0_VOPP_CSC_INK_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int ink_en : 1;       /* [0]  */
+        unsigned int ink_sel : 1;      /* [1]  */
+        unsigned int data_fmt : 1;     /* [2]  */
+        unsigned int cross_enable : 1; /* [3]  */
+        unsigned int color_mode : 2;   /* [5..4]  */
+        unsigned int reserved_0 : 26;  /* [31..6]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_INK_CTRL;
+
+/* define the union U_V0_VOPP_CSC_INK_POS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int x_pos : 16; /* [15..0]  */
+        unsigned int y_pos : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_INK_POS;
+
+/* define the union U_V0_VOPP_CSC_INK_DATA */
+typedef union {
+    /* define the struct bits  */
+    struct {
+        unsigned int ink_data : 32; /* [31..0]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_INK_DATA;
+/* define the union U_V0_VOPP_CSC_INK_DATA2 */
+typedef union {
+    /* define the struct bits  */
+    struct {
+        unsigned int ink_data2 : 32; /* [31..0]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_VOPP_CSC_INK_DATA2;
+/* define the union U_V0_CVFIR_VINFO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int out_height : 16;   /* [15..0]  */
+        unsigned int out_fmt : 2;       /* [17..16]  */
+        unsigned int out_pro : 1;       /* [18]  */
+        unsigned int vzme_ck_gt_en : 1; /* [19]  */
+        unsigned int reserved_0 : 12;   /* [31..20]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_CVFIR_VINFO;
+
+/* define the union U_V0_CVFIR_VSP */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vratio : 16;    /* [15..0]  */
+        unsigned int reserved_0 : 1; /* [16]  */
+        unsigned int reserved_1 : 8; /* [24..17]  */
+        unsigned int cvfir_mode : 1; /* [25]  */
+        unsigned int reserved_2 : 1; /* [26]  */
+        unsigned int reserved_3 : 1; /* [27]  */
+        unsigned int cvmid_en : 1;   /* [28]  */
+        unsigned int reserved_4 : 1; /* [29]  */
+        unsigned int cvfir_en : 1;   /* [30]  */
+        unsigned int reserved_5 : 1; /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_CVFIR_VSP;
+
+/* define the union U_V0_CVFIR_VOFFSET */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vchroma_offset : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;     /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_CVFIR_VOFFSET;
+
+/* define the union U_V0_CVFIR_VBOFFSET */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vbchroma_offset : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;      /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_CVFIR_VBOFFSET;
+
+/* define the union U_V0_CVFIR_VCOEF0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vccoef02 : 10;  /* [9..0]  */
+        unsigned int vccoef01 : 10;  /* [19..10]  */
+        unsigned int vccoef00 : 10;  /* [29..20]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_CVFIR_VCOEF0;
+
+/* define the union U_V0_CVFIR_VCOEF1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vccoef11 : 10;  /* [9..0]  */
+        unsigned int vccoef10 : 10;  /* [19..10]  */
+        unsigned int vccoef03 : 10;  /* [29..20]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_CVFIR_VCOEF1;
+
+/* define the union U_V0_CVFIR_VCOEF2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vccoef13 : 10;   /* [9..0]  */
+        unsigned int vccoef12 : 10;   /* [19..10]  */
+        unsigned int reserved_0 : 12; /* [31..20]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_CVFIR_VCOEF2;
+
+/* define the union U_V0_HFIR_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 1;  /* [0]  */
+        unsigned int hfir_mode : 2;   /* [2..1]  */
+        unsigned int mid_en : 1;      /* [3]  */
+        unsigned int ck_gt_en : 1;    /* [4]  */
+        unsigned int reserved_1 : 27; /* [31..5]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_HFIR_CTRL;
+
+/* define the union U_V0_HFIRCOEF01 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int coef0 : 10;     /* [9..0]  */
+        unsigned int reserved_0 : 6; /* [15..10]  */
+        unsigned int coef1 : 10;     /* [25..16]  */
+        unsigned int reserved_1 : 6; /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_HFIRCOEF01;
+
+/* define the union U_V0_HFIRCOEF23 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int coef2 : 10;     /* [9..0]  */
+        unsigned int reserved_0 : 6; /* [15..10]  */
+        unsigned int coef3 : 10;     /* [25..16]  */
+        unsigned int reserved_1 : 6; /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_HFIRCOEF23;
+
+/* define the union U_V0_HFIRCOEF45 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int coef4 : 10;     /* [9..0]  */
+        unsigned int reserved_0 : 6; /* [15..10]  */
+        unsigned int coef5 : 10;     /* [25..16]  */
+        unsigned int reserved_1 : 6; /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_HFIRCOEF45;
+
+/* define the union U_V0_HFIRCOEF67 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int coef6 : 10;     /* [9..0]  */
+        unsigned int reserved_0 : 6; /* [15..10]  */
+        unsigned int coef7 : 10;     /* [25..16]  */
+        unsigned int reserved_1 : 6; /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_HFIRCOEF67;
+
+/* define the union U_V1_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int galpha : 8;      /* [7..0]  */
+        unsigned int reserved_0 : 20; /* [27..8]  */
+        unsigned int rupd_field : 1;  /* [28]  */
+        unsigned int rgup_mode : 1;   /* [29]  */
+        unsigned int nosec_flag : 1;  /* [30]  */
+        unsigned int surface_en : 1;  /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_CTRL;
+
+/* define the union U_V1_UPD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int regup : 1;       /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_UPD;
+
+/* define the union U_V1_0RESO_READ */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int ow : 16; /* [15..0]  */
+        unsigned int oh : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_0RESO_READ;
+
+/* define the union U_V1_DFPOS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int disp_xfpos : 16; /* [15..0]  */
+        unsigned int disp_yfpos : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_DFPOS;
+
+/* define the union U_V1_DLPOS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int disp_xlpos : 16; /* [15..0]  */
+        unsigned int disp_ylpos : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_DLPOS;
+
+/* define the union U_V1_VFPOS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int video_xfpos : 16; /* [15..0]  */
+        unsigned int video_yfpos : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_VFPOS;
+
+/* define the union U_V1_VLPOS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int video_xlpos : 16; /* [15..0]  */
+        unsigned int video_ylpos : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_VLPOS;
+
+/* define the union U_V1_BK */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vbk_cr : 10;    /* [9..0]  */
+        unsigned int vbk_cb : 10;    /* [19..10]  */
+        unsigned int vbk_y : 10;     /* [29..20]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_BK;
+
+/* define the union U_V1_ALPHA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vbk_alpha : 8;   /* [7..0]  */
+        unsigned int reserved_0 : 24; /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_ALPHA;
+
+/* define the union U_V1_MUTE_BK */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mute_cr : 10;   /* [9..0]  */
+        unsigned int mute_cb : 10;   /* [19..10]  */
+        unsigned int mute_y : 10;    /* [29..20]  */
+        unsigned int reserved_0 : 1; /* [30]  */
+        unsigned int mute_en : 1;    /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_MUTE_BK;
+
+/* define the union U_V1_RIMWIDTH */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int v0_rim_width : 5; /* [4..0]  */
+        unsigned int reserved_0 : 27;  /* [31..5]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_RIMWIDTH;
+
+/* define the union U_V1_RIMCOL0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int v0_rim_v0 : 10; /* [9..0]  */
+        unsigned int v0_rim_u0 : 10; /* [19..10]  */
+        unsigned int v0_rim_y0 : 10; /* [29..20]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_RIMCOL0;
+
+/* define the union U_V1_RIMCOL1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int v0_rim_v1 : 10; /* [9..0]  */
+        unsigned int v0_rim_u1 : 10; /* [19..10]  */
+        unsigned int v0_rim_y1 : 10; /* [29..20]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_RIMCOL1;
+
+/* define the union U_V1_CVFIR_VINFO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int out_height : 16;   /* [15..0]  */
+        unsigned int out_fmt : 2;       /* [17..16]  */
+        unsigned int out_pro : 1;       /* [18]  */
+        unsigned int vzme_ck_gt_en : 1; /* [19]  */
+        unsigned int reserved_0 : 12;   /* [31..20]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_CVFIR_VINFO;
+
+/* define the union U_V1_CVFIR_VSP */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vratio : 16;    /* [15..0]  */
+        unsigned int reserved_0 : 1; /* [16]  */
+        unsigned int reserved_1 : 8; /* [24..17]  */
+        unsigned int cvfir_mode : 1; /* [25]  */
+        unsigned int reserved_2 : 1; /* [26]  */
+        unsigned int reserved_3 : 1; /* [27]  */
+        unsigned int cvmid_en : 1;   /* [28]  */
+        unsigned int reserved_4 : 1; /* [29]  */
+        unsigned int cvfir_en : 1;   /* [30]  */
+        unsigned int reserved_5 : 1; /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_CVFIR_VSP;
+
+/* define the union U_V1_CVFIR_VOFFSET */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vchroma_offset : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;     /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_CVFIR_VOFFSET;
+
+/* define the union U_V1_CVFIR_VBOFFSET */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vbchroma_offset : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;      /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_CVFIR_VBOFFSET;
+
+/* define the union U_V1_CVFIR_VCOEF0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vccoef02 : 10;  /* [9..0]  */
+        unsigned int vccoef01 : 10;  /* [19..10]  */
+        unsigned int vccoef00 : 10;  /* [29..20]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_CVFIR_VCOEF0;
+
+/* define the union U_V1_CVFIR_VCOEF1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vccoef11 : 10;  /* [9..0]  */
+        unsigned int vccoef10 : 10;  /* [19..10]  */
+        unsigned int vccoef03 : 10;  /* [29..20]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_CVFIR_VCOEF1;
+
+/* define the union U_V1_CVFIR_VCOEF2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vccoef13 : 10;   /* [9..0]  */
+        unsigned int vccoef12 : 10;   /* [19..10]  */
+        unsigned int reserved_0 : 12; /* [31..20]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_CVFIR_VCOEF2;
+
+/* define the union U_V1_HFIR_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 1;  /* [0]  */
+        unsigned int hfir_mode : 2;   /* [2..1]  */
+        unsigned int mid_en : 1;      /* [3]  */
+        unsigned int ck_gt_en : 1;    /* [4]  */
+        unsigned int reserved_1 : 27; /* [31..5]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_HFIR_CTRL;
+
+/* define the union U_V1_HFIRCOEF01 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int coef0 : 10;     /* [9..0]  */
+        unsigned int reserved_0 : 6; /* [15..10]  */
+        unsigned int coef1 : 10;     /* [25..16]  */
+        unsigned int reserved_1 : 6; /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_HFIRCOEF01;
+
+/* define the union U_V1_HFIRCOEF23 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int coef2 : 10;     /* [9..0]  */
+        unsigned int reserved_0 : 6; /* [15..10]  */
+        unsigned int coef3 : 10;     /* [25..16]  */
+        unsigned int reserved_1 : 6; /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_HFIRCOEF23;
+
+/* define the union U_V1_HFIRCOEF45 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int coef4 : 10;     /* [9..0]  */
+        unsigned int reserved_0 : 6; /* [15..10]  */
+        unsigned int coef5 : 10;     /* [25..16]  */
+        unsigned int reserved_1 : 6; /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_HFIRCOEF45;
+
+/* define the union U_V1_HFIRCOEF67 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int coef6 : 10;     /* [9..0]  */
+        unsigned int reserved_0 : 6; /* [15..10]  */
+        unsigned int coef7 : 10;     /* [25..16]  */
+        unsigned int reserved_1 : 6; /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_HFIRCOEF67;
+
+/* define the union U_V2_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int galpha : 8;      /* [7..0]  */
+        unsigned int reserved_0 : 20; /* [27..8]  */
+        unsigned int rupd_field : 1;  /* [28]  */
+        unsigned int rgup_mode : 1;   /* [29]  */
+        unsigned int nosec_flag : 1;  /* [30]  */
+        unsigned int surface_en : 1;  /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V2_CTRL;
+
+/* define the union U_V2_UPD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int regup : 1;       /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V2_UPD;
+
+/* define the union U_V2_0RESO_READ */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int ow : 16; /* [15..0]  */
+        unsigned int oh : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V2_0RESO_READ;
+
+/* define the union U_V2_DFPOS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int disp_xfpos : 16; /* [15..0]  */
+        unsigned int disp_yfpos : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V2_DFPOS;
+
+/* define the union U_V2_DLPOS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int disp_xlpos : 16; /* [15..0]  */
+        unsigned int disp_ylpos : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V2_DLPOS;
+
+/* define the union U_V2_VFPOS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int video_xfpos : 16; /* [15..0]  */
+        unsigned int video_yfpos : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V2_VFPOS;
+
+/* define the union U_V2_VLPOS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int video_xlpos : 16; /* [15..0]  */
+        unsigned int video_ylpos : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V2_VLPOS;
+
+/* define the union U_V2_BK */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vbk_cr : 10;    /* [9..0]  */
+        unsigned int vbk_cb : 10;    /* [19..10]  */
+        unsigned int vbk_y : 10;     /* [29..20]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V2_BK;
+
+/* define the union U_V2_ALPHA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vbk_alpha : 8;   /* [7..0]  */
+        unsigned int reserved_0 : 24; /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V2_ALPHA;
+
+/* define the union U_V2_MUTE_BK */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mute_cr : 10;   /* [9..0]  */
+        unsigned int mute_cb : 10;   /* [19..10]  */
+        unsigned int mute_y : 10;    /* [29..20]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V2_MUTE_BK;
+
+/* define the union U_V2_LBOX_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mute_en : 1;     /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V2_LBOX_CTRL;
+
+/* define the union U_V2_CVFIR_VINFO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int out_height : 16;   /* [15..0]  */
+        unsigned int out_fmt : 2;       /* [17..16]  */
+        unsigned int out_pro : 1;       /* [18]  */
+        unsigned int vzme_ck_gt_en : 1; /* [19]  */
+        unsigned int reserved_0 : 12;   /* [31..20]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V2_CVFIR_VINFO;
+
+/* define the union U_V2_CVFIR_VSP */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vratio : 16;    /* [15..0]  */
+        unsigned int reserved_0 : 1; /* [16]  */
+        unsigned int reserved_1 : 8; /* [24..17]  */
+        unsigned int cvfir_mode : 1; /* [25]  */
+        unsigned int reserved_2 : 1; /* [26]  */
+        unsigned int reserved_3 : 1; /* [27]  */
+        unsigned int cvmid_en : 1;   /* [28]  */
+        unsigned int reserved_4 : 1; /* [29]  */
+        unsigned int cvfir_en : 1;   /* [30]  */
+        unsigned int reserved_5 : 1; /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V2_CVFIR_VSP;
+
+/* define the union U_V2_CVFIR_VOFFSET */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vchroma_offset : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;     /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V2_CVFIR_VOFFSET;
+
+/* define the union U_V2_CVFIR_VBOFFSET */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vbchroma_offset : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;      /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V2_CVFIR_VBOFFSET;
+
+/* define the union U_V2_CVFIR_VCOEF0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vccoef02 : 10;  /* [9..0]  */
+        unsigned int vccoef01 : 10;  /* [19..10]  */
+        unsigned int vccoef00 : 10;  /* [29..20]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V2_CVFIR_VCOEF0;
+
+/* define the union U_V2_CVFIR_VCOEF1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vccoef11 : 10;  /* [9..0]  */
+        unsigned int vccoef10 : 10;  /* [19..10]  */
+        unsigned int vccoef03 : 10;  /* [29..20]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V2_CVFIR_VCOEF1;
+
+/* define the union U_V2_CVFIR_VCOEF2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vccoef13 : 10;   /* [9..0]  */
+        unsigned int vccoef12 : 10;   /* [19..10]  */
+        unsigned int reserved_0 : 12; /* [31..20]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V2_CVFIR_VCOEF2;
+
+/* define the union U_V2_HFIR_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 1;  /* [0]  */
+        unsigned int hfir_mode : 2;   /* [2..1]  */
+        unsigned int mid_en : 1;      /* [3]  */
+        unsigned int ck_gt_en : 1;    /* [4]  */
+        unsigned int reserved_1 : 27; /* [31..5]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V2_HFIR_CTRL;
+
+/* define the union U_V2_HFIRCOEF01 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int coef0 : 10;     /* [9..0]  */
+        unsigned int reserved_0 : 6; /* [15..10]  */
+        unsigned int coef1 : 10;     /* [25..16]  */
+        unsigned int reserved_1 : 6; /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V2_HFIRCOEF01;
+
+/* define the union U_V2_HFIRCOEF23 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int coef2 : 10;     /* [9..0]  */
+        unsigned int reserved_0 : 6; /* [15..10]  */
+        unsigned int coef3 : 10;     /* [25..16]  */
+        unsigned int reserved_1 : 6; /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V2_HFIRCOEF23;
+
+/* define the union U_V2_HFIRCOEF45 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int coef4 : 10;     /* [9..0]  */
+        unsigned int reserved_0 : 6; /* [15..10]  */
+        unsigned int coef5 : 10;     /* [25..16]  */
+        unsigned int reserved_1 : 6; /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V2_HFIRCOEF45;
+
+/* define the union U_V2_HFIRCOEF67 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int coef6 : 10;     /* [9..0]  */
+        unsigned int reserved_0 : 6; /* [15..10]  */
+        unsigned int coef7 : 10;     /* [25..16]  */
+        unsigned int reserved_1 : 6; /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V2_HFIRCOEF67;
+
+/* define the union U_VP0_UPD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int regup : 1;       /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VP0_UPD;
+
+/* define the union U_VP0_IRESO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int iw : 16; /* [15..0]  */
+        unsigned int ih : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VP0_IRESO;
+
+/* define the union U_VP0_LBOX_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mute_en : 1;     /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VP0_LBOX_CTRL;
+
+/* define the union U_VP0_GALPHA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int galpha : 8;      /* [7..0]  */
+        unsigned int reserved_0 : 24; /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VP0_GALPHA;
+
+/* define the union U_VP0_DFPOS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int disp_xfpos : 12; /* [11..0]  */
+        unsigned int disp_yfpos : 12; /* [23..12]  */
+        unsigned int reserved_0 : 8;  /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VP0_DFPOS;
+
+/* define the union U_VP0_DLPOS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int disp_xlpos : 12; /* [11..0]  */
+        unsigned int disp_ylpos : 12; /* [23..12]  */
+        unsigned int reserved_0 : 8;  /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VP0_DLPOS;
+
+/* define the union U_VP0_VFPOS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int video_xfpos : 12; /* [11..0]  */
+        unsigned int video_yfpos : 12; /* [23..12]  */
+        unsigned int reserved_0 : 8;   /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VP0_VFPOS;
+
+/* define the union U_VP0_VLPOS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int video_xlpos : 12; /* [11..0]  */
+        unsigned int video_ylpos : 12; /* [23..12]  */
+        unsigned int reserved_0 : 8;   /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VP0_VLPOS;
+
+/* define the union U_VP0_BK */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vbk_cr : 10;    /* [9..0]  */
+        unsigned int vbk_cb : 10;    /* [19..10]  */
+        unsigned int vbk_y : 10;     /* [29..20]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VP0_BK;
+
+/* define the union U_VP0_ALPHA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vbk_alpha : 8;   /* [7..0]  */
+        unsigned int reserved_0 : 24; /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VP0_ALPHA;
+
+/* define the union U_VP0_MUTE_BK */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mute_cr : 10;   /* [9..0]  */
+        unsigned int mute_cb : 10;   /* [19..10]  */
+        unsigned int mute_y : 10;    /* [29..20]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VP0_MUTE_BK;
+
+/* define the union U_GP0_UPD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int regup : 1;       /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GP0_UPD;
+
+/* define the union U_GP0_IRESO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int iw : 16; /* [15..0]  */
+        unsigned int ih : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GP0_IRESO;
+
+/* define the union U_GP0_LBOX_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mute_en : 1;     /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GP0_LBOX_CTRL;
+
+/* define the union U_GP0_GALPHA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int galpha : 8;      /* [7..0]  */
+        unsigned int reserved_0 : 24; /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GP0_GALPHA;
+
+/* define the union U_GP0_DFPOS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int disp_xfpos : 12; /* [11..0]  */
+        unsigned int disp_yfpos : 12; /* [23..12]  */
+        unsigned int reserved_0 : 8;  /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GP0_DFPOS;
+
+/* define the union U_GP0_DLPOS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int disp_xlpos : 12; /* [11..0]  */
+        unsigned int disp_ylpos : 12; /* [23..12]  */
+        unsigned int reserved_0 : 8;  /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GP0_DLPOS;
+
+/* define the union U_GP0_VFPOS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int video_xfpos : 12; /* [11..0]  */
+        unsigned int video_yfpos : 12; /* [23..12]  */
+        unsigned int reserved_0 : 8;   /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GP0_VFPOS;
+
+/* define the union U_GP0_VLPOS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int video_xlpos : 12; /* [11..0]  */
+        unsigned int video_ylpos : 12; /* [23..12]  */
+        unsigned int reserved_0 : 8;   /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GP0_VLPOS;
+
+/* define the union U_GP0_BK */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vbk_cr : 10;    /* [9..0]  */
+        unsigned int vbk_cb : 10;    /* [19..10]  */
+        unsigned int vbk_y : 10;     /* [29..20]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GP0_BK;
+
+/* define the union U_GP0_ALPHA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vbk_alpha : 8;   /* [7..0]  */
+        unsigned int reserved_0 : 24; /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GP0_ALPHA;
+
+/* define the union U_GP0_MUTE_BK */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mute_cr : 10;   /* [9..0]  */
+        unsigned int mute_cb : 10;   /* [19..10]  */
+        unsigned int mute_y : 10;    /* [29..20]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GP0_MUTE_BK;
+
+/* define the union U_GP0_CSC_IDC */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int cscidc0 : 11;   /* [10..0]  */
+        unsigned int cscidc1 : 11;   /* [21..11]  */
+        unsigned int csc_en : 1;     /* [22]  */
+        unsigned int reserved_0 : 9; /* [31..23]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GP0_CSC_IDC;
+
+/* define the union U_GP0_CSC_ODC */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int cscodc0 : 11;      /* [10..0]  */
+        unsigned int cscodc1 : 11;      /* [21..11]  */
+        unsigned int csc_sign_mode : 1; /* [22]  */
+        unsigned int reserved_0 : 9;    /* [31..23]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GP0_CSC_ODC;
+
+/* define the union U_GP0_CSC_IODC */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int cscidc2 : 11;    /* [10..0]  */
+        unsigned int cscodc2 : 11;    /* [21..11]  */
+        unsigned int reserved_0 : 10; /* [31..22]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GP0_CSC_IODC;
+
+/* define the union U_GP0_CSC_P0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int cscp00 : 15;    /* [14..0]  */
+        unsigned int reserved_0 : 1; /* [15]  */
+        unsigned int cscp01 : 15;    /* [30..16]  */
+        unsigned int reserved_1 : 1; /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GP0_CSC_P0;
+
+/* define the union U_GP0_CSC_P1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int cscp02 : 15;    /* [14..0]  */
+        unsigned int reserved_0 : 1; /* [15]  */
+        unsigned int cscp10 : 15;    /* [30..16]  */
+        unsigned int reserved_1 : 1; /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GP0_CSC_P1;
+
+/* define the union U_GP0_CSC_P2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int cscp11 : 15;    /* [14..0]  */
+        unsigned int reserved_0 : 1; /* [15]  */
+        unsigned int cscp12 : 15;    /* [30..16]  */
+        unsigned int reserved_1 : 1; /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GP0_CSC_P2;
+
+/* define the union U_GP0_CSC_P3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int cscp20 : 15;    /* [14..0]  */
+        unsigned int reserved_0 : 1; /* [15]  */
+        unsigned int cscp21 : 15;    /* [30..16]  */
+        unsigned int reserved_1 : 1; /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GP0_CSC_P3;
+
+/* define the union U_GP0_CSC_P4 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int cscp22 : 15;     /* [14..0]  */
+        unsigned int reserved_0 : 17; /* [31..15]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GP0_CSC_P4;
+
+/* define the union U_WBC_G0_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int req_interval : 10; /* [9..0]  */
+        unsigned int auto_stop_en : 1;  /* [10]  */
+        unsigned int reserved_0 : 15;   /* [25..11]  */
+        unsigned int format_out : 2;    /* [27..26]  */
+        unsigned int reserved_1 : 3;    /* [30..28]  */
+        unsigned int wbc_en : 1;        /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_G0_CTRL;
+
+/* define the union U_WBC_G0_UPD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int regup : 1;       /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_G0_UPD;
+
+/* define the union U_WBC_G0_CMP */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int cmp_lossy_en : 1; /* [0]  */
+        unsigned int reserved_0 : 3;   /* [3..1]  */
+        unsigned int cmp_drr : 4;      /* [7..4]  */
+        unsigned int reserved_1 : 23;  /* [30..8]  */
+        unsigned int cmp_en : 1;       /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_G0_CMP;
+
+/* define the union U_WBC_G0_STRIDE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int wbcstride : 16;  /* [15..0]  */
+        unsigned int reserved_0 : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_G0_STRIDE;
+
+/* define the union U_WBC_G0_ORESO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int ow : 12;        /* [11..0]  */
+        unsigned int oh : 12;        /* [23..12]  */
+        unsigned int reserved_0 : 8; /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_G0_ORESO;
+
+/* define the union U_WBC_G0_FCROP */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int wfcrop : 12;    /* [11..0]  */
+        unsigned int hfcrop : 12;    /* [23..12]  */
+        unsigned int reserved_0 : 8; /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_G0_FCROP;
+
+/* define the union U_WBC_G0_LCROP */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int wlcrop : 12;    /* [11..0]  */
+        unsigned int hlcrop : 12;    /* [23..12]  */
+        unsigned int reserved_0 : 8; /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_G0_LCROP;
+
+/* define the union U_WBC_GP0_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int req_interval : 10;  /* [9..0]  */
+        unsigned int auto_stop_en : 1;   /* [10]  */
+        unsigned int reserved_0 : 1;     /* [11]  */
+        unsigned int wbc_vtthd_mode : 1; /* [12]  */
+        unsigned int reserved_1 : 5;     /* [17..13]  */
+        unsigned int three_d_mode : 2;   /* [19..18]  */
+        unsigned int reserved_2 : 3;     /* [22..20]  */
+        unsigned int flip_en : 1;        /* [23]  */
+        unsigned int format_out : 4;     /* [27..24]  */
+        unsigned int mode_out : 2;       /* [29..28]  */
+        unsigned int reserved_3 : 1;     /* [30]  */
+        unsigned int wbc_en : 1;         /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_GP0_CTRL;
+
+/* define the union U_WBC_GP0_UPD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int regup : 1;       /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_GP0_UPD;
+
+/* define the union U_WBC_GP0_STRIDE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int wbclstride : 16; /* [15..0]  */
+        unsigned int wbccstride : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_GP0_STRIDE;
+
+/* define the union U_WBC_GP0_ORESO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int ow : 12;        /* [11..0]  */
+        unsigned int oh : 12;        /* [23..12]  */
+        unsigned int reserved_0 : 8; /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_GP0_ORESO;
+
+/* define the union U_WBC_GP0_FCROP */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int wfcrop : 12;    /* [11..0]  */
+        unsigned int hfcrop : 12;    /* [23..12]  */
+        unsigned int reserved_0 : 8; /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_GP0_FCROP;
+
+/* define the union U_WBC_GP0_LCROP */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int wlcrop : 12;    /* [11..0]  */
+        unsigned int hlcrop : 12;    /* [23..12]  */
+        unsigned int reserved_0 : 8; /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_GP0_LCROP;
+
+/* define the union U_WBC_GP0_DITHER_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 29;  /* [28..0]  */
+        unsigned int dither_round : 1; /* [29]  */
+        unsigned int dither_mode : 1;  /* [30]  */
+        unsigned int dither_en : 1;    /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_GP0_DITHER_CTRL;
+
+/* define the union U_WBC_GP0_DITHER_COEF0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_coef0 : 8; /* [7..0]  */
+        unsigned int dither_coef1 : 8; /* [15..8]  */
+        unsigned int dither_coef2 : 8; /* [23..16]  */
+        unsigned int dither_coef3 : 8; /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_GP0_DITHER_COEF0;
+
+/* define the union U_WBC_GP0_DITHER_COEF1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_coef4 : 8; /* [7..0]  */
+        unsigned int dither_coef5 : 8; /* [15..8]  */
+        unsigned int dither_coef6 : 8; /* [23..16]  */
+        unsigned int dither_coef7 : 8; /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_GP0_DITHER_COEF1;
+
+/* define the union U_WBC_GP0_HPZME */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 29;  /* [28..0]  */
+        unsigned int hpzme_mode : 1;   /* [29]  */
+        unsigned int hpzme_mid_en : 1; /* [30]  */
+        unsigned int hpzme_en : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_GP0_HPZME;
+
+/* define the union U_WBC_ME_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int req_interval : 10; /* [9..0]  */
+        unsigned int reserved_0 : 10;   /* [19..10]  */
+        unsigned int ofl_master : 1;    /* [20]  */
+        unsigned int reserved_1 : 2;    /* [22..21]  */
+        unsigned int mad_data_mode : 1; /* [23]  */
+        unsigned int format_out : 4;    /* [27..24]  */
+        unsigned int reserved_2 : 1;    /* [28]  */
+        unsigned int c_wbc_en : 1;      /* [29]  */
+        unsigned int reserved_3 : 1;    /* [30]  */
+        unsigned int wbc_en : 1;        /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_ME_CTRL;
+
+/* define the union U_WBC_ME_UPD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int regup : 1;       /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_ME_UPD;
+
+/* define the union U_WBC_ME_WLEN_SEL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int wlen_sel : 2;    /* [1..0]  */
+        unsigned int reserved_0 : 30; /* [31..2]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_ME_WLEN_SEL;
+
+/* define the union U_WBC_ME_STRIDE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int wbclstride : 16; /* [15..0]  */
+        unsigned int wbccstride : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_ME_STRIDE;
+
+/* define the union U_WBC_ME_ORESO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int ow : 12;        /* [11..0]  */
+        unsigned int oh : 12;        /* [23..12]  */
+        unsigned int reserved_0 : 8; /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_ME_ORESO;
+
+/* define the union U_WBC_ME_SMMU_BYPASS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int l_bypass : 1;    /* [0]  */
+        unsigned int c_bypass : 1;    /* [1]  */
+        unsigned int reserved_0 : 30; /* [31..2]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_ME_SMMU_BYPASS;
+
+/* define the union U_WBC_ME_PARAUP */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int wbc_hlcoef_upd : 1; /* [0]  */
+        unsigned int wbc_hccoef_upd : 1; /* [1]  */
+        unsigned int wbc_vlcoef_upd : 1; /* [2]  */
+        unsigned int wbc_vccoef_upd : 1; /* [3]  */
+        unsigned int reserved_0 : 28;    /* [31..4]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_ME_PARAUP;
+
+/* define the union U_WBC_ME_DITHER_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 29;  /* [28..0]  */
+        unsigned int dither_round : 1; /* [29]  */
+        unsigned int dither_mode : 1;  /* [30]  */
+        unsigned int dither_en : 1;    /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_ME_DITHER_CTRL;
+
+/* define the union U_WBC_ME_DITHER_COEF0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_coef0 : 8; /* [7..0]  */
+        unsigned int dither_coef1 : 8; /* [15..8]  */
+        unsigned int dither_coef2 : 8; /* [23..16]  */
+        unsigned int dither_coef3 : 8; /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_ME_DITHER_COEF0;
+
+/* define the union U_WBC_ME_DITHER_COEF1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_coef4 : 8; /* [7..0]  */
+        unsigned int dither_coef5 : 8; /* [15..8]  */
+        unsigned int dither_coef6 : 8; /* [23..16]  */
+        unsigned int dither_coef7 : 8; /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_ME_DITHER_COEF1;
+
+/* define the union U_WBC_ME_ZME_HSP */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hratio : 24;    /* [23..0]  */
+        unsigned int hfir_order : 1; /* [24]  */
+        unsigned int hchfir_en : 1;  /* [25]  */
+        unsigned int hlfir_en : 1;   /* [26]  */
+        unsigned int reserved_0 : 1; /* [27]  */
+        unsigned int hchmid_en : 1;  /* [28]  */
+        unsigned int hlmid_en : 1;   /* [29]  */
+        unsigned int hchmsc_en : 1;  /* [30]  */
+        unsigned int hlmsc_en : 1;   /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_ME_ZME_HSP;
+
+/* define the union U_WBC_ME_ZME_HLOFFSET */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hor_loffset : 28; /* [27..0]  */
+        unsigned int reserved_0 : 4;   /* [31..28]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_ME_ZME_HLOFFSET;
+
+/* define the union U_WBC_ME_ZME_HCOFFSET */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hor_coffset : 28; /* [27..0]  */
+        unsigned int reserved_0 : 4;   /* [31..28]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_ME_ZME_HCOFFSET;
+
+/* define the union U_WBC_ME_ZME_VSP */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 19; /* [18..0]  */
+        unsigned int zme_in_fmt : 2;  /* [20..19]  */
+        unsigned int zme_out_fmt : 2; /* [22..21]  */
+        unsigned int vchfir_en : 1;   /* [23]  */
+        unsigned int vlfir_en : 1;    /* [24]  */
+        unsigned int reserved_1 : 3;  /* [27..25]  */
+        unsigned int vchmid_en : 1;   /* [28]  */
+        unsigned int vlmid_en : 1;    /* [29]  */
+        unsigned int vchmsc_en : 1;   /* [30]  */
+        unsigned int vlmsc_en : 1;    /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_ME_ZME_VSP;
+
+/* define the union U_WBC_ME_ZME_VSR */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vratio : 16;     /* [15..0]  */
+        unsigned int reserved_0 : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_ME_ZME_VSR;
+
+/* define the union U_WBC_ME_ZME_VOFFSET */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vchroma_offset : 16; /* [15..0]  */
+        unsigned int vluma_offset : 16;   /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_ME_ZME_VOFFSET;
+
+/* define the union U_WBC_ME_ZME_VBOFFSET */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vbchroma_offset : 16; /* [15..0]  */
+        unsigned int vbluma_offset : 16;   /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_ME_ZME_VBOFFSET;
+
+/* define the union U_WBC_FI_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int req_interval : 10; /* [9..0]  */
+        unsigned int reserved_0 : 3;    /* [12..10]  */
+        unsigned int addr_mode : 1;     /* [13]  */
+        unsigned int fsize_mode : 1;    /* [14]  */
+        unsigned int tnr_nrds_en : 1;   /* [15]  */
+        unsigned int reserved_1 : 4;    /* [19..16]  */
+        unsigned int ofl_master : 1;    /* [20]  */
+        unsigned int data_width : 1;    /* [21]  */
+        unsigned int reserved_2 : 2;    /* [23..22]  */
+        unsigned int format_out : 4;    /* [27..24]  */
+        unsigned int reserved_3 : 2;    /* [29..28]  */
+        unsigned int cmp_en : 1;        /* [30]  */
+        unsigned int wbc_en : 1;        /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_FI_CTRL;
+
+/* define the union U_WBC_FI_UPD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int regup : 1;       /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_FI_UPD;
+
+/* define the union U_WBC_FI_WLEN_SEL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int wlen_sel : 2;    /* [1..0]  */
+        unsigned int reserved_0 : 30; /* [31..2]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_FI_WLEN_SEL;
+
+/* define the union U_WBC_FI_STRIDE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int wbclstride : 16; /* [15..0]  */
+        unsigned int wbccstride : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_FI_STRIDE;
+
+/* define the union U_WBC_FI_ORESO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int ow : 12;        /* [11..0]  */
+        unsigned int oh : 12;        /* [23..12]  */
+        unsigned int reserved_0 : 8; /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_FI_ORESO;
+
+/* define the union U_WBC_FI_SMMU_BYPASS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int l_bypass : 1;    /* [0]  */
+        unsigned int c_bypass : 1;    /* [1]  */
+        unsigned int reserved_0 : 30; /* [31..2]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_FI_SMMU_BYPASS;
+
+/* define the union U_WBC_FI_FRAME_SIZE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int frame_size : 23; /* [22..0]  */
+        unsigned int reserved_0 : 9;  /* [31..23]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_FI_FRAME_SIZE;
+
+/* define the union U_WBC_FI_HCDS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 29; /* [28..0]  */
+        unsigned int hchfir_en : 1;   /* [29]  */
+        unsigned int hchmid_en : 1;   /* [30]  */
+        unsigned int hcds_en : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_FI_HCDS;
+
+/* define the union U_WBC_FI_HCDS_COEF0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int coef0 : 10;     /* [9..0]  */
+        unsigned int coef1 : 10;     /* [19..10]  */
+        unsigned int coef2 : 10;     /* [29..20]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_FI_HCDS_COEF0;
+
+/* define the union U_WBC_FI_HCDS_COEF1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int coef3 : 10;      /* [9..0]  */
+        unsigned int reserved_0 : 22; /* [31..10]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_FI_HCDS_COEF1;
+
+/* define the union U_WBC_FI_CMP_MB */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mb_bits : 10;    /* [9..0]  */
+        unsigned int reserved_0 : 22; /* [31..10]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_FI_CMP_MB;
+
+/* define the union U_WBC_FI_CMP_MAX_MIN */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int min_bits_cnt : 10; /* [9..0]  */
+        unsigned int reserved_0 : 6;    /* [15..10]  */
+        unsigned int max_bits_cnt : 10; /* [25..16]  */
+        unsigned int reserved_1 : 6;    /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_FI_CMP_MAX_MIN;
+
+/* define the union U_WBC_FI_CMP_ADJ_THR */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int adj_sad_thr : 12;     /* [11..0]  */
+        unsigned int reserved_0 : 4;       /* [15..12]  */
+        unsigned int adj_sad_bit_thr : 8;  /* [23..16]  */
+        unsigned int adj_spec_bit_thr : 8; /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_FI_CMP_ADJ_THR;
+
+/* define the union U_WBC_FI_CMP_BIG_GRAD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int big_grad_thr : 7;     /* [6..0]  */
+        unsigned int reserved_0 : 1;       /* [7]  */
+        unsigned int big_grad_num_thr : 5; /* [12..8]  */
+        unsigned int reserved_1 : 19;      /* [31..13]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_FI_CMP_BIG_GRAD;
+
+/* define the union U_WBC_FI_CMP_BLK */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int smth_thr : 6;     /* [5..0]  */
+        unsigned int reserved_0 : 2;   /* [7..6]  */
+        unsigned int blk_comp_thr : 3; /* [10..8]  */
+        unsigned int reserved_1 : 21;  /* [31..11]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_FI_CMP_BLK;
+
+/* define the union U_WBC_FI_CMP_GRAPHIC_JUDGE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int graphic_en : 1;     /* [0]  */
+        unsigned int reserved_0 : 15;    /* [15..1]  */
+        unsigned int video_sad_thr : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_FI_CMP_GRAPHIC_JUDGE;
+
+/* define the union U_WBC_FI_CMP_RC */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int sadbits_ngain : 3; /* [2..0]  */
+        unsigned int reserved_0 : 5;    /* [7..3]  */
+        unsigned int rc_smth_gain : 3;  /* [10..8]  */
+        unsigned int reserved_1 : 5;    /* [15..11]  */
+        unsigned int max_trow_bits : 6; /* [21..16]  */
+        unsigned int reserved_2 : 10;   /* [31..22]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_FI_CMP_RC;
+
+/* define the union U_WBC_FI_CMP_FRAME_SIZE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int frame_size : 21; /* [20..0]  */
+        unsigned int reserved_0 : 11; /* [31..21]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_FI_CMP_FRAME_SIZE;
+
+/* define the union U_WBC_CMP_GLB_INFO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int is_lossless : 1; /* [0]  */
+        unsigned int cmp_mode : 1;    /* [1]  */
+        unsigned int dw_mode : 1;     /* [2]  */
+        unsigned int sep_cmp_en : 1;  /* [3]  */
+        unsigned int reserved_0 : 28; /* [31..4]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_CMP_GLB_INFO;
+
+/* define the union U_WBC_CMP_FRAMESIZE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int frame_width : 13;  /* [12..0]  */
+        unsigned int reserved_0 : 3;    /* [15..13]  */
+        unsigned int frame_height : 13; /* [28..16]  */
+        unsigned int reserved_1 : 3;    /* [31..29]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_CMP_FRAMESIZE;
+
+/* define the union U_WBC_CMP_RC_CFG0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mb_bits_y : 10;     /* [9..0]  */
+        unsigned int reserved_0 : 6;     /* [15..10]  */
+        unsigned int min_mb_bits_y : 10; /* [25..16]  */
+        unsigned int reserved_1 : 6;     /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_CMP_RC_CFG0;
+
+/* define the union U_WBC_CMP_RC_CFG2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int max_qp_y : 4;       /* [3..0]  */
+        unsigned int reserved_0 : 4;     /* [7..4]  */
+        unsigned int sad_bits_ngain : 4; /* [11..8]  */
+        unsigned int reserved_1 : 4;     /* [15..12]  */
+        unsigned int rc_smth_ngain : 3;  /* [18..16]  */
+        unsigned int reserved_2 : 5;     /* [23..19]  */
+        unsigned int max_trow_bits : 8;  /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_CMP_RC_CFG2;
+
+/* define the union U_WBC_CMP_RC_CFG3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int max_sad_thr : 7; /* [6..0]  */
+        unsigned int reserved_0 : 9;  /* [15..7]  */
+        unsigned int min_sad_thr : 7; /* [22..16]  */
+        unsigned int reserved_1 : 9;  /* [31..23]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_CMP_RC_CFG3;
+
+/* define the union U_WBC_CMP_RC_CFG4 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int smth_thr : 7;      /* [6..0]  */
+        unsigned int reserved_0 : 1;    /* [7]  */
+        unsigned int still_thr : 7;     /* [14..8]  */
+        unsigned int reserved_1 : 1;    /* [15]  */
+        unsigned int big_grad_thr : 10; /* [25..16]  */
+        unsigned int reserved_2 : 6;    /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_CMP_RC_CFG4;
+
+/* define the union U_WBC_CMP_RC_CFG5 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int smth_pix_num_thr : 6;  /* [5..0]  */
+        unsigned int reserved_0 : 2;        /* [7..6]  */
+        unsigned int still_pix_num_thr : 6; /* [13..8]  */
+        unsigned int reserved_1 : 2;        /* [15..14]  */
+        unsigned int noise_pix_num_thr : 6; /* [21..16]  */
+        unsigned int reserved_2 : 10;       /* [31..22]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_CMP_RC_CFG5;
+
+/* define the union U_WBC_CMP_RC_CFG6 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int noise_sad : 7;    /* [6..0]  */
+        unsigned int reserved_0 : 9;   /* [15..7]  */
+        unsigned int pix_diff_thr : 9; /* [24..16]  */
+        unsigned int reserved_1 : 7;   /* [31..25]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_CMP_RC_CFG6;
+
+/* define the union U_WBC_CMP_RC_CFG7 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int adj_sad_bits_thr : 7; /* [6..0]  */
+        unsigned int reserved_0 : 25;      /* [31..7]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_CMP_RC_CFG7;
+
+/* define the union U_WBC_CMP_RC_CFG8 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int qp_inc1_bits_thr_y : 8; /* [7..0]  */
+        unsigned int qp_inc2_bits_thr_y : 8; /* [15..8]  */
+        unsigned int qp_dec1_bits_thr_y : 8; /* [23..16]  */
+        unsigned int qp_dec2_bits_thr_y : 8; /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_CMP_RC_CFG8;
+
+/* define the union U_WBC_CMP_RC_CFG10 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int est_err_gain : 5;         /* [4..0]  */
+        unsigned int reserved_0 : 11;          /* [15..5]  */
+        unsigned int max_est_err_level : 9;    /* [24..16]  */
+        unsigned int max_vbv_buf_loss_thr : 7; /* [31..25]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_CMP_RC_CFG10;
+
+/* define the union U_WBC_CMP_OUTSIZE0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int frame_size0_reg : 22; /* [21..0]  */
+        unsigned int reserved_0 : 10;      /* [31..22]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_CMP_OUTSIZE0;
+
+/* define the union U_WBC_CMP_MAX_ROW */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int frame_size1_reg : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;      /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_CMP_MAX_ROW;
+
+/* define the union U_WBC_BMP_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int req_interval : 10; /* [9..0]  */
+        unsigned int reserved_0 : 10;   /* [19..10]  */
+        unsigned int ofl_master : 1;    /* [20]  */
+        unsigned int data_width : 1;    /* [21]  */
+        unsigned int reserved_1 : 2;    /* [23..22]  */
+        unsigned int format_out : 4;    /* [27..24]  */
+        unsigned int reserved_2 : 3;    /* [30..28]  */
+        unsigned int wbc_en : 1;        /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_BMP_CTRL;
+
+/* define the union U_WBC_BMP_UPD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int regup : 1;       /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_BMP_UPD;
+
+/* define the union U_WBC_BMP_ORESO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int ow : 12;        /* [11..0]  */
+        unsigned int oh : 12;        /* [23..12]  */
+        unsigned int reserved_0 : 8; /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_BMP_ORESO;
+
+/* define the union U_WBC_BMP_SUM */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int bmp_sum : 25;   /* [24..0]  */
+        unsigned int reserved_0 : 7; /* [31..25]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_BMP_SUM;
+
+/* define the union U_WBC_DHD0_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int p2i_en : 1;         /* [0]  */
+        unsigned int root_path : 2;      /* [2..1]  */
+        unsigned int reserved_0 : 19;    /* [21..3]  */
+        unsigned int mode_out : 2;       /* [23..22]  */
+        unsigned int three_d_mode : 2;   /* [25..24]  */
+        unsigned int auto_stop_en : 1;   /* [26]  */
+        unsigned int wbc_vtthd_mode : 1; /* [27]  */
+        unsigned int rupd_field : 1;     /* [28]  */
+        unsigned int rgup_mode : 1;      /* [29]  */
+        unsigned int nosec_flag : 1;     /* [30]  */
+        unsigned int wbc_en : 1;         /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_DHD0_CTRL;
+
+/* define the union U_WBC_DHD0_UPD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int regup : 1;       /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_DHD0_UPD;
+
+/* define the union U_WBC_DHD0_ORESO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int ow : 16; /* [15..0]  */
+        unsigned int oh : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_DHD0_ORESO;
+
+/* define the union U_WD_HPZME_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hfir_en : 1;     /* [0]  */
+        unsigned int hfir_mode : 2;   /* [2..1]  */
+        unsigned int mid_en : 1;      /* [3]  */
+        unsigned int ck_gt_en : 1;    /* [4]  */
+        unsigned int reserved_0 : 27; /* [31..5]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_HPZME_CTRL;
+
+/* define the union U_WD_HPZMECOEF01 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 10; /* [9..0]  */
+        unsigned int reserved_1 : 6;  /* [15..10]  */
+        unsigned int reserved_2 : 10; /* [25..16]  */
+        unsigned int reserved_3 : 6;  /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_HPZMECOEF01;
+
+/* define the union U_WD_HPZMECOEF23 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 10; /* [9..0]  */
+        unsigned int reserved_1 : 6;  /* [15..10]  */
+        unsigned int reserved_2 : 10; /* [25..16]  */
+        unsigned int reserved_3 : 6;  /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_HPZMECOEF23;
+
+/* define the union U_WD_HPZMECOEF45 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 10; /* [9..0]  */
+        unsigned int reserved_1 : 6;  /* [15..10]  */
+        unsigned int reserved_2 : 10; /* [25..16]  */
+        unsigned int reserved_3 : 6;  /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_HPZMECOEF45;
+
+/* define the union U_WD_HPZMECOEF67 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 10; /* [9..0]  */
+        unsigned int reserved_1 : 6;  /* [15..10]  */
+        unsigned int reserved_2 : 10; /* [25..16]  */
+        unsigned int reserved_3 : 6;  /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_HPZMECOEF67;
+
+/* define the union U_WD_HCDS_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hfir_en : 1;     /* [0]  */
+        unsigned int hfir_mode : 2;   /* [2..1]  */
+        unsigned int mid_en : 1;      /* [3]  */
+        unsigned int ck_gt_en : 1;    /* [4]  */
+        unsigned int reserved_0 : 27; /* [31..5]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_HCDS_CTRL;
+
+/* define the union U_WD_HCDSCOEF01 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int coef0 : 10;     /* [9..0]  */
+        unsigned int reserved_0 : 6; /* [15..10]  */
+        unsigned int coef1 : 10;     /* [25..16]  */
+        unsigned int reserved_1 : 6; /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_HCDSCOEF01;
+
+/* define the union U_WD_HCDSCOEF23 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int coef2 : 10;     /* [9..0]  */
+        unsigned int reserved_0 : 6; /* [15..10]  */
+        unsigned int coef3 : 10;     /* [25..16]  */
+        unsigned int reserved_1 : 6; /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_HCDSCOEF23;
+
+/* define the union U_WD_HCDSCOEF45 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 10; /* [9..0]  */
+        unsigned int reserved_1 : 6;  /* [15..10]  */
+        unsigned int reserved_2 : 10; /* [25..16]  */
+        unsigned int reserved_3 : 6;  /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_HCDSCOEF45;
+
+/* define the union U_WD_HCDSCOEF67 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 10; /* [9..0]  */
+        unsigned int reserved_1 : 6;  /* [15..10]  */
+        unsigned int reserved_2 : 10; /* [25..16]  */
+        unsigned int reserved_3 : 6;  /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_HCDSCOEF67;
+
+/* define the union U_DITHER_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_tap_mode : 2;     /* [1..0]  */
+        unsigned int dither_domain_mode : 1;  /* [2]  */
+        unsigned int dither_round : 1;        /* [3]  */
+        unsigned int dither_mode : 1;         /* [4]  */
+        unsigned int dither_en : 1;           /* [5]  */
+        unsigned int dither_round_unlim : 1;  /* [6]  */
+        unsigned int i_data_width_dither : 3; /* [9..7]  */
+        unsigned int o_data_width_dither : 3; /* [12..10]  */
+        unsigned int reserved_0 : 19;         /* [31..13]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DITHER_CTRL;
+
+/* define the union U_DITHER_SED_Y0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_y0 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DITHER_SED_Y0;
+
+/* define the union U_DITHER_SED_U0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_u0 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DITHER_SED_U0;
+
+/* define the union U_DITHER_SED_V0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_v0 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DITHER_SED_V0;
+
+/* define the union U_DITHER_SED_W0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_w0 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DITHER_SED_W0;
+
+/* define the union U_DITHER_SED_Y1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_y1 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DITHER_SED_Y1;
+
+/* define the union U_DITHER_SED_U1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_u1 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DITHER_SED_U1;
+
+/* define the union U_DITHER_SED_V1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_v1 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DITHER_SED_V1;
+
+/* define the union U_DITHER_SED_W1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_w1 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DITHER_SED_W1;
+
+/* define the union U_DITHER_SED_Y2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_y2 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DITHER_SED_Y2;
+
+/* define the union U_DITHER_SED_U2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_u2 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DITHER_SED_U2;
+
+/* define the union U_DITHER_SED_V2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_v2 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DITHER_SED_V2;
+
+/* define the union U_DITHER_SED_W2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_w2 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DITHER_SED_W2;
+
+/* define the union U_DITHER_SED_Y3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_y3 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DITHER_SED_Y3;
+
+/* define the union U_DITHER_SED_U3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_u3 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DITHER_SED_U3;
+
+/* define the union U_DITHER_SED_V3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_v3 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DITHER_SED_V3;
+
+/* define the union U_DITHER_SED_W3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_w3 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DITHER_SED_W3;
+
+/* define the union U_DITHER_THR */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_thr_min : 16; /* [15..0]  */
+        unsigned int dither_thr_max : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DITHER_THR;
+
+/* define the union U_WD_ZME_HINFO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int out_width : 16;    /* [15..0]  */
+        unsigned int hzme_ck_gt_en : 1; /* [16]  */
+        unsigned int reserved_0 : 15;   /* [31..17]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_ZME_HINFO;
+
+/* define the union U_WD_ZME_HSP */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 24; /* [23..0]  */
+        unsigned int hfir_order : 1;  /* [24]  */
+        unsigned int chfir_mode : 1;  /* [25]  */
+        unsigned int lhfir_mode : 1;  /* [26]  */
+        unsigned int non_lnr_en : 1;  /* [27]  */
+        unsigned int chmid_en : 1;    /* [28]  */
+        unsigned int lhmid_en : 1;    /* [29]  */
+        unsigned int chfir_en : 1;    /* [30]  */
+        unsigned int lhfir_en : 1;    /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_ZME_HSP;
+
+/* define the union U_WD_ZME_HLOFFSET */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int lhfir_offset : 28; /* [27..0]  */
+        unsigned int reserved_0 : 4;    /* [31..28]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_ZME_HLOFFSET;
+
+/* define the union U_WD_ZME_HCOFFSET */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int chfir_offset : 28; /* [27..0]  */
+        unsigned int reserved_0 : 4;    /* [31..28]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_ZME_HCOFFSET;
+
+/* define the union U_WD_ZME_HCOEF_REN */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int apb_vhd_hf_cren : 1; /* [0]  */
+        unsigned int apb_vhd_hf_lren : 1; /* [1]  */
+        unsigned int reserved_0 : 30;     /* [31..2]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_ZME_HCOEF_REN;
+
+/* define the union U_WD_ZME_HCOEF_RDATA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int apb_vhd_hcoef_raddr : 8; /* [7..0]  */
+        unsigned int reserved_0 : 24;         /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_ZME_HCOEF_RDATA;
+
+/* define the union U_WD_ZME_HDRAW */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hdraw_mode : 2;  /* [1..0]  */
+        unsigned int reserved_0 : 30; /* [31..2]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_ZME_HDRAW;
+
+/* define the union U_WD_ZME_HRATIO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hratio : 27;    /* [26..0]  */
+        unsigned int reserved_0 : 5; /* [31..27]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_ZME_HRATIO;
+
+/* define the union U_WD_ZME_VINFO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int out_height : 16;   /* [15..0]  */
+        unsigned int out_fmt : 2;       /* [17..16]  */
+        unsigned int out_pro : 1;       /* [18]  */
+        unsigned int vzme_ck_gt_en : 1; /* [19]  */
+        unsigned int reserved_0 : 12;   /* [31..20]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_ZME_VINFO;
+
+/* define the union U_WD_ZME_VSP */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 16;  /* [15..0]  */
+        unsigned int graphdet_en : 1;  /* [16]  */
+        unsigned int reserved_1 : 8;   /* [24..17]  */
+        unsigned int cvfir_mode : 1;   /* [25]  */
+        unsigned int lvfir_mode : 1;   /* [26]  */
+        unsigned int vfir_1tap_en : 1; /* [27]  */
+        unsigned int cvmid_en : 1;     /* [28]  */
+        unsigned int lvmid_en : 1;     /* [29]  */
+        unsigned int cvfir_en : 1;     /* [30]  */
+        unsigned int lvfir_en : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_ZME_VSP;
+
+/* define the union U_WD_ZME_VOFFSET */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vchroma_offset : 16; /* [15..0]  */
+        unsigned int vluma_offset : 16;   /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_ZME_VOFFSET;
+
+/* define the union U_WD_ZME_VBOFFSET */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vbchroma_offset : 16; /* [15..0]  */
+        unsigned int vbluma_offset : 16;   /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_ZME_VBOFFSET;
+
+/* define the union U_WD_ZME_VCOEF_REN */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int apb_vhd_vf_cren : 1; /* [0]  */
+        unsigned int apb_vhd_vf_lren : 1; /* [1]  */
+        unsigned int reserved_0 : 30;     /* [31..2]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_ZME_VCOEF_REN;
+
+/* define the union U_WD_ZME_VCOEF_RDATA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int apb_vhd_vcoef_raddr : 8; /* [7..0]  */
+        unsigned int reserved_0 : 24;         /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_ZME_VCOEF_RDATA;
+
+/* define the union U_WD_ZME_VDRAW */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vdraw_mode : 2;  /* [1..0]  */
+        unsigned int reserved_0 : 30; /* [31..2]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_ZME_VDRAW;
+
+/* define the union U_WD_ZME_VRATIO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vratio : 19;     /* [18..0]  */
+        unsigned int reserved_0 : 13; /* [31..19]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WD_ZME_VRATIO;
+
+/* define the union U_DHD0_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int regup : 1;          /* [0]  */
+        unsigned int disp_mode : 3;      /* [3..1]  */
+        unsigned int iop : 1;            /* [4]  */
+        unsigned int intf_ivs : 1;       /* [5]  */
+        unsigned int intf_ihs : 1;       /* [6]  */
+        unsigned int intf_idv : 1;       /* [7]  */
+        unsigned int reserved_0 : 1;     /* [8]  */
+        unsigned int hdmi420c_sel : 1;   /* [9]  */
+        unsigned int hdmi420_en : 1;     /* [10]  */
+        unsigned int uf_offline_en : 1;  /* [11]  */
+        unsigned int reserved_1 : 2;     /* [13..12]  */
+        unsigned int hdmi_mode : 1;      /* [14]  */
+        unsigned int twochn_debug : 1;   /* [15]  */
+        unsigned int twochn_en : 1;      /* [16]  */
+        unsigned int reserved_2 : 1;     /* [17]  */
+        unsigned int cbar_mode : 1;      /* [18]  */
+        unsigned int sin_en : 1;         /* [19]  */
+        unsigned int fpga_lmt_width : 7; /* [26..20]  */
+        unsigned int fpga_lmt_en : 1;    /* [27]  */
+        unsigned int p2i_en : 1;         /* [28]  */
+        unsigned int cbar_sel : 1;       /* [29]  */
+        unsigned int cbar_en : 1;        /* [30]  */
+        unsigned int intf_en : 1;        /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_CTRL;
+
+/* define the union U_DHD0_VSYNC1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vact : 16; /* [15..0]  */
+        unsigned int vbb : 16;  /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_VSYNC1;
+
+/* define the union U_DHD0_VSYNC2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vfb : 16;        /* [15..0]  */
+        unsigned int reserved_0 : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_VSYNC2;
+
+/* define the union U_DHD0_HSYNC1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hact : 16; /* [15..0]  */
+        unsigned int hbb : 16;  /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_HSYNC1;
+
+/* define the union U_DHD0_HSYNC2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hfb : 16;  /* [15..0]  */
+        unsigned int hmid : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_HSYNC2;
+
+/* define the union U_DHD0_VPLUS1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int bvact : 16; /* [15..0]  */
+        unsigned int bvbb : 16;  /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_VPLUS1;
+
+/* define the union U_DHD0_VPLUS2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int bvfb : 16;       /* [15..0]  */
+        unsigned int reserved_0 : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_VPLUS2;
+
+/* define the union U_DHD0_PWR */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hpw : 16;        /* [15..0]  */
+        unsigned int vpw : 8;         /* [23..16]  */
+        unsigned int reserved_0 : 3;  /* [26..24]  */
+        unsigned int multichn_en : 2; /* [28..27]  */
+        unsigned int reserved_1 : 3;  /* [31..29]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_PWR;
+
+/* define the union U_DHD0_VTTHD3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vtmgthd3 : 13;  /* [12..0]  */
+        unsigned int reserved_0 : 2; /* [14..13]  */
+        unsigned int thd3_mode : 1;  /* [15]  */
+        unsigned int vtmgthd4 : 13;  /* [28..16]  */
+        unsigned int reserved_1 : 2; /* [30..29]  */
+        unsigned int thd4_mode : 1;  /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_VTTHD3;
+
+/* define the union U_DHD0_VTTHD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vtmgthd1 : 13;  /* [12..0]  */
+        unsigned int reserved_0 : 2; /* [14..13]  */
+        unsigned int thd1_mode : 1;  /* [15]  */
+        unsigned int vtmgthd2 : 13;  /* [28..16]  */
+        unsigned int reserved_1 : 2; /* [30..29]  */
+        unsigned int thd2_mode : 1;  /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_VTTHD;
+
+/* define the union U_DHD0_PARATHD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int para_thd : 8;    /* [7..0]  */
+        unsigned int reserved_0 : 23; /* [30..8]  */
+        unsigned int dfs_en : 1;      /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_PARATHD;
+
+/* define the union U_DHD0_PRECHARGE_THD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int tcon_precharge_thd : 17; /* [16..0]  */
+        unsigned int reserved_0 : 3;          /* [19..17]  */
+        unsigned int vsync_te_mode : 1;       /* [20]  ---- */
+        unsigned int reserved_1 : 11;         /* [31..21]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_PRECHARGE_THD;
+
+/* define the union U_DHD0_START_POS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int start_pos : 8;        /* [7..0]  */
+        unsigned int timing_start_pos : 8; /* [15..8]  */
+        unsigned int fi_start_pos : 4;     /* [19..16]  */
+        unsigned int req_start_pos : 12;   /* [31..20]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_START_POS;
+
+/* define the union U_DHD0_START_POS1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int req_start_pos1 : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;     /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_START_POS1;
+
+/* define the union U_DHD0_PARAUP */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 31; /* [30..0]  */
+        unsigned int paraup_mode : 1; /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_PARAUP;
+
+/* define the union U_DHD0_SYNC_INV */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int lcd_dv_inv : 1;  /* [0]  */
+        unsigned int lcd_hs_inv : 1;  /* [1]  */
+        unsigned int lcd_vs_inv : 1;  /* [2]  */
+        unsigned int reserved_0 : 1;  /* [3]  */
+        unsigned int vga_dv_inv : 1;  /* [4]  */
+        unsigned int vga_hs_inv : 1;  /* [5]  */
+        unsigned int vga_vs_inv : 1;  /* [6]  */
+        unsigned int reserved_1 : 1;  /* [7]  */
+        unsigned int hdmi_dv_inv : 1; /* [8]  */
+        unsigned int hdmi_hs_inv : 1; /* [9]  */
+        unsigned int hdmi_vs_inv : 1; /* [10]  */
+        unsigned int hdmi_f_inv : 1;  /* [11]  */
+        unsigned int date_dv_inv : 1; /* [12]  */
+        unsigned int date_hs_inv : 1; /* [13]  */
+        unsigned int date_vs_inv : 1; /* [14]  */
+        unsigned int date_f_inv : 1;  /* [15]  */
+        unsigned int reserved_2 : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_SYNC_INV;
+
+/* define the union U_DHD0_CLK_DV_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int intf_clk_mux : 1;        /* [0]  */
+        unsigned int intf_dv_mux : 1;         /* [1]  */
+        unsigned int no_active_area_pos : 16; /* [17..2]  */
+        unsigned int reserved_0 : 14;         /* [31..18]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_CLK_DV_CTRL;
+
+/* define the union U_DHD0_RGB_FIX_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int fix_b : 10;      /* [9..0]  */
+        unsigned int fix_g : 10;      /* [19..10]  */
+        unsigned int fix_r : 10;      /* [29..20]  */
+        unsigned int rgb_fix_mux : 1; /* [30]  */
+        unsigned int reserved_0 : 1;  /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_RGB_FIX_CTRL;
+
+/* define the union U_DHD0_LOCKCFG */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int measure_en : 1;     /* [0]  */
+        unsigned int lock_cnt_en : 1;    /* [1]  */
+        unsigned int vdp_measure_en : 1; /* [2]  */
+        unsigned int reserved_0 : 29;    /* [31..3]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_LOCKCFG;
+
+/* define the union U_DHD0_INTF_CHKSUM_HIGH1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int r0_sum_high : 8; /* [7..0]  */
+        unsigned int g0_sum_high : 8; /* [15..8]  */
+        unsigned int b0_sum_high : 8; /* [23..16]  */
+        unsigned int reserved_0 : 8;  /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_INTF_CHKSUM_HIGH1;
+
+/* define the union U_DHD0_INTF_CHKSUM_HIGH2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int r1_sum_high : 8; /* [7..0]  */
+        unsigned int g1_sum_high : 8; /* [15..8]  */
+        unsigned int b1_sum_high : 8; /* [23..16]  */
+        unsigned int reserved_0 : 8;  /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_INTF_CHKSUM_HIGH2;
+
+/* define the union U_DHD0_STATE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vback_blank : 1;  /* [0]  */
+        unsigned int vblank : 1;       /* [1]  */
+        unsigned int bottom_field : 1; /* [2]  */
+        unsigned int vcnt : 13;        /* [15..3]  */
+        unsigned int count_int : 8;    /* [23..16]  */
+        unsigned int dhd_even : 1;     /* [24]  */
+        unsigned int reserved_0 : 7;   /* [31..25]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_STATE;
+
+/* define the union U_DHD0_UF_STATE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int ud_first_cnt : 13; /* [12..0]  */
+        unsigned int reserved_0 : 3;    /* [15..13]  */
+        unsigned int start_pos : 8;     /* [23..16]  */
+        unsigned int reserved_1 : 8;    /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_UF_STATE;
+
+/* define the union U_VO_MUX */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mipi_sel : 4;    /* [3..0]  */
+        unsigned int lcd_sel : 4;     /* [7..4]  */
+        unsigned int bt_sel : 4;      /* [11..8]  */
+        unsigned int reserved_0 : 16; /* [27..12]  */
+        unsigned int digital_sel : 4; /* [31..28]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VO_MUX;
+
+/* define the union U_VO_MUX_SYNC */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int sync_dv : 1;        /* [0]  */
+        unsigned int sync_hsync : 1;     /* [1]  */
+        unsigned int sync_vsync : 1;     /* [2]  */
+        unsigned int sync_field : 1;     /* [3]  */
+        unsigned int reserved_0 : 27;    /* [30..4]  */
+        unsigned int sync_test_mode : 1; /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VO_MUX_SYNC;
+
+/* define the union U_VO_MUX_DATA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vomux_data : 30; /* [29..0]  */
+        unsigned int reserved_0 : 2;  /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VO_MUX_DATA;
+
+/* define the union U_DHD0_VSYNC_TE_STATE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vsync_te_start_sta : 8;  /* [7..0]  */
+        unsigned int vsync_te_start_sta1 : 8; /* [15..8]  */
+        unsigned int vsync_te_end_sta : 8;    /* [23..16]  */
+        unsigned int reserved_0 : 8;          /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_VSYNC_TE_STATE;
+
+/* define the union U_DHD0_VSYNC_TE_STATE1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vsync_te_vfb : 16;   /* [15..0]  */
+        unsigned int vsync_te_width : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD0_VSYNC_TE_STATE1;
+
+/* define the union U_INTF0_DITHER_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_tap_mode : 2;     /* [1..0]  */
+        unsigned int dither_domain_mode : 1;  /* [2]  */
+        unsigned int dither_round : 1;        /* [3]  */
+        unsigned int dither_mode : 1;         /* [4]  */
+        unsigned int dither_en : 1;           /* [5]  */
+        unsigned int dither_round_unlim : 1;  /* [6]  */
+        unsigned int i_data_width_dither : 3; /* [9..7]  */
+        unsigned int o_data_width_dither : 3; /* [12..10]  */
+        unsigned int reserved_0 : 19;         /* [31..13]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF0_DITHER_CTRL;
+
+/* define the union U_INTF0_DITHER_SED_Y0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_y0 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF0_DITHER_SED_Y0;
+
+/* define the union U_INTF0_DITHER_SED_U0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_u0 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF0_DITHER_SED_U0;
+
+/* define the union U_INTF0_DITHER_SED_V0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_v0 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF0_DITHER_SED_V0;
+
+/* define the union U_INTF0_DITHER_SED_W0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_w0 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF0_DITHER_SED_W0;
+
+/* define the union U_INTF0_DITHER_SED_Y1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_y1 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF0_DITHER_SED_Y1;
+
+/* define the union U_INTF0_DITHER_SED_U1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_u1 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF0_DITHER_SED_U1;
+
+/* define the union U_INTF0_DITHER_SED_V1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_v1 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF0_DITHER_SED_V1;
+
+/* define the union U_INTF0_DITHER_SED_W1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_w1 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF0_DITHER_SED_W1;
+
+/* define the union U_INTF0_DITHER_SED_Y2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_y2 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF0_DITHER_SED_Y2;
+
+/* define the union U_INTF0_DITHER_SED_U2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_u2 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF0_DITHER_SED_U2;
+
+/* define the union U_INTF0_DITHER_SED_V2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_v2 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF0_DITHER_SED_V2;
+
+/* define the union U_INTF0_DITHER_SED_W2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_w2 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF0_DITHER_SED_W2;
+
+/* define the union U_INTF0_DITHER_SED_Y3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_y3 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF0_DITHER_SED_Y3;
+
+/* define the union U_INTF0_DITHER_SED_U3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_u3 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF0_DITHER_SED_U3;
+
+/* define the union U_INTF0_DITHER_SED_V3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_v3 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF0_DITHER_SED_V3;
+
+/* define the union U_INTF0_DITHER_SED_W3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_w3 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF0_DITHER_SED_W3;
+
+/* define the union U_INTF0_DITHER_THR */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_thr_min : 16; /* [15..0]  */
+        unsigned int dither_thr_max : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF0_DITHER_THR;
+
+/* define the union U_INTF_HDMI_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int intf_422_en : 1;   /* [0]  */
+        unsigned int intf_420_en : 1;   /* [1]  */
+        unsigned int intf_420_mode : 2; /* [3..2]  */
+        unsigned int hdmi_mode : 2;     /* [5..4]  */
+        unsigned int reserved_0 : 26;   /* [31..6]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF_HDMI_CTRL;
+
+/* define the union U_INTF_HDMI_UPD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int regup : 1;       /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF_HDMI_UPD;
+
+/* define the union U_INTF_HDMI_SYNC_INV */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dv_inv : 1;      /* [0]  */
+        unsigned int hs_inv : 1;      /* [1]  */
+        unsigned int vs_inv : 1;      /* [2]  */
+        unsigned int f_inv : 1;       /* [3]  */
+        unsigned int reserved_0 : 28; /* [31..4]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF_HDMI_SYNC_INV;
+
+/* define the union U_HDMI_INTF_CHKSUM_HIGH */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int r0_sum_high : 8; /* [7..0]  */
+        unsigned int g0_sum_high : 8; /* [15..8]  */
+        unsigned int b0_sum_high : 8; /* [23..16]  */
+        unsigned int reserved_0 : 8;  /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_HDMI_INTF_CHKSUM_HIGH;
+
+/* define the union U_HDMI_INTF1_CHKSUM_HIGH */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int r1_sum_high : 8; /* [7..0]  */
+        unsigned int g1_sum_high : 8; /* [15..8]  */
+        unsigned int b1_sum_high : 8; /* [23..16]  */
+        unsigned int reserved_0 : 8;  /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_HDMI_INTF1_CHKSUM_HIGH;
+
+/* define the union U_HDMI_HFIR_COEF0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hfir_coef0 : 10; /* [9..0]  */
+        unsigned int reserved_0 : 6;  /* [15..10]  */
+        unsigned int hfir_coef1 : 10; /* [25..16]  */
+        unsigned int reserved_1 : 6;  /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_HDMI_HFIR_COEF0;
+
+/* define the union U_HDMI_HFIR_COEF1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hfir_coef2 : 10; /* [9..0]  */
+        unsigned int reserved_0 : 6;  /* [15..10]  */
+        unsigned int hfir_coef3 : 10; /* [25..16]  */
+        unsigned int reserved_1 : 6;  /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_HDMI_HFIR_COEF1;
+
+/* define the union U_HDMI_HFIR_COEF2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hfir_coef4 : 10; /* [9..0]  */
+        unsigned int reserved_0 : 6;  /* [15..10]  */
+        unsigned int hfir_coef5 : 10; /* [25..16]  */
+        unsigned int reserved_1 : 6;  /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_HDMI_HFIR_COEF2;
+
+/* define the union U_HDMI_HFIR_COEF3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hfir_coef6 : 10; /* [9..0]  */
+        unsigned int reserved_0 : 22; /* [31..10]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_HDMI_HFIR_COEF3;
+
+/* define the union U_INTF_MIPI_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int intf_422_en : 1;   /* [0]  */
+        unsigned int intf_420_en : 1;   /* [1]  */
+        unsigned int intf_420_mode : 2; /* [3..2]  */
+        unsigned int reserved_0 : 28;   /* [31..4]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF_MIPI_CTRL;
+
+/* define the union U_INTF_MIPI_UPD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int regup : 1;       /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF_MIPI_UPD;
+
+/* define the union U_INTF_MIPI_SYNC_INV */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dv_inv : 1;      /* [0]  */
+        unsigned int hs_inv : 1;      /* [1]  */
+        unsigned int vs_inv : 1;      /* [2]  */
+        unsigned int f_inv : 1;       /* [3]  */
+        unsigned int reserved_0 : 28; /* [31..4]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF_MIPI_SYNC_INV;
+
+/* define the union U_MIPI_INTF_CHKSUM_HIGH */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int b0_sum_high : 8; /* [7..0]  */
+        unsigned int g0_sum_high : 8; /* [15..8]  */
+        unsigned int r0_sum_high : 8; /* [23..16]  */
+        unsigned int reserved_0 : 8;  /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_MIPI_INTF_CHKSUM_HIGH;
+
+/* define the union U_MIPI_INTF1_CHKSUM_HIGH */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int b1_sum_high : 8; /* [7..0]  */
+        unsigned int g1_sum_high : 8; /* [15..8]  */
+        unsigned int r1_sum_high : 8; /* [23..16]  */
+        unsigned int reserved_0 : 8;  /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_MIPI_INTF1_CHKSUM_HIGH;
+
+/* define the union U_MIPI_HFIR_COEF0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hfir_coef0 : 10; /* [9..0]  */
+        unsigned int reserved_0 : 6;  /* [15..10]  */
+        unsigned int hfir_coef1 : 10; /* [25..16]  */
+        unsigned int reserved_1 : 6;  /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_MIPI_HFIR_COEF0;
+
+/* define the union U_MIPI_HFIR_COEF1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hfir_coef2 : 10; /* [9..0]  */
+        unsigned int reserved_0 : 6;  /* [15..10]  */
+        unsigned int hfir_coef3 : 10; /* [25..16]  */
+        unsigned int reserved_1 : 6;  /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_MIPI_HFIR_COEF1;
+
+/* define the union U_MIPI_HFIR_COEF2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hfir_coef4 : 10; /* [9..0]  */
+        unsigned int reserved_0 : 6;  /* [15..10]  */
+        unsigned int hfir_coef5 : 10; /* [25..16]  */
+        unsigned int reserved_1 : 6;  /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_MIPI_HFIR_COEF2;
+
+/* define the union U_MIPI_HFIR_COEF3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hfir_coef6 : 10; /* [9..0]  */
+        unsigned int reserved_0 : 22; /* [31..10]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_MIPI_HFIR_COEF3;
+
+/* define the union U_INTF_BT_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 23;        /* [22..0]  */
+        unsigned int uv_mode : 1;            /* [23]  ---- */
+        unsigned int yc_mode : 1;            /* [24]  */
+        unsigned int lcd_parallel_mode : 1;  /* [25]  */
+        unsigned int lcd_data_inv : 1;       /* [26]  */
+        unsigned int lcd_parallel_order : 1; /* [27]  */
+        unsigned int lcd_serial_perd : 1;    /* [28]  */
+        unsigned int lcd_serial_mode : 1;    /* [29]  */
+        unsigned int dfir_en : 1;            /* [30]  */
+        unsigned int hdmi_mode : 1;          /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF_BT_CTRL;
+
+/* define the union U_INTF_BT_UPD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int regup : 1;       /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF_BT_UPD;
+
+/* define the union U_INTF_BT_SYNC_INV */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dv_inv : 1;      /* [0]  */
+        unsigned int hs_inv : 1;      /* [1]  */
+        unsigned int vs_inv : 1;      /* [2]  */
+        unsigned int f_inv : 1;       /* [3]  */
+        unsigned int reserved_0 : 28; /* [31..4]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF_BT_SYNC_INV;
+
+/* define the union U_BT_CLIP0_L */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int clip_cl0 : 10;  /* [9..0]  */
+        unsigned int clip_cl1 : 10;  /* [19..10]  */
+        unsigned int clip_cl2 : 10;  /* [29..20]  */
+        unsigned int reserved_0 : 1; /* [30]  */
+        unsigned int clip_en : 1;    /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_BT_CLIP0_L;
+
+/* define the union U_BT_CLIP0_H */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int clip_ch0 : 10;  /* [9..0]  */
+        unsigned int clip_ch1 : 10;  /* [19..10]  */
+        unsigned int clip_ch2 : 10;  /* [29..20]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_BT_CLIP0_H;
+
+/* define the union U_BT_DITHER_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_tap_mode : 2;     /* [1..0]  */
+        unsigned int dither_domain_mode : 1;  /* [2]  */
+        unsigned int dither_round : 1;        /* [3]  */
+        unsigned int dither_mode : 1;         /* [4]  */
+        unsigned int dither_en : 1;           /* [5]  */
+        unsigned int dither_round_unlim : 1;  /* [6]  */
+        unsigned int i_data_width_dither : 3; /* [9..7]  */
+        unsigned int o_data_width_dither : 3; /* [12..10]  */
+        unsigned int reserved_0 : 19;         /* [31..13]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_BT_DITHER_CTRL;
+
+/* define the union U_BT_DITHER_SED_Y0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_y0 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_BT_DITHER_SED_Y0;
+
+/* define the union U_BT_DITHER_SED_U0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_u0 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_BT_DITHER_SED_U0;
+
+/* define the union U_BT_DITHER_SED_V0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_v0 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_BT_DITHER_SED_V0;
+
+/* define the union U_BT_DITHER_SED_W0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_w0 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_BT_DITHER_SED_W0;
+
+/* define the union U_BT_DITHER_SED_Y1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_y1 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_BT_DITHER_SED_Y1;
+
+/* define the union U_BT_DITHER_SED_U1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_u1 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_BT_DITHER_SED_U1;
+
+/* define the union U_BT_DITHER_SED_V1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_v1 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_BT_DITHER_SED_V1;
+
+/* define the union U_BT_DITHER_SED_W1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_w1 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_BT_DITHER_SED_W1;
+
+/* define the union U_BT_DITHER_SED_Y2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_y2 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_BT_DITHER_SED_Y2;
+
+/* define the union U_BT_DITHER_SED_U2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_u2 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_BT_DITHER_SED_U2;
+
+/* define the union U_BT_DITHER_SED_V2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_v2 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_BT_DITHER_SED_V2;
+
+/* define the union U_BT_DITHER_SED_W2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_w2 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_BT_DITHER_SED_W2;
+
+/* define the union U_BT_DITHER_SED_Y3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_y3 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_BT_DITHER_SED_Y3;
+
+/* define the union U_BT_DITHER_SED_U3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_u3 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_BT_DITHER_SED_U3;
+
+/* define the union U_BT_DITHER_SED_V3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_v3 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_BT_DITHER_SED_V3;
+
+/* define the union U_BT_DITHER_SED_W3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_w3 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_BT_DITHER_SED_W3;
+
+/* define the union U_BT_DITHER_THR */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_thr_min : 16; /* [15..0]  */
+        unsigned int dither_thr_max : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_BT_DITHER_THR;
+
+/* define the union U_INTF_LCD_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 24;        /* [23..0]  */
+        unsigned int yc_mode : 1;            /* [24]  */
+        unsigned int lcd_parallel_mode : 1;  /* [25]  */
+        unsigned int lcd_data_inv : 1;       /* [26]  */
+        unsigned int lcd_parallel_order : 1; /* [27]  */
+        unsigned int lcd_serial_perd : 1;    /* [28]  */
+        unsigned int lcd_serial_mode : 1;    /* [29]  */
+        unsigned int dfir_en : 1;            /* [30]  */
+        unsigned int hdmi_mode : 1;          /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF_LCD_CTRL;
+
+/* define the union U_INTF_LCD_UPD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int regup : 1;       /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF_LCD_UPD;
+
+/* define the union U_INTF_LCD_SYNC_INV */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dv_inv : 1;      /* [0]  */
+        unsigned int hs_inv : 1;      /* [1]  */
+        unsigned int vs_inv : 1;      /* [2]  */
+        unsigned int f_inv : 1;       /* [3]  */
+        unsigned int reserved_0 : 28; /* [31..4]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF_LCD_SYNC_INV;
+
+/* define the union U_LCD_DITHER_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_tap_mode : 2;     /* [1..0]  */
+        unsigned int dither_domain_mode : 1;  /* [2]  */
+        unsigned int dither_round : 1;        /* [3]  */
+        unsigned int dither_mode : 1;         /* [4]  */
+        unsigned int dither_en : 1;           /* [5]  */
+        unsigned int dither_round_unlim : 1;  /* [6]  */
+        unsigned int i_data_width_dither : 3; /* [9..7]  */
+        unsigned int o_data_width_dither : 3; /* [12..10]  */
+        unsigned int reserved_0 : 19;         /* [31..13]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_LCD_DITHER_CTRL;
+
+/* define the union U_LCD_DITHER_SED_Y0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_y0 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_LCD_DITHER_SED_Y0;
+
+/* define the union U_LCD_DITHER_SED_U0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_u0 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_LCD_DITHER_SED_U0;
+
+/* define the union U_LCD_DITHER_SED_V0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_v0 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_LCD_DITHER_SED_V0;
+
+/* define the union U_LCD_DITHER_SED_W0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_w0 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_LCD_DITHER_SED_W0;
+
+/* define the union U_LCD_DITHER_SED_Y1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_y1 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_LCD_DITHER_SED_Y1;
+
+/* define the union U_LCD_DITHER_SED_U1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_u1 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_LCD_DITHER_SED_U1;
+
+/* define the union U_LCD_DITHER_SED_V1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_v1 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_LCD_DITHER_SED_V1;
+
+/* define the union U_LCD_DITHER_SED_W1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_w1 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_LCD_DITHER_SED_W1;
+
+/* define the union U_LCD_DITHER_SED_Y2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_y2 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_LCD_DITHER_SED_Y2;
+
+/* define the union U_LCD_DITHER_SED_U2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_u2 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_LCD_DITHER_SED_U2;
+
+/* define the union U_LCD_DITHER_SED_V2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_v2 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_LCD_DITHER_SED_V2;
+
+/* define the union U_LCD_DITHER_SED_W2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_w2 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_LCD_DITHER_SED_W2;
+
+/* define the union U_LCD_DITHER_SED_Y3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_y3 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_LCD_DITHER_SED_Y3;
+
+/* define the union U_LCD_DITHER_SED_U3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_u3 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_LCD_DITHER_SED_U3;
+
+/* define the union U_LCD_DITHER_SED_V3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_v3 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_LCD_DITHER_SED_V3;
+
+/* define the union U_LCD_DITHER_SED_W3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_w3 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_LCD_DITHER_SED_W3;
+
+/* define the union U_LCD_DITHER_THR */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_thr_min : 16; /* [15..0]  */
+        unsigned int dither_thr_max : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_LCD_DITHER_THR;
+
+/* define the union U_DHD1_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int regup : 1;          /* [0]  */
+        unsigned int disp_mode : 3;      /* [3..1]  */
+        unsigned int iop : 1;            /* [4]  */
+        unsigned int intf_ivs : 1;       /* [5]  */
+        unsigned int intf_ihs : 1;       /* [6]  */
+        unsigned int intf_idv : 1;       /* [7]  */
+        unsigned int reserved_0 : 1;     /* [8]  */
+        unsigned int hdmi420c_sel : 1;   /* [9]  */
+        unsigned int hdmi420_en : 1;     /* [10]  */
+        unsigned int uf_offline_en : 1;  /* [11]  */
+        unsigned int reserved_1 : 2;     /* [13..12]  */
+        unsigned int hdmi_mode : 1;      /* [14]  */
+        unsigned int twochn_debug : 1;   /* [15]  */
+        unsigned int twochn_en : 1;      /* [16]  */
+        unsigned int reserved_2 : 1;     /* [17]  */
+        unsigned int cbar_mode : 1;      /* [18]  */
+        unsigned int sin_en : 1;         /* [19]  */
+        unsigned int fpga_lmt_width : 7; /* [26..20]  */
+        unsigned int fpga_lmt_en : 1;    /* [27]  */
+        unsigned int p2i_en : 1;         /* [28]  */
+        unsigned int cbar_sel : 1;       /* [29]  */
+        unsigned int cbar_en : 1;        /* [30]  */
+        unsigned int intf_en : 1;        /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_CTRL;
+
+/* define the union U_DHD1_VSYNC1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vact : 16; /* [15..0]  */
+        unsigned int vbb : 16;  /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_VSYNC1;
+
+/* define the union U_DHD1_VSYNC2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vfb : 16;        /* [15..0]  */
+        unsigned int reserved_0 : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_VSYNC2;
+
+/* define the union U_DHD1_HSYNC1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hact : 16; /* [15..0]  */
+        unsigned int hbb : 16;  /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_HSYNC1;
+
+/* define the union U_DHD1_HSYNC2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hfb : 16;  /* [15..0]  */
+        unsigned int hmid : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_HSYNC2;
+
+/* define the union U_DHD1_VPLUS1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int bvact : 16; /* [15..0]  */
+        unsigned int bvbb : 16;  /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_VPLUS1;
+
+/* define the union U_DHD1_VPLUS2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int bvfb : 16;       /* [15..0]  */
+        unsigned int reserved_0 : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_VPLUS2;
+
+/* define the union U_DHD1_PWR */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hpw : 16;        /* [15..0]  */
+        unsigned int vpw : 8;         /* [23..16]  */
+        unsigned int reserved_0 : 3;  /* [26..24]  */
+        unsigned int multichn_en : 2; /* [28..27]  */
+        unsigned int reserved_1 : 3;  /* [31..29]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_PWR;
+
+/* define the union U_DHD1_VTTHD3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vtmgthd3 : 13;  /* [12..0]  */
+        unsigned int reserved_0 : 2; /* [14..13]  */
+        unsigned int thd3_mode : 1;  /* [15]  */
+        unsigned int vtmgthd4 : 13;  /* [28..16]  */
+        unsigned int reserved_1 : 2; /* [30..29]  */
+        unsigned int thd4_mode : 1;  /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_VTTHD3;
+
+/* define the union U_DHD1_VTTHD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vtmgthd1 : 13;  /* [12..0]  */
+        unsigned int reserved_0 : 2; /* [14..13]  */
+        unsigned int thd1_mode : 1;  /* [15]  */
+        unsigned int vtmgthd2 : 13;  /* [28..16]  */
+        unsigned int reserved_1 : 2; /* [30..29]  */
+        unsigned int thd2_mode : 1;  /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_VTTHD;
+
+/* define the union U_DHD1_PARATHD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int para_thd : 8;    /* [7..0]  */
+        unsigned int reserved_0 : 23; /* [30..8]  */
+        unsigned int dfs_en : 1;      /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_PARATHD;
+
+/* define the union U_DHD1_PRECHARGE_THD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int tcon_precharge_thd : 17; /* [16..0]  */
+        unsigned int reserved_0 : 3;          /* [19..17]  */
+        unsigned int vsync_te_mode : 1;       /* [20]  ---- */
+        unsigned int reserved_1 : 11;         /* [31..21]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_PRECHARGE_THD;
+
+/* define the union U_DHD1_START_POS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int start_pos : 8;        /* [7..0]  */
+        unsigned int timing_start_pos : 8; /* [15..8]  */
+        unsigned int fi_start_pos : 4;     /* [19..16]  */
+        unsigned int req_start_pos : 12;   /* [31..20]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_START_POS;
+
+/* define the union U_DHD1_START_POS1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int req_start_pos1 : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;     /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_START_POS1;
+
+/* define the union U_DHD1_PARAUP */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 31; /* [30..0]  */
+        unsigned int paraup_mode : 1; /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_PARAUP;
+
+/* define the union U_DHD1_SYNC_INV */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int lcd_dv_inv : 1;  /* [0]  */
+        unsigned int lcd_hs_inv : 1;  /* [1]  */
+        unsigned int lcd_vs_inv : 1;  /* [2]  */
+        unsigned int reserved_0 : 1;  /* [3]  */
+        unsigned int vga_dv_inv : 1;  /* [4]  */
+        unsigned int vga_hs_inv : 1;  /* [5]  */
+        unsigned int vga_vs_inv : 1;  /* [6]  */
+        unsigned int reserved_1 : 1;  /* [7]  */
+        unsigned int hdmi_dv_inv : 1; /* [8]  */
+        unsigned int hdmi_hs_inv : 1; /* [9]  */
+        unsigned int hdmi_vs_inv : 1; /* [10]  */
+        unsigned int hdmi_f_inv : 1;  /* [11]  */
+        unsigned int date_dv_inv : 1; /* [12]  */
+        unsigned int date_hs_inv : 1; /* [13]  */
+        unsigned int date_vs_inv : 1; /* [14]  */
+        unsigned int date_f_inv : 1;  /* [15]  */
+        unsigned int reserved_2 : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_SYNC_INV;
+
+/* define the union U_DHD1_CLK_DV_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int intf_clk_mux : 1;        /* [0]  */
+        unsigned int intf_dv_mux : 1;         /* [1]  */
+        unsigned int no_active_area_pos : 16; /* [17..2]  */
+        unsigned int reserved_0 : 14;         /* [31..18]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_CLK_DV_CTRL;
+
+/* define the union U_DHD1_RGB_FIX_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int fix_b : 10;      /* [9..0]  */
+        unsigned int fix_g : 10;      /* [19..10]  */
+        unsigned int fix_r : 10;      /* [29..20]  */
+        unsigned int rgb_fix_mux : 1; /* [30]  */
+        unsigned int reserved_0 : 1;  /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_RGB_FIX_CTRL;
+
+/* define the union U_DHD1_LOCKCFG */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int measure_en : 1;     /* [0]  */
+        unsigned int lock_cnt_en : 1;    /* [1]  */
+        unsigned int vdp_measure_en : 1; /* [2]  */
+        unsigned int reserved_0 : 29;    /* [31..3]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_LOCKCFG;
+
+/* define the union U_DHD1_INTF_CHKSUM_HIGH1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int y0_sum_high : 8; /* [7..0]  */
+        unsigned int g0_sum_high : 8; /* [15..8]  */
+        unsigned int b0_sum_high : 8; /* [23..16]  */
+        unsigned int reserved_0 : 8;  /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_INTF_CHKSUM_HIGH1;
+
+/* define the union U_DHD1_INTF_CHKSUM_HIGH2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int y1_sum_high : 8; /* [7..0]  */
+        unsigned int g1_sum_high : 8; /* [15..8]  */
+        unsigned int b1_sum_high : 8; /* [23..16]  */
+        unsigned int reserved_0 : 8;  /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_INTF_CHKSUM_HIGH2;
+
+/* define the union U_DHD1_STATE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vback_blank : 1;  /* [0]  */
+        unsigned int vblank : 1;       /* [1]  */
+        unsigned int bottom_field : 1; /* [2]  */
+        unsigned int vcnt : 13;        /* [15..3]  */
+        unsigned int count_int : 8;    /* [23..16]  */
+        unsigned int dhd_even : 1;     /* [24]  */
+        unsigned int reserved_0 : 7;   /* [31..25]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_STATE;
+
+/* define the union U_DHD1_UF_STATE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int ud_first_cnt : 13; /* [12..0]  */
+        unsigned int reserved_0 : 3;    /* [15..13]  */
+        unsigned int start_pos : 8;     /* [23..16]  */
+        unsigned int reserved_1 : 8;    /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_UF_STATE;
+
+/* define the union U_DHD1_VSYNC_TE_STATE ---- */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vsync_te_start_sta : 8;  /* [7..0]  */
+        unsigned int vsync_te_start_sta1 : 8; /* [15..8]  */
+        unsigned int vsync_te_end_sta : 8;    /* [23..16]  */
+        unsigned int reserved_0 : 8;          /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_VSYNC_TE_STATE;
+
+/* define the union U_DHD1_VSYNC_TE_STATE1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vsync_te_vfb : 16;   /* [15..0]  */
+        unsigned int vsync_te_width : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_DHD1_VSYNC_TE_STATE1;
+
+/* define the union U_INTF1_DITHER_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_tap_mode : 2;     /* [1..0]  */
+        unsigned int dither_domain_mode : 1;  /* [2]  */
+        unsigned int dither_round : 1;        /* [3]  */
+        unsigned int dither_mode : 1;         /* [4]  */
+        unsigned int dither_en : 1;           /* [5]  */
+        unsigned int dither_round_unlim : 1;  /* [6]  */
+        unsigned int i_data_width_dither : 3; /* [9..7]  */
+        unsigned int o_data_width_dither : 3; /* [12..10]  */
+        unsigned int reserved_0 : 19;         /* [31..13]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF1_DITHER_CTRL;
+
+/* define the union U_INTF1_DITHER_SED_Y0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_y0 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF1_DITHER_SED_Y0;
+
+/* define the union U_INTF1_DITHER_SED_U0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_u0 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF1_DITHER_SED_U0;
+
+/* define the union U_INTF1_DITHER_SED_V0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_v0 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF1_DITHER_SED_V0;
+
+/* define the union U_INTF1_DITHER_SED_W0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_w0 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF1_DITHER_SED_W0;
+
+/* define the union U_INTF1_DITHER_SED_Y1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_y1 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF1_DITHER_SED_Y1;
+
+/* define the union U_INTF1_DITHER_SED_U1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_u1 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF1_DITHER_SED_U1;
+
+/* define the union U_INTF1_DITHER_SED_V1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_v1 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF1_DITHER_SED_V1;
+
+/* define the union U_INTF1_DITHER_SED_W1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_w1 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF1_DITHER_SED_W1;
+
+/* define the union U_INTF1_DITHER_SED_Y2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_y2 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF1_DITHER_SED_Y2;
+
+/* define the union U_INTF1_DITHER_SED_U2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_u2 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF1_DITHER_SED_U2;
+
+/* define the union U_INTF1_DITHER_SED_V2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_v2 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF1_DITHER_SED_V2;
+
+/* define the union U_INTF1_DITHER_SED_W2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_w2 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF1_DITHER_SED_W2;
+
+/* define the union U_INTF1_DITHER_SED_Y3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_y3 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF1_DITHER_SED_Y3;
+
+/* define the union U_INTF1_DITHER_SED_U3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_u3 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF1_DITHER_SED_U3;
+
+/* define the union U_INTF1_DITHER_SED_V3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_v3 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF1_DITHER_SED_V3;
+
+/* define the union U_INTF1_DITHER_SED_W3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_sed_w3 : 31; /* [30..0]  */
+        unsigned int reserved_0 : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF1_DITHER_SED_W3;
+
+/* define the union U_INTF1_DITHER_THR */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dither_thr_min : 16; /* [15..0]  */
+        unsigned int dither_thr_max : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_INTF1_DITHER_THR;
+
+/* define the union U_MAC_OUTSTANDING */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mstr0_routstanding : 4; /* [3..0]  */
+        unsigned int mstr0_woutstanding : 4; /* [7..4]  */
+        unsigned int mstr1_routstanding : 4; /* [11..8]  */
+        unsigned int mstr1_woutstanding : 4; /* [15..12]  */
+        unsigned int mstr2_routstanding : 4; /* [19..16]  */
+        unsigned int mstr2_woutstanding : 4; /* [23..20]  */
+        unsigned int reserved_0 : 8;         /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_MAC_OUTSTANDING;
+
+/* define the union U_MAC_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int split_mode : 4;  /* [3..0]  */
+        unsigned int arb_mode : 4;    /* [7..4]  */
+        unsigned int mid_enable : 1;  /* [8]  */
+        unsigned int reserved_0 : 3;  /* [11..9]  */
+        unsigned int wport_sel : 4;   /* [15..12]  ---- */
+        unsigned int reserved_1 : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_MAC_CTRL;
+
+/* define the union U_MAC_RCHN_PRIO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int para_prio : 1;   /* [0]  */
+        unsigned int v0l_prio : 1;    /* [1]  */
+        unsigned int v0c_prio : 1;    /* [2]  */
+        unsigned int v0lh_prio : 1;   /* [3]  */
+        unsigned int v0ch_prio : 1;   /* [4]  */
+        unsigned int v1l_prio : 1;    /* [5]  */
+        unsigned int v1c_prio : 1;    /* [6]  */
+        unsigned int v1lh_prio : 1;   /* [7]  */
+        unsigned int v1ch_prio : 1;   /* [8]  */
+        unsigned int g0ar_prio : 1;   /* [9]  */
+        unsigned int g0gb_prio : 1;   /* [10]  */
+        unsigned int g1ar_prio : 1;   /* [11]  */
+        unsigned int g1gb_prio : 1;   /* [12]  */
+        unsigned int v2l_prio : 1;    /* [13]  */
+        unsigned int v2c_prio : 1;    /* [14]  */
+        unsigned int v2lh_prio : 1;   /* [15]  */
+        unsigned int v2ch_prio : 1;   /* [16]  */
+        unsigned int g3ar_prio : 1;   /* [17]  */
+        unsigned int g3gb_prio : 1;   /* [18]  */
+        unsigned int reserved_0 : 13; /* [31..19]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_MAC_RCHN_PRIO;
+
+/* define the union U_MAC_WCHN_PRIO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int wbcl_prio : 1;   /* [0]  */
+        unsigned int wbcc_prio : 1;   /* [1]  */
+        unsigned int wbclh_prio : 1;  /* [2]  */
+        unsigned int wbcch_prio : 1;  /* [3]  */
+        unsigned int reserved_0 : 28; /* [31..4]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_MAC_WCHN_PRIO;
+
+/* define the union U_MAC_RCHN_SEL0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int para_sel : 2;   /* [1..0]  */
+        unsigned int v0l_sel : 2;    /* [3..2]  */
+        unsigned int v0c_sel : 2;    /* [5..4]  */
+        unsigned int v0lh_sel : 2;   /* [7..6]  */
+        unsigned int v0ch_sel : 2;   /* [9..8]  */
+        unsigned int v1l_sel : 2;    /* [11..10]  */
+        unsigned int v1c_sel : 2;    /* [13..12]  */
+        unsigned int v1lh_sel : 2;   /* [15..14]  */
+        unsigned int v1ch_sel : 2;   /* [17..16]  */
+        unsigned int g0ar_sel : 2;   /* [19..18]  */
+        unsigned int g0gb_sel : 2;   /* [21..20]  */
+        unsigned int g1ar_sel : 2;   /* [23..22]  */
+        unsigned int g1gb_sel : 2;   /* [25..24]  */
+        unsigned int v2_sel : 2;     /* [27..26]  */
+        unsigned int g3_sel : 2;     /* [29..28]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_MAC_RCHN_SEL0;
+
+/* define the union U_MAC_WCHN_SEL0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int wbcl_sel : 2;    /* [1..0]  */
+        unsigned int wbcc_sel : 2;    /* [3..2]  */
+        unsigned int wbclh_sel : 2;   /* [5..4]  */
+        unsigned int wbcch_sel : 2;   /* [7..6]  */
+        unsigned int reserved_0 : 24; /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_MAC_WCHN_SEL0;
+
+/* define the union U_MAC_BUS_ERR_CLR */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int bus_error_clr : 1; /* [0]  */
+        unsigned int reserved_0 : 31;   /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_MAC_BUS_ERR_CLR;
+
+/* define the union U_MAC_BUS_ERR */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mst0_r_error : 1; /* [0]  */
+        unsigned int mst0_w_error : 1; /* [1]  */
+        unsigned int mst1_r_error : 1; /* [2]  */
+        unsigned int mst1_w_error : 1; /* [3]  */
+        unsigned int mst2_r_error : 1; /* [4]  */
+        unsigned int mst2_w_error : 1; /* [5]  */
+        unsigned int reserved_0 : 26;  /* [31..6]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_MAC_BUS_ERR;
+
+/* define the union U_MAC_DEBUG_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int axi_det_enable : 1; /* [0]  */
+        unsigned int reserved_0 : 3;     /* [3..1]  */
+        unsigned int fifo_det_mode : 4;  /* [7..4]  ---- */
+        unsigned int reserved_1 : 24;    /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_MAC_DEBUG_CTRL;
+
+/* define the union U_MAC_DEBUG_CLR */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int axi_det_clr : 1; /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_MAC_DEBUG_CLR;
+
+/* define the union U_VID_READ_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int chm_rmode : 3;     /* [2..0]  */
+        unsigned int reserved_0 : 1;    /* [3]  */
+        unsigned int lm_rmode : 3;      /* [6..4]  */
+        unsigned int reserved_1 : 1;    /* [7]  */
+        unsigned int chm_draw_mode : 2; /* [9..8]  */
+        unsigned int lm_draw_mode : 2;  /* [11..10]  */
+        unsigned int flip_en : 1;       /* [12]  */
+        unsigned int chm_copy_en : 1;   /* [13]  */
+        unsigned int reserved_2 : 2;    /* [15..14]  */
+        unsigned int mute_en : 1;       /* [16]  */
+        unsigned int mute_req_en : 1;   /* [17]  */
+        unsigned int vicap_mute_en : 1; /* [18]  */
+        unsigned int mrg_enable : 1;    /* [19]  */
+        unsigned int mrg_mute_mode : 1; /* [20]  */
+        unsigned int fdr_ck_gt_en : 1;  /* [21]  ---- */
+        unsigned int reserved_3 : 10;   /* [31..22]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VID_READ_CTRL;
+
+/* define the union U_VID_MAC_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int req_ctrl : 2;    /* [1..0]  */
+        unsigned int req_len : 2;     /* [3..2]  */
+        unsigned int reserved_0 : 4;  /* [7..4]  */
+        unsigned int ofl_master : 1;  /* [8]  */
+        unsigned int reserved_1 : 22; /* [30..9]  */
+        unsigned int pre_rd_en : 1;   /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VID_MAC_CTRL;
+
+/* define the union U_VID_OUT_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int draw_pixel_mode : 3;  /* [2..0]  */
+        unsigned int draw_pixel_en : 1;    /* [3]  */
+        unsigned int uv_order_en : 1;      /* [4]  */
+        unsigned int single_port_mode : 1; /* [5]  */
+        unsigned int testpattern_en : 1;   /* [6]  */
+        unsigned int reserved_0 : 25;      /* [31..7]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VID_OUT_CTRL;
+
+/* define the union U_VID_MUTE_ALPHA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mute_alpha : 8;  /* [7..0]  */
+        unsigned int reserved_0 : 24; /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VID_MUTE_ALPHA;
+
+/* define the union U_VID_MUTE_BK */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mute_cr : 10;   /* [9..0]  */
+        unsigned int mute_cb : 10;   /* [19..10]  */
+        unsigned int mute_y : 10;    /* [29..20]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VID_MUTE_BK;
+
+/* define the union U_VID_SRC_INFO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int data_type : 3;   /* [2..0]  */
+        unsigned int data_fmt : 2;    /* [4..3]  */
+        unsigned int reserved_0 : 3;  /* [7..5]  */
+        unsigned int data_width : 2;  /* [9..8]  */
+        unsigned int reserved_1 : 2;  /* [11..10]  */
+        unsigned int field_type : 1;  /* [12]  */
+        unsigned int reserved_2 : 3;  /* [15..13]  */
+        unsigned int disp_mode : 4;   /* [19..16]  */
+        unsigned int dcmp_en : 1;     /* [20]  */
+        unsigned int reserved_3 : 11; /* [31..21]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VID_SRC_INFO;
+
+/* define the union U_VID_SRC_RESO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int src_w : 16; /* [15..0]  */
+        unsigned int src_h : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VID_SRC_RESO;
+
+/* define the union U_VID_SRC_CROP */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int src_crop_x : 16; /* [15..0]  */
+        unsigned int src_crop_y : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VID_SRC_CROP;
+
+/* define the union U_VID_IN_RESO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int ireso_w : 16; /* [15..0]  */
+        unsigned int ireso_h : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VID_IN_RESO;
+
+/* define the union U_VID_STRIDE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int lm_stride : 16;  /* [15..0]  */
+        unsigned int chm_stride : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VID_STRIDE;
+
+/* define the union U_VID_2BIT_STRIDE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int lm_tile_stride : 16;  /* [15..0]  */
+        unsigned int chm_tile_stride : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VID_2BIT_STRIDE;
+
+/* define the union U_VID_HEAD_STRIDE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int lm_head_stride : 16;  /* [15..0]  */
+        unsigned int chm_head_stride : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VID_HEAD_STRIDE;
+
+/* define the union U_VID_SMMU_BYPASS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int lm_bypass_2d : 1;  /* [0]  */
+        unsigned int chm_bypass_2d : 1; /* [1]  */
+        unsigned int lm_bypass_3d : 1;  /* [2]  */
+        unsigned int chm_bypass_3d : 1; /* [3]  */
+        unsigned int reserved_0 : 28;   /* [31..4]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VID_SMMU_BYPASS;
+
+/* define the union U_VID_TESTPAT_CFG */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int tp_speed : 10;     /* [9..0]  */
+        unsigned int reserved_0 : 2;    /* [11..10]  */
+        unsigned int tp_line_w : 1;     /* [12]  */
+        unsigned int tp_color_mode : 1; /* [13]  */
+        unsigned int reserved_1 : 2;    /* [15..14]  */
+        unsigned int tp_mode : 2;       /* [17..16]  */
+        unsigned int reserved_2 : 14;   /* [31..18]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VID_TESTPAT_CFG;
+
+/* define the union U_VID_TESTPAT_SEED */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int tp_seed : 30;   /* [29..0]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VID_TESTPAT_SEED;
+
+/* define the union U_VID_DCMP_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int c_is_lossless : 1; /* [0]  */
+        unsigned int l_is_lossless : 1; /* [1]  */
+        unsigned int c_cmp_mode : 1;    /* [2]  */
+        unsigned int l_cmp_mode : 1;    /* [3]  */
+        unsigned int c_cmp_rate : 2;    /* [5..4]  */
+        unsigned int l_cmp_rate : 2;    /* [7..6]  */
+        unsigned int mem_mode : 1;      /* [8]  */
+        unsigned int reserved_0 : 23;   /* [31..9]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_VID_DCMP_CTRL;
+
+/* define the union U_ICE_V3R2_SEG_DCMP_GLB_INFO ---- */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int ice_en : 1;      /* [0]  */
+        unsigned int is_lossless : 1; /* [1]  */
+        unsigned int cmp_mode : 1;    /* [2]  */
+        unsigned int reserved_0 : 29; /* [31..3]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_ICE_V3R2_SEG_DCMP_GLB_INFO;
+
+/* define the union U_ICE_V3R2_SEG_DCMP_FRAME_SIZE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int frame_width : 14;  /* [13..0]  */
+        unsigned int reserved_0 : 2;    /* [15..14]  */
+        unsigned int frame_height : 14; /* [29..16]  */
+        unsigned int reserved_1 : 2;    /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_ICE_V3R2_SEG_DCMP_FRAME_SIZE;
+
+/* define the union U_ICE_V3R2_SEG_DCMP_ERROR_STA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dcmp_error : 1;  /* [0]  */
+        unsigned int forgive : 1;     /* [1]  */
+        unsigned int consume : 1;     /* [2]  */
+        unsigned int bs_error : 1;    /* [3]  ---- */
+        unsigned int reserved_0 : 28; /* [31..4]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_ICE_V3R2_SEG_DCMP_ERROR_STA;
+
+/* define the union U_ICE_V3R2_SEG_DCMP_DBG_REG ---- */
+typedef union {
+    /* define the struct bits  */
+    struct {
+        unsigned int dcmp_dbg : 32; /* [31..0]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_ICE_V3R2_SEG_DCMP_DBG_REG;
+/* define the union U_ICE_V3R2_SEG_DCMP_GLB_INFO_CHM */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int ice_en : 1;      /* [0]  */
+        unsigned int is_lossless : 1; /* [1]  */
+        unsigned int cmp_mode : 1;    /* [2]  */
+        unsigned int reserved_0 : 29; /* [31..3]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_ICE_V3R2_SEG_DCMP_GLB_INFO_CHM;
+
+/* define the union U_ICE_V3R2_SEG_DCMP_FRAME_SIZE_CHM */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int frame_width : 14;  /* [13..0]  */
+        unsigned int reserved_0 : 2;    /* [15..14]  */
+        unsigned int frame_height : 14; /* [29..16]  */
+        unsigned int reserved_1 : 2;    /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_ICE_V3R2_SEG_DCMP_FRAME_SIZE_CHM;
+
+/* define the union U_ICE_V3R2_SEG_DCMP_ERROR_STA_CHM */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dcmp_error : 1;  /* [0]  */
+        unsigned int forgive : 1;     /* [1]  */
+        unsigned int consume : 1;     /* [2]  */
+        unsigned int bs_error : 1;    /* [3]  ---- */
+        unsigned int reserved_0 : 28; /* [31..4]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_ICE_V3R2_SEG_DCMP_ERROR_STA_CHM;
+
+/* define the union U_ICE_V3R2_SEG_DCMP_DBG_REG_CHM */
+typedef union {
+    /* define the struct bits  */
+    struct {
+        unsigned int dcmp_dbg : 32; /* [31..0]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_ICE_V3R2_SEG_DCMP_DBG_REG_CHM;
+/* define the union U_GFX_READ_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int read_mode : 2;    /* [1..0]  */
+        unsigned int reserved_0 : 2;   /* [3..2]  */
+        unsigned int draw_mode : 2;    /* [5..4]  */
+        unsigned int reserved_1 : 2;   /* [7..6]  */
+        unsigned int flip_en : 1;      /* [8]  */
+        unsigned int reserved_2 : 1;   /* [9]  */
+        unsigned int mute_en : 1;      /* [10]  */
+        unsigned int mute_req_en : 1;  /* [11]  */
+        unsigned int fdr_ck_gt_en : 1; /* [12]  ---- */
+        unsigned int reserved_3 : 19;  /* [31..13]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_READ_CTRL;
+
+/* define the union U_GFX_MAC_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int req_ctrl : 2;    /* [1..0]  */
+        unsigned int req_len : 2;     /* [3..2]  */
+        unsigned int reserved_0 : 4;  /* [7..4]  */
+        unsigned int ofl_master : 1;  /* [8]  */
+        unsigned int reserved_1 : 23; /* [31..9]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_MAC_CTRL;
+
+/* define the union U_GFX_OUT_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int palpha_range : 1;   /* [0]  */
+        unsigned int palpha_en : 1;      /* [1]  */
+        unsigned int reserved_0 : 2;     /* [3..2]  */
+        unsigned int key_mode : 1;       /* [4]  */
+        unsigned int key_en : 1;         /* [5]  */
+        unsigned int reserved_1 : 2;     /* [7..6]  */
+        unsigned int bitext : 2;         /* [9..8]  */
+        unsigned int premulti_en : 1;    /* [10]  */
+        unsigned int testpattern_en : 1; /* [11]  */
+        unsigned int reserved_2 : 20;    /* [31..12]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_OUT_CTRL;
+
+/* define the union U_GFX_MUTE_ALPHA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mute_alpha : 8;  /* [7..0]  */
+        unsigned int reserved_0 : 24; /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_MUTE_ALPHA;
+
+/* define the union U_GFX_MUTE_BK */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mute_cr : 10;   /* [9..0]  */
+        unsigned int mute_cb : 10;   /* [19..10]  */
+        unsigned int mute_y : 10;    /* [29..20]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_MUTE_BK;
+
+/* define the union U_GFX_SMMU_BYPASS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int smmu_bypass_2d : 1; /* [0]  */
+        unsigned int smmu_bypass_3d : 1; /* [1]  */
+        unsigned int reserved_0 : 30;    /* [31..2]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_SMMU_BYPASS;
+
+/* define the union U_GFX_1555_ALPHA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int alpha_0 : 8;     /* [7..0]  */
+        unsigned int alpha_1 : 8;     /* [15..8]  */
+        unsigned int reserved_0 : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_1555_ALPHA;
+
+/* define the union U_GFX_SRC_INFO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int ifmt : 8;        /* [7..0]  */
+        unsigned int reserved_0 : 8;  /* [15..8]  */
+        unsigned int disp_mode : 4;   /* [19..16]  */
+        unsigned int dcmp_en : 1;     /* [20]  */
+        unsigned int reserved_1 : 11; /* [31..21]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_SRC_INFO;
+
+/* define the union U_GFX_SRC_RESO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int src_w : 16; /* [15..0]  */
+        unsigned int src_h : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_SRC_RESO;
+
+/* define the union U_GFX_SRC_CROP */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int src_crop_x : 16; /* [15..0]  */
+        unsigned int src_crop_y : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_SRC_CROP;
+
+/* define the union U_GFX_IRESO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int ireso_w : 16; /* [15..0]  */
+        unsigned int ireso_h : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_IRESO;
+
+/* define the union U_GFX_STRIDE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int surface_stride : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;     /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_STRIDE;
+
+/* define the union U_GFX_CKEY_MAX */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int key_max : 8;  /* [7..0]  */
+        unsigned int key_g_max : 8;  /* [15..8]  */
+        unsigned int key_r_max : 8;  /* [23..16]  */
+        unsigned int reserved_0 : 8; /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_CKEY_MAX;
+
+/* define the union U_GFX_CKEY_MIN */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int key_min : 8;  /* [7..0]  */
+        unsigned int key_g_min : 8;  /* [15..8]  */
+        unsigned int key_r_min : 8;  /* [23..16]  */
+        unsigned int reserved_0 : 8; /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_CKEY_MIN;
+
+/* define the union U_GFX_CKEY_MASK */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int key_msk : 8;  /* [7..0]  */
+        unsigned int key_g_msk : 8;  /* [15..8]  */
+        unsigned int key_r_msk : 8;  /* [23..16]  */
+        unsigned int reserved_0 : 8; /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_CKEY_MASK;
+
+/* define the union U_GFX_TESTPAT_CFG */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int tp_speed : 10;     /* [9..0]  */
+        unsigned int reserved_0 : 2;    /* [11..10]  */
+        unsigned int tp_line_w : 1;     /* [12]  */
+        unsigned int tp_color_mode : 1; /* [13]  */
+        unsigned int reserved_1 : 2;    /* [15..14]  */
+        unsigned int tp_mode : 2;       /* [17..16]  */
+        unsigned int reserved_2 : 14;   /* [31..18]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_TESTPAT_CFG;
+
+/* define the union U_GFX_TESTPAT_SEED */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int tp_seed : 30;   /* [29..0]  */
+        unsigned int reserved_0 : 2; /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_TESTPAT_SEED;
+
+/* define the union U_GFX_DCMP_FRAMESIZE0 */
+typedef union {
+    /* define the struct bits  */
+    struct {
+        unsigned int frame_size0 : 32; /* [31..0]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_DCMP_FRAMESIZE0;
+/* define the union U_GFX_DCMP_FRAMESIZE1 */
+typedef union {
+    /* define the struct bits  */
+    struct {
+        unsigned int frame_size1 : 32; /* [31..0]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_DCMP_FRAMESIZE1;
+/* define the union U_GFX_CUR_FLOW */
+typedef union {
+    /* define the struct bits  */
+    struct {
+        unsigned int gfx_cur_flow : 32; /* [31..0]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_CUR_FLOW;
+/* define the union U_GFX_CUR_SREQ_TIME */
+typedef union {
+    /* define the struct bits  */
+    struct {
+        unsigned int gfx_cur_sreq_time : 32; /* [31..0]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_CUR_SREQ_TIME;
+/* define the union U_GFX_LAST_FLOW */
+typedef union {
+    /* define the struct bits  */
+    struct {
+        unsigned int gfx_last_flow : 32; /* [31..0]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_LAST_FLOW;
+/* define the union U_GFX_LAST_SREQ_TIME */
+typedef union {
+    /* define the struct bits  */
+    struct {
+        unsigned int gfx_last_sreq_time : 32; /* [31..0]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_LAST_SREQ_TIME;
+/* define the union U_GFX_BUSY_TIME */
+typedef union {
+    /* define the struct bits  */
+    struct {
+        unsigned int gfx_busy_time : 32; /* [31..0]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_BUSY_TIME;
+/* define the union U_GFX_AR_NEEDNORDY_TIME */
+typedef union {
+    /* define the struct bits  */
+    struct {
+        unsigned int ar_neednordy_time : 32; /* [31..0]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_AR_NEEDNORDY_TIME;
+/* define the union U_GFX_GB_NEEDNORDY_TIME */
+typedef union {
+    /* define the struct bits  */
+    struct {
+        unsigned int gb_neednordy_time : 32; /* [31..0]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_GB_NEEDNORDY_TIME;
+/* define the union U_GFX_DCMP_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int is_lossless : 1;   /* [0]  */
+        unsigned int is_lossless_a : 1; /* [1]  */
+        unsigned int cmp_mode : 1;      /* [2]  */
+        unsigned int osd_mode : 2;      /* [4..3]  */
+        unsigned int reserved_0 : 27;   /* [31..5]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_DCMP_CTRL;
+
+/* define the union U_GFX_DCMP_WRONG_STA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int bs_err : 1;      /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_DCMP_WRONG_STA;
+
+/* define the union U_WBC_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 4;  /* [3..0]  */
+        unsigned int data_width : 1;  /* [4]  */
+        unsigned int reserved_1 : 3;  /* [7..5]  */
+        unsigned int uv_order : 1;    /* [8]  */
+        unsigned int flip_en : 1;     /* [9]  */
+        unsigned int align_mode : 1;  /* [10]  */
+        unsigned int reserved_2 : 18; /* [28..11]  */
+        unsigned int wbc_cmp_en : 1;  /* [29]  */
+        unsigned int reserved_3 : 2;  /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_CTRL;
+
+/* define the union U_WBC_MAC_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int req_interval : 10; /* [9..0]  */
+        unsigned int reserved_0 : 2;    /* [11..10]  */
+        unsigned int wbc_len : 2;       /* [13..12]  */
+        unsigned int reserved_1 : 18;   /* [31..14]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_MAC_CTRL;
+
+/* define the union U_WBC_SMMU_BYPASS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int l_bypass : 1;    /* [0]  */
+        unsigned int c_bypass : 1;    /* [1]  */
+        unsigned int reserved_0 : 30; /* [31..2]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_SMMU_BYPASS;
+
+/* define the union U_WBC_LOWDLYCTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int wb_per_line_num : 12;  /* [11..0]  */
+        unsigned int partfns_line_num : 12; /* [23..12]  */
+        unsigned int reserved_0 : 6;        /* [29..24]  */
+        unsigned int lowdly_test : 1;       /* [30]  */
+        unsigned int lowdly_en : 1;         /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_LOWDLYCTRL;
+
+/* define the union U_WBC_LOWDLYSTA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 31; /* [30..0]  */
+        unsigned int part_finish : 1; /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_LOWDLYSTA;
+
+/* define the union U_WBC_YSTRIDE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int wbc_ystride : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;  /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_YSTRIDE;
+
+/* define the union U_WBC_CSTRIDE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int wbc_cstride : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;  /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_CSTRIDE;
+
+/* define the union U_WBC_YNSTRIDE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int wbc_ynstride : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;   /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_YNSTRIDE;
+
+/* define the union U_WBC_CNSTRIDE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int wbc_cnstride : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;   /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_CNSTRIDE;
+
+/* define the union U_WBC_STA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int wbc_l_busy : 1;  /* [0]  */
+        unsigned int wbc_c_busy : 1;  /* [1]  */
+        unsigned int wbc_lh_busy : 1; /* [2]  */
+        unsigned int wbc_ch_busy : 1; /* [3]  */
+        unsigned int reserved_0 : 28; /* [31..4]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_STA;
+
+/* define the union U_WBC_LINE_NUM */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int wbc_l_linenum : 16; /* [15..0]  */
+        unsigned int wbc_c_linenum : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_LINE_NUM;
+
+/* define the union U_WBC_CAP_RESO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int cap_width : 16;  /* [15..0]  */
+        unsigned int cap_height : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_CAP_RESO;
+
+/* define the union U_ICE_V2R1_SEG_256X1_CMP_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int ice_en : 1;               /* [0]  */
+        unsigned int cmp_mode : 1;             /* [1]  */
+        unsigned int is_lossless : 1;          /* [2]  */
+        unsigned int chroma_en : 1;            /* [3]  */
+        unsigned int tile_en : 1;              /* [4]  */
+        unsigned int reserved_0 : 1;           /* [5]  */
+        unsigned int bitdepth : 1;             /* [6]  */
+        unsigned int reserved_1 : 1;           /* [7]  */
+        unsigned int fix_k : 3;                /* [10..8]  */
+        unsigned int reserved_2 : 1;           /* [11]  */
+        unsigned int max_qp : 3;               /* [14..12]  */
+        unsigned int rc_qp_offset : 1;         /* [15]  */
+        unsigned int mb_mode_sel_grad_thr : 8; /* [23..16]  */
+        unsigned int tile_height : 5;          /* [28..24]  */
+        unsigned int reserved_3 : 3;           /* [31..29]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_ICE_V2R1_SEG_256X1_CMP_CTRL;
+
+/* define the union U_ICE_V2R1_SEG_256X1_CMP_SAD_THR */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int grad_ave_thr0 : 8; /* [7..0]  */
+        unsigned int grad_ave_thr1 : 8; /* [15..8]  */
+        unsigned int grad_ave_thr2 : 8; /* [23..16]  */
+        unsigned int reserved_0 : 8;    /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_ICE_V2R1_SEG_256X1_CMP_SAD_THR;
+
+/* define the union U_ICE_V2R1_SEG_256X1_CMP_SIM_THR */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int simi_fct_thr0 : 8; /* [7..0]  */
+        unsigned int simi_fct_thr1 : 8; /* [15..8]  */
+        unsigned int simi_fct_thr2 : 8; /* [23..16]  */
+        unsigned int reserved_0 : 8;    /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_ICE_V2R1_SEG_256X1_CMP_SIM_THR;
+
+/* define the union U_ICE_V2R1_SEG_256X1_CMP_RESO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int frame_width : 14;  /* [13..0]  */
+        unsigned int reserved_0 : 2;    /* [15..14]  */
+        unsigned int frame_height : 14; /* [29..16]  */
+        unsigned int reserved_1 : 2;    /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_ICE_V2R1_SEG_256X1_CMP_RESO;
+
+/* define the union U_ICE_V2R1_SEG_256X1_CMP_MAX_BIT */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int seg_cfg_max_bit : 12; /* [11..0]  */
+        unsigned int reserved_0 : 4;       /* [15..12]  */
+        unsigned int seg_cfg_tar_bit : 12; /* [27..16]  */
+        unsigned int reserved_1 : 4;       /* [31..28]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_ICE_V2R1_SEG_256X1_CMP_MAX_BIT;
+
+/* define the union U_ICE_V2R1_SEG_256X1_CMP_SLC_BIT */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int slc_cfg_tar_bit : 28; /* [27..0]  */
+        unsigned int reserved_0 : 4;       /* [31..28]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_ICE_V2R1_SEG_256X1_CMP_SLC_BIT;
+
+/* define the union U_ICE_V2R1_SEG_256X1_CMP_CTRL_CHM */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int ice_en : 1;               /* [0]  */
+        unsigned int cmp_mode : 1;             /* [1]  */
+        unsigned int is_lossless : 1;          /* [2]  */
+        unsigned int chroma_en : 1;            /* [3]  */
+        unsigned int tile_en : 1;              /* [4]  */
+        unsigned int reserved_0 : 1;           /* [5]  */
+        unsigned int bitdepth : 1;             /* [6]  */
+        unsigned int reserved_1 : 1;           /* [7]  */
+        unsigned int fix_k : 3;                /* [10..8]  */
+        unsigned int reserved_2 : 1;           /* [11]  */
+        unsigned int max_qp : 3;               /* [14..12]  */
+        unsigned int rc_qp_offset : 1;         /* [15]  */
+        unsigned int mb_mode_sel_grad_thr : 8; /* [23..16]  */
+        unsigned int tile_height : 5;          /* [28..24]  */
+        unsigned int reserved_3 : 3;           /* [31..29]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_ICE_V2R1_SEG_256X1_CMP_CTRL_CHM;
+
+/* define the union U_ICE_V2R1_SEG_256X1_CMP_SAD_THR_CHM */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int grad_ave_thr0 : 8; /* [7..0]  */
+        unsigned int grad_ave_thr1 : 8; /* [15..8]  */
+        unsigned int grad_ave_thr2 : 8; /* [23..16]  */
+        unsigned int reserved_0 : 8;    /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_ICE_V2R1_SEG_256X1_CMP_SAD_THR_CHM;
+
+/* define the union U_ICE_V2R1_SEG_256X1_CMP_SIM_THR_CHM */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int simi_fct_thr0 : 8; /* [7..0]  */
+        unsigned int simi_fct_thr1 : 8; /* [15..8]  */
+        unsigned int simi_fct_thr2 : 8; /* [23..16]  */
+        unsigned int reserved_0 : 8;    /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_ICE_V2R1_SEG_256X1_CMP_SIM_THR_CHM;
+
+/* define the union U_ICE_V2R1_SEG_256X1_CMP_RESO_CHM */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int frame_width : 14;  /* [13..0]  */
+        unsigned int reserved_0 : 2;    /* [15..14]  */
+        unsigned int frame_height : 14; /* [29..16]  */
+        unsigned int reserved_1 : 2;    /* [31..30]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_ICE_V2R1_SEG_256X1_CMP_RESO_CHM;
+
+/* define the union U_ICE_V2R1_SEG_256X1_CMP_MAX_BIT_CHM */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int seg_cfg_max_bit : 12; /* [11..0]  */
+        unsigned int reserved_0 : 4;       /* [15..12]  */
+        unsigned int seg_cfg_tar_bit : 12; /* [27..16]  */
+        unsigned int reserved_1 : 4;       /* [31..28]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_ICE_V2R1_SEG_256X1_CMP_MAX_BIT_CHM;
+
+/* define the union U_ICE_V2R1_SEG_256X1_CMP_SLC_BIT_CHM */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int slc_cfg_tar_bit : 28; /* [27..0]  */
+        unsigned int reserved_0 : 4;       /* [31..28]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_ICE_V2R1_SEG_256X1_CMP_SLC_BIT_CHM;
+
+/* define the union U_WBC_CMP_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int req_interval : 10; /* [9..0]  */
+        unsigned int reserved_0 : 17;   /* [26..10]  */
+        unsigned int mem_mode : 1;      /* [27]  */
+        unsigned int data_width : 1;    /* [28]  */
+        unsigned int reserved_1 : 1;    /* [29]  */
+        unsigned int l_cmp_en : 1;      /* [30]  */
+        unsigned int wbc_en : 1;        /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_CMP_CTRL;
+
+/* define the union U_WBC_CMP_UPD */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int regup : 1;       /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_CMP_UPD;
+
+/* define the union U_WBC_CMP_HEIGHT */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int c_max_height : 13; /* [12..0]  */
+        unsigned int l_max_height : 13; /* [25..13]  */
+        unsigned int addr_mode : 1;     /* [26]  */
+        unsigned int fsize_mode : 1;    /* [27]  */
+        unsigned int rgb_cmp_mode : 2;  /* [29..28]  */
+        unsigned int pause_mode : 1;    /* [30]  */
+        unsigned int buffer_mode : 1;   /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_CMP_HEIGHT;
+
+/* define the union U_WBC_CMP_ORESO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int ow : 12;        /* [11..0]  */
+        unsigned int oh : 12;        /* [23..12]  */
+        unsigned int reserved_0 : 8; /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_CMP_ORESO;
+
+/* define the union U_WBC_OD_STATE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int addr_err : 1;      /* [0]  */
+        unsigned int he_addr_err0 : 1;  /* [1]  */
+        unsigned int he_addr_err1 : 1;  /* [2]  */
+        unsigned int he_addr_err2 : 1;  /* [3]  */
+        unsigned int w_addr_err : 1;    /* [4]  */
+        unsigned int he_fsize_err0 : 1; /* [5]  */
+        unsigned int he_fsize_err1 : 1; /* [6]  */
+        unsigned int he_fsize_err2 : 1; /* [7]  */
+        unsigned int w_fsize_err : 1;   /* [8]  */
+        unsigned int he_fsize_war0 : 1; /* [9]  */
+        unsigned int he_fsize_war1 : 1; /* [10]  */
+        unsigned int he_fsize_war2 : 1; /* [11]  */
+        unsigned int w_fsize_war : 1;   /* [12]  */
+        unsigned int reserved_0 : 19;   /* [31..13]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_WBC_OD_STATE;
+
+/* define the union U_OD_PIC_OSD_GLB_INFO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int is_lossless : 1;   /* [0]  */
+        unsigned int is_lossless_a : 1; /* [1]  */
+        unsigned int cmp_mode : 1;      /* [2]  */
+        unsigned int source_mode : 3;   /* [5..3]  */
+        unsigned int part_cmp_en : 1;   /* [6]  */
+        unsigned int top_pred_en : 1;   /* [7]  */
+        unsigned int graphic_en : 1;    /* [8]  */
+        unsigned int reserved_0 : 23;   /* [31..9]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_GLB_INFO;
+
+/* define the union U_OD_PIC_OSD_FRAME_SIZE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int frame_width : 13;  /* [12..0]  */
+        unsigned int reserved_0 : 3;    /* [15..13]  */
+        unsigned int frame_height : 13; /* [28..16]  */
+        unsigned int reserved_1 : 3;    /* [31..29]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_FRAME_SIZE;
+
+/* define the union U_OD_PIC_OSD_RC_CFG0 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mb_bits : 10;     /* [9..0]  */
+        unsigned int reserved_0 : 6;   /* [15..10]  */
+        unsigned int min_mb_bits : 10; /* [25..16]  */
+        unsigned int reserved_1 : 6;   /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_RC_CFG0;
+
+/* define the union U_OD_PIC_OSD_RC_CFG1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int max_qp : 4;        /* [3..0]  */
+        unsigned int reserved_0 : 4;    /* [7..4]  */
+        unsigned int sad_bits_gain : 4; /* [11..8]  */
+        unsigned int reserved_1 : 4;    /* [15..12]  */
+        unsigned int rc_smth_ngain : 3; /* [18..16]  */
+        unsigned int reserved_2 : 5;    /* [23..19]  */
+        unsigned int max_trow_bits : 8; /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_RC_CFG1;
+
+/* define the union U_OD_PIC_OSD_RC_CFG2 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int max_sad_thr : 7; /* [6..0]  */
+        unsigned int reserved_0 : 9;  /* [15..7]  */
+        unsigned int min_sad_thr : 7; /* [22..16]  */
+        unsigned int reserved_1 : 9;  /* [31..23]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_RC_CFG2;
+
+/* define the union U_OD_PIC_OSD_RC_CFG3 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int smth_thr : 7;      /* [6..0]  */
+        unsigned int reserved_0 : 1;    /* [7]  */
+        unsigned int still_thr : 7;     /* [14..8]  */
+        unsigned int reserved_1 : 1;    /* [15]  */
+        unsigned int big_grad_thr : 10; /* [25..16]  */
+        unsigned int reserved_2 : 6;    /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_RC_CFG3;
+
+/* define the union U_OD_PIC_OSD_RC_CFG4 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int smth_pix_num_thr : 6;  /* [5..0]  */
+        unsigned int reserved_0 : 2;        /* [7..6]  */
+        unsigned int still_pix_num_thr : 6; /* [13..8]  */
+        unsigned int reserved_1 : 2;        /* [15..14]  */
+        unsigned int noise_pix_num_thr : 6; /* [21..16]  */
+        unsigned int reserved_2 : 10;       /* [31..22]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_RC_CFG4;
+
+/* define the union U_OD_PIC_OSD_RC_CFG5 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int noise_sad : 7;     /* [6..0]  */
+        unsigned int reserved_0 : 9;    /* [15..7]  */
+        unsigned int pix_diff_thr : 10; /* [25..16]  */
+        unsigned int reserved_1 : 6;    /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_RC_CFG5;
+
+/* define the union U_OD_PIC_OSD_RC_CFG6 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int adj_sad_bits_thr : 7; /* [6..0]  */
+        unsigned int reserved_0 : 25;      /* [31..7]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_RC_CFG6;
+
+/* define the union U_OD_PIC_OSD_RC_CFG7 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int qp_inc1_bits_thr : 8; /* [7..0]  */
+        unsigned int qp_inc2_bits_thr : 8; /* [15..8]  */
+        unsigned int qp_dec1_bits_thr : 8; /* [23..16]  */
+        unsigned int qp_dec2_bits_thr : 8; /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_RC_CFG7;
+
+/* define the union U_OD_PIC_OSD_RC_CFG8 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int est_err_gain : 5;      /* [4..0]  */
+        unsigned int reserved_0 : 11;       /* [15..5]  */
+        unsigned int max_est_err_level : 9; /* [24..16]  */
+        unsigned int reserved_1 : 7;        /* [31..25]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_RC_CFG8;
+
+/* define the union U_OD_PIC_OSD_RC_CFG9 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 16;       /* [15..0]  */
+        unsigned int vbv_buf_loss1_thr : 7; /* [22..16]  */
+        unsigned int reserved_1 : 1;        /* [23]  */
+        unsigned int vbv_buf_loss2_thr : 7; /* [30..24]  */
+        unsigned int reserved_2 : 1;        /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_RC_CFG9;
+
+/* define the union U_OD_PIC_OSD_RC_CFG10 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int qp_thr0 : 3;     /* [2..0]  */
+        unsigned int reserved_0 : 5;  /* [7..3]  */
+        unsigned int qp_thr1 : 3;     /* [10..8]  */
+        unsigned int reserved_1 : 5;  /* [15..11]  */
+        unsigned int qp_thr2 : 3;     /* [18..16]  */
+        unsigned int reserved_2 : 13; /* [31..19]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_RC_CFG10;
+
+/* define the union U_OD_PIC_OSD_RC_CFG11 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int grph_bias_bit_thr0 : 8;  /* [7..0]  */
+        unsigned int grph_bias_bit_thr1 : 8;  /* [15..8]  */
+        unsigned int grph_ideal_bit_thr : 10; /* [25..16]  */
+        unsigned int reserved_0 : 6;          /* [31..26]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_RC_CFG11;
+
+/* define the union U_OD_PIC_OSD_RC_CFG12 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int force_rc_en : 1;           /* [0]  */
+        unsigned int reserved_0 : 7;            /* [7..1]  */
+        unsigned int forcerc_bits_diff_thr : 8; /* [15..8]  */
+        unsigned int reserved_1 : 16;           /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_RC_CFG12;
+
+/* define the union U_OD_PIC_OSD_RC_CFG13 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int maxdiff_ctrl_en : 1; /* [0]  */
+        unsigned int reserved_0 : 31;     /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_RC_CFG13;
+
+/* define the union U_OD_PIC_OSD_RC_CFG14 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mb_bits_cap : 10;       /* [9..0]  */
+        unsigned int reserved_0 : 6;         /* [15..10]  */
+        unsigned int init_buf_bits_cap : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_RC_CFG14;
+
+/* define the union U_OD_PIC_OSD_RC_CFG15 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int lfw_mb_len : 7;    /* [6..0]  */
+        unsigned int reserved_0 : 1;    /* [7]  */
+        unsigned int cmplx_sad_thr : 4; /* [11..8]  */
+        unsigned int reserved_1 : 4;    /* [15..12]  */
+        unsigned int err_thr0 : 4;      /* [19..16]  */
+        unsigned int reserved_2 : 4;    /* [23..20]  */
+        unsigned int err_thr1 : 4;      /* [27..24]  */
+        unsigned int reserved_3 : 4;    /* [31..28]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_RC_CFG15;
+
+/* define the union U_OD_PIC_OSD_RC_CFG16 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int sim_num_thr : 3;   /* [2..0]  */
+        unsigned int reserved_0 : 5;    /* [7..3]  */
+        unsigned int sum_y_err_thr : 7; /* [14..8]  */
+        unsigned int reserved_1 : 1;    /* [15]  */
+        unsigned int sum_c_err_thr : 7; /* [22..16]  */
+        unsigned int reserved_2 : 9;    /* [31..23]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_RC_CFG16;
+
+/* define the union U_OD_PIC_OSD_RC_CFG17 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int cpmlx_sad_thr_y : 4;   /* [3..0]  */
+        unsigned int reserved_0 : 4;        /* [7..4]  */
+        unsigned int smpl_sad_thr_c : 4;    /* [11..8]  */
+        unsigned int reserved_1 : 4;        /* [15..12]  */
+        unsigned int smpl_sumsad_thr_y : 8; /* [23..16]  */
+        unsigned int smpl_sumsad_thr_c : 8; /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_RC_CFG17;
+
+/* define the union U_OD_PIC_OSD_RC_CFG18 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int future_sad_y_thr0 : 4; /* [3..0]  */
+        unsigned int reserved_0 : 4;        /* [7..4]  */
+        unsigned int future_sad_c_thr0 : 4; /* [11..8]  */
+        unsigned int reserved_1 : 4;        /* [15..12]  */
+        unsigned int future_sad_y_thr1 : 4; /* [19..16]  */
+        unsigned int reserved_2 : 4;        /* [23..20]  */
+        unsigned int future_sad_c_thr1 : 4; /* [27..24]  */
+        unsigned int reserved_3 : 4;        /* [31..28]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_RC_CFG18;
+
+/* define the union U_OD_PIC_OSD_RC_CFG19 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int cmplx_sumsad_thr_y : 8; /* [7..0]  */
+        unsigned int cmplx_sumsad_thr_c : 8; /* [15..8]  */
+        unsigned int reserved_0 : 16;        /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_RC_CFG19;
+
+/* define the union U_OD_PIC_OSD_STAT_THR */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int max_gap_bw_row_len_thr : 7; /* [6..0]  */
+        unsigned int reserved_0 : 25;            /* [31..7]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_STAT_THR;
+
+/* define the union U_OD_PIC_OSD_PCMP */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int pcmp_start_hpos : 13; /* [12..0]  */
+        unsigned int reserved_0 : 3;       /* [15..13]  */
+        unsigned int pcmp_end_hpos : 13;   /* [28..16]  */
+        unsigned int reserved_1 : 3;       /* [31..29]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_PCMP;
+
+/* define the union U_OD_PIC_OSD_BS_SIZE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int frame_size_reg : 22; /* [21..0]  */
+        unsigned int reserved_0 : 10;     /* [31..22]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_BS_SIZE;
+
+/* define the union U_OD_PIC_OSD_WORST_ROW */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int max_frm_row_len : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;      /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_WORST_ROW;
+
+/* define the union U_OD_PIC_OSD_BEST_ROW */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int min_frm_row_len : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;      /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_BEST_ROW;
+
+/* define the union U_OD_PIC_OSD_STAT_INFO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int max_gap_bw_row_len_cnt : 16; /* [15..0]  */
+        unsigned int reserved_0 : 16;             /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_OD_PIC_OSD_STAT_INFO;
+
+/* define the union U_V0_MRG_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 20;  /* [19..0]  */
+        unsigned int mrg_edge_en : 1;  /* [20]  */
+        unsigned int reserved_1 : 4;   /* [24..21]  */
+        unsigned int mrg_edge_typ : 1; /* [25]  */
+        unsigned int reserved_2 : 2;   /* [27..26]  */
+        unsigned int mrg_crop_en : 1;  /* [28]  */
+        unsigned int mrg_dcmp_en : 1;  /* [29]  ---- */
+        unsigned int mrg_mute_en : 1;  /* [30]  */
+        unsigned int mrg_en : 1;       /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_MRG_CTRL;
+
+/* define the union U_V0_MRG_DISP_POS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mrg_xpos : 16; /* [15..0]  */
+        unsigned int mrg_ypos : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_MRG_DISP_POS;
+
+/* define the union U_V0_MRG_DISP_RESO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mrg_width : 16;  /* [15..0]  */
+        unsigned int mrg_height : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_MRG_DISP_RESO;
+
+/* define the union U_V0_MRG_SRC_RESO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mrg_src_width : 16;  /* [15..0]  */
+        unsigned int mrg_src_height : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_MRG_SRC_RESO;
+
+/* define the union U_V0_MRG_SRC_OFFSET */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mrg_src_hoffset : 16; /* [15..0]  */
+        unsigned int mrg_src_voffset : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_MRG_SRC_OFFSET;
+
+/* define the union U_V0_MRG_STRIDE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mrg_c_stride : 16; /* [15..0]  */
+        unsigned int mrg_y_stride : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_MRG_STRIDE;
+
+/* define the union U_V0_MRG_HSTRIDE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mrg_ch_stride : 16; /* [15..0]  */
+        unsigned int mrg_yh_stride : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_MRG_HSTRIDE;
+
+/* define the union U_V0_MRG_READ_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int rd_region : 8;   /* [7..0]  */
+        unsigned int reserved_0 : 24; /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_MRG_READ_CTRL;
+
+/* define the union U_V0_MRG_READ_EN */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int rd_en : 1;       /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_MRG_READ_EN;
+
+/* define the union U_V1_MRG_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 20;  /* [19..0]  */
+        unsigned int mrg_edge_en : 1;  /* [20]  */
+        unsigned int reserved_1 : 4;   /* [24..21]  */
+        unsigned int mrg_edge_typ : 1; /* [25]  */
+        unsigned int reserved_2 : 2;   /* [27..26]  */
+        unsigned int mrg_crop_en : 1;  /* [28]  */
+        unsigned int mrg_dcmp_en : 1;  /* [29]  ---- */
+        unsigned int mrg_mute_en : 1;  /* [30]  */
+        unsigned int mrg_en : 1;       /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_MRG_CTRL;
+
+/* define the union U_V1_MRG_DISP_POS */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mrg_xpos : 16; /* [15..0]  */
+        unsigned int mrg_ypos : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_MRG_DISP_POS;
+
+/* define the union U_V1_MRG_DISP_RESO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mrg_width : 16;  /* [15..0]  */
+        unsigned int mrg_height : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_MRG_DISP_RESO;
+
+/* define the union U_V1_MRG_SRC_RESO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mrg_src_width : 16;  /* [15..0]  */
+        unsigned int mrg_src_height : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_MRG_SRC_RESO;
+
+/* define the union U_V1_MRG_SRC_OFFSET */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mrg_src_hoffset : 16; /* [15..0]  */
+        unsigned int mrg_src_voffset : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_MRG_SRC_OFFSET;
+
+/* define the union U_V1_MRG_STRIDE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mrg_c_stride : 16; /* [15..0]  */
+        unsigned int mrg_y_stride : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_MRG_STRIDE;
+
+/* define the union U_V1_MRG_HSTRIDE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int mrg_ch_stride : 16; /* [15..0]  */
+        unsigned int mrg_yh_stride : 16; /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_MRG_HSTRIDE;
+
+/* define the union U_V1_MRG_READ_CTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int rd_region : 8;   /* [7..0]  */
+        unsigned int reserved_0 : 24; /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_MRG_READ_CTRL;
+
+/* define the union U_V1_MRG_READ_EN */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int rd_en : 1;       /* [0]  */
+        unsigned int reserved_0 : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V1_MRG_READ_EN;
+
+/* define the union U_V0_ZME_HINFO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int out_width : 16;    /* [15..0]  */
+        unsigned int hzme_ck_gt_en : 1; /* [16]  */
+        unsigned int reserved_0 : 15;   /* [31..17]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_ZME_HINFO;
+
+/* define the union U_V0_ZME_HSP */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hratio : 24;    /* [23..0]  */
+        unsigned int hfir_order : 1; /* [24]  */
+        unsigned int chfir_mode : 1; /* [25]  */
+        unsigned int lhfir_mode : 1; /* [26]  */
+        unsigned int non_lnr_en : 1; /* [27]  */
+        unsigned int chmid_en : 1;   /* [28]  */
+        unsigned int lhmid_en : 1;   /* [29]  */
+        unsigned int chfir_en : 1;   /* [30]  */
+        unsigned int lhfir_en : 1;   /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_ZME_HSP;
+
+/* define the union U_V0_ZME_HLOFFSET */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int lhfir_offset : 28; /* [27..0]  */
+        unsigned int reserved_0 : 4;    /* [31..28]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_ZME_HLOFFSET;
+
+/* define the union U_V0_ZME_HCOFFSET */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int chfir_offset : 28; /* [27..0]  */
+        unsigned int reserved_0 : 4;    /* [31..28]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_ZME_HCOFFSET;
+
+/* define the union U_V0_ZME_HZONE0DELTA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int zone0_delta : 22; /* [21..0]  */
+        unsigned int reserved_0 : 10;  /* [31..22]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_ZME_HZONE0DELTA;
+
+/* define the union U_V0_ZME_HZONE2DELTA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int zone2_delta : 22; /* [21..0]  */
+        unsigned int reserved_0 : 10;  /* [31..22]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_ZME_HZONE2DELTA;
+
+/* define the union U_V0_ZME_HZONEEND */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int zone0_end : 12; /* [11..0]  */
+        unsigned int zone1_end : 12; /* [23..12]  */
+        unsigned int reserved_0 : 8; /* [31..24]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_ZME_HZONEEND;
+
+/* define the union U_V0_ZME_HL_SHOOTCTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hl_coring : 8;         /* [7..0]  */
+        unsigned int hl_gain : 6;           /* [13..8]  */
+        unsigned int hl_coringadj_en : 1;   /* [14]  */
+        unsigned int hl_flatdect_mode : 1;  /* [15]  */
+        unsigned int hl_shootctrl_mode : 1; /* [16]  */
+        unsigned int reserved_0 : 1;        /* [17]  */
+        unsigned int hl_shootctrl_en : 1;   /* [18]  */
+        unsigned int reserved_1 : 13;       /* [31..19]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_ZME_HL_SHOOTCTRL;
+
+/* define the union U_V0_ZME_HC_SHOOTCTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int hc_coring : 8;         /* [7..0]  */
+        unsigned int hc_gain : 6;           /* [13..8]  */
+        unsigned int hc_coringadj_en : 1;   /* [14]  */
+        unsigned int hc_flatdect_mode : 1;  /* [15]  */
+        unsigned int hc_shootctrl_mode : 1; /* [16]  */
+        unsigned int reserved_0 : 1;        /* [17]  */
+        unsigned int hc_shootctrl_en : 1;   /* [18]  */
+        unsigned int reserved_1 : 13;       /* [31..19]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_ZME_HC_SHOOTCTRL;
+
+/* define the union U_V0_ZME_HCOEF_REN */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int apb_vhd_hf_cren : 1; /* [0]  */
+        unsigned int apb_vhd_hf_lren : 1; /* [1]  */
+        unsigned int reserved_0 : 30;     /* [31..2]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_ZME_HCOEF_REN;
+
+/* define the union U_V0_ZME_HCOEF_RDATA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int apb_vhd_hcoef_raddr : 8; /* [7..0]  */
+        unsigned int reserved_0 : 24;         /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_ZME_HCOEF_RDATA;
+
+/* define the union U_V0_ZME_VINFO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int out_height : 16;   /* [15..0]  */
+        unsigned int out_fmt : 2;       /* [17..16]  */
+        unsigned int out_pro : 1;       /* [18]  */
+        unsigned int vzme_ck_gt_en : 1; /* [19]  */
+        unsigned int reserved_0 : 12;   /* [31..20]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_ZME_VINFO;
+
+/* define the union U_V0_ZME_VSP */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vratio : 16;      /* [15..0]  */
+        unsigned int graphdet_en : 1;  /* [16]  */
+        unsigned int reserved_0 : 8;   /* [24..17]  */
+        unsigned int cvfir_mode : 1;   /* [25]  */
+        unsigned int lvfir_mode : 1;   /* [26]  */
+        unsigned int vfir_1tap_en : 1; /* [27]  */
+        unsigned int cvmid_en : 1;     /* [28]  */
+        unsigned int lvmid_en : 1;     /* [29]  */
+        unsigned int cvfir_en : 1;     /* [30]  */
+        unsigned int lvfir_en : 1;     /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_ZME_VSP;
+
+/* define the union U_V0_ZME_VOFFSET */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vchroma_offset : 16; /* [15..0]  */
+        unsigned int vluma_offset : 16;   /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_ZME_VOFFSET;
+
+/* define the union U_V0_ZME_VBOFFSET */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vbchroma_offset : 16; /* [15..0]  */
+        unsigned int vbluma_offset : 16;   /* [31..16]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_ZME_VBOFFSET;
+
+/* define the union U_V0_ZME_VL_SHOOTCTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vl_coring : 8;         /* [7..0]  */
+        unsigned int vl_gain : 6;           /* [13..8]  */
+        unsigned int vl_coringadj_en : 1;   /* [14]  */
+        unsigned int vl_flatdect_mode : 1;  /* [15]  */
+        unsigned int vl_shootctrl_mode : 1; /* [16]  */
+        unsigned int reserved_0 : 1;        /* [17]  */
+        unsigned int vl_shootctrl_en : 1;   /* [18]  */
+        unsigned int reserved_1 : 13;       /* [31..19]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_ZME_VL_SHOOTCTRL;
+
+/* define the union U_V0_ZME_VC_SHOOTCTRL */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int vc_coring : 8;         /* [7..0]  */
+        unsigned int vc_gain : 6;           /* [13..8]  */
+        unsigned int vc_coringadj_en : 1;   /* [14]  */
+        unsigned int vc_flatdect_mode : 1;  /* [15]  */
+        unsigned int vc_shootctrl_mode : 1; /* [16]  */
+        unsigned int reserved_0 : 1;        /* [17]  */
+        unsigned int vc_shootctrl_en : 1;   /* [18]  */
+        unsigned int reserved_1 : 13;       /* [31..19]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_ZME_VC_SHOOTCTRL;
+
+/* define the union U_V0_ZME_VCOEF_REN */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int apb_vhd_vf_cren : 1; /* [0]  */
+        unsigned int apb_vhd_vf_lren : 1; /* [1]  */
+        unsigned int reserved_0 : 30;     /* [31..2]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_ZME_VCOEF_REN;
+
+/* define the union U_V0_ZME_VCOEF_RDATA */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int apb_vhd_vcoef_raddr : 8; /* [7..0]  */
+        unsigned int reserved_0 : 24;         /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_V0_ZME_VCOEF_RDATA;
+
+/* define the union U_GFX_OSD_GLB_INFO */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int dcmp_en : 1;       /* [0]  */
+        unsigned int is_lossless : 1;   /* [1]  */
+        unsigned int is_lossless_a : 1; /* [2]  */
+        unsigned int cmp_mode : 1;      /* [3]  */
+        unsigned int source_mode : 3;   /* [6..4]  */
+        unsigned int tpred_en : 1;      /* [7]  */
+        unsigned int reserved_0 : 24;   /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_OSD_GLB_INFO;
+
+/* define the union U_GFX_OSD_FRAME_SIZE */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int frame_width : 13;  /* [12..0]  */
+        unsigned int reserved_0 : 3;    /* [15..13]  */
+        unsigned int frame_height : 13; /* [28..16]  */
+        unsigned int reserved_1 : 3;    /* [31..29]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_OSD_FRAME_SIZE;
+
+/* define the union U_GFX_OSD_DBG_REG */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 30; /* [29..0]  */
+        unsigned int dcmp_err0 : 1;   /* [30]  */
+        unsigned int reserved_1 : 1;  /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_OSD_DBG_REG;
+
+/* define the union U_GFX_OSD_DBG_REG1 */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int reserved_0 : 30; /* [29..0]  */
+        unsigned int dcmp_err1 : 1;   /* [30]  */
+        unsigned int reserved_1 : 1;  /* [31]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int u32;
+} U_GFX_OSD_DBG_REG1;
+
+/* define the global struct */
+typedef struct {
+    volatile U_VOCTRL VOCTRL;                                                         /* 0x0 */
+    volatile U_VOINTSTA VOINTSTA;                                                     /* 0x4 */
+    volatile U_VOMSKINTSTA VOMSKINTSTA;                                               /* 0x8 */
+    volatile U_VOINTMSK VOINTMSK;                                                     /* 0xc */
+    volatile U_VODEBUG VODEBUG;                                                       /* 0x10 */
+    volatile U_VOINTSTA1 VOINTSTA1;                                                   /* 0x14 */
+    volatile U_VOMSKINTSTA1 VOMSKINTSTA1;                                             /* 0x18 */
+    volatile U_VOINTMSK1 VOINTMSK1;                                                   /* 0x1c */
+    volatile unsigned int VDPVERSION1;                                                /* 0x20 */
+    volatile unsigned int VDPVERSION2;                                                /* 0x24 */
+    volatile U_VOLOWPOWER_CTRL VOLOWPOWER_CTRL;                                       /* 0x28 */
+    volatile U_VOUFSTA VOUFSTA;                                                       /* 0x2c */
+    volatile U_VOUFCLR VOUFCLR;                                                       /* 0x30 */
+    volatile U_VOINTPROC_TIM VOINTPROC_TIM;                                           /* 0x34 */
+    volatile unsigned int VOFPGATEST;                                                 /* 0x38 */
+    volatile unsigned int reserved_0[3];                                              /* 0x3c~0x44 */
+    volatile U_VOLOWPOWER_CTRL1 VOLOWPOWER_CTRL1;                                     /* 0x48 */
+    volatile U_VOFPGADEF VOFPGADEF;                                                   /* 0x4c */
+    volatile unsigned int reserved_1[172];                                            /* 0x50~0x2fc */
+    volatile U_CBM_BKG1 CBM_BKG1;                                                     /* 0x300 */
+    volatile unsigned int reserved_2;                                                 /* 0x304 */
+    volatile U_CBM_MIX1 CBM_MIX1;                                                     /* 0x308 */
+    volatile unsigned int reserved_3[14];                                             /* 0x30c~0x340 */
+    volatile U_WBC_BMP_THD WBC_BMP_THD;                                               /* 0x344 */
+    volatile unsigned int reserved_4[14];                                             /* 0x348~0x37c */
+    volatile U_CBM_BKG2 CBM_BKG2;                                                     /* 0x380 */
+    volatile unsigned int reserved_5;                                                 /* 0x384 */
+    volatile U_CBM_MIX2 CBM_MIX2;                                                     /* 0x388 */
+    volatile unsigned int reserved_6[14];                                             /* 0x38c~0x3c0 */
+    volatile U_HC_BMP_THD HC_BMP_THD;                                                 /* 0x3c4 */
+    volatile unsigned int reserved_7[14];                                             /* 0x3c8~0x3fc */
+    volatile U_CBM_BKG3 CBM_BKG3;                                                     /* 0x400 */
+    volatile unsigned int reserved_8;                                                 /* 0x404 */
+    volatile U_CBM_MIX3 CBM_MIX3;                                                     /* 0x408 */
+    volatile unsigned int reserved_9[125];                                            /* 0x40c~0x5fc */
+    volatile U_MIXV0_BKG MIXV0_BKG;                                                   /* 0x600 */
+    volatile unsigned int reserved_10;                                                /* 0x604 */
+    volatile U_MIXV0_MIX MIXV0_MIX;                                                   /* 0x608 */
+    volatile unsigned int reserved_11[189];                                           /* 0x60c~0x8fc */
+    volatile U_MIXG0_BKG MIXG0_BKG;                                                   /* 0x900 */
+    volatile U_MIXG0_BKALPHA MIXG0_BKALPHA;                                           /* 0x904 */
+    volatile U_MIXG0_MIX MIXG0_MIX;                                                   /* 0x908 */
+    volatile unsigned int reserved_12[189];                                           /* 0x90c~0xbfc */
+    volatile U_LINK_CTRL LINK_CTRL;                                                   /* 0xc00 */
+    volatile unsigned int reserved_13[63];                                            /* 0xc04~0xcfc */
+    volatile U_VPSS_CTRL VPSS_CTRL;                                                   /* 0xd00 */
+    volatile U_VPSS_MISCELLANEOUS VPSS_MISCELLANEOUS;                                 /* 0xd04 */
+    volatile U_VPSS_FTCONFIG VPSS_FTCONFIG;                                           /* 0xd08 */
+    volatile unsigned int reserved_14[5];                                             /* 0xd0c~0xd1c */
+    volatile unsigned int VPSS_VERSION;                                               /* 0xd20 */
+    volatile unsigned int VPSS_DEBUG0;                                                /* 0xd24 */
+    volatile unsigned int VPSS_DEBUG1;                                                /* 0xd28 */
+    volatile unsigned int VPSS_DEBUG2;                                                /* 0xd2c */
+    volatile unsigned int VPSS_DEBUG3;                                                /* 0xd30 */
+    volatile unsigned int VPSS_DEBUG4;                                                /* 0xd34 */
+    volatile unsigned int VPSS_DEBUG5;                                                /* 0xd38 */
+    volatile unsigned int VPSS_DEBUG6;                                                /* 0xd3c */
+    volatile unsigned int reserved_15[48];                                            /* 0xd40~0xdfc */
+    volatile unsigned int PARA_HADDR_VHD_CHN00;                                       /* 0xe00 */
+    volatile unsigned int PARA_ADDR_VHD_CHN00;                                        /* 0xe04 */
+    volatile unsigned int PARA_HADDR_VHD_CHN01;                                       /* 0xe08 */
+    volatile unsigned int PARA_ADDR_VHD_CHN01;                                        /* 0xe0c */
+    volatile unsigned int PARA_HADDR_VHD_CHN02;                                       /* 0xe10 */
+    volatile unsigned int PARA_ADDR_VHD_CHN02;                                        /* 0xe14 */
+    volatile unsigned int PARA_HADDR_VHD_CHN03;                                       /* 0xe18 */
+    volatile unsigned int PARA_ADDR_VHD_CHN03;                                        /* 0xe1c */
+    volatile unsigned int PARA_HADDR_VHD_CHN04;                                       /* 0xe20 */
+    volatile unsigned int PARA_ADDR_VHD_CHN04;                                        /* 0xe24 */
+    volatile unsigned int PARA_HADDR_VHD_CHN05;                                       /* 0xe28 */
+    volatile unsigned int PARA_ADDR_VHD_CHN05;                                        /* 0xe2c */
+    volatile unsigned int PARA_HADDR_VHD_CHN06;                                       /* 0xe30 */
+    volatile unsigned int PARA_ADDR_VHD_CHN06;                                        /* 0xe34 */
+    volatile unsigned int PARA_HADDR_VHD_CHN07;                                       /* 0xe38 */
+    volatile unsigned int PARA_ADDR_VHD_CHN07;                                        /* 0xe3c */
+    volatile unsigned int PARA_HADDR_VHD_CHN08;                                       /* 0xe40 */
+    volatile unsigned int PARA_ADDR_VHD_CHN08;                                        /* 0xe44 */
+    volatile unsigned int PARA_HADDR_VHD_CHN09;                                       /* 0xe48 */
+    volatile unsigned int PARA_ADDR_VHD_CHN09;                                        /* 0xe4c */
+    volatile unsigned int PARA_HADDR_VHD_CHN10;                                       /* 0xe50 */
+    volatile unsigned int PARA_ADDR_VHD_CHN10;                                        /* 0xe54 */
+    volatile unsigned int PARA_HADDR_VHD_CHN11;                                       /* 0xe58 */
+    volatile unsigned int PARA_ADDR_VHD_CHN11;                                        /* 0xe5c */
+    volatile unsigned int PARA_HADDR_VHD_CHN12;                                       /* 0xe60 */
+    volatile unsigned int PARA_ADDR_VHD_CHN12;                                        /* 0xe64 */
+    volatile unsigned int PARA_HADDR_VHD_CHN13;                                       /* 0xe68 */
+    volatile unsigned int PARA_ADDR_VHD_CHN13;                                        /* 0xe6c */
+    volatile unsigned int PARA_HADDR_VHD_CHN14;                                       /* 0xe70 */
+    volatile unsigned int PARA_ADDR_VHD_CHN14;                                        /* 0xe74 */
+    volatile unsigned int PARA_HADDR_VHD_CHN15;                                       /* 0xe78 */
+    volatile unsigned int PARA_ADDR_VHD_CHN15;                                        /* 0xe7c */
+    volatile unsigned int PARA_HADDR_VHD_CHN16;                                       /* 0xe80 */
+    volatile unsigned int PARA_ADDR_VHD_CHN16;                                        /* 0xe84 */
+    volatile unsigned int PARA_HADDR_VHD_CHN17;                                       /* 0xe88 */
+    volatile unsigned int PARA_ADDR_VHD_CHN17;                                        /* 0xe8c */
+    volatile unsigned int PARA_HADDR_VHD_CHN18;                                       /* 0xe90 */
+    volatile unsigned int PARA_ADDR_VHD_CHN18;                                        /* 0xe94 */
+    volatile unsigned int PARA_HADDR_VHD_CHN19;                                       /* 0xe98 */
+    volatile unsigned int PARA_ADDR_VHD_CHN19;                                        /* 0xe9c */
+    volatile unsigned int PARA_HADDR_VHD_CHN20;                                       /* 0xea0 */
+    volatile unsigned int PARA_ADDR_VHD_CHN20;                                        /* 0xea4 */
+    volatile unsigned int PARA_HADDR_VHD_CHN21;                                       /* 0xea8 */
+    volatile unsigned int PARA_ADDR_VHD_CHN21;                                        /* 0xeac */
+    volatile unsigned int PARA_HADDR_VHD_CHN22;                                       /* 0xeb0 */
+    volatile unsigned int PARA_ADDR_VHD_CHN22;                                        /* 0xeb4 */
+    volatile unsigned int PARA_HADDR_VHD_CHN23;                                       /* 0xeb8 */
+    volatile unsigned int PARA_ADDR_VHD_CHN23;                                        /* 0xebc */
+    volatile unsigned int PARA_HADDR_VHD_CHN24;                                       /* 0xec0 */
+    volatile unsigned int PARA_ADDR_VHD_CHN24;                                        /* 0xec4 */
+    volatile unsigned int PARA_HADDR_VHD_CHN25;                                       /* 0xec8 */
+    volatile unsigned int PARA_ADDR_VHD_CHN25;                                        /* 0xecc */
+    volatile unsigned int PARA_HADDR_VHD_CHN26;                                       /* 0xed0 */
+    volatile unsigned int PARA_ADDR_VHD_CHN26;                                        /* 0xed4 */
+    volatile unsigned int PARA_HADDR_VHD_CHN27;                                       /* 0xed8 */
+    volatile unsigned int PARA_ADDR_VHD_CHN27;                                        /* 0xedc */
+    volatile unsigned int PARA_HADDR_VHD_CHN28;                                       /* 0xee0 */
+    volatile unsigned int PARA_ADDR_VHD_CHN28;                                        /* 0xee4 */
+    volatile unsigned int PARA_HADDR_VHD_CHN29;                                       /* 0xee8 */
+    volatile unsigned int PARA_ADDR_VHD_CHN29;                                        /* 0xeec */
+    volatile unsigned int PARA_HADDR_VHD_CHN30;                                       /* 0xef0 */
+    volatile unsigned int PARA_ADDR_VHD_CHN30;                                        /* 0xef4 */
+    volatile unsigned int PARA_HADDR_VHD_CHN31;                                       /* 0xef8 */
+    volatile unsigned int PARA_ADDR_VHD_CHN31;                                        /* 0xefc */
+    volatile U_PARA_UP_VHD PARA_UP_VHD;                                               /* 0xf00 */
+    volatile unsigned int PARA_HADDR_VSD_CHN00;                                       /* 0xf04 */
+    volatile unsigned int PARA_ADDR_VSD_CHN00;                                        /* 0xf08 */
+    volatile unsigned int PARA_HADDR_VSD_CHN01;                                       /* 0xf0c */
+    volatile unsigned int PARA_ADDR_VSD_CHN01;                                        /* 0xf10 */
+    volatile unsigned int PARA_HADDR_VSD_CHN02;                                       /* 0xf14 */
+    volatile unsigned int PARA_ADDR_VSD_CHN02;                                        /* 0xf18 */
+    volatile unsigned int PARA_HADDR_VSD_CHN03;                                       /* 0xf1c */
+    volatile unsigned int PARA_ADDR_VSD_CHN03;                                        /* 0xf20 */
+    volatile unsigned int PARA_HADDR_VSD_CHN04;                                       /* 0xf24 */
+    volatile unsigned int PARA_ADDR_VSD_CHN04;                                        /* 0xf28 */
+    volatile unsigned int PARA_HADDR_VSD_CHN05;                                       /* 0xf2c */
+    volatile unsigned int PARA_ADDR_VSD_CHN05;                                        /* 0xf30 */
+    volatile unsigned int PARA_HADDR_VSD_CHN06;                                       /* 0xf34 */
+    volatile unsigned int PARA_ADDR_VSD_CHN06;                                        /* 0xf38 */
+    volatile unsigned int PARA_HADDR_VSD_CHN07;                                       /* 0xf3c */
+    volatile unsigned int PARA_ADDR_VSD_CHN07;                                        /* 0xf40 */
+    volatile U_PARA_UP_VSD PARA_UP_VSD;                                               /* 0xf44 */
+    volatile U_PARA_CONFLICT_CLR PARA_CONFLICT_CLR;                                   /* 0xf48 */
+    volatile U_PARA_CONFLICT_STA PARA_CONFLICT_STA;                                   /* 0xf4c */
+    volatile unsigned int reserved_16[44];                                            /* 0xf50~0xffc */
+    volatile U_V0_CTRL V0_CTRL;                                                       /* 0x1000 */
+    volatile U_V0_UPD V0_UPD;                                                         /* 0x1004 */
+    volatile U_V0_0RESO_READ V0_0RESO_READ;                                           /* 0x1008 */
+    volatile unsigned int reserved_17[29];                                            /* 0x100c~0x107c */
+    volatile U_V0_DFPOS V0_DFPOS;                                                     /* 0x1080 */
+    volatile U_V0_DLPOS V0_DLPOS;                                                     /* 0x1084 */
+    volatile U_V0_VFPOS V0_VFPOS;                                                     /* 0x1088 */
+    volatile U_V0_VLPOS V0_VLPOS;                                                     /* 0x108c */
+    volatile U_V0_BK V0_BK;                                                           /* 0x1090 */
+    volatile U_V0_ALPHA V0_ALPHA;                                                     /* 0x1094 */
+    volatile U_V0_MUTE_BK V0_MUTE_BK;                                                 /* 0x1098 */
+    volatile unsigned int reserved_18;                                                /* 0x109c */
+    volatile U_V0_RIMWIDTH V0_RIMWIDTH;                                               /* 0x10a0 */
+    volatile U_V0_RIMCOL0 V0_RIMCOL0;                                                 /* 0x10a4 */
+    volatile U_V0_RIMCOL1 V0_RIMCOL1;                                                 /* 0x10a8 */
+    volatile unsigned int reserved_19[85];                                            /* 0x10ac~0x11fc */
+    volatile U_V0_VOPP_CSC_CTRL V0_VOPP_CSC_CTRL;                                     /* 0x1200 */
+    volatile U_V0_VOPP_CSC_COEF00 V0_VOPP_CSC_COEF00;                                 /* 0x1204 */
+    volatile U_V0_VOPP_CSC_COEF01 V0_VOPP_CSC_COEF01;                                 /* 0x1208 */
+    volatile U_V0_VOPP_CSC_COEF02 V0_VOPP_CSC_COEF02;                                 /* 0x120c */
+    volatile U_V0_VOPP_CSC_COEF10 V0_VOPP_CSC_COEF10;                                 /* 0x1210 */
+    volatile U_V0_VOPP_CSC_COEF11 V0_VOPP_CSC_COEF11;                                 /* 0x1214 */
+    volatile U_V0_VOPP_CSC_COEF12 V0_VOPP_CSC_COEF12;                                 /* 0x1218 */
+    volatile U_V0_VOPP_CSC_COEF20 V0_VOPP_CSC_COEF20;                                 /* 0x121c */
+    volatile U_V0_VOPP_CSC_COEF21 V0_VOPP_CSC_COEF21;                                 /* 0x1220 */
+    volatile U_V0_VOPP_CSC_COEF22 V0_VOPP_CSC_COEF22;                                 /* 0x1224 */
+    volatile U_V0_VOPP_CSC_SCALE V0_VOPP_CSC_SCALE;                                   /* 0x1228 */
+    volatile U_V0_VOPP_CSC_IDC0 V0_VOPP_CSC_IDC0;                                     /* 0x122c */
+    volatile U_V0_VOPP_CSC_IDC1 V0_VOPP_CSC_IDC1;                                     /* 0x1230 */
+    volatile U_V0_VOPP_CSC_IDC2 V0_VOPP_CSC_IDC2;                                     /* 0x1234 */
+    volatile U_V0_VOPP_CSC_ODC0 V0_VOPP_CSC_ODC0;                                     /* 0x1238 */
+    volatile U_V0_VOPP_CSC_ODC1 V0_VOPP_CSC_ODC1;                                     /* 0x123c */
+    volatile U_V0_VOPP_CSC_ODC2 V0_VOPP_CSC_ODC2;                                     /* 0x1240 */
+    volatile U_V0_VOPP_CSC_MIN_Y V0_VOPP_CSC_MIN_Y;                                   /* 0x1244 */
+    volatile U_V0_VOPP_CSC_MIN_C V0_VOPP_CSC_MIN_C;                                   /* 0x1248 */
+    volatile U_V0_VOPP_CSC_MAX_Y V0_VOPP_CSC_MAX_Y;                                   /* 0x124c */
+    volatile U_V0_VOPP_CSC_MAX_C V0_VOPP_CSC_MAX_C;                                   /* 0x1250 */
+    volatile U_V0_VOPP_CSC2_COEF00 V0_VOPP_CSC2_COEF00;                               /* 0x1254 */
+    volatile U_V0_VOPP_CSC2_COEF01 V0_VOPP_CSC2_COEF01;                               /* 0x1258 */
+    volatile U_V0_VOPP_CSC2_COEF02 V0_VOPP_CSC2_COEF02;                               /* 0x125c */
+    volatile U_V0_VOPP_CSC2_COEF10 V0_VOPP_CSC2_COEF10;                               /* 0x1260 */
+    volatile U_V0_VOPP_CSC2_COEF11 V0_VOPP_CSC2_COEF11;                               /* 0x1264 */
+    volatile U_V0_VOPP_CSC2_COEF12 V0_VOPP_CSC2_COEF12;                               /* 0x1268 */
+    volatile U_V0_VOPP_CSC2_COEF20 V0_VOPP_CSC2_COEF20;                               /* 0x126c */
+    volatile U_V0_VOPP_CSC2_COEF21 V0_VOPP_CSC2_COEF21;                               /* 0x1270 */
+    volatile U_V0_VOPP_CSC2_COEF22 V0_VOPP_CSC2_COEF22;                               /* 0x1274 */
+    volatile U_V0_VOPP_CSC2_SCALE V0_VOPP_CSC2_SCALE;                                 /* 0x1278 */
+    volatile U_V0_VOPP_CSC2_IDC0 V0_VOPP_CSC2_IDC0;                                   /* 0x127c */
+    volatile U_V0_VOPP_CSC2_IDC1 V0_VOPP_CSC2_IDC1;                                   /* 0x1280 */
+    volatile U_V0_VOPP_CSC2_IDC2 V0_VOPP_CSC2_IDC2;                                   /* 0x1284 */
+    volatile U_V0_VOPP_CSC2_ODC0 V0_VOPP_CSC2_ODC0;                                   /* 0x1288 */
+    volatile U_V0_VOPP_CSC2_ODC1 V0_VOPP_CSC2_ODC1;                                   /* 0x128c */
+    volatile U_V0_VOPP_CSC2_ODC2 V0_VOPP_CSC2_ODC2;                                   /* 0x1290 */
+    volatile U_V0_VOPP_CSC2_MIN_Y V0_VOPP_CSC2_MIN_Y;                                 /* 0x1294 */
+    volatile U_V0_VOPP_CSC2_MIN_C V0_VOPP_CSC2_MIN_C;                                 /* 0x1298 */
+    volatile U_V0_VOPP_CSC2_MAX_Y V0_VOPP_CSC2_MAX_Y;                                 /* 0x129c */
+    volatile U_V0_VOPP_CSC2_MAX_C V0_VOPP_CSC2_MAX_C;                                 /* 0x12a0 */
+    volatile unsigned int reserved_19_1[19];                                          /* 0x12a4~0x12ec */
+    volatile U_V0_VOPP_CSC_INK_CTRL V0_VOPP_CSC_INK_CTRL;                             /* 0x12f0 */
+    volatile U_V0_VOPP_CSC_INK_POS V0_VOPP_CSC_INK_POS;                               /* 0x12f4 */
+    volatile U_V0_VOPP_CSC_INK_DATA V0_VOPP_CSC_INK_DATA;                             /* 0x12f8 */
+    volatile U_V0_VOPP_CSC_INK_DATA2 V0_VOPP_CSC_INK_DATA2;                           /* 0x12fc */
+    volatile unsigned int reserved_20[64];                                            /* 0x1300~0x13fc */
+    volatile U_V0_CVFIR_VINFO V0_CVFIR_VINFO;                                         /* 0x1400 */
+    volatile U_V0_CVFIR_VSP V0_CVFIR_VSP;                                             /* 0x1404 */
+    volatile U_V0_CVFIR_VOFFSET V0_CVFIR_VOFFSET;                                     /* 0x1408 */
+    volatile U_V0_CVFIR_VBOFFSET V0_CVFIR_VBOFFSET;                                   /* 0x140c */
+    volatile unsigned int reserved_21[8];                                             /* 0x1410~0x142c */
+    volatile U_V0_CVFIR_VCOEF0 V0_CVFIR_VCOEF0;                                       /* 0x1430 */
+    volatile U_V0_CVFIR_VCOEF1 V0_CVFIR_VCOEF1;                                       /* 0x1434 */
+    volatile U_V0_CVFIR_VCOEF2 V0_CVFIR_VCOEF2;                                       /* 0x1438 */
+    volatile unsigned int reserved_22[49];                                            /* 0x143c~0x14fc */
+    volatile U_V0_HFIR_CTRL V0_HFIR_CTRL;                                             /* 0x1500 */
+    volatile U_V0_HFIRCOEF01 V0_HFIRCOEF01;                                           /* 0x1504 */
+    volatile U_V0_HFIRCOEF23 V0_HFIRCOEF23;                                           /* 0x1508 */
+    volatile U_V0_HFIRCOEF45 V0_HFIRCOEF45;                                           /* 0x150c */
+    volatile U_V0_HFIRCOEF67 V0_HFIRCOEF67;                                           /* 0x1510 */
+    volatile unsigned int reserved_23[699];                                           /* 0x1514~0x1ffc */
+    volatile U_V1_CTRL V1_CTRL;                                                       /* 0x2000 */
+    volatile U_V1_UPD V1_UPD;                                                         /* 0x2004 */
+    volatile U_V1_0RESO_READ V1_0RESO_READ;                                           /* 0x2008 */
+    volatile unsigned int reserved_24[29];                                            /* 0x200c~0x207c */
+    volatile U_V1_DFPOS V1_DFPOS;                                                     /* 0x2080 */
+    volatile U_V1_DLPOS V1_DLPOS;                                                     /* 0x2084 */
+    volatile U_V1_VFPOS V1_VFPOS;                                                     /* 0x2088 */
+    volatile U_V1_VLPOS V1_VLPOS;                                                     /* 0x208c */
+    volatile U_V1_BK V1_BK;                                                           /* 0x2090 */
+    volatile U_V1_ALPHA V1_ALPHA;                                                     /* 0x2094 */
+    volatile U_V1_MUTE_BK V1_MUTE_BK;                                                 /* 0x2098 */
+    volatile unsigned int reserved_25;                                                /* 0x209c */
+    volatile U_V1_RIMWIDTH V1_RIMWIDTH;                                               /* 0x20a0 */
+    volatile U_V1_RIMCOL0 V1_RIMCOL0;                                                 /* 0x20a4 */
+    volatile U_V1_RIMCOL1 V1_RIMCOL1;                                                 /* 0x20a8 */
+    volatile unsigned int reserved_26[85];                                            /* 0x20ac~0x21fc */
+    volatile unsigned int reserved_27[64];                                            /* 0x2200~0x22fc v1 csc */
+    volatile unsigned int reserved_27_1[64];                                          /* 0x2300~0x23fc */
+    volatile U_V1_CVFIR_VINFO V1_CVFIR_VINFO;                                         /* 0x2400 */
+    volatile U_V1_CVFIR_VSP V1_CVFIR_VSP;                                             /* 0x2404 */
+    volatile U_V1_CVFIR_VOFFSET V1_CVFIR_VOFFSET;                                     /* 0x2408 */
+    volatile U_V1_CVFIR_VBOFFSET V1_CVFIR_VBOFFSET;                                   /* 0x240c */
+    volatile unsigned int reserved_28[8];                                             /* 0x2410~0x242c */
+    volatile U_V1_CVFIR_VCOEF0 V1_CVFIR_VCOEF0;                                       /* 0x2430 */
+    volatile U_V1_CVFIR_VCOEF1 V1_CVFIR_VCOEF1;                                       /* 0x2434 */
+    volatile U_V1_CVFIR_VCOEF2 V1_CVFIR_VCOEF2;                                       /* 0x2438 */
+    volatile unsigned int reserved_29[49];                                            /* 0x243c~0x24fc */
+    volatile U_V1_HFIR_CTRL V1_HFIR_CTRL;                                             /* 0x2500 */
+    volatile U_V1_HFIRCOEF01 V1_HFIRCOEF01;                                           /* 0x2504 */
+    volatile U_V1_HFIRCOEF23 V1_HFIRCOEF23;                                           /* 0x2508 */
+    volatile U_V1_HFIRCOEF45 V1_HFIRCOEF45;                                           /* 0x250c */
+    volatile U_V1_HFIRCOEF67 V1_HFIRCOEF67;                                           /* 0x2510 */
+    volatile unsigned int reserved_30[699];                                           /* 0x2514~0x2ffc */
+    volatile U_V2_CTRL V2_CTRL;                                                       /* 0x3000 */
+    volatile U_V2_UPD V2_UPD;                                                         /* 0x3004 */
+    volatile U_V2_0RESO_READ V2_0RESO_READ;                                           /* 0x3008 */
+    volatile unsigned int reserved_31[29];                                            /* 0x300c~0x307c */
+    volatile U_V2_DFPOS V2_DFPOS;                                                     /* 0x3080 */
+    volatile U_V2_DLPOS V2_DLPOS;                                                     /* 0x3084 */
+    volatile U_V2_VFPOS V2_VFPOS;                                                     /* 0x3088 */
+    volatile U_V2_VLPOS V2_VLPOS;                                                     /* 0x308c */
+    volatile U_V2_BK V2_BK;                                                           /* 0x3090 */
+    volatile U_V2_ALPHA V2_ALPHA;                                                     /* 0x3094 */
+    volatile U_V2_MUTE_BK V2_MUTE_BK;                                                 /* 0x3098 */
+    volatile U_V2_LBOX_CTRL V2_LBOX_CTRL;                                             /* 0x309c */
+    volatile unsigned int reserved_32[216];                                           /* 0x30a0~0x33fc */
+    volatile U_V2_CVFIR_VINFO V2_CVFIR_VINFO;                                         /* 0x3400 */
+    volatile U_V2_CVFIR_VSP V2_CVFIR_VSP;                                             /* 0x3404 */
+    volatile U_V2_CVFIR_VOFFSET V2_CVFIR_VOFFSET;                                     /* 0x3408 */
+    volatile U_V2_CVFIR_VBOFFSET V2_CVFIR_VBOFFSET;                                   /* 0x340c */
+    volatile unsigned int reserved_34[8];                                             /* 0x3410~0x342c */
+    volatile U_V2_CVFIR_VCOEF0 V2_CVFIR_VCOEF0;                                       /* 0x3430 */
+    volatile U_V2_CVFIR_VCOEF1 V2_CVFIR_VCOEF1;                                       /* 0x3434 */
+    volatile U_V2_CVFIR_VCOEF2 V2_CVFIR_VCOEF2;                                       /* 0x3438 */
+    volatile unsigned int reserved_35[49];                                            /* 0x343c~0x34fc */
+    volatile U_V2_HFIR_CTRL V2_HFIR_CTRL;                                             /* 0x3500 */
+    volatile U_V2_HFIRCOEF01 V2_HFIRCOEF01;                                           /* 0x3504 */
+    volatile U_V2_HFIRCOEF23 V2_HFIRCOEF23;                                           /* 0x3508 */
+    volatile U_V2_HFIRCOEF45 V2_HFIRCOEF45;                                           /* 0x350c */
+    volatile U_V2_HFIRCOEF67 V2_HFIRCOEF67;                                           /* 0x3510 */
+    volatile unsigned int reserved_36[2235];                                          /* 0x3514~0x57fc */
+    volatile unsigned int VP0_CTRL;                                                   /* 0x5800 */
+    volatile U_VP0_UPD VP0_UPD;                                                       /* 0x5804 */
+    volatile U_VP0_IRESO VP0_IRESO;                                                   /* 0x5808 */
+    volatile unsigned int reserved_37[29];                                            /* 0x580c~0x587c */
+    volatile U_VP0_LBOX_CTRL VP0_LBOX_CTRL;                                           /* 0x5880 */
+    volatile U_VP0_GALPHA VP0_GALPHA;                                                 /* 0x5884 */
+    volatile U_VP0_DFPOS VP0_DFPOS;                                                   /* 0x5888 */
+    volatile U_VP0_DLPOS VP0_DLPOS;                                                   /* 0x588c */
+    volatile U_VP0_VFPOS VP0_VFPOS;                                                   /* 0x5890 */
+    volatile U_VP0_VLPOS VP0_VLPOS;                                                   /* 0x5894 */
+    volatile U_VP0_BK VP0_BK;                                                         /* 0x5898 */
+    volatile U_VP0_ALPHA VP0_ALPHA;                                                   /* 0x589c */
+    volatile U_VP0_MUTE_BK VP0_MUTE_BK;                                               /* 0x58a0 */
+    volatile unsigned int reserved_38[1495];                                          /* 0x58a4~0x6ffc */
+    volatile unsigned int G0_CTRL;                                                    /* 0x7000 */
+    volatile unsigned int G0_UPD;                                                     /* 0x7004 */
+    volatile unsigned int G0_GALPHA_SUM;                                              /* 0x7008 */
+    volatile unsigned int G0_0RESO_READ;                                              /* 0x700c */
+    volatile unsigned int reserved_39[28];                                            /* 0x7010~0x707c */
+    volatile unsigned int G0_DFPOS;                                                   /* 0x7080 */
+    volatile unsigned int G0_DLPOS;                                                   /* 0x7084 */
+    volatile unsigned int G0_VFPOS;                                                   /* 0x7088 */
+    volatile unsigned int G0_VLPOS;                                                   /* 0x708c */
+    volatile unsigned int G0_BK;                                                      /* 0x7090 */
+    volatile unsigned int G0_ALPHA;                                                   /* 0x7094 */
+    volatile unsigned int G0_MUTE_BK;                                                 /* 0x7098 */
+    volatile unsigned int G0_LBOX_CTRL;                                               /* 0x709c */
+    volatile unsigned int reserved_40[24];                                            /* 0x70a0~0x70fc */
+    volatile U_V0_VOPP_CSC_CTRL G0_VOPP_CSC_CTRL;                                     /* 0x7100 */
+    volatile U_V0_VOPP_CSC_COEF00 G0_VOPP_CSC_COEF00;                                 /* 0x7104 */
+    volatile U_V0_VOPP_CSC_COEF01 G0_VOPP_CSC_COEF01;                                 /* 0x7108 */
+    volatile U_V0_VOPP_CSC_COEF02 G0_VOPP_CSC_COEF02;                                 /* 0x710c */
+    volatile U_V0_VOPP_CSC_COEF10 G0_VOPP_CSC_COEF10;                                 /* 0x7110 */
+    volatile U_V0_VOPP_CSC_COEF11 G0_VOPP_CSC_COEF11;                                 /* 0x7114 */
+    volatile U_V0_VOPP_CSC_COEF12 G0_VOPP_CSC_COEF12;                                 /* 0x7118 */
+    volatile U_V0_VOPP_CSC_COEF20 G0_VOPP_CSC_COEF20;                                 /* 0x711c */
+    volatile U_V0_VOPP_CSC_COEF21 G0_VOPP_CSC_COEF21;                                 /* 0x7120 */
+    volatile U_V0_VOPP_CSC_COEF22 G0_VOPP_CSC_COEF22;                                 /* 0x7124 */
+    volatile U_V0_VOPP_CSC_SCALE G0_VOPP_CSC_SCALE;                                   /* 0x7128 */
+    volatile U_V0_VOPP_CSC_IDC0 G0_VOPP_CSC_IDC0;                                     /* 0x712c */
+    volatile U_V0_VOPP_CSC_IDC1 G0_VOPP_CSC_IDC1;                                     /* 0x7130 */
+    volatile U_V0_VOPP_CSC_IDC2 G0_VOPP_CSC_IDC2;                                     /* 0x7134 */
+    volatile U_V0_VOPP_CSC_ODC0 G0_VOPP_CSC_ODC0;                                     /* 0x7138 */
+    volatile U_V0_VOPP_CSC_ODC1 G0_VOPP_CSC_ODC1;                                     /* 0x713c */
+    volatile U_V0_VOPP_CSC_ODC2 G0_VOPP_CSC_ODC2;                                     /* 0x7140 */
+    volatile U_V0_VOPP_CSC_MIN_Y G0_VOPP_CSC_MIN_Y;                                   /* 0x7144 */
+    volatile U_V0_VOPP_CSC_MIN_C G0_VOPP_CSC_MIN_C;                                   /* 0x7148 */
+    volatile U_V0_VOPP_CSC_MAX_Y G0_VOPP_CSC_MAX_Y;                                   /* 0x714c */
+    volatile U_V0_VOPP_CSC_MAX_C G0_VOPP_CSC_MAX_C;                                   /* 0x7150 */
+    volatile U_V0_VOPP_CSC2_COEF00 G0_VOPP_CSC2_COEF00;                               /* 0x7154 */
+    volatile U_V0_VOPP_CSC2_COEF01 G0_VOPP_CSC2_COEF01;                               /* 0x7158 */
+    volatile U_V0_VOPP_CSC2_COEF02 G0_VOPP_CSC2_COEF02;                               /* 0x715c */
+    volatile U_V0_VOPP_CSC2_COEF10 G0_VOPP_CSC2_COEF10;                               /* 0x7160 */
+    volatile U_V0_VOPP_CSC2_COEF11 G0_VOPP_CSC2_COEF11;                               /* 0x7164 */
+    volatile U_V0_VOPP_CSC2_COEF12 G0_VOPP_CSC2_COEF12;                               /* 0x7168 */
+    volatile U_V0_VOPP_CSC2_COEF20 G0_VOPP_CSC2_COEF20;                               /* 0x716c */
+    volatile U_V0_VOPP_CSC2_COEF21 G0_VOPP_CSC2_COEF21;                               /* 0x7170 */
+    volatile U_V0_VOPP_CSC2_COEF22 G0_VOPP_CSC2_COEF22;                               /* 0x7174 */
+    volatile U_V0_VOPP_CSC2_SCALE G0_VOPP_CSC2_SCALE;                                 /* 0x7178 */
+    volatile U_V0_VOPP_CSC2_IDC0 G0_VOPP_CSC2_IDC0;                                   /* 0x717c */
+    volatile U_V0_VOPP_CSC2_IDC1 G0_VOPP_CSC2_IDC1;                                   /* 0x7180 */
+    volatile U_V0_VOPP_CSC2_IDC2 G0_VOPP_CSC2_IDC2;                                   /* 0x7184 */
+    volatile U_V0_VOPP_CSC2_ODC0 G0_VOPP_CSC2_ODC0;                                   /* 0x7188 */
+    volatile U_V0_VOPP_CSC2_ODC1 G0_VOPP_CSC2_ODC1;                                   /* 0x718c */
+    volatile U_V0_VOPP_CSC2_ODC2 G0_VOPP_CSC2_ODC2;                                   /* 0x7190 */
+    volatile U_V0_VOPP_CSC2_MIN_Y G0_VOPP_CSC2_MIN_Y;                                 /* 0x7194 */
+    volatile U_V0_VOPP_CSC2_MIN_C G0_VOPP_CSC2_MIN_C;                                 /* 0x7198 */
+    volatile U_V0_VOPP_CSC2_MAX_Y G0_VOPP_CSC2_MAX_Y;                                 /* 0x719c */
+    volatile U_V0_VOPP_CSC2_MAX_C G0_VOPP_CSC2_MAX_C;                                 /* 0x71a0 */
+    volatile unsigned int reserved_40_1[19];                                          /* 0x71a4~0x71ec */
+    volatile U_V0_VOPP_CSC_INK_CTRL G0_VOPP_CSC_INK_CTRL;                             /* 0x71f0 */
+    volatile U_V0_VOPP_CSC_INK_POS G0_VOPP_CSC_INK_POS;                               /* 0x71f4 */
+    volatile U_V0_VOPP_CSC_INK_DATA G0_VOPP_CSC_INK_DATA;                             /* 0x71f8 */
+    volatile U_V0_VOPP_CSC_INK_DATA2 G0_VOPP_CSC_INK_DATA2;                           /* 0x71fc */
+    volatile unsigned int G0_DOF_CTRL;                                                /* 0x7200 */
+    volatile unsigned int G0_DOF_STEP;                                                /* 0x7204 */
+    volatile unsigned int G0_DOF_BKG;                                                 /* 0x7208 */
+    volatile unsigned int G0_DOF_ALPHA;                                               /* 0x720c */
+    volatile unsigned int reserved_41[60];                                            /* 0x7210~0x72fc */
+    volatile unsigned int G0_ZME_HINFO;                                               /* 0x7300 */
+    volatile unsigned int G0_ZME_HSP;                                                 /* 0x7304 */
+    volatile unsigned int G0_ZME_HLOFFSET;                                            /* 0x7308 */
+    volatile unsigned int G0_ZME_HCOFFSET;                                            /* 0x730c */
+    volatile unsigned int reserved_42[5];                                             /* 0x7310~0x7320 */
+    volatile unsigned int G0_ZME_COEF_REN;                                            /* 0x7324 */
+    volatile unsigned int G0_ZME_COEF_RDATA;                                          /* 0x7328 */
+    volatile unsigned int reserved_43[21];                                            /* 0x732c~0x737c */
+    volatile unsigned int G0_ZME_VINFO;                                               /* 0x7380 */
+    volatile unsigned int G0_ZME_VSP;                                                 /* 0x7384 */
+    volatile unsigned int G0_ZME_VOFFSET;                                             /* 0x7388 */
+    volatile unsigned int reserved_44[285];                                           /* 0x738c~0x77fc */
+    volatile unsigned int G1_CTRL;                                                    /* 0x7800 */
+    volatile unsigned int G1_UPD;                                                     /* 0x7804 */
+    volatile unsigned int G1_GALPHA_SUM;                                              /* 0x7808 */
+    volatile unsigned int G1_0RESO_READ;                                              /* 0x780c */
+    volatile unsigned int reserved_45[28];                                            /* 0x7810~0x787c */
+    volatile unsigned int G1_DFPOS;                                                   /* 0x7880 */
+    volatile unsigned int G1_DLPOS;                                                   /* 0x7884 */
+    volatile unsigned int G1_VFPOS;                                                   /* 0x7888 */
+    volatile unsigned int G1_VLPOS;                                                   /* 0x788c */
+    volatile unsigned int G1_BK;                                                      /* 0x7890 */
+    volatile unsigned int G1_ALPHA;                                                   /* 0x7894 */
+    volatile unsigned int G1_MUTE_BK;                                                 /* 0x7898 */
+    volatile unsigned int G1_LBOX_CTRL;                                               /* 0x789c */
+    volatile unsigned int reserved_46[24];                                            /* 0x78a0~0x78fc */
+    volatile unsigned int reserved_46_1[64];                                          /* 0x7900~0x79fc g1 csc */
+    volatile unsigned int reserved_47[896];                                           /* 0x7a00~0x87fc */
+    volatile unsigned int G3_CTRL;                                                    /* 0x8800 */
+    volatile unsigned int G3_UPD;                                                     /* 0x8804 */
+    volatile unsigned int G3_GALPHA_SUM;                                              /* 0x8808 */
+    volatile unsigned int G3_0RESO_READ;                                              /* 0x880c */
+    volatile unsigned int reserved_48[28];                                            /* 0x8810~0x887c */
+    volatile unsigned int G3_DFPOS;                                                   /* 0x8880 */
+    volatile unsigned int G3_DLPOS;                                                   /* 0x8884 */
+    volatile unsigned int G3_VFPOS;                                                   /* 0x8888 */
+    volatile unsigned int G3_VLPOS;                                                   /* 0x888c */
+    volatile unsigned int G3_BK;                                                      /* 0x8890 */
+    volatile unsigned int G3_ALPHA;                                                   /* 0x8894 */
+    volatile unsigned int G3_MUTE_BK;                                                 /* 0x8898 */
+    volatile unsigned int G3_LBOX_CTRL;                                               /* 0x889c */
+    volatile unsigned int reserved_49[984];                                           /* 0x88a0~0x97fc */
+    volatile unsigned int GP0_CTRL;                                                   /* 0x9800 */
+    volatile U_GP0_UPD GP0_UPD;                                                       /* 0x9804 */
+    volatile U_GP0_IRESO GP0_IRESO;                                                   /* 0x9808 */
+    volatile unsigned int reserved_51[29];                                            /* 0x980c~0x987c */
+    volatile U_GP0_LBOX_CTRL GP0_LBOX_CTRL;                                           /* 0x9880 */
+    volatile U_GP0_GALPHA GP0_GALPHA;                                                 /* 0x9884 */
+    volatile unsigned int GP0_GALPHA_SUM;                                             /* 0x9888 */
+    volatile U_GP0_DFPOS GP0_DFPOS;                                                   /* 0x988c */
+    volatile U_GP0_DLPOS GP0_DLPOS;                                                   /* 0x9890 */
+    volatile U_GP0_VFPOS GP0_VFPOS;                                                   /* 0x9894 */
+    volatile U_GP0_VLPOS GP0_VLPOS;                                                   /* 0x9898 */
+    volatile U_GP0_BK GP0_BK;                                                         /* 0x989c */
+    volatile U_GP0_ALPHA GP0_ALPHA;                                                   /* 0x98a0 */
+    volatile U_GP0_MUTE_BK GP0_MUTE_BK;                                               /* 0x98a4 */
+    volatile unsigned int reserved_52[22];                                            /* 0x98a8~0x98fc */
+    volatile U_GP0_CSC_IDC GP0_CSC_IDC;                                               /* 0x9900 */
+    volatile U_GP0_CSC_ODC GP0_CSC_ODC;                                               /* 0x9904 */
+    volatile U_GP0_CSC_IODC GP0_CSC_IODC;                                             /* 0x9908 */
+    volatile U_GP0_CSC_P0 GP0_CSC_P0;                                                 /* 0x990c */
+    volatile U_GP0_CSC_P1 GP0_CSC_P1;                                                 /* 0x9910 */
+    volatile U_GP0_CSC_P2 GP0_CSC_P2;                                                 /* 0x9914 */
+    volatile U_GP0_CSC_P3 GP0_CSC_P3;                                                 /* 0x9918 */
+    volatile U_GP0_CSC_P4 GP0_CSC_P4;                                                 /* 0x991c */
+    volatile unsigned int reserved_53[1464];                                          /* 0x9920~0xaffc */
+    volatile U_WBC_G0_CTRL WBC_G0_CTRL;                                               /* 0xb000 */
+    volatile U_WBC_G0_UPD WBC_G0_UPD;                                                 /* 0xb004 */
+    volatile U_WBC_G0_CMP WBC_G0_CMP;                                                 /* 0xb008 */
+    volatile unsigned int reserved_54;                                                /* 0xb00c */
+    volatile unsigned int WBC_G0_AR_ADDR;                                             /* 0xb010 */
+    volatile unsigned int WBC_G0_GB_ADDR;                                             /* 0xb014 */
+    volatile U_WBC_G0_STRIDE WBC_G0_STRIDE;                                           /* 0xb018 */
+    volatile unsigned int WBC_G0_OFFSET;                                              /* 0xb01c */
+    volatile U_WBC_G0_ORESO WBC_G0_ORESO;                                             /* 0xb020 */
+    volatile U_WBC_G0_FCROP WBC_G0_FCROP;                                             /* 0xb024 */
+    volatile U_WBC_G0_LCROP WBC_G0_LCROP;                                             /* 0xb028 */
+    volatile unsigned int reserved_55[501];                                           /* 0xb02c~0xb7fc */
+    volatile U_WBC_GP0_CTRL WBC_GP0_CTRL;                                             /* 0xb800 */
+    volatile U_WBC_GP0_UPD WBC_GP0_UPD;                                               /* 0xb804 */
+    volatile unsigned int reserved_56[2];                                             /* 0xb808~0xb80c */
+    volatile unsigned int WBC_GP0_YADDR;                                              /* 0xb810 */
+    volatile unsigned int WBC_GP0_CADDR;                                              /* 0xb814 */
+    volatile U_WBC_GP0_STRIDE WBC_GP0_STRIDE;                                         /* 0xb818 */
+    volatile unsigned int reserved_57;                                                /* 0xb81c */
+    volatile U_WBC_GP0_ORESO WBC_GP0_ORESO;                                           /* 0xb820 */
+    volatile U_WBC_GP0_FCROP WBC_GP0_FCROP;                                           /* 0xb824 */
+    volatile U_WBC_GP0_LCROP WBC_GP0_LCROP;                                           /* 0xb828 */
+    volatile unsigned int reserved_58[53];                                            /* 0xb82c~0xb8fc */
+    volatile U_WBC_GP0_DITHER_CTRL WBC_GP0_DITHER_CTRL;                               /* 0xb900 */
+    volatile U_WBC_GP0_DITHER_COEF0 WBC_GP0_DITHER_COEF0;                             /* 0xb904 */
+    volatile U_WBC_GP0_DITHER_COEF1 WBC_GP0_DITHER_COEF1;                             /* 0xb908 */
+    volatile unsigned int reserved_59[17];                                            /* 0xb90c~0xb94c */
+    volatile U_WBC_GP0_HPZME WBC_GP0_HPZME;                                           /* 0xb950 */
+    volatile unsigned int reserved_60[43];                                            /* 0xb954~0xb9fc */
+    volatile U_WBC_ME_CTRL WBC_ME_CTRL;                                               /* 0xba00 */
+    volatile U_WBC_ME_UPD WBC_ME_UPD;                                                 /* 0xba04 */
+    volatile U_WBC_ME_WLEN_SEL WBC_ME_WLEN_SEL;                                       /* 0xba08 */
+    volatile unsigned int reserved_61;                                                /* 0xba0c */
+    volatile unsigned int WBC_ME_YADDR;                                               /* 0xba10 */
+    volatile unsigned int WBC_ME_CADDR;                                               /* 0xba14 */
+    volatile U_WBC_ME_STRIDE WBC_ME_STRIDE;                                           /* 0xba18 */
+    volatile unsigned int reserved_62;                                                /* 0xba1c */
+    volatile U_WBC_ME_ORESO WBC_ME_ORESO;                                             /* 0xba20 */
+    volatile unsigned int reserved_63[2];                                             /* 0xba24~0xba28 */
+    volatile U_WBC_ME_SMMU_BYPASS WBC_ME_SMMU_BYPASS;                                 /* 0xba2c */
+    volatile unsigned int reserved_64[4];                                             /* 0xba30~0xba3c */
+    volatile U_WBC_ME_PARAUP WBC_ME_PARAUP;                                           /* 0xba40 */
+    volatile unsigned int reserved_65[3];                                             /* 0xba44~0xba4c */
+    volatile unsigned int WBC_ME_HLCOEFAD;                                            /* 0xba50 */
+    volatile unsigned int WBC_ME_HCCOEFAD;                                            /* 0xba54 */
+    volatile unsigned int WBC_ME_VLCOEFAD;                                            /* 0xba58 */
+    volatile unsigned int WBC_ME_VCCOEFAD;                                            /* 0xba5c */
+    volatile unsigned int reserved_66[36];                                            /* 0xba60~0xbaec */
+    volatile unsigned int WBC_ME_CHECKSUM_Y;                                          /* 0xbaf0 */
+    volatile unsigned int WBC_ME_CHECKSUM_C;                                          /* 0xbaf4 */
+    volatile unsigned int reserved_67[2];                                             /* 0xbaf8~0xbafc */
+    volatile U_WBC_ME_DITHER_CTRL WBC_ME_DITHER_CTRL;                                 /* 0xbb00 */
+    volatile U_WBC_ME_DITHER_COEF0 WBC_ME_DITHER_COEF0;                               /* 0xbb04 */
+    volatile U_WBC_ME_DITHER_COEF1 WBC_ME_DITHER_COEF1;                               /* 0xbb08 */
+    volatile unsigned int reserved_68[109];                                           /* 0xbb0c~0xbcbc */
+    volatile U_WBC_ME_ZME_HSP WBC_ME_ZME_HSP;                                         /* 0xbcc0 */
+    volatile U_WBC_ME_ZME_HLOFFSET WBC_ME_ZME_HLOFFSET;                               /* 0xbcc4 */
+    volatile U_WBC_ME_ZME_HCOFFSET WBC_ME_ZME_HCOFFSET;                               /* 0xbcc8 */
+    volatile unsigned int reserved_69[3];                                             /* 0xbccc~0xbcd4 */
+    volatile U_WBC_ME_ZME_VSP WBC_ME_ZME_VSP;                                         /* 0xbcd8 */
+    volatile U_WBC_ME_ZME_VSR WBC_ME_ZME_VSR;                                         /* 0xbcdc */
+    volatile U_WBC_ME_ZME_VOFFSET WBC_ME_ZME_VOFFSET;                                 /* 0xbce0 */
+    volatile U_WBC_ME_ZME_VBOFFSET WBC_ME_ZME_VBOFFSET;                               /* 0xbce4 */
+    volatile unsigned int reserved_70[6];                                             /* 0xbce8~0xbcfc */
+    volatile U_WBC_FI_CTRL WBC_FI_CTRL;                                               /* 0xbd00 */
+    volatile U_WBC_FI_UPD WBC_FI_UPD;                                                 /* 0xbd04 */
+    volatile U_WBC_FI_WLEN_SEL WBC_FI_WLEN_SEL;                                       /* 0xbd08 */
+    volatile unsigned int reserved_71;                                                /* 0xbd0c */
+    volatile unsigned int WBC_FI_YADDR;                                               /* 0xbd10 */
+    volatile unsigned int WBC_FI_CADDR;                                               /* 0xbd14 */
+    volatile U_WBC_FI_STRIDE WBC_FI_STRIDE;                                           /* 0xbd18 */
+    volatile unsigned int reserved_72;                                                /* 0xbd1c */
+    volatile U_WBC_FI_ORESO WBC_FI_ORESO;                                             /* 0xbd20 */
+    volatile unsigned int reserved_73[2];                                             /* 0xbd24~0xbd28 */
+    volatile U_WBC_FI_SMMU_BYPASS WBC_FI_SMMU_BYPASS;                                 /* 0xbd2c */
+    volatile unsigned int reserved_74[5];                                             /* 0xbd30~0xbd40 */
+    volatile U_WBC_FI_FRAME_SIZE WBC_FI_FRAME_SIZE;                                   /* 0xbd44 */
+    volatile unsigned int WBC_FI_Y_RADDR;                                             /* 0xbd48 */
+    volatile unsigned int WBC_FI_C_RADDR;                                             /* 0xbd4c */
+    volatile unsigned int reserved_75[40];                                            /* 0xbd50~0xbdec */
+    volatile unsigned int WBC_FI_CHECKSUM_Y;                                          /* 0xbdf0 */
+    volatile unsigned int WBC_FI_CHECKSUM_C;                                          /* 0xbdf4 */
+    volatile unsigned int reserved_76[6];                                             /* 0xbdf8~0xbe0c */
+    volatile U_WBC_FI_HCDS WBC_FI_HCDS;                                               /* 0xbe10 */
+    volatile U_WBC_FI_HCDS_COEF0 WBC_FI_HCDS_COEF0;                                   /* 0xbe14 */
+    volatile U_WBC_FI_HCDS_COEF1 WBC_FI_HCDS_COEF1;                                   /* 0xbe18 */
+    volatile unsigned int reserved_77;                                                /* 0xbe1c */
+    volatile U_WBC_FI_CMP_MB WBC_FI_CMP_MB;                                           /* 0xbe20 */
+    volatile U_WBC_FI_CMP_MAX_MIN WBC_FI_CMP_MAX_MIN;                                 /* 0xbe24 */
+    volatile U_WBC_FI_CMP_ADJ_THR WBC_FI_CMP_ADJ_THR;                                 /* 0xbe28 */
+    volatile U_WBC_FI_CMP_BIG_GRAD WBC_FI_CMP_BIG_GRAD;                               /* 0xbe2c */
+    volatile U_WBC_FI_CMP_BLK WBC_FI_CMP_BLK;                                         /* 0xbe30 */
+    volatile U_WBC_FI_CMP_GRAPHIC_JUDGE WBC_FI_CMP_GRAPHIC_JUDGE;                     /* 0xbe34 */
+    volatile U_WBC_FI_CMP_RC WBC_FI_CMP_RC;                                           /* 0xbe38 */
+    volatile U_WBC_FI_CMP_FRAME_SIZE WBC_FI_CMP_FRAME_SIZE;                           /* 0xbe3c */
+    volatile unsigned int reserved_78[48];                                            /* 0xbe40~0xbefc */
+    volatile U_WBC_CMP_GLB_INFO WBC_CMP_GLB_INFO;                                     /* 0xbf00 */
+    volatile U_WBC_CMP_FRAMESIZE WBC_CMP_FRAMESIZE;                                   /* 0xbf04 */
+    volatile U_WBC_CMP_RC_CFG0 WBC_CMP_RC_CFG0;                                       /* 0xbf08 */
+    volatile U_WBC_CMP_RC_CFG2 WBC_CMP_RC_CFG2;                                       /* 0xbf0c */
+    volatile U_WBC_CMP_RC_CFG3 WBC_CMP_RC_CFG3;                                       /* 0xbf10 */
+    volatile U_WBC_CMP_RC_CFG4 WBC_CMP_RC_CFG4;                                       /* 0xbf14 */
+    volatile U_WBC_CMP_RC_CFG5 WBC_CMP_RC_CFG5;                                       /* 0xbf18 */
+    volatile U_WBC_CMP_RC_CFG6 WBC_CMP_RC_CFG6;                                       /* 0xbf1c */
+    volatile U_WBC_CMP_RC_CFG7 WBC_CMP_RC_CFG7;                                       /* 0xbf20 */
+    volatile U_WBC_CMP_RC_CFG8 WBC_CMP_RC_CFG8;                                       /* 0xbf24 */
+    volatile U_WBC_CMP_RC_CFG10 WBC_CMP_RC_CFG10;                                     /* 0xbf28 */
+    volatile U_WBC_CMP_OUTSIZE0 WBC_CMP_OUTSIZE0;                                     /* 0xbf2c */
+    volatile unsigned int WBC_CMP_DBG_REG0;                                           /* 0xbf30 */
+    volatile U_WBC_CMP_MAX_ROW WBC_CMP_MAX_ROW;                                       /* 0xbf34 */
+    volatile U_WBC_BMP_CTRL WBC_BMP_CTRL;                                             /* 0xbf38 */
+    volatile U_WBC_BMP_UPD WBC_BMP_UPD;                                               /* 0xbf3c */
+    volatile unsigned int WBC_BMP_YADDR;                                              /* 0xbf40 */
+    volatile unsigned int reserved_79[23];                                            /* 0xbf44~0xbf9c */
+    volatile U_WBC_BMP_ORESO WBC_BMP_ORESO;                                           /* 0xbfa0 */
+    volatile U_WBC_BMP_SUM WBC_BMP_SUM;                                               /* 0xbfa4 */
+    volatile unsigned int reserved_80[18];                                            /* 0xbfa8~0xbfec */
+    volatile unsigned int WBC_BMP_CHECKSUM_Y;                                         /* 0xbff0 */
+    volatile unsigned int WBC_BMP_CHECKSUM_C;                                         /* 0xbff4 */
+    volatile unsigned int reserved_81[2];                                             /* 0xbff8~0xbffc */
+    volatile U_WBC_DHD0_CTRL WBC_DHD0_CTRL;                                           /* 0xc000 */
+    volatile U_WBC_DHD0_UPD WBC_DHD0_UPD;                                             /* 0xc004 */
+    volatile U_WBC_DHD0_ORESO WBC_DHD0_ORESO;                                         /* 0xc008 */
+    volatile unsigned int reserved_82[29];                                            /* 0xc00c~0xc07c */
+    volatile U_WD_HPZME_CTRL WD_HPZME_CTRL;                                           /* 0xc080 */
+    volatile U_WD_HPZMECOEF01 WD_HPZMECOEF01;                                         /* 0xc084 */
+    volatile U_WD_HPZMECOEF23 WD_HPZMECOEF23;                                         /* 0xc088 */
+    volatile U_WD_HPZMECOEF45 WD_HPZMECOEF45;                                         /* 0xc08c */
+    volatile U_WD_HPZMECOEF67 WD_HPZMECOEF67;                                         /* 0xc090 */
+    volatile unsigned int reserved_83[91];                                            /* 0xc094~0xc1fc */
+    volatile U_WD_HCDS_CTRL WD_HCDS_CTRL;                                             /* 0xc200 */
+    volatile U_WD_HCDSCOEF01 WD_HCDSCOEF01;                                           /* 0xc204 */
+    volatile U_WD_HCDSCOEF23 WD_HCDSCOEF23;                                           /* 0xc208 */
+    volatile U_WD_HCDSCOEF45 WD_HCDSCOEF45;                                           /* 0xc20c */
+    volatile U_WD_HCDSCOEF67 WD_HCDSCOEF67;                                           /* 0xc210 */
+    volatile unsigned int reserved_84[27];                                            /* 0xc214~0xc27c */
+    volatile U_DITHER_CTRL DITHER_CTRL;                                               /* 0xc280 */
+    volatile U_DITHER_SED_Y0 DITHER_SED_Y0;                                           /* 0xc284 */
+    volatile U_DITHER_SED_U0 DITHER_SED_U0;                                           /* 0xc288 */
+    volatile U_DITHER_SED_V0 DITHER_SED_V0;                                           /* 0xc28c */
+    volatile U_DITHER_SED_W0 DITHER_SED_W0;                                           /* 0xc290 */
+    volatile U_DITHER_SED_Y1 DITHER_SED_Y1;                                           /* 0xc294 */
+    volatile U_DITHER_SED_U1 DITHER_SED_U1;                                           /* 0xc298 */
+    volatile U_DITHER_SED_V1 DITHER_SED_V1;                                           /* 0xc29c */
+    volatile U_DITHER_SED_W1 DITHER_SED_W1;                                           /* 0xc2a0 */
+    volatile U_DITHER_SED_Y2 DITHER_SED_Y2;                                           /* 0xc2a4 */
+    volatile U_DITHER_SED_U2 DITHER_SED_U2;                                           /* 0xc2a8 */
+    volatile U_DITHER_SED_V2 DITHER_SED_V2;                                           /* 0xc2ac */
+    volatile U_DITHER_SED_W2 DITHER_SED_W2;                                           /* 0xc2b0 */
+    volatile U_DITHER_SED_Y3 DITHER_SED_Y3;                                           /* 0xc2b4 */
+    volatile U_DITHER_SED_U3 DITHER_SED_U3;                                           /* 0xc2b8 */
+    volatile U_DITHER_SED_V3 DITHER_SED_V3;                                           /* 0xc2bc */
+    volatile U_DITHER_SED_W3 DITHER_SED_W3;                                           /* 0xc2c0 */
+    volatile U_DITHER_THR DITHER_THR;                                                 /* 0xc2c4 */
+    volatile unsigned int reserved_85[14];                                            /* 0xc2c8~0xc2fc */
+    volatile U_WD_ZME_HINFO WD_ZME_HINFO;                                             /* 0xc300 */
+    volatile U_WD_ZME_HSP WD_ZME_HSP;                                                 /* 0xc304 */
+    volatile U_WD_ZME_HLOFFSET WD_ZME_HLOFFSET;                                       /* 0xc308 */
+    volatile U_WD_ZME_HCOFFSET WD_ZME_HCOFFSET;                                       /* 0xc30c */
+    volatile unsigned int reserved_86[5];                                             /* 0xc310~0xc320 */
+    volatile U_WD_ZME_HCOEF_REN WD_ZME_HCOEF_REN;                                     /* 0xc324 */
+    volatile U_WD_ZME_HCOEF_RDATA WD_ZME_HCOEF_RDATA;                                 /* 0xc328 */
+    volatile U_WD_ZME_HDRAW WD_ZME_HDRAW;                                             /* 0xc32c */
+    volatile U_WD_ZME_HRATIO WD_ZME_HRATIO;                                           /* 0xc330 */
+    volatile unsigned int reserved_87[51];                                            /* 0xc334~0xc3fc */
+    volatile U_WD_ZME_VINFO WD_ZME_VINFO;                                             /* 0xc400 */
+    volatile U_WD_ZME_VSP WD_ZME_VSP;                                                 /* 0xc404 */
+    volatile U_WD_ZME_VOFFSET WD_ZME_VOFFSET;                                         /* 0xc408 */
+    volatile U_WD_ZME_VBOFFSET WD_ZME_VBOFFSET;                                       /* 0xc40c */
+    volatile unsigned int reserved_88[5];                                             /* 0xc410~0xc420 */
+    volatile U_WD_ZME_VCOEF_REN WD_ZME_VCOEF_REN;                                     /* 0xc424 */
+    volatile U_WD_ZME_VCOEF_RDATA WD_ZME_VCOEF_RDATA;                                 /* 0xc428 */
+    volatile U_WD_ZME_VDRAW WD_ZME_VDRAW;                                             /* 0xc42c */
+    volatile U_WD_ZME_VRATIO WD_ZME_VRATIO;                                           /* 0xc430 */
+    volatile unsigned int reserved_89[755];                                           /* 0xc434~0xcffc */
+    volatile U_DHD0_CTRL DHD0_CTRL;                                                   /* 0xd000 */
+    volatile U_DHD0_VSYNC1 DHD0_VSYNC1;                                               /* 0xd004 */
+    volatile U_DHD0_VSYNC2 DHD0_VSYNC2;                                               /* 0xd008 */
+    volatile U_DHD0_HSYNC1 DHD0_HSYNC1;                                               /* 0xd00c */
+    volatile U_DHD0_HSYNC2 DHD0_HSYNC2;                                               /* 0xd010 */
+    volatile U_DHD0_VPLUS1 DHD0_VPLUS1;                                               /* 0xd014 */
+    volatile U_DHD0_VPLUS2 DHD0_VPLUS2;                                               /* 0xd018 */
+    volatile U_DHD0_PWR DHD0_PWR;                                                     /* 0xd01c */
+    volatile U_DHD0_VTTHD3 DHD0_VTTHD3;                                               /* 0xd020 */
+    volatile U_DHD0_VTTHD DHD0_VTTHD;                                                 /* 0xd024 */
+    volatile U_DHD0_PARATHD DHD0_PARATHD;                                             /* 0xd028 */
+    volatile U_DHD0_PRECHARGE_THD DHD0_PRECHARGE_THD;                                 /* 0xd02c */
+    volatile U_DHD0_START_POS DHD0_START_POS;                                         /* 0xd030 */
+    volatile U_DHD0_START_POS1 DHD0_START_POS1;                                       /* 0xd034 */
+    volatile U_DHD0_PARAUP DHD0_PARAUP;                                               /* 0xd038 */
+    volatile U_DHD0_SYNC_INV DHD0_SYNC_INV;                                           /* 0xd03c */
+    volatile U_DHD0_CLK_DV_CTRL DHD0_CLK_DV_CTRL;                                     /* 0xd040 */
+    volatile U_DHD0_RGB_FIX_CTRL DHD0_RGB_FIX_CTRL;                                   /* 0xd044 */
+    volatile U_DHD0_LOCKCFG DHD0_LOCKCFG;                                             /* 0xd048 */
+    volatile unsigned int DHD0_CAP_FRM_CNT;                                           /* 0xd04c */
+    volatile unsigned int DHD0_VDP_FRM_CNT;                                           /* 0xd050 */
+    volatile unsigned int DHD0_VSYNC_CAP_VDP_CNT;                                     /* 0xd054 */
+    volatile unsigned int DHD0_INTF_CHKSUM_Y;                                         /* 0xd058 */
+    volatile unsigned int DHD0_INTF_CHKSUM_U;                                         /* 0xd05c */
+    volatile unsigned int DHD0_INTF_CHKSUM_V;                                         /* 0xd060 */
+    volatile unsigned int DHD0_INTF1_CHKSUM_Y;                                        /* 0xd064 */
+    volatile unsigned int DHD0_INTF1_CHKSUM_U;                                        /* 0xd068 */
+    volatile unsigned int DHD0_INTF1_CHKSUM_V;                                        /* 0xd06c */
+    volatile U_DHD0_INTF_CHKSUM_HIGH1 DHD0_INTF_CHKSUM_HIGH1;                         /* 0xd070 */
+    volatile U_DHD0_INTF_CHKSUM_HIGH2 DHD0_INTF_CHKSUM_HIGH2;                         /* 0xd074 */
+    volatile unsigned int reserved_90[3];                                             /* 0xd078~0xd080 */
+    volatile unsigned int DHD0_AFIFO_PRE_THD;                                         /* 0xd084 */
+    volatile U_DHD0_STATE DHD0_STATE;                                                 /* 0xd088 */
+    volatile U_DHD0_UF_STATE DHD0_UF_STATE;                                           /* 0xd08c */
+    volatile U_VO_MUX VO_MUX;                                                         /* 0xd090 */
+    volatile U_VO_MUX_SYNC VO_MUX_SYNC;                                               /* 0xd094 */
+    volatile U_VO_MUX_DATA VO_MUX_DATA;                                               /* 0xd098 */
+    volatile unsigned int reserved_91_1;                                              /* 0xd09c */
+    volatile U_DHD0_VSYNC_TE_STATE DHD0_VSYNC_TE_STATE;                               /* 0xd0a0 */
+    volatile U_DHD0_VSYNC_TE_STATE1 DHD0_VSYNC_TE_STATE1;                             /* 0xd0a4 */
+    volatile unsigned int reserved_91_2[2];                                           /* 0xd0a8~0xd0ac */
+    volatile U_INTF0_DITHER_CTRL INTF0_DITHER_CTRL;                                   /* 0xd0b0 */
+    volatile U_INTF0_DITHER_SED_Y0 INTF0_DITHER_SED_Y0;                               /* 0xd0b4 */
+    volatile U_INTF0_DITHER_SED_U0 INTF0_DITHER_SED_U0;                               /* 0xd0b8 */
+    volatile U_INTF0_DITHER_SED_V0 INTF0_DITHER_SED_V0;                               /* 0xd0bc */
+    volatile U_INTF0_DITHER_SED_W0 INTF0_DITHER_SED_W0;                               /* 0xd0c0 */
+    volatile U_INTF0_DITHER_SED_Y1 INTF0_DITHER_SED_Y1;                               /* 0xd0c4 */
+    volatile U_INTF0_DITHER_SED_U1 INTF0_DITHER_SED_U1;                               /* 0xd0c8 */
+    volatile U_INTF0_DITHER_SED_V1 INTF0_DITHER_SED_V1;                               /* 0xd0cc */
+    volatile U_INTF0_DITHER_SED_W1 INTF0_DITHER_SED_W1;                               /* 0xd0d0 */
+    volatile U_INTF0_DITHER_SED_Y2 INTF0_DITHER_SED_Y2;                               /* 0xd0d4 */
+    volatile U_INTF0_DITHER_SED_U2 INTF0_DITHER_SED_U2;                               /* 0xd0d8 */
+    volatile U_INTF0_DITHER_SED_V2 INTF0_DITHER_SED_V2;                               /* 0xd0dc */
+    volatile U_INTF0_DITHER_SED_W2 INTF0_DITHER_SED_W2;                               /* 0xd0e0 */
+    volatile U_INTF0_DITHER_SED_Y3 INTF0_DITHER_SED_Y3;                               /* 0xd0e4 */
+    volatile U_INTF0_DITHER_SED_U3 INTF0_DITHER_SED_U3;                               /* 0xd0e8 */
+    volatile U_INTF0_DITHER_SED_V3 INTF0_DITHER_SED_V3;                               /* 0xd0ec */
+    volatile U_INTF0_DITHER_SED_W3 INTF0_DITHER_SED_W3;                               /* 0xd0f0 */
+    volatile U_INTF0_DITHER_THR INTF0_DITHER_THR;                                     /* 0xd0f4 */
+    volatile unsigned int reserved_92[2];                                             /* 0xd0f8~0xd0fc */
+    volatile U_INTF_HDMI_CTRL INTF_HDMI_CTRL;                                         /* 0xd100 */
+    volatile U_INTF_HDMI_UPD INTF_HDMI_UPD;                                           /* 0xd104 */
+    volatile U_INTF_HDMI_SYNC_INV INTF_HDMI_SYNC_INV;                                 /* 0xd108 */
+    volatile unsigned int reserved_93;                                                /* 0xd10c */
+    volatile unsigned int HDMI_INTF_CHKSUM_Y;                                         /* 0xd110 */
+    volatile unsigned int HDMI_INTF_CHKSUM_U;                                         /* 0xd114 */
+    volatile unsigned int HDMI_INTF_CHKSUM_V;                                         /* 0xd118 */
+    volatile U_HDMI_INTF_CHKSUM_HIGH HDMI_INTF_CHKSUM_HIGH;                           /* 0xd11c */
+    volatile unsigned int HDMI_INTF1_CHKSUM_Y;                                        /* 0xd120 */
+    volatile unsigned int HDMI_INTF1_CHKSUM_U;                                        /* 0xd124 */
+    volatile unsigned int HDMI_INTF1_CHKSUM_V;                                        /* 0xd128 */
+    volatile U_HDMI_INTF1_CHKSUM_HIGH HDMI_INTF1_CHKSUM_HIGH;                         /* 0xd12c */
+    volatile unsigned int reserved_94[8];                                             /* 0xd130~0xd14c */
+    volatile U_HDMI_HFIR_COEF0 HDMI_HFIR_COEF0;                                       /* 0xd150 */
+    volatile U_HDMI_HFIR_COEF1 HDMI_HFIR_COEF1;                                       /* 0xd154 */
+    volatile U_HDMI_HFIR_COEF2 HDMI_HFIR_COEF2;                                       /* 0xd158 */
+    volatile U_HDMI_HFIR_COEF3 HDMI_HFIR_COEF3;                                       /* 0xd15c */
+    volatile unsigned int reserved_95[8];                                             /* 0xd160~0xd17c */
+    volatile U_INTF_MIPI_CTRL INTF_MIPI_CTRL;                                         /* 0xd180 */
+    volatile U_INTF_MIPI_UPD INTF_MIPI_UPD;                                           /* 0xd184 */
+    volatile U_INTF_MIPI_SYNC_INV INTF_MIPI_SYNC_INV;                                 /* 0xd188 */
+    volatile unsigned int reserved_96;                                                /* 0xd18c */
+    volatile unsigned int MIPI_INTF_CHKSUM_Y;                                         /* 0xd190 */
+    volatile unsigned int MIPI_INTF_CHKSUM_U;                                         /* 0xd194 */
+    volatile unsigned int MIPI_INTF_CHKSUM_V;                                         /* 0xd198 */
+    volatile U_MIPI_INTF_CHKSUM_HIGH MIPI_INTF_CHKSUM_HIGH;                           /* 0xd19c */
+    volatile unsigned int MIPI_INTF1_CHKSUM_Y;                                        /* 0xd1a0 */
+    volatile unsigned int MIPI_INTF1_CHKSUM_U;                                        /* 0xd1a4 */
+    volatile unsigned int MIPI_INTF1_CHKSUM_V;                                        /* 0xd1a8 */
+    volatile U_MIPI_INTF1_CHKSUM_HIGH MIPI_INTF1_CHKSUM_HIGH;                         /* 0xd1ac */
+    volatile unsigned int reserved_97[8];                                             /* 0xd1b0~0xd1cc */
+    volatile U_MIPI_HFIR_COEF0 MIPI_HFIR_COEF0;                                       /* 0xd1d0 */
+    volatile U_MIPI_HFIR_COEF1 MIPI_HFIR_COEF1;                                       /* 0xd1d4 */
+    volatile U_MIPI_HFIR_COEF2 MIPI_HFIR_COEF2;                                       /* 0xd1d8 */
+    volatile U_MIPI_HFIR_COEF3 MIPI_HFIR_COEF3;                                       /* 0xd1dc */
+    volatile unsigned int reserved_98[8];                                             /* 0xd1e0~0xd1fc */
+    volatile U_INTF_BT_CTRL INTF_BT_CTRL;                                             /* 0xd200 */
+    volatile U_INTF_BT_UPD INTF_BT_UPD;                                               /* 0xd204 */
+    volatile U_INTF_BT_SYNC_INV INTF_BT_SYNC_INV;                                     /* 0xd208 */
+    volatile unsigned int reserved_99;                                                /* 0xd20c */
+    volatile U_BT_CLIP0_L BT_CLIP0_L;                                                 /* 0xd210 */
+    volatile U_BT_CLIP0_H BT_CLIP0_H;                                                 /* 0xd214 */
+    volatile unsigned int reserved_100[26];                                           /* 0xd218~0xd27c */
+    volatile U_BT_DITHER_CTRL BT_DITHER_CTRL;                                         /* 0xd280 */
+    volatile U_BT_DITHER_SED_Y0 BT_DITHER_SED_Y0;                                     /* 0xd284 */
+    volatile U_BT_DITHER_SED_U0 BT_DITHER_SED_U0;                                     /* 0xd288 */
+    volatile U_BT_DITHER_SED_V0 BT_DITHER_SED_V0;                                     /* 0xd28c */
+    volatile U_BT_DITHER_SED_W0 BT_DITHER_SED_W0;                                     /* 0xd290 */
+    volatile U_BT_DITHER_SED_Y1 BT_DITHER_SED_Y1;                                     /* 0xd294 */
+    volatile U_BT_DITHER_SED_U1 BT_DITHER_SED_U1;                                     /* 0xd298 */
+    volatile U_BT_DITHER_SED_V1 BT_DITHER_SED_V1;                                     /* 0xd29c */
+    volatile U_BT_DITHER_SED_W1 BT_DITHER_SED_W1;                                     /* 0xd2a0 */
+    volatile U_BT_DITHER_SED_Y2 BT_DITHER_SED_Y2;                                     /* 0xd2a4 */
+    volatile U_BT_DITHER_SED_U2 BT_DITHER_SED_U2;                                     /* 0xd2a8 */
+    volatile U_BT_DITHER_SED_V2 BT_DITHER_SED_V2;                                     /* 0xd2ac */
+    volatile U_BT_DITHER_SED_W2 BT_DITHER_SED_W2;                                     /* 0xd2b0 */
+    volatile U_BT_DITHER_SED_Y3 BT_DITHER_SED_Y3;                                     /* 0xd2b4 */
+    volatile U_BT_DITHER_SED_U3 BT_DITHER_SED_U3;                                     /* 0xd2b8 */
+    volatile U_BT_DITHER_SED_V3 BT_DITHER_SED_V3;                                     /* 0xd2bc */
+    volatile U_BT_DITHER_SED_W3 BT_DITHER_SED_W3;                                     /* 0xd2c0 */
+    volatile U_BT_DITHER_THR BT_DITHER_THR;                                           /* 0xd2c4 */
+    volatile unsigned int reserved_101[10];                                           /* 0xd2c8~0xd2ec */
+    volatile unsigned int BT_INTF_CHKSUM_Y;                                           /* 0xd2f0 */
+    volatile unsigned int BT_INTF_CHKSUM_U;                                           /* 0xd2f4 */
+    volatile unsigned int BT_INTF_CHKSUM_V;                                           /* 0xd2f8 */
+    volatile unsigned int reserved_102;                                               /* 0xd2fc */
+    volatile U_INTF_LCD_CTRL INTF_LCD_CTRL;                                           /* 0xd300 */
+    volatile U_INTF_LCD_UPD INTF_LCD_UPD;                                             /* 0xd304 */
+    volatile U_INTF_LCD_SYNC_INV INTF_LCD_SYNC_INV;                                   /* 0xd308 */
+    volatile unsigned int reserved_103[29];                                           /* 0xd30c~0xd37c */
+    volatile U_LCD_DITHER_CTRL LCD_DITHER_CTRL;                                       /* 0xd380 */
+    volatile U_LCD_DITHER_SED_Y0 LCD_DITHER_SED_Y0;                                   /* 0xd384 */
+    volatile U_LCD_DITHER_SED_U0 LCD_DITHER_SED_U0;                                   /* 0xd388 */
+    volatile U_LCD_DITHER_SED_V0 LCD_DITHER_SED_V0;                                   /* 0xd38c */
+    volatile U_LCD_DITHER_SED_W0 LCD_DITHER_SED_W0;                                   /* 0xd390 */
+    volatile U_LCD_DITHER_SED_Y1 LCD_DITHER_SED_Y1;                                   /* 0xd394 */
+    volatile U_LCD_DITHER_SED_U1 LCD_DITHER_SED_U1;                                   /* 0xd398 */
+    volatile U_LCD_DITHER_SED_V1 LCD_DITHER_SED_V1;                                   /* 0xd39c */
+    volatile U_LCD_DITHER_SED_W1 LCD_DITHER_SED_W1;                                   /* 0xd3a0 */
+    volatile U_LCD_DITHER_SED_Y2 LCD_DITHER_SED_Y2;                                   /* 0xd3a4 */
+    volatile U_LCD_DITHER_SED_U2 LCD_DITHER_SED_U2;                                   /* 0xd3a8 */
+    volatile U_LCD_DITHER_SED_V2 LCD_DITHER_SED_V2;                                   /* 0xd3ac */
+    volatile U_LCD_DITHER_SED_W2 LCD_DITHER_SED_W2;                                   /* 0xd3b0 */
+    volatile U_LCD_DITHER_SED_Y3 LCD_DITHER_SED_Y3;                                   /* 0xd3b4 */
+    volatile U_LCD_DITHER_SED_U3 LCD_DITHER_SED_U3;                                   /* 0xd3b8 */
+    volatile U_LCD_DITHER_SED_V3 LCD_DITHER_SED_V3;                                   /* 0xd3bc */
+    volatile U_LCD_DITHER_SED_W3 LCD_DITHER_SED_W3;                                   /* 0xd3c0 */
+    volatile U_LCD_DITHER_THR LCD_DITHER_THR;                                         /* 0xd3c4 */
+    volatile unsigned int reserved_104[10];                                           /* 0xd3c8~0xd3ec */
+    volatile unsigned int LCD_INTF_CHKSUM_Y;                                          /* 0xd3f0 */
+    volatile unsigned int LCD_INTF_CHKSUM_U;                                          /* 0xd3f4 */
+    volatile unsigned int LCD_INTF_CHKSUM_V;                                          /* 0xd3f8 */
+    volatile unsigned int reserved_105[769];                                          /* 0xd3fc~0xdffc */
+    volatile U_DHD1_CTRL DHD1_CTRL;                                                   /* 0xe000 */
+    volatile U_DHD1_VSYNC1 DHD1_VSYNC1;                                               /* 0xe004 */
+    volatile U_DHD1_VSYNC2 DHD1_VSYNC2;                                               /* 0xe008 */
+    volatile U_DHD1_HSYNC1 DHD1_HSYNC1;                                               /* 0xe00c */
+    volatile U_DHD1_HSYNC2 DHD1_HSYNC2;                                               /* 0xe010 */
+    volatile U_DHD1_VPLUS1 DHD1_VPLUS1;                                               /* 0xe014 */
+    volatile U_DHD1_VPLUS2 DHD1_VPLUS2;                                               /* 0xe018 */
+    volatile U_DHD1_PWR DHD1_PWR;                                                     /* 0xe01c */
+    volatile U_DHD1_VTTHD3 DHD1_VTTHD3;                                               /* 0xe020 */
+    volatile U_DHD1_VTTHD DHD1_VTTHD;                                                 /* 0xe024 */
+    volatile U_DHD1_PARATHD DHD1_PARATHD;                                             /* 0xe028 */
+    volatile U_DHD1_PRECHARGE_THD DHD1_PRECHARGE_THD;                                 /* 0xe02c */
+    volatile U_DHD1_START_POS DHD1_START_POS;                                         /* 0xe030 */
+    volatile U_DHD1_START_POS1 DHD1_START_POS1;                                       /* 0xe034 */
+    volatile U_DHD1_PARAUP DHD1_PARAUP;                                               /* 0xe038 */
+    volatile U_DHD1_SYNC_INV DHD1_SYNC_INV;                                           /* 0xe03c */
+    volatile U_DHD1_CLK_DV_CTRL DHD1_CLK_DV_CTRL;                                     /* 0xe040 */
+    volatile U_DHD1_RGB_FIX_CTRL DHD1_RGB_FIX_CTRL;                                   /* 0xe044 */
+    volatile U_DHD1_LOCKCFG DHD1_LOCKCFG;                                             /* 0xe048 */
+    volatile unsigned int DHD1_CAP_FRM_CNT;                                           /* 0xe04c */
+    volatile unsigned int DHD1_VDP_FRM_CNT;                                           /* 0xe050 */
+    volatile unsigned int DHD1_VSYNC_CAP_VDP_CNT;                                     /* 0xe054 */
+    volatile unsigned int DHD1_INTF_CHKSUM_Y;                                         /* 0xe058 */
+    volatile unsigned int DHD1_INTF_CHKSUM_U;                                         /* 0xe05c */
+    volatile unsigned int DHD1_INTF_CHKSUM_V;                                         /* 0xe060 */
+    volatile unsigned int DHD1_INTF1_CHKSUM_Y;                                        /* 0xe064 */
+    volatile unsigned int DHD1_INTF1_CHKSUM_U;                                        /* 0xe068 */
+    volatile unsigned int DHD1_INTF1_CHKSUM_V;                                        /* 0xe06c */
+    volatile U_DHD1_INTF_CHKSUM_HIGH1 DHD1_INTF_CHKSUM_HIGH1;                         /* 0xe070 */
+    volatile U_DHD1_INTF_CHKSUM_HIGH2 DHD1_INTF_CHKSUM_HIGH2;                         /* 0xe074 */
+    volatile unsigned int reserved_106[3];                                            /* 0xe078~0xe080 */
+    volatile unsigned int DHD1_AFIFO_PRE_THD;                                         /* 0xe084 */
+    volatile U_DHD1_STATE DHD1_STATE;                                                 /* 0xe088 */
+    volatile U_DHD1_UF_STATE DHD1_UF_STATE;                                           /* 0xe08c */
+    volatile unsigned int reserved_107[4];                                            /* 0xe090~0xe09c */
+    volatile U_DHD1_VSYNC_TE_STATE DHD1_VSYNC_TE_STATE;                               /* 0xe0a0 */
+    volatile U_DHD1_VSYNC_TE_STATE1 DHD1_VSYNC_TE_STATE1;                             /* 0xe0a4 */
+    volatile unsigned int reserved_107_1[2];                                          /* 0xe0a8~0xe0ac */
+    volatile U_INTF1_DITHER_CTRL INTF1_DITHER_CTRL;                                   /* 0xe0b0 */
+    volatile U_INTF1_DITHER_SED_Y0 INTF1_DITHER_SED_Y0;                               /* 0xe0b4 */
+    volatile U_INTF1_DITHER_SED_U0 INTF1_DITHER_SED_U0;                               /* 0xe0b8 */
+    volatile U_INTF1_DITHER_SED_V0 INTF1_DITHER_SED_V0;                               /* 0xe0bc */
+    volatile U_INTF1_DITHER_SED_W0 INTF1_DITHER_SED_W0;                               /* 0xe0c0 */
+    volatile U_INTF1_DITHER_SED_Y1 INTF1_DITHER_SED_Y1;                               /* 0xe0c4 */
+    volatile U_INTF1_DITHER_SED_U1 INTF1_DITHER_SED_U1;                               /* 0xe0c8 */
+    volatile U_INTF1_DITHER_SED_V1 INTF1_DITHER_SED_V1;                               /* 0xe0cc */
+    volatile U_INTF1_DITHER_SED_W1 INTF1_DITHER_SED_W1;                               /* 0xe0d0 */
+    volatile U_INTF1_DITHER_SED_Y2 INTF1_DITHER_SED_Y2;                               /* 0xe0d4 */
+    volatile U_INTF1_DITHER_SED_U2 INTF1_DITHER_SED_U2;                               /* 0xe0d8 */
+    volatile U_INTF1_DITHER_SED_V2 INTF1_DITHER_SED_V2;                               /* 0xe0dc */
+    volatile U_INTF1_DITHER_SED_W2 INTF1_DITHER_SED_W2;                               /* 0xe0e0 */
+    volatile U_INTF1_DITHER_SED_Y3 INTF1_DITHER_SED_Y3;                               /* 0xe0e4 */
+    volatile U_INTF1_DITHER_SED_U3 INTF1_DITHER_SED_U3;                               /* 0xe0e8 */
+    volatile U_INTF1_DITHER_SED_V3 INTF1_DITHER_SED_V3;                               /* 0xe0ec */
+    volatile U_INTF1_DITHER_SED_W3 INTF1_DITHER_SED_W3;                               /* 0xe0f0 */
+    volatile U_INTF1_DITHER_THR INTF1_DITHER_THR;                                     /* 0xe0f4 */
+    volatile unsigned int reserved_108[1986];                                         /* 0xe0f8~0xfffc */
+    volatile U_MAC_OUTSTANDING MAC_OUTSTANDING;                                       /* 0x10000 */
+    volatile U_MAC_CTRL MAC_CTRL;                                                     /* 0x10004 */
+    unsigned int reserved_113[2];                                                     /* 0x10008~0x1000c */
+    volatile U_MAC_RCHN_PRIO MAC_RCHN_PRIO;                                           /* 0x10010 */
+    unsigned int reserved_114;                                                        /* 0x10014 */
+    volatile U_MAC_WCHN_PRIO MAC_WCHN_PRIO;                                           /* 0x10018 */
+    unsigned int reserved_115;                                                        /* 0x1001c */
+    volatile U_MAC_RCHN_SEL0 MAC_RCHN_SEL0;                                           /* 0x10020 */
+    volatile unsigned int MAC_RCHN_SEL1;                                              /* 0x10024 */
+    unsigned int reserved_116[2];                                                     /* 0x10028~0x1002c */
+    volatile U_MAC_WCHN_SEL0 MAC_WCHN_SEL0;                                           /* 0x10030 */
+    unsigned int reserved_117[3];                                                     /* 0x10034~0x1003c */
+    volatile U_MAC_BUS_ERR_CLR MAC_BUS_ERR_CLR;                                       /* 0x10040 */
+    volatile U_MAC_BUS_ERR MAC_BUS_ERR;                                               /* 0x10044 */
+    unsigned int reserved_118[2];                                                     /* 0x10048~0x1004c */
+    volatile unsigned int MAC_SRC0_STATUS0;                                           /* 0x10050 */
+    volatile unsigned int MAC_SRC0_STATUS1;                                           /* 0x10054 */
+    volatile unsigned int MAC_SRC1_STATUS0;                                           /* 0x10058 */
+    volatile unsigned int MAC_SRC1_STATUS1;                                           /* 0x1005c */
+    volatile unsigned int MAC_SRC2_STATUS0;                                           /* 0x10060 */
+    volatile unsigned int MAC_SRC2_STATUS1;                                           /* 0x10064 */
+    volatile unsigned int reserved_119[2];                                            /* 0x10068~0x1006c */
+    volatile U_MAC_DEBUG_CTRL MAC_DEBUG_CTRL;                                         /* 0x10070 */
+    volatile U_MAC_DEBUG_CLR MAC_DEBUG_CLR;                                           /* 0x10074 */
+    unsigned int reserved_120[2];                                                     /* 0x10078~0x1007c */
+    volatile unsigned int MAC0_DEBUG_INFO;                                            /* 0x10080 */
+    unsigned int reserved_121[3];                                                     /* 0x10084~0x1008c */
+    volatile unsigned int MAC0_RD_INFO;                                               /* 0x10090 */
+    volatile unsigned int MAC0_WR_INFO;                                               /* 0x10094 */
+    volatile unsigned int MAC1_RD_INFO;                                               /* 0x10098 */
+    volatile unsigned int MAC1_WR_INFO;                                               /* 0x1009c */
+    volatile unsigned int MAC2_RD_INFO;                                               /* 0x100a0 */
+    volatile unsigned int MAC2_WR_INFO;                                               /* 0x100a4 */
+    unsigned int reserved_122[2];                                                     /* 0x100a8~0x100ac */
+    volatile unsigned int MAC0_DET_LATENCY0;                                          /* 0x100b0 */
+    volatile unsigned int MAC0_DET_LATENCY1;                                          /* 0x100b4 */
+    volatile unsigned int MAC0_DET_LATENCY2;                                          /* 0x100b8 */
+    volatile unsigned int MAC0_DET_LATENCY3;                                          /* 0x100bc */
+    volatile unsigned int MAC0_DET_LATENCY4;                                          /* 0x100c0 */
+    volatile unsigned int MAC0_DET_LATENCY5;                                          /* 0x100c4 */
+    volatile unsigned int MAC1_DET_LATENCY0;                                          /* 0x100c8 */
+    volatile unsigned int MAC1_DET_LATENCY1;                                          /* 0x100cc */
+    volatile unsigned int MAC1_DET_LATENCY2;                                          /* 0x100d0 */
+    volatile unsigned int MAC1_DET_LATENCY3;                                          /* 0x100d4 */
+    volatile unsigned int MAC1_DET_LATENCY4;                                          /* 0x100d8 */
+    volatile unsigned int MAC1_DET_LATENCY5;                                          /* 0x100dc */
+    unsigned int reserved_123[72];                                                    /* 0x100e0~0x101fc */
+    volatile U_VID_READ_CTRL VID_READ_CTRL;                                           /* 0x10200 */
+    volatile U_VID_MAC_CTRL VID_MAC_CTRL;                                             /* 0x10204 */
+    volatile unsigned int reserved_124[2];                                            /* 0x10208~0x1020c */
+    volatile U_VID_OUT_CTRL VID_OUT_CTRL;                                             /* 0x10210 */
+    volatile U_VID_MUTE_ALPHA VID_MUTE_ALPHA;                                         /* 0x10214 */
+    volatile unsigned int reserved_125;                                               /* 0x10218 */
+    volatile U_VID_MUTE_BK VID_MUTE_BK;                                               /* 0x1021c */
+    volatile unsigned int reserved_126[8];                                            /* 0x10220~0x1023c */
+    volatile U_VID_SRC_INFO VID_SRC_INFO;                                             /* 0x10240 */
+    volatile U_VID_SRC_RESO VID_SRC_RESO;                                             /* 0x10244 */
+    volatile U_VID_SRC_CROP VID_SRC_CROP;                                             /* 0x10248 */
+    volatile U_VID_IN_RESO VID_IN_RESO;                                               /* 0x1024c */
+    volatile unsigned int VID_ADDR_H;                                                 /* 0x10250 */
+    volatile unsigned int VID_ADDR_L;                                                 /* 0x10254 */
+    volatile unsigned int VID_CADDR_H;                                                /* 0x10258 */
+    volatile unsigned int VID_CADDR_L;                                                /* 0x1025c */
+    volatile unsigned int VID_NADDR_H;                                                /* 0x10260 */
+    volatile unsigned int VID_NADDR_L;                                                /* 0x10264 */
+    volatile unsigned int VID_NCADDR_H;                                               /* 0x10268 */
+    volatile unsigned int VID_NCADDR_L;                                               /* 0x1026c */
+    volatile U_VID_STRIDE VID_STRIDE;                                                 /* 0x10270 */
+    volatile U_VID_2BIT_STRIDE VID_2BIT_STRIDE;                                       /* 0x10274 */
+    volatile U_VID_HEAD_STRIDE VID_HEAD_STRIDE;                                       /* 0x10278 */
+    volatile unsigned int reserved_127;                                               /* 0x1027c */
+    volatile U_VID_SMMU_BYPASS VID_SMMU_BYPASS;                                       /* 0x10280 */
+    volatile unsigned int reserved_128[3];                                            /* 0x10284~0x1028c */
+    volatile unsigned int VID_HEAD_ADDR_H;                                            /* 0x10290 */
+    volatile unsigned int VID_HEAD_ADDR_L;                                            /* 0x10294 */
+    volatile unsigned int VID_HEAD_CADDR_H;                                           /* 0x10298 */
+    volatile unsigned int VID_HEAD_CADDR_L;                                           /* 0x1029c */
+    volatile U_VID_TESTPAT_CFG VID_TESTPAT_CFG;                                       /* 0x102a0 */
+    volatile U_VID_TESTPAT_SEED VID_TESTPAT_SEED;                                     /* 0x102a4 */
+    volatile unsigned int VID_TESTPAT_CHKSUM_Y;                                       /* 0x102a8 */
+    volatile unsigned int VID_TESTPAT_CHKSUM_C;                                       /* 0x102ac */
+    volatile unsigned int reserved_129[20];                                           /* 0x102b0~0x102fc */
+    volatile unsigned int VID_L_CUR_FLOW;                                             /* 0x10300 ---- */
+    volatile unsigned int VID_L_CUR_SREQ_TIME;                                        /* 0x10304 */
+    volatile unsigned int VID_C_CUR_FLOW;                                             /* 0x10308 */
+    volatile unsigned int VID_C_CUR_SREQ_TIME;                                        /* 0x1030c */
+    volatile unsigned int VID_L_LAST_FLOW;                                            /* 0x10310 */
+    volatile unsigned int VID_L_LAST_SREQ_TIME;                                       /* 0x10314 */
+    volatile unsigned int VID_C_LAST_FLOW;                                            /* 0x10318 */
+    volatile unsigned int VID_C_LAST_SREQ_TIME;                                       /* 0x1031c */
+    volatile unsigned int VID_L_BUSY_TIME;                                            /* 0x10320 */
+    volatile unsigned int VID_L_NEEDNORDY_TIME;                                       /* 0x10324 */
+    volatile unsigned int VID_L2_NEEDNORDY_TIME;                                      /* 0x10328 */
+    volatile unsigned int VID_C_BUSY_TIME;                                            /* 0x1032c */
+    volatile unsigned int VID_C_NEEDNORDY_TIME;                                       /* 0x10330 */
+    volatile unsigned int VID_C2_NEEDNORDY_TIME;                                      /* 0x10334 ---- */
+    unsigned int reserved_130[2];                                                     /* 0x10338~0x1033c */
+    volatile U_VID_DCMP_CTRL VID_DCMP_CTRL;                                           /* 0x10340 */
+    volatile unsigned int VID_DCMP_L_FSIZE;                                           /* 0x10344 */
+    unsigned int reserved_131[14];                                                    /* 0x10348~0x1037c */
+    volatile U_ICE_V3R2_SEG_DCMP_GLB_INFO ICE_V3R2_SEG_DCMP_GLB_INFO;                 /* 0x10380 */
+    volatile U_ICE_V3R2_SEG_DCMP_FRAME_SIZE ICE_V3R2_SEG_DCMP_FRAME_SIZE;             /* 0x10384 */
+    unsigned int reserved_132[2];                                                     /* 0x10388~0x1038c */
+    volatile U_ICE_V3R2_SEG_DCMP_ERROR_STA ICE_V3R2_SEG_DCMP_ERROR_STA;               /* 0x10390 */
+    volatile U_ICE_V3R2_SEG_DCMP_DBG_REG ICE_V3R2_SEG_DCMP_DBG_REG;                   /* 0x10394 */
+    unsigned int reserved_133[10];                                                    /* 0x10398~0x103bc */
+    volatile U_ICE_V3R2_SEG_DCMP_GLB_INFO_CHM ICE_V3R2_SEG_DCMP_GLB_INFO_CHM;         /* 0x103c0 */
+    volatile U_ICE_V3R2_SEG_DCMP_FRAME_SIZE_CHM ICE_V3R2_SEG_DCMP_FRAME_SIZE_CHM;     /* 0x103c4 */
+    unsigned int reserved_134[2];                                                     /* 0x103c8~0x103cc */
+    volatile U_ICE_V3R2_SEG_DCMP_ERROR_STA_CHM ICE_V3R2_SEG_DCMP_ERROR_STA_CHM;       /* 0x103d0 */
+    volatile U_ICE_V3R2_SEG_DCMP_DBG_REG_CHM ICE_V3R2_SEG_DCMP_DBG_REG_CHM;           /* 0x103d4 */
+    unsigned int reserved_135[650];                                                   /* 0x103d8~0x10dfc */
+    volatile U_GFX_READ_CTRL GFX_READ_CTRL;                                           /* 0x10e00 */
+    volatile U_GFX_MAC_CTRL GFX_MAC_CTRL;                                             /* 0x10e04 */
+    volatile U_GFX_OUT_CTRL GFX_OUT_CTRL;                                             /* 0x10e08 */
+    volatile unsigned int reserved_136;                                               /* 0x10e0c */
+    volatile U_GFX_MUTE_ALPHA GFX_MUTE_ALPHA;                                         /* 0x10e10 */
+    volatile U_GFX_MUTE_BK GFX_MUTE_BK;                                               /* 0x10e14 */
+    volatile unsigned int reserved_137[2];                                            /* 0x10e18~0x10e1c */
+    volatile U_GFX_SMMU_BYPASS GFX_SMMU_BYPASS;                                       /* 0x10e20 */
+    volatile unsigned int reserved_138;                                               /* 0x10e24 */
+    volatile U_GFX_1555_ALPHA GFX_1555_ALPHA;                                         /* 0x10e28 */
+    volatile unsigned int reserved_139[5];                                            /* 0x10e2c~0x10e3c */
+    volatile U_GFX_SRC_INFO GFX_SRC_INFO;                                             /* 0x10e40 */
+    volatile U_GFX_SRC_RESO GFX_SRC_RESO;                                             /* 0x10e44 */
+    volatile U_GFX_SRC_CROP GFX_SRC_CROP;                                             /* 0x10e48 */
+    volatile U_GFX_IRESO GFX_IRESO;                                                   /* 0x10e4c */
+    volatile unsigned int GFX_ADDR_H;                                                 /* 0x10e50 */
+    volatile unsigned int GFX_ADDR_L;                                                 /* 0x10e54 */
+    volatile unsigned int GFX_NADDR_H;                                                /* 0x10e58 */
+    volatile unsigned int GFX_NADDR_L;                                                /* 0x10e5c */
+    volatile U_GFX_STRIDE GFX_STRIDE;                                                 /* 0x10e60 */
+    volatile unsigned int reserved_140[3];                                            /* 0x10e64~0x10e6c */
+    volatile unsigned int GFX_DCMP_ADDR_H;                                            /* 0x10e70 */
+    volatile unsigned int GFX_DCMP_ADDR_L;                                            /* 0x10e74 */
+    volatile unsigned int GFX_DCMP_NADDR_H;                                           /* 0x10e78 */
+    volatile unsigned int GFX_DCMP_NADDR_L;                                           /* 0x10e7c */
+    volatile unsigned int reserved_141[32];                                           /* 0x10e80~0x10efc */
+    volatile U_GFX_CKEY_MAX GFX_CKEY_MAX;                                             /* 0x10f00 */
+    volatile U_GFX_CKEY_MIN GFX_CKEY_MIN;                                             /* 0x10f04 */
+    volatile U_GFX_CKEY_MASK GFX_CKEY_MASK;                                           /* 0x10f08 */
+    volatile unsigned int reserved_142;                                               /* 0x10f0c */
+    volatile U_GFX_TESTPAT_CFG GFX_TESTPAT_CFG;                                       /* 0x10f10 */
+    volatile U_GFX_TESTPAT_SEED GFX_TESTPAT_SEED;                                     /* 0x10f14 */
+    unsigned int reserved_143[2];                                                     /* 0x10f18~0x10f1c */
+    volatile U_GFX_DCMP_FRAMESIZE0 GFX_DCMP_FRAMESIZE0;                               /* 0x10f20 */
+    volatile U_GFX_DCMP_FRAMESIZE1 GFX_DCMP_FRAMESIZE1;                               /* 0x10f24 */
+    unsigned int reserved_144[2];                                                     /* 0x10f28~0x10f2c */
+    volatile U_GFX_CUR_FLOW GFX_CUR_FLOW;                                             /* 0x10f30 */
+    volatile U_GFX_CUR_SREQ_TIME GFX_CUR_SREQ_TIME;                                   /* 0x10f34 */
+    volatile U_GFX_LAST_FLOW GFX_LAST_FLOW;                                           /* 0x10f38 */
+    volatile U_GFX_LAST_SREQ_TIME GFX_LAST_SREQ_TIME;                                 /* 0x10f3c */
+    volatile U_GFX_BUSY_TIME GFX_BUSY_TIME;                                           /* 0x10f40 */
+    volatile U_GFX_AR_NEEDNORDY_TIME GFX_AR_NEEDNORDY_TIME;                           /* 0x10f44 */
+    volatile U_GFX_GB_NEEDNORDY_TIME GFX_GB_NEEDNORDY_TIME;                           /* 0x10f48 */
+    unsigned int reserved_145[13];                                                    /* 0x10f4c~0x10f7c */
+    volatile U_GFX_DCMP_CTRL GFX_DCMP_CTRL;                                           /* 0x10f80 */
+    volatile unsigned int reserved_146[3];                                            /* 0x10f84~0x10f8c */
+    volatile U_GFX_DCMP_WRONG_STA GFX_DCMP_WRONG_STA;                                 /* 0x10f90 */
+    volatile unsigned int GFX_DCMP_DEBUG_STA0;                                        /* 0x10f94 */
+    volatile unsigned int reserved_147[538];                                          /* 0x10f98~0x117fc */
+    volatile U_WBC_CTRL WBC_CTRL;                                                     /* 0x11800 */
+    volatile U_WBC_MAC_CTRL WBC_MAC_CTRL;                                             /* 0x11804 */
+    volatile unsigned int reserved_148[3];                                            /* 0x11808~0x11810 */
+    volatile U_WBC_SMMU_BYPASS WBC_SMMU_BYPASS;                                       /* 0x11814 */
+    volatile unsigned int reserved_149[2];                                            /* 0x11818~0x1181c */
+    volatile U_WBC_LOWDLYCTRL WBC_LOWDLYCTRL;                                         /* 0x11820 */
+    volatile unsigned int WBC_TUNLADDR_H;                                             /* 0x11824 */
+    volatile unsigned int WBC_TUNLADDR_L;                                             /* 0x11828 */
+    volatile U_WBC_LOWDLYSTA WBC_LOWDLYSTA;                                           /* 0x1182c */
+    volatile unsigned int reserved_150[8];                                            /* 0x11830~0x1184c */
+    volatile unsigned int WBC_YADDR_H;                                                /* 0x11850 */
+    volatile unsigned int WBC_YADDR_L;                                                /* 0x11854 */
+    volatile unsigned int WBC_CADDR_H;                                                /* 0x11858 */
+    volatile unsigned int WBC_CADDR_L;                                                /* 0x1185c */
+    volatile U_WBC_YSTRIDE WBC_YSTRIDE;                                               /* 0x11860 */
+    volatile U_WBC_CSTRIDE WBC_CSTRIDE;                                               /* 0x11864 */
+    volatile unsigned int reserved_151[2];                                            /* 0x11868~0x1186c */
+    volatile unsigned int WBC_YNADDR_H;                                               /* 0x11870 */
+    volatile unsigned int WBC_YNADDR_L;                                               /* 0x11874 */
+    volatile unsigned int WBC_CNADDR_H;                                               /* 0x11878 */
+    volatile unsigned int WBC_CNADDR_L;                                               /* 0x1187c */
+    volatile U_WBC_YNSTRIDE WBC_YNSTRIDE;                                             /* 0x11880 */
+    volatile U_WBC_CNSTRIDE WBC_CNSTRIDE;                                             /* 0x11884 */
+    volatile unsigned int reserved_152[10];                                           /* 0x11888~0x118ac */
+    volatile U_WBC_STA WBC_STA;                                                       /* 0x118b0 */
+    volatile U_WBC_LINE_NUM WBC_LINE_NUM;                                             /* 0x118b4 */
+    volatile U_WBC_CAP_RESO WBC_CAP_RESO;                                             /* 0x118b8 */
+    volatile unsigned int WBC_CAP_INFO;                                               /* 0x118bc */
+    volatile unsigned int reserved_153[16];                                           /* 0x118c0~0x118fc */
+    volatile U_ICE_V2R1_SEG_256X1_CMP_CTRL ICE_V2R1_SEG_256X1_CMP_CTRL;               /* 0x11900 */
+    volatile U_ICE_V2R1_SEG_256X1_CMP_SAD_THR ICE_V2R1_SEG_256X1_CMP_SAD_THR;         /* 0x11904 */
+    volatile U_ICE_V2R1_SEG_256X1_CMP_SIM_THR ICE_V2R1_SEG_256X1_CMP_SIM_THR;         /* 0x11908 */
+    volatile U_ICE_V2R1_SEG_256X1_CMP_RESO ICE_V2R1_SEG_256X1_CMP_RESO;               /* 0x1190c */
+    volatile U_ICE_V2R1_SEG_256X1_CMP_MAX_BIT ICE_V2R1_SEG_256X1_CMP_MAX_BIT;         /* 0x11910 */
+    volatile U_ICE_V2R1_SEG_256X1_CMP_SLC_BIT ICE_V2R1_SEG_256X1_CMP_SLC_BIT;         /* 0x11914 */
+    volatile unsigned int reserved_154[2];                                            /* 0x11918~0x1191c */
+    volatile unsigned int ICE_V2R1_SEG_256X1_CMP_DEBUG;                               /* 0x11920 */
+    volatile unsigned int reserved_155[23];                                           /* 0x11924~0x1197c */
+    volatile U_ICE_V2R1_SEG_256X1_CMP_CTRL_CHM ICE_V2R1_SEG_256X1_CMP_CTRL_CHM;       /* 0x11980 */
+    volatile U_ICE_V2R1_SEG_256X1_CMP_SAD_THR_CHM ICE_V2R1_SEG_256X1_CMP_SAD_THR_CHM; /* 0x11984 */
+    volatile U_ICE_V2R1_SEG_256X1_CMP_SIM_THR_CHM ICE_V2R1_SEG_256X1_CMP_SIM_THR_CHM; /* 0x11988 */
+    volatile U_ICE_V2R1_SEG_256X1_CMP_RESO_CHM ICE_V2R1_SEG_256X1_CMP_RESO_CHM;       /* 0x1198c */
+    volatile U_ICE_V2R1_SEG_256X1_CMP_MAX_BIT_CHM ICE_V2R1_SEG_256X1_CMP_MAX_BIT_CHM; /* 0x11990 */
+    volatile U_ICE_V2R1_SEG_256X1_CMP_SLC_BIT_CHM ICE_V2R1_SEG_256X1_CMP_SLC_BIT_CHM; /* 0x11994 */
+    volatile unsigned int reserved_156[2];                                            /* 0x11998~0x1199c */
+    volatile unsigned int ICE_V2R1_SEG_256X1_CMP_DEBUG_CHM;                           /* 0x119a0 */
+    volatile unsigned int reserved_157[279];                                          /* 0x119a4~0x11dfc */
+    volatile U_WBC_CMP_CTRL WBC_CMP_CTRL;                                             /* 0x11e00 */
+    volatile U_WBC_CMP_UPD WBC_CMP_UPD;                                               /* 0x11e04 */
+    volatile U_WBC_CMP_HEIGHT WBC_CMP_HEIGHT;                                         /* 0x11e08 */
+    volatile U_WBC_CMP_ORESO WBC_CMP_ORESO;                                           /* 0x11e0c */
+    volatile unsigned int WBC_CMP_YADDR;                                              /* 0x11e10 */
+    volatile unsigned int WBC_CMP_YADDR1;                                             /* 0x11e14 */
+    volatile unsigned int WBC_CMP_CADDR;                                              /* 0x11e18 */
+    volatile unsigned int WBC_CMP_CADDR1;                                             /* 0x11e1c */
+    volatile unsigned int WBC_CMP_ADDR0_T0;                                           /* 0x11e20 */
+    volatile unsigned int WBC_CMP_ADDR1_T0;                                           /* 0x11e24 */
+    volatile unsigned int WBC_CMP_ADDR0_T1;                                           /* 0x11e28 */
+    volatile unsigned int WBC_CMP_ADDR1_T1;                                           /* 0x11e2c */
+    volatile unsigned int WBC_CMP_L_FSIZE;                                            /* 0x11e30 */
+    volatile unsigned int WBC_CMP_C_FSIZE;                                            /* 0x11e34 */
+    volatile unsigned int WBC_CMP_T0_FSIZE;                                           /* 0x11e38 */
+    volatile unsigned int WBC_CMP_T1_FSIZE;                                           /* 0x11e3c */
+    volatile unsigned int WBC_SETY_FSIZE;                                             /* 0x11e40 */
+    volatile unsigned int WBC_SETC_FSIZE;                                             /* 0x11e44 */
+    volatile unsigned int WBC_SETT0_FSIZE;                                            /* 0x11e48 */
+    volatile unsigned int WBC_SETT1_FSIZE;                                            /* 0x11e4c */
+    volatile U_WBC_OD_STATE WBC_OD_STATE;                                             /* 0x11e50 */
+    volatile unsigned int reserved_158[43];                                           /* 0x11e54~0x11efc */
+    volatile U_OD_PIC_OSD_GLB_INFO OD_PIC_OSD_GLB_INFO;                               /* 0x11f00 */
+    volatile U_OD_PIC_OSD_FRAME_SIZE OD_PIC_OSD_FRAME_SIZE;                           /* 0x11f04 */
+    volatile U_OD_PIC_OSD_RC_CFG0 OD_PIC_OSD_RC_CFG0;                                 /* 0x11f08 */
+    volatile U_OD_PIC_OSD_RC_CFG1 OD_PIC_OSD_RC_CFG1;                                 /* 0x11f0c */
+    volatile U_OD_PIC_OSD_RC_CFG2 OD_PIC_OSD_RC_CFG2;                                 /* 0x11f10 */
+    volatile U_OD_PIC_OSD_RC_CFG3 OD_PIC_OSD_RC_CFG3;                                 /* 0x11f14 */
+    volatile U_OD_PIC_OSD_RC_CFG4 OD_PIC_OSD_RC_CFG4;                                 /* 0x11f18 */
+    volatile U_OD_PIC_OSD_RC_CFG5 OD_PIC_OSD_RC_CFG5;                                 /* 0x11f1c */
+    volatile U_OD_PIC_OSD_RC_CFG6 OD_PIC_OSD_RC_CFG6;                                 /* 0x11f20 */
+    volatile U_OD_PIC_OSD_RC_CFG7 OD_PIC_OSD_RC_CFG7;                                 /* 0x11f24 */
+    volatile U_OD_PIC_OSD_RC_CFG8 OD_PIC_OSD_RC_CFG8;                                 /* 0x11f28 */
+    volatile U_OD_PIC_OSD_RC_CFG9 OD_PIC_OSD_RC_CFG9;                                 /* 0x11f2c */
+    volatile U_OD_PIC_OSD_RC_CFG10 OD_PIC_OSD_RC_CFG10;                               /* 0x11f30 */
+    volatile U_OD_PIC_OSD_RC_CFG11 OD_PIC_OSD_RC_CFG11;                               /* 0x11f34 */
+    volatile U_OD_PIC_OSD_RC_CFG12 OD_PIC_OSD_RC_CFG12;                               /* 0x11f38 */
+    volatile U_OD_PIC_OSD_RC_CFG13 OD_PIC_OSD_RC_CFG13;                               /* 0x11f3c */
+    volatile U_OD_PIC_OSD_RC_CFG14 OD_PIC_OSD_RC_CFG14;                               /* 0x11f40 */
+    volatile U_OD_PIC_OSD_RC_CFG15 OD_PIC_OSD_RC_CFG15;                               /* 0x11f44 */
+    volatile U_OD_PIC_OSD_RC_CFG16 OD_PIC_OSD_RC_CFG16;                               /* 0x11f48 */
+    volatile U_OD_PIC_OSD_RC_CFG17 OD_PIC_OSD_RC_CFG17;                               /* 0x11f4c */
+    volatile U_OD_PIC_OSD_RC_CFG18 OD_PIC_OSD_RC_CFG18;                               /* 0x11f50 */
+    volatile U_OD_PIC_OSD_RC_CFG19 OD_PIC_OSD_RC_CFG19;                               /* 0x11f54 */
+    volatile unsigned int reserved_159[2];                                            /* 0x11f58~0x11f5c */
+    volatile U_OD_PIC_OSD_STAT_THR OD_PIC_OSD_STAT_THR;                               /* 0x11f60 */
+    volatile U_OD_PIC_OSD_PCMP OD_PIC_OSD_PCMP;                                       /* 0x11f64 */
+    volatile unsigned int reserved_160[6];                                            /* 0x11f68~0x11f7c */
+    volatile U_OD_PIC_OSD_BS_SIZE OD_PIC_OSD_BS_SIZE;                                 /* 0x11f80 */
+    volatile U_OD_PIC_OSD_WORST_ROW OD_PIC_OSD_WORST_ROW;                             /* 0x11f84 */
+    volatile U_OD_PIC_OSD_BEST_ROW OD_PIC_OSD_BEST_ROW;                               /* 0x11f88 */
+    volatile U_OD_PIC_OSD_STAT_INFO OD_PIC_OSD_STAT_INFO;                             /* 0x11f8c */
+    volatile unsigned int OD_PIC_OSD_DEBUG0;                                          /* 0x11f90 */
+    volatile unsigned int OD_PIC_OSD_DEBUG1;                                          /* 0x11f94 */
+    volatile unsigned int reserved_161[26];                                           /* 0x11f98~0x11ffc */
+    volatile U_V0_MRG_CTRL V0_MRG_CTRL;                                               /* 0x12000 */
+    volatile U_V0_MRG_DISP_POS V0_MRG_DISP_POS;                                       /* 0x12004 */
+    volatile U_V0_MRG_DISP_RESO V0_MRG_DISP_RESO;                                     /* 0x12008 */
+    volatile U_V0_MRG_SRC_RESO V0_MRG_SRC_RESO;                                       /* 0x1200c */
+    volatile U_V0_MRG_SRC_OFFSET V0_MRG_SRC_OFFSET;                                   /* 0x12010 */
+    volatile unsigned int V0_MRG_Y_ADDR;                                              /* 0x12014 */
+    volatile unsigned int V0_MRG_C_ADDR;                                              /* 0x12018 */
+    volatile U_V0_MRG_STRIDE V0_MRG_STRIDE;                                           /* 0x1201c */
+    volatile unsigned int V0_MRG_YH_ADDR;                                             /* 0x12020 */
+    volatile unsigned int V0_MRG_CH_ADDR;                                             /* 0x12024 */
+    volatile U_V0_MRG_HSTRIDE V0_MRG_HSTRIDE;                                         /* 0x12028 */
+    volatile unsigned int reserved_162[5];                                            /* 0x1202c~0x1203c */
+    volatile U_V0_MRG_READ_CTRL V0_MRG_READ_CTRL;                                     /* 0x12040 */
+    volatile U_V0_MRG_READ_EN V0_MRG_READ_EN;                                         /* 0x12044 */
+    volatile unsigned int reserved_163[750];                                          /* 0x12048~0x12bfc */
+    volatile U_V1_MRG_CTRL V1_MRG_CTRL;                                               /* 0x12c00 */
+    volatile U_V1_MRG_DISP_POS V1_MRG_DISP_POS;                                       /* 0x12c04 */
+    volatile U_V1_MRG_DISP_RESO V1_MRG_DISP_RESO;                                     /* 0x12c08 */
+    volatile U_V1_MRG_SRC_RESO V1_MRG_SRC_RESO;                                       /* 0x12c0c */
+    volatile U_V1_MRG_SRC_OFFSET V1_MRG_SRC_OFFSET;                                   /* 0x12c10 */
+    volatile unsigned int V1_MRG_Y_ADDR;                                              /* 0x12c14 */
+    volatile unsigned int V1_MRG_C_ADDR;                                              /* 0x12c18 */
+    volatile U_V1_MRG_STRIDE V1_MRG_STRIDE;                                           /* 0x12c1c */
+    volatile unsigned int V1_MRG_YH_ADDR;                                             /* 0x12c20 */
+    volatile unsigned int V1_MRG_CH_ADDR;                                             /* 0x12c24 */
+    volatile U_V1_MRG_HSTRIDE V1_MRG_HSTRIDE;                                         /* 0x12c28 */
+    volatile unsigned int reserved_164[5];                                            /* 0x12c2c~0x12c3c */
+    volatile U_V1_MRG_READ_CTRL V1_MRG_READ_CTRL;                                     /* 0x12c40 */
+    volatile U_V1_MRG_READ_EN V1_MRG_READ_EN;                                         /* 0x12c44 */
+    volatile unsigned int reserved_165[2286];                                         /* 0x12c48~0x14ffc */
+    volatile unsigned int reserved_166[256];                                          /* 0x15000~0x153fc */
+    volatile U_V0_ZME_HINFO V0_ZME_HINFO;                                             /* 0x15400 */
+    volatile U_V0_ZME_HSP V0_ZME_HSP;                                                 /* 0x15404 */
+    volatile U_V0_ZME_HLOFFSET V0_ZME_HLOFFSET;                                       /* 0x15408 */
+    volatile U_V0_ZME_HCOFFSET V0_ZME_HCOFFSET;                                       /* 0x1540c */
+    volatile U_V0_ZME_HZONE0DELTA V0_ZME_HZONE0DELTA;                                 /* 0x15410 */
+    volatile U_V0_ZME_HZONE2DELTA V0_ZME_HZONE2DELTA;                                 /* 0x15414 */
+    volatile U_V0_ZME_HZONEEND V0_ZME_HZONEEND;                                       /* 0x15418 */
+    volatile U_V0_ZME_HL_SHOOTCTRL V0_ZME_HL_SHOOTCTRL;                               /* 0x1541c */
+    volatile U_V0_ZME_HC_SHOOTCTRL V0_ZME_HC_SHOOTCTRL;                               /* 0x15420 */
+    volatile U_V0_ZME_HCOEF_REN V0_ZME_HCOEF_REN;                                     /* 0x15424 */
+    volatile U_V0_ZME_HCOEF_RDATA V0_ZME_HCOEF_RDATA;                                 /* 0x15428 */
+    volatile unsigned int reserved_170[53];                                           /* 0x1542c~0x154fc */
+    volatile U_V0_ZME_VINFO V0_ZME_VINFO;                                             /* 0x15500 */
+    volatile U_V0_ZME_VSP V0_ZME_VSP;                                                 /* 0x15504 */
+    volatile U_V0_ZME_VOFFSET V0_ZME_VOFFSET;                                         /* 0x15508 */
+    volatile U_V0_ZME_VBOFFSET V0_ZME_VBOFFSET;                                       /* 0x1550c */
+    volatile unsigned int reserved_171[3];                                            /* 0x15510~0x15518 */
+    volatile U_V0_ZME_VL_SHOOTCTRL V0_ZME_VL_SHOOTCTRL;                               /* 0x1551c */
+    volatile U_V0_ZME_VC_SHOOTCTRL V0_ZME_VC_SHOOTCTRL;                               /* 0x15520 */
+    volatile U_V0_ZME_VCOEF_REN V0_ZME_VCOEF_REN;                                     /* 0x15524 */
+    volatile U_V0_ZME_VCOEF_RDATA V0_ZME_VCOEF_RDATA;                                 /* 0x15528 */
+    volatile unsigned int reserved_172[661];                                          /* 0x1552c~0x15f7c */
+    volatile U_GFX_OSD_GLB_INFO GFX_OSD_GLB_INFO;                                     /* 0x15f80 */
+    volatile U_GFX_OSD_FRAME_SIZE GFX_OSD_FRAME_SIZE;                                 /* 0x15f84 */
+    volatile unsigned int reserved_173[2];                                            /* 0x15f88~0x15f8c */
+    volatile U_GFX_OSD_DBG_REG GFX_OSD_DBG_REG;                                       /* 0x15f90 */
+    volatile U_GFX_OSD_DBG_REG1 GFX_OSD_DBG_REG1;                                     /* 0x15f94 */
+} S_VDP_REGS_TYPE;
+
+#ifdef __cplusplus
+}
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* __VOU_REG_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/include/common_vo.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/include/common_vo.h
--- u-boot-2016.11/product/osd/vo/include/common_vo.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/include/common_vo.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,434 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __GK_COMMON_VO_H__
+#define __GK_COMMON_VO_H__
+
+#include "type.h"
+#include "errno.h"
+#include "common_video.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+/* Vo define error code */
+#define GK_ERR_VO_INVALID_DEV_ID      GK_DEFINE_ERR(GK_ID_VO, GK_ERR_LEVEL_ERROR, GK_ERR_INVALID_DEV_ID)
+#define GK_ERR_VO_INVALID_CHN_ID      GK_DEFINE_ERR(GK_ID_VO, GK_ERR_LEVEL_ERROR, GK_ERR_INVALID_CHN_ID)
+#define GK_ERR_VO_INVALID_LAYER_ID    GK_DEFINE_ERR(GK_ID_VO, GK_ERR_LEVEL_ERROR, GK_ERR_INVALID_LAYER_ID)
+#define GK_ERR_VO_ILLEGAL_PARAM       GK_DEFINE_ERR(GK_ID_VO, GK_ERR_LEVEL_ERROR, GK_ERR_ILLEGAL_PARAM)
+#define GK_ERR_VO_NULL_PTR            GK_DEFINE_ERR(GK_ID_VO, GK_ERR_LEVEL_ERROR, GK_ERR_NULL_PTR)
+#define GK_ERR_VO_NOT_CFG             GK_DEFINE_ERR(GK_ID_VO, GK_ERR_LEVEL_ERROR, GK_ERR_NOT_CFG)
+#define GK_ERR_VO_NOT_SUPPORT         GK_DEFINE_ERR(GK_ID_VO, GK_ERR_LEVEL_ERROR, GK_ERR_NOT_SUPPORT)
+#define GK_ERR_VO_NOT_PERM            GK_DEFINE_ERR(GK_ID_VO, GK_ERR_LEVEL_ERROR, GK_ERR_NOT_PERM)
+#define GK_ERR_VO_NOT_ENABLE          GK_DEFINE_ERR(GK_ID_VO, GK_ERR_LEVEL_ERROR, GK_ERR_NOT_ENABLE)
+#define GK_ERR_VO_NOT_DISABLE         GK_DEFINE_ERR(GK_ID_VO, GK_ERR_LEVEL_ERROR, GK_ERR_NOT_DISABLE)
+#define GK_ERR_VO_NO_MEM              GK_DEFINE_ERR(GK_ID_VO, GK_ERR_LEVEL_ERROR, GK_ERR_NO_MEM)
+#define GK_ERR_VO_NOT_READY           GK_DEFINE_ERR(GK_ID_VO, GK_ERR_LEVEL_ERROR, GK_ERR_NOT_READY)
+#define GK_ERR_VO_TIMEOUT             GK_DEFINE_ERR(GK_ID_VO, GK_ERR_LEVEL_ERROR, GK_ERR_TIMEOUT)
+#define GK_ERR_VO_BUSY                GK_DEFINE_ERR(GK_ID_VO, GK_ERR_LEVEL_ERROR, GK_ERR_BUSY)
+#define GK_ERR_VO_NOT_BINDED          GK_DEFINE_ERR(GK_ID_VO, GK_ERR_LEVEL_ERROR, GK_ERR_NOT_BINDED)
+#define GK_ERR_VO_BINDED              GK_DEFINE_ERR(GK_ID_VO, GK_ERR_LEVEL_ERROR, GK_ERR_BINDED)
+
+/* VO video output interface type */
+#define GK_VO_INTF_CVBS       (0x01L << 0)
+#define GK_VO_INTF_VGA        (0x01L << 1)
+#define GK_VO_INTF_BT656      (0x01L << 2)
+#define GK_VO_INTF_BT1120     (0x01L << 3)
+#define GK_VO_INTF_HDMI       (0x01L << 4)
+#define GK_VO_INTF_RGB_6BIT   (0x01L << 5)
+#define GK_VO_INTF_RGB_8BIT   (0x01L << 6)
+#define GK_VO_INTF_RGB_16BIT  (0x01L << 7)
+#define GK_VO_INTF_RGB_18BIT  (0x01L << 8)
+#define GK_VO_INTF_RGB_24BIT  (0x01L << 9)
+#define GK_VO_INTF_MIPI       (0x01L << 10)
+#define GK_VO_INTF_MIPI_SLAVE (0x01L << 11)
+
+typedef gk_u32 gk_vo_intf_type;
+
+typedef enum {
+    GK_VO_OUT_PAL = 0, /* PAL standard */
+    GK_VO_OUT_NTSC = 1, /* NTSC standard */
+    GK_VO_OUT_960H_PAL = 2, /* ITU-R BT.1302 960 x 576 at 50 Hz (interlaced) */
+    GK_VO_OUT_960H_NTSC = 3, /* ITU-R BT.1302 960 x 480 at 60 Hz (interlaced) */
+
+    GK_VO_OUT_640x480_60 = 4, /* VESA 640 x 480 at 60 Hz (non-interlaced) CVT */
+    GK_VO_OUT_480P60 = 5, /* 720  x  480 at 60 Hz. */
+    GK_VO_OUT_576P50 = 6, /* 720  x  576 at 50 Hz. */
+    GK_VO_OUT_800x600_60 = 7, /* VESA 800 x 600 at 60 Hz (non-interlaced) */
+    GK_VO_OUT_1024x768_60 = 8, /* VESA 1024 x 768 at 60 Hz (non-interlaced) */
+    GK_VO_OUT_720P50 = 9, /* 1280 x  720 at 50 Hz. */
+    GK_VO_OUT_720P60 = 10, /* 1280 x  720 at 60 Hz. */
+    GK_VO_OUT_1280x800_60 = 11, /* 1280*800@60Hz VGA@60Hz */
+    GK_VO_OUT_1280x1024_60 = 12, /* VESA 1280 x 1024 at 60 Hz (non-interlaced) */
+    GK_VO_OUT_1366x768_60 = 13, /* VESA 1366 x 768 at 60 Hz (non-interlaced) */
+    GK_VO_OUT_1400x1050_60 = 14, /* VESA 1400 x 1050 at 60 Hz (non-interlaced) CVT */
+    GK_VO_OUT_1440x900_60 = 15, /* VESA 1440 x 900 at 60 Hz (non-interlaced) CVT Compliant */
+    GK_VO_OUT_1600x1200_60 = 16, /* VESA 1600 x 1200 at 60 Hz (non-interlaced) */
+    GK_VO_OUT_1680x1050_60 = 17, /* VESA 1680 x 1050 at 60 Hz (non-interlaced) */
+
+    GK_VO_OUT_1080P24 = 18, /* 1920 x 1080 at 24 Hz. */
+    GK_VO_OUT_1080P25 = 19, /* 1920 x 1080 at 25 Hz. */
+    GK_VO_OUT_1080P30 = 20, /* 1920 x 1080 at 30 Hz. */
+    GK_VO_OUT_1080I50 = 21, /* 1920 x 1080 at 50 Hz, interlaced. */
+    GK_VO_OUT_1080I60 = 22, /* 1920 x 1080 at 60 Hz, interlaced. */
+    GK_VO_OUT_1080P50 = 23, /* 1920 x 1080 at 50 Hz. */
+    GK_VO_OUT_1080P60 = 24, /* 1920 x 1080 at 60 Hz. */
+
+    GK_VO_OUT_1920x1200_60 = 25, /* VESA 1920 x 1200 at 60 Hz (non-interlaced) CVT (Reduced Blanking) */
+    GK_VO_OUT_1920x2160_30 = 26, /* 1920x2160_30 */
+    GK_VO_OUT_2560x1440_30 = 27, /* 2560x1440_30 */
+    GK_VO_OUT_2560x1440_60 = 28, /* 2560x1440_60 */
+    GK_VO_OUT_2560x1600_60 = 29, /* 2560x1600_60 */
+
+    GK_VO_OUT_3840x2160_24 = 30, /* 3840x2160_24 */
+    GK_VO_OUT_3840x2160_25 = 31, /* 3840x2160_25 */
+    GK_VO_OUT_3840x2160_30 = 32, /* 3840x2160_30 */
+    GK_VO_OUT_3840x2160_50 = 33, /* 3840x2160_50 */
+    GK_VO_OUT_3840x2160_60 = 34, /* 3840x2160_60 */
+    GK_VO_OUT_4096x2160_24 = 35, /* 4096x2160_24 */
+    GK_VO_OUT_4096x2160_25 = 36, /* 4096x2160_25 */
+    GK_VO_OUT_4096x2160_30 = 37, /* 4096x2160_30 */
+    GK_VO_OUT_4096x2160_50 = 38, /* 4096x2160_50 */
+    GK_VO_OUT_4096x2160_60 = 39, /* 4096x2160_60 */
+    GK_VO_OUT_7680x4320_30 = 40, /* 7680x4320_30 */
+
+    GK_VO_OUT_240x320_50 = 41, /* 240x320_50 */
+    GK_VO_OUT_320x240_50 = 42, /* 320x240_50 */
+    GK_VO_OUT_240x320_60 = 43, /* 240x320_60 */
+    GK_VO_OUT_320x240_60 = 44, /* 320x240_60 */
+    GK_VO_OUT_800x600_50 = 45, /* 800x600_60 */
+
+    GK_VO_OUT_720x1280_60 = 46, /* For MIPI DSI Tx 720 x1280 at 60 Hz */
+    GK_VO_OUT_1080x1920_60 = 47, /* For MIPI DSI Tx 1080x1920 at 60 Hz */
+
+    GK_VO_OUT_USER = 48, /* User timing. */
+
+    GK_VO_OUT_BUTT,
+} gk_vo_intf_sync;
+
+typedef struct {
+    gk_bool syncm; /* RW; sync mode(0:timing,as BT.656; 1:signal,as LCD) */
+    gk_bool iop; /* RW; interlaced or progressive display(0:i; 1:p) */
+    gk_u8 intfb; /* RW; interlaced bit width while output */
+
+    gk_u16 vact; /* RW; vertical active area */
+    gk_u16 vbb; /* RW; vertical back blank porch */
+    gk_u16 vfb; /* RW; vertical front blank porch */
+
+    gk_u16 hact; /* RW; horizontal active area */
+    gk_u16 hbb; /* RW; horizontal back blank porch */
+    gk_u16 hfb; /* RW; horizontal front blank porch */
+    gk_u16 hmid; /* RW; bottom horizontal active area */
+
+    gk_u16 bvact; /* RW; bottom vertical active area */
+    gk_u16 bvbb; /* RW; bottom vertical back blank porch */
+    gk_u16 bvfb; /* RW; bottom vertical front blank porch */
+
+    gk_u16 hpw; /* RW; horizontal pulse width */
+    gk_u16 vpw; /* RW; vertical pulse width */
+
+    gk_bool idv; /* RW; inverse data valid of output */
+    gk_bool ihs; /* RW; inverse horizontal synchronization signal */
+    gk_bool ivs; /* RW; inverse vertical synchronization signal */
+} gk_vo_sync_info;
+
+typedef struct {
+    gk_u32 bg_color; /* RW; background color of a device, in RGB format. */
+    gk_vo_intf_type intf_type; /* RW; type of a VO interface */
+    gk_vo_intf_sync intf_sync; /* RW; type of a VO interface timing */
+    gk_vo_sync_info sync_info; /* RW; information about VO interface timing */
+} gk_vo_pub_attr;
+
+typedef struct {
+    gk_bool exit_dev_en;  /* RW, range: [0, 1];  whether to disable the vo device when sys exit */
+    gk_bool dev_clk_ext_en;  /* RW, range: [0, 1];  whether to open the vo device clock by the external user */
+    gk_bool vga_detect_en;   /* RW, range: [0, 1];  whether to enable the vga detect */
+    gk_u32 vdac_detect_cycle;  /* RW; VDAC(video digital-to-analog converter) detect cycle; Unit: frame interruption */
+} gk_vo_mod_param;
+
+typedef enum {
+    GK_VO_CLK_SRC_PLL = 0,       /* Clock source type PLL */
+    GK_VO_CLK_SRC_LCDMCLK = 1,   /* Clock source type LCDMCLK */
+    GK_VO_CLK_SRC_PLL_FOUT4 = 2, /* Clock source type PLL FOUT4 */
+    GK_VO_CLK_SRC_FIXED = 3,     /* Clock source type FIXED */
+
+    GK_VO_CLK_SRC_BUTT,
+} gk_vo_clk_src;
+
+typedef enum {
+    GK_VO_FIXED_CLK_65M    = 0, /* Fixed clock source 65MHz */
+    GK_VO_FIXED_CLK_74_25M = 1, /* Fixed clock source 74.25MHz */
+    GK_VO_FIXED_CLK_108M   = 2, /* Fixed clock source 108MHz */
+    GK_VO_FIXED_CLK_135M   = 3, /* Fixed clock source 135MHz */
+    GK_VO_FIXED_CLK_148_5M = 4, /* Fixed clock source 148.5MHz */
+    GK_VO_FIXED_CLK_297M   = 5, /* Fixed clock source 297MHz */
+
+    GK_VO_FIXED_CLK_BUTT,
+} gk_vo_fixed_clk;
+
+typedef struct {
+    gk_u32 fb_div;    /* RW, range: [0, 0xfff];  frequency double division */
+    gk_u32 frac;      /* RW, range: [0, 0xffffff]; fractional division */
+    gk_u32 ref_div;   /* RW, range: (0, 0x3f]; reference clock division */
+    gk_u32 post_div1; /* RW, range: (0, 0x7]; level 1 post division */
+    gk_u32 post_div2; /* RW, range: (0, 0x7]; level 2 post division */
+} gk_vo_pll;
+
+typedef struct {
+    gk_vo_clk_src clk_src; /* RW; clock source type */
+
+    union {
+        /*
+         * RW; user synchronization timing clock PLL information.
+         * AUTO: gk_vo_clk_src:GK_VO_CLK_SRC_PLL, GK_VO_CLK_SRC_PLL_FOUT4;
+         */
+        gk_vo_pll vo_pll;
+        /*
+         * RW, range: [1, 8473341]; LCD clock division.
+         * AUTO: gk_vo_clk_src:GK_VO_CLK_SRC_LCDMCLK;
+         */
+        gk_u32 lcd_m_clk_div;
+
+        gk_vo_fixed_clk fixed_clk; /* RW; fixed clock. AUTO: gk_vo_clk_src:GK_VO_CLK_SRC_FIXED; */
+    };
+} gk_vo_user_sync_attr;
+
+typedef struct {
+    gk_vo_user_sync_attr user_sync_attr; /* RW; user synchronization timing attribute */
+    gk_u32 pre_div;                      /* RW, range: [1, 32]; device previous division */
+    gk_u32 dev_div;                      /* RW, range: [1, 4]; device clock division */
+    gk_bool clk_reverse_en;              /* RW, range: [0, 1]; whether to reverse clock  */
+} gk_vo_user_sync_info;
+
+typedef struct {
+    gk_bool enable;  /* RW, less buf enable */
+    gk_u32 vtth;     /* RW, vtth value */
+}gk_vo_less_buf_attr;
+
+typedef enum {
+    GK_VO_INTF_STATUS_NO_PLUG = 0,  /* Interface status is not plugged */
+    GK_VO_INTF_STATUS_PLUG = 1,     /* Interface status is plugged */
+    GK_VO_INTF_STATUS_BUTT,
+}gk_vo_intf_plug_status;
+
+typedef struct {
+    gk_vo_intf_plug_status plug_status;  /* R; Interface plug status */
+}gk_vo_intf_status;
+
+typedef enum {
+    GK_VO_CSC_MATRIX_BT601LIMIT_TO_BT601LIMIT = 0, /* Identity matrix.   from BT.601 limit to BT.601 limit */
+    GK_VO_CSC_MATRIX_BT601FULL_TO_BT601LIMIT = 1,  /* Change color space from BT.601 full to BT.601 limit */
+    GK_VO_CSC_MATRIX_BT709LIMIT_TO_BT601LIMIT = 2, /* Change color space from BT.709 limit to BT.601 limit */
+    GK_VO_CSC_MATRIX_BT709FULL_TO_BT601LIMIT = 3,  /* Change color space from BT.709 full to BT.601 limit */
+
+    GK_VO_CSC_MATRIX_BT601LIMIT_TO_BT709LIMIT = 4, /* Change color space from BT.601 limit to BT.709 limit */
+    GK_VO_CSC_MATRIX_BT601FULL_TO_BT709LIMIT = 5,  /* Change color space from BT.601 full to BT.709 limit */
+    GK_VO_CSC_MATRIX_BT709LIMIT_TO_BT709LIMIT = 6, /* Identity matrix.   from BT.709 limit to BT.709 limit */
+    GK_VO_CSC_MATRIX_BT709FULL_TO_BT709LIMIT = 7,  /* Change color space from BT.709 full to BT.709 limit */
+
+    GK_VO_CSC_MATRIX_BT601LIMIT_TO_BT601FULL = 8,  /* Change color space from BT.601 limit to BT.601 full */
+    GK_VO_CSC_MATRIX_BT601FULL_TO_BT601FULL = 9,   /* Identity matrix.   from BT.601 full to BT.601 full */
+    GK_VO_CSC_MATRIX_BT709LIMIT_TO_BT601FULL = 10,  /* Change color space from BT.709 limit to BT.601 full */
+    GK_VO_CSC_MATRIX_BT709FULL_TO_BT601FULL = 11,   /* Change color space from BT.709 full to BT.601 full */
+
+    GK_VO_CSC_MATRIX_BT601LIMIT_TO_BT709FULL = 12,  /* Change color space from BT.601 limit to BT.709 full */
+    GK_VO_CSC_MATRIX_BT601FULL_TO_BT709FULL = 13,   /* Change color space from BT.601 full to BT.709 full */
+    GK_VO_CSC_MATRIX_BT709LIMIT_TO_BT709FULL = 14,  /* Change color space from BT.709 limit to BT.709 full */
+    GK_VO_CSC_MATRIX_BT709FULL_TO_BT709FULL = 15,   /* Identity matrix.   from BT.709 full to BT.709 full */
+
+    GK_VO_CSC_MATRIX_BT601LIMIT_TO_RGBFULL = 16,    /* Change color space from BT.601 limit to RGB full */
+    GK_VO_CSC_MATRIX_BT601FULL_TO_RGBFULL = 17,     /* Change color space from BT.601 full to RGB full */
+    GK_VO_CSC_MATRIX_BT709LIMIT_TO_RGBFULL = 18,    /* Change color space from BT.709 limit to RGB full */
+    GK_VO_CSC_MATRIX_BT709FULL_TO_RGBFULL = 19,     /* Change color space from BT.709 full to RGB full */
+
+    GK_VO_CSC_MATRIX_BT601LIMIT_TO_RGBLIMIT = 20,   /* Change color space from BT.601 limit to RGB limit */
+    GK_VO_CSC_MATRIX_BT601FULL_TO_RGBLIMIT = 21,    /* Change color space from BT.709 full to RGB limit */
+    GK_VO_CSC_MATRIX_BT709LIMIT_TO_RGBLIMIT = 22,   /* Change color space from BT.601 limit to RGB limit */
+    GK_VO_CSC_MATRIX_BT709FULL_TO_RGBLIMIT = 23,    /* Change color space from BT.709 full to RGB limit */
+
+    GK_VO_CSC_MATRIX_RGBFULL_TO_BT601LIMIT = 24,    /* Change color space from RGB full to BT.601 limit */
+    GK_VO_CSC_MATRIX_RGBFULL_TO_BT601FULL = 25,     /* Change color space from RGB full to BT.601 full */
+    GK_VO_CSC_MATRIX_RGBFULL_TO_BT709LIMIT = 26,    /* Change color space from RGB full to BT.709 limit */
+    GK_VO_CSC_MATRIX_RGBFULL_TO_BT709FULL = 27,     /* Change color space from RGB full to BT.709 full */
+
+    GK_VO_CSC_MATRIX_BUTT,
+} gk_vo_csc_matrix;
+
+typedef struct {
+    gk_vo_csc_matrix csc_matrix; /* RW; CSC matrix */
+    gk_u32 luma; /* RW; range: [0, 100]; luminance, default: 50 */
+    gk_u32 contrast; /* RW; range: [0, 100]; contrast, default: 50 */
+    gk_u32 hue; /* RW; range: [0, 100]; hue, default: 50 */
+    gk_u32 saturation; /* RW; range: [0, 100]; saturation, default: 50 */
+    gk_bool ex_csc_en; /* RW; range: [0, 1]; extended csc switch for luminance, default: 0 */
+} gk_vo_csc;
+
+typedef struct {
+    gk_vo_csc csc;  /* RW; color space */
+    gk_u32 gain;  /* RW; range: [0, 64); current gain of VGA signals. */
+    gk_s32 sharpen_strength;  /* RW; range: [0, 255]; current sharpen strength of VGA signals. */
+} gk_vo_vga_param;
+
+typedef struct {
+    gk_vo_csc csc; /* RW, color space */
+} gk_vo_hdmi_param;
+
+typedef struct {
+    gk_vo_csc csc; /* RW, color space */
+    gk_bool rgb_inverted_en; /* RW; component r g b inverted, rgb to bgr, default: 0, rgb */
+    gk_bool bit_inverted_en; /* RW; data's bit inverted,
+                                rgb6bit: bit[5:0] to bit[0:5],
+                                rgb8bit: bit[7:0] to bit[0:7],
+                                rgb16bit: bit[15:0] to bit[0:15],
+                                rgb18bit: bit[17:0] to bit[0:17],
+                                rgb24bit: bit[23:0] to bit[0:23],
+                                default: 0, bit[5/7/15/17/23:0] */
+} gk_vo_rgb_param;
+
+typedef struct {
+    gk_bool yc_inverted_en; /* RW; component y c inverted, yc to cy, default: 0, yc */
+    gk_bool bit_inverted_en; /* RW; data's bit inverted, bt.656: bit[7:0] to bit[0:7],
+                                bt.1120: bit[15:0] to bit[0:15],
+                                default: 0, bit[7:0] or bit[15:0] */
+} gk_vo_bt_param;
+
+typedef enum {
+    GK_VO_PARTITION_MODE_SINGLE = 0, /* Single partition, use software to make multi-picture in one hardware cell */
+    GK_VO_PARTITION_MODE_MULTI = 1,  /* Multi partition, each partition is a hardware cell */
+    GK_VO_PARTITION_MODE_BUTT,
+} gk_vo_partition_mode;
+
+typedef struct {
+    gk_rect display_rect; /* RW; display resolution */
+    gk_phys_addr_t address;
+    gk_u32 stride;
+} gk_vo_video_layer_attr;
+
+typedef enum {
+    GK_VO_GFX_TYPE_ARGB1555 = 0,
+    GK_VO_GFX_TYPE_BMP1555 = 1,
+
+    GK_VO_GFX_TYPE_BUTT
+}gk_vo_gfx_type;
+
+typedef struct {
+    gk_rect display_rect;
+    gk_phys_addr_t address;
+    gk_u32 stride;
+    gk_vo_gfx_type type;
+} gk_vo_gfx_attr;
+
+typedef struct {
+    gk_aspect_ratio aspect_ratio; /* RW; aspect ratio */
+} gk_vo_layer_param;
+
+typedef struct {
+    gk_u32 priority; /* RW; video out overlay priority sd */
+    gk_rect rect; /* RW; rectangle of video output channel */
+    gk_bool deflicker_en; /* RW; deflicker or not sd */
+} gk_vo_chn_attr;
+
+typedef struct {
+    gk_aspect_ratio aspect_ratio; /* RW; aspect ratio */
+} gk_vo_chn_param;
+
+typedef enum {
+    GK_VO_ZOOM_IN_RECT = 0, /* Zoom in by rect */
+    GK_VO_ZOOM_IN_RATIO = 1, /* Zoom in by ratio */
+    GK_VO_ZOOM_IN_BUTT,
+} gk_vo_zoom_in_type;
+
+typedef struct {
+    /* RW; range: [0, 1000]; x_ratio = x * 1000 / W, x means start point to be zoomed, W means channel's width. */
+    gk_u32 x_ratio;
+    /* RW; range: [0, 1000]; y_ratio = y * 1000 / H, y means start point to be zoomed, H means channel's height. */
+    gk_u32 y_ratio;
+    /* RW; range: [0, 1000]; width_ratio = w * 1000 / W, w means width to be zoomed, W means channel's width. */
+    gk_u32 width_ratio;
+    /* RW; range: [0, 1000]; height_ratio = h * 1000 / H, h means height to be zoomed, H means channel's height. */
+    gk_u32 height_ratio;
+} gk_vo_zoom_ratio;
+
+typedef struct {
+    gk_vo_zoom_in_type zoom_type; /* RW; choose the type of zoom in */
+    union {
+        gk_rect zoom_rect; /* RW; zoom in by rect. AUTO:gk_vo_zoom_in_type:GK_VO_ZOOM_IN_RECT; */
+        gk_vo_zoom_ratio zoom_ratio; /* RW; zoom in by ratio. AUTO:gk_vo_zoom_in_type:GK_VO_ZOOM_IN_RATIO; */
+    };
+} gk_vo_zoom_attr;
+
+typedef struct {
+    gk_bool enable; /* RW; do frame or not */
+    gk_border border; /* RW; frame's top, bottom, left, right width and color */
+} gk_vo_border;
+
+typedef struct {
+    gk_u32 chn_buf_used; /* R; channel buffer that been used */
+} gk_vo_chn_status;
+
+typedef struct {
+    gk_size target_size; /* RW; WBC zoom target size */
+    gk_pixel_format pixel_format; /* RW; the pixel format of WBC output */
+    gk_u32 frame_rate; /* RW; frame rate control */
+    gk_dynamic_range dynamic_range; /* RW; write back dynamic range type */
+    gk_compress_mode compress_mode; /* RW; write back compressing mode   */
+} gk_vo_wbc_attr;
+
+typedef enum {
+    GK_VO_WBC_MODE_NORM = 0, /* In this mode, wbc will capture frames according to dev frame rate
+                                and wbc frame rate */
+    GK_VO_WBC_MODE_DROP_REPEAT = 1, /* In this mode, wbc will drop dev repeat frame, and capture the real frame
+                                according to video layer's display rate and wbc frame rate */
+    GK_VO_WBC_MODE_PROGRESSIVE_TO_INTERLACED = 2, /* In this mode, wbc will drop dev repeat frame which repeats more
+                                than 3 times, and change two progressive frames to one interlaced frame */
+    GK_VO_WBC_MODE_BUTT,
+} gk_vo_wbc_mode;
+
+typedef enum {
+    GK_VO_WBC_SRC_DEV = 0, /* WBC source is device */
+    GK_VO_WBC_SRC_VIDEO = 1, /* WBC source is video layer */
+    GK_VO_WBC_SRC_BUTT,
+} gk_vo_wbc_src_type;
+
+typedef struct {
+    gk_vo_wbc_src_type src_type; /* RW; WBC source's type */
+    gk_u32 src_id; /* RW; WBC source's ID */
+} gk_vo_wbc_src;
+
+typedef enum {
+    GK_VO_CAS_MODE_SINGLE = 0, /* cascade mode is single */
+    GK_VO_CAS_MODE_DUAL = 1, /* cascade mode is dual */
+    GK_VO_CAS_MODE_BUTT,
+} gk_vo_cas_mode;
+
+typedef enum {
+    GK_VO_CAS_MODE_SINGLE_EDGE = 0, /* single transmission,clock rising edge or falling edge trigger transmission */
+    GK_VO_CAS_MODE_DUAL_EDGE = 1, /* dual transmission,clock rising edge and falling edge trigger transmission */
+    GK_VO_CAS_MODE_EDGE_BUTT,
+} gk_vo_cas_data_transmission_mode;
+
+typedef enum {
+    GK_VO_CAS_RGN_64 = 0, /* cascade region number 64 */
+    GK_VO_CAS_RGN_32 = 1, /* cascade region number 32 */
+    GK_VO_CAS_RGN_BUTT,
+} gk_vo_cas_rgn;
+
+typedef struct {
+    gk_bool         is_slave;                        /* RW; GK_TRUE: slave mode, GK_FALSE: master mode */
+    gk_vo_cas_rgn   cas_rgn;                         /* RW; cascade region number */
+    gk_vo_cas_mode  cas_mode;                        /* RW; cascade mode */
+    gk_vo_cas_data_transmission_mode cas_edge_mode;  /* RW; cascade data transmission mode  */
+} gk_vo_cas_attr;
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* end of #ifndef __GK_COMMON_VO_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/include/vo.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/include/vo.h
--- u-boot-2016.11/product/osd/vo/include/vo.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/include/vo.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __VO_H__
+#define __VO_H__
+
+#include "common_vo.h"
+
+#define VO_RECT_ALIGN                       2
+#define VO_ALPHA_OPACITY                    0xFF /* opacity alpha */
+#define VOU_ALIGN(val, align) (((val) + (align) - 1) & (~((align) - 1)))
+#define VO_MAX_VTTH_WATERLINE                8191
+
+/* typical value of video size */
+typedef enum {
+    VO_DISP_1080_WIDTH = 1920,
+    VO_DISP_1080_HEIGHT = 1080,
+    VO_DISP_720P_WIDTH = 1280,
+    VO_DISP_720P_HEIGHT = 720,
+    VO_DISP_D1_WIDTH = 720,
+    VO_DISP_D1P_HEIGH = 576,
+    VO_DISP_D1N_HEIGH = 480,
+    VO_DISP_VGA_1024 = 1024,
+    VO_DISP_VGA_768 = 768,
+    VO_DISP_VGA_800 = 800,
+    VO_DISP_VGA_600 = 600,
+    VO_DISP_VIRT_WIDTH = 5000,
+    VO_DISP_VIRT_HEIGHT = 5000,
+    VO_DISP_8K_WIDTH = 8192,
+    VO_DISP_8K_HEIGHT = 4320,
+    VO_DISP_BUTT
+} vo_disp_size;
+
+int set_vobg(unsigned int dev, unsigned int rgb);
+int start_vo(unsigned int dev, unsigned int type, unsigned int sync);
+int stop_vo(unsigned int dev);
+int start_gx(unsigned int layer, unsigned long addr, unsigned int strd, gk_rect gx_rect, unsigned int type);
+int stop_gx(unsigned int layer);
+int start_videolayer(unsigned int layer, unsigned long addr, unsigned int strd, gk_rect layer_rect);
+int stop_videolayer(unsigned int layer);
+gk_void vo_dcache_range(gk_phys_addr_t start_addr, gk_u64 size);
+typedef struct {
+    gk_bool video_enable;
+    gk_bool video_config;
+    gk_vo_csc layer_csc;
+    gk_vo_video_layer_attr vou_video_attr;
+} vo_layer_info;
+
+#endif /* end of __VO_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/Makefile
--- u-boot-2016.11/product/osd/vo/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,59 @@
+cflags-y     += -I$(srctree)/product/osd/include
+cflags-y     += -I$(srctree)/product/osd/vo/ext_inc
+cflags-y     += -I$(srctree)/product/osd/vo/include
+cflags-y     += -I$(srctree)/product/osd/vo/mkp/include
+cflags-y     += -I$(srctree)/product/osd/vo/mkp/src
+cflags-y     += -I$(srctree)/product/osd/vo/mkp/src/dev
+cflags-y     += -I$(srctree)/product/osd/vo/mkp/src/intf
+cflags-y     += -I$(srctree)/product/osd/vo/mkp/src/layer
+cflags-y     += -I$(srctree)/product/osd/vo/mkp/src/common
+cflags-y     += -I$(srctree)/product/osd/vo/arch/include
+cflags-y     += -I$(srctree)/product/osd/vo/arch/comm/src
+cflags-y     += -I$(srctree)/product/osd/vo/arch/comm/include
+cflags-y     += -I$(srctree)/product/osd/vo/arch/$(VO_ARCH_NAME)/include
+cflags-y     += -I$(srctree)/product/osd/vo/arch/include
+cflags-y     += -I$(srctree)/product/osd/vo/arch/$(VO_ARCH_NAME)/include/$(VO_SUB_ARCH_NAME)
+
+ccflags-y  += $(cflags-y)
+#HOSTCFLAGS += $(cflags-y)
+#CPPFLAGS   += $(cflags-y)
+
+CBB_VO_ARCH_COMM_SRC = arch/comm/src
+CBB_VO_ARCH_HAL = arch/$(VO_ARCH_NAME)/hal
+
+#enum mkp src files
+obj-y += mkp/src/vo.o
+obj-y += mkp/src/mkp_vo_user.o
+obj-y += mkp/src/dev/mkp_vo_dev.o
+obj-y += mkp/src/intf/mkp_vo_intf.o
+obj-y += mkp/src/layer/mkp_vo_video.o
+obj-y += mkp/src/layer/mkp_vo_gfx.o
+obj-y += mkp/src/common/mkp_vo_comm.o
+obj-y += mkp/src/common/mkp_vo_init.o
+obj-y += mkp/src/mkp_vo_bmp.o
+
+#enum arch comm src files
+obj-y += $(CBB_VO_ARCH_COMM_SRC)/drv_vo_comm.o
+obj-y += $(CBB_VO_ARCH_COMM_SRC)/drv_vo_dev_comm.o
+obj-y += $(CBB_VO_ARCH_COMM_SRC)/drv_vo_layer_comm.o
+obj-y += $(CBB_VO_ARCH_COMM_SRC)/drv_vo_video_comm.o
+obj-y += $(CBB_VO_ARCH_COMM_SRC)/drv_vo_gfx_comm.o
+obj-y += $(CBB_VO_ARCH_COMM_SRC)/drv_vo_coef_org_comm.o
+obj-y += $(CBB_VO_ARCH_COMM_SRC)/hal_vo_comm.o
+obj-y += $(CBB_VO_ARCH_COMM_SRC)/hal_vo_dev_comm.o
+obj-y += $(CBB_VO_ARCH_COMM_SRC)/hal_vo_layer_comm.o
+obj-y += $(CBB_VO_ARCH_COMM_SRC)/hal_vo_video_comm.o
+obj-y += $(CBB_VO_ARCH_COMM_SRC)/hal_vo_gfx_comm.o
+
+#enum vo hal src files
+obj-y += $(CBB_VO_ARCH_HAL)/drv_vo.o
+obj-y += $(CBB_VO_ARCH_HAL)/drv_vo_dev.o
+obj-y += $(CBB_VO_ARCH_HAL)/drv_vo_video.o
+obj-y += $(CBB_VO_ARCH_HAL)/drv_vo_gfx.o
+obj-y += $(CBB_VO_ARCH_HAL)/hal_vo.o
+obj-y += $(CBB_VO_ARCH_HAL)/hal_vo_dev.o
+obj-y += $(CBB_VO_ARCH_HAL)/hal_vo_video.o
+
+#enum vo sys hal src files
+obj-y += $(CBB_VO_ARCH_HAL)/sys_drv.o
+obj-y += $(CBB_VO_ARCH_HAL)/sys_hal.o
diff -uraN u-boot-2016.11/product/osd/vo/mkp/include/inner_vo.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/include/inner_vo.h
--- u-boot-2016.11/product/osd/vo/mkp/include/inner_vo.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/include/inner_vo.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __GK_INNER_VO_H__
+#define __GK_INNER_VO_H__
+
+#include "common_video.h"
+#include "common_vo.h"
+#include "common.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+#define VO_DESC(x)  1
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __GK_INNER_VO_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/mkp/include/mkp_vo.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/include/mkp_vo.h
--- u-boot-2016.11/product/osd/vo/mkp/include/mkp_vo.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/include/mkp_vo.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __MKP_VO_H__
+#define __MKP_VO_H__
+
+#include "common.h"
+#include "common_video.h"
+#include "common_vo.h"
+#include "inner_vo.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#define VO_LAYER_BUTT GK_VO_MAX_PHYS_LAYER_NUM
+
+#define vo_err_trace(fmt, ...)                                                                            \
+    GK_ERR_TRACE(GK_ID_VO, "[Func]:%s [Line]:%d [Info]:" fmt, __FUNCTION__, __LINE__, ##__VA_ARGS__);
+
+#define vo_warn_trace(fmt, ...)                                                                            \
+    GK_WARN_TRACE(GK_ID_VO, "[Func]:%s [Line]:%d [Info]:" fmt, __FUNCTION__, __LINE__, ##__VA_ARGS__);
+
+gk_s32 vo_def_check_dev_id(gk_vo_dev dev);
+gk_s32 vo_def_check_layer_id(gk_vo_layer layer);
+gk_bool vo_def_is_gfx_layer_id(gk_vo_layer layer);
+
+#define vo_check_null_ptr_return(ptr)                              \
+    do {                                                           \
+        if ((ptr) == GK_NULL) {                                    \
+            vo_err_trace("null ptr!\n");                           \
+            return GK_ERR_VO_NULL_PTR;                             \
+        }                                                          \
+    } while (0)
+
+/* vo device relative */
+#define vo_check_dev_id_return(dev)                         \
+    do {                                                    \
+        if (vo_drv_check_dev_id(dev) != GK_SUCCESS) {       \
+            vo_err_trace("dev %d invalid!\n", dev);         \
+            return GK_ERR_VO_INVALID_DEV_ID;                \
+        }                                                   \
+    } while (0)
+
+/* vo video relative */
+#define vo_check_layer_id_return(layer)                   \
+    do {                                                  \
+        if (vo_drv_check_layer_id(layer) != GK_SUCCESS) { \
+            vo_err_trace("layer %d invalid!\n", layer);   \
+            return GK_ERR_VO_INVALID_LAYER_ID;            \
+        }                                                 \
+    } while (0)
+
+#define vo_check_gfx_id_return(gfx_layer)                       \
+    do {                                                        \
+        if (vo_check_gfx_id(gfx_layer) != GK_SUCCESS) {         \
+            vo_err_trace("gfx layer %d invalid!\n", gfx_layer); \
+            return GK_ERR_VO_INVALID_LAYER_ID;                  \
+        }                                                       \
+    } while (0)
+
+#define vo_check_gfx_layer_return(layer)                                     \
+    do {                                                                     \
+        if (vo_def_is_gfx_layer_id(layer)) {                                 \
+            vo_err_trace("vo layer %d is gfx layer, not support!\n", layer); \
+            return GK_ERR_VO_NOT_SUPPORT;                                    \
+        }                                                                    \
+    } while (0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* end of #ifndef __MKP_VO_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/mkp/include/mkp_vo_user.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/include/mkp_vo_user.h
--- u-boot-2016.11/product/osd/vo/mkp/include/mkp_vo_user.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/include/mkp_vo_user.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,14 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __MKP_VO_USER_H__
+#define __MKP_VO_USER_H__
+
+#include "common_vo.h"
+#include "common.h"
+
+gk_vo_sync_info *vo_get_dev_user_sync_timing(gk_vo_dev dev);
+gk_vo_user_sync_info *vo_get_dev_user_sync_info(gk_vo_dev dev);
+
+#endif /* end of __MKP_VO_USER_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/mkp/src/common/mkp_vo_comm.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/common/mkp_vo_comm.c
--- u-boot-2016.11/product/osd/vo/mkp/src/common/mkp_vo_comm.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/common/mkp_vo_comm.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#include "mkp_vo_comm.h"
+#include "vo.h"
+#include "common_vo.h"
+#include "common_video.h"
+
+#include "mkp_vo.h"
+#include "sys_ext.h"
+
+#include "board.h"
+#include "drv_vo.h"
+
+#if VO_DESC("dev check")
+
+gk_s32 vo_def_check_dev_id(gk_vo_dev dev)
+{
+    if ((dev < 0) || (dev >= GK_VO_MAX_PHYS_DEV_NUM)) {
+        return GK_ERR_VO_INVALID_DEV_ID;
+    }
+
+    return GK_SUCCESS;
+}
+
+gk_s32 vo_def_check_layer_id(gk_vo_layer layer)
+{
+    if ((layer < 0) || (layer >= GK_VO_MAX_LAYER_NUM)) {
+        return GK_ERR_VO_INVALID_LAYER_ID;
+    }
+
+    return GK_SUCCESS;
+}
+
+gk_bool vo_def_is_gfx_layer_id(gk_vo_layer layer)
+{
+    if ((layer >= GK_VO_LAYER_G0) && (layer < VO_LAYER_BUTT)) {
+        return GK_TRUE;
+    }
+
+    return GK_FALSE;
+}
+
+#endif
+
+#if VO_DESC("check attr pub")
+
+gk_s32 vo_check_bool_value(gk_bool bool_val)
+{
+    if ((bool_val != GK_TRUE) && (bool_val != GK_FALSE)) {
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    return GK_SUCCESS;
+}
+
+gk_s32 vo_check_rect_align(const gk_rect *rect)
+{
+    if ((rect->x % VO_RECT_ALIGN) || (rect->y % VO_RECT_ALIGN) ||
+        (rect->width % VO_RECT_ALIGN) || (rect->height % VO_RECT_ALIGN)) {
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    return GK_SUCCESS;
+}
+#endif
+
+#if VO_DESC("check dev pub")
+
+gk_bool vo_is_phy_dev(gk_vo_dev dev)
+{
+    return GK_TRUE;
+}
+
+gk_bool vo_is_typical_intf_sync(gk_vo_intf_sync intf_sync)
+{
+    if ((intf_sync < GK_VO_OUT_BUTT) && (intf_sync != GK_VO_OUT_USER)) {
+        return GK_TRUE;
+    }
+
+    return GK_FALSE;
+}
+
+gk_bool vo_is_user_intf_sync(gk_vo_intf_sync intf_sync)
+{
+    if (intf_sync == GK_VO_OUT_USER) {
+        return GK_TRUE;
+    }
+
+    return GK_FALSE;
+}
+
+#endif
diff -uraN u-boot-2016.11/product/osd/vo/mkp/src/common/mkp_vo_comm.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/common/mkp_vo_comm.h
--- u-boot-2016.11/product/osd/vo/mkp/src/common/mkp_vo_comm.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/common/mkp_vo_comm.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __MKP_VO_COMM_H__
+#define __MKP_VO_COMM_H__
+
+#include "inner_vo.h"
+
+#define VO_RECT_INTERLACED_ALIGN  4
+
+#if VO_DESC("check attr pub")
+gk_s32 vo_check_bool_value(gk_bool bool_val);
+gk_s32 vo_check_rect_align(const gk_rect *rect);
+gk_s32 vo_check_csc_no_matrix(const gk_vo_csc *csc);
+#endif
+
+#if VO_DESC("check dev pub")
+gk_bool vo_is_phy_dev(gk_vo_dev dev);
+gk_bool vo_is_virt_dev(gk_vo_dev dev);
+gk_bool vo_is_cas_dev(gk_vo_dev dev);
+gk_bool vo_is_typical_intf_sync(gk_vo_intf_sync intf_sync);
+gk_bool vo_is_user_intf_sync(gk_vo_intf_sync intf_sync);
+
+#endif
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* end of #ifndef __MKP_VO_COMM_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/mkp/src/common/mkp_vo_init.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/common/mkp_vo_init.c
--- u-boot-2016.11/product/osd/vo/mkp/src/common/mkp_vo_init.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/common/mkp_vo_init.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,96 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#include "mkp_vo_init.h"
+#include "mkp_vo_dev.h"
+#include "mkp_vo_gfx.h"
+#include "mkp_vo_video.h"
+#include "vo.h"
+#include "common_vo.h"
+#include "common_video.h"
+
+#include "mkp_vo.h"
+#include "sys_ext.h"
+
+#include "board.h"
+#include "drv_vo.h"
+
+#if VO_DESC("clk init")
+static gk_void vo_init_set_sys_clk(gk_void)
+{
+    vo_lpw_bus_reset(GK_FALSE);
+}
+
+static gk_void vo_init_crg_clk(gk_void)
+{
+    vo_drv_set_all_crg_clk(GK_TRUE);
+}
+
+static gk_void vo_init_board(gk_void)
+{
+    vo_drv_board_init();
+}
+#endif
+
+#if VO_DESC("init context")
+
+static gk_void vo_init_context(gk_void)
+{
+    vo_init_dev_info();
+
+    vo_init_layer_resource();
+}
+#endif
+
+#if VO_DESC("vo init flag")
+
+static gk_bool g_is_initialized = GK_FALSE;
+gk_bool vo_get_vo_init_flag(gk_void)
+{
+    return g_is_initialized;
+}
+
+static gk_void vo_set_vo_init_flag(gk_bool flag)
+{
+    g_is_initialized = flag;
+}
+#endif
+
+#if VO_DESC("init operation")
+
+gk_s32 vo_init(gk_void)
+{
+    gk_vo_dev dev;
+    gk_vo_layer layer;
+    if (vo_get_vo_init_flag() == GK_FALSE) {
+        /* unreset */
+        vo_init_set_sys_clk();
+
+        /* clk enable */
+        vo_init_crg_clk();
+
+        /* step1: init drv context */
+        vo_init_context();
+
+        /* step2: init mkp context */
+        for (dev = 0; dev < GK_VO_MAX_PHYS_DEV_NUM; dev++) {
+            vo_init_dev_ctx(dev);
+        }
+        for (layer = 0; layer < GK_VO_MAX_PHYS_VIDEO_LAYER_NUM; layer++) {
+            vo_init_layer_ctx(layer);
+        }
+
+        /* step3: init mkp gfx context */
+        vo_init_gfx();
+
+        /* hardware init */
+        vo_init_board();
+
+        vo_set_vo_init_flag(GK_TRUE);
+    }
+
+    return GK_SUCCESS;
+}
+#endif
diff -uraN u-boot-2016.11/product/osd/vo/mkp/src/common/mkp_vo_init.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/common/mkp_vo_init.h
--- u-boot-2016.11/product/osd/vo/mkp/src/common/mkp_vo_init.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/common/mkp_vo_init.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __MKP_VO_INIT_H__
+#define __MKP_VO_INIT_H__
+
+#include "type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+gk_bool vo_get_vo_init_flag(gk_void);
+gk_s32 vo_init(gk_void);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* end of #ifndef __MKP_VO_INIT_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/mkp/src/dev/mkp_vo_dev.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/dev/mkp_vo_dev.c
--- u-boot-2016.11/product/osd/vo/mkp/src/dev/mkp_vo_dev.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/dev/mkp_vo_dev.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,628 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "mkp_vo_dev.h"
+#include "mkp_vo_intf.h"
+#include "mkp_vo_init.h"
+#include "mkp_vo_video.h"
+#include "mkp_vo_comm.h"
+#include "mkp_vo_gfx.h"
+#include "math.h"
+#include "mkp_vo.h"
+#include "board.h"
+#include "common.h"
+#include "vo.h"
+
+static gk_u32 g_bg_color[GK_VO_MAX_PHYS_DEV_NUM] = {0x00ffff, 0xFF00, 0xFF00}; /* default value is CYAN */
+
+gk_u32 vo_dev_get_bg_color(gk_vo_dev dev)
+{
+    return g_bg_color[dev];
+}
+
+gk_void vo_dev_set_bg_color(gk_vo_dev dev, gk_u32 bg_color)
+{
+    g_bg_color[dev] = bg_color;
+}
+
+#if VO_DESC("dev pub api")
+vo_dev_info g_vo_dev[GK_VO_MAX_DEV_NUM] = {0};
+
+vo_dev_info *vo_get_dev_ctx(gk_vo_dev vo_dev)
+{
+    return &(g_vo_dev[vo_dev]);
+}
+
+gk_s32 vo_init_dev_ctx(gk_vo_dev dev)
+{
+    gk_u32 dev_ctx_len;
+    vo_dev_info *dev_ctx = GK_NULL;
+
+    dev_ctx = vo_get_dev_ctx(dev);
+
+    dev_ctx_len = sizeof(vo_dev_info);
+
+    memset(dev_ctx, 0, dev_ctx_len);
+    vo_init_vga_param(&(dev_ctx->vga_param));
+    vo_init_hdmi_param(&(dev_ctx->hdmi_param));
+    vo_init_rgb_param(&(dev_ctx->rgb_param));
+    vo_init_bt_param(&(dev_ctx->bt_param));
+    return GK_SUCCESS;
+}
+
+gk_void vo_init_dev_info(gk_void)
+{
+    if ((vo_get_vo_init_flag() == GK_FALSE)) {
+        vo_drv_dev_info_init();
+    }
+}
+
+gk_bool vo_is_dev_enabled(gk_vo_dev dev)
+{
+    vo_dev_info *dev_ctx = GK_NULL;
+
+    if (vo_def_check_dev_id(dev) != GK_SUCCESS) {
+        vo_warn_trace("Vo device id %d is invalid!\n", dev);
+        return GK_FALSE;
+    }
+
+    dev_ctx = vo_get_dev_ctx(dev);
+    if (dev_ctx == GK_NULL) {
+        return GK_FALSE;
+    }
+
+    return dev_ctx->vo_enable;
+}
+
+gk_void vo_get_dev_max_size(gk_vo_dev dev, gk_size *dev_size)
+{
+    vo_dev_info *dev_ctx = GK_NULL;
+
+    dev_ctx = vo_get_dev_ctx(dev);
+    if (dev_ctx == GK_NULL) {
+        vo_err_trace("vo dev id %d ctx is GK_NULL!\n", dev);
+        dev_size->width = 0;
+        dev_size->height = 0;
+        return;
+    }
+
+    dev_size->width = dev_ctx->max_width;
+    dev_size->height = dev_ctx->max_height;
+}
+
+#endif
+
+#if VO_DESC("intf sync info")
+static vo_intf_sync_info g_vo_intf_sync_info[GK_VO_OUT_BUTT] = {
+    { GK_VO_OUT_PAL,          720,  576  },
+    { GK_VO_OUT_NTSC,         720,  480  },
+    { GK_VO_OUT_960H_PAL,     960,  576  },
+    { GK_VO_OUT_960H_NTSC,    960,  480  },
+
+    { GK_VO_OUT_640x480_60,   640,  480  },
+    { GK_VO_OUT_480P60,       720,  480  },
+    { GK_VO_OUT_576P50,       720,  576  },
+    { GK_VO_OUT_800x600_60,   800,  600  },
+    { GK_VO_OUT_1024x768_60,  1024, 768  },
+    { GK_VO_OUT_720P50,       1280, 720  },
+    { GK_VO_OUT_720P60,       1280, 720  },
+    { GK_VO_OUT_1280x800_60,  1280, 800  },
+    { GK_VO_OUT_1280x1024_60, 1280, 1024 },
+    { GK_VO_OUT_1366x768_60,  1366, 768 },
+    { GK_VO_OUT_1400x1050_60, 1400, 1050 },
+    { GK_VO_OUT_1440x900_60,  1440, 900 },
+    { GK_VO_OUT_1600x1200_60, 1600, 1200 },
+    { GK_VO_OUT_1680x1050_60, 1680, 1050 },
+
+    { GK_VO_OUT_1080P24,      1920, 1080 },
+    { GK_VO_OUT_1080P25,      1920, 1080 },
+    { GK_VO_OUT_1080P30,      1920, 1080 },
+    { GK_VO_OUT_1080I50,      1920, 1080 },
+    { GK_VO_OUT_1080I60,      1920, 1080 },
+    { GK_VO_OUT_1080P50,      1920, 1080 },
+    { GK_VO_OUT_1080P60,      1920, 1080 },
+
+    { GK_VO_OUT_1920x1200_60, 1920, 1200 },
+    { GK_VO_OUT_1920x2160_30, 1920, 2160 },
+    { GK_VO_OUT_2560x1440_30, 2560, 1440 },
+    { GK_VO_OUT_2560x1440_60, 2560, 1440 },
+    { GK_VO_OUT_2560x1600_60, 2560, 1600 },
+
+    { GK_VO_OUT_3840x2160_24, 3840, 2160 },
+    { GK_VO_OUT_3840x2160_25, 3840, 2160 },
+    { GK_VO_OUT_3840x2160_30, 3840, 2160 },
+    { GK_VO_OUT_3840x2160_50, 3840, 2160 },
+    { GK_VO_OUT_3840x2160_60, 3840, 2160 },
+    { GK_VO_OUT_4096x2160_24, 4096, 2160 },
+    { GK_VO_OUT_4096x2160_25, 4096, 2160 },
+    { GK_VO_OUT_4096x2160_30, 4096, 2160 },
+    { GK_VO_OUT_4096x2160_50, 4096, 2160 },
+    { GK_VO_OUT_4096x2160_60, 4096, 2160 },
+    { GK_VO_OUT_7680x4320_30, 7680, 4320 },
+
+    { GK_VO_OUT_240x320_50,   240,  320 },
+    { GK_VO_OUT_320x240_50,   320,  240 },
+    { GK_VO_OUT_240x320_60,   240,  320 },
+    { GK_VO_OUT_320x240_60,   320,  240 },
+    { GK_VO_OUT_800x600_50,   800,  600 },
+
+    { GK_VO_OUT_720x1280_60,  720,  1280 },
+    { GK_VO_OUT_1080x1920_60, 1080, 1920 },
+
+    { GK_VO_OUT_USER,         0,    0,   },
+};
+
+static vo_intf_sync_info *vo_get_intf_sync_info(gk_vo_intf_sync intf_sync)
+{
+    return &g_vo_intf_sync_info[intf_sync];
+}
+
+gk_void vo_get_intf_sync_size(gk_vo_intf_sync intf_sync, gk_u32 *width, gk_u32 *height)
+{
+    vo_intf_sync_info *sync_info = GK_NULL;
+
+    if (vo_is_typical_intf_sync(intf_sync) != GK_TRUE) {
+        return;
+    }
+
+    sync_info = vo_get_intf_sync_info(intf_sync);
+    if (sync_info->intf_sync == intf_sync) {
+        *width = sync_info->width;
+        *height = sync_info->height;
+    }
+}
+
+static gk_void vo_get_intf_sync_size_user(const gk_vo_sync_info *sync_info, gk_u32 *width, gk_u32 *height)
+{
+    *width = sync_info->hact;
+    *height = (sync_info->iop) ? sync_info->vact : sync_info->vact * 2; /* 2 times */
+}
+#endif
+
+#if VO_DESC("enable dev")
+
+static gk_void vo_enable_clk(gk_void)
+{
+    vo_lpw_bus_reset(GK_FALSE);
+    vo_drv_set_all_crg_clk(GK_TRUE);
+}
+
+static gk_s32 vo_check_enable_user_div(gk_vo_dev dev)
+{
+    gk_s32 ret;
+    gk_u32 dev_div;
+    gk_u32 pre_div;
+    vo_dev_info *dev_ctx = GK_NULL;
+
+    dev_ctx = vo_get_dev_ctx(dev);
+    if ((dev_ctx->vou_attr.intf_sync != GK_VO_OUT_USER) || (dev_ctx->user_config != GK_TRUE)) {
+        return GK_SUCCESS;
+    }
+
+    dev_div = dev_ctx->vo_user_sync_info.dev_div;
+    pre_div = dev_ctx->vo_user_sync_info.pre_div;
+    ret = vo_check_dev_user_div(dev, dev_div, pre_div);
+    if (ret != GK_SUCCESS) {
+        vo_err_trace("vo dev %d user sync dev_div %d or pre_div %d is illegal, pls check the user sync info!\n",
+            dev, dev_div, pre_div);
+        return ret;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 vo_check_enable(gk_vo_dev dev)
+{
+    gk_s32 ret;
+    vo_dev_info *dev_ctx = GK_NULL;
+
+    dev_ctx = vo_get_dev_ctx(dev);
+    if (dev_ctx->config != GK_TRUE) {
+        vo_err_trace("vo device %d doesn't configured!\n", dev);
+        return GK_ERR_VO_NOT_CFG;
+    }
+
+    if (dev_ctx->vo_enable == GK_TRUE) {
+        vo_err_trace("vo device %d has enabled!\n", dev);
+        return GK_ERR_VO_NOT_DISABLE;
+    }
+
+    ret = vo_check_enable_user_div(dev);
+    if (ret != GK_SUCCESS) {
+        vo_err_trace("vo%d's user sync info div is illegal!\n", dev);
+        return ret;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_void vo_set_dev_intf_param(gk_vo_dev dev)
+{
+    vo_dev_info *dev_ctx = GK_NULL;
+    dev_ctx = vo_get_dev_ctx(dev);
+    if (GK_VO_INTF_HDMI & dev_ctx->vou_attr.intf_type) {
+        vo_drv_set_hdmi_param(dev, &dev_ctx->hdmi_param);
+    }
+
+    if (GK_VO_INTF_VGA & dev_ctx->vou_attr.intf_type) {
+        vo_drv_set_vga_param(dev, &dev_ctx->vga_param);
+    }
+
+    if ((vo_drv_is_dev_support_rgb(dev) == GK_TRUE) &&
+        (vo_drv_is_rgb_intf(dev_ctx->vou_attr.intf_type))) {
+        vo_drv_set_rgb_param(dev, &dev_ctx->rgb_param);
+    }
+}
+
+static gk_void vo_do_enable_dev(gk_vo_dev dev)
+{
+    vou_drv_set_dev_clk(dev);
+    vo_drv_set_dev_clk_en_sel(dev);
+    vo_drv_open(dev);
+    vo_set_dev_intf_param(dev);
+}
+
+static gk_void vo_had_enable(gk_vo_dev dev)
+{
+    vo_dev_info *dev_ctx = GK_NULL;
+    dev_ctx = vo_get_dev_ctx(dev);
+
+    vo_drv_enable(dev);
+    dev_ctx->vo_enable = GK_TRUE;
+}
+
+static gk_s32 vo_do_enable(gk_vo_dev dev)
+{
+    gk_s32 ret;
+    vo_enable_clk();
+
+    ret = vo_check_enable(dev);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    vo_do_enable_dev(dev);
+    vo_had_enable(dev);
+    return GK_SUCCESS;
+}
+
+gk_s32 vo_enable(gk_vo_dev dev)
+{
+    gk_s32 ret;
+    vo_check_dev_id_return(dev);
+    ret = vo_do_enable(dev);
+    return ret;
+}
+#endif
+
+#if VO_DESC("disable dev")
+gk_void vo_reset_dev_intf_param(gk_vo_dev dev)
+{
+    vo_dev_info *dev_ctx = GK_NULL;
+
+    dev_ctx = vo_get_dev_ctx(dev);
+    vo_init_vga_param(&dev_ctx->vga_param);
+    vo_init_hdmi_param(&dev_ctx->hdmi_param);
+    vo_init_rgb_param(&dev_ctx->rgb_param);
+}
+
+gk_void vo_reset_dev_vars(gk_vo_dev dev)
+{
+    vo_reset_dev_intf_param(dev);
+}
+
+static gk_s32 vo_check_disable(gk_vo_dev dev)
+{
+    if (vo_is_dev_layer_enabled(dev)) {
+        return GK_ERR_VO_NOT_DISABLE;
+    }
+
+    if (vo_is_dev_gfx_layer_enabled(dev)) {
+        return GK_ERR_VO_NOT_DISABLE;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_void vo_reset_vtth(gk_vo_dev dev)
+{
+    if (vo_is_phy_dev(dev)) {
+        vo_drv_set_dev_default_vtth(dev);
+    }
+}
+
+static gk_void vo_disable_clk(gk_void)
+{
+    gk_vo_dev dev;
+    vo_dev_info *dev_ctx = GK_NULL;
+
+    for (dev = 0; dev < GK_VO_MAX_PHYS_DEV_NUM; dev++) {
+        dev_ctx = vo_get_dev_ctx(dev);
+        if (dev_ctx == GK_NULL) {
+            continue;
+        }
+        if ((dev_ctx->vo_enable) || (vou_drv_get_dev_enable(dev) == GK_TRUE)) {
+            break;
+        }
+    }
+
+    if (dev == GK_VO_MAX_PHYS_DEV_NUM) {
+        vo_drv_set_all_crg_clk(GK_FALSE);
+    }
+}
+
+static gk_s32 vo_do_disable(gk_vo_dev dev)
+{
+    gk_s32 ret;
+    vo_dev_info *dev_ctx = GK_NULL;
+    vo_drv_set_all_crg_clk(GK_TRUE);
+
+    ret = vo_check_disable(dev);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+    if (vo_is_phy_dev(dev)) {
+        vo_drv_close(dev);
+    }
+
+    vo_drv_disable(dev);
+
+    dev_ctx = vo_get_dev_ctx(dev);
+    dev_ctx->config = GK_FALSE;
+    dev_ctx->vo_enable = GK_FALSE;
+    dev_ctx->user_config = GK_FALSE;
+    vo_reset_dev_vars(dev);
+
+    vo_reset_vtth(dev);
+
+    vo_disable_clk();
+
+    return GK_SUCCESS;
+}
+
+gk_s32 vo_disable(gk_vo_dev dev)
+{
+    gk_s32 ret;
+
+    vo_check_dev_id_return(dev);
+
+    ret = vo_do_disable(dev);
+    return ret;
+}
+#endif
+
+#if VO_DESC("pub attr")
+
+static gk_s32 vo_check_set_pub_attr(gk_vo_dev dev, const gk_vo_pub_attr *pub_attr)
+{
+    gk_s32 ret;
+    vo_dev_info *dev_ctx = GK_NULL;
+
+    dev_ctx = vo_get_dev_ctx(dev);
+    if (dev_ctx->vo_enable == GK_TRUE) {
+        vo_err_trace("vo%d doesn't disabled!\n", dev);
+        return GK_ERR_VO_NOT_DISABLE;
+    }
+
+    ret = vou_drv_check_dev_pub_attr(dev, pub_attr);
+    if (ret != GK_SUCCESS) {
+        vo_err_trace("vo%d's pub attr is illegal!\n", dev);
+        return ret;
+    }
+    return GK_SUCCESS;
+}
+
+static gk_void vo_set_phy_dev_pub_attr(gk_vo_dev dev)
+{
+    gk_u32 vtth;
+
+    vtth = vo_drv_get_dev_vtth(dev);
+    vo_drv_set_dev_vtth(dev, vtth);
+}
+
+static gk_void vo_set_disp_max_size(gk_vo_dev dev, const gk_vo_pub_attr *pub_attr)
+{
+    gk_u32 max_width = VO_DISP_1080_WIDTH;
+    gk_u32 max_height = VO_DISP_1080_HEIGHT;
+    vo_dev_info *dev_ctx = GK_NULL;
+    gk_vo_intf_sync intf_sync = pub_attr->intf_sync;
+
+    if (vo_is_typical_intf_sync(intf_sync)) {
+        vo_get_intf_sync_size(intf_sync, &max_width, &max_height);
+    } else if (vo_is_user_intf_sync(intf_sync)) {
+        vo_get_intf_sync_size_user(&pub_attr->sync_info, &max_width, &max_height);
+    }
+
+    dev_ctx = vo_get_dev_ctx(dev);
+    dev_ctx->max_width = max_width;
+    dev_ctx->max_height = max_height;
+
+    vou_drv_set_disp_max_size(dev, max_width, max_height);
+}
+
+static gk_s32 vo_do_set_pub_attr(gk_vo_dev dev, const gk_vo_pub_attr *pub_attr)
+{
+    gk_s32 ret;
+    vo_dev_info *dev_ctx = GK_NULL;
+
+    ret = vo_check_set_pub_attr(dev, pub_attr);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    vo_set_disp_max_size(dev, pub_attr);
+    vo_drv_set_pub_attr(dev, pub_attr);
+
+    dev_ctx = vo_get_dev_ctx(dev);
+    memcpy(&dev_ctx->vou_attr, pub_attr, sizeof(gk_vo_pub_attr));
+    dev_ctx->config = GK_TRUE;
+
+    if (vo_is_phy_dev(dev)) {
+        vo_set_phy_dev_pub_attr(dev);
+    }
+
+    return GK_SUCCESS;
+}
+
+gk_s32 vo_set_pub_attr(gk_vo_dev dev, const gk_vo_pub_attr *pub_attr)
+{
+    gk_s32 ret;
+
+    vo_check_null_ptr_return(pub_attr);
+    vo_check_dev_id_return(dev);
+
+    ret = vo_do_set_pub_attr(dev, pub_attr);
+
+    return ret;
+}
+#endif
+
+#if VO_DESC("user sync info")
+static gk_s32 vo_check_dev_user_dev_div(gk_vo_dev dev, gk_u32 dev_div)
+{
+    if ((dev_div < VO_MIN_DIV_MODE) || (dev_div > VO_MAX_DIV_MODE)) {
+        vo_err_trace("vo(%d) dev div %u is illegal, it must be in [%u,%u].\n", dev, dev_div, VO_MIN_DIV_MODE,
+            VO_MAX_DIV_MODE);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    return vo_drv_check_intf_user_dev_div(dev, dev_div);
+}
+
+static gk_s32 vo_check_intf_user_pre_div(gk_vo_dev dev, gk_u32 pre_div)
+{
+    gk_vo_intf_type intf_type;
+    vo_dev_info *dev_ctx = GK_NULL;
+
+    dev_ctx = vo_get_dev_ctx(dev);
+    intf_type = dev_ctx->vou_attr.intf_type;
+    if (vo_drv_is_hdmi_intf(intf_type) != GK_TRUE) {
+        if (pre_div != VO_INTF_NO_HDMI_PRE_DIV_MODE) {
+            vo_err_trace("vo(%d) pre div %u is illegal, it must be %u when intf type is %u.\n", dev, pre_div,
+                VO_INTF_NO_HDMI_PRE_DIV_MODE, intf_type);
+            return GK_ERR_VO_ILLEGAL_PARAM;
+        }
+    }
+
+    return GK_SUCCESS;
+}
+
+gk_s32 vo_check_dev_user_pre_div(gk_vo_dev dev, gk_u32 pre_div)
+{
+    if ((pre_div < VO_MIN_PRE_DIV_MODE) || (pre_div > VO_MAX_PRE_DIV_MODE)) {
+        vo_err_trace("vo(%d) pre div %u is illegal, it must be in [%u,%u].\n", dev, pre_div,
+            VO_MIN_PRE_DIV_MODE, VO_MAX_PRE_DIV_MODE);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    return vo_check_intf_user_pre_div(dev, pre_div);
+}
+
+gk_s32 vo_check_dev_user_div(gk_vo_dev dev, gk_u32 dev_div, gk_u32 pre_div)
+{
+    gk_s32 ret;
+
+    ret = vo_check_dev_user_dev_div(dev, dev_div);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    return vo_check_dev_user_pre_div(dev, pre_div);
+}
+
+static gk_s32 vo_check_dev_user_sync_info(gk_vo_dev dev, const gk_vo_user_sync_info *sync_info)
+{
+    gk_s32 ret;
+
+    ret = vo_check_dev_user_div(dev, sync_info->dev_div, sync_info->pre_div);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    if (vo_check_bool_value(sync_info->clk_reverse_en) != GK_SUCCESS) {
+        vo_err_trace("vo(%d) clk_reverse_en %d is illegal!\n", dev, sync_info->clk_reverse_en);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    return vo_drv_check_dev_clkvalue(dev, sync_info);;
+}
+static gk_s32 vo_check_do_user_sync_info(gk_vo_dev dev)
+{
+    vo_dev_info *dev_ctx = GK_NULL;
+
+    dev_ctx = vo_get_dev_ctx(dev);
+    if (dev_ctx->config != GK_TRUE) {
+        vo_err_trace("vo device %d doesn't configured!\n", dev);
+        return GK_ERR_VO_NOT_CFG;
+    }
+
+    if (dev_ctx->vou_attr.intf_sync != GK_VO_OUT_USER) {
+        vo_err_trace("vo device %d only support this in user sync.\n", dev);
+        return GK_ERR_VO_NOT_SUPPORT;
+    }
+
+    return GK_SUCCESS;
+}
+static gk_s32 vo_check_set_user_sync_info(gk_vo_dev dev, const gk_vo_user_sync_info *sync_info)
+{
+    gk_s32 ret;
+    vo_dev_info *dev_ctx = GK_NULL;
+
+    ret = vo_check_do_user_sync_info(dev);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    dev_ctx = vo_get_dev_ctx(dev);
+    if (dev_ctx->vo_enable == GK_TRUE) {
+        vo_err_trace("vo device %d has enabled!\n", dev);
+        return GK_ERR_VO_NOT_DISABLE;
+    }
+
+    ret = vo_check_dev_user_sync_info(dev, sync_info);
+    if (ret != GK_SUCCESS) {
+        vo_err_trace("VO%d's user sync info is illegal ret=0x%x!\n", dev, ret);
+        return ret;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 vo_do_set_user_sync_info(gk_vo_dev dev, const gk_vo_user_sync_info *sync_info)
+{
+    gk_s32 ret;
+    vo_dev_info *dev_ctx = GK_NULL;
+    vo_drv_set_all_crg_clk(GK_TRUE);
+
+    ret = vo_check_set_user_sync_info(dev, sync_info);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    vo_drv_set_dev_user_intf_sync_attr(dev, sync_info);
+
+    vo_drv_set_dev_div(dev, sync_info->dev_div);
+
+    vo_drv_set_hdmi_div(dev, sync_info->pre_div);
+
+    vo_drv_set_clk_reverse(dev, sync_info->clk_reverse_en);
+
+    dev_ctx = vo_get_dev_ctx(dev);
+    memcpy(&dev_ctx->vo_user_sync_info, sync_info, sizeof(gk_vo_user_sync_info));
+    dev_ctx->user_config = GK_TRUE;
+    return GK_SUCCESS;
+}
+
+gk_s32 vo_set_user_sync_info(gk_vo_dev dev, const gk_vo_user_sync_info *sync_info)
+{
+    gk_s32 ret;
+
+    vo_check_dev_id_return(dev);
+    vo_check_null_ptr_return(sync_info);
+
+    ret = vo_do_set_user_sync_info(dev, sync_info);
+
+    return ret;
+}
+#endif
diff -uraN u-boot-2016.11/product/osd/vo/mkp/src/dev/mkp_vo_dev.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/dev/mkp_vo_dev.h
--- u-boot-2016.11/product/osd/vo/mkp/src/dev/mkp_vo_dev.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/dev/mkp_vo_dev.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __MKP_VO_DEV_H__
+#define __MKP_VO_DEV_H__
+
+#include "common_vo.h"
+#include "drv_vo.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#define VO_DEV_TIME_REF_STEP        2
+
+#define VO_DEV_MAX_FRAME_RATE       240
+
+typedef struct {
+    gk_vo_intf_sync intf_sync;
+    gk_u32 width;
+    gk_u32 height;
+} vo_intf_sync_info;
+
+typedef struct {
+    gk_bool vo_enable;
+    gk_bool config;
+    gk_vo_pub_attr vou_attr;
+
+    gk_u32 max_width;
+    gk_u32 max_height;
+
+    gk_bool user_config;
+    gk_vo_user_sync_info vo_user_sync_info;
+    gk_vo_vga_param vga_param;
+    gk_vo_hdmi_param hdmi_param;
+    gk_vo_rgb_param rgb_param;
+    gk_vo_bt_param bt_param;
+} vo_dev_info;
+
+gk_void vo_init_dev_info(gk_void);
+vo_dev_info *vo_get_dev_ctx(gk_vo_dev vo_dev);
+gk_s32 vo_init_dev_ctx(gk_vo_dev dev);
+
+gk_bool vo_is_dev_enabled(gk_vo_dev dev);
+gk_void vo_get_dev_max_size(gk_vo_dev dev, gk_size *dev_size);
+gk_void vo_get_intf_sync_size(gk_vo_intf_sync intf_sync, gk_u32 *width, gk_u32 *height);
+gk_void vo_get_dev_max_size(gk_vo_dev dev, gk_size *dev_size);
+
+gk_s32 vo_enable(gk_vo_dev dev);
+gk_s32 vo_disable(gk_vo_dev dev);
+
+gk_s32 vo_set_pub_attr(gk_vo_dev dev, const gk_vo_pub_attr *pub_attr);
+gk_s32 vo_get_pub_attr(gk_vo_dev dev, gk_vo_pub_attr *pub_attr);
+
+gk_s32 vo_check_dev_user_div(gk_vo_dev dev, gk_u32 dev_div, gk_u32 pre_div);
+gk_s32 vo_set_user_sync_info(gk_vo_dev dev, const gk_vo_user_sync_info *sync_info);
+
+gk_u32 vo_dev_get_bg_color(gk_vo_dev dev);
+gk_void vo_dev_set_bg_color(gk_vo_dev dev, gk_u32 bg_color);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* end of #ifndef __MKP_VO_DEV_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/mkp/src/intf/mkp_vo_intf.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/intf/mkp_vo_intf.c
--- u-boot-2016.11/product/osd/vo/mkp/src/intf/mkp_vo_intf.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/intf/mkp_vo_intf.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "mkp_vo_intf.h"
+#include "drv_vo.h"
+#include "vo.h"
+#include "mkp_vo.h"
+
+#include "mkp_vo_comm.h"
+#include "mkp_vo_dev.h"
+
+#if VO_DESC("hdmi param")
+gk_void vo_init_hdmi_param(gk_vo_hdmi_param *hdmi_param)
+{
+    hdmi_param->csc.csc_matrix = GK_VO_CSC_MATRIX_BT601FULL_TO_BT601FULL;
+    hdmi_param->csc.luma = VO_CSC_DEF_VAL;
+    hdmi_param->csc.contrast = VO_CSC_DEF_VAL;
+    hdmi_param->csc.hue = VO_CSC_DEF_VAL;
+    hdmi_param->csc.saturation = VO_CSC_DEF_VAL;
+    hdmi_param->csc.ex_csc_en = GK_FALSE;
+}
+#endif
+#if VO_DESC("vga param")
+gk_void vo_init_vga_param(gk_vo_vga_param *vga_param)
+{
+    vga_param->csc.csc_matrix = GK_VO_CSC_MATRIX_BT601FULL_TO_RGBFULL;
+    vga_param->csc.luma = VO_CSC_DEF_VAL;
+    vga_param->csc.contrast = VO_CSC_DEF_VAL;
+    vga_param->csc.hue = VO_CSC_DEF_VAL;
+    vga_param->csc.saturation = VO_CSC_DEF_VAL;
+    vga_param->csc.ex_csc_en = GK_FALSE;
+    vga_param->gain = vo_drv_get_vga_gain_def();
+    vga_param->sharpen_strength = VO_VGA_SHARPEN_STRENGTH_DEF;
+}
+#endif
+
+#if VO_DESC("rgb param")
+gk_void vo_init_rgb_param(gk_vo_rgb_param *rgb_param)
+{
+    rgb_param->csc.csc_matrix = GK_VO_CSC_MATRIX_BT601FULL_TO_RGBFULL;
+    rgb_param->csc.luma = VO_CSC_DEF_VAL;
+    rgb_param->csc.contrast = VO_CSC_DEF_VAL;
+    rgb_param->csc.hue = VO_CSC_DEF_VAL;
+    rgb_param->csc.saturation = VO_CSC_DEF_VAL;
+    rgb_param->csc.ex_csc_en = GK_FALSE;
+    rgb_param->rgb_inverted_en = GK_FALSE;
+    rgb_param->bit_inverted_en = GK_FALSE;
+}
+#endif
+
+#if VO_DESC("bt param")
+gk_void vo_init_bt_param(gk_vo_bt_param *bt_param)
+{
+    bt_param->yc_inverted_en = GK_FALSE;
+    bt_param->bit_inverted_en = GK_FALSE;
+}
+#endif
diff -uraN u-boot-2016.11/product/osd/vo/mkp/src/intf/mkp_vo_intf.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/intf/mkp_vo_intf.h
--- u-boot-2016.11/product/osd/vo/mkp/src/intf/mkp_vo_intf.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/intf/mkp_vo_intf.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __MKP_VO_INTF_H__
+#define __MKP_VO_INTF_H__
+
+#include "common_vo.h"
+#include "mkp_vo.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+gk_void vo_init_vga_param(gk_vo_vga_param *vga_param);
+gk_void vo_init_hdmi_param(gk_vo_hdmi_param *hdmi_param);
+gk_void vo_init_rgb_param(gk_vo_rgb_param *rgb_param);
+gk_void vo_init_bt_param(gk_vo_bt_param *bt_param);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* end of #ifndef __MKP_VO_INTF_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/mkp/src/layer/mkp_vo_gfx.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/layer/mkp_vo_gfx.c
--- u-boot-2016.11/product/osd/vo/mkp/src/layer/mkp_vo_gfx.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/layer/mkp_vo_gfx.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,297 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#include "mkp_vo_gfx.h"
+#include "common_vo.h"
+#include "mkp_vo_gfx.h"
+#include "mkp_vo_dev.h"
+#include "mkp_vo_video.h"
+#include "mkp_vo_comm.h"
+#include "drv_vo_gfx.h"
+#include "vo.h"
+#include "drv_vo.h"
+#include "common.h"
+
+#if VO_DESC("public api")
+vo_gfxlayer_context g_vo_gfx_layer_ctx[GK_VO_MAX_GFX_LAYER_NUM];
+
+vo_gfxlayer_context *vo_get_gfx_layer_ctx(gk_vo_layer vo_layer)
+{
+    return &(g_vo_gfx_layer_ctx[vo_layer - GK_VO_LAYER_G0]);
+}
+
+gk_void vo_init_gfx(gk_void)
+{
+    gk_vo_layer gfx_layer;
+    vo_gfxlayer_context *gfx_layer_ctx = GK_NULL;
+
+    for (gfx_layer = GK_VO_LAYER_G0; gfx_layer < GK_VO_LAYER_G0 + GK_VO_MAX_GFX_LAYER_NUM; gfx_layer++) {
+        gfx_layer_ctx = vo_get_gfx_layer_ctx(gfx_layer);
+
+        gfx_layer_ctx->gfx_csc.csc_matrix = GK_VO_CSC_MATRIX_RGBFULL_TO_BT601FULL;
+        gfx_layer_ctx->gfx_csc.luma = VO_CSC_DEF_VAL;
+        gfx_layer_ctx->gfx_csc.contrast = VO_CSC_DEF_VAL;
+        gfx_layer_ctx->gfx_csc.hue = VO_CSC_DEF_VAL;
+        gfx_layer_ctx->gfx_csc.saturation = VO_CSC_DEF_VAL;
+        gfx_layer_ctx->gfx_csc.ex_csc_en = GK_FALSE;
+        gfx_layer_ctx->csc_param.csc_scale2p = GFX_CSC_SCALE;
+        gfx_layer_ctx->csc_param.csc_clip_min = GFX_CSC_CLIP_MIN;
+        gfx_layer_ctx->csc_param.csc_clip_max = GFX_CSC_CLIP_MAX;
+    }
+}
+
+gk_vo_dev vo_get_gfx_bind_dev(gk_vo_layer layer)
+{
+    return vou_drv_get_gfx_bind_dev(layer);
+}
+
+gk_s32 vo_check_gfx_id(gk_vo_layer gfx_layer)
+{
+    if (vo_def_is_gfx_layer_id(gfx_layer) != GK_TRUE) {
+        return GK_ERR_VO_INVALID_LAYER_ID;
+    }
+
+    return vo_drv_check_gfx_id(gfx_layer);
+}
+#endif
+
+#if VO_DESC("gfx attr")
+static gk_s32 vo_check_gfx_attr_display_rect(gk_vo_dev dev, gk_vo_layer layer, const gk_rect *rect)
+{
+    gk_size dev_size;
+
+    vo_get_dev_max_size(dev, &dev_size);
+    if ((rect->x < 0) || (rect->y < 0) || (rect->width < VO_RESO_MIN_WDT) || (rect->height < VO_RESO_MIN_HGT) ||
+        ((rect->width + rect->x) > dev_size.width) || ((rect->height + rect->y) > dev_size.height)) {
+        vo_err_trace("layer(%d) display rect(%d, %d, %d,%d) is illegal, should between (%d, %d) and (%d, %d)\n",
+            layer, rect->x, rect->y, rect->width, rect->height,
+            VO_RESO_MIN_WDT, VO_RESO_MIN_HGT, dev_size.width, dev_size.height);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    if (vo_check_rect_align(rect) != GK_SUCCESS) {
+        vo_err_trace("layer(%d), display rect (%d, %d, %d, %d) dosen't aligned by 2 pixels!\n",
+            layer, rect->x, rect->y, rect->width, rect->height);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    return vo_drv_check_gfx_attr_display_rect(layer, rect);
+}
+
+static gk_s32 vo_check_gfx_attr_stride(gk_vo_layer layer, const gk_vo_gfx_attr *attr)
+{
+    if (((attr->stride % VO_RECT_ALIGN) != 0)) {
+        vo_err_trace("layer%d's stride %d is illegal!\n", layer, attr->stride);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    if (((attr->address % VO_ADDR_ALIGN) != 0)) {
+        vo_err_trace("layer%d's addr 0x%lx is illegal, it should be %d bytes align!\n", layer, attr->address,
+            VO_ADDR_ALIGN);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 vo_check_gfx_attr_type(gk_vo_layer layer, const gk_vo_gfx_attr *attr)
+{
+    if ((attr->type != GK_VO_GFX_TYPE_ARGB1555) &&
+        (attr->type != GK_VO_GFX_TYPE_BMP1555)) {
+        vo_err_trace("layer%d's picture type %d is illegal!\n", layer, attr->type);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 vo_check_gfx_attr(gk_vo_dev dev, gk_vo_layer layer, const gk_vo_gfx_attr *attr)
+{
+    gk_s32 ret;
+    ret = vo_check_gfx_attr_display_rect(dev, layer, &attr->display_rect);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    ret = vo_check_gfx_attr_stride(layer, attr);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    return vo_check_gfx_attr_type(layer, attr);
+}
+
+static gk_s32 vo_check_set_gfx_attr(gk_vo_layer layer, const gk_vo_gfx_attr *attr)
+{
+    gk_vo_dev dev;
+
+    dev = vo_get_gfx_bind_dev(layer);
+    if (vo_check_layer_binded_dev(layer, dev) != GK_SUCCESS) {
+        vo_err_trace("vo layer %d can't set layer attr when the layer has not been binded!\n", layer);
+        return GK_ERR_VO_NOT_BINDED;
+    }
+
+    if (vo_is_dev_enabled(dev) != GK_TRUE) {
+        vo_err_trace("vo gfx layer %d bind dev %d doesn't enable!\n", layer, dev);
+        return GK_ERR_VO_NOT_ENABLE;
+    }
+
+    return vo_check_gfx_attr(dev, layer, attr);
+}
+
+static gk_void vo_set_gfx_attr_in_drv(gk_vo_layer layer, const gk_vo_gfx_attr *attr)
+{
+    hal_disp_layer gfx_layer = HAL_DISP_LAYER_GFX0;
+    vo_gfxlayer_context *gfx_layer_ctx = GK_NULL;
+
+    gfx_layer_ctx = vo_get_gfx_layer_ctx(layer);
+    vo_drv_get_hal_gfx_layer(layer, &gfx_layer);
+    vo_drv_set_gfx_layer_csc(gfx_layer, &gfx_layer_ctx->gfx_csc, &gfx_layer_ctx->csc_param);
+    vou_drv_layer_csc_enable(gfx_layer, GK_TRUE);
+}
+
+static gk_s32 vo_do_set_gfx_attr(gk_vo_layer layer, const gk_vo_gfx_attr *attr)
+{
+    gk_s32 ret;
+
+    ret = vo_check_set_gfx_attr(layer, attr);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    vo_set_gfx_attr_in_drv(layer, attr);
+
+    return GK_SUCCESS;
+}
+
+gk_s32 vo_set_gfx_attr(gk_vo_layer layer, const gk_vo_gfx_attr *attr)
+{
+    gk_s32 ret;
+
+    vo_check_null_ptr_return(attr);
+    vo_check_gfx_id_return(layer);
+
+    ret = vo_do_set_gfx_attr(layer, attr);
+    return ret;
+}
+
+#endif
+
+#if VO_DESC("enable gfx")
+
+gk_bool vo_is_gfx_layer_enabled(gk_vo_layer layer)
+{
+    vo_gfxlayer_context *ctx = GK_NULL;
+
+    ctx = vo_get_gfx_layer_ctx(layer);
+    return ctx->opened;
+}
+
+gk_bool vo_is_dev_gfx_layer_enabled(gk_vo_dev dev)
+{
+    gk_vo_layer gfx_layer;
+
+    gfx_layer = vo_drv_get_gfx_layer(dev);
+    if (vo_is_gfx_layer_enabled(gfx_layer) == GK_TRUE) {
+        vo_err_trace("vo %d's gfx layer %d doesn't disable!\n", dev, gfx_layer);
+        return GK_TRUE;
+    }
+
+    return GK_FALSE;
+}
+
+static gk_s32 vo_check_enable_gfx_layer(gk_vo_layer layer)
+{
+    gk_vo_dev dev;
+
+    dev = vo_get_gfx_bind_dev(layer);
+    if (vo_check_layer_binded_dev(layer, dev) != GK_SUCCESS) {
+        vo_err_trace("layer(%d) is not bind any dev!\n", layer);
+        return GK_ERR_VO_NOT_BINDED;
+    }
+
+    if (vo_is_dev_enabled(dev) != GK_TRUE) {
+        vo_err_trace("vo device %d doesn't enable!\n", dev);
+        return GK_ERR_VO_NOT_ENABLE;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 vo_do_enable_gfx_layer(gk_vo_layer layer, const gk_vo_gfx_attr *gfx_attr)
+{
+    gk_s32 ret;
+    vo_gfxlayer_context *gfx_ctx = GK_NULL;
+
+    gfx_ctx = vo_get_gfx_layer_ctx(layer);
+    if (gfx_ctx->opened == GK_TRUE) {
+        vo_warn_trace("video layer%d has been enabled!\n", layer);
+        return GK_SUCCESS;
+    }
+
+    ret = vo_check_enable_gfx_layer(layer);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    gfx_ctx->opened = GK_TRUE;
+
+    vo_drv_gfx_open(layer, gfx_attr);
+
+    return GK_SUCCESS;
+}
+
+gk_s32 vo_enable_gfx_layer(gk_vo_layer layer, const gk_vo_gfx_attr *gfx_attr)
+{
+    gk_s32 ret;
+    vo_check_gfx_id_return(layer);
+    ret = vo_do_enable_gfx_layer(layer, gfx_attr);
+    return ret;
+}
+
+#endif
+
+#if VO_DESC("disable gfx")
+static gk_s32 vo_check_disable_gfx_layer(gk_vo_layer layer)
+{
+    gk_vo_dev dev;
+
+    dev = vo_get_gfx_bind_dev(layer);
+    if (vo_check_layer_binded_dev(layer, dev) != GK_SUCCESS) {
+        vo_err_trace("layer(%d) is not bind any dev!\n", layer);
+        return GK_ERR_VO_NOT_BINDED;
+    }
+    return GK_SUCCESS;
+}
+
+static gk_s32 vo_do_disable_gfx_layer(gk_vo_layer layer)
+{
+    gk_s32 ret;
+    vo_gfxlayer_context *gfx_layer_ctx = GK_NULL;
+    ret = vo_check_disable_gfx_layer(layer);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+    gfx_layer_ctx = vo_get_gfx_layer_ctx(layer);
+    if (gfx_layer_ctx->opened == GK_FALSE) {
+        return GK_SUCCESS;
+    }
+    vo_drv_gfx_close(layer);
+    /* sleep: msleep(40); */
+    gfx_layer_ctx->opened = GK_FALSE;
+
+    return GK_SUCCESS;
+}
+
+gk_s32 vo_disable_gfx_layer(gk_vo_layer layer_id)
+{
+    gk_s32 ret;
+
+    vo_check_gfx_id_return(layer_id);
+    ret = vo_do_disable_gfx_layer(layer_id);
+
+    return ret;
+}
+#endif
diff -uraN u-boot-2016.11/product/osd/vo/mkp/src/layer/mkp_vo_gfx.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/layer/mkp_vo_gfx.h
--- u-boot-2016.11/product/osd/vo/mkp/src/layer/mkp_vo_gfx.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/layer/mkp_vo_gfx.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __MKP_VO_GFX_H__
+#define __MKP_VO_GFX_H__
+
+#include "type.h"
+#include "common.h"
+#include "common_vo.h"
+#include "drv_vo_gfx.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+gk_void vo_init_gfx(gk_void);
+gk_bool vo_is_dev_gfx_layer_enabled(gk_vo_dev dev);
+gk_s32 vo_set_gfx_attr(gk_vo_layer layer, const gk_vo_gfx_attr *attr);
+gk_s32 vo_enable_gfx_layer(gk_vo_layer layer, const gk_vo_gfx_attr *gfx_attr);
+gk_s32 vo_disable_gfx_layer(gk_vo_layer layer_id);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* end of #ifndef __MKP_VO_GFX_H__ */
diff -uraN u-boot-2016.11/product/osd/vo/mkp/src/layer/mkp_vo_video.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/layer/mkp_vo_video.c
--- u-boot-2016.11/product/osd/vo/mkp/src/layer/mkp_vo_video.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/layer/mkp_vo_video.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,412 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#include "mkp_vo_video.h"
+#include "common_vo.h"
+#include "mkp_vo.h"
+#include "vo.h"
+#include "sys_ext.h"
+
+#include "mkp_vo_comm.h"
+#include "mkp_vo_dev.h"
+#include "common.h"
+
+#if VO_DESC("public api")
+vo_layer_info g_vo_layer[GK_VO_MAX_LAYER_NUM];
+
+vo_layer_info *vo_get_layer_ctx(gk_vo_layer vo_layer)
+{
+    return &(g_vo_layer[vo_layer]);
+}
+
+static gk_void vo_init_def_layer_ctx(gk_vo_layer layer, vo_layer_info *ctx)
+{
+    vou_drv_init_default_csc(layer);
+    vou_drv_init_default_csc_param(layer);
+    vou_drv_get_default_csc(layer, &ctx->layer_csc);
+}
+
+gk_s32 vo_init_layer_ctx(gk_vo_layer layer)
+{
+    gk_u32 layer_ctx_len;
+    vo_layer_info *ctx = GK_NULL;
+
+    ctx = vo_get_layer_ctx(layer);
+
+    layer_ctx_len = sizeof(vo_layer_info);
+
+    memset(ctx, 0, layer_ctx_len);
+    vo_init_def_layer_ctx(layer, ctx);
+    return GK_SUCCESS;
+}
+
+gk_void vo_init_layer_resource(gk_void)
+{
+    vo_drv_layer_info_init();
+}
+
+gk_vo_dev vo_get_video_layer_bind_dev(gk_vo_layer layer)
+{
+    return vou_drv_get_video_layer_bind_dev(layer);
+}
+
+gk_s32 vo_check_layer_binded_dev(gk_vo_layer layer, gk_vo_dev dev)
+{
+    if (dev == GK_INVALID_DEV) {
+        return GK_ERR_VO_NOT_BINDED;
+    }
+
+    if (vo_def_check_dev_id(dev) != GK_SUCCESS) {
+        vo_warn_trace("vo layer %d binded dev %d is invalid!\n", layer, dev);
+        return GK_ERR_VO_INVALID_DEV_ID;
+    }
+
+    return GK_SUCCESS;
+}
+
+gk_bool vo_is_layer_enabled(gk_vo_layer layer)
+{
+    vo_layer_info *ctx = GK_NULL;
+
+    ctx = vo_get_layer_ctx(layer);
+    if (ctx == GK_NULL) {
+        return GK_FALSE;
+    }
+
+    return ctx->video_enable;
+}
+
+gk_bool vo_is_dev_layer_enabled(gk_vo_dev dev)
+{
+    gk_u32 layer_num;
+    gk_u32 loop;
+    gk_vo_layer layer[GK_VO_MAX_LAYER_IN_DEV] = {0};
+
+    layer_num = vou_drv_get_dev_layer_num(dev);
+    if (layer_num == 0) {
+        return GK_FALSE;
+    }
+    vou_drv_get_dev_layer(dev, &(layer[0]), GK_VO_MAX_LAYER_IN_DEV);
+    for (loop = 0; loop < layer_num; loop++) {
+
+        if (vo_is_layer_enabled(layer[loop]) == GK_TRUE) {
+            vo_err_trace("vo %d's video layer %d doesn't disable!\n", dev, layer[loop]);
+            return GK_TRUE;
+        }
+    }
+
+    return GK_FALSE;
+}
+
+#endif
+
+#if VO_DESC("enable video layer")
+gk_bool vo_is_layer_configured(gk_vo_layer layer)
+{
+    vo_layer_info *ctx = GK_NULL;
+
+    ctx = vo_get_layer_ctx(layer);
+    if (ctx == GK_NULL) {
+        vo_err_trace("vo layer %d ctx is GK_NULL!\n", layer);
+        return GK_FALSE;
+    }
+
+    return ctx->video_config;
+}
+
+static gk_s32 vo_check_enable_video_layer(gk_vo_layer layer)
+{
+    gk_vo_dev dev;
+
+    if (vo_is_layer_configured(layer) != GK_TRUE) {
+        vo_err_trace("layer%d's video layer hasn't configured!\n", layer);
+        return GK_ERR_VO_NOT_CFG;
+    }
+
+    dev = vo_get_video_layer_bind_dev(layer);
+    if (vo_check_layer_binded_dev(layer, dev) != GK_SUCCESS) {
+        vo_err_trace("layer(%d) is not bind any dev!\n", layer);
+        return GK_ERR_VO_NOT_BINDED;
+    }
+
+    if (vo_is_dev_enabled(dev) != GK_TRUE) {
+        vo_err_trace("vo device %d doesn't enable!\n", dev);
+        return GK_ERR_VO_NOT_ENABLE;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 vo_do_enable_video_layer(gk_vo_layer layer, const gk_vo_video_layer_attr *video_attr)
+{
+    gk_s32 ret;
+    vo_layer_info *layer_ctx = GK_NULL;
+
+    layer_ctx = vo_get_layer_ctx(layer);
+    if (layer_ctx->video_enable == GK_TRUE) {
+        vo_warn_trace("layer%d's video layer has been enabled!\n", layer);
+        return GK_SUCCESS;
+    }
+
+    ret = vo_check_enable_video_layer(layer);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    layer_ctx->video_enable = GK_TRUE;
+
+    vo_drv_layer_open(layer, video_attr);
+
+    return GK_SUCCESS;
+}
+
+gk_s32 vo_enable_video_layer(gk_vo_layer layer, const gk_vo_video_layer_attr *video_attr)
+{
+    gk_s32 ret;
+
+    vo_check_layer_id_return(layer);
+    vo_check_gfx_layer_return(layer);
+
+    ret = vo_do_enable_video_layer(layer, video_attr);
+    return ret;
+}
+
+#endif
+
+#if VO_DESC("disable video layer")
+gk_void vo_reset_layer_vars(gk_vo_layer layer)
+{
+    vo_layer_info *layer_ctx = GK_NULL;
+
+    layer_ctx = vo_get_layer_ctx(layer);
+
+    vou_drv_init_default_csc(layer);
+    vou_drv_init_default_csc_param(layer);
+
+    vou_drv_get_default_csc(layer, &layer_ctx->layer_csc);
+}
+
+static gk_s32 vo_check_disable_video_layer(gk_vo_layer layer)
+{
+    gk_vo_dev dev;
+
+    dev = vo_get_video_layer_bind_dev(layer);
+    if (vo_check_layer_binded_dev(layer, dev) != GK_SUCCESS) {
+        vo_err_trace("layer(%d) is not bind any dev!\n", layer);
+        return GK_ERR_VO_NOT_BINDED;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 vo_do_disable_video_layer(gk_vo_layer layer)
+{
+    gk_s32 ret;
+    gk_s32 dev;
+    vo_layer_info *layer_ctx = GK_NULL;
+
+    ret = vo_check_disable_video_layer(layer);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    layer_ctx = vo_get_layer_ctx(layer);
+    if (layer_ctx->video_enable == GK_FALSE) {
+        return GK_SUCCESS;
+    }
+
+    dev = vou_drv_get_video_layer_bind_dev(layer);
+    if (vo_is_phy_dev(dev)) {
+        vou_drv_layer_enable(layer, GK_FALSE);
+        vou_drv_set_layer_reg_up(layer);
+        /* sleep: msleep(40); */
+    }
+
+    layer_ctx->video_enable = GK_FALSE;
+    layer_ctx->video_config = GK_FALSE;
+    vo_drv_disable_layer(layer);
+
+    vo_reset_layer_vars(layer);
+
+    return GK_SUCCESS;
+}
+
+gk_s32 vo_disable_video_layer(gk_vo_layer layer_id)
+{
+    vo_check_layer_id_return(layer_id);
+    vo_check_gfx_layer_return(layer_id);
+
+    return vo_do_disable_video_layer(layer_id);
+}
+
+#endif
+
+#if VO_DESC("layer attr")
+
+static gk_s32 vo_check_layer_attr_display_rect(gk_vo_dev dev, gk_vo_layer layer, const gk_rect *rect)
+{
+    gk_size dev_size;
+
+    vo_get_dev_max_size(dev, &dev_size);
+    if ((rect->x < 0) || (rect->y < 0) || (rect->width < VO_RESO_MIN_WDT) || (rect->height < VO_RESO_MIN_HGT) ||
+        ((rect->width + rect->x) > dev_size.width) || ((rect->height + rect->y) > dev_size.height)) {
+        vo_err_trace("layer(%d) display rect(%d, %d, %u, %u) is illegal, should between (%u, %u) and (%u, %u)\n",
+            layer, rect->x, rect->y, rect->width, rect->height,
+            VO_RESO_MIN_WDT, VO_RESO_MIN_HGT, dev_size.width, dev_size.height);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    if (vo_check_rect_align(rect) != GK_SUCCESS) {
+        vo_err_trace("layer(%d), display rect (%d, %d, %u, %u) dosen't aligned by 2 pixels!\n",
+            layer, rect->x, rect->y, rect->width, rect->height);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    return vo_drv_check_layer_attr_display_rect(layer, rect);
+}
+
+static gk_s32 vo_check_layer_attr_stride(gk_vo_layer layer, const gk_vo_video_layer_attr *video_attr)
+{
+    if (((video_attr->stride % VO_RECT_ALIGN) != 0)) {
+        vo_err_trace("layer%d's stride %d is illegal!\n", layer, video_attr->stride);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    if ((video_attr->address % VO_ADDR_ALIGN) != 0) {
+        vo_err_trace("layer%d's addr 0x%lx is illegal, it should be %d bytes align!\n", layer, video_attr->address,
+            VO_ADDR_ALIGN);
+        return GK_ERR_VO_ILLEGAL_PARAM;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_s32 vo_check_layer_attr(gk_vo_dev dev, gk_vo_layer layer, const gk_vo_video_layer_attr *video_attr)
+{
+    gk_s32 ret;
+    ret = vo_check_layer_attr_display_rect(dev, layer, &video_attr->display_rect);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    return vo_check_layer_attr_stride(layer, video_attr);
+}
+
+static gk_s32 vo_check_set_video_layer_attr(gk_vo_layer layer, const gk_vo_video_layer_attr *video_attr)
+{
+    gk_vo_dev dev;
+
+    dev = vo_get_video_layer_bind_dev(layer);
+    if (vo_check_layer_binded_dev(layer, dev) != GK_SUCCESS) {
+        vo_err_trace("vo layer %d can't set layer attr when the layer has not been binded!\n", layer);
+        return GK_ERR_VO_NOT_BINDED;
+    }
+
+    if (vo_is_dev_enabled(dev) != GK_TRUE) {
+        vo_err_trace("vo layer %d bind dev %d doesn't enable!\n", layer, dev);
+        return GK_ERR_VO_NOT_ENABLE;
+    }
+
+    return vo_check_layer_attr(dev, layer, video_attr);
+}
+
+static gk_bool vo_is_layer_only_pos_changed(gk_vo_layer layer, const gk_vo_video_layer_attr *video_attr_set)
+{
+    gk_vo_video_layer_attr video_attr_old;
+    vo_layer_info *layer_ctx = GK_NULL;
+
+    layer_ctx = vo_get_layer_ctx(layer);
+
+    memcpy(&video_attr_old, &layer_ctx->vou_video_attr,
+        sizeof(gk_vo_video_layer_attr));
+
+    video_attr_old.display_rect.x = video_attr_set->display_rect.x;
+    video_attr_old.display_rect.y = video_attr_set->display_rect.y;
+
+    if (memcmp(&video_attr_old, video_attr_set, sizeof(gk_vo_video_layer_attr)) == 0) {
+        return GK_TRUE;
+    }
+    return GK_FALSE;
+}
+
+static gk_s32 vo_set_layer_attr_with_layer_enable(gk_vo_layer layer, const gk_vo_video_layer_attr *video_attr)
+{
+    vo_layer_info *layer_ctx = GK_NULL;
+
+    layer_ctx = vo_get_layer_ctx(layer);
+    if ((vo_is_layer_only_pos_changed(layer, video_attr))) {
+            memcpy(&layer_ctx->vou_video_attr, video_attr,
+                sizeof(gk_vo_video_layer_attr));
+            vo_drv_set_layer_attr(layer, video_attr);
+            return GK_SUCCESS;
+    }
+
+    vo_err_trace("layer(%d): change layer attr, but layer doesn't disabled!\n", layer);
+    return GK_ERR_VO_NOT_DISABLE;
+}
+
+static gk_void vo_set_layer_attr_with_layer_disable(gk_vo_layer layer, const gk_vo_video_layer_attr *video_attr)
+{
+    vo_layer_info *layer_ctx = GK_NULL;
+
+    layer_ctx = vo_get_layer_ctx(layer);
+
+    memcpy(&layer_ctx->vou_video_attr, video_attr, sizeof(gk_vo_video_layer_attr));
+    layer_ctx->video_config = GK_TRUE;
+}
+
+static gk_void vo_set_layer_attr_in_drv(gk_vo_layer layer, const gk_vo_video_layer_attr *video_attr)
+{
+    gk_vo_dev dev;
+    vo_layer_info *layer_ctx = GK_NULL;
+    csc_coef_param csc_param;
+
+    dev = vou_drv_get_video_layer_bind_dev(layer);
+    layer_ctx = vo_get_layer_ctx(layer);
+
+    vo_drv_set_layer_attr(layer, video_attr);
+
+    if (vo_is_phy_dev(dev)) {
+        vou_drv_get_default_csc(layer, &layer_ctx->layer_csc);
+        vou_drv_get_layer_csc_param(layer, &csc_param);
+        vou_drv_layer_csc_config(layer, &layer_ctx->layer_csc, &csc_param);
+        vou_drv_layer_csc_enable(layer, GK_TRUE);
+    }
+}
+
+static gk_s32 vo_do_set_video_layer_attr(gk_vo_layer layer, const gk_vo_video_layer_attr *video_attr)
+{
+    gk_s32 ret;
+
+    ret = vo_check_set_video_layer_attr(layer, video_attr);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    if (vo_is_layer_enabled(layer)) {
+        ret = vo_set_layer_attr_with_layer_enable(layer, video_attr);
+        return ret;
+    }
+
+    vo_set_layer_attr_with_layer_disable(layer, video_attr);
+    vo_set_layer_attr_in_drv(layer, video_attr);
+
+    return GK_SUCCESS;
+}
+
+gk_s32 vo_set_video_layer_attr(gk_vo_layer layer, const gk_vo_video_layer_attr *video_attr)
+{
+    gk_s32 ret;
+
+    vo_check_null_ptr_return(video_attr);
+    vo_check_layer_id_return(layer);
+    vo_check_gfx_layer_return(layer);
+
+    ret = vo_do_set_video_layer_attr(layer, video_attr);
+    return ret;
+}
+
+#endif
+
diff -uraN u-boot-2016.11/product/osd/vo/mkp/src/layer/mkp_vo_video.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/layer/mkp_vo_video.h
--- u-boot-2016.11/product/osd/vo/mkp/src/layer/mkp_vo_video.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/layer/mkp_vo_video.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+
+#ifndef __MKP_VO_VIDEO_H__
+#define __MKP_VO_VIDEO_H__
+
+#include "common_vo.h"
+#include "common.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#define VO_LAYER_DISPLAY_MAX_FRAME_RATE  240 /* max display frame rate */
+
+#define VO_LAYER_PLAY_TOLERATION_UNIT   1000
+
+gk_bool vo_is_multi_layer(gk_vo_layer layer);
+gk_bool vo_is_single_layer(gk_vo_layer layer);
+gk_bool vo_is_layer_enabled(gk_vo_layer layer);
+gk_bool vo_is_layer_configured(gk_vo_layer layer);
+gk_bool vo_is_layer_bypass(gk_vo_layer layer);
+gk_bool vo_is_layer_cluster_mode_enabled(gk_vo_layer layer);
+gk_vo_dev vo_get_video_layer_bind_dev(gk_vo_layer layer);
+gk_s32 vo_check_layer_binded_dev(gk_vo_layer layer, gk_vo_dev dev);
+gk_bool vo_is_layer_binded_dev(gk_vo_layer layer);
+gk_bool vo_is_dev_layer_enabled(gk_vo_dev dev);
+gk_bool vo_is_layer_chn_enabled(gk_vo_layer layer);
+gk_void vo_exit_layer(gk_void);
+
+gk_s32 vo_init_layer_ctx(gk_vo_layer layer);
+
+gk_void vo_init_layer_info(gk_void);
+gk_void vo_init_layer_resource(gk_void);
+gk_void vo_deinit_layer_info(gk_void);
+
+gk_s32 vo_enable_video_layer(gk_vo_layer layer, const gk_vo_video_layer_attr *video_attr);
+gk_s32 vo_disable_video_layer(gk_vo_layer layer);
+
+gk_s32 vo_set_video_layer_attr(gk_vo_layer layer, const gk_vo_video_layer_attr *video_attr);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* end of #ifndef __MKP_VO_VIDEO_H__ */
+
diff -uraN u-boot-2016.11/product/osd/vo/mkp/src/mkp_vo_bmp.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/mkp_vo_bmp.c
--- u-boot-2016.11/product/osd/vo/mkp/src/mkp_vo_bmp.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/mkp_vo_bmp.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "mkp_vo_bmp.h"
+#include "common.h"
+
+gk_s32 load_bmp(gk_phys_addr_t bmp_addr, osd_logo_t *video_logo)
+{
+    gk_u16 bpp;
+    osd_bitmap_file_header bmp_file_header;
+    osd_bitmap_info bmp_info;
+
+    memcpy(&bmp_file_header, (char *)(uintptr_t)(bmp_addr + sizeof(gk_u16)), sizeof(osd_bitmap_file_header));
+    memcpy(&bmp_info, (char *)(uintptr_t)(bmp_addr + sizeof(gk_u16) + sizeof(osd_bitmap_file_header)), sizeof(osd_bitmap_info));
+    video_logo->width = bmp_info.bmi_header.bi_width;
+    video_logo->height = bmp_info.bmi_header.bi_height;
+    video_logo->stride = bmp_info.bmi_header.bi_width * (OSD_BI_BIT_COUNT_16BPP / 8); /* 8 bits per bytes */
+    video_logo->rgb_buffer = bmp_addr + bmp_file_header.bf_off_bits;
+
+    bpp = bmp_info.bmi_header.bi_bit_count;
+    if (bpp != OSD_BI_BIT_COUNT_16BPP) { /* 16 bits, 2bytes per pixel bitmap format */
+        printf("bitmap format bpp=%d not supported! only supoort format bpp=%d\n", bpp, OSD_BI_BIT_COUNT_16BPP);
+        return -1;
+    }
+    return 0;
+}
diff -uraN u-boot-2016.11/product/osd/vo/mkp/src/mkp_vo_bmp.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/mkp_vo_bmp.h
--- u-boot-2016.11/product/osd/vo/mkp/src/mkp_vo_bmp.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/mkp_vo_bmp.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#ifndef __MKP_VO_BMP_H__
+#define __MKP_VO_BMP_H__
+
+#include "type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+typedef struct {
+    gk_u16 bi_size;
+    gk_u32 bi_width;
+    gk_s32 bi_height;
+    gk_u16 bi_planes;
+    gk_u16 bi_bit_count;
+    gk_u32 bi_compression;
+    gk_u32 bi_size_image;
+    gk_u32 bi_x_pels_per_meter;
+    gk_u32 bi_y_pels_per_meter;
+    gk_u32 bi_clr_used;
+    gk_u32 bi_clr_important;
+} osd_bitmap_info_header;
+
+typedef struct {
+    gk_u8 rgb_blue;
+    gk_u8 rgb_green;
+    gk_u8 rgb_red;
+    gk_u8 rgb_reserved;
+} osd_rgb_quad;
+
+typedef struct {
+    gk_u32 bf_size;
+    gk_u16 bf_reserved1;
+    gk_u16 bf_reserved2;
+    gk_u32 bf_off_bits;
+} osd_bitmap_file_header;
+
+typedef struct {
+    osd_bitmap_info_header bmi_header;
+    osd_rgb_quad bmi_colors[1];
+} osd_bitmap_info;
+
+typedef struct {
+    gk_u32 width;       /* out */
+    gk_u32 height;      /* out */
+    gk_u32 stride;      /* in */
+    gk_phys_addr_t rgb_buffer; /* in */
+} osd_logo_t;
+
+typedef enum {
+    OSD_BI_BIT_COUNT_1BPP = 1,
+    OSD_BI_BIT_COUNT_4BPP = 4,
+    OSD_BI_BIT_COUNT_8BPP = 8,
+    OSD_BI_BIT_COUNT_16BPP = 16,
+    OSD_BI_BIT_COUNT_24BPP = 24,
+    OSD_BI_BIT_COUNT_32BPP = 32,
+} osd_bi_bit_count;
+
+gk_s32 load_bmp(gk_phys_addr_t bmp_addr, osd_logo_t *video_logo);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* end of #ifdef __cplusplus */
+
+#endif /* end of #ifndef __MKP_VO_BMP__ */
diff -uraN u-boot-2016.11/product/osd/vo/mkp/src/mkp_vo_user.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/mkp_vo_user.c
--- u-boot-2016.11/product/osd/vo/mkp/src/mkp_vo_user.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/mkp_vo_user.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "mkp_vo_user.h"
+#include "mkp_vo.h"
+
+#if VO_DESC("dev user sync timing")
+/* dhd0: 1080P60, dhd1: 1080P60, dsd0: pal */
+static gk_vo_sync_info g_vo_user_sync_timing[GK_VO_MAX_PHYS_DEV_NUM] = {
+    /*
+     * |--INTFACE---||-----TOP-----||----HORIZON--------||----BOTTOM-----||-PULSE-||-INVERSE-|
+     * syncm, iop, itf,   vact, vbb,  vfb,  hact,  hbb,  hfb, hmid,bvact,bvbb, bvfb, hpw, vpw,idv, ihs, ivs
+     */
+    { 0, 1, 1, 1080, 41, 4, 1920, 192, 88,  1,    1,   1,  1,  44, 5, 0, 0, 0 }, /* 1080P@60_hz */
+    { 0, 1, 1, 1080, 41, 4, 1920, 192, 88,  1,    1,   1,  1,  44, 5, 0, 0, 0 }, /* 1080P@60_hz */
+    { 0, 0, 0,  288, 22, 2,  720, 132, 12,  1,  288,  23,  2, 126, 3, 0, 0, 0 }, /* 576I(PAL)  */
+};
+
+gk_vo_sync_info *vo_get_dev_user_sync_timing(gk_vo_dev dev)
+{
+    if ((dev < 0) || (dev >= GK_VO_MAX_PHYS_DEV_NUM)) {
+        return GK_NULL;
+    }
+    return &(g_vo_user_sync_timing[dev]);
+}
+#endif
+
+#if VO_DESC("dev user sync info")
+/* dhd0: 1080P60, dhd1: 1080P60, dsd0: pal */
+static gk_vo_user_sync_info g_vo_user_sync_info[GK_VO_MAX_PHYS_DEV_NUM] = {
+    {
+        .user_sync_attr = {
+            .clk_src = GK_VO_CLK_SRC_PLL,
+            .vo_pll = { /* if hdmi, set it by pixel clk and div mode */
+                .fb_div = 99, /* 99 fb div */
+                .frac = 0,
+                .ref_div = 2, /* 2 ref div */
+                .post_div1 = 4, /* 4 post div1 */
+                .post_div2 = 2, /* 2 post div2 */
+            },
+        },
+        .pre_div = 1, /* if hdmi, set it by pixel clk */
+        .dev_div = 1, /* if rgb, set it by serial mode */
+        .clk_reverse_en = GK_TRUE,
+    }, {
+        .user_sync_attr = {
+            .clk_src = GK_VO_CLK_SRC_PLL,
+            .vo_pll = { /* if hdmi, set it by pixel clk and div mode */
+                .fb_div = 99, /* 99 fb div */
+                .frac = 0,
+                .ref_div = 2, /* 2 ref div */
+                .post_div1 = 4, /* 4 post div1 */
+                .post_div2 = 2, /* 2 post div2 */
+            },
+        },
+        .pre_div = 1, /* if hdmi, set it by pixel clk */
+        .dev_div = 1, /* if rgb, set it by serial mode */
+        .clk_reverse_en = GK_TRUE,
+    }, {
+        .user_sync_attr = {
+            .clk_src = GK_VO_CLK_SRC_PLL,
+            .vo_pll = { /* if hdmi, set it by pixel clk and div mode */
+                .fb_div = 99, /* 99 fb div */
+                .frac = 0,
+                .ref_div = 2, /* 2 ref div */
+                .post_div1 = 4, /* 4 post div1 */
+                .post_div2 = 2, /* 2 post div2 */
+            },
+        },
+        .pre_div = 1, /* if hdmi, set it by pixel clk */
+        .dev_div = 4, /* if cvbs, set it by 4 div mode */
+        .clk_reverse_en = GK_FALSE,
+    }
+};
+
+gk_vo_user_sync_info *vo_get_dev_user_sync_info(gk_vo_dev dev)
+{
+    if ((dev < 0) || (dev >= GK_VO_MAX_PHYS_DEV_NUM)) {
+        return GK_NULL;
+    }
+    return &g_vo_user_sync_info[dev];
+}
+#endif
diff -uraN u-boot-2016.11/product/osd/vo/mkp/src/vo.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/vo.c
--- u-boot-2016.11/product/osd/vo/mkp/src/vo.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/osd/vo/mkp/src/vo.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,184 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "vo.h"
+#include "mkp_vo_dev.h"
+#include "mkp_vo_video.h"
+#include "mkp_vo_comm.h"
+#include "mkp_vo_gfx.h"
+#include "mkp_vo_init.h"
+#include "mkp_vo_user.h"
+#include "math.h"
+#include <common.h>
+#include <command.h>
+#include <version.h>
+#include <asm/io.h>
+#include <asm/arch/platform.h>
+#include <config.h>
+
+#include "drv_vo.h"
+#include "drv_vo_gfx.h"
+
+gk_void vo_dcache_range(gk_phys_addr_t start_addr, gk_u64 size)
+{
+    if (dcache_status()) {
+        flush_dcache_range(start_addr, start_addr + size);
+    }
+}
+
+int set_vobg(unsigned int dev, unsigned int rgb)
+{
+    vo_check_dev_id_return(dev);
+    vo_dev_set_bg_color(dev, rgb);
+    return GK_SUCCESS;
+}
+
+static gk_void vo_construct_pub_attr(unsigned int dev,
+    unsigned int type, unsigned int sync, gk_vo_pub_attr *pub_attr)
+{
+    gk_vo_sync_info *sync_info = GK_NULL;
+
+    pub_attr->bg_color = vo_dev_get_bg_color(dev);
+    pub_attr->intf_sync = sync;
+    pub_attr->intf_type = type;
+    if (vo_is_user_intf_sync(sync) == GK_TRUE) {
+        sync_info = vo_get_dev_user_sync_timing(dev);
+        if (sync_info != NULL) {
+            memcpy(&(pub_attr->sync_info), sync_info, sizeof(gk_vo_sync_info));
+        }
+    }
+}
+
+static gk_s32 vo_set_user_sync_clk(unsigned int dev, unsigned int sync)
+{
+    gk_s32 ret;
+    gk_vo_user_sync_info *user_sync = GK_NULL;
+
+    if (vo_is_user_intf_sync(sync) == GK_TRUE) {
+        /* set the user sync info: clk source, clk value */
+        user_sync = vo_get_dev_user_sync_info(dev);
+        if (user_sync == GK_NULL) {
+            return GK_FAILURE;
+        }
+        ret = vo_set_user_sync_info(dev, user_sync);
+        if (ret != GK_SUCCESS) {
+            return ret;
+        }
+    }
+    return GK_SUCCESS;
+}
+
+int start_vo(unsigned int dev, unsigned int type, unsigned int sync)
+{
+    gk_s32 ret;
+    gk_vo_pub_attr pub_attr = {0};
+
+    vo_init();
+
+    vo_construct_pub_attr(dev, type, sync, &pub_attr);
+
+    ret = vo_set_pub_attr(dev, &pub_attr);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    ret = vo_set_user_sync_clk(dev, sync);
+    if (ret != GK_SUCCESS) {
+        return ret;
+    }
+
+    ret = vo_enable(dev);
+    return ret;
+}
+
+int stop_vo(unsigned int dev)
+{
+    vo_check_dev_id_return(dev);
+    return vo_disable(dev);
+}
+
+static gk_s32 vo_construct_gfx_attr(unsigned long addr, unsigned int strd,
+    gk_rect gfx_rect, unsigned int type, gk_vo_gfx_attr *gfx_attr)
+{
+    gk_vo_gfx_attr gfx_attr_tmp = {0};
+
+    gfx_attr_tmp.stride = strd;
+    gfx_attr_tmp.address = addr;
+    gfx_attr_tmp.type = type;
+    memcpy(&gfx_attr_tmp.display_rect, &gfx_rect, sizeof(gk_rect));
+
+    return vo_drv_gfx_convert_gfx_attr(&gfx_attr_tmp, gfx_attr);
+}
+
+int start_gx(unsigned int layer, unsigned long addr, unsigned int strd, gk_rect gx_rect, unsigned int type)
+{
+    gk_s32 ret;
+    gk_vo_gfx_attr gfx_attr = {0};
+
+    ret = vo_construct_gfx_attr(addr, strd, gx_rect, type, &gfx_attr);
+    if (ret != GK_SUCCESS) {
+        vo_err_trace("convert gfx attr failed.\n");
+        return ret;
+    }
+
+    ret = vo_set_gfx_attr(layer, &gfx_attr);
+    if (ret != GK_SUCCESS) {
+        printf("invalid parameter!\n");
+        return ret;
+    }
+    ret = vo_enable_gfx_layer(layer, &gfx_attr);
+
+    return ret;
+}
+
+int stop_gx(unsigned int layer)
+{
+    gk_s32 ret;
+    ret = vo_disable_gfx_layer(layer);
+    if (ret != GK_SUCCESS) {
+        printf("invalid parameter!\n");
+        return ret;
+    }
+
+    return GK_SUCCESS;
+}
+
+static gk_void vo_contruct_video_layer_attr(unsigned long addr, unsigned int strd,
+    gk_rect layer_rect, gk_vo_video_layer_attr *video_attr)
+{
+    video_attr->stride = strd;
+    video_attr->address = addr;
+    memcpy(&video_attr->display_rect, &layer_rect, sizeof(gk_rect));
+}
+
+int start_videolayer(unsigned int layer, unsigned long addr, unsigned int strd, gk_rect layer_rect)
+{
+    gk_s32 ret;
+    gk_vo_video_layer_attr video_attr = {0};
+
+    vo_contruct_video_layer_attr(addr, strd, layer_rect, &video_attr);
+    ret = vo_set_video_layer_attr(layer, &video_attr);
+    if (ret != GK_SUCCESS) {
+        printf("invalid parameter!\n");
+        return ret;
+    }
+
+    vo_dcache_range(addr, strd * layer_rect.height * 3 / 2); /* 3 / 2 times */
+
+    ret = vo_enable_video_layer(layer, &video_attr);
+
+    return ret;
+}
+
+int stop_videolayer(unsigned int layer)
+{
+    gk_s32 ret;
+    ret = vo_disable_video_layer(layer);
+    if (ret != GK_SUCCESS) {
+        printf("invalid parameter!\n");
+        return ret;
+    }
+
+    return 0;
+}
diff -uraN u-boot-2016.11/product/otp/hal_otp.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/otp/hal_otp.c
--- u-boot-2016.11/product/otp/hal_otp.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/otp/hal_otp.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,170 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include "hal_otp.h"
+#include "cipher_adapt.h"
+
+#ifdef OTP_SUPPORT
+
+typedef enum {
+	OTP_USER_LOCK_STA0_TYPE,
+	OTP_USER_LOCK_STA1_TYPE,
+	OTP_USER_LOCK_UNKNOWN_STA,
+} opt_lock_sta_type_e;
+
+typedef enum {
+	OTP_READ_LOCK_STA_MODE,
+	OTP_LOCK_CIPHER_KEY_MODE,
+	OTP_WRITE_KEY_ID_OR_PASSWD_MODE,
+	OTP_KEY_ID_OR_PASSWD_CRC_MODE,
+	OTP_SET_FLAG_ENABLE_MODE,
+	OTP_WRITE_USER_ROOM_MODE,
+	OTP_READ_USER_ROOM_MODE,
+	OTP_UNKOOWN_MODE,
+} otp_user_work_mode_e;
+
+typedef enum {
+	OTP_USER_KEY0,
+	OTP_USER_KEY1,
+	OTP_USER_KEY2,
+	OTP_USER_KEY3,
+	OTP_USER_KEY_JTAG_PW_ID,
+	OTP_USER_KEY_JTAG_PW,
+	OTP_USER_KEY_ROOTKEY,
+	OTP_USER_KEY_UNKNOWN,
+} otp_user_key_index_e;
+
+typedef enum {
+	OTP_KEY_LENGTH_64BIT,
+	OTP_KEY_LENGTH_128BIT,
+	OTP_KEY_LENGTH_256BIT,
+	OTP_KEY_LENGTH_UNSUPPORT,
+} otp_user_key_length_e;
+
+gk_void *g_efuse_otp_reg_base = GK_NULL;
+
+/* OTP init */
+gk_s32 hal_efuse_otp_init(gk_void)
+{
+	gk_u32 crg_value = 0;
+	gk_u32 *sys_addr = GK_NULL;
+
+	sys_addr = cipher_ioremap_nocache(REG_SYS_OTP_CLK_ADDR_PHY, 0x100);
+	if (sys_addr == GK_NULL) {
+		gk_err_cipher("ERROR: sys_addr ioremap with nocache failed!!\n");
+		return GK_FAILURE;
+	}
+
+	hal_cipher_read_reg(sys_addr, &crg_value);
+#ifdef OTP_CRG_RESET_SUPPORT
+	crg_value |= OTP_CRG_RESET_BIT;   /* reset */
+	crg_value |= OTP_CRG_CLOCK_BIT;   /* set the bit 0, clock opened */
+	hal_cipher_write_reg(sys_addr, crg_value);
+
+	/* clock select and cancel reset 0x30100 */
+	crg_value &= (~OTP_CRG_RESET_BIT); /* cancel reset */
+#endif
+	crg_value |= OTP_CRG_CLOCK_BIT;   /* set the bit 0, clock opened */
+	hal_cipher_write_reg(sys_addr, crg_value);
+
+	cipher_iounmap(sys_addr);
+	sys_addr = GK_NULL;
+
+	g_efuse_otp_reg_base = cipher_ioremap_nocache(CIPHER_OTP_REG_BASE_ADDR_PHY, 0x100);
+	if (g_efuse_otp_reg_base == GK_NULL) {
+		gk_err_cipher("ERROR: osal_ioremap_nocache for OTP failed!!\n");
+		return GK_FAILURE;
+	}
+
+	return GK_SUCCESS;
+}
+
+static gk_s32 hal_otp_wait_free(gk_void)
+{
+	gk_u32 timeout_cnt = 0;
+	gk_u32 reg_value = 0;
+
+	while (1) {
+		hal_cipher_read_reg(OTP_USER_CTRL_STA, &reg_value);
+		if ((reg_value & 0x1) == 0) /* bit0:otp_op_busy 0:idle, 1:busy */
+			return GK_SUCCESS;
+
+		timeout_cnt++;
+		if (timeout_cnt >= 10000) { /* 10000 count */
+			gk_err_cipher("OTP_WaitFree TimeOut!\n");
+			break;
+		}
+	}
+	return GK_FAILURE;
+}
+
+static gk_s32 hal_otp_set_mode(otp_user_work_mode_e otp_mode)
+{
+	gk_u32 reg_value = otp_mode;
+
+	if (otp_mode >= OTP_UNKOOWN_MODE) {
+		gk_err_cipher("Mode Unknown!\n");
+		return  GK_FAILURE;
+	}
+
+	(gk_void)hal_cipher_write_reg(OTP_USER_WORK_MODE, reg_value);
+	return GK_SUCCESS;
+}
+
+static gk_void hal_otp_op_start(gk_void)
+{
+	gk_u32 reg_value = 0x1acce551;
+	(gk_void)hal_cipher_write_reg(OTP_USER_OP_START, reg_value);
+}
+
+static gk_s32 hal_otp_wait_op_done(gk_void)
+{
+	gk_u32 timeout_cnt = 0;
+	gk_u32 reg_value = 0;
+
+	while (1) {
+		hal_cipher_read_reg(OTP_USER_CTRL_STA, &reg_value);
+		if (reg_value & 0x2) {
+			return GK_SUCCESS;
+		}
+
+		timeout_cnt++;
+		if (timeout_cnt >= 10000) { /* 10000 count */
+			gk_err_cipher("OTP_Wait_OP_done TimeOut!\n");
+			break;
+		}
+	}
+	return GK_FAILURE;
+}
+
+static gk_void hal_choose_otp_key(otp_user_key_index_e which_key)
+{
+	gk_u32 reg_value;
+
+	reg_value = which_key;
+	(gk_void)hal_cipher_write_reg(OTP_USER_KEY_INDEX, reg_value);
+}
+
+/* set otp key to klad */
+gk_s32 hal_efuse_otp_load_cipher_key(gk_u32 chn_id, gk_u32 opt_id)
+{
+	if (opt_id > OTP_USER_KEY3)
+		opt_id = OTP_USER_KEY0;
+
+	if (GK_FAILURE == hal_otp_wait_free())
+		return GK_FAILURE;
+	hal_choose_otp_key(opt_id);
+
+	if (hal_otp_set_mode(OTP_LOCK_CIPHER_KEY_MODE))
+		return GK_FAILURE;
+
+	hal_otp_op_start();
+
+	if (GK_FAILURE == hal_otp_wait_op_done())
+		return GK_FAILURE;
+
+	return  GK_SUCCESS;
+}
+#endif
+
diff -uraN u-boot-2016.11/product/otp/hal_otp.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/otp/hal_otp.h
--- u-boot-2016.11/product/otp/hal_otp.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/otp/hal_otp.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#ifndef __HAL_OTP_H__
+#define __HAL_OTP_H__
+
+#include "types.h"
+
+#define OTP_USER_IF_BASE            g_efuse_otp_reg_base
+#define OTP_USER_WORK_MODE          (OTP_USER_IF_BASE + 0x0000)
+#define OTP_USER_OP_START           (OTP_USER_IF_BASE + 0x0004)
+#define OTP_USER_KEY_INDEX          (OTP_USER_IF_BASE + 0x0008)
+#define OTP_USER_KEY_DATA0          (OTP_USER_IF_BASE + 0x000c)
+#define OTP_USER_KEY_DATA1          (OTP_USER_IF_BASE + 0x0010)
+#define OTP_USER_KEY_DATA2          (OTP_USER_IF_BASE + 0x0014)
+#define OTP_USER_KEY_DATA3          (OTP_USER_IF_BASE + 0x0018)
+#define OTP_USER_KEY_DATA4          (OTP_USER_IF_BASE + 0x001c)
+#define OTP_USER_KEY_DATA5          (OTP_USER_IF_BASE + 0x0020)
+#define OTP_USER_KEY_DATA6          (OTP_USER_IF_BASE + 0x0024)
+#define OTP_USER_KEY_DATA7          (OTP_USER_IF_BASE + 0x0028)
+#define OTP_USER_KEY_DATA8          (OTP_USER_IF_BASE + 0x002c)
+#define OTP_USER_FLAG_VALUE         (OTP_USER_IF_BASE + 0x0030)
+#define OTP_USER_FLAG_INDEX         (OTP_USER_IF_BASE + 0x0034)
+#define OTP_USER_REV_ADDR           (OTP_USER_IF_BASE + 0x0038)
+#define OTP_USER_REV_WDATA          (OTP_USER_IF_BASE + 0x003c)
+#define OTP_USER_REV_RDATA          (OTP_USER_IF_BASE + 0x0040)
+#define OTP_USER_LOCK_STA0          (OTP_USER_IF_BASE + 0x0044)
+#define OTP_USER_LOCK_STA1          (OTP_USER_IF_BASE + 0x0048)
+#define OTP_USER_CTRL_STA           (OTP_USER_IF_BASE + 0x004c)
+
+#if (defined(CONFIG_TARGET_GK7205V200) || defined(CONFIG_TARGET_GK7205V300) || \
+       defined(CONFIG_TARGET_GK7202V300) || defined(CONFIG_TARGET_GK7605V100))
+#define REG_SYS_OTP_CLK_ADDR_PHY    0x120101BC
+#define OTP_CRG_CLOCK_BIT           (0x01 << 1)
+#endif
+
+gk_s32 hal_efuse_otp_init(gk_void);
+gk_s32 hal_efuse_otp_load_cipher_key(gk_u32 chn_id, gk_u32 opt_id);
+
+#endif
diff -uraN u-boot-2016.11/product/otp/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/otp/Makefile
--- u-boot-2016.11/product/otp/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/otp/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,15 @@
+
+cflags-y += -I$(srctree)/product/cipher/v2/api
+cflags-y += -I$(srctree)/product/cipher/v2/drv/platform
+cflags-y += -I$(srctree)/product/cipher/v2/drv/rng
+cflags-y += -I$(srctree)/product/cipher/v2/drv/rsa
+cflags-y += -I$(srctree)/product/cipher/v2/drv/compat
+cflags-y += -I$(srctree)/product/cipher/v2/drv/spacc
+cflags-y += -I$(srctree)/product/cipher/v2/drv/include
+cflags-y += -I$(srctree)/product/otp
+
+ccflags-y  += $(cflags-y)
+HOSTCFLAGS += $(cflags-y)
+CPPFLAGS   += $(cflags-y)
+
+obj-y    += hal_otp.o
diff -uraN u-boot-2016.11/product/update/auto_update_adaptation.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/update/auto_update_adaptation.c
--- u-boot-2016.11/product/update/auto_update_adaptation.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/update/auto_update_adaptation.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,1755 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <common.h>
+#include <environment.h>
+#include <command.h>
+#include <malloc.h>
+#include <image.h>
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <spi_flash.h>
+#include <linux/mtd/mtd.h>
+#include <fat.h>
+#include <console.h>
+#include <mmc.h>
+#include <sparse_format.h>
+#include <linux/kernel.h>
+#include <nand.h>
+#if (CONFIG_AUTO_UPDATE == 1)  /* cover the whole file */
+
+#ifdef CONFIG_AUTO_SD_UPDATE
+#ifndef CONFIG_MMC
+#error "should have defined CONFIG_MMC"
+#endif
+#include <mmc.h>
+#include "mmc_init.c"
+#endif
+
+#if defined CONFIG_AUTO_USB_UPDATE
+#ifndef CONFIG_GK_MC
+#if !defined CONFIG_USB_OHCI && !defined CONFIG_USB_XHCI_HCD
+#error "should have defined CONFIG_USB_OHCI or CONFIG_USB_XHCI"
+#endif
+#endif
+#ifndef CONFIG_USB_STORAGE
+#error "should have defined CONFIG_USB_STORAGE"
+#endif
+#include <usb.h>
+#include "usb_init.c"
+#endif
+#include "../../fs/ext4/unsparse.h"
+
+#undef AU_DEBUG
+#undef debug_print
+#ifdef  AU_DEBUG
+#define debug_print(fmt, args...) printf(fmt, ##args)
+#else
+#define debug_print(fmt, args...)
+#endif  /* AU_DEBUG */
+
+/* possible names of files on the medium. */
+#define AU_CONFIG   "config"
+/* config file's size < 1K */
+#define CONFIG_MAX_SIZE  	2048
+#define BLOCK_SIZE           	512
+#define STR_LEN			80
+#define LINE			16
+#define EMMC_BLOCK_SHIFT	9
+#define NAME_LEN		20
+#define SIZE_M			(1024 * 1024)
+#define SIZE_K			1024
+#define DECI_VALUE		10
+#define STR_STEPS		2
+#define PERCENT_VALUE		100
+#define STOR_DEV_OFFSET		16
+#define STOR_DEV_MASK		0x03
+#define STOR_PART		18
+#define STOR_PART_MASK		0x1f
+
+#ifdef CONFIG_GK_UPGRADE_BY_SEGMENT
+#define SECTION_SIZE         0x1000000UL   /* 16M  */
+#define BLOCK_SIZE           512
+#define DEFAULT_BLOCK_SIZE   4096
+#define CHUNK_HEAD_SIZE      12
+#define BOUNDARY             (DEFAULT_BLOCK_SIZE + CHUNK_HEAD_SIZE)
+#define HEX_DUMP_LEN         128
+unsigned long map_size;
+#endif
+
+#define AU_FIRMWARE "u-boot.bin"
+#define AU_KERNEL   "kernel"
+
+int boot_medium_type = 0xff;
+
+#include "nand.h"
+struct flash_layout {
+	long start;
+	long end;
+};
+
+struct seg_update_parm {
+	loff_t actread;
+	loff_t pos;
+	int extra;
+	int nsect;
+	int uboot_updated;
+	int updatefile_found;
+	unsigned long sz;
+	unsigned int section_size;
+	unsigned int remain;
+};
+struct update_medium_interface {
+	char name[NAME_LEN];
+	int (*init)(void);
+	int (*erase)(unsigned long offset, unsigned long len);
+	int (*write)(unsigned long offset, unsigned long len,
+			unsigned char *buf);
+	int (*write_yaffs)(unsigned long offset, unsigned long len,
+			unsigned char *buf);
+	int (*write_ext4)(unsigned long offset, unsigned long len,
+			unsigned char *buf);
+};
+
+#if defined(CONFIG_CMD_SF) || defined(CONFIG_CMD_NAND)
+static void schedule_notify(unsigned long offset, unsigned long len,
+							unsigned long off_start)
+{
+	int percent_complete = -1;
+	unsigned long long n;
+
+	do {
+		n = (unsigned long long)(offset - off_start) * PERCENT_VALUE;
+		int percent;
+
+		do_div(n, len);
+		percent = (int)n;
+
+		/* output progress message only at whole percent
+		 * steps to reduce the number of messages
+		 * printed on (slow) serial consoles
+		 */
+		if (percent != percent_complete)
+			printf("\rOperation at 0x%lx -- %3d%% complete.",
+				   offset, percent);
+	} while (0);
+}
+#endif
+
+#ifdef CONFIG_CMD_SF
+static struct spi_flash *spinor_flash;
+static int spinor_flash_init(void)
+{
+	spinor_flash = spi_flash_probe(0, 0, 0, 0);
+	return 0;
+}
+
+static int spi_flash_erase_op(struct spi_flash *flash, unsigned long offset,
+							  unsigned long len)
+{
+	int ret;
+	struct mtd_info_ex *spiflash_info = get_spiflash_info();
+	unsigned long erase_start, erase_len, erase_step;
+
+	erase_start = offset;
+	erase_len   = len;
+	erase_step  = spiflash_info->erasesize;
+
+	while (len > 0) {
+		if (len < erase_step)
+			erase_step = len;
+
+		ret = flash->erase(flash, (u32)offset, erase_step);
+		if (ret)
+			return 1;
+
+		len -= erase_step;
+		offset += erase_step;
+		/* notify real time schedule */
+		schedule_notify(offset, erase_len, erase_start);
+	}
+
+	return ret;
+}
+
+static int spinor_flash_erase(unsigned long offset, unsigned long len)
+{
+	return spi_flash_erase_op(spinor_flash, offset, len);
+}
+
+static int spi_flash_write_op(struct spi_flash *flash, unsigned long offset,
+					unsigned long len, unsigned char *buf)
+{
+	int ret;
+	unsigned long write_start, write_len, write_step;
+	unsigned char *pbuf = buf;
+	struct mtd_info_ex *spiflash_info = get_spiflash_info();
+
+	write_start = offset;
+	write_len   = len;
+	write_step  = spiflash_info->erasesize;
+
+	while (len > 0) {
+		if (len < write_step)
+			write_step = len;
+
+		ret = flash->write(flash, offset, write_step, pbuf);
+		if (ret)
+			break;
+
+		offset += write_step;
+		pbuf   += write_step;
+		len    -= write_step;
+		/* notify real time schedule */
+		schedule_notify(offset, write_len, write_start);
+	}
+
+	return ret;
+}
+
+static int spinor_flash_write(unsigned long offset, unsigned long len,
+							unsigned char *buf)
+{
+	return spi_flash_write_op(spinor_flash, offset, len, (unsigned char *)buf);
+}
+#endif
+
+#ifdef CONFIG_CMD_NAND
+struct mtd_info *nand_flash;
+
+static int nand_flash_init(void)
+{
+	nand_flash = nand_info[0];
+	return 0;
+}
+
+static int nand_flash_erase(unsigned long offset, unsigned long len)
+{
+	int ret;
+	unsigned long erase_len;
+	unsigned long erase_step;
+	unsigned long length;
+	nand_erase_options_t opts;
+
+	memset(&opts, 0, sizeof(opts));
+
+	length = len;
+	erase_step = nand_flash->erasesize;
+	erase_len = length;
+	opts.length  = erase_step;
+	opts.offset = offset;
+	opts.quiet = 1;
+
+	while (length > 0) {
+		if (length < erase_step)
+			erase_step = length;
+
+		ret = nand_erase_opts(nand_flash, &opts);
+		if (ret)
+			return 1;
+
+		length -= erase_step;
+		opts.offset += erase_step;
+		/* notify real time schedule */
+		schedule_notify(opts.offset, erase_len, offset);
+	}
+
+	return ret;
+}
+
+static int nand_flash_write(unsigned long offset, unsigned long len,
+						unsigned char *buf)
+{
+	int ret;
+	unsigned long offset_notify;
+	unsigned long write_start;
+	unsigned long write_len;
+	unsigned long write_step;
+	size_t length;
+	unsigned char *pbuf = buf;
+
+	if (offset == 0) {
+		/* Make sure the length is block size algin */
+		length = len & (nand_flash->erasesize - 1) ? (size_t)(len +
+				 (nand_flash->erasesize - len %
+				  nand_flash->erasesize)) : len;
+		write_step  = nand_flash->erasesize;
+	} else {
+		/* Make sure the length is writesize algin */
+		length = len & (nand_flash->erasesize - 1) ? (size_t)(len +
+				 (nand_flash->writesize - len %
+				  nand_flash->writesize)) : len;
+		write_step  = nand_flash->writesize;
+	}
+
+	write_start = offset;
+	offset_notify = offset;
+	write_len   = length;
+
+	while (length > 0) {
+		size_t block_offset = offset & (nand_flash->erasesize - 1);
+		size_t *rw_size;
+
+		if (nand_flash->_block_isbad(nand_flash, offset & ~
+					(nand_flash->erasesize - 1))) {
+			printf("Skip bad block 0x%08llx\n",
+				   offset & ~(loff_t)(nand_flash->erasesize - 1));
+			offset += nand_flash->erasesize - block_offset;
+			continue;
+		}
+
+		rw_size = (size_t *)&write_step;
+
+		ret = nand_flash->_write(nand_flash, (size_t)offset, *rw_size,
+						rw_size, (u_char *)pbuf);
+		if (ret) {
+			printf("NAND write to offset %lx failed %d\n",
+				   offset, ret);
+			break;
+		}
+		offset += write_step;
+		pbuf   += write_step;
+		length -= write_step;
+		offset_notify += write_step;
+		/* notify real time schedule */
+		schedule_notify(offset_notify, write_len, write_start);
+	}
+
+	return ret;
+}
+
+static int nand_flash_yaffs_write(unsigned long offset, unsigned long len,
+							unsigned char *buf)
+{
+	int ret;
+	size_t rw_size = len;
+
+	ret = nand_write_yaffs_skip_bad(nand_flash, offset, &rw_size,
+							(u_char *)buf);
+	if (ret)
+		printk("Write yaffs fail !!\n");
+	printk("Write yaffs done\n");
+
+	return ret;
+}
+
+/* get count of area's bad block for nand flash */
+int get_bad_block_count(unsigned long offset, unsigned long len)
+{
+	int count = 0;
+	unsigned long block_offset = 0;
+	if (offset & (nand_flash->erasesize - 1))
+		block_offset = offset & (nand_flash->erasesize - 1);
+
+	if (len & (nand_flash->erasesize - 1))
+		len = ALIGN(len, nand_flash->erasesize);
+
+	for (int i = 0; i < len / nand_flash->erasesize; i++) {
+		if (nand_block_isbad(nand_flash, offset))
+			count++;
+		offset += nand_flash->erasesize - block_offset;
+	}
+	return count;
+}
+#endif
+
+void hex_dump(unsigned char *buf, int len, int addr)
+{
+	int i;
+	int j;
+	int k;
+	char binstr[STR_LEN];
+
+	for (i = 0; i < len; i++) {
+		if ((i % LINE) == 0) {
+			sprintf(binstr, "%08x -", i + addr);
+			sprintf(binstr, "%s %02x", binstr,
+					(unsigned char)buf[i]);
+		} else if ((i % LINE) == (LINE - 1)) {
+			sprintf(binstr, "%s %02x", binstr,
+					(unsigned char)buf[i]);
+			sprintf(binstr, "%s  ", binstr);
+			for (j = i - (LINE - 1); j <= i; j++)
+				sprintf(binstr, "%s%c", binstr,
+						(buf[j] > '!' &&
+						 buf[j] <= '~') ? buf[j] : '.');
+			printf("%s\n", binstr);
+		} else {
+			sprintf(binstr, "%s %02x", binstr,
+					(unsigned char)buf[i]);
+		}
+	}
+
+	if ((i % LINE) != 0) {
+		k = LINE - (i % LINE);
+		for (j = 0; j < k; j++)
+			sprintf(binstr, "%s   ", binstr);
+		sprintf(binstr, "%s  ", binstr);
+		k = LINE - k;
+		for (j = i - k; j < i; j++)
+			sprintf(binstr, "%s%c", binstr,
+					(buf[j] > '!' && buf[j] <= '~') ? buf[j] : '.');
+		printf("%s\n", binstr);
+	}
+}
+
+#ifdef CONFIG_SUPPORT_EMMC_BOOT
+static int mmc_save_init(void)
+{
+	struct mmc *mmc = find_mmc_device(0);
+
+	if (!mmc) {
+		printf("%s:find mmc device failed\n", __func__);
+		return -1;
+	}
+
+	(void)mmc_init(mmc);
+
+	return 0;
+}
+
+static int mmc_save_write(unsigned long offset, unsigned long len,
+		unsigned char *buf)
+{
+	struct mmc *mmc = find_mmc_device(0);
+
+	if (!mmc) {
+		printf("%s:find mmc device failed\n", __func__);
+		return -1;
+	}
+	if (len % MMC_MAX_BLOCK_LEN)
+		blk_dwrite(mmc_get_blk_desc(mmc), (offset >> EMMC_BLOCK_SHIFT),
+				   (len >> EMMC_BLOCK_SHIFT) + 1, buf);
+	else
+		blk_dwrite(mmc_get_blk_desc(mmc), (offset >> EMMC_BLOCK_SHIFT),
+				   (len >> EMMC_BLOCK_SHIFT), buf);
+
+	return 0;
+}
+#ifndef CONFIG_GK_UPGRADE_BY_SEGMENT
+static int mmc_save_write_ext4(unsigned long offset, unsigned long len,
+							unsigned  char *buf)
+{
+	struct mmc *mmc = find_mmc_device(0);
+	int retlen;
+
+	if (!mmc) {
+		printf("%s:find mmc device failed\n", __func__);
+		return -1;
+	}
+
+	if (len % MMC_MAX_BLOCK_LEN)
+		retlen = ext4_unsparse(mmc, 0, buf,
+			(offset >> EMMC_BLOCK_SHIFT),
+			(len >> EMMC_BLOCK_SHIFT) + 1);
+	else
+		retlen = ext4_unsparse(mmc, 0, buf,
+				(offset >> EMMC_BLOCK_SHIFT),
+				(len >> EMMC_BLOCK_SHIFT));
+	return retlen;
+}
+#endif
+#endif
+
+#define UPDATE_MEDIUM_SPINOR 0
+#define UPDATE_MEDIUM_NAND   1
+#define UPDATE_MEDIUM_EMMC   2
+
+
+static struct update_medium_interface update_intf[3] = {
+#ifdef CONFIG_CMD_SF
+	{"spinor", spinor_flash_init, spinor_flash_erase, spinor_flash_write,
+		NULL, NULL},
+#else
+	{"none", NULL, NULL, NULL, NULL, NULL},
+#endif
+
+#ifdef CONFIG_CMD_NAND
+	{"nand", nand_flash_init, nand_flash_erase, nand_flash_write,
+		nand_flash_yaffs_write, NULL},
+#else
+	{"none",  NULL,  NULL, NULL, NULL, NULL},
+#endif
+#ifdef CONFIG_SUPPORT_EMMC_BOOT
+#ifndef CONFIG_GK_UPGRADE_BY_SEGMENT
+	{"emmc", mmc_save_init, NULL, mmc_save_write, NULL,
+		mmc_save_write_ext4}
+#else
+	{"emmc", mmc_save_init, NULL, mmc_save_write, NULL,  mmc_save_write}
+#endif
+#endif
+};
+
+static struct update_medium_interface *update_intf_p;
+
+struct medium_interface {
+	char name[NAME_LEN];
+	int (*init)(void);
+	void (*exit)(void);
+};
+
+#define MAX_UPDATE_INTF 3
+static struct medium_interface s_intf[MAX_UPDATE_INTF] = {
+#ifdef CONFIG_AUTO_SD_UPDATE
+	{ .name = "mmc", .init = mmc_stor_init, .exit = mmc_stor_exit, },
+#endif
+#ifdef CONFIG_AUTO_USB_UPDATE
+	{ .name = "usb", .init = usb_stor_init, .exit = usb_stor_exit, },
+#endif
+};
+
+static int au_stor_curr_dev; /* current device */
+
+/* index of each file in the following arrays */
+#define IDX_FIRMWARE    0
+#define IDX_KERNEL  1
+#define IDX_ROOTFS  2
+
+/* max. number of files which could interest us */
+#define AU_MAXFILES 32
+
+/* pointers to file names */
+char *aufile[AU_MAXFILES] = {
+	0
+};
+
+#define NAME_MAX_LEN 0x20
+char aufile_table[AU_MAXFILES][NAME_MAX_LEN] = {{0, }, };
+unsigned long aufile_size[AU_MAXFILES] = {0};
+
+/* sizes of flash areas for each file */
+long ausize[AU_MAXFILES] = {0};
+
+/* array of flash areas start and end addresses */
+struct flash_layout aufl_layout[AU_MAXFILES] = {
+	{ 0,    0, }
+};
+
+#ifdef CONFIG_GK_UPGRADE_BY_SEGMENT
+typedef struct buff_layout {
+	unsigned long offset;  /* chunk header offset in next buffer */
+	u32 count;      /* chunk header count */
+	u32 remain;    /* remain add offset equals chunk_len */
+	u32 len;      /* all the data length we need to handle in buffer */
+	u32 type;    /* the last chunk type */
+	u8  flag;   /* 0: filesize < SECTION_SIZE 1: filesize > SECTION_SIZE */
+} buff_layout_t;
+
+buff_layout_t layout;           /* current buffer chunk information */
+buff_layout_t perv_layout;      /* the previous buffer chunk information */
+sparse_header_t sparse_header;  /* Sparse file header information */
+
+#if (defined CONFIG_EMMC) || (defined CONFIG_CMD_UFS)
+int get_buffer_chunk_layout(unsigned long offset, unsigned char *pbuf,
+				unsigned long filesize, unsigned long pos)
+{
+	chunk_header_t *chunk = NULL;
+	unsigned long off;
+	unsigned long chunk_len;
+
+	off = offset;
+
+	/* big chunk handle */
+	if (off > SECTION_SIZE) {
+		layout.offset = off - (SECTION_SIZE - 1);
+		layout.len    = SECTION_SIZE;
+		layout.type   = layout.type;
+		layout.count  = 1;
+		layout.remain = SECTION_SIZE;
+		debug_print("big chunk: layout.count:%u,layout.remain:%u,\
+			layout.offset:%lu,layout.len:%u,\
+			layout.type: % #x\n", layout.count, layout.remain, \
+			layout.offset, layout.len, layout.type);
+		return 0;
+	}
+
+	memset(&layout, 0, sizeof(buff_layout_t));
+
+	if (filesize <= SECTION_SIZE)
+		layout.flag = 0;
+	else
+		layout.flag = 1;
+
+	do {
+		chunk = (chunk_header_t *)(pbuf + off);
+		print_chunk_info(chunk);
+		if ((chunk->chunk_type != CHUNK_TYPE_RAW) &&
+				(chunk->chunk_type != CHUNK_TYPE_DONT_CARE) &&
+				(chunk->chunk_type != CHUNK_TYPE_FILL)) {
+			printf("This type of chunk:%x is not supported\n",\
+					chunk->chunk_type);
+			hex_dump(pbuf + off, HEX_DUMP_LEN, 0);
+			return 1;
+		}
+
+		chunk_len = chunk->chunk_sz * sparse_header.blk_sz;
+		off += chunk->total_sz;
+
+		if ((off <= SECTION_SIZE - 1)) {
+			layout.count++;
+			layout.len = off;
+		} else {
+			/*  Special case handle: just have only one
+			 *  chunk header in buffer
+			 */
+			if (layout.count == 0)
+				layout.len = offset;
+
+			if (((SECTION_SIZE - 1 - layout.len) >=
+						BOUNDARY)) {
+				layout.count += 1;
+				layout.remain = SECTION_SIZE - 1 -
+					layout.len - sparse_header.chunk_hdr_sz;
+				layout.remain = layout.remain &
+					~(DEFAULT_BLOCK_SIZE - 1);
+				layout.offset = chunk_len - layout.remain;
+				layout.len += layout.remain +
+					sparse_header.chunk_hdr_sz;
+				layout.type   = chunk->chunk_type;
+			}
+		}
+	} while (((pos + layout.len) != filesize) &&
+			 ((SECTION_SIZE - layout.len > DEFAULT_BLOCK_SIZE)));
+	printf("layout.count:%u,layout.remain:%u,layout.offset:%lu,\
+		layout.len: % u, layout.type: % #x\n", layout.count, \
+		layout.remain, layout.offset, layout.len, layout.type);
+	return 0;
+}
+
+#endif
+#endif
+
+/* where to load files into memory */
+#if defined(CONFIG_TARGET_GK7205V200) || \
+	defined(CONFIG_TARGET_GK7205V300) || defined(CONFIG_TARGET_GK7202V300) || \
+	defined(CONFIG_TARGET_GK7605V100) 
+#define LOAD_ADDR ((unsigned char *)0x42000000)
+#endif
+/* the app is the largest image */
+#define MAX_LOADSZ ausize[IDX_ROOTFS]
+
+#ifdef CONFIG_GK_UPGRADE_BY_SEGMENT
+
+int write_yaffs2_fs(int idx, unsigned int sz, unsigned char *pbuf)
+{
+#ifdef CONFIG_CMD_NAND
+	int bad_block_count;
+	unsigned long pages_len;
+	int ret;
+	unsigned long tmp_start_addr = aufl_layout[idx].start;
+	unsigned int sec_yaffs = nand_flash->writesize + nand_flash->oobsize;
+
+	if (update_intf_p->write_yaffs) {
+		pages_len = (sz / sec_yaffs) * nand_flash->writesize;
+		bad_block_count = get_bad_block_count(tmp_start_addr, pages_len);
+		debug_print("write offset:%ld, bad block count:%d\n",
+				aufl_layout[idx].start, bad_block_count);
+
+		tmp_start_addr += pages_len + bad_block_count *
+			nand_flash->erasesize;
+
+		if (tmp_start_addr > aufl_layout[idx].end) {
+			printf("The actual length of the partition is greater \
+				than the specified value due to the \
+				address offset caused by bad blocks.\n");
+			return 1;
+		}
+		ret = update_intf_p->write_yaffs(aufl_layout[idx].start, sz,
+				pbuf);
+		if (ret) {
+			printf("write yaffs failed\n");
+			return ret;
+		}
+		aufl_layout[idx].start += pages_len + bad_block_count *
+			nand_flash->erasesize;
+	}
+#endif
+	return 0;
+}
+
+int chunk_write(int idx, int chunk_count, chunk_header_t *chunk,
+	unsigned int write_len, unsigned int chunk_len, unsigned char *pbuf)
+{
+	unsigned int ret;
+
+	switch (chunk->chunk_type) {
+	case CHUNK_TYPE_RAW:
+		if (!layout.flag) {
+			write_len = chunk_len;
+		} else {
+			if (chunk_count == layout.count - 1) {
+				write_len = layout.remain;
+				debug_print("layout.remian:%u\n", layout.remain);
+			} else {
+				write_len = chunk_len;
+			}
+		}
+		ret = update_intf_p->write_ext4(aufl_layout[idx].start, write_len, pbuf);
+		if (ret) {
+			printf("write chunk error\n");
+			return 1;
+		}
+		aufl_layout[idx].start += write_len;
+		pbuf += write_len;
+		break;
+
+	case CHUNK_TYPE_DONT_CARE:
+		aufl_layout[idx].start += chunk_len;
+		break;
+
+	default:
+		printf("sparse:unknow chunk type %04x,chunk_count:%d,\
+				pbuf: %p\n", chunk->chunk_type, chunk_count, pbuf);
+		return 1;
+	}
+	return 0;
+}
+
+int write_ext4_fs(int idx, unsigned int offset, unsigned short type,
+							unsigned char *pbuf)
+{
+	unsigned int write_len;
+	unsigned int chunk_len;
+	int chunk_count;
+	int ret;
+	chunk_header_t *chunk;
+
+	write_len = 0;
+	if (offset && (type == CHUNK_TYPE_RAW)) {
+		if (offset < SECTION_SIZE) {
+			write_len = offset;
+			ret = update_intf_p->write_ext4(
+					aufl_layout[idx].start, write_len, pbuf);
+			if (ret) {
+				printf("write chunk error\n");
+				return 1;
+			}
+			aufl_layout[idx].start += write_len;
+			pbuf += write_len;
+		} else {
+			/* big chunk write */
+			write_len = SECTION_SIZE;
+			ret = update_intf_p->write_ext4(
+					aufl_layout[idx].start, write_len, pbuf);
+			if (ret) {
+				printf("write chunk error\n");
+				return 1;
+			}
+			aufl_layout[idx].start += write_len;
+			return 0;
+		}
+	} else {
+		/* skip the sparse header */
+		pbuf += offset;
+	}
+	for (chunk_count = 0; chunk_count < layout.count; chunk_count++) {
+		chunk = (chunk_header_t *)(pbuf);
+		pbuf += sparse_header.chunk_hdr_sz;
+		chunk_len = chunk->chunk_sz * sparse_header.blk_sz;
+		if (chunk_write(idx, chunk_count, chunk, write_len, chunk_len,
+					pbuf)) {
+			printf("chunk write error\n");
+			return 1;
+		}
+	}
+	printf("write a part of file %s finished\n", aufile[idx]);
+	return 0;
+}
+
+int write_ubi_fs(int idx, unsigned int sz, unsigned char *pbuf)
+{
+#ifdef CONFIG_CMD_NAND
+	int bad_block_count;
+	unsigned long tmp_start_addr;
+	int ret;
+#endif
+	if (boot_medium_type == BOOT_FROM_NAND) {
+#ifdef CONFIG_CMD_NAND
+		tmp_start_addr = aufl_layout[idx].start;
+		while (sz & (nand_flash->writesize - 1))
+			sz = ALIGN(sz, nand_flash->writesize);
+		bad_block_count = get_bad_block_count(tmp_start_addr, sz);
+		debug_print("write offset: start:%ld, bad block count:%d\n",
+				tmp_start_addr, bad_block_count);
+		tmp_start_addr += sz + bad_block_count * nand_flash->erasesize;
+		if (tmp_start_addr > aufl_layout[idx].end) {
+			printf("The actual length of the partition is greater\
+				than the specified value due to the address\
+				offset caused by bad blocks.\n");
+			return 1;
+		}
+		ret = update_intf_p->write((aufl_layout[idx].start), sz, pbuf);
+		if (ret) {
+			printf("spi nand write ubifs error.\n");
+			return 1;
+		}
+		aufl_layout[idx].start += sz + bad_block_count *
+			nand_flash->erasesize;
+#endif
+	} else {
+		/* ubifs for spi nor */
+		update_intf_p->write((aufl_layout[idx].start), sz, pbuf);
+		aufl_layout[idx].start += sz;
+	}
+
+	return 0;
+}
+
+int write_other_files(int idx, unsigned int sz, unsigned char *pbuf)
+{
+	int ret = 0;
+#ifdef CONFIG_CMD_NAND
+	int bad_block_count;
+	unsigned long tmp_start_addr;
+#endif
+	if (boot_medium_type == BOOT_FROM_NAND) {
+#ifdef CONFIG_CMD_NAND
+		tmp_start_addr = aufl_layout[idx].start;
+		while (sz & (nand_flash->writesize - 1))
+			sz = ALIGN(sz, nand_flash->writesize);
+		debug_print("write start:%ld, len:%u,pagesize:%u\n",
+			aufl_layout[idx].start, sz, nand_flash->writesize);
+		bad_block_count = get_bad_block_count(tmp_start_addr, sz);
+		tmp_start_addr += sz + bad_block_count * nand_flash->erasesize;
+		/* u-boot */
+		if (strcmp((char *)AU_FIRMWARE, aufile[idx]) == 0) {
+			if (tmp_start_addr > aufl_layout[idx].end) {
+				printf("The address offset caused by bad\
+				blocks causes the u-boot.bin file to overwrite the environment variable.\n");
+				return 1;
+			}
+		} else if (strcmp((char *)AU_KERNEL, aufile[idx]) == 0) {
+			if (tmp_start_addr > aufl_layout[idx].end) {
+				printf("The address offset caused by bad blocks causes the kernel file to\
+						overwrite the File system.\n");
+				return 1;
+			}
+		}
+		ret = update_intf_p->write((aufl_layout[idx].start), sz, pbuf);
+		aufl_layout[idx].start += sz + bad_block_count *
+			nand_flash->erasesize;
+
+#endif
+	} else if (boot_medium_type == BOOT_FROM_EMMC) {
+		if (sz & (BLOCK_SIZE - 1))
+			sz = ALIGN(sz, BLOCK_SIZE);
+		debug_print("write start:%ld, len:%#x\n", aufl_layout[idx].start, sz);
+		ret = update_intf_p->write((aufl_layout[idx].start), sz, pbuf);
+		aufl_layout[idx].start += sz;
+	} else if (boot_medium_type == BOOT_FROM_SPI) {
+		debug_print("write start:%ld, len:%#x\n", aufl_layout[idx].start, sz);
+		ret = update_intf_p->write((aufl_layout[idx].start), sz, pbuf);
+		aufl_layout[idx].start += sz;
+	}
+
+	if (ret) {
+		printf("write file %s failed\n", aufile[idx]);
+		return ret;
+	}
+	return 0;
+}
+#endif
+#ifndef CONFIG_GK_UPGRADE_BY_SEGMENT
+static int au_do_update(int idx, long sz)
+{
+	unsigned long start;
+	unsigned long len;
+	unsigned long write_len;
+	int rc = 0;
+	char *buf;
+	void *pbuf;
+
+	start = aufl_layout[idx].start;
+	len = aufl_layout[idx].end - aufl_layout[idx].start + 1;
+
+	/* erase the address range. */
+	if (boot_medium_type == BOOT_FROM_SPI || boot_medium_type == BOOT_FROM_NAND) {
+		printf("%s erase...\n", update_intf_p->name);
+		rc = update_intf_p->erase(start, len);
+		if (rc) {
+			printf("sector erase failed\n");
+			return 1;
+		}
+	}
+
+	buf = map_physmem((unsigned long)LOAD_ADDR, len, MAP_WRBACK);
+	if (!buf) {
+		puts("Failed to map physical memory\n");
+		return 1;
+	}
+
+	/* write the whole file to flash;uboot and rootfs image have head
+	 * kernel has head,it's head also be writed to flash
+	 */
+	pbuf = buf;
+	write_len = aufile_size[idx];
+
+	/* copy the data from RAM to FLASH */
+	printf("\n%s write...\n", update_intf_p->name);
+
+	if (strstr(aufile[idx], "yaffs")) {
+		if (update_intf_p->write_yaffs)
+			rc = update_intf_p->write_yaffs(start, write_len, pbuf);
+	} else if (strstr(aufile[idx], "ext4")) {
+		if (update_intf_p->write_ext4)
+			rc = update_intf_p->write_ext4(start, len, pbuf);
+	} else {
+		rc = update_intf_p->write(start, write_len, pbuf);
+	}
+
+	if (rc) {
+		printf("write failed, return %d\n", rc);
+		return 1;
+	}
+
+	unmap_physmem(buf, len);
+	return 0;
+}
+#else
+static int au_do_update(int idx, unsigned int sz, int segment, u32 offset,
+							u16 type)
+{
+	int rc;
+	void *buf;
+	unsigned char *pbuf;
+	unsigned long erase_len;
+
+	if (segment > 0)
+		goto write_op;
+
+	if (boot_medium_type == BOOT_FROM_SPI ||
+			boot_medium_type == BOOT_FROM_NAND) {
+		printf("%s erase...\n", update_intf_p->name);
+		erase_len = aufl_layout[idx].end - aufl_layout[idx].start + 1;
+		rc = update_intf_p->erase(aufl_layout[idx].start, erase_len);
+		debug_print("erase start:%lx erase end:%lx erase len:%lx\n",
+			aufl_layout[idx].start, aufl_layout[idx].end, erase_len);
+		if (rc) {
+			printf("sector erase failed\n");
+			return 1;
+		}
+	}
+
+write_op:
+	buf = map_physmem((unsigned long)LOAD_ADDR, map_size, MAP_WRBACK);
+	if (!buf) {
+		puts("Failed to map physical memory\n");
+		return 1;
+	}
+
+	/*
+	 * write the whole file to flash;uboot and rootfs image have head
+	 * kernel has head,it's head also be writed to flash
+	 */
+	pbuf = buf;
+
+	/* copy the data from RAM to FLASH */
+	printf("%s write...\n", update_intf_p->name);
+
+	if (strstr(aufile[idx], "yaffs")) {
+		rc = write_yaffs2_fs(idx, sz, pbuf);
+		if (rc) {
+			printf("write yaffs fs failed\n");
+			return rc;
+		}
+	} else if (strstr(aufile[idx], "ext4")) {
+		rc = write_ext4_fs(idx, offset, type, pbuf);
+		if (rc) {
+			printf("write ext4 fs failed\n");
+			return rc;
+		}
+	} else if (strstr(aufile[idx], "ubifs")) {
+		rc = write_ubi_fs(idx, sz, pbuf);
+		if (rc) {
+			printf("write ubi fs failed\n");
+			return rc;
+		}
+	} else {
+		rc = write_other_files(idx, sz, pbuf);
+		if (rc) {
+			printf("write file operation failed\n");
+			return rc;
+		}
+	}
+	unmap_physmem(buf, map_size);
+	return 0;
+}
+#endif
+
+/*
+ * If none of the update file(u-boot, kernel or rootfs) was found
+ * in the medium, return -1;
+ * If u-boot has been updated, return 1;
+ * Others, return 0;
+ */
+#ifndef CONFIG_GK_UPGRADE_BY_SEGMENT
+static int update_to_flash(void)
+{
+	int i;
+	loff_t sz;
+	int res;
+	int cnt;
+	int uboot_updated = 0;
+
+	/* just loop thru all the possible files */
+	for (i = 0; i < AU_MAXFILES && aufile[i] != NULL; i++) {
+		printf("\n");
+
+		if (!fat_exists(aufile[i])) {
+			printf("%s not found!\n", aufile[i]);
+			continue;
+		}
+
+		/* get file's real size */
+		if (!fat_size(aufile[i], &sz)) {
+			aufile_size[i] = ALIGN((unsigned long )sz, CONFIG_SYS_CACHELINE_SIZE);
+		} else {
+			printf("get size of %s failed!\n", aufile[i]);
+			continue;
+		}
+		printf("aligned size=0x%08lx\n", aufile_size[i]);
+
+		memset(LOAD_ADDR, 0xff, aufile_size[i]);
+		sz = file_fat_read(aufile[i], LOAD_ADDR, (unsigned long)sz);
+		debug_print("read %s sz %ld hdr %lu\n",
+			  aufile[i], (unsigned long)sz, (unsigned long)sizeof(image_header_t));
+		if (sz <= 0) {
+			printf("read %s failed!\n", aufile[i]);
+			continue;
+		}
+		/* get file's real size */
+		aufile_size[i] = (unsigned long)sz;
+		printf("size=0x%08lx\n", aufile_size[i]);
+
+		/* If u-boot had been updated, we need to
+		 * save current env to flash */
+		if (strcmp((char *)AU_FIRMWARE, aufile[i]) == 0)
+			uboot_updated = 1;
+
+		/* this is really not a good idea, but it's what the */
+		/* customer wants. */
+		cnt = 0;
+		do {
+			res = au_do_update(i, (unsigned long)sz);
+			/* let the user break out of the loop */
+			if (ctrlc() || had_ctrlc()) {
+				clear_ctrlc();
+
+				break;
+			}
+			cnt++;
+		} while (res < 0);
+	}
+
+	if (uboot_updated == 1)
+		return 1;
+	else
+		return -1;
+}
+#else
+void get_sparse_header(int file_idx, struct seg_update_parm *update_parm)
+{
+#if (defined CONFIG_EMMC) || (defined CONFIG_CMD_UFS)
+	int ret;
+	if (strstr(aufile[file_idx], "ext4") || strstr(aufile[file_idx], "ufs")) {
+		ret = file_fat_read_at(aufile[file_idx],
+			update_parm->pos, LOAD_ADDR, BLOCK_SIZE, &update_parm->actread);
+		if (ret)
+			printf("read %s failed, actread:%lld\n",
+					aufile[file_idx], update_parm->actread);
+		memset(&sparse_header, 0, sizeof(sparse_header_t));
+		get_unspare_header_info(LOAD_ADDR, &sparse_header);
+		layout.offset = sparse_header.file_hdr_sz;
+	}
+#endif
+
+	return ;
+}
+
+void get_section_size(int file_idx, struct seg_update_parm *update_parm)
+{
+#ifdef CONFIG_CMD_NAND
+	if (strstr(aufile[file_idx], "yaffs2")) {
+		if (update_parm->sz > SECTION_SIZE)
+			update_parm->section_size = (SECTION_SIZE / (nand_flash->writesize + 
+				nand_flash->oobsize)) * (nand_flash->writesize + nand_flash->oobsize);
+		else
+			update_parm->section_size = update_parm->sz;
+		debug_print("pagesize:%u, oobsize:%u, section_size:%u\n", nand_flash->writesize,
+				nand_flash->oobsize, update_parm->section_size);
+	} else {
+		update_parm->section_size = SECTION_SIZE;
+	}
+#endif
+
+#ifndef CONFIG_CMD_NAND
+	update_parm->section_size = SECTION_SIZE;
+#endif
+
+	return ;
+}
+
+void loop_au_do_update(int file_idx, unsigned int opsz, int segment)
+{
+	int cnt;
+	int res;
+
+	do {
+		res = au_do_update(file_idx, opsz, segment, perv_layout.offset, perv_layout.type);
+		/* let the user break out of the loop */
+		if (ctrlc() || had_ctrlc()) {
+			clear_ctrlc();
+
+			break;
+		}
+		cnt++;
+	} while (res < 0);
+
+	return ;
+}
+
+void segment_data_save(int file_idx, struct seg_update_parm *update_parm)
+{
+	unsigned int opsz;
+	int ret;
+
+	for (int segment = 0; segment < (update_parm->nsect + update_parm->extra); segment++) {
+		if ((segment == update_parm->nsect) && update_parm->remain)
+			opsz = update_parm->remain;
+		else
+			opsz = update_parm->section_size;
+
+		printf("\nnsect:%d, remain:%u, section_size:%u, pos:%llu, opsz:%u, map_size:%lu\n",
+				update_parm->nsect, update_parm->remain,
+				update_parm->section_size, update_parm->pos, opsz, map_size);
+		memset(LOAD_ADDR, 0xff, map_size);
+		ret = file_fat_read_at(aufile[file_idx], update_parm->pos, LOAD_ADDR, opsz,
+				&update_parm->actread);
+		if (ret)
+			printf("read %s failed,opsz:%d,actread:%lld,pos:%lld\n",
+				aufile[file_idx], opsz, update_parm->actread, update_parm->pos);
+#if (defined CONFIG_EMMC) || (defined CONFIG_CMD_UFS)
+		memset(&perv_layout, 0, sizeof(buff_layout_t));
+		if (strstr(aufile[file_idx], "ext4") || strstr(aufile[file_idx], "ufs")) {
+			perv_layout.offset = layout.offset;
+			perv_layout.type = layout.type;
+			ret = get_buffer_chunk_layout(perv_layout.offset, LOAD_ADDR,
+					aufile_size[file_idx], update_parm->pos);
+			if (ret)
+				printf("Failed to parse the buffer.\n");
+		}
+#endif
+		printf("reading %d part of %s ,size:%u, start:%lld\n", segment,
+				aufile[file_idx], opsz, update_parm->pos);
+		update_parm->updatefile_found = 1;
+
+		/* If u-boot had been updated, we need to
+		 * save current env to flash */
+		if (strcmp((char *)AU_FIRMWARE, aufile[file_idx]) == 0)
+			update_parm->uboot_updated = 1;
+
+		loop_au_do_update(file_idx, opsz, segment);
+#if (defined CONFIG_EMMC) || (defined CONFIG_CMD_UFS)
+		if (strstr(aufile[file_idx], "ext4") || strstr(aufile[file_idx], "ufs")) {
+			update_parm->pos += layout.len;
+			update_parm->remain = aufile_size[file_idx] - update_parm->pos;
+			debug_print("nsect:%d,remain:%u,pos:%lld\n", update_parm->nsect, 
+					update_parm->remain, update_parm->pos);
+		}
+
+		if ((segment == update_parm->nsect) && (update_parm->remain > SECTION_SIZE))
+			update_parm->extra += 1;
+#else
+		update_parm->pos += update_parm->section_size;
+#endif
+	}
+
+	return ;
+}
+
+static int update_to_flash(void)
+{
+	int i;
+	struct seg_update_parm update_parm = {0};
+
+	memset(&layout, 0, sizeof(buff_layout_t));
+	/* just loop thru all the possible files */
+	for (i = 0; i < AU_MAXFILES && aufile[i] != NULL; i++) {
+		printf("\n\n");
+
+		update_parm.pos = 0;
+		update_parm.extra = 0;
+		if (!fat_exists(aufile[i])) {
+			printf("%s not found!\n", aufile[i]);
+			continue;
+		}
+
+		/* get file's real size */
+		if (!fat_size(aufile[i], (loff_t *)&update_parm.sz)) {
+			aufile_size[i] = update_parm.sz;
+		} else {
+			printf("get size of %s failed!\n", aufile[i]);
+			continue;
+		}
+		printf("filesize size= %lu\n", aufile_size[i]);
+
+		map_size = SECTION_SIZE;
+		memset(LOAD_ADDR, 0xff, map_size);
+
+		get_sparse_header(i, &update_parm);
+		get_section_size(i, &update_parm);
+
+		update_parm.nsect = aufile_size[i] / update_parm.section_size;
+		update_parm.remain = aufile_size[i] % update_parm.section_size;
+
+		if (update_parm.remain)
+			update_parm.extra = 1;
+		segment_data_save(i, &update_parm);
+	}
+
+	if (update_parm.uboot_updated == 1)
+		return 1;
+	else if (update_parm.updatefile_found == 1)
+		return 0;
+	else
+		return -1;
+}
+#endif
+
+
+#define ENV_MAX_LEN    (CONFIG_MAX_SIZE / 2)
+
+/*
+ * pick up env form config file and set env
+ * fail:return -1;
+ * ok:  return 0;
+ */
+static int env_pick_up(const char *envname, const char *buffer)
+{
+	char *str, *str_s, *str_e;
+	char env[ENV_MAX_LEN];
+
+	str = strstr(buffer, envname);
+	if (!str)
+		goto env_err;
+
+	str_s = strchr(str, '\'');
+	if (!str_s)
+		goto env_err;
+
+	str_e = strchr(++str_s, '\'');
+	if (!str_e)
+		goto env_err;
+
+	if ((unsigned long)(str_e - str_s) > ENV_MAX_LEN) {
+		printf("ERROR:%s too long!\n", envname);
+		goto err;
+	}
+
+	strncpy(env, str_s, (size_t)(str_e - str_s));
+	env[(size_t)(str_e - str_s)] = '\0';
+	setenv((char *)envname, env);
+
+	return 0;
+
+env_err:
+	printf("ERROR:%s not found!\n", envname);
+err:
+	return -1;
+}
+
+/*
+ * pick up bootargs and bootcmd from config file and save env
+ * fail:return -1;
+ * ok:  return 0;
+ */
+static int get_env_from_config(void)
+{
+	char *aufile = AU_CONFIG;
+	int ret;
+	long sz = file_fat_read(aufile, (void *)LOAD_ADDR, CONFIG_MAX_SIZE);
+	if (sz <= 0) {
+		printf("ERROR:%s not found!\n", aufile);
+		goto err;
+	}
+
+	ret = env_pick_up("bootargs", (char *)LOAD_ADDR);
+	if (ret < 0)
+		goto err;
+
+	ret = env_pick_up("bootcmd", (char *)LOAD_ADDR);
+	if (ret < 0)
+		goto err;
+
+	return 0;
+err:
+	return -1;
+}
+
+struct mtd_part_s {
+	char *str;
+	int unit;
+	struct mtd_part_s *next;
+};
+
+/*
+ * insert node to list
+ */
+struct mtd_part_s *list_insert(struct mtd_part_s *head, struct mtd_part_s *node)
+{
+	struct mtd_part_s *p = head;
+
+	if (!head)
+		head = node;
+
+	while (p) {
+		if (p->next == NULL) {
+			p->next = node;
+			break;
+		}
+		p = p->next;
+	}
+
+	return head;
+}
+
+/*
+ * sort list by str
+ */
+struct mtd_part_s *mtd_list_sort(struct mtd_part_s *head)
+{
+	int flag;
+	struct mtd_part_s *p, *pt1, *pt2;
+
+	if (!head)
+		return NULL;
+
+	if (head->next == NULL)
+		return head;
+
+	do {
+		flag = 0;
+
+		if ((uintptr_t)(head->str) >= (uintptr_t)
+				(head->next->str)) {
+			pt1 = head->next->next;
+			pt2 = head->next;
+			pt2->next = head;
+			head->next = pt1;
+			head = pt2;
+		}
+
+		for (p = head; p->next->next != NULL; p = p->next) {
+			if ((uintptr_t)(p->next->str) >= (uintptr_t)
+					(p->next->next->str)) {
+				pt1 = p->next->next->next;
+				pt2 = p->next->next;
+				pt2->next = p->next;
+				p->next->next = pt1;
+				p->next = pt2;
+				flag = 1;
+			}
+		}
+	} while (flag);
+
+	return head;
+}
+
+/*
+ * get mtd parttion info list from env string
+ */
+struct mtd_part_s *get_mtd_parts(char *env)
+{
+	char *str = NULL;
+	struct mtd_part_s *part_p = NULL;
+	struct mtd_part_s *head = NULL;
+
+	if (env == NULL) {
+		printf("env is null!\n");
+		return NULL;
+	}
+
+	str = env;
+	while ((str = strstr(str, "M("))) {
+		part_p = malloc(sizeof(struct mtd_part_s));
+		if (part_p == NULL)
+			return NULL;
+
+		part_p->str = str;
+		part_p->unit = SIZE_M;
+		part_p->next = NULL;
+		head = list_insert(head, part_p);
+		str++;
+	}
+
+	str = env;
+	while ((str = strstr(str, "K("))) {
+		part_p = malloc(sizeof(struct mtd_part_s));
+		if (part_p == NULL)
+			return NULL;
+
+		part_p->str = str;
+		part_p->unit = SIZE_K;
+		part_p->next = NULL;
+		head = list_insert(head, part_p);
+		str++;
+	}
+
+	head = mtd_list_sort(head);
+	return head;
+}
+
+unsigned long get_mtd_part_size(const char *str_num)
+{
+	unsigned long size = 0;
+	int k;
+	int j = 0;
+	int num;
+
+	while (*str_num >= '0' && *str_num <= '9') {
+		k = j;
+		num = *str_num - '0';
+		while (k) {
+			num *= DECI_VALUE;
+			k--;
+		}
+		size += num;
+		j++;
+		str_num--;
+	}
+
+	return size;
+}
+
+int bootargs_analyze(void)
+{
+	char *str;
+	char *str_0;
+	int i;
+	long start = 0;
+	struct mtd_part_s *part_p = NULL;
+	char env[ENV_MAX_LEN];
+	char *envp = getenv("bootargs");
+	if(envp == NULL){
+		printf("ERROR:bootargs is NULL!\n");
+		return -1;
+	}
+
+	if (strlen(envp) > ENV_MAX_LEN - 1) {
+		printf("ERROR:bootargs is too long!\n");
+		return -1;
+	}
+
+	strcpy(env, envp);
+
+	str = env;
+	str_0 = env;
+	i = 0;
+	part_p = get_mtd_parts(env);
+
+	while (part_p) {
+		if (i >= AU_MAXFILES) {
+			printf("ERROR:Num of partition is more than %0d!\n",
+					AU_MAXFILES);
+			break;
+		}
+		str = part_p->str;
+		ausize[i] = get_mtd_part_size(str - 1) * part_p->unit;
+		aufl_layout[i].start = start;
+		aufl_layout[i].end = start + ausize[i] - 1;
+		start += ausize[i];
+
+		str += STR_STEPS;
+		str_0 = strstr(str, ")");
+		if ((unsigned long)(str_0 - str) > NAME_MAX_LEN) {
+			printf("file name len is too long\n");
+			return -1;
+		}
+		strncpy(aufile_table[i], str, (unsigned long)(str_0 - str));
+		aufile_table[i][str_0 - str] = '\0';
+		aufile[i] = &(aufile_table[i][0]);
+		printf("\n[%0d]=%-16s start=0x%08lx end=0x%08lx size=0x%08lx",
+				i, aufile_table[i],
+			   (unsigned long)(aufl_layout[i].start),
+			   (unsigned long)(aufl_layout[i].end),
+			   (unsigned long)ausize[i]);
+		i++;
+		part_p = part_p->next;
+	}
+
+	if (i == 0) {
+		printf("ERROR:Can't find valid partition info!\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_EMMC
+unsigned int dos_start_lba = 0;
+/* 0:emmc 1:sd */
+int target_dev = 1;
+/* the user's upgrade image stores the partition number in the eMMC medium */
+int target_paratition;
+
+void *get_target_dev_value(void)
+{
+	return &target_dev;
+}
+
+void *get_target_paratition_dev(void)
+{
+	return &target_paratition;
+}
+
+void *get_dos_start_lba_value(void)
+{
+	return &dos_start_lba;
+}
+
+/*
+ * get mtd parttion info list from env string in order
+ */
+struct mtd_part_s *get_mtd_parts_inorder(char *env, int *total_paratition)
+{
+	char *str = env;
+	struct mtd_part_s *part_p;
+	struct mtd_part_s *head = NULL;
+	int num = 0;
+
+	str = env;
+	str = strstr(str, "(");
+	while (str != NULL) {
+		printf("get_mtd_parts_inorder str=%s\n", str);
+		part_p = malloc(sizeof(struct mtd_part_s));
+		if (part_p == NULL)
+			return NULL;
+		if ((*(str - 1) == 'M') || (*(str - 1) == 'm'))
+			part_p->unit = SIZE_M;
+		else if ((*(str - 1) == 'K') || (*(str - 1) == 'k'))
+			part_p->unit = SIZE_K;
+		else
+			part_p->unit = 1;
+
+		part_p->str = str;
+		part_p->next = NULL;
+		head = list_insert(head, part_p);
+
+		str++;
+		str = strstr(str, "(");
+		num++;
+	}
+
+	head = mtd_list_sort(head);
+
+	if (total_paratition != NULL)
+		*total_paratition = num;
+
+	return head;
+}
+
+int bootargs_getend(void)
+{
+	char *str;
+	int i;
+	unsigned long start = 0;
+	char filename[NAME_MAX_LEN] = {0};
+	int cur_target_paratition;
+	struct mtd_part_s *part_p = NULL;
+	char env[ENV_MAX_LEN];
+	char *envp = getenv("bootargs");
+	if(envp == NULL){
+		printf("ERROR:bootargs is NULL!\n");
+		return -1;
+	}
+
+	if (strlen(envp) > ENV_MAX_LEN - 1) {
+		printf("ERROR:bootargs is too long!\n");
+		return -1;
+	}
+
+	strcpy(env, envp);
+
+	str = env;
+	i = 0;
+	part_p = get_mtd_parts_inorder(env, NULL);
+	cur_target_paratition = target_paratition;
+
+	while (part_p) {
+		if (i >= AU_MAXFILES) {
+			printf("ERROR:Num of partition is more than %0d!\n",\
+					AU_MAXFILES);
+			break;
+		}
+		str = part_p->str;
+		start += get_mtd_part_size(str - 1) * part_p->unit;
+		str += 1;
+		if (strstr(str, ")") == NULL || (unsigned long)(strstr(str, ")") - str) >
+				(NAME_MAX_LEN - 1)) {
+			printf("file name is more than NAME_MAX_LEN\n");
+			return -1;
+		}
+		strncpy(filename, str, (unsigned long)(strstr(str, ")") - str));
+		filename[strstr(str, ")") - str] = '\0';
+
+		printf("\n[%0d]=%-16s start=0x%08lx", i, filename, start);
+		i++;
+		part_p = part_p->next;
+		if (i >= cur_target_paratition)
+			break;
+	}
+
+	if (i == 0) {
+		printf("ERROR:Can't find valid partition info!\n");
+		dos_start_lba = 0;
+		return -1;
+	}
+
+	if (target_dev == 0)
+		/* emmc device */
+		dos_start_lba = start >> EMMC_BLOCK_SHIFT;
+	else
+		/* sd device */
+		dos_start_lba = 0;
+
+	printf("\n dos_start_lba = %d\n", dos_start_lba);
+
+	return 0;
+}
+#endif
+
+void get_boot_info(void)
+{
+	unsigned int reg;
+	reg = readl((void *)(SYS_CTRL_REG_BASE + REG_SYSSTAT));
+
+	if (get_sys_boot_mode(reg) == BOOT_FROM_SPI) {
+		/* SFC_DEVICE_MODE:0:SPINOR 1:SPINAND */
+		if (get_spi_device_type(reg)) {
+			boot_medium_type = BOOT_FROM_NAND;
+			update_intf_p = &update_intf[UPDATE_MEDIUM_NAND];
+		} else {
+			boot_medium_type = BOOT_FROM_SPI;
+			update_intf_p = &update_intf[UPDATE_MEDIUM_SPINOR];
+		}
+	} else if (get_sys_boot_mode(reg) == BOOT_FROM_NAND) {
+		boot_medium_type = BOOT_FROM_NAND;
+		update_intf_p = &update_intf[UPDATE_MEDIUM_NAND];
+	} else if (get_sys_boot_mode(reg) == BOOT_FROM_EMMC) {
+		boot_medium_type = BOOT_FROM_EMMC;
+		update_intf_p = &update_intf[UPDATE_MEDIUM_EMMC];
+	}
+}
+
+/*
+ * This is called by board_init() after the hardware has been set up
+ * and is usable.
+ * return -1, otherwise it will return 0;
+ */
+int do_auto_update(void)
+{
+	struct blk_desc *stor_dev;
+	int old_ctrlc;
+	int j;
+	int state = -1;
+	int dev;
+	int updateflg = 0;
+
+	au_stor_curr_dev = -1;
+	for (j = 0; j < MAX_UPDATE_INTF; j++) {
+		if ((unsigned long)s_intf[j].name[0] != 0) {
+			au_stor_curr_dev = s_intf[j].init();
+			if (au_stor_curr_dev == -1) {
+				debug_print("%s storage device not found!\n", s_intf[j].name);
+				continue;
+			}
+
+			dev = 0;
+			if (strncmp("mmc", s_intf[j].name, sizeof("mmc")) == 0) {
+#ifdef CONFIG_EMMC
+				dev = target_dev;
+#else
+				dev = 0;
+#endif
+			}
+			debug_print("device name %s!\n", s_intf[j].name);
+			stor_dev = blk_get_dev(s_intf[j].name, dev);
+			if (stor_dev == NULL) {
+				debug_print("Unknow device type!\n");
+				continue;
+			}
+
+#ifdef CONFIG_EMMC
+			if (target_dev == 0) {
+				/* emmc upgrade */
+				bootargs_getend();
+				/* re-do the entry->test(dev_desc) to set the
+				 * dev_desc->part_type to PART_TYPE_DOS
+				 */
+				part_init(stor_dev);
+			}
+#endif
+
+			if (fat_register_device(stor_dev, 1) != 0) {
+				debug_print("Unable to use %s %d:%d for fatls\n", s_intf[j].name, au_stor_curr_dev, 1);
+				continue;
+			}
+
+			if (file_fat_detectfs() != 0) {
+				debug_print("file_fat_detectfs failed\n");
+				continue;
+			}
+			get_boot_info();
+			update_intf_p->init();
+
+			if (get_env_from_config()) {
+				printf("Warning:no config!\n");
+				printf("Try to use old env!\n");
+			}
+
+			if (bootargs_analyze()) {
+				printf("ERROR:bootargs analyze fail!\n");
+				continue;
+			}
+
+			/*
+			 * make sure that we see CTRL-C
+			 * and save the old state
+			 */
+			old_ctrlc = disable_ctrlc(0);
+
+			state = update_to_flash();
+
+			/* restore the old state */
+			disable_ctrlc(old_ctrlc);
+
+			s_intf[j].exit();
+
+			/*
+			 * no update file found
+			 */
+			if (state == -1)
+				continue;
+			/*
+			 * update files have been found on current medium,
+			 * so just break here
+			 */
+			updateflg = 1;
+			break;
+		}
+	}
+
+	/*
+	 * If u-boot has been updated, it's better to save environment to flash
+	 */
+	if (state == 1)
+		saveenv();
+
+	if (updateflg == 1)
+		return 0;
+	else
+		return -1;
+}
+
+#endif /* CONFIG_AUTO_UPDATE */
diff -uraN u-boot-2016.11/product/update/auto_update.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/update/auto_update.c
--- u-boot-2016.11/product/update/auto_update.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/update/auto_update.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,553 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <common.h>
+#include <environment.h>
+#include <command.h>
+#include <malloc.h>
+#include <image.h>
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <spi_flash.h>
+#include <linux/mtd/mtd.h>
+#include <fat.h>
+
+#if (CONFIG_AUTO_UPDATE == 1)  /* cover the whole file */
+
+#ifdef CONFIG_AUTO_SD_UPDATE
+#ifndef CONFIG_MMC
+#error "should have defined CONFIG_MMC"
+#endif
+#include <mmc.h>
+#include "mmc_init.c"
+#endif
+
+#if defined CONFIG_AUTO_USB_UPDATE
+#if !defined CONFIG_USB_OHCI && !defined CONFIG_USB_XHCI
+#error "should have defined CONFIG_USB_OHCI or CONFIG_USB_XHCI"
+#endif
+#ifndef CONFIG_USB_STORAGE
+#error "should have defined CONFIG_USB_STORAGE"
+#endif
+#include <usb.h>
+#include "usb_init.c"
+#endif
+
+#undef AU_DEBUG
+#undef debug
+#ifdef  AU_DEBUG
+#define debug(fmt, args...) printf(fmt, ##args)
+#else
+#define debug(fmt, args...)
+#endif  /* AU_DEBUG */
+
+/* possible names of files on the medium. */
+#define AU_FIRMWARE "u-boot"
+#define AU_KERNEL   "kernel"
+#define AU_ROOTFS   "rootfs"
+
+#define NAME_LEN	20
+#define ENV_LEN		20
+#define PERCENT		100
+#define HEX		16
+#define COUNT		3
+#define MMC2		2
+#define MAX_HZ		1000000UL
+#define SPI_MODE3	3
+
+struct flash_layout {
+	long start;
+	long end;
+};
+static struct spi_flash *flash;
+
+struct medium_interface {
+	char name[NAME_LEN];
+	int (*init)(void);
+	void (*exit)(void);
+};
+
+#define MAX_UPDATE_INTF 3
+static struct medium_interface s_intf[MAX_UPDATE_INTF] = {
+#ifdef CONFIG_AUTO_SD_UPDATE
+	{.name = "mmc", .init = mmc_stor_init,  .exit = mmc_stor_exit, },
+#endif
+#ifdef CONFIG_AUTO_USB_UPDATE
+	{.name = "usb", .init = usb_stor_init,  .exit = usb_stor_exit, },
+#endif
+};
+
+/* layout of the FLASH. ST = start address, ND = end address. */
+#define AU_FL_FIRMWARE_ST   0x0
+#define AU_FL_FIRMWARE_ND   0x7FFFF
+#define AU_FL_KERNEL_ST     0x100000
+#define AU_FL_KERNEL_ND     0x5FFFFF
+#define AU_FL_ROOTFS_ST     0x600000
+#define AU_FL_ROOTFS_ND     0xbFFFFF
+
+static int au_stor_curr_dev; /* current device */
+
+/* index of each file in the following arrays */
+#define IDX_FIRMWARE    0
+#define IDX_KERNEL  1
+#define IDX_ROOTFS  2
+
+/* max. number of files which could interest us */
+#define AU_MAXFILES 3
+
+/* pointers to file names */
+char *aufile[AU_MAXFILES] = {
+	AU_FIRMWARE,
+	AU_KERNEL,
+	AU_ROOTFS
+};
+
+/* sizes of flash areas for each file */
+long ausize[AU_MAXFILES] = {
+	(AU_FL_FIRMWARE_ND + 1) - AU_FL_FIRMWARE_ST,
+	(AU_FL_KERNEL_ND + 1) - AU_FL_KERNEL_ST,
+	(AU_FL_ROOTFS_ND + 1) - AU_FL_ROOTFS_ST,
+};
+
+/* array of flash areas start and end addresses */
+struct flash_layout aufl_layout[AU_MAXFILES] = {
+	{ AU_FL_FIRMWARE_ST,    AU_FL_FIRMWARE_ND, },
+	{ AU_FL_KERNEL_ST,  AU_FL_KERNEL_ND,   },
+	{ AU_FL_ROOTFS_ST,  AU_FL_ROOTFS_ND,   },
+};
+
+#define LOAD_ADDR ((unsigned char *)0x82000000)
+
+/* the app is the largest image */
+#define MAX_LOADSZ ausize[IDX_ROOTFS]
+
+static int au_check_cksum_valid(int idx, long nbytes)
+{
+	image_header_t *hdr;
+	unsigned long checksum;
+
+	hdr = (image_header_t *)LOAD_ADDR;
+
+	if (nbytes != (sizeof(*hdr) + ntohl(hdr->ih_size))) {
+		printf("Image %s bad total SIZE\n", aufile[idx]);
+		return -1;
+	}
+	/* check the data CRC */
+	checksum = ntohl(hdr->ih_dcrc);
+	if (crc32(0, (unsigned char const *)(LOAD_ADDR + sizeof(*hdr)),
+			  ntohl(hdr->ih_size)) != checksum) {
+		printf("Image %s bad data checksum\n", aufile[idx]);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int au_check_header_valid(int idx, long nbytes)
+{
+	image_header_t *hdr;
+	unsigned long checksum;
+
+	char env[ENV_LEN];
+	char auversion[ENV_LEN];
+
+	hdr = (image_header_t *)LOAD_ADDR;
+	/* check the easy ones first */
+
+#undef CHECK_VALID_DEBUG
+#ifdef CHECK_VALID_DEBUG
+	printf("\nmagic %#x %#x\n", ntohl(hdr->ih_magic), IH_MAGIC);
+	printf("arch %#x %#x\n", hdr->ih_arch, IH_ARCH_ARM);
+	printf("size %#x %#lx\n", ntohl(hdr->ih_size), nbytes);
+	printf("type %#x %#x\n", hdr->ih_type, IH_TYPE_KERNEL);
+#endif
+	if (nbytes < sizeof(*hdr)) {
+		printf("Image %s bad header SIZE\n", aufile[idx]);
+		return -1;
+	}
+	if (ntohl(hdr->ih_magic) != IH_MAGIC || hdr->ih_arch != IH_ARCH_ARM) {
+		printf("Image %s bad MAGIC or ARCH\n", aufile[idx]);
+		return -1;
+	}
+	/* check the hdr CRC */
+	checksum = ntohl(hdr->ih_hcrc);
+	hdr->ih_hcrc = 0;
+
+	if (crc32(0, (unsigned char const *)hdr, sizeof(*hdr)) != checksum) {
+		printf("Image %s bad header checksum\n", aufile[idx]);
+		return -1;
+	}
+	hdr->ih_hcrc = htonl(checksum);
+	/* check the type - could do this all in one gigantic if() */
+	if ((idx == IDX_FIRMWARE) && (hdr->ih_type != IH_TYPE_FIRMWARE)) {
+		printf("Image %s wrong type\n", aufile[idx]);
+		return -1;
+	}
+	if ((idx == IDX_KERNEL) && (hdr->ih_type != IH_TYPE_KERNEL)) {
+		printf("Image %s wrong type\n", aufile[idx]);
+		return -1;
+	}
+	if ((idx == IDX_ROOTFS) &&
+		(hdr->ih_type != IH_TYPE_RAMDISK) &&
+		(hdr->ih_type != IH_TYPE_FILESYSTEM)) {
+		printf("Image %s wrong type\n", aufile[idx]);
+		ausize[idx] = 0;
+		return -1;
+	}
+
+	/* recycle checksum */
+	checksum = ntohl(hdr->ih_size);
+	/* for kernel and app the image header must also fit into flash */
+	if ((idx == IDX_KERNEL) || (hdr->ih_type == IH_TYPE_RAMDISK))
+		checksum += sizeof(*hdr);
+
+	/* check the size does not exceed space in flash. HUSH scripts */
+	/* all have ausize[] set to 0 */
+	if ((ausize[idx] != 0) && (ausize[idx] < checksum)) {
+		printf("Image %s is bigger than FLASH\n", aufile[idx]);
+		return -1;
+	}
+
+	sprintf(env, "%lx", (unsigned long)ntohl(hdr->ih_time));
+	setenv(auversion, env);
+
+	return 0;
+}
+
+static void schedule_notify(unsigned long offset, unsigned long len,
+						unsigned long off_start)
+{
+	int percent_complete = -1;
+
+	do {
+		unsigned long long n =
+				(unsigned long long)(offset - off_start) * PERCENT;
+		int percent;
+
+		do_div(n, len);
+		percent = (int)n;
+
+		/* output progress message only at whole percent
+		 * steps to reduce the number of messages
+		 * printed on (slow) serial consoles
+		 */
+		if (percent != percent_complete) {
+			percent_complete = percent;
+
+			printf("\rOperation at 0x%lx -- %3d%% complete",
+				   offset, percent);
+		}
+	} while (0);
+}
+
+static int spi_flash_erase_op(struct spi_flash *flash, unsigned long offset,
+							  unsigned long len)
+{
+	int ret;
+	struct mtd_info_ex *spiflash_info = get_spiflash_info();
+	unsigned long erase_start, erase_len, erase_step;
+
+	erase_start = offset;
+	erase_len   = len;
+	erase_step  = spiflash_info->erasesize;
+
+	while (len > 0) {
+		if (len < erase_step)
+			erase_step = len;
+
+		ret = flash->erase(flash, (u32)offset, erase_step);
+		if (ret)
+			return 1;
+
+		len -= erase_step;
+		offset += erase_step;
+		/* notify real time schedule */
+		schedule_notify(offset, erase_len, erase_start);
+	}
+	return ret;
+}
+
+static int spi_flash_write_op(struct spi_flash *flash, unsigned long offset,
+						unsigned long len, char *buf)
+{
+	int ret;
+	unsigned long write_start, write_len, write_step;
+	char *pbuf = buf;
+	struct mtd_info_ex *spiflash_info = get_spiflash_info();
+
+	write_start = offset;
+	write_len   = len;
+	write_step  = spiflash_info->erasesize;
+
+	while (len > 0) {
+		if (len < write_step)
+			write_step = len;
+
+		ret = flash->write(flash, offset, write_step, pbuf);
+		if (ret)
+			break;
+
+		offset += write_step;
+		pbuf   += write_step;
+		len    -= write_step;
+		/* notify real time schedule */
+		schedule_notify(offset, write_len, write_start);
+	}
+
+	return ret;
+}
+
+static int au_do_update(int idx, long sz)
+{
+	image_header_t *hdr;
+	unsigned long start, len;
+	unsigned long write_len;
+	int rc;
+	void *buf;
+	char *pbuf;
+
+	hdr = (image_header_t *)LOAD_ADDR;
+
+	start = aufl_layout[idx].start;
+	len = aufl_layout[idx].end - aufl_layout[idx].start + 1;
+
+	/*
+	 * erase the address range.
+	 */
+	printf("flash erase...\n");
+	rc = spi_flash_erase_op(flash, start, len);
+	if (rc) {
+		printf("SPI flash sector erase failed\n");
+		return 1;
+	}
+
+	buf = map_physmem((unsigned long)LOAD_ADDR, len, MAP_WRBACK);
+	if (!buf) {
+		puts("Failed to map physical memory\n");
+		return 1;
+	}
+
+	/* strip the header - except for the kernel and ramdisk */
+	if (hdr->ih_type == IH_TYPE_KERNEL || hdr->ih_type == IH_TYPE_RAMDISK) {
+		pbuf = buf;
+		write_len = sizeof(*hdr) + ntohl(hdr->ih_size);
+	} else {
+		pbuf = (buf + sizeof(*hdr));
+		write_len = ntohl(hdr->ih_size);
+	}
+
+	/* copy the data from RAM to FLASH */
+	printf("\nflash write...\n");
+	rc = spi_flash_write_op(flash, start, write_len, pbuf);
+	if (rc) {
+		printf("SPI flash write failed, return %d\n", rc);
+		return 1;
+	}
+
+	/* check the dcrc of the copy */
+	if (crc32(0, (unsigned char const *)(buf + sizeof(*hdr)),
+			  ntohl(hdr->ih_size)) != ntohl(hdr->ih_dcrc)) {
+		printf("Image %s Bad Data Checksum After COPY\n", aufile[idx]);
+		return -1;
+	}
+
+	unmap_physmem(buf, len);
+
+	return 0;
+}
+
+static void get_update_env(char *img_start, char *img_end)
+{
+	long start = -1;
+	long end = 0;
+	char *env;
+
+	/*
+	 * check whether start and end are defined in environment
+	 * variables.
+	 */
+	env = getenv(img_start);
+	if (env != NULL)
+		start = simple_strtoul(env, NULL, HEX);
+
+	env = getenv(img_end);
+	if (env != NULL)
+		end = simple_strtoul(env, NULL, HEX);
+
+	if (start >= 0 && end && end > start) {
+		ausize[IDX_FIRMWARE] = (end + 1) - start;
+		aufl_layout[0].start = start;
+		aufl_layout[0].end = end;
+	}
+}
+
+/*
+ * If none of the update file(u-boot, kernel or rootfs) was found
+ * in the medium, return -1;
+ * If u-boot has been updated, return 1;
+ * Others, return 0;
+ */
+static int update_to_flash(void)
+{
+	int i;
+	long sz;
+	int res, cnt;
+	int uboot_updated;
+	int image_found;
+
+	/* just loop thru all the possible files */
+	for (i = 0; i < AU_MAXFILES; i++) {
+		/* just read the header */
+		sz = file_fat_read(aufile[i], LOAD_ADDR, sizeof(image_header_t));
+		debug("read %s sz %ld hdr %d\n", aufile[i], sz, sizeof(image_header_t));
+		if (sz <= 0 || sz < sizeof(image_header_t)) {
+			debug("%s not found\n", aufile[i]);
+			continue;
+		}
+
+		image_found = 1;
+
+		if (au_check_header_valid(i, sz) < 0) {
+			debug("%s header not valid\n", aufile[i]);
+			continue;
+		}
+
+		sz = file_fat_read(aufile[i], LOAD_ADDR, MAX_LOADSZ);
+		debug("read %s sz %ld hdr %d\n", aufile[i], sz, sizeof(image_header_t));
+		if (sz <= 0 || sz <= sizeof(image_header_t)) {
+			debug("%s not found\n", aufile[i]);
+			continue;
+		}
+
+		if (au_check_cksum_valid(i, sz) < 0) {
+			debug("%s checksum not valid\n", aufile[i]);
+			continue;
+		}
+
+		/* If u-boot had been updated, we need to
+		 * save current env to flash
+		 */
+		if (strcmp((char *)AU_FIRMWARE, aufile[i]) == 0)
+			uboot_updated = 1;
+
+		/* this is really not a good idea, but it's what the customer wants. */
+		cnt = 0;
+		do {
+			res = au_do_update(i, sz);
+			/* let the user break out of the loop */
+			if (ctrlc() || had_ctrlc()) {
+				clear_ctrlc();
+
+				break;
+			}
+			cnt++;
+		} while (res < 0);
+	}
+
+	if (uboot_updated == 1)
+		return 1;
+
+	if (image_found == 1)
+		return 0;
+
+	return -1;
+}
+
+/*
+ * This is called by board_init() after the hardware has been set up
+ * and is usable. Only if SPI flash initialization failed will this function
+ * return -1, otherwise it will return 0;
+ */
+int do_auto_update(void)
+{
+	struct blk_desc *stor_dev;
+	int old_ctrlc;
+	int j;
+	int state = -1;
+	int dev;
+
+	au_stor_curr_dev = -1;
+	for (j = 0; j < MAX_UPDATE_INTF; j++) {
+		if ((unsigned long)s_intf[j].name[0] != 0) {
+			au_stor_curr_dev = s_intf[j].init();
+			if (au_stor_curr_dev == -1) {
+				debug("No %s storage device found!\n",
+					  s_intf[j].name);
+				continue;
+			}
+
+			dev = 0;
+
+			debug("device name %s!\n", s_intf[j].name);
+			stor_dev = blk_get_dev(s_intf[j].name, dev);
+			if (stor_dev == NULL) {
+				debug("Unknow device type!\n");
+				continue;
+			}
+
+			if (fat_register_device(stor_dev, 1) != 0) {
+				debug("Unable to use %s %d:%d for fatls\n",
+						s_intf[j].name, au_stor_curr_dev, 1);
+				continue;
+			}
+
+			if (file_fat_detectfs() != 0) {
+				debug("file_fat_detectfs failed\n");
+				continue;
+			}
+
+			/*
+			 * Get image layout from environment.
+			 * If the start address and the end address
+			 * were not definedin environment virables,
+			 * use the default value
+			 */
+			get_update_env("firmware_st", "firmware_nd");
+			get_update_env("kernel_st", "kernel_nd");
+			get_update_env("rootfs_st", "rootfs_nd");
+
+			/*
+			 * make sure that we see CTRL-C
+			 * and save the old state
+			 */
+			old_ctrlc = disable_ctrlc(0);
+
+			/*
+			 * CONFIG_SF_DEFAULT_SPEED equals 1000000,
+			 * CONFIG_SF_DEFAULT_MODE equals 0x3
+			 */
+			flash = spi_flash_probe(0, 0, MAX_HZ, SPI_MODE3);
+			if (!flash) {
+				printf("Failed to initialize SPI flash\n");
+				return -1;
+			}
+
+			state = update_to_flash();
+
+			/* restore the old state */
+			disable_ctrlc(old_ctrlc);
+
+			s_intf[j].exit();
+
+			/*
+			 * no update file found
+			 */
+			if (state == -1)
+				continue;
+			/*
+			 * update files have been found on current medium,
+			 * so just break here
+			 */
+			break;
+		}
+	}
+
+	/*
+	 * If u-boot has been updated, it's better to save environment to flash
+	 */
+	if (state == 1)
+		saveenv();
+	return 0;
+}
+#endif /* CONFIG_AUTO_UPDATE */
diff -uraN u-boot-2016.11/product/update/auto_update.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/update/auto_update.h
--- u-boot-2016.11/product/update/auto_update.h	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/update/auto_update.h	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,11 @@
+#ifndef __AUTO_UPDATE__H
+#define __AUTO_UPDATE__H
+
+int do_auto_update(void);
+void *get_target_dev_value(void);
+void *get_target_paratition_value(void);
+void select_upgrade_media(void);
+void *get_dos_start_lba_value(void);
+#endif
+
+
diff -uraN u-boot-2016.11/product/update/Makefile gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/update/Makefile
--- u-boot-2016.11/product/update/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/update/Makefile	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,8 @@
+sinclude $(TOPDIR)/config.mk
+
+ifdef CONFIG_AUTO_UPDATE_ADAPTATION
+obj-y += auto_update_adaptation.o
+else
+obj-y += auto_update.o
+endif
+
diff -uraN u-boot-2016.11/product/update/mmc_init.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/update/mmc_init.c
--- u-boot-2016.11/product/update/mmc_init.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/update/mmc_init.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+
+#include <mmc.h>
+#include <common.h>
+#include "auto_update.h"
+static int mmc_stor_init(void)
+{
+	struct mmc *mmc;
+	int dev_num;
+#ifdef CONFIG_EMMC
+	int *target_dev = get_target_dev_value();
+	dev_num = *target_dev;
+#else
+	dev_num = 0;
+#endif
+	mmc = find_mmc_device(dev_num);
+	if (mmc == NULL) {
+		printf("No mmc driver found!\n");
+		return -1;
+	}
+
+	if (((unsigned long)mmc->block_dev.vendor[0] == 0) ||
+			((unsigned long)mmc->block_dev.product[0] == 0)) {
+		printf("*No SD card found!\n");
+		return -1;
+	}
+	return 0;
+}
+
+static void mmc_stor_exit(void)
+{
+}
diff -uraN u-boot-2016.11/product/update/usb_init.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/update/usb_init.c
--- u-boot-2016.11/product/update/usb_init.c	1970-01-01 03:00:00.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/product/update/usb_init.c	2021-06-07 13:01:32.000000000 +0300
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) Hunan Goke,Chengdu Goke,Shandong Goke. 2021. All rights reserved.
+ */
+#include <common.h>
+#include <usb.h>
+#include <linux/errno.h>
+
+static int usb_stor_init(void)
+{
+	int ret = -1;
+#ifndef CONFIG_GK_MC
+try_again:
+	if (usb_stop() < 0) {
+		debug("usb_stop failed\n");
+		return ret;
+	}
+	/* delay for 1000 ms */
+	mdelay(1000);
+	ret = usb_init();
+	if (ret == -ESRCH)
+		goto try_again;
+
+	if (ret < 0) {
+		debug("usb_init failed!\n");
+		return ret;
+	}
+
+	/*
+	 * check whether a storage device is attached (assume that it's
+	 * a USB memory stick, since nothing else should be attached).
+	 */
+	ret = usb_stor_scan(0);
+	if (ret == -1)
+		debug("No USB device found. Not initialized!\n");
+#endif
+	return ret;
+}
+
+static void usb_stor_exit(void)
+{
+#ifndef CONFIG_GK_MC
+	usb_stop();
+#endif
+}
+
diff -uraN u-boot-2016.11/scripts/basic/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/scripts/basic/.gitignore
--- u-boot-2016.11/scripts/basic/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/scripts/basic/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1 +0,0 @@
-fixdep
diff -uraN u-boot-2016.11/scripts/check-config.sh gk7205v100_u-boot-2016.11_sdk-C00SPC020/scripts/check-config.sh
--- u-boot-2016.11/scripts/check-config.sh	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/scripts/check-config.sh	2021-06-07 13:01:32.000000000 +0300
@@ -23,6 +23,7 @@
 suspects="${path}.suspects"
 ok="${path}.ok"
 new_adhoc="${path}.adhoc"
+sorted_white_list="sorted_white_list.txt"
 
 export LC_ALL=C
 export LC_COLLATE=C
@@ -30,7 +31,8 @@
 cat ${path} |sed -n 's/^#define \(CONFIG_[A-Za-z0-9_]*\).*/\1/p' |sort |uniq \
 	>${configs}
 
-comm -23 ${configs} ${whitelist} > ${suspects}
+sort ${whitelist} -o ${sorted_white_list}
+comm -23 ${configs} ${sorted_white_list} > ${suspects}
 
 cat `find ${srctree} -name "Kconfig*"` |sed -n \
 	-e 's/^config *\([A-Za-z0-9_]*\).*$/CONFIG_\1/p' \
@@ -46,5 +48,5 @@
 	# Don't delete the temporary files in case they are useful
 	exit 1
 else
-	rm ${suspects} ${ok} ${new_adhoc}
+	rm ${suspects} ${ok} ${new_adhoc} ${sorted_white_list}
 fi
diff -uraN u-boot-2016.11/scripts/config_whitelist.txt gk7205v100_u-boot-2016.11_sdk-C00SPC020/scripts/config_whitelist.txt
--- u-boot-2016.11/scripts/config_whitelist.txt	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/scripts/config_whitelist.txt	2021-06-07 13:01:32.000000000 +0300
@@ -287,9 +287,14 @@
 CONFIG_ATSTK1000_16MB_SDRAM
 CONFIG_ATSTK1002
 CONFIG_AT_TRANS
+CONFIG_AUDIO_ENABLE
 CONFIG_AUTOCALIB
 CONFIG_AUTONEG_TIMEOUT
 CONFIG_AUTO_COMPLETE
+CONFIG_AUTO_SD_UPDATE
+CONFIG_AUTO_UPDATE
+CONFIG_AUTO_UPDATE_ADAPTATION
+CONFIG_AUTO_USB_UPDATE
 CONFIG_AUTO_ZRELADDR
 CONFIG_B4860QDS
 CONFIG_BACKSIDE_L2_CACHE
@@ -514,6 +519,7 @@
 CONFIG_CHIP_SELECTS_PER_CTRL
 CONFIG_CHIP_SELECT_QUAD_CAPABLE
 CONFIG_CHROMEOS_EXTRA_ENV_SETTINGS
+CONFIG_CIPHER_ENABLE
 CONFIG_CIS8201_PHY
 CONFIG_CI_UDC_HAS_HOSTPC
 CONFIG_CLK0_DIV
@@ -645,6 +651,8 @@
 CONFIG_CMD_TRACE
 CONFIG_CMD_TSI148
 CONFIG_CMD_UBIFS
+CONFIG_CMD_UFS
+CONFIG_CMD_UGZIP
 CONFIG_CMD_UNIVERSE
 CONFIG_CMD_UNZIP
 CONFIG_CMD_USB_STORAGE
@@ -661,6 +669,7 @@
 CONFIG_CM_T43
 CONFIG_CM_T54
 CONFIG_CM_TCRAM
+CONFIG_CMD_CREAD
 CONFIG_CNTL
 CONFIG_COLDFIRE
 CONFIG_COMMANDS
@@ -751,6 +760,7 @@
 CONFIG_CTL_TBE
 CONFIG_CTRD1_PROBE_T1
 CONFIG_CTRD1_PROBE_T2
+CONFIG_CUR_UART_BASE
 CONFIG_CUSTOMER_BOARD_SUPPORT
 CONFIG_CYRUS
 CONFIG_D2NET_V2
@@ -802,6 +812,7 @@
 CONFIG_DDR_RFDC_FIXED
 CONFIG_DDR_RQDC_FIXED
 CONFIG_DDR_SPD
+CONFIG_DDR_TRAINING_V2
 CONFIG_DEBUG
 CONFIG_DEBUG_DUMP
 CONFIG_DEBUG_DUMP_SYMS
@@ -1029,6 +1040,7 @@
 CONFIG_EMAC_NR_START
 CONFIG_EMAC_PHY_MODE
 CONFIG_EMIF4
+CONFIG_EMMC
 CONFIG_EMMC_BOOT
 CONFIG_EMU
 CONFIG_ENABLE_36BIT_PHYS
@@ -1041,7 +1053,6 @@
 CONFIG_ENV_ADDR
 CONFIG_ENV_ADDR_FLEX
 CONFIG_ENV_ADDR_REDUND
-CONFIG_ENV_AES
 CONFIG_ENV_BASE
 CONFIG_ENV_CALLBACK_LIST_DEFAULT
 CONFIG_ENV_CALLBACK_LIST_STATIC
@@ -1139,6 +1150,7 @@
 CONFIG_ETH_BUFSIZE
 CONFIG_ETH_RXSIZE
 CONFIG_EXCEPTION_DEFER
+CONFIG_EXT4_SPARSE
 CONFIG_EXT4_WRITE
 CONFIG_EXTRA_BOOTARGS
 CONFIG_EXTRA_CLOCK
@@ -1241,6 +1253,9 @@
 CONFIG_FLASH_VERIFY
 CONFIG_FMAN_ENET
 CONFIG_FM_PLAT_CLK_DIV
+CONFIG_FMC_BUFFER_BASE
+CONFIG_FMC_MAX_CS_NUM
+CONFIG_FMC_REG_BASE
 CONFIG_FO300
 CONFIG_FORCE_DDR_DATA_BUS_WIDTH_32
 CONFIG_FORMIKE
@@ -1635,6 +1650,7 @@
 CONFIG_I2C_REPEATED_START
 CONFIG_I2C_RTC_ADDR
 CONFIG_I2C_TIMEOUT
+CONFIG_GK_I2C
 CONFIG_IBM_EMAC4_V4
 CONFIG_ICACHE
 CONFIG_ICACHE_OFF
@@ -3081,6 +3097,11 @@
 CONFIG_MMCBOOTCOMMAND
 CONFIG_MMCROOT
 CONFIG_MMC_DEFAULT_DEV
+CONFIG_MMC_PHY
+CONFIG_MMC_POWER_OFF_TIMEOUT
+CONFIG_MMC_POWER_ON_TIMEROUT
+CONFIG_MMC_RESET_HIGH_TIMEROUT
+CONFIG_MMC_RESET_LOW_TIMEOUT
 CONFIG_MMC_RPMB_TRACE
 CONFIG_MMC_SDHCI_IO_ACCESSORS
 CONFIG_MMC_SDMA
@@ -3405,6 +3426,8 @@
 CONFIG_ORIGEN
 CONFIG_OS1_ENV_ADDR
 CONFIG_OS2_ENV_ADDR
+CONFIG_OSD_ENABLE
+CONFIG_OSD_HDMI_DISABLE
 CONFIG_OS_ENV_ADDR
 CONFIG_OTHBOOTARGS
 CONFIG_OVERWRITE_ETHADDR_ONCE
@@ -3713,6 +3736,7 @@
 CONFIG_PRIMEVIEW_V16C6448AC
 CONFIG_PRINTK
 CONFIG_PROC_FS
+CONFIG_PRODUCTNAME
 CONFIG_PROFILE_ALL_BRANCHES
 CONFIG_PROFILING
 CONFIG_PROG_FDT
@@ -3964,6 +3988,8 @@
 CONFIG_SC_TIMER_CLK
 CONFIG_SDCARD
 CONFIG_SDHCI
+CONFIG_SDHCI_ADMA
+CONFIG_SDIO0_FREQ
 CONFIG_SDRAM_BANK0
 CONFIG_SDRAM_BANK1
 CONFIG_SDRAM_ECC
@@ -4203,6 +4229,8 @@
 CONFIG_SPI_HALF_DUPLEX
 CONFIG_SPI_IDLE_VAL
 CONFIG_SPI_LENGTH
+CONFIG_SPI_NOR_MAX_CHIP_NUM
+CONFIG_SPI_NOR_QUIET_TEST
 CONFIG_SPI_N25Q256A_RESET
 CONFIG_SPLASHIMAGE_GUARD
 CONFIG_SPLASH_SCREEN
@@ -6292,6 +6320,7 @@
 CONFIG_SYS_LED_ADDR
 CONFIG_SYS_LED_BASE
 CONFIG_SYS_LED_DISP_BASE
+CONFIG_SYS_LEVEL2_CACHE_SHARE
 CONFIG_SYS_LIME_BASE
 CONFIG_SYS_LIME_BASE_0
 CONFIG_SYS_LIME_BASE_1
@@ -7692,6 +7721,7 @@
 CONFIG_SYS_TEMP_STACK_OCM
 CONFIG_SYS_TEXT_ADDR
 CONFIG_SYS_TEXT_BASE_NOR
+CONFIG_SYS_TEXT_BASE_ORI
 CONFIG_SYS_TEXT_BASE_SPL
 CONFIG_SYS_TFP410_ADDR
 CONFIG_SYS_TFP410_BUS
@@ -8239,6 +8269,8 @@
 CONFIG_VCO_MULT
 CONFIG_VCT_NOR
 CONFIG_VE8313
+CONFIG_GK_SDHCI
+CONFIG_GK_SDHCI_MAX_FREQ
 CONFIG_VERY_BIG_RAM
 CONFIG_VEXPRESS_EXTENDED_MEMORY_MAP
 CONFIG_VEXPRESS_ORIGINAL_MEMORY_MAP
@@ -8362,3 +8394,5 @@
 CONFIG_ZYNQ_SDHCI_MIN_FREQ
 CONFIG_ZYNQ_SERIAL
 CONFIG_eTSEC_MDIO_BUS
+DDR_SCRAMB_ENABLE
+SVB_ENABLE
diff -uraN u-boot-2016.11/scripts/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/scripts/.gitignore
--- u-boot-2016.11/scripts/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/scripts/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1,4 +0,0 @@
-#
-# Generated files
-#
-docproc
diff -uraN u-boot-2016.11/scripts/kconfig/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/scripts/kconfig/.gitignore
--- u-boot-2016.11/scripts/kconfig/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/scripts/kconfig/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1,22 +0,0 @@
-#
-# Generated files
-#
-config*
-*.lex.c
-*.tab.c
-*.tab.h
-zconf.hash.c
-*.moc
-gconf.glade.h
-*.pot
-*.mo
-
-#
-# configuration programs
-#
-conf
-mconf
-nconf
-qconf
-gconf
-kxgettext
diff -uraN u-boot-2016.11/scripts/kconfig/lxdialog/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/scripts/kconfig/lxdialog/.gitignore
--- u-boot-2016.11/scripts/kconfig/lxdialog/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/scripts/kconfig/lxdialog/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1,4 +0,0 @@
-#
-# Generated files
-#
-lxdialog
diff -uraN u-boot-2016.11/test/py/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/test/py/.gitignore
--- u-boot-2016.11/test/py/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/test/py/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1 +0,0 @@
-*.pyc
diff -uraN u-boot-2016.11/test/py/tests/test_vboot.py gk7205v100_u-boot-2016.11_sdk-C00SPC020/test/py/tests/test_vboot.py
--- u-boot-2016.11/test/py/tests/test_vboot.py	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/test/py/tests/test_vboot.py	2021-06-07 13:01:32.000000000 +0300
@@ -140,8 +140,7 @@
 
         cons.log.action('%s: Check signed config on the host' % sha_algo)
 
-        util.run_and_log(cons, [fit_check_sign, '-f', fit, '-k', tmpdir,
-                                '-k', dtb])
+        util.run_and_log(cons, [fit_check_sign, '-f', fit, '-k', dtb])
 
         # Increment the first byte of the signature, which should cause failure
         sig = util.run_and_log(cons, 'fdtget -t bx %s %s value' %
@@ -153,7 +152,8 @@
         util.run_and_log(cons, 'fdtput -t bx %s %s value %s' %
                          (fit, sig_node, sig))
 
-        run_bootm(sha_algo, 'Signed config with bad hash', 'Bad Data Hash', False)
+        run_bootm(sha_algo, 'Signed config with bad hash', 'Bad Data Hash',
+                  False)
 
         cons.log.action('%s: Check bad config on the host' % sha_algo)
         util.run_and_log_expect_exception(cons, [fit_check_sign, '-f', fit,
diff -uraN u-boot-2016.11/tools/buildman/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/tools/buildman/.gitignore
--- u-boot-2016.11/tools/buildman/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/tools/buildman/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1 +0,0 @@
-*.pyc
diff -uraN u-boot-2016.11/tools/dtoc/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/tools/dtoc/.gitignore
--- u-boot-2016.11/tools/dtoc/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/tools/dtoc/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1 +0,0 @@
-*.pyc
diff -uraN u-boot-2016.11/tools/env/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/tools/env/.gitignore
--- u-boot-2016.11/tools/env/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/tools/env/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1,2 +0,0 @@
-fw_printenv
-fw_printenv_unstripped
diff -uraN u-boot-2016.11/tools/fdt_host.h gk7205v100_u-boot-2016.11_sdk-C00SPC020/tools/fdt_host.h
--- u-boot-2016.11/tools/fdt_host.h	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/tools/fdt_host.h	2021-06-07 13:01:32.000000000 +0300
@@ -11,6 +11,7 @@
 #include "../include/libfdt.h"
 #include "../include/fdt_support.h"
 
-int fit_check_sign(const void *working_fdt, const void *key);
+int fit_check_sign(const void *fit, const void *key,
+		   const char *fit_uname_config);
 
 #endif /* __FDT_HOST_H__ */
diff -uraN u-boot-2016.11/tools/fit_check_sign.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/tools/fit_check_sign.c
--- u-boot-2016.11/tools/fit_check_sign.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/tools/fit_check_sign.c	2021-06-07 13:01:32.000000000 +0300
@@ -42,6 +42,7 @@
 	void *fit_blob;
 	char *fdtfile = NULL;
 	char *keyfile = NULL;
+	char *config_name = NULL;
 	char cmdname[256];
 	int ret;
 	void *key_blob;
@@ -49,7 +50,7 @@
 
 	strncpy(cmdname, *argv, sizeof(cmdname) - 1);
 	cmdname[sizeof(cmdname) - 1] = '\0';
-	while ((c = getopt(argc, argv, "f:k:")) != -1)
+	while ((c = getopt(argc, argv, "f:k:c:")) != -1)
 		switch (c) {
 		case 'f':
 			fdtfile = optarg;
@@ -57,6 +58,9 @@
 		case 'k':
 			keyfile = optarg;
 			break;
+		case 'c':
+			config_name = optarg;
+			break;
 		default:
 			usage(cmdname);
 			break;
@@ -79,7 +83,7 @@
 		return EXIT_FAILURE;
 
 	image_set_host_blob(key_blob);
-	ret = fit_check_sign(fit_blob, key_blob);
+	ret = fit_check_sign(fit_blob, key_blob, config_name);
 	if (!ret) {
 		ret = EXIT_SUCCESS;
 		fprintf(stderr, "Signature check OK\n");
diff -uraN u-boot-2016.11/tools/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/tools/.gitignore
--- u-boot-2016.11/tools/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/tools/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1,28 +0,0 @@
-/atmel_pmecc_params
-/bin2header
-/bmp_logo
-/envcrc
-/fdtgrep
-/fit_check_sign
-/fit_info
-/gen_eth_addr
-/ifdtool
-/img2srec
-/kwboot
-/dumpimage
-/mkenvimage
-/mkimage
-/mkexynosspl
-/mxsboot
-/mksunxiboot
-/ncb
-/proftool
-/relocate-rela
-/ubsha1
-/xway-swap-bytes
-/easylogo/easylogo
-/gdb/gdbcont
-/gdb/gdbsend
-
-/lib/
-/common/
diff -uraN u-boot-2016.11/tools/image-host.c gk7205v100_u-boot-2016.11_sdk-C00SPC020/tools/image-host.c
--- u-boot-2016.11/tools/image-host.c	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/tools/image-host.c	2021-06-07 13:01:32.000000000 +0300
@@ -163,7 +163,7 @@
 
 	memset(info, '\0', sizeof(*info));
 	info->keydir = keydir;
-	info->keyname = fdt_getprop(fit, noffset, "key-name-hint", NULL);
+	info->keyname = fdt_getprop(fit, noffset, FIT_KEY_HINT, NULL);
 	info->fit = fit;
 	info->node_offset = noffset;
 	info->algo = image_get_sig_algo(algo_name);
@@ -236,7 +236,7 @@
 	free(value);
 
 	/* Get keyname again, as FDT has changed and invalidated our pointer */
-	info.keyname = fdt_getprop(fit, noffset, "key-name-hint", NULL);
+	info.keyname = fdt_getprop(fit, noffset, FIT_KEY_HINT, NULL);
 
 	if (keydest)
 		ret = info.algo->add_verify_data(&info, keydest);
@@ -613,7 +613,7 @@
 	free(region_prop);
 
 	/* Get keyname again, as FDT has changed and invalidated our pointer */
-	info.keyname = fdt_getprop(fit, noffset, "key-name-hint", NULL);
+	info.keyname = fdt_getprop(fit, noffset, FIT_KEY_HINT, NULL);
 
 	/* Write the public key into the supplied FDT file */
 	if (keydest) {
@@ -716,19 +716,22 @@
 }
 
 #ifdef CONFIG_FIT_SIGNATURE
-int fit_check_sign(const void *fit, const void *key)
+int fit_check_sign(const void *fit, const void *key,
+		   const char *fit_uname_config)
 {
 	int cfg_noffset;
 	int ret;
 
-	cfg_noffset = fit_conf_get_node(fit, NULL);
+	cfg_noffset = fit_conf_get_node(fit, fit_uname_config);
 	if (!cfg_noffset)
 		return -1;
 
-	printf("Verifying Hash Integrity ... ");
+	printf("Verifying Hash Integrity for node '%s'... ",
+	       fdt_get_name(fit, cfg_noffset, NULL));
 	ret = fit_config_verify(fit, cfg_noffset);
 	if (ret)
 		return ret;
+	printf("Verified OK, loading images\n");
 	ret = bootm_host_load_images(fit, cfg_noffset);
 
 	return ret;
diff -uraN u-boot-2016.11/tools/patman/.gitignore gk7205v100_u-boot-2016.11_sdk-C00SPC020/tools/patman/.gitignore
--- u-boot-2016.11/tools/patman/.gitignore	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/tools/patman/.gitignore	1970-01-01 03:00:00.000000000 +0300
@@ -1 +0,0 @@
-*.pyc
diff -uraN u-boot-2016.11/.travis.yml gk7205v100_u-boot-2016.11_sdk-C00SPC020/.travis.yml
--- u-boot-2016.11/.travis.yml	2016-11-14 19:27:11.000000000 +0300
+++ gk7205v100_u-boot-2016.11_sdk-C00SPC020/.travis.yml	1970-01-01 03:00:00.000000000 +0300
@@ -1,278 +0,0 @@
-# Copyright Roger Meier <r.meier@siemens.com>
-# SPDX-License-Identifier:	GPL-2.0+
-
-# build U-Boot on Travis CI - https://travis-ci.org/
-
-sudo: required
-dist: trusty
-
-language: c
-
-addons:
-  apt:
-    sources:
-    - sourceline: 'ppa:gns3/qemu'
-    packages:
-    - cppcheck
-    - sloccount
-    - sparse
-    - bc
-    - build-essential
-    - libsdl1.2-dev
-    - python
-    - python-virtualenv
-    - qemu-system-arm
-    - qemu-system-mips
-    - qemu-system-ppc
-    - qemu-system-x86
-    - gcc-powerpc-linux-gnu
-    - gcc-arm-linux-gnueabihf
-    - gcc-aarch64-linux-gnu
-    - iasl
-
-install:
- # install latest device tree compiler
- - git clone --depth=1 git://git.kernel.org/pub/scm/utils/dtc/dtc.git /tmp/dtc
- - make -j4 -C /tmp/dtc
- # Clone uboot-test-hooks
- - git clone --depth=1 git://github.com/swarren/uboot-test-hooks.git /tmp/uboot-test-hooks
- - ln -s travis-ci /tmp/uboot-test-hooks/bin/`hostname`
- - ln -s travis-ci /tmp/uboot-test-hooks/py/`hostname`
- # prepare buildman environment
- - echo -e "[toolchain]\nroot = /usr" > ~/.buildman
- - echo -e "\n[toolchain-alias]\nblackfin = bfin\nsh = sh4\nopenrisc = or32" >> ~/.buildman
- - cat ~/.buildman
- - virtualenv /tmp/venv
- - . /tmp/venv/bin/activate
- - pip install pytest
-
-env:
-  global:
-    - PATH=/tmp/dtc:/tmp/uboot-test-hooks/bin:$PATH
-    - BUILD_DIR=build
-    - HOSTCC="cc"
-    - HOSTCXX="c++"
-
-before_script:
-  # install toolchains based on TOOLCHAIN} variable
-  - if [[ "${TOOLCHAIN}" == *avr32* ]]; then ./tools/buildman/buildman --fetch-arch avr32 ; fi
-  - if [[ "${TOOLCHAIN}" == *bfin* ]]; then ./tools/buildman/buildman --fetch-arch bfin ; fi
-  - if [[ "${TOOLCHAIN}" == *m68k* ]]; then ./tools/buildman/buildman --fetch-arch m68k ; fi
-  - if [[ "${TOOLCHAIN}" == *microblaze* ]]; then ./tools/buildman/buildman --fetch-arch microblaze ; fi
-  - if [[ "${TOOLCHAIN}" == *mips* ]]; then ./tools/buildman/buildman --fetch-arch mips ; fi
-  - if [[ "${TOOLCHAIN}" == *or32* ]]; then ./tools/buildman/buildman --fetch-arch or32 ; fi
-  - if [[ "${TOOLCHAIN}" == *sh4* ]]; then ./tools/buildman/buildman --fetch-arch sh4 ; fi
-  - if [[ "${TOOLCHAIN}" == *x86_64* ]]; then
-      ./tools/buildman/buildman --fetch-arch x86_64;
-      echo -e "\n[toolchain-prefix]\nx86 = ${HOME}/.buildman-toolchains/gcc-4.9.0-nolibc/x86_64-linux/bin/x86_64-linux-" >> ~/.buildman;
-    fi
-  - if [[ "${TOOLCHAIN}" == *xtensa* ]]; then ./tools/buildman/buildman --fetch-arch xtensa ; fi
-
-script:
- # Comments must be outside the command strings below, or the Travis parser
- # will get confused.
- #
- # Exit code 129 means warnings only.
- - if [[ "${BUILDMAN}" != "" ]]; then
-     set +e;
-     tools/buildman/buildman -P ${BUILDMAN};
-     ret=$?;
-     if [[ $ret -ne 0 && $ret -ne 129 ]]; then
-       tools/buildman/buildman -sdeP ${BUILDMAN};
-       exit $ret;
-     fi;
-   fi
- # "not a_test_which_does_not_exist" is a dummy -k parameter which will
- # never prevent any test from running. That way, we can always pass
- # "-k something" even when $TEST_PY_TEST_SPEC doesnt need a custom
- # value.
- - if [[ "${TEST_PY_BD}" != "" ]]; then
-     ./test/py/test.py --bd ${TEST_PY_BD} ${TEST_PY_ID}
-       -k "${TEST_PY_TEST_SPEC:-not a_test_which_does_not_exist}"
-       --build-dir `cd .. && pwd`/.bm-work/${TEST_PY_BD};
-   fi
-
-matrix:
-  include:
-  # we need to build by vendor due to 50min time limit for builds
-  # each env setting here is a dedicated build
-    - env:
-        - BUILDMAN="arm11"
-    - env:
-        - BUILDMAN="arm7"
-    - env:
-        - BUILDMAN="arm920t"
-    - env:
-        - JOB="arm926ejs"
-          BUILDMAN="arm926ejs -x mx,siemens,atmel"
-    - env:
-        - BUILDMAN="arm946es"
-    - env:
-        - BUILDMAN="atmel -x avr32"
-    - env:
-        - BUILDMAN="avr32"
-          TOOLCHAIN="avr32"
-    - env:
-        - BUILDMAN="denx"
-    - env:
-        - JOB="Freescale ARM"
-          BUILDMAN="freescale -x powerpc,m68k"
-    - env:
-        - JOB="i.MX (non-Freescale)"
-          BUILDMAN="mx -x freescale"
-    - env:
-        - BUILDMAN="sun4i"
-    - env:
-        - BUILDMAN="sun5i"
-    - env:
-        - BUILDMAN="sun6i"
-    - env:
-        - BUILDMAN="sun7i"
-    - env:
-        - BUILDMAN="sun8i"
-    - env:
-        - BUILDMAN="sun9i"
-    - env:
-        - BUILDMAN="sun50i"
-    - env:
-        - JOB="Catch-all ARM"
-          BUILDMAN="arm -x arm11,arm7,arm9,aarch64,atmel,denx,freescale,kirkwood,siemens,tegra,uniphier,mx,sunxi,am33xx,omap3,omap4,omap5,pxa"
-    - env:
-        - BUILDMAN="sandbox x86"
-          TOOLCHAIN="x86_64"
-    - env:
-        - BUILDMAN="kirkwood"
-    - env:
-        - BUILDMAN="pxa"
-    - env:
-        - BUILDMAN="m68k"
-          TOOLCHAIN="m68k"
-    - env:
-        - BUILDMAN="microblaze"
-          TOOLCHAIN="microblaze"
-    - env:
-        - BUILDMAN="mips"
-          TOOLCHAIN="mips"
-    - env:
-        - BUILDMAN="mpc512x"
-    - env:
-        - BUILDMAN="mpc5xx"
-    - env:
-        - BUILDMAN="mpc5xxx"
-    - env:
-        - BUILDMAN="mpc8260"
-    - env:
-        - BUILDMAN="mpc83xx"
-    - env:
-        - BUILDMAN="mpc85xx -x freescale"
-    - env:
-        - BUILDMAN="mpc85xx -x t208xrdb -x t4qds -x t102* -x p1_p2_rdb_pc -x p1010rdb -x corenet_ds -x b4860qds -x sbc8548 -x bsc91*"
-    - env:
-        - BUILDMAN="t208xrdb t4qds t102*"
-    - env:
-        - BUILDMAN="p1_p2_rdb_pc p1010rdb"
-    - env:
-        - BUILDMAN="corenet_ds b4860qds sbc8548 bsc91*"
-    - env:
-        - BUILDMAN="mpc86xx"
-    - env:
-        - BUILDMAN="mpc8xx"
-    - env:
-        - BUILDMAN="siemens"
-    - env:
-        - BUILDMAN="tegra"
-    - env:
-        - JOB="am33xx"
-          BUILDMAN="am33xx -x siemens"
-    - env:
-        - BUILDMAN="omap3"
-    - env:
-        - BUILDMAN="omap4"
-    - env:
-        - BUILDMAN="omap5"
-    - env:
-        - BUILDMAN="uniphier"
-    - env:
-        - BUILDMAN="aarch64 -x tegra,freescale,uniphier,sunxi"
-          TOOLCHAIN="aarch64"
-    - env:
-        - BUILDMAN="sh4"
-          TOOLCHAIN="sh4"
-    - env:
-        - BUILDMAN="xtensa"
-          TOOLCHAIN="xtensa"
-
-    # QA jobs for code analytics
-    # static code analysis with cppcheck (we can add --enable=all later)
-    - env:
-        - JOB="cppcheck"
-      script:
-        - cppcheck --force --quiet --inline-suppr .
-    # search for TODO within source tree
-    - env:
-        - JOB="grep TODO"
-      script:
-        - grep -r TODO .
-    # search for FIXME within source tree
-    - env:
-        - JOB="grep FIXME HACK"
-      script:
-        - grep -r FIXME .
-    # search for HACK within source tree and ignore HACKKIT board
-      script:
-        - grep -r HACK . | grep -v HACKKIT
-    # some statistics about the code base
-    - env:
-        - JOB="sloccount"
-      script:
-        - sloccount .
-
-    # test/py
-    - env:
-        - TEST_PY_BD="sandbox"
-          BUILDMAN="^sandbox$"
-          TOOLCHAIN="x86_64"
-    - env:
-        - TEST_PY_BD="vexpress_ca15_tc2"
-          TEST_PY_ID="--id qemu"
-          BUILDMAN="^vexpress_ca15_tc2$"
-    - env:
-        - TEST_PY_BD="vexpress_ca9x4"
-          TEST_PY_ID="--id qemu"
-          BUILDMAN="^vexpress_ca9x4$"
-    - env:
-        - TEST_PY_BD="integratorcp_cm926ejs"
-          TEST_PY_ID="--id qemu"
-          BUILDMAN="^integratorcp_cm926ejs$"
-    - env:
-        - TEST_PY_BD="qemu_mips"
-          TEST_PY_TEST_SPEC="not sleep"
-          BUILDMAN="^qemu_mips$"
-          TOOLCHAIN="mips"
-    - env:
-        - TEST_PY_BD="qemu_mipsel"
-          TEST_PY_TEST_SPEC="not sleep"
-          BUILDMAN="^qemu_mipsel$"
-          TOOLCHAIN="mips"
-    - env:
-        - TEST_PY_BD="qemu_mips64"
-          TEST_PY_TEST_SPEC="not sleep"
-          BUILDMAN="^qemu_mips64$"
-          TOOLCHAIN="mips"
-    - env:
-        - TEST_PY_BD="qemu_mips64el"
-          TEST_PY_TEST_SPEC="not sleep"
-          BUILDMAN="^qemu_mips64el$"
-          TOOLCHAIN="mips"
-    - env:
-        - TEST_PY_BD="qemu-ppce500"
-          TEST_PY_TEST_SPEC="not sleep"
-          BUILDMAN="^qemu-ppce500$"
-    - env:
-        - TEST_PY_BD="qemu-x86"
-          TEST_PY_TEST_SPEC="not sleep"
-          BUILDMAN="^qemu-x86$"
-          TOOLCHAIN="x86_64"
-          BUILD_ROM="yes"
-
-# TODO make it perfect ;-r
